;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	F900B9FB3AF29CF139B3E43E15C287E9
; Input	CRC32 :	2C55775E

; ---------------------------------------------------------------------------
; File Name   :	C:\compspace\compare\pidgin\dlls\full\libmeanwhile-1_full.dll
; Format      :	Portable executable for	80386 (PE)
; Imagebase   :	10000000
; Section 1. (virtual address 00001000)
; Virtual size			: 00019B18 ( 105240.)
; Section size in file		: 00019C00 ( 105472.)
; Offset to raw	data for section: 00000400
; Flags	60500020: Text Executable Readable
; Alignment	: 16 bytes

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	para public 'CODE' use32
		assume cs:_text
		;org 10001000h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	eax, [ebp+8]
		push	offset dword_10021010
		push	offset Memory
		push	eax
		call	__dllonexit
		leave
		retn
; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10001020	proc near		; CODE XREF: sub_10001200+50p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 0Ch
		mov	edx, [ebp+arg_0]
		push	offset dword_10021010
		push	offset Memory
		push	edx
		call	__dllonexit
		add	esp, 10h
		cmp	eax, 1
		leave
		sbb	eax, eax
		retn
sub_10001020	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10001050	proc near		; CODE XREF: DllEntryPoint:loc_100010ECp

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	edx, ds:Memory
		test	edx, edx
		jz	short loc_1000109F
		mov	ecx, ds:dword_10021010
		lea	eax, [ecx-4]
		cmp	edx, eax
		ja	short loc_10001089
		lea	ebx, [ecx-8]

loc_10001071:				; CODE XREF: sub_10001050+37j
		mov	eax, [ebx+4]
		test	eax, eax
		jz	short loc_10001080
		call	eax
		mov	edx, ds:Memory

loc_10001080:				; CODE XREF: sub_10001050+26j
		mov	eax, ebx
		sub	ebx, 4
		cmp	edx, eax
		jbe	short loc_10001071

loc_10001089:				; CODE XREF: sub_10001050+1Cj
		sub	esp, 0Ch
		push	edx		; Memory
		call	free
		mov	ds:Memory, 0
		add	esp, 10h

loc_1000109F:				; CODE XREF: sub_10001050+Fj
		sub	esp, 0Ch
		push	0		; File
		call	fflush
		add	esp, 10h
		mov	ebx, [ebp+var_4]
		leave
		retn
sub_10001050	endp

; ---------------------------------------------------------------------------
		jmp	short DllEntryPoint
; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
		public DllEntryPoint
DllEntryPoint	proc near		; CODE XREF: .text:100010B1j

hinstDLL	= dword	ptr  8
fdwReason	= dword	ptr  0Ch
lpReserved	= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		mov	ebx, [ebp+fdwReason]
		cmp	ebx, 1
		jz	short loc_10001100
		push	eax
		mov	eax, [ebp+lpReserved]
		push	eax
		push	ebx
		mov	esi, [ebp+hinstDLL]
		push	esi
		call	sub_1001AA00
		test	ebx, ebx
		mov	esi, eax
		pop	ecx
		jnz	short loc_100010F1
		mov	eax, ds:Memory
		test	eax, eax
		jz	short loc_10001150

loc_100010EC:				; CODE XREF: DllEntryPoint+83j
		call	sub_10001050

loc_100010F1:				; CODE XREF: DllEntryPoint+21j
					; DllEntryPoint+AAj
		lea	esp, [ebp-8]
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	ebp
		retn	0Ch
; ---------------------------------------------------------------------------
		align 10h

loc_10001100:				; CODE XREF: DllEntryPoint+Bj
		sub	esp, 0Ch
		push	80h		; Size
		call	malloc
		add	esp, 10h
		mov	ds:Memory, eax
		test	eax, eax
		jz	short loc_1000115D
		mov	dword ptr [eax], 0
		mov	ds:dword_10021010, eax
		call	sub_1001AA10
		call	sub_10001200
		push	edx
		mov	eax, [ebp+lpReserved]
		push	eax
		push	1
		mov	eax, [ebp+hinstDLL]
		push	eax
		call	sub_1001AA00
		mov	esi, eax
		pop	eax
		test	esi, esi
		jz	short loc_100010EC
		lea	esp, [ebp-8]
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	ebp
		retn	0Ch
; ---------------------------------------------------------------------------

loc_10001150:				; CODE XREF: DllEntryPoint+2Aj
		xor	esi, esi
		lea	esp, [ebp-8]
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	ebp
		retn	0Ch
; ---------------------------------------------------------------------------

loc_1000115D:				; CODE XREF: DllEntryPoint+57j
		call	_errno
		xor	esi, esi
		mov	dword ptr [eax], 0Ch
		jmp	short loc_100010F1
DllEntryPoint	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10001170	proc near		; CODE XREF: sub_10001200+26p
		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, dword_1001B064
		test	eax, eax
		jz	short locret_100011BA
		sub	esp, 0Ch
		push	offset ModuleName ; "libgcj_s.dll"
		call	GetModuleHandleA
		mov	edx, eax
		add	esp, 0Ch
		mov	eax, 0
		test	edx, edx
		jz	short loc_100011A9
		push	eax
		push	eax
		push	offset ProcName	; "_Jv_RegisterClasses"
		push	edx		; hModule
		call	GetProcAddress
		pop	edx
		pop	ecx

loc_100011A9:				; CODE XREF: sub_10001170+28j
		test	eax, eax
		jz	short locret_100011BA
		sub	esp, 0Ch
		push	offset dword_1001B064
		call	eax
		add	esp, 10h

locret_100011BA:			; CODE XREF: sub_10001170+Dj
					; sub_10001170+3Bj
		leave
		retn
sub_10001170	endp

; ---------------------------------------------------------------------------
		align 10h
		push	ebp
		mov	ebp, esp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100011D0	proc near		; DATA XREF: sub_10001200+4Bo
		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, off_1001B004
		mov	eax, [eax]
		test	eax, eax
		jz	short locret_100011F6

loc_100011E1:				; CODE XREF: sub_100011D0+24j
		call	eax
		mov	eax, off_1001B004
		add	eax, 4
		mov	off_1001B004, eax
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_100011E1

locret_100011F6:			; CODE XREF: sub_100011D0+Fj
		leave
		retn
sub_100011D0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10001200	proc near		; CODE XREF: DllEntryPoint+69p
		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		mov	ecx, dword_1001B000
		test	ecx, ecx
		jz	short loc_10001216
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10001216:				; CODE XREF: sub_10001200+Dj
		mov	ebx, ds:dword_1001AB08
		mov	dword_1001B000,	1
		call	sub_10001170
		cmp	ebx, 0FFFFFFFFh
		jz	short loc_1000125F

loc_10001230:				; CODE XREF: sub_10001200+73j
		test	ebx, ebx
		jz	short loc_10001248
		lea	esi, dword_1001AB08[ebx*4]
		nop
		lea	esi, [esi+0]

loc_10001240:				; CODE XREF: sub_10001200+46j
		call	dword ptr [esi]
		sub	esi, 4
		dec	ebx
		jnz	short loc_10001240

loc_10001248:				; CODE XREF: sub_10001200+32j
		sub	esp, 0Ch
		push	offset sub_100011D0
		call	sub_10001020
		add	esp, 10h
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000125F:				; CODE XREF: sub_10001200+2Ej
		xor	ebx, ebx
		jmp	short loc_10001265
; ---------------------------------------------------------------------------

loc_10001263:				; CODE XREF: sub_10001200+71j
		mov	ebx, eax

loc_10001265:				; CODE XREF: sub_10001200+61j
		lea	eax, [ebx+1]
		mov	edx, ds:dword_1001AB08[eax*4]
		test	edx, edx
		jnz	short loc_10001263
		jmp	short loc_10001230
sub_10001200	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10001280	proc near		; CODE XREF: sub_10001700+26p
					; sub_10001700+62p ...
		push	ebp
		cmp	eax, 5		; switch 6 cases
		mov	ebp, esp
		mov	edx, offset aUnknown ; "UNKNOWN"
		ja	short loc_100012A0 ; jumptable 1000128D	default	case
		jmp	ds:off_1001C074[eax*4] ; switch	jump
; ---------------------------------------------------------------------------

loc_10001294:				; CODE XREF: sub_10001280+Dj
					; DATA XREF: .rdata:off_1001C074o
		mov	edx, offset aNew ; jumptable 1000128D case 0
		lea	esi, [esi+0]

loc_100012A0:				; CODE XREF: sub_10001280+Bj
		pop	ebp		; jumptable 1000128D default case
		mov	eax, edx
		retn
; ---------------------------------------------------------------------------

loc_100012A4:				; CODE XREF: sub_10001280+Dj
					; DATA XREF: .rdata:off_1001C074o
		pop	ebp		; jumptable 1000128D case 5
		mov	edx, offset aError ; "error"
		mov	eax, edx
		retn
; ---------------------------------------------------------------------------

loc_100012AD:				; CODE XREF: sub_10001280+Dj
					; DATA XREF: .rdata:off_1001C074o
		pop	ebp		; jumptable 1000128D case 1
		mov	edx, offset aInitializing ; "initializing"
		mov	eax, edx
		retn
; ---------------------------------------------------------------------------

loc_100012B6:				; CODE XREF: sub_10001280+Dj
					; DATA XREF: .rdata:off_1001C074o
		pop	ebp		; jumptable 1000128D case 2
		mov	edx, offset aWaiting ; "waiting"
		mov	eax, edx
		retn
; ---------------------------------------------------------------------------

loc_100012BF:				; CODE XREF: sub_10001280+Dj
					; DATA XREF: .rdata:off_1001C074o
		pop	ebp		; jumptable 1000128D case 3
		mov	edx, offset aOpen ; "open"
		mov	eax, edx
		retn
; ---------------------------------------------------------------------------

loc_100012C8:				; CODE XREF: sub_10001280+Dj
					; DATA XREF: .rdata:off_1001C074o
		pop	ebp		; jumptable 1000128D case 4
		mov	edx, offset aClosing ; "closing"
		mov	eax, edx
		retn
sub_10001280	endp

; ---------------------------------------------------------------------------
		jmp	short mwChannel_getState
; ---------------------------------------------------------------------------
		align 10h
; Exported entry  62. mwChannel_getState

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_getState
mwChannel_getState proc	near		; CODE XREF: .text:100012D1j
					; mwChannel_recvAccept+160p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_100012F2
		mov	eax, [eax+4]
		leave
		retn
; ---------------------------------------------------------------------------

loc_100012F2:				; CODE XREF: mwChannel_getState+Bj
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_gets ; "mwChannel_getState"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 6
		leave
		retn
mwChannel_getState endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  52. mwChannel_getCipherInstance

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_getCipherInstance
mwChannel_getCipherInstance proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10001332
		mov	eax, [eax+5Ch]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10001332:				; CODE XREF: mwChannel_getCipherInstance+Bj
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_getc ; "mwChannel_getCipherInstance"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwChannel_getCipherInstance endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  50. mwChannel_getAddtlAccept

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_getAddtlAccept
mwChannel_getAddtlAccept proc near	; CODE XREF: sub_10011730+2A6p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10001372
		leave
		add	eax, 4Ch
		retn
; ---------------------------------------------------------------------------

loc_10001372:				; CODE XREF: mwChannel_getAddtlAccept+Bj
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_geta ; "mwChannel_getAddtlAccept"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwChannel_getAddtlAccept endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  51. mwChannel_getAddtlCreate

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_getAddtlCreate
mwChannel_getAddtlCreate proc near	; CODE XREF: mwConference_open+CEp
					; mwFileTransfer_offer+13Ep ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_100013B2
		leave
		add	eax, 44h
		retn
; ---------------------------------------------------------------------------

loc_100013B2:				; CODE XREF: mwChannel_getAddtlCreate+Bj
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_ge_0 ; "mwChannel_getAddtlCreate"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwChannel_getAddtlCreate endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  65. mwChannel_getUser

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_getUser
mwChannel_getUser proc near		; CODE XREF: sub_10004130+10p
					; mwFileTransfer_offer+B4p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_100013F2
		leave
		add	eax, 8
		retn
; ---------------------------------------------------------------------------

loc_100013F2:				; CODE XREF: mwChannel_getUser+Bj
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_getu ; "mwChannel_getUser"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwChannel_getUser endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  77. mwChannel_setOptions

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_setOptions
mwChannel_setOptions proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000143B
		cmp	dword ptr [eax+4], 1
		jnz	short loc_10001459
		mov	edx, [ebp+arg_4]
		mov	[eax+40h], edx
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000143B:				; CODE XREF: mwChannel_setOptions+Bj
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_seto ; "mwChannel_setOptions"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
; ---------------------------------------------------------------------------

loc_10001459:				; CODE XREF: mwChannel_setOptions+11j
		mov	[esp+18h+var_10], offset aChanStateMwcha ; "chan->state	== mwChannel_INIT"
		mov	[esp+18h+var_14], offset aMwchannel_seto ; "mwChannel_setOptions"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwChannel_setOptions endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  55. mwChannel_getOptions

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_getOptions
mwChannel_getOptions proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10001492
		mov	eax, [eax+40h]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10001492:				; CODE XREF: mwChannel_getOptions+Bj
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_geto ; "mwChannel_getOptions"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwChannel_getOptions endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  53. mwChannel_getEncryptPolicy

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_getEncryptPolicy
mwChannel_getEncryptPolicy proc	near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_100014D3
		movzx	eax, word ptr [eax+5Ah]
		leave
		retn
; ---------------------------------------------------------------------------

loc_100014D3:				; CODE XREF: mwChannel_getEncryptPolicy+Bj
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_gete ; "mwChannel_getEncryptPolicy"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwChannel_getEncryptPolicy endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  79. mwChannel_setProtoVer

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_setProtoVer
mwChannel_setProtoVer proc near		; CODE XREF: sub_1000C3F0+47p
					; mwConference_open+91p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000151B
		cmp	dword ptr [eax+4], 1
		jnz	short loc_10001539
		mov	edx, [ebp+arg_4]
		mov	[eax+3Ch], edx
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000151B:				; CODE XREF: mwChannel_setProtoVer+Bj
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_setp ; "mwChannel_setProtoVer"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
; ---------------------------------------------------------------------------

loc_10001539:				; CODE XREF: mwChannel_setProtoVer+11j
		mov	[esp+18h+var_10], offset aChanStateMwcha ; "chan->state	== mwChannel_INIT"
		mov	[esp+18h+var_14], offset aMwchannel_setp ; "mwChannel_setProtoVer"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwChannel_setProtoVer endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  57. mwChannel_getProtoVer

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_getProtoVer
mwChannel_getProtoVer proc near		; CODE XREF: sub_10011730+41p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10001572
		mov	eax, [eax+3Ch]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10001572:				; CODE XREF: mwChannel_getProtoVer+Bj
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_getp ; "mwChannel_getProtoVer"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwChannel_getProtoVer endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  78. mwChannel_setProtoType

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_setProtoType
mwChannel_setProtoType proc near	; CODE XREF: sub_1000C3F0+37p
					; mwConference_open+81p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_100015BB
		cmp	dword ptr [eax+4], 1
		jnz	short loc_100015D9
		mov	edx, [ebp+arg_4]
		mov	[eax+38h], edx
		leave
		retn
; ---------------------------------------------------------------------------

loc_100015BB:				; CODE XREF: mwChannel_setProtoType+Bj
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_se_0 ; "mwChannel_setProtoType"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
; ---------------------------------------------------------------------------

loc_100015D9:				; CODE XREF: mwChannel_setProtoType+11j
		mov	[esp+18h+var_10], offset aChanStateMwcha ; "chan->state	== mwChannel_INIT"
		mov	[esp+18h+var_14], offset aMwchannel_se_0 ; "mwChannel_setProtoType"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwChannel_setProtoType endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  56. mwChannel_getProtoType

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_getProtoType
mwChannel_getProtoType proc near	; CODE XREF: sub_10011730+36p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10001612
		mov	eax, [eax+38h]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10001612:				; CODE XREF: mwChannel_getProtoType+Bj
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_ge_1 ; "mwChannel_getProtoType"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwChannel_getProtoType endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  60. mwChannel_getServiceId

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_getServiceId
mwChannel_getServiceId proc near	; CODE XREF: sub_10011730+2Bp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10001652
		mov	eax, [eax+34h]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10001652:				; CODE XREF: mwChannel_getServiceId+Bj
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_ge_2 ; "mwChannel_getServiceId"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwChannel_getServiceId endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  61. mwChannel_getSession

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_getSession
mwChannel_getSession proc near		; CODE XREF: mwService_recv+38p
					; mwService_recvDestroy+38p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10001691
		mov	eax, [eax]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10001691:				; CODE XREF: mwChannel_getSession+Bj
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_ge_3 ; "mwChannel_getSession"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwChannel_getSession endp

; ---------------------------------------------------------------------------
		jmp	short mwChannel_getId
; ---------------------------------------------------------------------------
		align 10h
; Exported entry  54. mwChannel_getId

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_getId
mwChannel_getId	proc near		; CODE XREF: .text:100016B1j
					; mwChannel_recvAccept+34p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_100016D2
		mov	eax, [eax+30h]
		leave
		retn
; ---------------------------------------------------------------------------

loc_100016D2:				; CODE XREF: mwChannel_getId+Bj
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_geti ; "mwChannel_getId"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwChannel_getId	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10001700	proc near		; CODE XREF: mwChannel_recvDestroy+33p
					; sub_10001E60+12p ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		test	eax, eax
		mov	[ebp+var_8], ebx
		mov	ebx, eax
		mov	[ebp+var_4], esi
		mov	esi, ecx
		jz	loc_10001798
		cmp	[eax+4], edx
		jz	short loc_10001756
		test	ecx, ecx
		mov	[eax+4], edx
		jz	short loc_10001760
		mov	eax, edx
		call	sub_10001280
		mov	[esp+28h+var_14], esi
		mov	[esp+28h+var_18], eax
		mov	eax, [ebx+30h]
		mov	[esp+28h+var_20], offset aChannel0x08xSt ; "channel 0x%08x state: %s (0x%08x)"
		mov	[esp+28h+var_24], 20h
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		mov	[esp+28h+var_1C], eax
		call	g_log

loc_10001756:				; CODE XREF: sub_10001700+1Bj
					; sub_10001700+B4j
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10001760:				; CODE XREF: sub_10001700+22j
		mov	eax, edx
		call	sub_10001280
		mov	[esp+28h+var_18], eax
		mov	eax, [ebx+30h]
		mov	[esp+28h+var_20], offset aChannel0x08x_0 ; "channel 0x%08x state: %s"
		mov	[esp+28h+var_24], 20h
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		mov	[esp+28h+var_1C], eax
		call	g_log
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10001798:				; CODE XREF: sub_10001700+12j
		mov	[esp+28h+var_20], offset aChanNull ; "chan != NULL"
		mov	[esp+28h+var_24], offset aState	; "state"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10001756
sub_10001700	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  74. mwChannel_selectCipherInstance

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_selectCipherInstance
mwChannel_selectCipherInstance proc near ; CODE	XREF: mwChannel_recvAccept+137p
					; mwChannel_recvAccept+18Cp ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 20h
		mov	esi, [ebp+arg_0]
		mov	eax, [ebp+arg_4]
		test	esi, esi
		jz	loc_100018C3
		mov	edx, [esi+54h]
		test	edx, edx
		jz	loc_100018E1
		test	eax, eax
		mov	[esi+5Ch], eax
		jz	loc_10001898
		mov	[esp+28h+var_28], eax
		call	mwCipherInstance_getCipher
		mov	ebx, eax
		mov	[esp+28h+var_28], eax
		call	mwCipher_getType
		movzx	eax, ax
		mov	[esp+28h+var_24], eax
		mov	eax, [esi+54h]
		mov	[esp+28h+var_28], eax
		call	g_hash_table_steal
		mov	[esp+28h+var_28], ebx
		call	mwCipher_getType
		test	ax, ax
		jz	short loc_10001884
		sub	ax, 1
		jz	short loc_10001890
		mov	word ptr [esi+5Ah], 1

loc_10001829:				; CODE XREF: mwChannel_selectCipherInstance+CAj
					; mwChannel_selectCipherInstance+D6j
		mov	[esp+28h+var_28], ebx
		call	mwCipher_getName
		mov	edx, offset aNull ; "(null)"
		test	eax, eax
		jz	short loc_10001844
		mov	[esp+28h+var_28], ebx
		call	mwCipher_getName
		mov	edx, eax

loc_10001844:				; CODE XREF: mwChannel_selectCipherInstance+78j
		mov	[esp+28h+var_18], edx
		mov	eax, [esi+30h]
		mov	[esp+28h+var_20], offset aChannel0x08xSe ; "channel 0x%08x selected cipher %s"
		mov	[esp+28h+var_24], 20h
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		mov	[esp+28h+var_1C], eax
		call	g_log

loc_1000186B:				; CODE XREF: mwChannel_selectCipherInstance+101j
		mov	eax, [esi+54h]
		mov	[esp+28h+var_28], eax
		call	g_hash_table_destroy
		mov	dword ptr [esi+54h], 0

loc_1000187D:				; CODE XREF: mwChannel_selectCipherInstance+11Fj
					; mwChannel_selectCipherInstance+13Dj
		add	esp, 20h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10001884:				; CODE XREF: mwChannel_selectCipherInstance+5Bj
		mov	word ptr [esi+5Ah], 1000h
		jmp	short loc_10001829
; ---------------------------------------------------------------------------
		align 10h

loc_10001890:				; CODE XREF: mwChannel_selectCipherInstance+61j
		mov	word ptr [esi+5Ah], 2000h
		jmp	short loc_10001829
; ---------------------------------------------------------------------------

loc_10001898:				; CODE XREF: mwChannel_selectCipherInstance+26j
		mov	eax, [esi+30h]
		mov	word ptr [esi+5Ah], 0
		mov	[esp+28h+var_20], offset aChannel0x08x_1 ; "channel 0x%08x selected no cipher"
		mov	[esp+28h+var_24], 20h
		mov	[esp+28h+var_1C], eax
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_log
		jmp	short loc_1000186B
; ---------------------------------------------------------------------------

loc_100018C3:				; CODE XREF: mwChannel_selectCipherInstance+10j
		mov	[esp+28h+var_20], offset aChanNull ; "chan != NULL"
		mov	[esp+28h+var_24], offset aMwchannel_sele ; "mwChannel_selectCipherInstance"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000187D
; ---------------------------------------------------------------------------

loc_100018E1:				; CODE XREF: mwChannel_selectCipherInstance+1Bj
		mov	[esp+28h+var_20], offset aChanSupportedN ; "chan->supported != NULL"
		mov	[esp+28h+var_24], offset aMwchannel_sele ; "mwChannel_selectCipherInstance"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000187D
mwChannel_selectCipherInstance endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  64. mwChannel_getSupportedCipherInstances

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_getSupportedCipherInstances
mwChannel_getSupportedCipherInstances proc near	; CODE XREF: mwChannel_accept+F8p
					; mwChannel_create+8Bp

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	edx, [ebp+arg_0]
		mov	[ebp+var_4], 0
		test	edx, edx
		jz	short loc_10001943
		lea	eax, [ebp+var_4]
		mov	[esp+28h+var_20], eax
		mov	[esp+28h+var_24], offset sub_10001970
		mov	eax, [edx+54h]
		mov	[esp+28h+var_28], eax
		call	g_hash_table_foreach
		mov	eax, [ebp+var_4]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10001943:				; CODE XREF: mwChannel_getSupportedCipherInstances+12j
		mov	[esp+28h+var_20], offset aChanNull ; "chan != NULL"
		mov	[esp+28h+var_24], offset aMwchannel_ge_4 ; "mwChannel_getSupportedCipherInstances"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwChannel_getSupportedCipherInstances endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10001970	proc near		; DATA XREF: mwChannel_getSupportedCipherInstances+1Bo

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_8]
		mov	eax, [ebp+arg_4]
		mov	[esp+18h+var_14], eax
		mov	eax, [ebx]
		mov	[esp+18h+var_18], eax
		call	g_list_append
		mov	[ebx], eax
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
sub_10001970	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100019A0	proc near		; CODE XREF: mwChannel_addSupportedCipherInstance+6Ej
					; mwChannel_populateSupportedCipherInstances+39p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[esp+18h+var_18], edx
		mov	[ebp+var_8], ebx
		mov	ebx, edx
		mov	[ebp+var_4], esi
		mov	esi, eax
		call	mwCipherInstance_getCipher
		mov	[esp+18h+var_18], eax
		call	mwCipher_getType
		mov	[esp+18h+var_10], ebx
		movzx	eax, ax
		mov	[esp+18h+var_14], eax
		mov	eax, [esi+54h]
		mov	[esp+18h+var_18], eax
		call	g_hash_table_insert
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
sub_100019A0	endp

; Exported entry  46. mwChannel_addSupportedCipherInstance

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_addSupportedCipherInstance
mwChannel_addSupportedCipherInstance proc near ; CODE XREF: mwChannel_recvCreate+177p

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 20h
		mov	ebx, [ebp+arg_0]
		mov	esi, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_10001A53
		mov	[esp+28h+var_28], esi
		call	mwCipherInstance_getCipher
		mov	[esp+28h+var_28], eax
		call	mwCipher_getName
		mov	edx, offset aNull ; "(null)"
		test	eax, eax
		jz	short loc_10001A1D
		mov	[esp+28h+var_28], esi
		call	mwCipherInstance_getCipher
		mov	[esp+28h+var_28], eax
		call	mwCipher_getName
		mov	edx, eax

loc_10001A1D:				; CODE XREF: mwChannel_addSupportedCipherInstance+29j
		mov	[esp+28h+var_18], edx
		mov	eax, [ebx+30h]
		mov	[esp+28h+var_20], offset aChannel0x08xAd ; "channel 0x%08x added cipher	%s"
		mov	[esp+28h+var_24], 20h
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		mov	[esp+28h+var_1C], eax
		call	g_log
		add	esp, 20h
		mov	edx, esi
		mov	eax, ebx
		pop	ebx
		pop	esi
		pop	ebp
		jmp	sub_100019A0
; ---------------------------------------------------------------------------

loc_10001A53:				; CODE XREF: mwChannel_addSupportedCipherInstance+10j
		mov	[esp+28h+var_20], offset aChanNull ; "chan != NULL"
		mov	[esp+28h+var_24], offset aMwchannel_adds ; "mwChannel_addSupportedCipherInstance"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		add	esp, 20h
		pop	ebx
		pop	esi
		pop	ebp
		retn
mwChannel_addSupportedCipherInstance endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10001A80	proc near		; CODE XREF: sub_10001DA0+34p
					; sub_10001E60+2Cp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[esp+18h+var_10], ecx
		mov	[esp+18h+var_14], edx
		mov	eax, [eax+60h]
		mov	[esp+18h+var_18], eax
		call	g_hash_table_insert
		leave
		retn
sub_10001A80	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  68. mwChannel_populateSupportedCipherInstances

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_populateSupportedCipherInstances
mwChannel_populateSupportedCipherInstances proc	near ; CODE XREF: mwFileTransfer_offer+ACp
					; sub_10011460+7Cp ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_0]
		test	esi, esi
		jz	short loc_10001AEC
		mov	eax, [esi]
		test	eax, eax
		jz	short loc_10001B0A
		mov	[esp+18h+var_18], eax
		call	mwSession_getCiphers
		test	eax, eax
		mov	ebx, eax
		jz	short loc_10001AE5

loc_10001AC3:				; CODE XREF: mwChannel_populateSupportedCipherInstances+43j
		mov	[esp+18h+var_14], esi
		mov	eax, [ebx]
		mov	[esp+18h+var_18], eax
		call	mwCipher_newInstance
		test	eax, eax
		jz	short loc_10001ADE
		mov	edx, eax
		mov	eax, esi
		call	sub_100019A0

loc_10001ADE:				; CODE XREF: mwChannel_populateSupportedCipherInstances+33j
		mov	ebx, [ebx+4]
		test	ebx, ebx
		jnz	short loc_10001AC3

loc_10001AE5:				; CODE XREF: mwChannel_populateSupportedCipherInstances+21j
					; mwChannel_populateSupportedCipherInstances+68j ...
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10001AEC:				; CODE XREF: mwChannel_populateSupportedCipherInstances+Dj
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_popu ; "mwChannel_populateSupportedCipherInstan"...
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10001AE5
; ---------------------------------------------------------------------------

loc_10001B0A:				; CODE XREF: mwChannel_populateSupportedCipherInstances+13j
		mov	[esp+18h+var_10], offset aSessionNull ;	"session != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_popu ; "mwChannel_populateSupportedCipherInstan"...
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10001AE5
mwChannel_populateSupportedCipherInstances endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  58. mwChannel_getService

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_getService
mwChannel_getService proc near		; CODE XREF: mwChannel_recvDestroy+3Bp
					; sub_10001DA0+16p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	edx, [ebp+arg_0]
		test	edx, edx
		jz	short loc_10001B50
		mov	eax, [edx+34h]
		mov	[esp+18h+var_14], eax
		mov	eax, [edx]
		mov	[esp+18h+var_18], eax
		call	mwSession_getService
		leave
		retn
; ---------------------------------------------------------------------------

loc_10001B50:				; CODE XREF: mwChannel_getService+Bj
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_ge_5 ; "mwChannel_getService"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwChannel_getService endp

; Exported entry  72. mwChannel_recvDestroy

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_recvDestroy
mwChannel_recvDestroy proc near		; CODE XREF: sub_10009A60+650p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	ebx, [ebp+arg_0]
		mov	esi, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_10001BF1
		test	esi, esi
		jz	loc_10001C14
		mov	eax, [ebx+30h]
		cmp	eax, [esi+4]
		jnz	loc_10001C32
		mov	ecx, [esi+10h]
		mov	eax, ebx
		cmp	ecx, 1
		sbb	edx, edx
		add	edx, 5
		call	sub_10001700
		mov	[esp+18h+var_18], ebx
		call	mwChannel_getService
		test	eax, eax
		jz	short loc_10001BC4
		mov	[esp+18h+var_10], esi
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+var_18], eax
		call	mwService_recvDestroy

loc_10001BC4:				; CODE XREF: mwChannel_recvDestroy+42j
		mov	eax, [ebx]
		mov	[esp+18h+var_18], eax
		call	mwSession_getChannels
		test	eax, eax
		jz	short loc_10001C50
		mov	edx, [eax+4]
		test	edx, edx
		jz	loc_10001C6E
		mov	eax, [ebx+30h]
		mov	[ebp+arg_0], edx
		mov	[ebp+arg_4], eax
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	g_hash_table_remove
; ---------------------------------------------------------------------------

loc_10001BF1:				; CODE XREF: mwChannel_recvDestroy+10j
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_recv ; "mwChannel_recvDestroy"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning

loc_10001C0D:				; CODE XREF: mwChannel_recvDestroy+C0j
					; mwChannel_recvDestroy+DEj ...
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10001C14:				; CODE XREF: mwChannel_recvDestroy+14j
		mov	[esp+18h+var_10], offset aMsgNull ; "msg != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_recv ; "mwChannel_recvDestroy"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10001C0D
; ---------------------------------------------------------------------------

loc_10001C32:				; CODE XREF: mwChannel_recvDestroy+20j
		mov	[esp+18h+var_10], offset aChanIdMsgHead_ ; "chan->id ==	msg->head.channel"
		mov	[esp+18h+var_14], offset aMwchannel_recv ; "mwChannel_recvDestroy"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10001C0D
; ---------------------------------------------------------------------------

loc_10001C50:				; CODE XREF: mwChannel_recvDestroy+60j
		mov	[esp+18h+var_10], offset aCsNull ; "cs != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_recv ; "mwChannel_recvDestroy"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10001C0D
; ---------------------------------------------------------------------------

loc_10001C6E:				; CODE XREF: mwChannel_recvDestroy+67j
		mov	[esp+18h+var_10], offset aCsMapNull ; "cs->map != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_recv ; "mwChannel_recvDestroy"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10001C0D
mwChannel_recvDestroy endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  49. mwChannel_find

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_find
mwChannel_find	proc near		; CODE XREF: sub_10009A60+425p
					; sub_10009A60+4A6p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	eax, eax
		jz	short loc_10001CB3
		mov	eax, [eax+4]
		test	eax, eax
		jz	short loc_10001CD3
		mov	[ebp+arg_4], edx
		mov	[ebp+arg_0], eax
		leave
		jmp	g_hash_table_lookup
; ---------------------------------------------------------------------------

loc_10001CB3:				; CODE XREF: mwChannel_find+Ej
		mov	[esp+18h+var_10], offset aCsNull ; "cs != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_find ; "mwChannel_find"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning

locret_10001CCF:			; CODE XREF: mwChannel_find+5Fj
		leave
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_10001CD3:				; CODE XREF: mwChannel_find+15j
		mov	[esp+18h+var_10], offset aCsMapNull ; "cs->map != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_find ; "mwChannel_find"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short locret_10001CCF
mwChannel_find	endp

; ---------------------------------------------------------------------------
		jmp	short sub_10001D00
; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10001D00	proc near		; CODE XREF: .text:10001CF1j
					; mwChannel_recvAccept+112p ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		movzx	edx, dx
		mov	ebp, esp
		sub	esp, 8
		mov	[esp+8+var_4], edx
		mov	eax, [eax+54h]
		mov	[esp+8+var_8], eax
		call	g_hash_table_lookup
		leave
		retn
sub_10001D00	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10001D20	proc near		; CODE XREF: mwChannel_getStatistic+18j
					; sub_10001DA0+25p

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[esp+8+var_4], edx
		mov	eax, [eax+60h]
		mov	[esp+8+var_8], eax
		call	g_hash_table_lookup
		leave
		retn
sub_10001D20	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  63. mwChannel_getStatistic

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_getStatistic
mwChannel_getStatistic proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	eax, eax
		jz	short loc_10001D5A
		mov	ecx, [eax+60h]
		test	ecx, ecx
		jz	short loc_10001D7A
		leave
		jmp	short sub_10001D20
; ---------------------------------------------------------------------------

loc_10001D5A:				; CODE XREF: mwChannel_getStatistic+Ej
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_ge_6 ; "mwChannel_getStatistic"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning

locret_10001D76:			; CODE XREF: mwChannel_getStatistic+56j
		leave
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_10001D7A:				; CODE XREF: mwChannel_getStatistic+15j
		mov	[esp+18h+var_10], offset aChanStatsNull	; "chan->stats != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_ge_6 ; "mwChannel_getStatistic"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short locret_10001D76
mwChannel_getStatistic endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10001DA0	proc near		; CODE XREF: sub_10001E60+4Cp
					; mwChannel_recv+C0j

var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	[esp+38h+var_38], eax
		mov	[ebp+var_8], esi
		mov	esi, eax
		mov	[ebp+var_4], edi
		mov	edi, edx
		mov	[ebp+var_C], ebx
		call	mwChannel_getService
		mov	edx, 1
		mov	[ebp+var_20], eax
		mov	eax, esi
		call	sub_10001D20
		mov	edx, 1
		lea	ecx, [eax+1]
		mov	eax, esi
		call	sub_10001A80
		test	byte ptr [edi+3], 40h
		jz	short loc_10001E40
		lea	ebx, [ebp+var_14]
		lea	eax, [edi+14h]
		mov	[esp+38h+var_34], eax
		mov	[ebp+var_14], 0
		mov	[ebp+var_10], 0
		mov	[esp+38h+var_38], ebx
		call	mwOpaque_clone
		mov	eax, [esi+5Ch]
		mov	[esp+38h+var_34], ebx
		mov	[esp+38h+var_38], eax
		call	mwCipherInstance_decrypt
		movzx	eax, word ptr [edi+10h]
		mov	[esp+38h+var_2C], ebx
		mov	[esp+38h+var_34], esi
		mov	[esp+38h+var_30], eax
		mov	eax, [ebp+var_20]
		mov	[esp+38h+var_38], eax
		call	mwService_recv
		mov	[esp+38h+var_38], ebx
		call	mwOpaque_clear

loc_10001E31:				; CODE XREF: sub_10001DA0+BEj
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10001E40:				; CODE XREF: sub_10001DA0+3Dj
		lea	eax, [edi+14h]
		mov	[esp+38h+var_2C], eax
		movzx	eax, word ptr [edi+10h]
		mov	[esp+38h+var_34], esi
		mov	[esp+38h+var_30], eax
		mov	eax, [ebp+var_20]
		mov	[esp+38h+var_38], eax
		call	mwService_recv
		jmp	short loc_10001E31
sub_10001DA0	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10001E60	proc near		; CODE XREF: mwChannel_recvAccept+17Cj
					; mwChannel_accept+B5p

Time		= dword	ptr -18h
var_14		= dword	ptr -14h

		push	ebp
		xor	ecx, ecx
		mov	ebp, esp
		mov	edx, 3
		push	edi
		mov	edi, eax
		push	esi
		push	ebx
		sub	esp, 0Ch
		call	sub_10001700
		mov	[esp+18h+Time],	0 ; Time
		call	time
		mov	edx, 4
		mov	ecx, eax
		mov	eax, edi
		call	sub_10001A80
		mov	eax, [edi+68h]
		test	eax, eax
		mov	esi, eax
		jz	short loc_10001EC3
		lea	esi, [esi+0]

loc_10001EA0:				; CODE XREF: sub_10001E60+5Ej
		mov	ebx, [esi]
		mov	eax, edi
		mov	dword ptr [esi], 0
		mov	edx, ebx
		call	sub_10001DA0
		mov	[esp+18h+Time],	ebx
		call	mwMessage_free
		mov	esi, [esi+4]
		test	esi, esi
		jnz	short loc_10001EA0
		mov	eax, [edi+68h]

loc_10001EC3:				; CODE XREF: sub_10001E60+38j
		mov	[esp+18h+Time],	eax
		call	g_slist_free
		mov	eax, [edi+64h]
		mov	dword ptr [edi+68h], 0
		test	eax, eax
		mov	esi, eax
		jz	short loc_10001F08
		nop
		lea	esi, [esi+0]

loc_10001EE0:				; CODE XREF: sub_10001E60+A3j
		mov	ebx, [esi]
		mov	eax, [edi]
		mov	dword ptr [esi], 0
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+Time],	eax
		call	mwSession_send
		mov	[esp+18h+Time],	ebx
		call	mwMessage_free
		mov	esi, [esi+4]
		test	esi, esi
		jnz	short loc_10001EE0
		mov	eax, [edi+64h]

loc_10001F08:				; CODE XREF: sub_10001E60+79j
		mov	[esp+18h+Time],	eax
		call	g_slist_free
		mov	dword ptr [edi+64h], 0
		add	esp, 0Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
sub_10001E60	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  44. mwChannelSet_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannelSet_new
mwChannelSet_new proc near		; CODE XREF: mwSession_new+42p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	[esp+18h+var_18], 0Ch
		call	g_malloc0
		mov	[esp+18h+var_C], offset	sub_10001FC0
		mov	[esp+18h+var_10], 0
		mov	[esp+18h+var_14], offset loc_1001A918
		mov	[esp+18h+var_18], offset loc_1001A910
		mov	ebx, eax
		mov	eax, [ebp+arg_0]
		mov	[ebx], eax
		call	g_hash_table_new_full
		mov	[ebx+4], eax
		mov	eax, ebx
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
mwChannelSet_new endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10001F70	proc near		; DATA XREF: mwChannel_newIncoming+5Ao
		push	ebp
		mov	ebp, esp
		pop	ebp
		jmp	mwCipherInstance_free
sub_10001F70	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  43. mwChannelSet_free

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannelSet_free
mwChannelSet_free proc near		; CODE XREF: mwSession_free+6Cp

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_10001FB0
		mov	eax, [ebx+4]
		test	eax, eax
		jz	short loc_10001F9D
		mov	[esp+8+var_8], eax
		call	g_hash_table_destroy

loc_10001F9D:				; CODE XREF: mwChannelSet_free+13j
		mov	[ebp+arg_0], ebx
		add	esp, 4
		pop	ebx
		pop	ebp
		jmp	g_free
; ---------------------------------------------------------------------------
		align 10h

loc_10001FB0:				; CODE XREF: mwChannelSet_free+Cj
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
mwChannelSet_free endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10001FC0	proc near		; DATA XREF: mwChannelSet_new+13o

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_0]
		test	esi, esi
		jz	loc_10002090
		lea	eax, [esi+8]
		mov	[esp+18h+var_18], eax
		call	mwLoginInfo_clear
		lea	eax, [esi+44h]
		mov	[esp+18h+var_18], eax
		call	mwOpaque_clear
		lea	eax, [esi+4Ch]
		mov	[esp+18h+var_18], eax
		call	mwOpaque_clear
		mov	eax, [esi+54h]
		test	eax, eax
		jz	short loc_1000200A
		mov	[esp+18h+var_18], eax
		call	g_hash_table_destroy
		mov	dword ptr [esi+54h], 0

loc_1000200A:				; CODE XREF: sub_10001FC0+39j
		mov	eax, [esi+60h]
		test	eax, eax
		jz	short loc_10002020
		mov	[esp+18h+var_18], eax
		call	g_hash_table_destroy
		mov	dword ptr [esi+60h], 0

loc_10002020:				; CODE XREF: sub_10001FC0+4Fj
		mov	eax, [esi+5Ch]
		mov	[esp+18h+var_18], eax
		call	mwCipherInstance_free
		mov	eax, [esi+64h]
		test	eax, eax
		mov	ebx, eax
		jz	short loc_1000204E

loc_10002034:				; CODE XREF: sub_10001FC0+89j
		mov	eax, [ebx]
		mov	dword ptr [ebx], 0
		mov	[esp+18h+var_18], eax
		call	mwMessage_free
		mov	ebx, [ebx+4]
		test	ebx, ebx
		jnz	short loc_10002034
		mov	eax, [esi+64h]

loc_1000204E:				; CODE XREF: sub_10001FC0+72j
		mov	[esp+18h+var_18], eax
		call	g_slist_free
		mov	eax, [esi+68h]
		test	eax, eax
		mov	ebx, eax
		jz	short loc_1000207A
		nop

loc_10002060:				; CODE XREF: sub_10001FC0+B5j
		mov	eax, [ebx]
		mov	dword ptr [ebx], 0
		mov	[esp+18h+var_18], eax
		call	mwMessage_free
		mov	ebx, [ebx+4]
		test	ebx, ebx
		jnz	short loc_10002060
		mov	eax, [esi+68h]

loc_1000207A:				; CODE XREF: sub_10001FC0+9Dj
		mov	[esp+18h+var_18], eax
		call	g_slist_free
		mov	[ebp+arg_0], esi
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	g_free
; ---------------------------------------------------------------------------

loc_10002090:				; CODE XREF: sub_10001FC0+Dj
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aChannel_free ; "channel_free"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
sub_10001FC0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  69. mwChannel_recv

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_recv
mwChannel_recv	proc near		; CODE XREF: sub_10009A60+4BDp

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_0]
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		cmp	dword ptr [edi+4], 3
		jz	loc_10002170
		mov	[esp+28h+var_28], 1Ch
		call	g_malloc0
		mov	ebx, eax
		movzx	eax, word ptr [esi]
		mov	[ebx], ax
		movzx	eax, word ptr [esi+2]
		mov	[ebx+2], ax
		mov	eax, [esi+4]
		mov	[ebx+4], eax
		lea	eax, [esi+8]
		mov	[esp+28h+var_24], eax
		lea	eax, [ebx+8]
		mov	[esp+28h+var_28], eax
		call	mwOpaque_clone
		movzx	eax, word ptr [esi+10h]
		mov	[ebx+10h], ax
		lea	eax, [esi+14h]
		mov	[esp+28h+var_24], eax
		lea	eax, [ebx+14h]
		mov	[esp+28h+var_28], eax
		call	mwOpaque_clone
		mov	eax, [edi+30h]
		mov	[esp+28h+var_20], offset aQueue_incoming ; "queue_incoming, channel 0x%08x"
		mov	[esp+28h+var_24], 40h
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		mov	[esp+28h+var_1C], eax
		call	g_log
		mov	[esp+28h+var_24], ebx
		mov	eax, [edi+68h]
		mov	[esp+28h+var_28], eax
		call	g_slist_append
		mov	[edi+68h], eax
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10002170:				; CODE XREF: mwChannel_recv+19j
		mov	ebx, [ebp+var_C]
		mov	edx, esi
		mov	eax, edi
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	sub_10001DA0
mwChannel_recv	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  48. mwChannel_destroy

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_destroy
mwChannel_destroy proc near		; CODE XREF: mwChannel_recvAccept+88p
					; mwChannel_recvAccept+1C9p ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	edi, [ebp+arg_0]
		test	edi, edi
		jz	loc_1000223C
		cmp	[ebp+arg_4], 1
		mov	eax, edi
		mov	ecx, [ebp+arg_4]
		sbb	edx, edx
		add	edx, 5
		call	sub_10001700
		mov	esi, [edi]
		test	esi, esi
		jz	loc_1000225C
		mov	[esp+28h+var_28], esi
		call	mwSession_getChannels
		test	eax, eax
		mov	[ebp+var_10], eax
		jz	loc_1000227F
		mov	[esp+28h+var_28], 3
		call	mwMessage_new
		mov	ebx, eax
		mov	eax, [edi+30h]
		mov	[ebx+4], eax
		mov	eax, [ebp+arg_4]
		mov	[ebx+10h], eax
		mov	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_10002207
		mov	edx, [ebp+arg_8]
		lea	eax, [ebx+14h]
		mov	[esp+28h+var_28], eax
		mov	[esp+28h+var_24], edx
		call	mwOpaque_clone

loc_10002207:				; CODE XREF: mwChannel_destroy+63j
		mov	eax, [edi+30h]
		mov	edx, [ebp+var_10]
		mov	[esp+28h+var_24], eax
		mov	eax, [edx+4]
		mov	[esp+28h+var_28], eax
		call	g_hash_table_remove
		mov	[esp+28h+var_28], esi
		mov	[esp+28h+var_24], ebx
		call	mwSession_send
		mov	[esp+28h+var_28], ebx
		mov	esi, eax
		call	mwMessage_free

loc_10002232:				; CODE XREF: mwChannel_destroy+CAj
					; mwChannel_destroy+EDj ...
		add	esp, 1Ch
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000223C:				; CODE XREF: mwChannel_destroy+Ej
		mov	[esp+28h+var_20], offset aChanNull ; "chan != NULL"
		xor	esi, esi
		mov	[esp+28h+var_24], offset aMwchannel_dest ; "mwChannel_destroy"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10002232
; ---------------------------------------------------------------------------

loc_1000225C:				; CODE XREF: mwChannel_destroy+2Bj
		mov	[esp+28h+var_20], offset aSessionNull ;	"session != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwchannel_dest ; "mwChannel_destroy"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10002232
; ---------------------------------------------------------------------------

loc_1000227F:				; CODE XREF: mwChannel_destroy+3Ej
		mov	[esp+28h+var_20], offset aCsNull ; "cs != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwchannel_dest ; "mwChannel_destroy"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10002232
mwChannel_destroy endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  70. mwChannel_recvAccept

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_recvAccept
mwChannel_recvAccept proc near		; CODE XREF: sub_10009A60+43Cp

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_C], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_4]
		mov	[ebp+var_4], edi
		test	ebx, ebx
		jz	loc_100024D7
		test	esi, esi
		jz	loc_100024F8
		mov	eax, [ebx+30h]
		cmp	eax, [esi+4]
		jnz	loc_10002519
		mov	[esp+28h+var_28], ebx
		call	mwChannel_getId
		test	eax, eax
		js	loc_10002443
		mov	eax, [ebx+4]
		cmp	eax, 2
		jz	short loc_10002350
		call	sub_10001280
		mov	[esp+28h+var_18], eax
		mov	eax, [ebx+30h]
		mov	[esp+28h+var_20], offset aChannel0x08x_2 ; "channel 0x%08x state not WAIT: %s"
		mov	[esp+28h+var_24], 10h
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		mov	[esp+28h+var_1C], eax
		call	g_log
		mov	[esp+28h+var_20], 0
		mov	[esp+28h+var_24], 80000001h
		mov	[esp+28h+var_28], ebx
		call	mwChannel_destroy

loc_1000233D:				; CODE XREF: mwChannel_recvAccept+168j
					; mwChannel_recvAccept+1CEj ...
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10002350:				; CODE XREF: mwChannel_recvAccept+47j
		lea	eax, [esi+28h]
		mov	[esp+28h+var_24], eax
		lea	eax, [ebx+8]
		mov	[esp+28h+var_28], eax
		call	mwLoginInfo_clone
		mov	eax, [ebx+34h]
		mov	[esp+28h+var_24], eax
		mov	eax, [ebx]
		mov	[esp+28h+var_28], eax
		call	mwSession_getService
		test	eax, eax
		mov	[ebp+var_10], eax
		jz	loc_10002483
		movzx	eax, word ptr [esi+4Ch]
		mov	[ebx+5Ah], ax
		mov	[esp+28h+var_1C], eax
		mov	[esp+28h+var_20], offset aChannelAccepte ; "channel accepted with encrypt policy 0x"...
		mov	[esp+28h+var_24], 20h
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_log
		cmp	word ptr [esi+4Ch], 0
		jz	loc_10002431
		mov	eax, [esi+50h]
		test	eax, eax
		jz	short loc_10002431
		movzx	eax, word ptr [eax]
		mov	[ebp+var_14], eax
		mov	edx, eax
		mov	eax, ebx
		call	sub_10001D00
		test	eax, eax
		mov	edi, eax
		jz	loc_100024C3
		mov	eax, [esi+50h]
		mov	[esp+28h+var_28], edi
		mov	[esp+28h+var_24], eax
		call	mwCipherInstance_accepted
		mov	[esp+28h+var_24], edi
		mov	[esp+28h+var_28], ebx
		call	mwChannel_selectCipherInstance

loc_100023EC:				; CODE XREF: mwChannel_recvAccept+191j
		xor	ecx, ecx
		mov	edx, 3
		mov	eax, ebx
		call	sub_10001700
		mov	[esp+28h+var_20], esi
		mov	[esp+28h+var_24], ebx
		mov	eax, [ebp+var_10]
		mov	[esp+28h+var_28], eax
		call	mwService_recvAccept
		mov	[esp+28h+var_28], ebx
		call	mwChannel_getState
		cmp	eax, 3
		jnz	loc_1000233D
		mov	esi, [ebp+var_8]
		mov	eax, ebx
		mov	edi, [ebp+var_4]
		mov	ebx, [ebp+var_C]
		mov	esp, ebp
		pop	ebp
		jmp	sub_10001E60
; ---------------------------------------------------------------------------

loc_10002431:				; CODE XREF: mwChannel_recvAccept+FBj
					; mwChannel_recvAccept+106j
		mov	[esp+28h+var_24], 0
		mov	[esp+28h+var_28], ebx
		call	mwChannel_selectCipherInstance
		jmp	short loc_100023EC
; ---------------------------------------------------------------------------

loc_10002443:				; CODE XREF: mwChannel_recvAccept+3Bj
		mov	eax, [ebx+30h]
		mov	[esp+28h+var_20], offset aChannel0x08xNo ; "channel 0x%08x not an outgoing channel"
		mov	[esp+28h+var_1C], eax

loc_10002452:				; CODE XREF: mwChannel_recvAccept+222j
		mov	[esp+28h+var_24], 10h
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_log
		mov	[esp+28h+var_20], 0
		mov	[esp+28h+var_24], 80000001h
		mov	[esp+28h+var_28], ebx
		call	mwChannel_destroy
		jmp	loc_1000233D
; ---------------------------------------------------------------------------

loc_10002483:				; CODE XREF: mwChannel_recvAccept+C8j
		mov	eax, [ebx+34h]
		mov	[esp+28h+var_20], offset aNoService0x08x ; "no service:	0x%08x"
		mov	[esp+28h+var_24], 10h
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		mov	[esp+28h+var_1C], eax
		call	g_log
		mov	[esp+28h+var_20], 0
		mov	[esp+28h+var_24], 8000000Dh
		mov	[esp+28h+var_28], ebx
		call	mwChannel_destroy
		jmp	loc_1000233D
; ---------------------------------------------------------------------------

loc_100024C3:				; CODE XREF: mwChannel_recvAccept+11Bj
		mov	eax, [ebp+var_14]
		mov	[esp+28h+var_20], offset aNotAnOfferedCi ; "not	an offered cipher: 0x%04x"
		mov	[esp+28h+var_1C], eax
		jmp	loc_10002452
; ---------------------------------------------------------------------------

loc_100024D7:				; CODE XREF: mwChannel_recvAccept+17j
		mov	[esp+28h+var_20], offset aChanNull ; "chan != NULL"
		mov	[esp+28h+var_24], offset aMwchannel_re_0 ; "mwChannel_recvAccept"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000233D
; ---------------------------------------------------------------------------

loc_100024F8:				; CODE XREF: mwChannel_recvAccept+1Fj
		mov	[esp+28h+var_20], offset aMsgNull ; "msg != NULL"
		mov	[esp+28h+var_24], offset aMwchannel_re_0 ; "mwChannel_recvAccept"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000233D
; ---------------------------------------------------------------------------

loc_10002519:				; CODE XREF: mwChannel_recvAccept+2Bj
		mov	[esp+28h+var_20], offset aChanIdMsgHead_ ; "chan->id ==	msg->head.channel"
		mov	[esp+28h+var_24], offset aMwchannel_re_0 ; "mwChannel_recvAccept"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000233D
mwChannel_recvAccept endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  71. mwChannel_recvCreate

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_recvCreate
mwChannel_recvCreate proc near		; CODE XREF: sub_10009A60+48Cp

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	loc_10002740
		mov	eax, [ebp+arg_4]
		test	eax, eax
		jz	loc_10002761
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+30h]
		mov	edx, [ebp+arg_4]
		cmp	eax, [edx+14h]
		jnz	loc_100027A3
		mov	eax, [ebp+arg_0]
		mov	eax, [eax]
		test	eax, eax
		mov	[ebp+var_10], eax
		jz	loc_10002782
		mov	edx, [ebp+arg_0]
		mov	[esp+28h+var_28], edx
		call	mwChannel_getId
		test	eax, eax
		js	short loc_100025D9
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+30h]
		mov	[esp+28h+var_20], offset aChannel0x08x_3 ; "channel 0x%08x not an incoming channel"
		mov	[esp+28h+var_24], 10h
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		mov	[esp+28h+var_1C], eax
		call	g_log
		mov	[esp+28h+var_20], 0
		mov	[esp+28h+var_24], 80000001h
		mov	eax, [ebp+arg_0]
		mov	[esp+28h+var_28], eax
		call	mwChannel_destroy

loc_100025D1:				; CODE XREF: mwChannel_recvCreate+1FBj
					; mwChannel_recvCreate+21Cj ...
		add	esp, 1Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100025D9:				; CODE XREF: mwChannel_recvCreate+4Ej
		mov	edx, [ebp+arg_4]
		movzx	eax, word ptr [edx+60h]
		mov	edx, [ebp+arg_0]
		mov	[edx+58h], ax
		movzx	eax, word ptr [edx+5Ah]
		mov	[esp+28h+var_20], offset aChannelOffered ; "channel offered with encrypt policy	0x%"...
		mov	[esp+28h+var_24], 20h
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		mov	[esp+28h+var_1C], eax
		call	g_log
		mov	eax, [ebp+arg_4]
		mov	edi, [eax+64h]
		test	edi, edi
		jnz	loc_100026C7

loc_10002619:				; CODE XREF: mwChannel_recvCreate+181j
		mov	eax, [ebp+arg_4]
		add	eax, 3Ch
		mov	[esp+28h+var_24], eax
		mov	eax, [ebp+arg_0]
		add	eax, 8
		mov	[esp+28h+var_28], eax
		call	mwLoginInfo_clone
		mov	edx, [ebp+arg_4]
		mov	eax, [edx+20h]
		mov	edx, [ebp+arg_0]
		mov	[edx+34h], eax
		mov	edx, [ebp+arg_4]
		mov	eax, [edx+24h]
		mov	edx, [ebp+arg_0]
		mov	[edx+38h], eax
		mov	edx, [ebp+arg_4]
		mov	eax, [edx+28h]
		mov	edx, [ebp+arg_0]
		mov	[edx+3Ch], eax
		mov	edx, [ebp+arg_4]
		mov	eax, [edx+20h]
		mov	[esp+28h+var_24], eax
		mov	eax, [ebp+var_10]
		mov	[esp+28h+var_28], eax
		call	mwSession_getService
		test	eax, eax
		jz	loc_10002720
		mov	edx, [ebp+arg_4]
		mov	[esp+28h+var_20], edx
		mov	edx, [ebp+arg_0]
		mov	[esp+28h+var_28], eax
		mov	[esp+28h+var_24], edx
		call	mwService_recvCreate
		add	esp, 1Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10002690:				; CODE XREF: mwChannel_recvCreate+1C0j
		mov	edx, [ebp+arg_0]
		mov	[esp+28h+var_28], eax
		mov	[esp+28h+var_24], edx
		call	mwCipher_newInstance
		mov	[esp+28h+var_24], esi
		mov	ebx, eax
		mov	[esp+28h+var_28], eax
		call	mwCipherInstance_offered
		mov	[esp+28h+var_24], ebx
		mov	eax, [ebp+arg_0]
		mov	[esp+28h+var_28], eax
		call	mwChannel_addSupportedCipherInstance

loc_100026BC:				; CODE XREF: mwChannel_recvCreate+1DEj
		mov	edi, [edi+4]
		test	edi, edi
		jz	loc_10002619

loc_100026C7:				; CODE XREF: mwChannel_recvCreate+D3j
		mov	esi, [edi]
		movzx	eax, word ptr [esi]
		mov	[esp+28h+var_20], offset aChannelOffer_0 ; "channel offered cipher id 0x%04x"
		mov	[esp+28h+var_24], 20h
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		mov	[esp+28h+var_1C], eax
		call	g_log
		movzx	eax, word ptr [esi]
		mov	[esp+28h+var_24], eax
		mov	edx, [ebp+var_10]
		mov	[esp+28h+var_28], edx
		call	mwSession_getCipher
		test	eax, eax
		jnz	short loc_10002690
		mov	[esp+28h+var_20], offset aNoSuchCipherFo ; "no such cipher found in session"
		mov	[esp+28h+var_24], 20h
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_log
		jmp	short loc_100026BC
; ---------------------------------------------------------------------------

loc_10002720:				; CODE XREF: mwChannel_recvCreate+12Cj
		mov	[esp+28h+var_20], 0
		mov	[esp+28h+var_24], 8000000Dh
		mov	eax, [ebp+arg_0]
		mov	[esp+28h+var_28], eax
		call	mwChannel_destroy
		jmp	loc_100025D1
; ---------------------------------------------------------------------------

loc_10002740:				; CODE XREF: mwChannel_recvCreate+Ej
		mov	[esp+28h+var_20], offset aChanNull ; "chan != NULL"
		mov	[esp+28h+var_24], offset aMwchannel_re_1 ; "mwChannel_recvCreate"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_100025D1
; ---------------------------------------------------------------------------

loc_10002761:				; CODE XREF: mwChannel_recvCreate+19j
		mov	[esp+28h+var_20], offset aMsgNull ; "msg != NULL"
		mov	[esp+28h+var_24], offset aMwchannel_re_1 ; "mwChannel_recvCreate"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_100025D1
; ---------------------------------------------------------------------------

loc_10002782:				; CODE XREF: mwChannel_recvCreate+3Bj
		mov	[esp+28h+var_20], offset aSessionNull ;	"session != NULL"
		mov	[esp+28h+var_24], offset aMwchannel_re_1 ; "mwChannel_recvCreate"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_100025D1
; ---------------------------------------------------------------------------

loc_100027A3:				; CODE XREF: mwChannel_recvCreate+2Bj
		mov	[esp+28h+var_20], offset aChanIdMsgChann ; "chan->id ==	msg->channel"
		mov	[esp+28h+var_24], offset aMwchannel_re_1 ; "mwChannel_recvCreate"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_100025D1
mwChannel_recvCreate endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  76. mwChannel_sendEncrypted

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_sendEncrypted
mwChannel_sendEncrypted	proc near	; CODE XREF: mwChannel_send+22p
					; mwConference_sendTyping+9Cp ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_C], ebx
		mov	[ebp+var_4], edi
		test	esi, esi
		jz	loc_100028AC
		mov	[esp+28h+var_28], 4
		call	mwMessage_new
		mov	ebx, eax
		mov	eax, [esi+30h]
		lea	edi, [ebx+14h]
		mov	[ebx+4], eax
		movzx	eax, [ebp+arg_4]
		mov	[ebx+10h], ax
		mov	eax, [ebp+arg_8]
		mov	[esp+28h+var_28], edi
		mov	[esp+28h+var_24], eax
		call	mwOpaque_clone
		mov	eax, [ebp+arg_C]
		test	eax, eax
		jnz	short loc_10002870

loc_1000281F:				; CODE XREF: mwChannel_sendEncrypted+A5j
		cmp	dword ptr [esi+4], 3
		jz	short loc_10002892

loc_10002825:				; CODE XREF: mwChannel_sendEncrypted+C0j
		mov	eax, [esi+30h]
		mov	[esp+28h+var_20], offset aQueue_outgoing ; "queue_outgoing, channel 0x%08x"
		mov	[esp+28h+var_24], 40h
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		mov	[esp+28h+var_1C], eax
		call	g_log
		mov	[esp+28h+var_24], ebx
		mov	eax, [esi+64h]
		mov	[esp+28h+var_28], eax
		call	g_slist_append
		mov	[esi+64h], eax
		xor	esi, esi

loc_1000285C:				; CODE XREF: mwChannel_sendEncrypted+DAj
					; mwChannel_sendEncrypted+FDj
		mov	eax, esi
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10002870:				; CODE XREF: mwChannel_sendEncrypted+4Dj
		mov	eax, [esi+5Ch]
		test	eax, eax
		jz	short loc_1000281F
		mov	word ptr [ebx+2], 4000h
		mov	[esp+28h+var_24], edi
		mov	eax, [esi+5Ch]
		mov	[esp+28h+var_28], eax
		call	mwCipherInstance_encrypt
		cmp	dword ptr [esi+4], 3
		jnz	short loc_10002825

loc_10002892:				; CODE XREF: mwChannel_sendEncrypted+53j
		mov	[esp+28h+var_24], ebx
		mov	eax, [esi]
		mov	[esp+28h+var_28], eax
		call	mwSession_send
		mov	[esp+28h+var_28], ebx
		mov	esi, eax
		call	mwMessage_free
		jmp	short loc_1000285C
; ---------------------------------------------------------------------------

loc_100028AC:				; CODE XREF: mwChannel_sendEncrypted+14j
		mov	[esp+28h+var_20], offset aChanNull ; "chan != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwchannel_send ; "mwChannel_sendEncrypted"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000285C
mwChannel_sendEncrypted	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  75. mwChannel_send

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_send
mwChannel_send	proc near		; CODE XREF: mwServiceAware_unsetAttribute+52p
					; sub_1000AEB0+43p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_8]
		mov	[esp+18h+var_C], 1
		mov	[esp+18h+var_10], eax
		mov	eax, [ebp+arg_4]
		mov	[esp+18h+var_14], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+18h+var_18], eax
		call	mwChannel_sendEncrypted
		leave
		retn
mwChannel_send	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  45. mwChannel_accept

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_accept
mwChannel_accept proc near		; CODE XREF: mwConference_accept+19p
					; mwFileTransfer_accept+72p ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	edi, [ebp+arg_0]
		test	edi, edi
		jz	loc_10002A66
		mov	[esp+28h+var_28], edi
		call	mwChannel_getId
		test	eax, eax
		jns	loc_10002A8C
		cmp	dword ptr [edi+4], 2
		jnz	loc_10002AB2
		mov	ebx, [edi]
		test	ebx, ebx
		jz	loc_10002AD8
		mov	[esp+28h+var_28], 6
		call	mwMessage_new
		mov	esi, eax
		mov	eax, [edi+30h]
		mov	[esi+4], eax
		mov	eax, [edi+34h]
		mov	[esi+10h], eax
		mov	eax, [edi+38h]
		mov	[esi+14h], eax
		mov	eax, [edi+3Ch]
		mov	[esi+18h], eax
		lea	eax, [edi+4Ch]
		mov	[esp+28h+var_24], eax
		lea	eax, [esi+1Ch]
		mov	[esp+28h+var_28], eax
		call	mwOpaque_clone
		mov	eax, [edi+5Ch]
		test	eax, eax
		jz	short loc_100029E0

loc_10002977:				; CODE XREF: mwChannel_accept+12Bj
					; mwChannel_accept+140j ...
		movzx	eax, word ptr [edi+5Ah]
		mov	[esi+4Ch], ax
		movzx	eax, word ptr [edi+58h]
		mov	[esi+54h], ax
		mov	eax, [edi+5Ch]
		test	eax, eax
		jz	short loc_10002999
		mov	[esp+28h+var_28], eax
		call	mwCipherInstance_accept
		mov	[esi+50h], eax

loc_10002999:				; CODE XREF: mwChannel_accept+8Cj
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], esi
		call	mwSession_send
		mov	[esp+28h+var_28], esi
		mov	ebx, eax
		call	mwMessage_free
		test	ebx, ebx
		jnz	short loc_100029C4
		mov	eax, edi
		call	sub_10001E60

loc_100029BA:				; CODE XREF: mwChannel_accept+187j
					; mwChannel_accept+1ADj ...
		add	esp, 1Ch
		mov	eax, ebx
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100029C4:				; CODE XREF: mwChannel_accept+B1j
		mov	eax, edi
		mov	ecx, ebx
		mov	edx, 5
		call	sub_10001700
		add	esp, 1Ch
		mov	eax, ebx
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_100029E0:				; CODE XREF: mwChannel_accept+75j
		movzx	eax, word ptr [edi+58h]
		cmp	ax, 1000h
		jz	short loc_10002A62
		cmp	ax, 2000h
		jz	short loc_10002A45
		test	ax, ax
		jz	short loc_10002A30
		mov	[esp+28h+var_28], edi
		call	mwChannel_getSupportedCipherInstances
		test	eax, eax
		nop
		jz	short loc_10002A30
		mov	ecx, eax
		jmp	short loc_10002A08
; ---------------------------------------------------------------------------

loc_10002A06:				; CODE XREF: mwChannel_accept+10Dj
		mov	ecx, edx

loc_10002A08:				; CODE XREF: mwChannel_accept+104j
		mov	edx, [ecx+4]
		test	edx, edx
		jnz	short loc_10002A06
		mov	ecx, [ecx]
		mov	[ebp+var_10], ecx
		mov	[esp+28h+var_28], eax
		call	g_list_free
		mov	eax, [ebp+var_10]
		mov	[esp+28h+var_28], edi
		mov	[esp+28h+var_24], eax
		call	mwChannel_selectCipherInstance
		jmp	loc_10002977
; ---------------------------------------------------------------------------

loc_10002A30:				; CODE XREF: mwChannel_accept+F3j
					; mwChannel_accept+100j
		mov	[esp+28h+var_24], 0
		mov	[esp+28h+var_28], edi
		call	mwChannel_selectCipherInstance
		jmp	loc_10002977
; ---------------------------------------------------------------------------

loc_10002A45:				; CODE XREF: mwChannel_accept+EEj
		mov	edx, 1

loc_10002A4A:				; CODE XREF: mwChannel_accept+164j
		mov	eax, edi
		call	sub_10001D00
		mov	[esp+28h+var_28], edi
		mov	[esp+28h+var_24], eax
		call	mwChannel_selectCipherInstance
		jmp	loc_10002977
; ---------------------------------------------------------------------------

loc_10002A62:				; CODE XREF: mwChannel_accept+E8j
		xor	edx, edx
		jmp	short loc_10002A4A
; ---------------------------------------------------------------------------

loc_10002A66:				; CODE XREF: mwChannel_accept+Ej
		mov	[esp+28h+var_20], offset aChanNull ; "chan != NULL"
		mov	ebx, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwchannel_acce ; "mwChannel_accept"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_100029BA
; ---------------------------------------------------------------------------

loc_10002A8C:				; CODE XREF: mwChannel_accept+1Ej
		mov	[esp+28h+var_20], offset aMwchannel_isin ; "mwChannel_isIncoming(chan)"
		mov	ebx, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwchannel_acce ; "mwChannel_accept"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_100029BA
; ---------------------------------------------------------------------------

loc_10002AB2:				; CODE XREF: mwChannel_accept+28j
		mov	[esp+28h+var_20], offset aChanStateMwc_0 ; "chan->state	== mwChannel_WAIT"
		mov	ebx, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwchannel_acce ; "mwChannel_accept"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_100029BA
; ---------------------------------------------------------------------------

loc_10002AD8:				; CODE XREF: mwChannel_accept+32j
		mov	[esp+28h+var_20], offset aSessionNull ;	"session != NULL"
		mov	ebx, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwchannel_acce ; "mwChannel_accept"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_100029BA
mwChannel_accept endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  47. mwChannel_create

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_create
mwChannel_create proc near		; CODE XREF: sub_1000C3F0+4Fp
					; mwConference_open+E2p ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	edi, [ebp+arg_0]
		test	edi, edi
		jz	loc_10002C68
		cmp	dword ptr [edi+4], 1
		jnz	loc_10002C45
		mov	[esp+28h+var_28], edi
		call	mwChannel_getId
		test	eax, eax
		js	loc_10002C22
		mov	[esp+28h+var_28], 2
		call	mwMessage_new
		mov	esi, eax
		mov	eax, [edi+30h]
		mov	[esi+14h], eax
		mov	eax, [edi+10h]
		mov	[esp+28h+var_28], eax
		call	g_strdup
		mov	[esi+18h], eax
		mov	eax, [edi+18h]
		mov	[esp+28h+var_28], eax
		call	g_strdup
		mov	[esi+1Ch], eax
		mov	eax, [edi+34h]
		mov	[esi+20h], eax
		mov	eax, [edi+38h]
		mov	[esi+24h], eax
		mov	eax, [edi+3Ch]
		mov	[esi+28h], eax
		mov	eax, [edi+40h]
		mov	[esi+2Ch], eax
		lea	eax, [edi+44h]
		mov	[esp+28h+var_24], eax
		lea	eax, [esi+30h]
		mov	[esp+28h+var_28], eax
		call	mwOpaque_clone
		mov	[esp+28h+var_28], edi
		call	mwChannel_getSupportedCipherInstances
		test	eax, eax
		mov	[ebp+var_10], eax
		jz	loc_10002C1A
		mov	ebx, eax
		lea	esi, [esi+0]

loc_10002BA0:				; CODE XREF: mwChannel_create+C1j
		mov	eax, [ebx]
		mov	[esp+28h+var_28], eax
		call	mwCipherInstance_offer
		mov	[esp+28h+var_24], eax
		mov	eax, [esi+64h]
		mov	[esp+28h+var_28], eax
		call	g_list_append
		mov	[esi+64h], eax
		mov	ebx, [ebx+4]
		test	ebx, ebx
		jnz	short loc_10002BA0
		mov	eax, [ebp+var_10]
		mov	word ptr [edi+58h], 1
		mov	[esp+28h+var_28], eax
		call	g_list_free

loc_10002BD4:				; CODE XREF: mwChannel_create+120j
		movzx	eax, word ptr [edi+58h]
		mov	[esi+60h], ax
		movzx	eax, word ptr [edi+58h]
		mov	[esi+68h], ax
		mov	[esp+28h+var_24], esi
		mov	eax, [edi]
		mov	[esp+28h+var_28], eax
		call	mwSession_send
		mov	[esp+28h+var_28], esi
		mov	ebx, eax
		call	mwMessage_free
		cmp	ebx, 1
		mov	ecx, ebx
		sbb	edx, edx
		mov	eax, edi
		and	edx, 0FFFFFFFDh
		add	edx, 5
		call	sub_10001700

loc_10002C10:				; CODE XREF: mwChannel_create+143j
					; mwChannel_create+166j ...
		add	esp, 1Ch
		mov	eax, ebx
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10002C1A:				; CODE XREF: mwChannel_create+95j
		mov	word ptr [edi+58h], 0
		jmp	short loc_10002BD4
; ---------------------------------------------------------------------------

loc_10002C22:				; CODE XREF: mwChannel_create+28j
		mov	[esp+28h+var_20], offset aMwchannel_isou ; "mwChannel_isOutgoing(chan)"
		mov	ebx, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwchannel_crea ; "mwChannel_create"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10002C10
; ---------------------------------------------------------------------------

loc_10002C45:				; CODE XREF: mwChannel_create+18j
		mov	[esp+28h+var_20], offset aChanStateMwcha ; "chan->state	== mwChannel_INIT"
		mov	ebx, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwchannel_crea ; "mwChannel_create"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10002C10
; ---------------------------------------------------------------------------

loc_10002C68:				; CODE XREF: mwChannel_create+Ej
		mov	[esp+28h+var_20], offset aChanNull ; "chan != NULL"
		mov	ebx, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwchannel_crea ; "mwChannel_create"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10002C10
mwChannel_create endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  73. mwChannel_removeServiceData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_removeServiceData
mwChannel_removeServiceData proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10002CA9
		add	eax, 6Ch
		mov	[ebp+arg_0], eax
		leave
		jmp	mw_datum_clear
; ---------------------------------------------------------------------------

loc_10002CA9:				; CODE XREF: mwChannel_removeServiceData+Bj
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_remo ; "mwChannel_removeServiceData"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwChannel_removeServiceData endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  81. mwChannel_setServiceData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_setServiceData
mwChannel_setServiceData proc near	; CODE XREF: mwFileTransfer_offer+171p
					; sub_10010050+DCp ...

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	edx, [ebp+arg_8]
		test	eax, eax
		jz	short loc_10002CF2
		add	eax, 6Ch
		mov	[ebp+arg_8], edx
		mov	[ebp+arg_4], ecx
		mov	[ebp+arg_0], eax
		pop	ebp
		jmp	mw_datum_set
; ---------------------------------------------------------------------------

loc_10002CF2:				; CODE XREF: mwChannel_setServiceData+Ej
		mov	[ebp+arg_8], offset aChanNull ;	"chan != NULL"
		mov	[ebp+arg_4], offset aMwchannel_sets ; "mwChannel_setServiceData"
		mov	[ebp+arg_0], offset aMeanwhile ; "meanwhile"
		pop	ebp
		jmp	g_return_if_fail_warning
mwChannel_setServiceData endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  59. mwChannel_getServiceData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_getServiceData
mwChannel_getServiceData proc near	; CODE XREF: sub_1000FE00+1Ep
					; sub_1000FE90+1Cp ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10002D29
		add	eax, 6Ch
		mov	[ebp+arg_0], eax
		leave
		jmp	mw_datum_get
; ---------------------------------------------------------------------------

loc_10002D29:				; CODE XREF: mwChannel_getServiceData+Bj
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_ge_7 ; "mwChannel_getServiceData"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwChannel_getServiceData endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  80. mwChannel_setService

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_setService
mwChannel_setService proc near		; CODE XREF: sub_1000C3F0+27p
					; mwConference_open+71p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_10002D7E
		test	eax, eax
		jz	short loc_10002D9C
		cmp	dword ptr [ebx+4], 1
		jnz	short loc_10002DBA
		mov	[esp+18h+var_18], eax
		xchg	ax, ax
		call	mwService_getType
		mov	[ebx+34h], eax

loc_10002D78:				; CODE XREF: mwChannel_setService+4Aj
					; mwChannel_setService+68j ...
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10002D7E:				; CODE XREF: mwChannel_setService+Fj
		mov	[esp+18h+var_10], offset aChanNull ; "chan != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_se_1 ; "mwChannel_setService"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10002D78
; ---------------------------------------------------------------------------

loc_10002D9C:				; CODE XREF: mwChannel_setService+13j
		mov	[esp+18h+var_10], offset aSrvcNull ; "srvc != NULL"
		mov	[esp+18h+var_14], offset aMwchannel_se_1 ; "mwChannel_setService"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10002D78
; ---------------------------------------------------------------------------

loc_10002DBA:				; CODE XREF: mwChannel_setService+19j
		mov	[esp+18h+var_10], offset aChanStateMwcha ; "chan->state	== mwChannel_INIT"
		mov	[esp+18h+var_14], offset aMwchannel_se_1 ; "mwChannel_setService"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10002D78
mwChannel_setService endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  66. mwChannel_newIncoming

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_newIncoming
mwChannel_newIncoming proc near		; CODE XREF: mwChannel_newOutgoing+39p
					; sub_10009A60+47Dp

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		test	esi, esi
		jz	loc_10002E91
		mov	edx, [esi]
		test	edx, edx
		jz	loc_10002EB1
		mov	[esp+28h+var_28], 74h
		call	g_malloc0
		mov	ebx, eax
		mov	dword ptr [eax+4], 0
		mov	eax, [esi]
		mov	[ebx+30h], edi
		mov	[ebx], eax
		mov	[esp+28h+var_24], offset loc_1001A918
		mov	[esp+28h+var_28], offset loc_1001A910
		call	g_hash_table_new
		mov	[ebx+60h], eax
		mov	[esp+28h+var_1C], offset sub_10001F70
		mov	[esp+28h+var_20], 0
		mov	[esp+28h+var_24], offset loc_1001A918
		mov	[esp+28h+var_28], offset loc_1001A910
		call	g_hash_table_new_full
		mov	[ebx+54h], eax
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_24], edi
		mov	eax, [esi+4]
		mov	[esp+28h+var_28], eax
		call	g_hash_table_insert
		xor	ecx, ecx
		mov	edx, 2
		mov	eax, ebx
		call	sub_10001700

loc_10002E82:				; CODE XREF: mwChannel_newIncoming+CFj
					; mwChannel_newIncoming+EFj
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10002E91:				; CODE XREF: mwChannel_newIncoming+17j
		mov	[esp+28h+var_20], offset aCsNull ; "cs != NULL"
		xor	ebx, ebx
		mov	[esp+28h+var_24], offset aMwchannel_newi ; "mwChannel_newIncoming"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10002E82
; ---------------------------------------------------------------------------

loc_10002EB1:				; CODE XREF: mwChannel_newIncoming+21j
		mov	[esp+28h+var_20], offset aCsSessionNull	; "cs->session != NULL"
		xor	ebx, ebx
		mov	[esp+28h+var_24], offset aMwchannel_newi ; "mwChannel_newIncoming"
		mov	[esp+28h+var_28], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10002E82
mwChannel_newIncoming endp

; ---------------------------------------------------------------------------
		jmp	short mwChannel_newOutgoing
; ---------------------------------------------------------------------------
		align 10h
; Exported entry  67. mwChannel_newOutgoing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwChannel_newOutgoing
mwChannel_newOutgoing proc near		; CODE XREF: .text:10002ED1j
					; sub_1000C3F0+19p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_0]
		test	esi, esi
		jz	short loc_10002F35
		mov	ecx, [esi+4]
		test	ecx, ecx
		jz	short loc_10002F55

loc_10002EF6:				; CODE XREF: mwChannel_newOutgoing+30j
		mov	ebx, [esi+8]
		add	ebx, 1
		mov	[esi+8], ebx
		mov	[esp+18h+var_14], ebx
		mov	eax, [esi+4]
		mov	[esp+18h+var_18], eax
		call	g_hash_table_lookup
		test	eax, eax
		jnz	short loc_10002EF6
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+var_18], esi
		call	mwChannel_newIncoming
		xor	ecx, ecx
		mov	edx, 1
		mov	ebx, eax
		call	sub_10001700

loc_10002F2C:				; CODE XREF: mwChannel_newOutgoing+73j
					; mwChannel_newOutgoing+93j
		add	esp, 10h
		mov	eax, ebx
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10002F35:				; CODE XREF: mwChannel_newOutgoing+Dj
		mov	[esp+18h+var_10], offset aCsNull ; "cs != NULL"
		xor	ebx, ebx
		mov	[esp+18h+var_14], offset aMwchannel_newo ; "mwChannel_newOutgoing"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10002F2C
; ---------------------------------------------------------------------------

loc_10002F55:				; CODE XREF: mwChannel_newOutgoing+14j
		mov	[esp+18h+var_10], offset aCsMapNull ; "cs->map != NULL"
		xor	ebx, ebx
		mov	[esp+18h+var_14], offset aMwchannel_newo ; "mwChannel_newOutgoing"
		mov	[esp+18h+var_18], offset aMeanwhile ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10002F2C
mwChannel_newOutgoing endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 172. mwIV_init

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwIV_init
mwIV_init	proc near		; CODE XREF: sub_10003650+29p
					; sub_10003650+37p ...

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	byte ptr [eax],	1
		mov	byte ptr [eax+1], 23h
		mov	byte ptr [eax+2], 45h
		mov	byte ptr [eax+3], 67h
		mov	byte ptr [eax+4], 89h
		mov	byte ptr [eax+5], 0ABh
		mov	byte ptr [eax+6], 0CDh
		mov	byte ptr [eax+7], 0EFh
		pop	ebp
		retn
mwIV_init	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10002FB0	proc near		; DATA XREF: mwCipher_new_RC2_40+1Do
		push	ebp
		mov	eax, offset aRc240Cipher ; "RC2/40 Cipher"
		mov	ebp, esp
		pop	ebp
		retn
sub_10002FB0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10002FC0	proc near		; DATA XREF: mwCipher_new_RC2_40+24o
		push	ebp
		mov	eax, offset aRc240BitEffect ; "RC2, 40-bit effective key"
		mov	ebp, esp
		pop	ebp
		retn
sub_10002FC0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10002FD0	proc near		; DATA XREF: mwCipher_new_RC2_128+31o
		push	ebp
		mov	eax, offset aRc2128Cipher ; "RC2/128 Cipher"
		mov	ebp, esp
		pop	ebp
		retn
sub_10002FD0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10002FE0	proc near		; DATA XREF: mwCipher_new_RC2_128+38o
		push	ebp
		mov	eax, offset aRc2DhSharedSec ; "RC2, DH shared secret key"
		mov	ebp, esp
		pop	ebp
		retn
sub_10002FE0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  86. mwCipherInstance_free

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwCipherInstance_free
mwCipherInstance_free proc near		; CODE XREF: sub_10001F70+4j
					; sub_10001FC0+66p

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_10003020
		mov	eax, [ebx]
		test	eax, eax
		jz	short loc_10003010
		mov	eax, [eax+30h]
		test	eax, eax
		jz	short loc_10003010
		mov	[esp+8+var_8], ebx
		call	eax

loc_10003010:				; CODE XREF: mwCipherInstance_free+12j
					; mwCipherInstance_free+19j
		mov	[ebp+arg_0], ebx
		add	esp, 4
		pop	ebx
		pop	ebp
		jmp	g_free
; ---------------------------------------------------------------------------
		align 10h

loc_10003020:				; CODE XREF: mwCipherInstance_free+Cj
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
mwCipherInstance_free endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  91. mwCipher_free

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwCipher_free
mwCipher_free	proc near

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_10003057
		mov	eax, [ebx+2Ch]
		test	eax, eax
		jz	short loc_1000304A
		mov	[esp+8+var_8], ebx
		call	eax

loc_1000304A:				; CODE XREF: mwCipher_free+13j
		mov	[ebp+arg_0], ebx
		add	esp, 4
		pop	ebx
		pop	ebp
		jmp	g_free
; ---------------------------------------------------------------------------

loc_10003057:				; CODE XREF: mwCipher_free+Cj
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
mwCipher_free	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  84. mwCipherInstance_decrypt

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwCipherInstance_decrypt
mwCipherInstance_decrypt proc near	; CODE XREF: sub_10001DA0+69p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_4]
		mov	edx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_100030BA
		xor	eax, eax
		test	edx, edx
		jz	short loc_100030B4
		mov	eax, [edx]
		test	eax, eax
		jz	short loc_10003093
		mov	ecx, [eax+28h]
		xor	eax, eax
		test	ecx, ecx
		jz	short loc_100030B4
		mov	[ebp+arg_4], ebx
		mov	[ebp+arg_0], edx
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	ecx
; ---------------------------------------------------------------------------

loc_10003093:				; CODE XREF: mwCipherInstance_decrypt+1Bj
		mov	[esp+18h+var_10], offset aCipherNull ; "cipher != NULL"
		mov	[esp+18h+var_14], offset aMwcipherinstan ; "mwCipherInstance_decrypt"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFFFFFh

loc_100030B4:				; CODE XREF: mwCipherInstance_decrypt+15j
					; mwCipherInstance_decrypt+24j	...
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100030BA:				; CODE XREF: mwCipherInstance_decrypt+Fj
		mov	[esp+18h+var_10], offset aDataNull ; "data != NULL"
		mov	[esp+18h+var_14], offset aMwcipherinstan ; "mwCipherInstance_decrypt"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		jmp	short loc_100030B4
mwCipherInstance_decrypt endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  85. mwCipherInstance_encrypt

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwCipherInstance_encrypt
mwCipherInstance_encrypt proc near	; CODE XREF: mwChannel_sendEncrypted+B7p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_4]
		mov	edx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_1000313A
		xor	eax, eax
		test	edx, edx
		jz	short loc_10003134
		mov	eax, [edx]
		test	eax, eax
		jz	short loc_10003113
		mov	ecx, [eax+24h]
		xor	eax, eax
		test	ecx, ecx
		jz	short loc_10003134
		mov	[ebp+arg_4], ebx
		mov	[ebp+arg_0], edx
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	ecx
; ---------------------------------------------------------------------------

loc_10003113:				; CODE XREF: mwCipherInstance_encrypt+1Bj
		mov	[esp+18h+var_10], offset aCipherNull ; "cipher != NULL"
		mov	[esp+18h+var_14], offset aMwcipherinst_0 ; "mwCipherInstance_encrypt"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFFFFFh

loc_10003134:				; CODE XREF: mwCipherInstance_encrypt+15j
					; mwCipherInstance_encrypt+24j	...
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000313A:				; CODE XREF: mwCipherInstance_encrypt+Fj
		mov	[esp+18h+var_10], offset aDataNull ; "data != NULL"
		mov	[esp+18h+var_14], offset aMwcipherinst_0 ; "mwCipherInstance_encrypt"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		jmp	short loc_10003134
mwCipherInstance_encrypt endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  82. mwCipherInstance_accept

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwCipherInstance_accept
mwCipherInstance_accept	proc near	; CODE XREF: mwChannel_accept+91p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000317C
		mov	edx, [eax]
		test	edx, edx
		jz	short loc_1000319C
		mov	[ebp+arg_0], eax
		mov	ecx, [edx+20h]
		leave
		jmp	ecx
; ---------------------------------------------------------------------------

loc_1000317C:				; CODE XREF: mwCipherInstance_accept+Bj
		mov	[esp+18h+var_10], offset aCiNull ; "ci != NULL"
		mov	[esp+18h+var_14], offset aMwcipherinst_1 ; "mwCipherInstance_accept"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning

locret_10003198:			; CODE XREF: mwCipherInstance_accept+58j
		leave
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1000319C:				; CODE XREF: mwCipherInstance_accept+11j
		mov	[esp+18h+var_10], offset aCipherNull ; "cipher != NULL"
		mov	[esp+18h+var_14], offset aMwcipherinst_1 ; "mwCipherInstance_accept"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short locret_10003198
mwCipherInstance_accept	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  83. mwCipherInstance_accepted

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwCipherInstance_accepted
mwCipherInstance_accepted proc near	; CODE XREF: mwChannel_recvAccept+12Bp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	edx, [ebp+arg_0]
		mov	ebx, [ebp+arg_4]
		test	edx, edx
		jz	short loc_100031EB
		mov	eax, [edx]
		test	eax, eax
		jz	short loc_1000320D
		mov	ecx, [eax+1Ch]
		test	ecx, ecx
		jz	short loc_10003207
		mov	[ebp+arg_4], ebx
		mov	[ebp+arg_0], edx
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	ecx
; ---------------------------------------------------------------------------

loc_100031EB:				; CODE XREF: mwCipherInstance_accepted+Fj
		mov	[esp+18h+var_10], offset aCiNull ; "ci != NULL"
		mov	[esp+18h+var_14], offset aMwcipherinst_2 ; "mwCipherInstance_accepted"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning

loc_10003207:				; CODE XREF: mwCipherInstance_accepted+1Cj
					; mwCipherInstance_accepted+69j
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000320D:				; CODE XREF: mwCipherInstance_accepted+15j
		mov	[esp+18h+var_10], offset aCipherNull ; "cipher != NULL"
		mov	[esp+18h+var_14], offset aMwcipherinst_2 ; "mwCipherInstance_accepted"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10003207
mwCipherInstance_accepted endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  89. mwCipherInstance_offer

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwCipherInstance_offer
mwCipherInstance_offer proc near	; CODE XREF: mwChannel_create+A5p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000324C
		mov	edx, [eax]
		test	edx, edx
		jz	short loc_1000326C
		mov	[ebp+arg_0], eax
		mov	ecx, [edx+18h]
		leave
		jmp	ecx
; ---------------------------------------------------------------------------

loc_1000324C:				; CODE XREF: mwCipherInstance_offer+Bj
		mov	[esp+18h+var_10], offset aCiNull ; "ci != NULL"
		mov	[esp+18h+var_14], offset aMwcipherinst_3 ; "mwCipherInstance_offer"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning

locret_10003268:			; CODE XREF: mwCipherInstance_offer+58j
		leave
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1000326C:				; CODE XREF: mwCipherInstance_offer+11j
		mov	[esp+18h+var_10], offset aCipherNull ; "cipher != NULL"
		mov	[esp+18h+var_14], offset aMwcipherinst_3 ; "mwCipherInstance_offer"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short locret_10003268
mwCipherInstance_offer endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  90. mwCipherInstance_offered

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwCipherInstance_offered
mwCipherInstance_offered proc near	; CODE XREF: mwChannel_recvCreate+168p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	edx, [ebp+arg_0]
		mov	ebx, [ebp+arg_4]
		test	edx, edx
		jz	short loc_100032BB
		mov	eax, [edx]
		test	eax, eax
		jz	short loc_100032DD
		mov	ecx, [eax+14h]
		test	ecx, ecx
		jz	short loc_100032D7
		mov	[ebp+arg_4], ebx
		mov	[ebp+arg_0], edx
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	ecx
; ---------------------------------------------------------------------------

loc_100032BB:				; CODE XREF: mwCipherInstance_offered+Fj
		mov	[esp+18h+var_10], offset aCiNull ; "ci != NULL"
		mov	[esp+18h+var_14], offset aMwcipherinst_4 ; "mwCipherInstance_offered"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning

loc_100032D7:				; CODE XREF: mwCipherInstance_offered+1Cj
					; mwCipherInstance_offered+69j
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100032DD:				; CODE XREF: mwCipherInstance_offered+15j
		mov	[esp+18h+var_10], offset aCipherNull ; "cipher != NULL"
		mov	[esp+18h+var_14], offset aMwcipherinst_4 ; "mwCipherInstance_offered"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100032D7
mwCipherInstance_offered endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  87. mwCipherInstance_getChannel

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwCipherInstance_getChannel
mwCipherInstance_getChannel proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10003312
		mov	eax, [eax+4]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10003312:				; CODE XREF: mwCipherInstance_getChannel+Bj
		mov	[esp+18h+var_10], offset aCiNull ; "ci != NULL"
		mov	[esp+18h+var_14], offset aMwcipherinst_5 ; "mwCipherInstance_getChannel"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwCipherInstance_getChannel endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  88. mwCipherInstance_getCipher

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwCipherInstance_getCipher
mwCipherInstance_getCipher proc	near	; CODE XREF: mwChannel_selectCipherInstance+2Fp
					; sub_100019A0+13p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10003351
		mov	eax, [eax]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10003351:				; CODE XREF: mwCipherInstance_getCipher+Bj
		mov	[esp+18h+var_10], offset aCiNull ; "ci != NULL"
		mov	[esp+18h+var_14], offset aMwcipherinst_6 ; "mwCipherInstance_getCipher"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwCipherInstance_getCipher endp

; ---------------------------------------------------------------------------
		jmp	short mwCipher_newInstance
; ---------------------------------------------------------------------------
		align 10h
; Exported entry  96. mwCipher_newInstance

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwCipher_newInstance
mwCipher_newInstance proc near		; CODE XREF: mwChannel_populateSupportedCipherInstances+2Cp
					; mwChannel_recvCreate+15Ap ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	eax, eax
		jz	short loc_100033A4
		test	edx, edx
		jz	short loc_100033C4
		mov	ecx, [eax+10h]
		test	ecx, ecx
		jz	short loc_100033E2
		mov	[ebp+arg_4], edx
		mov	[ebp+arg_0], eax
		leave
		jmp	ecx
; ---------------------------------------------------------------------------

loc_100033A4:				; CODE XREF: mwCipher_newInstance+Ej
		mov	[esp+18h+var_10], offset aCipherNull ; "cipher != NULL"
		mov	[esp+18h+var_14], offset aMwcipher_newin ; "mwCipher_newInstance"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning

locret_100033C0:			; CODE XREF: mwCipher_newInstance+60j
					; mwCipher_newInstance+7Ej
		leave
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_100033C4:				; CODE XREF: mwCipher_newInstance+12j
		mov	[esp+18h+var_10], offset aChanNull_0 ; "chan !=	NULL"
		mov	[esp+18h+var_14], offset aMwcipher_newin ; "mwCipher_newInstance"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short locret_100033C0
; ---------------------------------------------------------------------------

loc_100033E2:				; CODE XREF: mwCipher_newInstance+19j
		mov	[esp+18h+var_10], offset aCipherNew_inst ; "cipher->new_instance != NULL"
		mov	[esp+18h+var_14], offset aMwcipher_newin ; "mwCipher_newInstance"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short locret_100033C0
mwCipher_newInstance endp

; Exported entry  92. mwCipher_getDesc

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwCipher_getDesc
mwCipher_getDesc proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10003417
		mov	ecx, [eax+0Ch]
		test	ecx, ecx
		jz	short loc_10003437
		leave
		jmp	ecx
; ---------------------------------------------------------------------------

loc_10003417:				; CODE XREF: mwCipher_getDesc+Bj
		mov	[esp+18h+var_10], offset aCipherNull ; "cipher != NULL"
		mov	[esp+18h+var_14], offset aMwcipher_getde ; "mwCipher_getDesc"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning

locret_10003433:			; CODE XREF: mwCipher_getDesc+53j
		leave
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_10003437:				; CODE XREF: mwCipher_getDesc+12j
		mov	[esp+18h+var_10], offset aCipherGet_desc ; "cipher->get_desc !=	NULL"
		mov	[esp+18h+var_14], offset aMwcipher_getde ; "mwCipher_getDesc"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short locret_10003433
mwCipher_getDesc endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  93. mwCipher_getName

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwCipher_getName
mwCipher_getName proc near		; CODE XREF: mwChannel_selectCipherInstance+6Cp
					; mwChannel_selectCipherInstance+7Dp ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10003477
		mov	ecx, [eax+8]
		test	ecx, ecx
		jz	short loc_10003497
		leave
		jmp	ecx
; ---------------------------------------------------------------------------

loc_10003477:				; CODE XREF: mwCipher_getName+Bj
		mov	[esp+18h+var_10], offset aCipherNull ; "cipher != NULL"
		mov	[esp+18h+var_14], offset aMwcipher_getna ; "mwCipher_getName"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning

locret_10003493:			; CODE XREF: mwCipher_getName+53j
		leave
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_10003497:				; CODE XREF: mwCipher_getName+12j
		mov	[esp+18h+var_10], offset aCipherGet_name ; "cipher->get_name !=	NULL"
		mov	[esp+18h+var_14], offset aMwcipher_getna ; "mwCipher_getName"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short locret_10003493
mwCipher_getName endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  95. mwCipher_getType

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwCipher_getType
mwCipher_getType proc near		; CODE XREF: mwChannel_selectCipherInstance+39p
					; mwChannel_selectCipherInstance+53p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_100034D3
		movzx	eax, word ptr [eax+4]
		leave
		retn
; ---------------------------------------------------------------------------

loc_100034D3:				; CODE XREF: mwCipher_getType+Bj
		mov	[esp+18h+var_10], offset aCipherNull ; "cipher != NULL"
		mov	[esp+18h+var_14], offset aMwcipher_getty ; "mwCipher_getType"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFh
		leave
		retn
mwCipher_getType endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  94. mwCipher_getSession

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwCipher_getSession
mwCipher_getSession proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10003511
		mov	eax, [eax]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10003511:				; CODE XREF: mwCipher_getSession+Bj
		mov	[esp+18h+var_10], offset aCipherNull ; "cipher != NULL"
		mov	[esp+18h+var_14], offset aMwcipher_getse ; "mwCipher_getSession"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwCipher_getSession endp

; ---------------------------------------------------------------------------
		jmp	short mwKeyExpand
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 179. mwKeyExpand

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwKeyExpand
mwKeyExpand	proc near		; CODE XREF: .text:10003531j
					; mwEncrypt+21p ...

var_8C		= byte ptr -8Ch
var_8B		= byte ptr -8Bh
var_D		= byte ptr -0Dh
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		add	esp, 0FFFFFF80h
		mov	eax, [ebp+arg_8]
		mov	esi, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	eax, eax
		jz	loc_10003621
		test	edx, edx
		jz	loc_10003642
		cmp	eax, 80h
		mov	edi, 80h
		cmovbe	edi, eax
		test	edi, edi
		jz	loc_10003616
		lea	ebx, [ebp+var_8C]
		lea	ecx, [edx+edi]
		lea	edx, [ebx+edi]

loc_10003583:				; CODE XREF: mwKeyExpand+52j
		movzx	eax, byte ptr [ecx-1]
		sub	ecx, 1
		mov	[edx-1], al
		sub	edx, 1
		cmp	edx, ebx
		jnz	short loc_10003583
		cmp	edi, 80h
		jz	short loc_100035C2

loc_1000359C:				; CODE XREF: mwKeyExpand+DCj
		lea	edx, [edi+ebx-1]
		xor	ecx, ecx
		lea	edi, [ebp+var_D]

loc_100035A5:				; CODE XREF: mwKeyExpand+80j
		movzx	eax, byte ptr [edx]
		add	al, [ecx+ebx]
		add	ecx, 1
		movzx	eax, al
		movzx	eax, ds:byte_1001CA60[eax]
		mov	[edx+1], al
		add	edx, 1
		cmp	edx, edi
		jnz	short loc_100035A5

loc_100035C2:				; CODE XREF: mwKeyExpand+5Aj
		movzx	eax, [ebp+var_8C]
		mov	ecx, 4
		movzx	eax, ds:byte_1001CA60[eax]
		mov	[ebp+var_8C], al
		movzx	eax, [ebp+var_8B]
		movzx	edx, [ebp+var_8C]
		shl	eax, 8
		or	eax, edx
		mov	[esi], eax

loc_100035F0:				; CODE XREF: mwKeyExpand+CCj
		movzx	eax, byte ptr [ecx+ebx-1]
		movzx	edx, byte ptr [ecx+ebx-2]
		shl	eax, 8
		or	eax, edx
		mov	[esi+ecx*2-4], eax
		add	ecx, 2
		cmp	ecx, 82h
		jnz	short loc_100035F0
		sub	esp, 0FFFFFF80h
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10003616:				; CODE XREF: mwKeyExpand+31j
		lea	ebx, [ebp+var_8C]
		jmp	loc_1000359C
; ---------------------------------------------------------------------------

loc_10003621:				; CODE XREF: mwKeyExpand+14j
		mov	[ebp+arg_8], offset aKeylen0 ; "keylen > 0"

loc_10003628:				; CODE XREF: mwKeyExpand+109j
		mov	[ebp+arg_4], offset aMwkeyexpand ; "mwKeyExpand"
		mov	[ebp+arg_0], offset aMeanwhile_0 ; "meanwhile"
		sub	esp, 0FFFFFF80h
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_10003642:				; CODE XREF: mwKeyExpand+1Cj
		mov	[ebp+arg_8], offset aKeyNull ; "key != NULL"
		jmp	short loc_10003628
mwKeyExpand	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10003650	proc near		; DATA XREF: mwCipher_new_RC2_128+3Fo

var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	[esp+8+var_8], 118h
		call	g_malloc0
		mov	ebx, eax
		mov	eax, [ebp+arg_0]
		mov	[ebx], eax
		mov	eax, [ebp+arg_4]
		mov	[ebx+4], eax
		lea	eax, [ebx+110h]
		mov	[esp+8+var_8], eax
		call	mwIV_init
		lea	eax, [ebx+108h]
		mov	[esp+8+var_8], eax
		call	mwIV_init
		mov	eax, ebx
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
sub_10003650	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  98. mwCipher_new_RC2_40

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwCipher_new_RC2_40
mwCipher_new_RC2_40 proc near

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[esp+8+var_8], 138h
		call	g_malloc0
		mov	edx, [ebp+arg_0]
		mov	[eax], edx
		mov	word ptr [eax+4], 0
		mov	dword ptr [eax+8], offset sub_10002FB0
		mov	dword ptr [eax+0Ch], offset sub_10002FC0
		mov	dword ptr [eax+10h], offset sub_100041A0
		mov	dword ptr [eax+18h], offset sub_10003720
		mov	dword ptr [eax+1Ch], offset sub_10004130
		mov	dword ptr [eax+20h], offset sub_10004170
		mov	dword ptr [eax+24h], offset sub_10004070
		mov	dword ptr [eax+28h], offset sub_10004500
		leave
		retn
mwCipher_new_RC2_40 endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10003700	proc near		; CODE XREF: sub_10003720+7j
					; sub_10004170+21j

var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[esp+8+var_8], 0Ch
		call	g_malloc0
		mov	word ptr [eax],	0
		leave
		retn
sub_10003700	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10003720	proc near		; DATA XREF: mwCipher_new_RC2_40+32o

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		pop	ebp
		jmp	short sub_10003700
sub_10003720	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 193. mwMpi_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwMpi_new
mwMpi_new	proc near		; CODE XREF: sub_10009A60+25Dp
					; sub_10009A60+265p ...

var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	[esp+8+var_8], 10h
		call	g_malloc0
		mov	ebx, eax
		mov	[esp+8+var_8], eax
		call	mw_mp_init
		mov	eax, ebx
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
mwMpi_new	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 191. mwMpi_free

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwMpi_free
mwMpi_free	proc near		; CODE XREF: sub_10009A60+3B8p
					; sub_10009A60+3C3p ...

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_10003783
		mov	[esp+8+var_8], ebx
		call	mw_mp_clear
		mov	[ebp+arg_0], ebx
		add	esp, 4
		pop	ebx
		pop	ebp
		jmp	g_free
; ---------------------------------------------------------------------------

loc_10003783:				; CODE XREF: mwMpi_free+Cj
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
mwMpi_free	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10003790	proc near		; CODE XREF: mwMpi_import+15j
					; sub_10003FB0+46p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	ecx, [edx]
		mov	[esp+18h+var_10], ecx
		mov	edx, [edx+4]
		mov	[esp+18h+var_18], eax
		mov	[esp+18h+var_14], edx
		call	mw_mp_read_unsigned_bin
		leave
		retn
sub_10003790	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 192. mwMpi_import

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwMpi_import
mwMpi_import	proc near		; CODE XREF: sub_10009A60+2AAp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	eax, eax
		jz	short loc_100037C7
		test	edx, edx
		jz	short loc_100037E5
		leave
		jmp	short sub_10003790
; ---------------------------------------------------------------------------

loc_100037C7:				; CODE XREF: mwMpi_import+Ej
		mov	[esp+18h+var_10], offset aINull	; "i !=	NULL"
		mov	[esp+18h+var_14], offset aMwmpi_import ; "mwMpi_import"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
; ---------------------------------------------------------------------------

loc_100037E5:				; CODE XREF: mwMpi_import+12j
		mov	[esp+18h+var_10], offset aONull	; "o !=	NULL"
		mov	[esp+18h+var_14], offset aMwmpi_import ; "mwMpi_import"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwMpi_import	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 196. mwMpi_setDHPrime

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwMpi_setDHPrime
mwMpi_setDHPrime proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10003837
		mov	[esp+18h+var_10], 40h
		mov	[esp+18h+var_14], offset dword_1001B020
		mov	[esp+18h+var_18], eax
		call	mw_mp_read_unsigned_bin
		leave
		retn
; ---------------------------------------------------------------------------

loc_10003837:				; CODE XREF: mwMpi_setDHPrime+Bj
		mov	[esp+18h+var_10], offset aINull	; "i !=	NULL"
		mov	[esp+18h+var_14], offset aMwmpi_setdhpri ; "mwMpi_setDHPrime"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwMpi_setDHPrime endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10003860	proc near		; CODE XREF: sub_10003890+1Bp
					; sub_10003CA0+1Ap

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h

		push	ebp
		mov	ebp, esp
		push	ebx
		mov	ebx, eax
		sub	esp, 14h
		mov	[esp+18h+var_18], eax
		call	mw_mp_init
		mov	[esp+18h+var_18], ebx
		mov	[esp+18h+var_10], 40h
		mov	[esp+18h+var_14], offset dword_1001B020
		call	mw_mp_read_unsigned_bin
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
sub_10003860	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10003890	proc near		; CODE XREF: mwMpi_calculateDHShared+19j
					; sub_10003FB0+55p

var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_20		= dword	ptr -20h
var_1C		= byte ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	[ebp+var_C], ebx
		lea	ebx, [ebp+var_1C]
		mov	[ebp+var_8], esi
		mov	esi, eax
		mov	eax, ebx
		mov	[ebp+var_20], edx
		mov	[ebp+var_4], edi
		mov	edi, ecx
		call	sub_10003860
		mov	eax, [ebp+var_20]
		mov	[esp+38h+var_2C], esi
		mov	[esp+38h+var_30], ebx
		mov	[esp+38h+var_34], edi
		mov	[esp+38h+var_38], eax
		call	mw_mp_exptmod
		mov	[esp+38h+var_38], ebx
		call	mw_mp_clear
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
sub_10003890	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 189. mwMpi_calculateDHShared

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwMpi_calculateDHShared
mwMpi_calculateDHShared	proc near	; CODE XREF: sub_10009A60+2C3p

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		mov	ecx, [ebp+arg_8]
		test	eax, eax
		jz	short loc_100038FB
		test	edx, edx
		jz	short loc_10003916
		test	ecx, ecx
		jz	short loc_10003931
		pop	ebp
		jmp	short sub_10003890
; ---------------------------------------------------------------------------

loc_100038FB:				; CODE XREF: mwMpi_calculateDHShared+Ej
		mov	[ebp+arg_8], offset aShared_keyNull ; "shared_key != NULL"
		mov	[ebp+arg_4], offset aMwmpi_calculat ; "mwMpi_calculateDHShared"
		mov	[ebp+arg_0], offset aMeanwhile_0 ; "meanwhile"
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_10003916:				; CODE XREF: mwMpi_calculateDHShared+12j
		mov	[ebp+arg_8], offset aRemote_keyNull ; "remote_key != NULL"
		mov	[ebp+arg_4], offset aMwmpi_calculat ; "mwMpi_calculateDHShared"
		mov	[ebp+arg_0], offset aMeanwhile_0 ; "meanwhile"
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_10003931:				; CODE XREF: mwMpi_calculateDHShared+16j
		mov	[ebp+arg_8], offset aPrivate_keyNul ; "private_key != NULL"
		mov	[ebp+arg_4], offset aMwmpi_calculat ; "mwMpi_calculateDHShared"
		mov	[ebp+arg_0], offset aMeanwhile_0 ; "meanwhile"
		pop	ebp
		jmp	g_return_if_fail_warning
mwMpi_calculateDHShared	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 195. mwMpi_setDHBase

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwMpi_setDHBase
mwMpi_setDHBase	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000396F
		mov	[esp+18h+var_14], 3
		mov	[esp+18h+var_18], eax
		call	mw_mp_set_int
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000396F:				; CODE XREF: mwMpi_setDHBase+Bj
		mov	[esp+18h+var_10], offset aINull	; "i !=	NULL"
		mov	[esp+18h+var_14], offset aMwmpi_setdhbas ; "mwMpi_setDHBase"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwMpi_setDHBase	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 141. mwEncryptExpanded

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwEncryptExpanded
mwEncryptExpanded proc near		; CODE XREF: mwEncrypt+3Ep
					; sub_10003F50+36p ...

var_28		= dword	ptr -28h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	eax, [ebp+arg_8]
		mov	ebx, [ebp+arg_C]
		mov	esi, [eax]
		mov	edx, [eax+4]
		mov	ecx, esi
		and	ecx, 0FFFFFFF8h
		mov	edi, ecx
		add	edi, 8
		mov	[ebp+var_20], edx
		mov	[ebp+var_10], ecx
		mov	[esp+28h+var_28], edi
		call	g_malloc
		test	esi, esi
		mov	[ebx], edi
		mov	[ebx+4], eax
		mov	ebx, esi
		mov	[ebp+var_1C], eax
		jz	short loc_100039E5
		mov	ecx, [ebp+var_20]
		mov	edx, eax
		add	edx, esi
		add	ecx, esi

loc_100039D3:				; CODE XREF: mwEncryptExpanded+53j
		movzx	eax, byte ptr [ecx-1]
		sub	ecx, 1
		mov	[edx-1], al
		sub	edx, 1
		cmp	edx, [ebp+var_1C]
		jnz	short loc_100039D3

loc_100039E5:				; CODE XREF: mwEncryptExpanded+38j
		cmp	esi, edi
		jnb	short loc_100039FE
		mov	eax, edi
		mov	edx, esi
		sub	al, dl

loc_100039EF:				; CODE XREF: mwEncryptExpanded+6Cj
		mov	ecx, [ebp+var_1C]
		add	ebx, 1
		cmp	edi, ebx
		mov	[esi+ecx], al
		mov	esi, ebx
		ja	short loc_100039EF

loc_100039FE:				; CODE XREF: mwEncryptExpanded+57j
		test	edi, edi
		jle	loc_10003BCB

loc_10003A06:				; CODE XREF: mwEncryptExpanded+236j
		mov	edx, [ebp+arg_4]
		mov	ecx, [ebp+var_1C]
		movzx	eax, byte ptr [edx+7]
		mov	edx, 5
		xor	[ecx+7], al

loc_10003A18:				; CODE XREF: mwEncryptExpanded+9Dj
		mov	ecx, [ebp+arg_4]
		movzx	eax, byte ptr [edx+ecx+1]
		mov	ecx, [ebp+var_1C]
		xor	[edx+ecx+1], al
		sub	edx, 1
		cmp	edx, 0FFFFFFFEh
		jnz	short loc_10003A18
		movzx	edi, byte ptr [ecx+7]
		movzx	eax, byte ptr [ecx+6]
		movzx	esi, byte ptr [ecx+5]
		movzx	ebx, byte ptr [ecx+3]
		shl	edi, 8
		mov	edx, [ebp+arg_0]
		or	edi, eax
		movzx	eax, byte ptr [ecx+4]
		shl	esi, 8
		shl	ebx, 8
		or	esi, eax
		movzx	eax, byte ptr [ecx+2]
		or	ebx, eax
		mov	eax, [ebp+var_1C]
		movzx	ecx, byte ptr [eax+1]
		movzx	eax, byte ptr [eax]
		mov	[ebp+var_14], edx
		mov	[ebp+var_18], 0
		shl	ecx, 8
		or	ecx, eax
		jmp	short loc_10003A90
; ---------------------------------------------------------------------------

loc_10003A74:				; CODE XREF: mwEncryptExpanded+196j
		cmp	[ebp+var_18], 0Ah
		jz	loc_10003B2C
		add	[ebp+var_18], 1
		add	[ebp+var_14], 10h
		cmp	[ebp+var_18], 10h
		jz	loc_10003B61

loc_10003A90:				; CODE XREF: mwEncryptExpanded+E2j
					; mwEncryptExpanded+1CBj
		mov	eax, [ebp+var_14]
		mov	edx, edi
		and	edx, esi
		add	ecx, [eax]
		mov	eax, edi
		xor	eax, 0FFFFh
		and	eax, ebx
		lea	edx, [ecx+edx]
		add	edx, eax
		mov	ecx, edx
		add	edx, edx
		sar	ecx, 0Fh
		and	ecx, 1
		or	ecx, edx
		mov	edx, [ebp+var_14]
		mov	eax, ecx
		xor	eax, 0FFFFh
		and	eax, esi
		add	ebx, [edx+4]
		mov	edx, ecx
		and	edx, edi
		lea	edx, [ebx+edx]
		add	edx, eax
		mov	eax, [ebp+var_14]
		mov	ebx, edx
		sar	ebx, 0Eh
		shl	edx, 2
		and	ebx, 3
		or	ebx, edx
		add	esi, [eax+8]
		mov	edx, ebx
		mov	eax, ebx
		and	edx, ecx
		xor	eax, 0FFFFh
		and	eax, edi
		lea	edx, [esi+edx]
		add	edx, eax
		mov	esi, edx
		sar	esi, 0Dh
		shl	edx, 3
		and	esi, 7
		or	esi, edx
		mov	edx, [ebp+var_14]
		mov	eax, esi
		xor	eax, 0FFFFh
		and	eax, ecx
		add	edi, [edx+0Ch]
		mov	edx, esi
		and	edx, ebx
		lea	edx, [edi+edx]
		add	edx, eax
		mov	edi, edx
		sar	edi, 0Bh
		and	edi, 1Fh
		shl	edx, 5
		or	edi, edx
		cmp	[ebp+var_18], 4
		jnz	loc_10003A74

loc_10003B2C:				; CODE XREF: mwEncryptExpanded+E8j
		mov	edx, [ebp+arg_0]
		mov	eax, edi
		and	eax, 3Fh
		add	[ebp+var_18], 1
		add	[ebp+var_14], 10h
		add	ecx, [edx+eax*4]
		mov	eax, ecx
		and	eax, 3Fh
		add	ebx, [edx+eax*4]
		mov	eax, ebx
		and	eax, 3Fh
		add	esi, [edx+eax*4]
		mov	eax, esi
		and	eax, 3Fh
		add	edi, [edx+eax*4]
		cmp	[ebp+var_18], 10h
		jnz	loc_10003A90

loc_10003B61:				; CODE XREF: mwEncryptExpanded+FAj
		mov	eax, [ebp+var_1C]
		mov	edx, esi
		sar	esi, 8
		mov	[eax], cl
		sar	ecx, 8
		mov	[eax+1], cl
		mov	ecx, esi
		mov	[eax+2], bl
		sar	ebx, 8
		mov	[eax+4], dl
		mov	edx, edi
		mov	[eax+3], bl
		mov	[eax+5], cl
		mov	[eax+6], dl
		mov	ecx, [ebp+var_1C]
		mov	eax, edi
		sar	eax, 8
		mov	[ecx+7], al
		mov	edx, [ebp+arg_4]
		mov	[edx+7], al
		mov	edx, 5
		lea	esi, [esi+0]

loc_10003BA0:				; CODE XREF: mwEncryptExpanded+225j
		mov	ecx, [ebp+var_1C]
		movzx	eax, byte ptr [edx+ecx+1]
		mov	ecx, [ebp+arg_4]
		mov	[edx+ecx+1], al
		sub	edx, 1
		cmp	edx, 0FFFFFFFEh
		jnz	short loc_10003BA0
		mov	eax, [ebp+var_10]
		test	eax, eax
		jle	short loc_10003BCB
		add	[ebp+var_1C], 8
		sub	[ebp+var_10], 8
		jmp	loc_10003A06
; ---------------------------------------------------------------------------

loc_10003BCB:				; CODE XREF: mwEncryptExpanded+70j
					; mwEncryptExpanded+22Cj
		add	esp, 1Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
mwEncryptExpanded endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 140. mwEncrypt

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwEncrypt
mwEncrypt	proc near		; CODE XREF: sub_10009A60+334p
					; sub_10009A60+6CDp

var_118		= dword	ptr -118h
var_114		= dword	ptr -114h
var_110		= dword	ptr -110h
var_10C		= dword	ptr -10Ch
var_104		= byte ptr -104h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 114h
		mov	eax, [ebp+arg_4]
		lea	ebx, [ebp+var_104]
		mov	[esp+118h+var_118], ebx
		mov	[esp+118h+var_110], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+118h+var_114], eax
		call	mwKeyExpand
		mov	eax, [ebp+arg_10]
		mov	[esp+118h+var_118], ebx
		mov	[esp+118h+var_10C], eax
		mov	eax, [ebp+arg_C]
		mov	[esp+118h+var_110], eax
		mov	eax, [ebp+arg_8]
		mov	[esp+118h+var_114], eax
		call	mwEncryptExpanded
		add	esp, 114h
		pop	ebx
		pop	ebp
		retn
mwEncrypt	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 180. mwKeyRandom

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwKeyRandom
mwKeyRandom	proc near		; CODE XREF: sub_10009A60+67Fp

Time		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		mov	ebx, [ebp+arg_0]
		mov	edi, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_10003C7A
		mov	[esp+18h+Time],	0 ; Time
		call	time
		mov	[esp+18h+Time],	eax ; Seed
		call	srand
		test	edi, edi
		jz	short loc_10003C72
		add	ebx, edi
		xor	esi, esi
		nop

loc_10003C60:				; CODE XREF: mwKeyRandom+40j
		call	rand
		add	esi, 1
		mov	[ebx-1], al
		sub	ebx, 1
		cmp	esi, edi
		jnz	short loc_10003C60

loc_10003C72:				; CODE XREF: mwKeyRandom+29j
					; mwKeyRandom+66j
		add	esp, 0Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10003C7A:				; CODE XREF: mwKeyRandom+11j
		mov	[esp+18h+var_10], offset aKeyNull ; "key != NULL"
		mov	[esp+18h+var_14], offset aMwkeyrandom ;	"mwKeyRandom"
		mov	[esp+18h+Time],	offset aMeanwhile_0 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10003C72
mwKeyRandom	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10003CA0	proc near		; CODE XREF: mwMpi_randDHKeypair+15j
					; mwCipher_new_RC2_128+88p

Time		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= byte ptr -2Ch
var_1C		= byte ptr -1Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		mov	ebx, 0FFFFFFFFh
		sub	esp, 3Ch
		lea	edi, [ebp+var_2C]
		mov	[ebp+var_30], eax
		lea	eax, [ebp+var_1C]
		mov	[ebp+var_34], edx
		call	sub_10003860
		mov	[esp+48h+Time],	edi
		call	mw_mp_init
		mov	[esp+48h+var_44], 3
		mov	[esp+48h+Time],	edi
		call	mw_mp_set_int
		mov	[esp+48h+Time],	41h
		call	g_malloc
		mov	[esp+48h+Time],	0 ; Time
		mov	esi, eax
		call	time
		mov	[esp+48h+Time],	eax ; Seed
		call	srand
		call	rand
		mov	[esi+40h], al

loc_10003D01:				; CODE XREF: sub_10003CA0+70j
		call	rand
		mov	[ebx+esi+40h], al
		sub	ebx, 1
		cmp	ebx, 0FFFFFFBFh
		jnz	short loc_10003D01
		mov	eax, [ebp+var_30]
		mov	[esp+48h+var_44], esi
		mov	byte ptr [esi],	0
		mov	[esp+48h+var_40], 41h
		mov	[esp+48h+Time],	eax
		call	mw_mp_read_unsigned_bin
		mov	[esp+48h+Time],	esi
		call	g_free
		mov	eax, [ebp+var_34]
		mov	[esp+48h+Time],	edi
		mov	[esp+48h+var_3C], eax
		lea	eax, [ebp+var_1C]
		mov	[esp+48h+var_40], eax
		mov	eax, [ebp+var_30]
		mov	[esp+48h+var_44], eax
		call	mw_mp_exptmod
		lea	eax, [ebp+var_1C]
		mov	[esp+48h+Time],	eax
		call	mw_mp_clear
		mov	[esp+48h+Time],	edi
		call	mw_mp_clear
		add	esp, 3Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
sub_10003CA0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 194. mwMpi_randDHKeypair

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwMpi_randDHKeypair
mwMpi_randDHKeypair proc near		; CODE XREF: sub_10009A60+295p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	eax, eax
		jz	short loc_10003D8A
		test	edx, edx
		jz	short loc_10003DA8
		leave
		jmp	sub_10003CA0
; ---------------------------------------------------------------------------

loc_10003D8A:				; CODE XREF: mwMpi_randDHKeypair+Ej
		mov	[esp+18h+var_10], offset aPrivate_keyNul ; "private_key	!= NULL"
		mov	[esp+18h+var_14], offset aMwmpi_randdhke ; "mwMpi_randDHKeypair"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
; ---------------------------------------------------------------------------

loc_10003DA8:				; CODE XREF: mwMpi_randDHKeypair+12j
		mov	[esp+18h+var_10], offset aPublic_keyNull ; "public_key != NULL"
		mov	[esp+18h+var_14], offset aMwmpi_randdhke ; "mwMpi_randDHKeypair"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwMpi_randDHKeypair endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10003DD0	proc near		; CODE XREF: mwCipher_new_RC2_128+92p
					; mwMpi_export+15j ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[esp+18h+var_18], eax
		mov	[ebp+var_8], ebx
		mov	ebx, edx
		mov	[ebp+var_4], esi
		mov	esi, eax
		call	mw_mp_unsigned_bin_size
		mov	[ebx], eax
		mov	[esp+18h+var_18], eax
		call	g_malloc0
		mov	[esp+18h+var_18], esi
		mov	[ebx+4], eax
		mov	[esp+18h+var_14], eax
		call	mw_mp_to_unsigned_bin
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
sub_10003DD0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  97. mwCipher_new_RC2_128

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwCipher_new_RC2_128
mwCipher_new_RC2_128 proc near

var_28		= dword	ptr -28h
var_1C		= byte ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[esp+28h+var_28], 4Ch
		mov	[ebp+var_C], ebx
		mov	[ebp+var_8], esi
		lea	esi, [ebp+var_1C]
		mov	[ebp+var_4], edi
		call	g_malloc0
		mov	ebx, eax
		mov	eax, [ebp+arg_0]
		lea	edi, [ebx+34h]
		mov	[esp+28h+var_28], edi
		mov	word ptr [ebx+4], 1
		mov	[ebx], eax
		mov	dword ptr [ebx+8], offset sub_10002FD0
		mov	dword ptr [ebx+0Ch], offset sub_10002FE0
		mov	dword ptr [ebx+10h], offset sub_10003650
		mov	dword ptr [ebx+14h], offset sub_10003FB0
		mov	dword ptr [ebx+18h], offset sub_100040D0
		mov	dword ptr [ebx+1Ch], offset sub_10004060
		mov	dword ptr [ebx+20h], offset sub_10004120
		mov	dword ptr [ebx+24h], offset sub_10003F50
		mov	dword ptr [ebx+28h], offset sub_100044A0
		mov	dword ptr [ebx+2Ch], offset sub_10003F20
		call	mw_mp_init
		mov	[esp+28h+var_28], esi
		call	mw_mp_init
		mov	edx, esi
		mov	eax, edi
		call	sub_10003CA0
		mov	eax, esi
		lea	edx, [ebx+44h]
		call	sub_10003DD0
		mov	[esp+28h+var_28], esi
		call	mw_mp_clear
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
mwCipher_new_RC2_128 endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 190. mwMpi_export

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwMpi_export
mwMpi_export	proc near		; CODE XREF: sub_10009A60+306p
					; sub_10009A60+34Bp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	eax, eax
		jz	short loc_10003EDA
		test	edx, edx
		jz	short loc_10003EF8
		leave
		jmp	sub_10003DD0
; ---------------------------------------------------------------------------

loc_10003EDA:				; CODE XREF: mwMpi_export+Ej
		mov	[esp+18h+var_10], offset aINull	; "i !=	NULL"
		mov	[esp+18h+var_14], offset aMwmpi_export ; "mwMpi_export"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
; ---------------------------------------------------------------------------

loc_10003EF8:				; CODE XREF: mwMpi_export+12j
		mov	[esp+18h+var_10], offset aONull	; "o !=	NULL"
		mov	[esp+18h+var_14], offset aMwmpi_export ; "mwMpi_export"
		mov	[esp+18h+var_18], offset aMeanwhile_0 ;	"meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwMpi_export	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10003F20	proc near		; DATA XREF: mwCipher_new_RC2_128+70o

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		lea	eax, [ebx+34h]
		add	ebx, 44h
		mov	[esp+8+var_8], eax
		call	mw_mp_clear
		mov	[ebp+arg_0], ebx
		add	esp, 4
		pop	ebx
		pop	ebp
		jmp	mwOpaque_clear
sub_10003F20	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10003F50	proc near		; DATA XREF: mwCipher_new_RC2_128+62o

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	edx, [ebp+arg_0]
		mov	ebx, [ebp+arg_4]
		lea	eax, [ebp+var_C]
		mov	[esp+28h+var_1C], eax
		mov	[ebp+var_C], 0
		lea	eax, [edx+108h]
		add	edx, 8
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_28], edx
		mov	[ebp+var_8], 0
		call	mwEncryptExpanded
		mov	[esp+28h+var_28], ebx
		call	mwOpaque_clear
		mov	eax, [ebp+var_8]
		mov	[ebx+4], eax
		mov	eax, [ebp+var_C]
		mov	[ebx], eax
		add	esp, 24h
		xor	eax, eax
		pop	ebx
		pop	ebp
		retn
sub_10003F50	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10003FB0	proc near		; CODE XREF: sub_10004060+4j
					; DATA XREF: mwCipher_new_RC2_128+46o

var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_40		= dword	ptr -40h
var_34		= byte ptr -34h
var_24		= byte ptr -24h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 58h
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_0]
		mov	[ebp+var_C], ebx
		lea	ebx, [ebp+var_34]
		mov	[ebp+var_8], esi
		lea	esi, [ebp+var_24]
		mov	[ebp+var_14], 0
		mov	eax, [edi]
		add	edi, 8
		mov	[esp+58h+var_58], esi
		mov	[ebp+var_10], 0
		mov	[ebp+var_40], eax
		call	mw_mp_init
		mov	[esp+58h+var_58], ebx
		call	mw_mp_init
		mov	edx, [ebp+arg_4]
		mov	eax, esi
		add	edx, 4
		call	sub_10003790
		mov	ecx, [ebp+var_40]
		mov	edx, esi
		mov	eax, ebx
		add	ecx, 34h
		call	sub_10003890
		lea	edx, [ebp+var_14]
		mov	eax, ebx
		call	sub_10003DD0
		mov	eax, [ebp+var_10]
		mov	[esp+58h+var_58], edi
		mov	[esp+58h+var_50], 10h
		sub	eax, 10h
		add	eax, [ebp+var_14]
		mov	[esp+58h+var_54], eax
		call	mwKeyExpand
		mov	[esp+58h+var_58], esi
		call	mw_mp_clear
		mov	[esp+58h+var_58], ebx
		call	mw_mp_clear
		lea	eax, [ebp+var_14]
		mov	[esp+58h+var_58], eax
		call	mwOpaque_clear
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
sub_10003FB0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10004060	proc near		; DATA XREF: mwCipher_new_RC2_128+54o
		push	ebp
		mov	ebp, esp
		pop	ebp
		jmp	sub_10003FB0
sub_10004060	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10004070	proc near		; DATA XREF: mwCipher_new_RC2_40+47o

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	edx, [ebp+arg_0]
		mov	ebx, [ebp+arg_4]
		lea	eax, [ebp+var_C]
		mov	[esp+28h+var_1C], eax
		mov	[ebp+var_C], 0
		lea	eax, [edx+108h]
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_24], eax
		mov	eax, [edx]
		mov	[ebp+var_8], 0
		add	eax, 34h
		mov	[esp+28h+var_28], eax
		call	mwEncryptExpanded
		mov	[esp+28h+var_28], ebx
		call	mwOpaque_clear
		mov	eax, [ebp+var_8]
		mov	[ebx+4], eax
		mov	eax, [ebp+var_C]
		mov	[ebx], eax
		add	esp, 24h
		xor	eax, eax
		pop	ebx
		pop	ebp
		retn
sub_10004070	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100040D0	proc near		; CODE XREF: sub_10004120+4j
					; DATA XREF: mwCipher_new_RC2_128+4Do

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_4], esi
		mov	[ebp+var_8], ebx
		mov	ebx, [eax]
		mov	[esp+18h+var_18], 0Ch
		call	g_malloc0
		add	ebx, 44h
		mov	word ptr [eax],	1
		mov	esi, eax
		lea	eax, [eax+4]
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+var_18], eax
		call	mwOpaque_clone
		mov	eax, esi
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
sub_100040D0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10004120	proc near		; DATA XREF: mwCipher_new_RC2_128+5Bo
		push	ebp
		mov	ebp, esp
		pop	ebp
		jmp	short sub_100040D0
sub_10004120	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10004130	proc near		; CODE XREF: sub_10004170+15p
					; DATA XREF: mwCipher_new_RC2_40+39o

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebx+4]
		mov	[esp+18h+var_18], eax
		call	mwChannel_getUser
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_10004162
		mov	[esp+18h+var_14], eax
		lea	eax, [ebx+8]
		mov	[esp+18h+var_10], 5
		mov	[esp+18h+var_18], eax
		call	mwKeyExpand

loc_10004162:				; CODE XREF: sub_10004130+19j
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
sub_10004130	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10004170	proc near		; DATA XREF: mwCipher_new_RC2_40+40o

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		mov	[esp+18h+var_14], 0
		mov	[esp+18h+var_18], ebx
		call	sub_10004130
		add	esp, 14h
		mov	eax, ebx
		pop	ebx
		pop	ebp
		jmp	sub_10003700
sub_10004170	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100041A0	proc near		; DATA XREF: mwCipher_new_RC2_40+2Bo

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_0]
		mov	edx, [esi+134h]
		test	edx, edx
		jnz	short loc_100041E2
		mov	eax, [esi]
		mov	[esp+18h+var_18], eax
		call	mwSession_getLoginInfo
		mov	[esp+18h+var_10], 5
		mov	eax, [eax]
		mov	[esp+18h+var_14], eax
		lea	eax, [esi+34h]
		mov	[esp+18h+var_18], eax
		call	mwKeyExpand
		mov	dword ptr [esi+134h], 1

loc_100041E2:				; CODE XREF: sub_100041A0+13j
		mov	[esp+18h+var_18], 118h
		call	g_malloc0
		mov	ebx, eax
		mov	[eax], esi
		mov	eax, [ebp+arg_4]
		mov	[ebx+4], eax
		lea	eax, [ebx+110h]
		mov	[esp+18h+var_18], eax
		call	mwIV_init
		lea	eax, [ebx+108h]
		mov	[esp+18h+var_18], eax
		call	mwIV_init
		add	esp, 10h
		mov	eax, ebx
		pop	ebx
		pop	esi
		pop	ebp
		retn
sub_100041A0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 127. mwDecryptExpanded

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwDecryptExpanded
mwDecryptExpanded proc near		; CODE XREF: sub_100044A0+36p
					; sub_10004500+36p ...

var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 2Ch
		mov	eax, [ebp+arg_8]
		mov	ebx, [eax]
		mov	edx, [eax+4]
		test	bl, 7
		mov	[ebp+var_18], edx
		jnz	loc_10004474

loc_1000423D:				; CODE XREF: mwDecryptExpanded+274j
		mov	[esp+38h+var_38], ebx
		call	g_malloc
		test	ebx, ebx
		mov	[ebp+var_14], eax
		jz	short loc_10004267
		mov	ecx, [ebp+var_18]
		mov	edx, eax
		add	edx, ebx
		add	ecx, ebx

loc_10004255:				; CODE XREF: mwDecryptExpanded+45j
		movzx	eax, byte ptr [ecx-1]
		sub	ecx, 1
		mov	[edx-1], al
		sub	edx, 1
		cmp	edx, [ebp+var_14]
		jnz	short loc_10004255

loc_10004267:				; CODE XREF: mwDecryptExpanded+2Aj
		mov	ecx, [ebp+arg_C]
		test	ebx, ebx
		mov	edi, [ebp+var_14]
		mov	[ecx], ebx
		mov	[ecx+4], edi
		jle	loc_10004460
		lea	ebx, [edi+ebx]
		mov	[ebp+var_1C], ebx

loc_10004280:				; CODE XREF: mwDecryptExpanded+23Bj
		mov	eax, [ebp+var_14]
		mov	edx, [ebp+var_14]
		mov	edi, [ebp+var_14]
		movzx	esi, byte ptr [eax+7]
		movzx	eax, byte ptr [eax+6]
		movzx	ebx, byte ptr [edx+5]
		movzx	ecx, byte ptr [edx+3]
		shl	esi, 8
		or	esi, eax
		movzx	eax, byte ptr [edx+4]
		shl	ebx, 8
		shl	ecx, 8
		or	ebx, eax
		movzx	eax, byte ptr [edx+2]
		movzx	edx, byte ptr [edx+1]
		or	ecx, eax
		movzx	eax, byte ptr [edi]
		shl	edx, 8
		mov	[ebp+var_10], 0Fh
		or	edx, eax
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_24], eax
		jmp	short loc_100042EC
; ---------------------------------------------------------------------------
		align 10h

loc_100042D0:				; CODE XREF: mwDecryptExpanded+16Aj
		cmp	[ebp+var_10], 0Bh
		jz	loc_10004390
		sub	[ebp+var_10], 1
		sub	[ebp+var_24], 10h
		cmp	[ebp+var_10], 0FFFFFFFFh
		jz	loc_100043CB

loc_100042EC:				; CODE XREF: mwDecryptExpanded+A9j
					; mwDecryptExpanded+1A5j
		mov	eax, esi
		mov	edi, [ebp+var_24]
		sar	eax, 5
		and	eax, 7FFh
		shl	esi, 0Bh
		or	esi, eax
		mov	eax, ebx
		xor	eax, 0FFFFh
		and	eax, edx
		sub	esi, eax
		mov	eax, ebx
		and	eax, ecx
		sub	esi, eax
		mov	eax, ebx
		sar	eax, 3
		and	eax, 1FFFh
		shl	ebx, 0Dh
		or	ebx, eax
		mov	eax, edx
		sub	esi, [edi+0FCh]
		and	eax, ecx
		sub	ebx, eax
		mov	eax, ecx
		sub	ebx, [edi+0F8h]
		xor	eax, 0FFFFh
		and	eax, esi
		sub	ebx, eax
		mov	eax, ecx
		sar	eax, 2
		and	eax, 3FFFh
		shl	ecx, 0Eh
		or	ecx, eax
		mov	eax, esi
		sub	ecx, [edi+0F4h]
		and	eax, edx
		sub	ecx, eax
		mov	eax, edx
		xor	eax, 0FFFFh
		and	eax, ebx
		sub	ecx, eax
		mov	eax, edx
		sar	eax, 1
		and	eax, 7FFFh
		shl	edx, 0Fh
		or	edx, eax
		mov	eax, ebx
		sub	edx, [edi+0F0h]
		and	eax, esi
		sub	edx, eax
		mov	eax, esi
		xor	eax, 0FFFFh
		and	eax, ecx
		sub	edx, eax
		cmp	[ebp+var_10], 5
		jnz	loc_100042D0

loc_10004390:				; CODE XREF: mwDecryptExpanded+B4j
		mov	edi, [ebp+arg_0]
		mov	eax, ebx
		and	eax, 3Fh
		sub	[ebp+var_10], 1
		sub	[ebp+var_24], 10h
		sub	esi, [edi+eax*4]
		mov	eax, ecx
		and	eax, 3Fh
		sub	ebx, [edi+eax*4]
		mov	edi, edx
		mov	eax, [ebp+arg_0]
		and	edi, 3Fh
		sub	ecx, [eax+edi*4]
		mov	edi, esi
		and	edi, 3Fh
		sub	edx, [eax+edi*4]
		cmp	[ebp+var_10], 0FFFFFFFFh
		mov	[ebp+var_20], edi
		jnz	loc_100042EC

loc_100043CB:				; CODE XREF: mwDecryptExpanded+C6j
		mov	eax, [ebp+var_14]
		mov	[eax], dl
		sar	edx, 8
		mov	[eax+1], dl
		mov	edx, esi
		mov	[eax+2], cl
		sar	esi, 8
		sar	ecx, 8
		mov	[eax+3], cl
		mov	ecx, esi
		mov	[eax+4], bl
		sar	ebx, 8
		mov	[eax+5], bl
		mov	[eax+6], dl
		mov	[eax+7], cl
		mov	edi, [ebp+arg_4]
		mov	edx, [ebp+var_14]
		movzx	eax, byte ptr [edi+7]
		xor	[edx+7], al
		mov	edx, 5

loc_10004407:				; CODE XREF: mwDecryptExpanded+1FCj
		mov	ecx, [ebp+arg_4]
		mov	edi, [ebp+var_14]
		movzx	eax, byte ptr [edx+ecx+1]
		xor	[edx+edi+1], al
		sub	edx, 1
		cmp	edx, 0FFFFFFFEh
		jnz	short loc_10004407
		mov	edx, [ebp+var_18]
		movzx	eax, byte ptr [edx+7]
		mov	edx, 5
		mov	[ecx+7], al
		lea	esi, [esi+0]

loc_10004430:				; CODE XREF: mwDecryptExpanded+225j
		mov	ecx, [ebp+var_18]
		mov	edi, [ebp+arg_4]
		movzx	eax, byte ptr [edx+ecx+1]
		mov	[edx+edi+1], al
		sub	edx, 1
		cmp	edx, 0FFFFFFFEh
		jnz	short loc_10004430
		add	[ebp+var_14], 8
		mov	eax, [ebp+var_1C]
		sub	eax, [ebp+var_14]
		test	eax, eax
		jle	short loc_10004460
		add	ecx, 8
		mov	[ebp+var_18], ecx
		jmp	loc_10004280
; ---------------------------------------------------------------------------

loc_10004460:				; CODE XREF: mwDecryptExpanded+54j
					; mwDecryptExpanded+233j
		mov	edx, [ebp+var_14]
		mov	ecx, [ebp+arg_C]
		movzx	eax, byte ptr [edx-1]
		sub	[ecx], eax
		add	esp, 2Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10004474:				; CODE XREF: mwDecryptExpanded+17j
		mov	[esp+38h+var_2C], ebx
		mov	[esp+38h+var_30], offset aAttemptingDecr ; "attempting decryption of mis-sized data"...
		mov	[esp+38h+var_34], 10h
		mov	[esp+38h+var_38], offset aMeanwhile_0 ;	"meanwhile"
		call	g_log
		jmp	loc_1000423D
mwDecryptExpanded endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100044A0	proc near		; DATA XREF: mwCipher_new_RC2_128+69o

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	edx, [ebp+arg_0]
		mov	ebx, [ebp+arg_4]
		lea	eax, [ebp+var_C]
		mov	[esp+28h+var_1C], eax
		mov	[ebp+var_C], 0
		lea	eax, [edx+110h]
		add	edx, 8
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_28], edx
		mov	[ebp+var_8], 0
		call	mwDecryptExpanded
		mov	[esp+28h+var_28], ebx
		call	mwOpaque_clear
		mov	eax, [ebp+var_8]
		mov	[ebx+4], eax
		mov	eax, [ebp+var_C]
		mov	[ebx], eax
		add	esp, 24h
		xor	eax, eax
		pop	ebx
		pop	ebp
		retn
sub_100044A0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10004500	proc near		; DATA XREF: mwCipher_new_RC2_40+4Eo

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	edx, [ebp+arg_0]
		mov	ebx, [ebp+arg_4]
		lea	eax, [ebp+var_C]
		mov	[esp+28h+var_1C], eax
		mov	[ebp+var_C], 0
		lea	eax, [edx+110h]
		add	edx, 8
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_28], edx
		mov	[ebp+var_8], 0
		call	mwDecryptExpanded
		mov	[esp+28h+var_28], ebx
		call	mwOpaque_clear
		mov	eax, [ebp+var_8]
		mov	[ebx+4], eax
		mov	eax, [ebp+var_C]
		mov	[ebx], eax
		add	esp, 24h
		xor	eax, eax
		pop	ebx
		pop	ebp
		retn
sub_10004500	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 126. mwDecrypt

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwDecrypt
mwDecrypt	proc near

var_118		= dword	ptr -118h
var_114		= dword	ptr -114h
var_110		= dword	ptr -110h
var_10C		= dword	ptr -10Ch
var_104		= byte ptr -104h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 114h
		mov	eax, [ebp+arg_4]
		lea	ebx, [ebp+var_104]
		mov	[esp+118h+var_118], ebx
		mov	[esp+118h+var_110], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+118h+var_114], eax
		call	mwKeyExpand
		mov	eax, [ebp+arg_10]
		mov	[esp+118h+var_118], ebx
		mov	[esp+118h+var_10C], eax
		mov	eax, [ebp+arg_C]
		mov	[esp+118h+var_110], eax
		mov	eax, [ebp+arg_8]
		mov	[esp+118h+var_114], eax
		call	mwDecryptExpanded
		add	esp, 114h
		pop	ebx
		pop	ebp
		retn
mwDecrypt	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100045B0	proc near		; CODE XREF: gboolean_get+27p
					; guint32_get+2Ep ...
		push	ebp
		mov	ecx, eax
		mov	eax, [eax+14h]
		mov	ebp, esp
		test	eax, eax
		jnz	short loc_100045C7
		xor	eax, eax
		cmp	[ecx+0Ch], edx
		setb	al
		mov	[ecx+14h], eax

loc_100045C7:				; CODE XREF: sub_100045B0+Aj
		test	eax, eax
		pop	ebp
		setz	al
		movzx	eax, al
		retn
sub_100045B0	endp

; ---------------------------------------------------------------------------
		jmp	short guint16_peek
; ---------------------------------------------------------------------------
		align 10h
; Exported entry   5. guint16_peek

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public guint16_peek
guint16_peek	proc near		; CODE XREF: .text:100045D1j

arg_0		= dword	ptr  8

		push	ebp
		xor	ecx, ecx
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		cmp	dword ptr [eax+0Ch], 1
		mov	edx, [eax]
		jbe	short loc_100045F9
		movzx	ecx, byte ptr [edx]
		add	edx, 1
		shl	ecx, 8

loc_100045F9:				; CODE XREF: guint16_peek+Ej
		movzx	eax, byte ptr [edx]
		pop	ebp
		or	eax, ecx
		movzx	eax, ax
		retn
guint16_peek	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry   8. guint32_peek

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public guint32_peek
guint32_peek	proc near		; CODE XREF: mwSession_recv+12Bp
					; mwSession_recv+16Dp ...

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	ebx
		xor	ebx, ebx
		cmp	dword ptr [eax+0Ch], 3
		mov	ecx, [eax]
		jbe	short loc_1000462A
		movzx	ebx, byte ptr [ecx]
		add	ecx, 1
		shl	ebx, 18h

loc_1000462A:				; CODE XREF: guint32_peek+Fj
		movzx	eax, byte ptr [ecx]
		movzx	edx, byte ptr [ecx+2]
		shl	eax, 10h
		or	eax, edx
		movzx	edx, byte ptr [ecx+1]
		or	eax, ebx
		pop	ebx
		pop	ebp
		shl	edx, 8
		or	eax, edx
		retn
guint32_peek	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry   2. gboolean_peek

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public gboolean_peek
gboolean_peek	proc near

arg_0		= dword	ptr  8

		push	ebp
		xor	eax, eax
		mov	ebp, esp
		mov	edx, [ebp+arg_0]
		mov	ecx, [edx+0Ch]
		test	ecx, ecx
		jz	short loc_1000466B
		mov	eax, [edx+8]
		cmp	byte ptr [eax],	0
		setnz	al
		movzx	eax, al

loc_1000466B:				; CODE XREF: gboolean_peek+Dj
		pop	ebp
		retn
gboolean_peek	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 173. mwIdBlock_clear

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwIdBlock_clear
mwIdBlock_clear	proc near		; CODE XREF: mwMessage_free+A8p
					; mwFileTransfer_free+5Bp ...

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_100046A0
		mov	eax, [ebx]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	eax, [ebx+4]
		mov	dword ptr [ebx], 0
		mov	[esp+8+var_8], eax
		call	g_free
		mov	dword ptr [ebx+4], 0

loc_100046A0:				; CODE XREF: mwIdBlock_clear+Cj
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
mwIdBlock_clear	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 199. mwOpaque_free

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwOpaque_free
mwOpaque_free	proc near

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_100046D6
		mov	eax, [ebx+4]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	[ebp+arg_0], ebx
		add	esp, 4
		pop	ebx
		pop	ebp
		jmp	g_free
; ---------------------------------------------------------------------------

loc_100046D6:				; CODE XREF: mwOpaque_free+Cj
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
mwOpaque_free	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 197. mwOpaque_clear

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwOpaque_clear
mwOpaque_clear	proc near		; CODE XREF: sub_10001DA0+8Cp
					; sub_10001FC0+24p ...

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_10004706
		mov	eax, [ebx+4]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	dword ptr [ebx+4], 0
		mov	dword ptr [ebx], 0

loc_10004706:				; CODE XREF: mwOpaque_clear+Cj
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
mwOpaque_clear	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 142. mwEncryptItem_clear

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwEncryptItem_clear
mwEncryptItem_clear proc near		; CODE XREF: mwEncryptItem_free+Dp
					; mwMessage_free+D5p ...

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10004728
		mov	word ptr [eax],	0
		add	eax, 4
		mov	[ebp+arg_0], eax
		pop	ebp
		jmp	short mwOpaque_clear
; ---------------------------------------------------------------------------

loc_10004728:				; CODE XREF: mwEncryptItem_clear+8j
		pop	ebp
		retn
mwEncryptItem_clear endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 143. mwEncryptItem_free

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwEncryptItem_free
mwEncryptItem_free proc	near

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		mov	[esp+8+var_8], ebx
		call	mwEncryptItem_clear
		mov	[ebp+arg_0], ebx
		add	esp, 4
		pop	ebx
		pop	ebp
		jmp	g_free
mwEncryptItem_free endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 166. mwGetBuffer_free

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwGetBuffer_free
mwGetBuffer_free proc near		; CODE XREF: mwMessage_get+4DAp
					; sub_10009A60+63p ...

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_10004790
		mov	eax, [ebx+10h]
		test	eax, eax
		jz	short loc_10004772
		mov	[ebp+arg_0], ebx
		add	esp, 4
		pop	ebx
		pop	ebp
		jmp	g_free
; ---------------------------------------------------------------------------

loc_10004772:				; CODE XREF: mwGetBuffer_free+13j
		mov	eax, [ebx]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	[ebp+arg_0], ebx
		add	esp, 4
		pop	ebx
		pop	ebp
		jmp	g_free
; ---------------------------------------------------------------------------
		align 10h

loc_10004790:				; CODE XREF: mwGetBuffer_free+Cj
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
mwGetBuffer_free endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 221. mwPutBuffer_free

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwPutBuffer_free
mwPutBuffer_free proc near

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_100047C5
		mov	eax, [ebx]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	[ebp+arg_0], ebx
		add	esp, 4
		pop	ebx
		pop	ebp
		jmp	g_free
; ---------------------------------------------------------------------------

loc_100047C5:				; CODE XREF: mwPutBuffer_free+Cj
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
mwPutBuffer_free endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  19. mwAwareIdBlock_clear

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareIdBlock_clear
mwAwareIdBlock_clear proc near		; CODE XREF: mwAwareSnapshot_clear+11p
					; sub_1000C570+B9p ...

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_10004808
		mov	eax, [ebx+4]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	eax, [ebx+8]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	dword ptr [ebx], 0
		mov	dword ptr [ebx+4], 0
		mov	dword ptr [ebx+8], 0

loc_10004808:				; CODE XREF: mwAwareIdBlock_clear+Cj
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
mwAwareIdBlock_clear endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 364. mwUserStatus_clear

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwUserStatus_clear
mwUserStatus_clear proc	near		; CODE XREF: mwAwareSnapshot_clear+1Cp
					; mwMessage_free+239p ...

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_1000483D
		mov	eax, [ebx+8]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	dword ptr [ebx], 0
		mov	dword ptr [ebx+4], 0
		mov	dword ptr [ebx+8], 0

loc_1000483D:				; CODE XREF: mwUserStatus_clear+Cj
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
mwUserStatus_clear endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  40. mwAwareSnapshot_clear

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareSnapshot_clear
mwAwareSnapshot_clear proc near		; CODE XREF: sub_1000AC10+18p
					; sub_1000AFA0+Dp ...

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		sub	esp, 4
		mov	edi, [ebp+arg_0]
		test	edi, edi
		jz	short loc_1000489C
		mov	[esp+8+var_8], edi
		call	mwAwareIdBlock_clear
		lea	eax, [edi+18h]
		mov	[esp+8+var_8], eax
		call	mwUserStatus_clear
		mov	eax, [edi+14h]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	eax, [edi+24h]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	eax, [edi+0Ch]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	ecx, 0Ah
		xor	eax, eax
		cld
		rep stosd

loc_1000489C:				; CODE XREF: mwAwareSnapshot_clear+Cj
		add	esp, 4
		pop	edi
		pop	ebp
		retn
mwAwareSnapshot_clear endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 360. mwUserItem_clear

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwUserItem_clear
mwUserItem_clear proc near		; CODE XREF: mwPrivacyInfo_clear+3Ap

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_100048FA
		mov	eax, [ebx+4]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	eax, [ebx+8]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	eax, [ebx+0Ch]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	dword ptr [ebx], 0
		mov	dword ptr [ebx+4], 0
		mov	dword ptr [ebx+8], 0
		mov	dword ptr [ebx+0Ch], 0

loc_100048FA:				; CODE XREF: mwUserItem_clear+Cj
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
mwUserItem_clear endp

; Exported entry 181. mwLoginInfo_clear

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwLoginInfo_clear
mwLoginInfo_clear proc near		; CODE XREF: sub_10001FC0+19p
					; mwMessage_free+BEp ...

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		sub	esp, 4
		mov	edi, [ebp+arg_0]
		test	edi, edi
		jz	short loc_10004959
		mov	eax, [edi]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	eax, [edi+8]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	eax, [edi+0Ch]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	eax, [edi+10h]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	eax, [edi+18h]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	eax, [edi+20h]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	ecx, 9
		xor	eax, eax
		cld
		rep stosd

loc_10004959:				; CODE XREF: mwLoginInfo_clear+Cj
		add	esp, 4
		pop	edi
		pop	ebp
		retn
mwLoginInfo_clear endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 216. mwPrivacyInfo_clear

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwPrivacyInfo_clear
mwPrivacyInfo_clear proc near		; CODE XREF: mwMessage_free+22Ep
					; mwMessage_free+25Bp ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_100049C7
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+arg_0]
		mov	edi, [edx+4]
		mov	eax, [eax+8]
		test	edi, edi
		mov	[ebp+var_10], eax
		jz	short loc_100049A3
		mov	edx, [ebp+var_10]
		mov	eax, edi
		xor	esi, esi
		shl	eax, 4
		lea	ebx, [edx+eax-10h]

loc_10004991:				; CODE XREF: mwPrivacyInfo_clear+41j
		add	esi, 1
		mov	[esp+28h+var_28], ebx
		sub	ebx, 10h
		call	mwUserItem_clear
		cmp	esi, edi
		jnz	short loc_10004991

loc_100049A3:				; CODE XREF: mwPrivacyInfo_clear+21j
		mov	eax, [ebp+var_10]
		mov	[esp+28h+var_28], eax
		call	g_free
		mov	edx, [ebp+arg_0]
		mov	dword ptr [edx+4], 0
		mov	dword ptr [edx+8], 0

loc_100049BF:				; CODE XREF: mwPrivacyInfo_clear+83j
		add	esp, 1Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100049C7:				; CODE XREF: mwPrivacyInfo_clear+Ej
		mov	[esp+28h+var_20], offset aInfoNull ; "info != NULL"
		mov	[esp+28h+var_24], offset aMwprivacyinfo_ ; "mwPrivacyInfo_clear"
		mov	[esp+28h+var_28], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100049BF
mwPrivacyInfo_clear endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry   1. gboolean_get

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public gboolean_get
gboolean_get	proc near		; CODE XREF: mwAwareSnapshot_get+52p
					; mwUserItem_get+37p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_10004A3F
		mov	eax, [ebx+14h]
		test	eax, eax
		jz	short loc_10004A10

loc_10004A05:				; CODE XREF: gboolean_get+6Bj
					; gboolean_get+89j
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10004A10:				; CODE XREF: gboolean_get+13j
		mov	edx, 1
		mov	eax, ebx
		call	sub_100045B0
		test	eax, eax
		jz	short loc_10004A5D
		mov	eax, [ebx+8]
		mov	edx, [ebp+arg_4]
		cmp	byte ptr [eax],	0
		setnz	al
		movzx	eax, al
		mov	[edx], eax
		add	dword ptr [ebx+8], 1
		sub	dword ptr [ebx+0Ch], 1
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10004A3F:				; CODE XREF: gboolean_get+Cj
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aGboolean_get ; "gboolean_get"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10004A05
; ---------------------------------------------------------------------------

loc_10004A5D:				; CODE XREF: gboolean_get+2Ej
		mov	[esp+18h+var_10], offset aCheck_bufferBG ; "check_buffer(b, gboolean_buflen())"
		mov	[esp+18h+var_14], offset aGboolean_get ; "gboolean_get"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10004A05
gboolean_get	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry   7. guint32_get

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public guint32_get
guint32_get	proc near		; CODE XREF: mwOpaque_get+4Dp
					; mwUserStatus_get+46p	...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_10004B00
		mov	eax, [ebx+14h]
		test	eax, eax
		jz	short loc_10004AA7

loc_10004A9D:				; CODE XREF: guint32_get+9Cj
					; guint32_get+BDj
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10004AA7:				; CODE XREF: guint32_get+1Bj
		mov	edx, 4
		mov	eax, ebx
		call	sub_100045B0
		test	eax, eax
		jz	short loc_10004B21
		mov	edx, [ebx+8]
		movzx	eax, byte ptr [edx]
		shl	eax, 18h
		mov	[esi], eax
		lea	eax, [edx+1]
		mov	[ebx+8], eax
		movzx	eax, byte ptr [edx+1]
		shl	eax, 10h
		or	[esi], eax
		lea	eax, [edx+2]
		mov	[ebx+8], eax
		movzx	eax, byte ptr [edx+2]
		shl	eax, 8
		or	[esi], eax
		lea	eax, [edx+3]
		mov	[ebx+8], eax
		movzx	eax, byte ptr [edx+3]
		add	edx, 4
		or	[esi], eax
		sub	dword ptr [ebx+0Ch], 4
		mov	[ebx+8], edx
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10004B00:				; CODE XREF: guint32_get+14j
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aGuint32_get ;	"guint32_get"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10004A9D
; ---------------------------------------------------------------------------

loc_10004B21:				; CODE XREF: guint32_get+35j
		mov	[esp+18h+var_10], offset aCheck_buffer_0 ; "check_buffer(b, guint32_buflen())"
		mov	[esp+18h+var_14], offset aGuint32_get ;	"guint32_get"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10004A9D
guint32_get	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry   4. guint16_get

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public guint16_get
guint16_get	proc near		; CODE XREF: mwEncryptItem_get+37p
					; mwString_get+4Ap ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_10004BB4
		mov	eax, [ebx+14h]
		test	eax, eax
		jz	short loc_10004B77

loc_10004B6D:				; CODE XREF: guint16_get+80j
					; guint16_get+9Ej
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10004B77:				; CODE XREF: guint16_get+1Bj
		mov	edx, 2
		mov	eax, ebx
		call	sub_100045B0
		test	eax, eax
		jz	short loc_10004BD2
		mov	edx, [ebx+8]
		movzx	eax, byte ptr [edx]
		shl	eax, 8
		mov	[esi], ax
		lea	eax, [edx+1]
		mov	[ebx+8], eax
		movzx	eax, byte ptr [edx+1]
		add	edx, 2
		or	[esi], ax
		sub	dword ptr [ebx+0Ch], 2
		mov	[ebx+8], edx
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10004BB4:				; CODE XREF: guint16_get+14j
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aGuint16_get ;	"guint16_get"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10004B6D
; ---------------------------------------------------------------------------

loc_10004BD2:				; CODE XREF: guint16_get+35j
		mov	[esp+18h+var_10], offset aCheck_buffer_1 ; "check_buffer(b, guint16_buflen())"
		mov	[esp+18h+var_14], offset aGuint16_get ;	"guint16_get"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10004B6D
guint16_get	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 165. mwGetBuffer_error

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwGetBuffer_error
mwGetBuffer_error proc near		; CODE XREF: mwMessage_get+25p
					; mwMessage_get+35p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10004C12
		mov	eax, [eax+14h]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10004C12:				; CODE XREF: mwGetBuffer_error+Bj
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aMwgetbuffer_er ; "mwGetBuffer_error"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 1
		leave
		retn
mwGetBuffer_error endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 169. mwGetBuffer_remaining

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwGetBuffer_remaining
mwGetBuffer_remaining proc near		; CODE XREF: sub_1000D750+1B1p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10004C52
		mov	eax, [eax+0Ch]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10004C52:				; CODE XREF: mwGetBuffer_remaining+Bj
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aMwgetbuffer_re ; "mwGetBuffer_remaining"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwGetBuffer_remaining endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 170. mwGetBuffer_reset

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwGetBuffer_reset
mwGetBuffer_reset proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	edx, [ebp+arg_0]
		test	edx, edx
		jz	short loc_10004CA1
		mov	eax, [edx+4]
		mov	dword ptr [edx+14h], 0
		mov	[edx+0Ch], eax
		mov	eax, [edx]
		mov	[edx+8], eax
		leave
		retn
; ---------------------------------------------------------------------------

loc_10004CA1:				; CODE XREF: mwGetBuffer_reset+Bj
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aMwgetbuffer__0 ; "mwGetBuffer_reset"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwGetBuffer_reset endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 164. mwGetBuffer_advance

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwGetBuffer_advance
mwGetBuffer_advance proc near		; CODE XREF: mwAwareSnapshot_get+73p
					; sub_10010E90+32Fp ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	ecx, ecx
		jz	short loc_10004CF6
		mov	eax, [ecx+14h]
		test	eax, eax
		jnz	short locret_10004CF0
		test	edx, edx
		jz	short locret_10004CE9
		mov	eax, [ecx+0Ch]
		cmp	edx, eax
		cmova	edx, eax
		add	[ecx+8], edx
		sub	[ecx+0Ch], edx

locret_10004CE9:			; CODE XREF: mwGetBuffer_advance+19j
					; mwGetBuffer_advance+54j
		leave
		mov	eax, edx
		retn
; ---------------------------------------------------------------------------
		align 10h

locret_10004CF0:			; CODE XREF: mwGetBuffer_advance+15j
		leave
		xor	edx, edx
		mov	eax, edx
		retn
; ---------------------------------------------------------------------------

loc_10004CF6:				; CODE XREF: mwGetBuffer_advance+Ej
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aMwgetbuffer_ad ; "mwGetBuffer_advance"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	edx, edx
		jmp	short locret_10004CE9
mwGetBuffer_advance endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 220. mwPutBuffer_finalize

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwPutBuffer_finalize
mwPutBuffer_finalize proc near		; CODE XREF: mwMessage_put+26Cp
					; mwMessage_put+598p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	ecx, ecx
		jz	short loc_10004D4A
		test	edx, edx
		jz	short loc_10004D68
		mov	eax, [edx+4]
		sub	eax, [edx+0Ch]
		mov	[ecx], eax
		mov	eax, [edx]
		mov	[ecx+4], eax
		mov	[ebp+arg_0], edx
		leave
		jmp	g_free
; ---------------------------------------------------------------------------

loc_10004D4A:				; CODE XREF: mwPutBuffer_finalize+Ej
		mov	[esp+18h+var_10], offset aToNull ; "to != NULL"
		mov	[esp+18h+var_14], offset aMwputbuffer_fi ; "mwPutBuffer_finalize"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
; ---------------------------------------------------------------------------

loc_10004D68:				; CODE XREF: mwPutBuffer_finalize+12j
		mov	[esp+18h+var_10], offset aFromNull ; "from != NULL"
		mov	[esp+18h+var_14], offset aMwputbuffer_fi ; "mwPutBuffer_finalize"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwPutBuffer_finalize endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  20. mwAwareIdBlock_clone

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareIdBlock_clone
mwAwareIdBlock_clone proc near		; CODE XREF: mwAwareSnapshot_clone+1Dp
					; mwAwareList_addAware+1D2p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_4]
		test	esi, esi
		jz	short loc_10004DD6
		test	ebx, ebx
		jz	short loc_10004DF4
		movzx	eax, word ptr [ebx]
		mov	[esi], ax
		mov	eax, [ebx+4]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[esi+4], eax
		mov	eax, [ebx+8]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[esi+8], eax

loc_10004DCC:				; CODE XREF: mwAwareIdBlock_clone+62j
					; mwAwareIdBlock_clone+80j
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10004DD6:				; CODE XREF: mwAwareIdBlock_clone+14j
		mov	[esp+18h+var_10], offset aToNull ; "to != NULL"
		mov	[esp+18h+var_14], offset aMwawareidblock ; "mwAwareIdBlock_clone"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10004DCC
; ---------------------------------------------------------------------------

loc_10004DF4:				; CODE XREF: mwAwareIdBlock_clone+18j
		mov	[esp+18h+var_10], offset aFromNull ; "from != NULL"
		mov	[esp+18h+var_14], offset aMwawareidblock ; "mwAwareIdBlock_clone"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10004DCC
mwAwareIdBlock_clone endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 174. mwIdBlock_clone

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwIdBlock_clone
mwIdBlock_clone	proc near		; CODE XREF: mwFileTransfer_new+3Bp
					; sub_10011730+211p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_4]
		test	esi, esi
		jz	short loc_10004E5E
		test	ebx, ebx
		jz	short loc_10004E7C
		mov	eax, [ebx]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[esi], eax
		mov	eax, [ebx+4]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[esi+4], eax

loc_10004E54:				; CODE XREF: mwIdBlock_clone+5Aj
					; mwIdBlock_clone+78j
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10004E5E:				; CODE XREF: mwIdBlock_clone+14j
		mov	[esp+18h+var_10], offset aToNull ; "to != NULL"
		mov	[esp+18h+var_14], offset aMwidblock_clon ; "mwIdBlock_clone"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10004E54
; ---------------------------------------------------------------------------

loc_10004E7C:				; CODE XREF: mwIdBlock_clone+18j
		mov	[esp+18h+var_10], offset aFromNull ; "from != NULL"
		mov	[esp+18h+var_14], offset aMwidblock_clon ; "mwIdBlock_clone"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10004E54
mwIdBlock_clone	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 365. mwUserStatus_clone

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwUserStatus_clone
mwUserStatus_clone proc	near		; CODE XREF: mwAwareSnapshot_clone+47p
					; sub_100092F0+2Dp ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_10004ED5
		test	edx, edx
		jz	short loc_10004EF3
		movzx	eax, word ptr [edx]
		mov	[ebx], ax
		mov	eax, [edx+4]
		mov	[ebx+4], eax
		mov	eax, [edx+8]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[ebx+8], eax

loc_10004ECF:				; CODE XREF: mwUserStatus_clone+51j
					; mwUserStatus_clone+6Fj
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10004ED5:				; CODE XREF: mwUserStatus_clone+Fj
		mov	[esp+18h+var_10], offset aToNull ; "to != NULL"
		mov	[esp+18h+var_14], offset aMwuserstatus_c ; "mwUserStatus_clone"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10004ECF
; ---------------------------------------------------------------------------

loc_10004EF3:				; CODE XREF: mwUserStatus_clone+13j
		mov	[esp+18h+var_10], offset aFromNull ; "from != NULL"
		mov	[esp+18h+var_14], offset aMwuserstatus_c ; "mwUserStatus_clone"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10004ECF
mwUserStatus_clone endp

; ---------------------------------------------------------------------------
		jmp	short mwAwareSnapshot_clone
; ---------------------------------------------------------------------------
		align 10h
; Exported entry  41. mwAwareSnapshot_clone

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareSnapshot_clone
mwAwareSnapshot_clone proc near		; CODE XREF: .text:10004F11j
					; sub_1000AC10+24p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_0]
		mov	ebx, [ebp+arg_4]
		test	esi, esi
		jz	short loc_10004F8F
		test	ebx, ebx
		jz	short loc_10004FAD
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+var_18], esi
		call	mwAwareIdBlock_clone
		mov	eax, [ebx+10h]
		test	eax, eax
		mov	[esi+10h], eax
		jz	short loc_10004F88
		mov	eax, [ebx+14h]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[esi+14h], eax
		lea	eax, [ebx+18h]
		mov	[esp+18h+var_14], eax
		lea	eax, [esi+18h]
		mov	[esp+18h+var_18], eax
		call	mwUserStatus_clone
		mov	eax, [ebx+24h]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[esi+24h], eax
		mov	eax, [ebx+0Ch]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[esi+0Ch], eax

loc_10004F88:				; CODE XREF: mwAwareSnapshot_clone+2Aj
					; mwAwareSnapshot_clone+8Bj ...
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10004F8F:				; CODE XREF: mwAwareSnapshot_clone+10j
		mov	[esp+18h+var_10], offset aToNull ; "to != NULL"
		mov	[esp+18h+var_14], offset aMwawaresnapsho ; "mwAwareSnapshot_clone"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10004F88
; ---------------------------------------------------------------------------

loc_10004FAD:				; CODE XREF: mwAwareSnapshot_clone+14j
		mov	[esp+18h+var_10], offset aFromNull ; "from != NULL"
		mov	[esp+18h+var_14], offset aMwawaresnapsho ; "mwAwareSnapshot_clone"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10004F88
mwAwareSnapshot_clone endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 361. mwUserItem_clone

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwUserItem_clone
mwUserItem_clone proc near		; CODE XREF: mwPrivacyInfo_clone+63p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	ebx, [ebp+arg_0]
		mov	esi, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_10005025
		test	esi, esi
		jz	short loc_10005043
		mov	eax, [esi]
		mov	[ebx], eax
		mov	eax, [esi+4]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[ebx+4], eax
		mov	eax, [esi+8]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	edx, [ebx]
		mov	[ebx+8], eax
		xor	eax, eax
		test	edx, edx
		jnz	short loc_10005018

loc_1000500E:				; CODE XREF: mwUserItem_clone+53j
		mov	[ebx+0Ch], eax

loc_10005011:				; CODE XREF: mwUserItem_clone+71j
					; mwUserItem_clone+8Fj
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10005018:				; CODE XREF: mwUserItem_clone+3Cj
		mov	eax, [esi+0Ch]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		jmp	short loc_1000500E
; ---------------------------------------------------------------------------

loc_10005025:				; CODE XREF: mwUserItem_clone+10j
		mov	[esp+18h+var_10], offset aToNull ; "to != NULL"
		mov	[esp+18h+var_14], offset aMwuseritem_clo ; "mwUserItem_clone"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10005011
; ---------------------------------------------------------------------------

loc_10005043:				; CODE XREF: mwUserItem_clone+14j
		mov	[esp+18h+var_10], offset aFromNull ; "from != NULL"
		mov	[esp+18h+var_14], offset aMwuseritem_clo ; "mwUserItem_clone"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10005011
mwUserItem_clone endp

; ---------------------------------------------------------------------------
		jmp	short mwLoginInfo_clone
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 182. mwLoginInfo_clone

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwLoginInfo_clone
mwLoginInfo_clone proc near		; CODE XREF: mwChannel_recvAccept+ADp
					; mwChannel_recvCreate+ECp ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_0]
		mov	ebx, [ebp+arg_4]
		test	esi, esi
		jz	short loc_100050FB
		test	ebx, ebx
		jz	loc_10005119
		mov	eax, [ebx]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[esi], eax
		movzx	eax, word ptr [ebx+4]
		mov	[esi+4], ax
		mov	eax, [ebx+8]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[esi+8], eax
		mov	eax, [ebx+0Ch]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[esi+0Ch], eax
		mov	eax, [ebx+10h]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[esi+10h], eax
		mov	eax, [ebx+14h]
		test	eax, eax
		mov	[esi+14h], eax
		jz	short loc_100050F4
		mov	eax, [ebx+18h]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[esi+18h], eax
		mov	eax, [ebx+1Ch]
		mov	[esi+1Ch], eax
		mov	eax, [ebx+20h]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[esi+20h], eax

loc_100050F4:				; CODE XREF: mwLoginInfo_clone+60j
					; mwLoginInfo_clone+A7j ...
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100050FB:				; CODE XREF: mwLoginInfo_clone+10j
		mov	[esp+18h+var_10], offset aToNull ; "to != NULL"
		mov	[esp+18h+var_14], offset aMwlogininfo_cl ; "mwLoginInfo_clone"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100050F4
; ---------------------------------------------------------------------------

loc_10005119:				; CODE XREF: mwLoginInfo_clone+14j
		mov	[esp+18h+var_10], offset aFromNull ; "from != NULL"
		mov	[esp+18h+var_14], offset aMwlogininfo_cl ; "mwLoginInfo_clone"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100050F4
mwLoginInfo_clone endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10005140	proc near		; CODE XREF: mwAwareIdBlock_equal+36p
					; mwAwareIdBlock_equal+45p ...

Str1		= dword	ptr -8
Str2		= dword	ptr -4

		push	ebp
		mov	ecx, 1
		mov	ebp, esp
		sub	esp, 8
		cmp	eax, edx
		jz	short locret_1000516A
		test	eax, eax
		jz	short locret_10005170
		test	edx, edx
		jz	short locret_10005170
		mov	[esp+8+Str2], edx ; Str2
		mov	[esp+8+Str1], eax ; Str1
		call	strcmp
		xor	ecx, ecx
		test	eax, eax
		setz	cl

locret_1000516A:			; CODE XREF: sub_10005140+Dj
		leave
		mov	eax, ecx
		retn
; ---------------------------------------------------------------------------
		align 10h

locret_10005170:			; CODE XREF: sub_10005140+11j
					; sub_10005140+15j
		leave
		xor	ecx, ecx
		mov	eax, ecx
		retn
sub_10005140	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  21. mwAwareIdBlock_equal

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareIdBlock_equal
mwAwareIdBlock_equal proc near		; DATA XREF: mwAwareList_addAware:loc_1000B6A9o
					; mwServiceAware_new+46o

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_4]
		test	esi, esi
		jz	short loc_100051D4
		test	ebx, ebx
		jz	short loc_100051F4
		movzx	eax, word ptr [esi]
		cmp	ax, [ebx]
		jz	short loc_100051B0

loc_100051A2:				; CODE XREF: mwAwareIdBlock_equal+3Dj
		xor	eax, eax

loc_100051A4:				; CODE XREF: mwAwareIdBlock_equal+52j
					; mwAwareIdBlock_equal+72j ...
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_100051B0:				; CODE XREF: mwAwareIdBlock_equal+20j
		mov	edx, [ebx+4]
		mov	eax, [esi+4]
		call	sub_10005140
		test	eax, eax
		jz	short loc_100051A2
		mov	edx, [ebx+8]
		mov	eax, [esi+8]
		call	sub_10005140
		test	eax, eax
		setnz	al
		movzx	eax, al
		jmp	short loc_100051A4
; ---------------------------------------------------------------------------

loc_100051D4:				; CODE XREF: mwAwareIdBlock_equal+14j
		mov	[esp+18h+var_10], offset aANull	; "a !=	NULL"
		mov	[esp+18h+var_14], offset aMwawareidblo_0 ; "mwAwareIdBlock_equal"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		jmp	short loc_100051A4
; ---------------------------------------------------------------------------

loc_100051F4:				; CODE XREF: mwAwareIdBlock_equal+18j
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aMwawareidblo_0 ; "mwAwareIdBlock_equal"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		jmp	short loc_100051A4
mwAwareIdBlock_equal endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 175. mwIdBlock_equal

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwIdBlock_equal
mwIdBlock_equal	proc near		; CODE XREF: sub_10011AE0+27p
					; mwSametimeGroup_findUser+35p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_4]
		test	esi, esi
		jz	short loc_10005273
		test	ebx, ebx
		jz	short loc_10005293
		mov	edx, [ebx]
		mov	eax, [esi]
		call	sub_10005140
		xor	edx, edx
		test	eax, eax
		jnz	short loc_10005255

loc_10005249:				; CODE XREF: mwIdBlock_equal+71j
					; mwIdBlock_equal+91j
		mov	ebx, [ebp+var_8]
		mov	eax, edx
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10005255:				; CODE XREF: mwIdBlock_equal+27j
		mov	edx, [ebx+4]
		mov	eax, [esi+4]
		call	sub_10005140
		xor	edx, edx
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		test	eax, eax
		setnz	dl
		mov	esp, ebp
		pop	ebp
		mov	eax, edx
		retn
; ---------------------------------------------------------------------------

loc_10005273:				; CODE XREF: mwIdBlock_equal+14j
		mov	[esp+18h+var_10], offset aANull	; "a !=	NULL"
		mov	[esp+18h+var_14], offset aMwidblock_equa ; "mwIdBlock_equal"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	edx, edx
		jmp	short loc_10005249
; ---------------------------------------------------------------------------

loc_10005293:				; CODE XREF: mwIdBlock_equal+18j
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aMwidblock_equa ; "mwIdBlock_equal"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	edx, edx
		jmp	short loc_10005249
mwIdBlock_equal	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  23. mwAwareIdBlock_hash

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareIdBlock_hash
mwAwareIdBlock_hash proc near		; DATA XREF: mwAwareList_addAware+131o
					; mwServiceAware_new+4Eo

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_100052D6
		mov	eax, [eax+4]
		mov	[ebp+arg_0], eax
		pop	ebp
		jmp	g_str_hash
; ---------------------------------------------------------------------------

loc_100052D6:				; CODE XREF: mwAwareIdBlock_hash+8j
		pop	ebp
		xor	eax, eax
		retn
mwAwareIdBlock_hash endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 177. mwIdBlock_hash

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwIdBlock_hash
mwIdBlock_hash	proc near

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_100052F5
		mov	eax, [eax]
		mov	[ebp+arg_0], eax
		pop	ebp
		jmp	g_str_hash
; ---------------------------------------------------------------------------

loc_100052F5:				; CODE XREF: mwIdBlock_hash+8j
		pop	ebp
		xor	eax, eax
		retn
mwIdBlock_hash	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 217. mwPrivacyInfo_clone

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwPrivacyInfo_clone
mwPrivacyInfo_clone proc near		; CODE XREF: mwSession_setPrivacyInfo+35p
					; sub_10009A60+5DBp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_10005374
		mov	ecx, [ebp+arg_4]
		test	ecx, ecx
		jz	short loc_10005392
		mov	edx, [ebp+arg_4]
		mov	eax, [edx]
		mov	edx, [ebp+arg_0]
		mov	[edx], eax
		mov	eax, [ebp+arg_4]
		mov	edi, [eax+4]
		mov	ebx, edi
		mov	[edx+4], edi
		shl	ebx, 4
		mov	[esp+18h+var_18], ebx
		call	g_malloc0
		mov	edx, [ebp+arg_0]
		test	edi, edi
		mov	[edx+8], eax
		jz	short loc_1000536C
		sub	ebx, 10h
		xor	esi, esi

loc_10005346:				; CODE XREF: mwPrivacyInfo_clone+6Aj
		mov	edx, [ebp+arg_4]
		mov	eax, ebx
		add	esi, 1
		add	eax, [edx+8]
		mov	edx, [ebp+arg_0]
		mov	[esp+18h+var_14], eax
		mov	eax, ebx
		sub	ebx, 10h
		add	eax, [edx+8]
		mov	[esp+18h+var_18], eax
		call	mwUserItem_clone
		cmp	esi, edi
		jnz	short loc_10005346

loc_1000536C:				; CODE XREF: mwPrivacyInfo_clone+3Fj
					; mwPrivacyInfo_clone+90j ...
		add	esp, 0Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10005374:				; CODE XREF: mwPrivacyInfo_clone+Ej
		mov	[esp+18h+var_10], offset aToNull ; "to != NULL"
		mov	[esp+18h+var_14], offset aMwprivacyinf_0 ; "mwPrivacyInfo_clone"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000536C
; ---------------------------------------------------------------------------

loc_10005392:				; CODE XREF: mwPrivacyInfo_clone+15j
		mov	[esp+18h+var_10], offset aFromNull ; "from != NULL"
		mov	[esp+18h+var_14], offset aMwprivacyinf_0 ; "mwPrivacyInfo_clone"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000536C
mwPrivacyInfo_clone endp

; Exported entry 171. mwGetBuffer_wrap

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwGetBuffer_wrap
mwGetBuffer_wrap proc near		; CODE XREF: mwMessage_get+4B2p
					; sub_10009A60+3Ep ...

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		mov	[esp+8+var_8], 18h
		call	g_malloc0
		test	ebx, ebx
		mov	edx, eax
		jz	short loc_100053E2
		mov	eax, [ebx]
		test	eax, eax
		jz	short loc_100053E2
		mov	eax, [ebx+4]
		mov	[edx+8], eax
		mov	[edx], eax
		mov	eax, [ebx]
		mov	[edx+0Ch], eax
		mov	[edx+4], eax

loc_100053E2:				; CODE XREF: mwGetBuffer_wrap+1Aj
					; mwGetBuffer_wrap+20j
		mov	dword ptr [edx+10h], 1
		add	esp, 4
		mov	eax, edx
		pop	ebx
		pop	ebp
		retn
mwGetBuffer_wrap endp

; ---------------------------------------------------------------------------
		jmp	short mwPutBuffer_new
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 222. mwPutBuffer_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwPutBuffer_new
mwPutBuffer_new	proc near		; CODE XREF: .text:100053F1j
					; mwMessage_put+22Dp ...

var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[esp+8+var_8], 10h
		call	g_malloc0
		leave
		retn
mwPutBuffer_new	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 198. mwOpaque_clone

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwOpaque_clone
mwOpaque_clone	proc near		; CODE XREF: sub_10001DA0+5Ap
					; mwChannel_recv+4Ep ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_10005468
		test	edx, edx
		mov	dword ptr [ebx], 0
		mov	dword ptr [ebx+4], 0
		jz	short loc_1000544A
		mov	eax, [edx]
		test	eax, eax
		mov	[ebx], eax
		jnz	short loc_10005450

loc_1000544A:				; CODE XREF: mwOpaque_clone+20j
					; mwOpaque_clone+64j
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10005450:				; CODE XREF: mwOpaque_clone+28j
		mov	[esp+18h+var_14], eax
		mov	eax, [edx+4]
		mov	[esp+18h+var_18], eax
		call	g_memdup
		mov	[ebx+4], eax
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10005468:				; CODE XREF: mwOpaque_clone+Fj
		mov	[esp+18h+var_10], offset aToNull ; "to != NULL"
		mov	[esp+18h+var_14], offset aMwopaque_clone ; "mwOpaque_clone"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000544A
mwOpaque_clone	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 200. mwOpaque_get

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwOpaque_get
mwOpaque_get	proc near		; CODE XREF: mwEncryptItem_get+4Ej
					; mwMessage_get+147p ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_4]
		mov	[ebp+var_C], 0
		test	ebx, ebx
		jz	short loc_1000551E
		test	esi, esi
		jz	loc_1000553C
		mov	dword ptr [esi], 0
		mov	eax, [ebx+14h]
		mov	dword ptr [esi+4], 0
		test	eax, eax
		jz	short loc_100054D3

loc_100054C9:				; CODE XREF: mwOpaque_get+67j
					; mwOpaque_get+AAj ...
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100054D3:				; CODE XREF: mwOpaque_get+37j
		lea	eax, [ebp+var_C]
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_28], ebx
		call	guint32_get
		mov	edx, [ebp+var_C]
		mov	eax, ebx
		call	sub_100045B0
		test	eax, eax
		jz	short loc_1000555D
		mov	eax, [ebp+var_C]
		test	eax, eax
		mov	[esi], eax
		jz	short loc_100054C9
		mov	[esp+28h+var_24], eax
		mov	eax, [ebx+8]
		mov	[esp+28h+var_28], eax
		call	g_memdup
		mov	[esi+4], eax
		mov	eax, [ebp+var_C]
		add	[ebx+8], eax
		sub	[ebx+0Ch], eax
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000551E:				; CODE XREF: mwOpaque_get+1Bj
		mov	[esp+28h+var_20], offset aBNull	; "b !=	NULL"
		mov	[esp+28h+var_24], offset aMwopaque_get ; "mwOpaque_get"
		mov	[esp+28h+var_28], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100054C9
; ---------------------------------------------------------------------------

loc_1000553C:				; CODE XREF: mwOpaque_get+1Fj
		mov	[esp+28h+var_20], offset aONull_0 ; "o != NULL"
		mov	[esp+28h+var_24], offset aMwopaque_get ; "mwOpaque_get"
		mov	[esp+28h+var_28], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_100054C9
; ---------------------------------------------------------------------------

loc_1000555D:				; CODE XREF: mwOpaque_get+5Ej
		mov	[esp+28h+var_20], offset aCheck_buffer_2 ; "check_buffer(b, (gsize) tmp)"
		mov	[esp+28h+var_24], offset aMwopaque_get ; "mwOpaque_get"
		mov	[esp+28h+var_28], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_100054C9
mwOpaque_get	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 144. mwEncryptItem_get

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwEncryptItem_get
mwEncryptItem_get proc near		; CODE XREF: mwMessage_get+33Bp
					; mwMessage_get+9A0p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_100055D3
		test	esi, esi
		jz	short loc_100055F1
		mov	eax, [ebx+14h]
		test	eax, eax
		jz	short loc_100055B0

loc_100055A1:				; CODE XREF: mwEncryptItem_get+6Fj
					; mwEncryptItem_get+8Dj
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_100055B0:				; CODE XREF: mwEncryptItem_get+1Fj
		mov	[esp+18h+var_14], esi
		mov	[esp+18h+var_18], ebx
		call	guint16_get
		lea	eax, [esi+4]
		mov	esi, [ebp+var_4]
		mov	[ebp+arg_0], ebx
		mov	ebx, [ebp+var_8]
		mov	[ebp+arg_4], eax
		mov	esp, ebp
		pop	ebp
		jmp	mwOpaque_get
; ---------------------------------------------------------------------------

loc_100055D3:				; CODE XREF: mwEncryptItem_get+14j
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aMwencryptitem_ ; "mwEncryptItem_get"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100055A1
; ---------------------------------------------------------------------------

loc_100055F1:				; CODE XREF: mwEncryptItem_get+18j
		mov	[esp+18h+var_10], offset aEiNull ; "ei != NULL"
		mov	[esp+18h+var_14], offset aMwencryptitem_ ; "mwEncryptItem_get"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100055A1
mwEncryptItem_get endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 167. mwGetBuffer_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwGetBuffer_new
mwGetBuffer_new	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], ebx
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_0]
		mov	[esp+18h+var_18], 18h
		call	g_malloc0
		test	esi, esi
		mov	ebx, eax
		jz	short loc_10005637
		mov	eax, [esi]
		test	eax, eax
		jnz	short loc_10005643

loc_10005637:				; CODE XREF: mwGetBuffer_new+1Fj
		mov	eax, ebx
		mov	esi, [ebp+var_4]
		mov	ebx, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10005643:				; CODE XREF: mwGetBuffer_new+25j
		mov	[esp+18h+var_14], eax
		mov	eax, [esi+4]
		mov	[esp+18h+var_18], eax
		call	g_memdup
		mov	[ebx+8], eax
		mov	[ebx], eax
		mov	eax, [esi]
		mov	[ebx+0Ch], eax
		mov	[ebx+4], eax
		mov	eax, ebx
		mov	esi, [ebp+var_4]
		mov	ebx, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn
mwGetBuffer_new	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 358. mwString_get

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwString_get
mwString_get	proc near		; CODE XREF: mwAwareIdBlock_get+46p
					; mwAwareIdBlock_get+5Dj ...

Dst		= dword	ptr -28h
Src		= dword	ptr -24h
Size		= dword	ptr -20h
var_A		= word ptr -0Ah
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_4]
		mov	[ebp+var_A], 0
		test	ebx, ebx
		jz	loc_10005716
		test	esi, esi
		jz	loc_10005737
		mov	eax, [ebx+14h]
		mov	dword ptr [esi], 0
		test	eax, eax
		jz	short loc_100056B0

loc_100056A5:				; CODE XREF: mwString_get+69j
					; mwString_get+C2j ...
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_100056B0:				; CODE XREF: mwString_get+33j
		lea	eax, [ebp+var_A]
		mov	[esp+28h+Src], eax
		mov	[esp+28h+Dst], ebx
		call	guint16_get
		movzx	edx, [ebp+var_A]
		mov	eax, ebx
		call	sub_100045B0
		test	eax, eax
		jz	loc_10005758
		movzx	eax, [ebp+var_A]
		test	ax, ax
		jz	short loc_100056A5
		movzx	eax, ax
		add	eax, 1
		mov	[esp+28h+Dst], eax
		call	g_malloc0
		movzx	edx, [ebp+var_A]
		mov	ecx, [ebx+8]
		mov	[esi], eax
		mov	[esp+28h+Size],	edx ; Size
		mov	[esp+28h+Src], ecx ; Src
		mov	[esp+28h+Dst], eax ; Dst
		call	memcpy
		movzx	eax, [ebp+var_A]
		add	[ebx+8], eax
		sub	[ebx+0Ch], eax
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10005716:				; CODE XREF: mwString_get+1Aj
		mov	[esp+28h+Size],	offset aBNull ;	"b != NULL"
		mov	[esp+28h+Src], offset aMwstring_get ; "mwString_get"
		mov	[esp+28h+Dst], offset aMeanwhile_1 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_100056A5
; ---------------------------------------------------------------------------

loc_10005737:				; CODE XREF: mwString_get+22j
		mov	[esp+28h+Size],	offset aValNull	; "val != NULL"
		mov	[esp+28h+Src], offset aMwstring_get ; "mwString_get"
		mov	[esp+28h+Dst], offset aMeanwhile_1 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_100056A5
; ---------------------------------------------------------------------------

loc_10005758:				; CODE XREF: mwString_get+5Cj
		mov	[esp+28h+Size],	offset aCheck_buffer_3 ; "check_buffer(b, (gsize) len)"
		mov	[esp+28h+Src], offset aMwstring_get ; "mwString_get"
		mov	[esp+28h+Dst], offset aMeanwhile_1 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_100056A5
mwString_get	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  22. mwAwareIdBlock_get

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareIdBlock_get
mwAwareIdBlock_get proc	near		; CODE XREF: mwAwareSnapshot_get+34p
					; sub_1000C570+99p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_100057E2
		test	esi, esi
		jz	short loc_10005800
		mov	eax, [ebx+14h]
		test	eax, eax
		jz	short loc_100057B0

loc_100057A1:				; CODE XREF: mwAwareIdBlock_get+7Ej
					; mwAwareIdBlock_get+9Cj
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_100057B0:				; CODE XREF: mwAwareIdBlock_get+1Fj
		mov	[esp+18h+var_14], esi
		mov	[esp+18h+var_18], ebx
		call	guint16_get
		lea	eax, [esi+4]
		mov	[esp+18h+var_14], eax
		mov	[esp+18h+var_18], ebx
		call	mwString_get
		lea	eax, [esi+8]
		mov	esi, [ebp+var_4]
		mov	[ebp+arg_0], ebx
		mov	ebx, [ebp+var_8]
		mov	[ebp+arg_4], eax
		mov	esp, ebp
		pop	ebp
		jmp	mwString_get
; ---------------------------------------------------------------------------

loc_100057E2:				; CODE XREF: mwAwareIdBlock_get+14j
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aMwawareidblo_1 ; "mwAwareIdBlock_get"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100057A1
; ---------------------------------------------------------------------------

loc_10005800:				; CODE XREF: mwAwareIdBlock_get+18j
		mov	[esp+18h+var_10], offset aIdbNull ; "idb != NULL"
		mov	[esp+18h+var_14], offset aMwawareidblo_1 ; "mwAwareIdBlock_get"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100057A1
mwAwareIdBlock_get endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 176. mwIdBlock_get

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwIdBlock_get
mwIdBlock_get	proc near		; CODE XREF: mwMessage_get+267p
					; sub_10012AC0+1BBp ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_10005873
		test	esi, esi
		jz	short loc_10005891
		mov	eax, [ebx+14h]
		test	eax, eax
		jz	short loc_10005850

loc_10005841:				; CODE XREF: mwIdBlock_get+6Fj
					; mwIdBlock_get+8Dj
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10005850:				; CODE XREF: mwIdBlock_get+1Fj
		mov	[esp+18h+var_14], esi
		mov	[esp+18h+var_18], ebx
		call	mwString_get
		lea	eax, [esi+4]
		mov	esi, [ebp+var_4]
		mov	[ebp+arg_0], ebx
		mov	ebx, [ebp+var_8]
		mov	[ebp+arg_4], eax
		mov	esp, ebp
		pop	ebp
		jmp	mwString_get
; ---------------------------------------------------------------------------

loc_10005873:				; CODE XREF: mwIdBlock_get+14j
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aMwidblock_get	; "mwIdBlock_get"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10005841
; ---------------------------------------------------------------------------

loc_10005891:				; CODE XREF: mwIdBlock_get+18j
		mov	[esp+18h+var_10], offset aIdNull ; "id != NULL"
		mov	[esp+18h+var_14], offset aMwidblock_get	; "mwIdBlock_get"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10005841
mwIdBlock_get	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 366. mwUserStatus_get

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwUserStatus_get
mwUserStatus_get proc near		; CODE XREF: mwAwareSnapshot_get+99p
					; mwMessage_get+74Ep ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_10005912
		test	esi, esi
		jz	short loc_10005930
		mov	edx, [ebx+14h]
		test	edx, edx
		jz	short loc_100058E0

loc_100058D1:				; CODE XREF: mwUserStatus_get+7Ej
					; mwUserStatus_get+9Cj
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_100058E0:				; CODE XREF: mwUserStatus_get+1Fj
		mov	[esp+18h+var_14], esi
		mov	[esp+18h+var_18], ebx
		call	guint16_get
		lea	eax, [esi+4]
		mov	[esp+18h+var_14], eax
		mov	[esp+18h+var_18], ebx
		call	guint32_get
		lea	eax, [esi+8]
		mov	esi, [ebp+var_4]
		mov	[ebp+arg_0], ebx
		mov	ebx, [ebp+var_8]
		mov	[ebp+arg_4], eax
		mov	esp, ebp
		pop	ebp
		jmp	mwString_get
; ---------------------------------------------------------------------------

loc_10005912:				; CODE XREF: mwUserStatus_get+14j
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aMwuserstatus_g ; "mwUserStatus_get"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100058D1
; ---------------------------------------------------------------------------

loc_10005930:				; CODE XREF: mwUserStatus_get+18j
		mov	[esp+18h+var_10], offset aStatNull ; "stat != NULL"
		mov	[esp+18h+var_14], offset aMwuserstatus_g ; "mwUserStatus_get"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100058D1
mwUserStatus_get endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  42. mwAwareSnapshot_get

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareSnapshot_get
mwAwareSnapshot_get proc near		; CODE XREF: sub_1000C570+1FEp
					; sub_1000C570+266p

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 20h
		mov	esi, [ebp+arg_0]
		mov	ebx, [ebp+arg_4]
		test	esi, esi
		jz	loc_100059FF
		test	ebx, ebx
		jz	loc_10005A1D
		lea	eax, [ebp+var_C]
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_28], esi
		call	guint32_get
		mov	[esp+28h+var_24], ebx
		mov	[esp+28h+var_28], esi
		call	mwAwareIdBlock_get
		lea	eax, [ebx+0Ch]
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_28], esi
		call	mwString_get
		lea	eax, [ebx+10h]
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_28], esi
		call	gboolean_get
		mov	ecx, [ebx+10h]
		test	ecx, ecx
		jnz	short loc_100059D0

loc_100059AE:				; CODE XREF: mwAwareSnapshot_get+ADj
		mov	edx, [esi+8]
		mov	eax, [ebp+var_C]
		add	eax, [esi]
		cmp	edx, eax
		jnb	short loc_100059C8
		sub	eax, edx
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_28], esi
		call	mwGetBuffer_advance

loc_100059C8:				; CODE XREF: mwAwareSnapshot_get+68j
					; mwAwareSnapshot_get+CBj ...
		add	esp, 20h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_100059D0:				; CODE XREF: mwAwareSnapshot_get+5Cj
		lea	eax, [ebx+14h]
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_28], esi
		call	mwString_get
		lea	eax, [ebx+18h]
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_28], esi
		call	mwUserStatus_get
		lea	eax, [ebx+24h]
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_28], esi
		call	mwString_get
		jmp	short loc_100059AE
; ---------------------------------------------------------------------------

loc_100059FF:				; CODE XREF: mwAwareSnapshot_get+10j
		mov	[esp+28h+var_20], offset aBNull	; "b !=	NULL"
		mov	[esp+28h+var_24], offset aMwawaresnaps_0 ; "mwAwareSnapshot_get"
		mov	[esp+28h+var_28], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100059C8
; ---------------------------------------------------------------------------

loc_10005A1D:				; CODE XREF: mwAwareSnapshot_get+18j
		mov	[esp+28h+var_20], offset aIdbNull ; "idb != NULL"
		mov	[esp+28h+var_24], offset aMwawaresnaps_0 ; "mwAwareSnapshot_get"
		mov	[esp+28h+var_28], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100059C8
mwAwareSnapshot_get endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 362. mwUserItem_get

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwUserItem_get
mwUserItem_get	proc near		; CODE XREF: mwPrivacyInfo_get+9Ep

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_4]
		test	esi, esi
		jz	short loc_10005AB7
		test	ebx, ebx
		jz	short loc_10005AD5
		mov	eax, [esi+14h]
		test	eax, eax
		jz	short loc_10005A70

loc_10005A61:				; CODE XREF: mwUserItem_get+5Ej
					; mwUserItem_get+93j ...
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10005A70:				; CODE XREF: mwUserItem_get+1Fj
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+var_18], esi
		call	gboolean_get
		lea	eax, [ebx+4]
		mov	[esp+18h+var_14], eax
		mov	[esp+18h+var_18], esi
		call	mwString_get
		lea	eax, [ebx+8]
		mov	[esp+18h+var_14], eax
		mov	[esp+18h+var_18], esi
		call	mwString_get
		mov	eax, [ebx]
		test	eax, eax
		jz	short loc_10005A61
		lea	eax, [ebx+0Ch]
		mov	ebx, [ebp+var_8]
		mov	[ebp+arg_0], esi
		mov	esi, [ebp+var_4]
		mov	[ebp+arg_4], eax
		mov	esp, ebp
		pop	ebp
		jmp	mwString_get
; ---------------------------------------------------------------------------

loc_10005AB7:				; CODE XREF: mwUserItem_get+14j
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aMwuseritem_get ; "mwUserItem_get"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10005A61
; ---------------------------------------------------------------------------

loc_10005AD5:				; CODE XREF: mwUserItem_get+18j
		mov	[esp+18h+var_10], offset aUserNull ; "user != NULL"
		mov	[esp+18h+var_14], offset aMwuseritem_get ; "mwUserItem_get"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10005A61
mwUserItem_get	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 218. mwPrivacyInfo_get

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwPrivacyInfo_get
mwPrivacyInfo_get proc near		; CODE XREF: mwMessage_get+610p
					; mwMessage_get+73Fp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_C], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_8], esi
		mov	[ebp+var_4], edi
		test	ebx, ebx
		jz	loc_10005BA9
		mov	ecx, [ebp+arg_4]
		test	ecx, ecx
		jz	loc_10005BCA
		mov	eax, [ebp+arg_0]
		mov	edx, [eax+14h]
		test	edx, edx
		jz	short loc_10005B40

loc_10005B2F:				; CODE XREF: mwPrivacyInfo_get+6Cj
					; mwPrivacyInfo_get+A7j ...
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10005B40:				; CODE XREF: mwPrivacyInfo_get+2Dj
		mov	edx, [ebp+arg_4]
		mov	[esp+18h+var_18], eax
		mov	[esp+18h+var_14], edx
		call	gboolean_get
		mov	eax, [ebp+arg_4]
		add	eax, 4
		mov	[esp+18h+var_14], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+18h+var_18], eax
		call	guint32_get
		mov	edx, [ebp+arg_4]
		mov	edi, [edx+4]
		test	edi, edi
		jz	short loc_10005B2F
		mov	ebx, edi
		xor	esi, esi
		shl	ebx, 4
		mov	[esp+18h+var_18], ebx
		sub	ebx, 10h
		call	g_malloc0
		mov	edx, [ebp+arg_4]
		mov	[edx+8], eax

loc_10005B86:				; CODE XREF: mwPrivacyInfo_get+A5j
		mov	edx, [ebp+arg_4]
		mov	eax, ebx
		add	esi, 1
		sub	ebx, 10h
		add	eax, [edx+8]
		mov	[esp+18h+var_14], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+18h+var_18], eax
		call	mwUserItem_get
		cmp	esi, edi
		jnz	short loc_10005B86
		jmp	short loc_10005B2F
; ---------------------------------------------------------------------------

loc_10005BA9:				; CODE XREF: mwPrivacyInfo_get+14j
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aMwprivacyinf_1 ; "mwPrivacyInfo_get"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10005B2F
; ---------------------------------------------------------------------------

loc_10005BCA:				; CODE XREF: mwPrivacyInfo_get+1Fj
		mov	[esp+18h+var_10], offset aInfoNull ; "info != NULL"
		mov	[esp+18h+var_14], offset aMwprivacyinf_1 ; "mwPrivacyInfo_get"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10005B2F
mwPrivacyInfo_get endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 183. mwLoginInfo_get

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwLoginInfo_get
mwLoginInfo_get	proc near		; CODE XREF: mwMessage_get+721p
					; mwMessage_get+90Ap ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	ebx, [ebp+arg_0]
		mov	esi, [ebp+arg_4]
		test	ebx, ebx
		jz	loc_10005CB0
		test	esi, esi
		jz	loc_10005CD1
		mov	eax, [ebx+14h]
		test	eax, eax
		jz	short loc_10005C20

loc_10005C15:				; CODE XREF: mwLoginInfo_get+8Cj
					; mwLoginInfo_get+DCj ...
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10005C20:				; CODE XREF: mwLoginInfo_get+23j
		mov	[esp+18h+var_14], esi
		mov	[esp+18h+var_18], ebx
		call	mwString_get
		lea	eax, [esi+4]
		mov	[esp+18h+var_14], eax
		mov	[esp+18h+var_18], ebx
		call	guint16_get
		lea	eax, [esi+8]
		mov	[esp+18h+var_14], eax
		mov	[esp+18h+var_18], ebx
		call	mwString_get
		lea	eax, [esi+0Ch]
		mov	[esp+18h+var_14], eax
		mov	[esp+18h+var_18], ebx
		call	mwString_get
		lea	eax, [esi+10h]
		mov	[esp+18h+var_14], eax
		mov	[esp+18h+var_18], ebx
		call	mwString_get
		lea	eax, [esi+14h]
		mov	[esp+18h+var_14], eax
		mov	[esp+18h+var_18], ebx
		call	gboolean_get
		mov	eax, [esi+14h]
		test	eax, eax
		jz	short loc_10005C15
		lea	eax, [esi+18h]
		mov	[esp+18h+var_14], eax
		mov	[esp+18h+var_18], ebx
		call	mwString_get
		lea	eax, [esi+1Ch]
		mov	[esp+18h+var_14], eax
		mov	[esp+18h+var_18], ebx
		call	guint32_get
		lea	eax, [esi+20h]
		mov	[ebp+arg_4], eax
		mov	[ebp+arg_0], ebx
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	mwString_get
; ---------------------------------------------------------------------------

loc_10005CB0:				; CODE XREF: mwLoginInfo_get+10j
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aMwlogininfo_ge ; "mwLoginInfo_get"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10005C15
; ---------------------------------------------------------------------------

loc_10005CD1:				; CODE XREF: mwLoginInfo_get+18j
		mov	[esp+18h+var_10], offset aLoginNull ; "login !=	NULL"
		mov	[esp+18h+var_14], offset aMwlogininfo_ge ; "mwLoginInfo_get"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10005C15
mwLoginInfo_get	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 168. mwGetBuffer_read

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl mwGetBuffer_read(int, void *, int)
		public mwGetBuffer_read
mwGetBuffer_read proc near

Dst		= dword	ptr -18h
Src		= dword	ptr -14h
Size		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		mov	edx, [ebp+arg_4]
		mov	ebx, [ebp+arg_8]
		test	esi, esi
		jz	short loc_10005D6F
		test	edx, edx
		jz	short loc_10005D8F
		mov	eax, [esi+14h]
		test	eax, eax
		jnz	short loc_10005D61
		test	ebx, ebx
		jnz	short loc_10005D34

loc_10005D28:				; CODE XREF: mwGetBuffer_read+8Dj
					; mwGetBuffer_read+ADj
		mov	eax, ebx
		mov	esi, [ebp+var_4]
		mov	ebx, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10005D34:				; CODE XREF: mwGetBuffer_read+26j
		mov	eax, [esi+0Ch]
		cmp	ebx, eax
		cmova	ebx, eax
		mov	eax, [esi+8]
		mov	[esp+18h+Size],	ebx ; Size
		mov	[esp+18h+Dst], edx ; Dst
		mov	[esp+18h+Src], eax ; Src
		call	memcpy
		mov	eax, ebx
		add	[esi+8], ebx
		sub	[esi+0Ch], ebx
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10005D61:				; CODE XREF: mwGetBuffer_read+22j
		xor	ebx, ebx
		mov	esi, [ebp+var_4]
		mov	eax, ebx
		mov	ebx, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10005D6F:				; CODE XREF: mwGetBuffer_read+17j
		mov	[esp+18h+Size],	offset aBNull ;	"b != NULL"
		xor	ebx, ebx
		mov	[esp+18h+Src], offset aMwgetbuffer__1 ;	"mwGetBuffer_read"
		mov	[esp+18h+Dst], offset aMeanwhile_1 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10005D28
; ---------------------------------------------------------------------------

loc_10005D8F:				; CODE XREF: mwGetBuffer_read+1Bj
		mov	[esp+18h+Size],	offset aDataNull_0 ; "data != NULL"
		xor	ebx, ebx
		mov	[esp+18h+Src], offset aMwgetbuffer__1 ;	"mwGetBuffer_read"
		mov	[esp+18h+Dst], offset aMeanwhile_1 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10005D28
mwGetBuffer_read endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10005DC0	proc near		; CODE XREF: gboolean_put+15p
					; guint32_put+1Dp ...

Dst		= dword	ptr -28h
Src		= dword	ptr -24h
Size		= dword	ptr -20h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h

		push	ebp
		mov	ecx, eax
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	[ebp+var_10], eax
		mov	eax, [eax+0Ch]
		cmp	eax, edx
		jnb	short loc_10005E41
		mov	ebx, [ecx+4]
		mov	edi, ebx
		sub	edi, eax
		test	ebx, ebx
		mov	eax, 400h
		cmovz	ebx, eax
		mov	esi, ebx
		sub	esi, edi
		cmp	edx, esi
		jbe	short loc_10005DFA
		xchg	ax, ax

loc_10005DF0:				; CODE XREF: sub_10005DC0+38j
		add	ebx, ebx
		mov	esi, ebx
		sub	esi, edi
		cmp	edx, esi
		ja	short loc_10005DF0

loc_10005DFA:				; CODE XREF: sub_10005DC0+2Cj
		mov	[esp+28h+Dst], ebx
		call	g_malloc
		mov	edx, [ebp+var_10]
		mov	[ebp+var_14], eax
		mov	eax, [edx]
		test	eax, eax
		jz	short loc_10005E2E
		mov	ecx, [ebp+var_14]
		mov	[esp+28h+Size],	edi ; Size
		mov	[esp+28h+Src], eax ; Src
		mov	[esp+28h+Dst], ecx ; Dst
		call	memcpy
		mov	edx, [ebp+var_10]
		mov	eax, [edx]
		mov	[esp+28h+Dst], eax
		call	g_free

loc_10005E2E:				; CODE XREF: sub_10005DC0+4Cj
		mov	ecx, [ebp+var_10]
		mov	eax, [ebp+var_14]
		mov	[ecx+4], ebx
		mov	[ecx], eax
		add	eax, edi
		mov	[ecx+8], eax
		mov	[ecx+0Ch], esi

loc_10005E41:				; CODE XREF: sub_10005DC0+13j
		add	esp, 1Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
sub_10005DC0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry   3. gboolean_put

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public gboolean_put
gboolean_put	proc near		; CODE XREF: mwUserItem_put+1Fp
					; mwPrivacyInfo_put+2Ap ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_10005E83
		mov	edx, 1
		mov	eax, ebx
		call	sub_10005DC0
		mov	edx, [ebp+arg_4]
		mov	eax, [ebx+8]
		test	edx, edx
		setnz	byte ptr [eax]
		add	dword ptr [ebx+8], 1
		sub	dword ptr [ebx+0Ch], 1

loc_10005E7D:				; CODE XREF: gboolean_put+4Fj
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10005E83:				; CODE XREF: gboolean_put+Cj
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aGboolean_put ; "gboolean_put"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10005E7D
gboolean_put	endp

; ---------------------------------------------------------------------------
		jmp	short guint32_put
; ---------------------------------------------------------------------------
		align 10h
; Exported entry   9. guint32_put

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public guint32_put
guint32_put	proc near		; CODE XREF: .text:10005EA1j
					; mwOpaque_put+31p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_10005F05
		mov	edx, 4
		mov	eax, ebx
		call	sub_10005DC0
		mov	eax, [ebx+8]
		mov	edx, esi
		shr	edx, 18h
		mov	[eax], dl
		mov	edx, esi
		shr	edx, 10h
		mov	[eax+1], dl
		mov	edx, esi
		shr	edx, 8
		mov	[eax+2], dl
		mov	edx, esi
		mov	[eax+3], dl
		add	eax, 4
		sub	dword ptr [ebx+0Ch], 4
		mov	[ebx+8], eax

loc_10005EFB:				; CODE XREF: guint32_put+71j
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10005F05:				; CODE XREF: guint32_put+14j
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aGuint32_put ;	"guint32_put"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10005EFB
guint32_put	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 201. mwOpaque_put

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwOpaque_put
mwOpaque_put	proc near		; CODE XREF: mwEncryptItem_put+3Bj
					; mwMessage_put+ECp ...

Dst		= dword	ptr -18h
Src		= dword	ptr -14h
Size		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_C], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_4]
		mov	[ebp+var_8], esi
		test	ebx, ebx
		jz	short loc_10005FB3
		test	edi, edi
		jz	short loc_10005F98
		mov	esi, [edi]
		test	esi, esi
		jz	short loc_10005F98
		mov	ecx, [edi+4]
		test	ecx, ecx
		jz	short loc_10005FD1
		mov	[esp+18h+Src], esi
		mov	[esp+18h+Dst], ebx
		call	guint32_put
		mov	edx, esi
		mov	eax, ebx
		call	sub_10005DC0
		mov	edx, [ebx+8]
		mov	eax, [edi+4]
		mov	[esp+18h+Size],	esi ; Size
		mov	[esp+18h+Dst], edx ; Dst
		mov	[esp+18h+Src], eax ; Src
		call	memcpy
		add	[ebx+8], esi
		sub	[ebx+0Ch], esi

loc_10005F8B:				; CODE XREF: mwOpaque_put+9Fj
					; mwOpaque_put+BDj
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10005F98:				; CODE XREF: mwOpaque_put+1Bj
					; mwOpaque_put+21j
		mov	[ebp+arg_0], ebx
		mov	esi, [ebp+var_8]
		mov	[ebp+arg_4], 0
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	guint32_put
; ---------------------------------------------------------------------------

loc_10005FB3:				; CODE XREF: mwOpaque_put+17j
		mov	[esp+18h+Size],	offset aBNull ;	"b != NULL"
		mov	[esp+18h+Src], offset aMwopaque_put ; "mwOpaque_put"
		mov	[esp+18h+Dst], offset aMeanwhile_1 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10005F8B
; ---------------------------------------------------------------------------

loc_10005FD1:				; CODE XREF: mwOpaque_put+28j
		mov	[esp+18h+Size],	offset aODataNull ; "o->data !=	NULL"
		mov	[esp+18h+Src], offset aMwopaque_put ; "mwOpaque_put"
		mov	[esp+18h+Dst], offset aMeanwhile_1 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10005F8B
mwOpaque_put	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry   6. guint16_put

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public guint16_put
guint16_put	proc near		; CODE XREF: mwEncryptItem_put+24p
					; mwString_put+31p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_4], esi
		movzx	esi, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_10006037
		mov	edx, 2
		mov	eax, ebx
		call	sub_10005DC0
		mov	eax, [ebx+8]
		mov	edx, esi
		shr	dx, 8
		mov	[eax], dl
		mov	edx, esi
		mov	[eax+1], dl
		add	eax, 2
		sub	dword ptr [ebx+0Ch], 2
		mov	[ebx+8], eax

loc_1000602D:				; CODE XREF: guint16_put+63j
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10006037:				; CODE XREF: guint16_put+15j
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aGuint16_put ;	"guint16_put"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000602D
guint16_put	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 145. mwEncryptItem_put

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwEncryptItem_put
mwEncryptItem_put proc near		; CODE XREF: mwMessage_put+23Ep
					; mwMessage_put+3AFp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_4]
		test	esi, esi
		jz	short loc_100060A0
		test	ebx, ebx
		jz	short loc_100060C6
		movzx	eax, word ptr [ebx]
		mov	[esp+18h+var_18], esi
		mov	[esp+18h+var_14], eax
		call	guint16_put
		lea	eax, [ebx+4]
		mov	ebx, [ebp+var_8]
		mov	[ebp+arg_0], esi
		mov	esi, [ebp+var_4]
		mov	[ebp+arg_4], eax
		mov	esp, ebp
		pop	ebp
		jmp	mwOpaque_put
; ---------------------------------------------------------------------------

loc_100060A0:				; CODE XREF: mwEncryptItem_put+14j
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aMwencryptite_0 ; "mwEncryptItem_put"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning

loc_100060BC:				; CODE XREF: mwEncryptItem_put+82j
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100060C6:				; CODE XREF: mwEncryptItem_put+18j
		mov	[esp+18h+var_10], offset aEiNull ; "ei != NULL"
		mov	[esp+18h+var_14], offset aMwencryptite_0 ; "mwEncryptItem_put"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100060BC
mwEncryptItem_put endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 223. mwPutBuffer_write

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl mwPutBuffer_write(int, void *, size_t)
		public mwPutBuffer_write
mwPutBuffer_write proc near		; CODE XREF: mwSametimeList_put+41p

Dst		= dword	ptr -18h
Src		= dword	ptr -14h
Size		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_C], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_8]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_10006143
		test	edi, edi
		jz	short loc_10006169
		test	esi, esi
		jz	short loc_10006136
		mov	edx, esi
		mov	eax, ebx
		call	sub_10005DC0
		mov	eax, [ebx+8]
		mov	[esp+18h+Size],	esi ; Size
		mov	[esp+18h+Src], edi ; Src
		mov	[esp+18h+Dst], eax ; Dst
		call	memcpy
		add	[ebx+8], esi
		sub	[ebx+0Ch], esi

loc_10006136:				; CODE XREF: mwPutBuffer_write+22j
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10006143:				; CODE XREF: mwPutBuffer_write+1Aj
		mov	[ebp+arg_8], offset aBNull ; "b	!= NULL"

loc_1000614A:				; CODE XREF: mwPutBuffer_write+80j
		mov	[ebp+arg_4], offset aMwputbuffer_wr ; "mwPutBuffer_write"
		mov	ebx, [ebp+var_C]
		mov	[ebp+arg_0], offset aMeanwhile_1 ; "meanwhile"
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_10006169:				; CODE XREF: mwPutBuffer_write+1Ej
		mov	[ebp+arg_8], offset aDataNull_0	; "data	!= NULL"
		jmp	short loc_1000614A
mwPutBuffer_write endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 359. mwString_put

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl mwString_put(int,	char *)
		public mwString_put
mwString_put	proc near		; CODE XREF: mwAwareIdBlock_put+33p
					; mwAwareIdBlock_put+4Aj ...

Str		= dword	ptr -18h
Src		= dword	ptr -14h
Size		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_C], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_4]
		mov	[ebp+var_8], esi
		test	ebx, ebx
		jz	short loc_1000620B
		test	edi, edi
		jz	short loc_100061F0
		mov	[esp+18h+Str], edi ; Str
		call	strlen
		mov	[esp+18h+Str], ebx
		mov	esi, eax
		movzx	eax, ax
		mov	[esp+18h+Src], eax
		call	guint16_put
		test	esi, esi
		jnz	short loc_100061C7

loc_100061BA:				; CODE XREF: mwString_put+69j
					; mwString_put+A7j
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100061C7:				; CODE XREF: mwString_put+38j
		mov	edx, esi
		mov	eax, ebx
		call	sub_10005DC0
		mov	eax, [ebx+8]
		mov	[esp+18h+Size],	esi ; Size
		mov	[esp+18h+Src], edi ; Src
		mov	[esp+18h+Str], eax ; Dst
		call	memcpy
		add	[ebx+8], esi
		sub	[ebx+0Ch], esi
		jmp	short loc_100061BA
; ---------------------------------------------------------------------------
		align 10h

loc_100061F0:				; CODE XREF: mwString_put+1Bj
		mov	[ebp+arg_0], ebx
		mov	esi, [ebp+var_8]
		mov	[ebp+arg_4], 0
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	guint16_put
; ---------------------------------------------------------------------------

loc_1000620B:				; CODE XREF: mwString_put+17j
		mov	[esp+18h+Size],	offset aBNull ;	"b != NULL"
		mov	[esp+18h+Src], offset aMwstring_put ; "mwString_put"
		mov	[esp+18h+Str], offset aMeanwhile_1 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100061BA
mwString_put	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  24. mwAwareIdBlock_put

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareIdBlock_put
mwAwareIdBlock_put proc	near		; CODE XREF: sub_1000AE70+2Dp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_4]
		test	esi, esi
		jz	short loc_1000627F
		test	ebx, ebx
		jz	short loc_100062A5
		movzx	eax, word ptr [ebx]
		mov	[esp+18h+var_18], esi
		mov	[esp+18h+var_14], eax
		call	guint16_put
		mov	eax, [ebx+4]
		mov	[esp+18h+var_18], esi ;	int
		mov	[esp+18h+var_14], eax ;	char *
		call	mwString_put
		mov	eax, [ebx+8]
		mov	[ebp+arg_0], esi
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	[ebp+arg_4], eax
		mov	esp, ebp
		pop	ebp
		jmp	mwString_put
; ---------------------------------------------------------------------------

loc_1000627F:				; CODE XREF: mwAwareIdBlock_put+14j
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aMwawareidblo_2 ; "mwAwareIdBlock_put"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning

loc_1000629B:				; CODE XREF: mwAwareIdBlock_put+91j
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100062A5:				; CODE XREF: mwAwareIdBlock_put+18j
		mov	[esp+18h+var_10], offset aIdbNull ; "idb != NULL"
		mov	[esp+18h+var_14], offset aMwawareidblo_2 ; "mwAwareIdBlock_put"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000629B
mwAwareIdBlock_put endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 178. mwIdBlock_put

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwIdBlock_put
mwIdBlock_put	proc near		; CODE XREF: mwMessage_put+2F9p
					; mwConference_invite+38p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_4]
		test	esi, esi
		jz	short loc_1000630F
		test	ebx, ebx
		jz	short loc_10006335
		mov	eax, [ebx]
		mov	[esp+18h+var_18], esi ;	int
		mov	[esp+18h+var_14], eax ;	char *
		call	mwString_put
		mov	eax, [ebx+4]
		mov	[ebp+arg_0], esi
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	[ebp+arg_4], eax
		mov	esp, ebp
		pop	ebp
		jmp	mwString_put
; ---------------------------------------------------------------------------

loc_1000630F:				; CODE XREF: mwIdBlock_put+14j
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aMwidblock_put	; "mwIdBlock_put"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning

loc_1000632B:				; CODE XREF: mwIdBlock_put+81j
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10006335:				; CODE XREF: mwIdBlock_put+18j
		mov	[esp+18h+var_10], offset aIdNull ; "id != NULL"
		mov	[esp+18h+var_14], offset aMwidblock_put	; "mwIdBlock_put"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000632B
mwIdBlock_put	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 367. mwUserStatus_put

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwUserStatus_put
mwUserStatus_put proc near		; CODE XREF: mwMessage_put+2C7p
					; sub_10011730+29Ep

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_4]
		test	esi, esi
		jz	short loc_100063AF
		test	ebx, ebx
		jz	short loc_100063D5
		movzx	eax, word ptr [ebx]
		mov	[esp+18h+var_18], esi
		mov	[esp+18h+var_14], eax
		call	guint16_put
		mov	eax, [ebx+4]
		mov	[esp+18h+var_18], esi
		mov	[esp+18h+var_14], eax
		call	guint32_put
		mov	eax, [ebx+8]
		mov	[ebp+arg_0], esi
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	[ebp+arg_4], eax
		mov	esp, ebp
		pop	ebp
		jmp	mwString_put
; ---------------------------------------------------------------------------

loc_100063AF:				; CODE XREF: mwUserStatus_put+14j
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aMwuserstatus_p ; "mwUserStatus_put"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning

loc_100063CB:				; CODE XREF: mwUserStatus_put+91j
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100063D5:				; CODE XREF: mwUserStatus_put+18j
		mov	[esp+18h+var_10], offset aStatNull ; "stat != NULL"
		mov	[esp+18h+var_14], offset aMwuserstatus_p ; "mwUserStatus_put"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100063CB
mwUserStatus_put endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 363. mwUserItem_put

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwUserItem_put
mwUserItem_put	proc near		; CODE XREF: mwPrivacyInfo_put+70p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_0]
		mov	ebx, [ebp+arg_4]
		test	esi, esi
		jz	short loc_10006464
		test	ebx, ebx
		jz	short loc_10006482
		mov	eax, [ebx]
		mov	[esp+18h+var_18], esi
		mov	[esp+18h+var_14], eax
		call	gboolean_put
		mov	eax, [ebx+4]
		mov	[esp+18h+var_18], esi ;	int
		mov	[esp+18h+var_14], eax ;	char *
		call	mwString_put
		mov	eax, [ebx+8]
		mov	[esp+18h+var_18], esi ;	int
		mov	[esp+18h+var_14], eax ;	char *
		call	mwString_put
		mov	eax, [ebx]
		test	eax, eax
		jnz	short loc_10006450

loc_10006448:				; CODE XREF: mwUserItem_put+80j
					; mwUserItem_put+9Ej
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10006450:				; CODE XREF: mwUserItem_put+46j
		mov	eax, [ebx+0Ch]
		mov	[ebp+arg_0], esi
		mov	[ebp+arg_4], eax
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	mwString_put
; ---------------------------------------------------------------------------

loc_10006464:				; CODE XREF: mwUserItem_put+10j
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aMwuseritem_put ; "mwUserItem_put"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10006448
; ---------------------------------------------------------------------------

loc_10006482:				; CODE XREF: mwUserItem_put+14j
		mov	[esp+18h+var_10], offset aUserNull ; "user != NULL"
		mov	[esp+18h+var_14], offset aMwuseritem_put ; "mwUserItem_put"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10006448
mwUserItem_put	endp

; Exported entry 219. mwPrivacyInfo_put

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwPrivacyInfo_put
mwPrivacyInfo_put proc near		; CODE XREF: mwMessage_put+9Cp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10006521
		mov	eax, [ebp+arg_4]
		test	eax, eax
		jz	loc_1000653F
		mov	edx, [ebp+arg_4]
		mov	eax, [edx]
		mov	[esp+18h+var_14], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+18h+var_18], eax
		call	gboolean_put
		mov	edx, [ebp+arg_4]
		mov	eax, [edx+4]
		mov	[esp+18h+var_14], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+18h+var_18], eax
		call	guint32_put
		mov	edx, [ebp+arg_4]
		mov	edi, [edx+4]
		test	edi, edi
		jz	short loc_10006519
		mov	eax, edi
		xor	esi, esi
		shl	eax, 4
		lea	ebx, [eax-10h]

loc_100064F8:				; CODE XREF: mwPrivacyInfo_put+77j
		mov	edx, [ebp+arg_4]
		mov	eax, ebx
		add	esi, 1
		sub	ebx, 10h
		add	eax, [edx+8]
		mov	[esp+18h+var_14], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+18h+var_18], eax
		call	mwUserItem_put
		cmp	esi, edi
		jnz	short loc_100064F8

loc_10006519:				; CODE XREF: mwPrivacyInfo_put+4Cj
					; mwPrivacyInfo_put+9Dj ...
		add	esp, 0Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10006521:				; CODE XREF: mwPrivacyInfo_put+Ej
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aMwprivacyinf_2 ; "mwPrivacyInfo_put"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10006519
; ---------------------------------------------------------------------------

loc_1000653F:				; CODE XREF: mwPrivacyInfo_put+15j
		mov	[esp+18h+var_10], offset aInfoNull ; "info != NULL"
		mov	[esp+18h+var_14], offset aMwprivacyinf_2 ; "mwPrivacyInfo_put"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10006519
mwPrivacyInfo_put endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 184. mwLoginInfo_put

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwLoginInfo_put
mwLoginInfo_put	proc near		; CODE XREF: mwMessage_put+5F7p
					; mwMessage_put+60Bp ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_0]
		mov	ebx, [ebp+arg_4]
		test	esi, esi
		jz	loc_10006618
		test	ebx, ebx
		jz	loc_10006636
		mov	eax, [ebx]
		mov	[esp+18h+var_18], esi ;	int
		mov	[esp+18h+var_14], eax ;	char *
		call	mwString_put
		movzx	eax, word ptr [ebx+4]
		mov	[esp+18h+var_18], esi
		mov	[esp+18h+var_14], eax
		call	guint16_put
		mov	eax, [ebx+8]
		mov	[esp+18h+var_18], esi ;	int
		mov	[esp+18h+var_14], eax ;	char *
		call	mwString_put
		mov	eax, [ebx+0Ch]
		mov	[esp+18h+var_18], esi ;	int
		mov	[esp+18h+var_14], eax ;	char *
		call	mwString_put
		mov	eax, [ebx+10h]
		mov	[esp+18h+var_18], esi ;	int
		mov	[esp+18h+var_14], eax ;	char *
		call	mwString_put
		mov	eax, [ebx+14h]
		mov	[esp+18h+var_18], esi
		mov	[esp+18h+var_14], eax
		call	gboolean_put
		mov	eax, [ebx+14h]
		test	eax, eax
		jnz	short loc_100065E6

loc_100065DF:				; CODE XREF: mwLoginInfo_put+D4j
					; mwLoginInfo_put+F2j
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100065E6:				; CODE XREF: mwLoginInfo_put+7Dj
		mov	eax, [ebx+18h]
		mov	[esp+18h+var_18], esi ;	int
		mov	[esp+18h+var_14], eax ;	char *
		call	mwString_put
		mov	eax, [ebx+1Ch]
		mov	[esp+18h+var_18], esi
		mov	[esp+18h+var_14], eax
		call	guint32_put
		mov	eax, [ebx+20h]
		mov	[ebp+arg_0], esi
		mov	[ebp+arg_4], eax
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	mwString_put
; ---------------------------------------------------------------------------

loc_10006618:				; CODE XREF: mwLoginInfo_put+10j
		mov	[esp+18h+var_10], offset aBNull	; "b !=	NULL"
		mov	[esp+18h+var_14], offset aMwlogininfo_pu ; "mwLoginInfo_put"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100065DF
; ---------------------------------------------------------------------------

loc_10006636:				; CODE XREF: mwLoginInfo_put+18j
		mov	[esp+18h+var_10], offset aLoginNull ; "login !=	NULL"
		mov	[esp+18h+var_14], offset aMwlogininfo_pu ; "mwLoginInfo_put"
		mov	[esp+18h+var_18], offset aMeanwhile_1 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100065DF
mwLoginInfo_put	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 146. mwError

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwError
mwError		proc near

Dest		= dword	ptr -18h
Format		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	edx, offset aIncorrectUsern ; "Incorrect Username/Password"
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		cmp	eax, 80000211h
		jz	short loc_100066D0
		jbe	short loc_100066E0
		cmp	eax, 80000227h
		mov	edx, offset aLoginToTwoDiff ; "Login to	two different servers concurre"...
		jz	short loc_100066D0
		jbe	loc_10006730
		cmp	eax, 80002001h
		mov	edx, offset aUserIsInDoNotD ; "User is in Do Not Disturb mode"
		jz	short loc_100066D0
		jbe	loc_10006830
		cmp	eax, 80002003h
		mov	edx, offset aCannotRegister ; "Cannot register a reserved type"
		jz	short loc_100066D0
		jb	loc_100068A0
		cmp	eax, 80002004h
		mov	edx, offset aRequestedTypeI ; "Requested type is already registered"
		jz	short loc_100066D0
		cmp	eax, 80002005h
		mov	edx, offset aRequestedTyp_0 ; "Requested type is not registered"
		jnz	loc_100067E2
		lea	esi, [esi+0]

loc_100066D0:				; CODE XREF: mwError+13j mwError+21j ...
		mov	[ebp+arg_0], edx
		leave
		jmp	g_strdup
; ---------------------------------------------------------------------------
		align 10h

loc_100066E0:				; CODE XREF: mwError+15j
		cmp	eax, 8000000Dh
		mov	edx, offset aRequestedServi ; "Requested service is not	supported"
		jz	short loc_100066D0
		jbe	loc_10006777
		cmp	eax, 80000013h
		mov	edx, offset aAlreadyInitial ; "Already initialized"
		jz	short loc_100066D0
		xchg	ax, ax
		jbe	loc_100067B7
		cmp	eax, 80000021h
		mov	edx, offset aNoCommonEncryp ; "No common encryption method"
		jz	short loc_100066D0
		ja	loc_100068BE
		cmp	eax, 8000001Dh
		jnz	loc_100067E2
		mov	edx, offset aEncryptionMeth ; "Encryption method not supported"
		jmp	short loc_100066D0
; ---------------------------------------------------------------------------
		align 10h

loc_10006730:				; CODE XREF: mwError+23j
		cmp	eax, 80000222h
		mov	edx, offset aConnectionAbor ; "Connection aborted"
		jz	short loc_100066D0
		jbe	loc_10006861
		cmp	eax, 80000224h
		mov	edx, offset aConnectionRese ; "Connection reset"
		jz	short loc_100066D0
		xchg	ax, ax
		jb	loc_100068B4
		cmp	eax, 80000225h
		mov	edx, offset aConnectionTime ; "Connection timed	out"
		jz	loc_100066D0
		cmp	eax, 80000226h
		jnz	short loc_100067E2
		mov	edx, offset aConnectionClos ; "Connection closed"
		jmp	loc_100066D0
; ---------------------------------------------------------------------------

loc_10006777:				; CODE XREF: mwError+8Cj
		cmp	eax, 80000001h
		mov	edx, offset aRequestIsInval ; "Request is invalid"
		jz	loc_100066D0
		jbe	loc_1000680B
		cmp	eax, 80000006h
		mov	edx, offset aUserIsNotOnlin ; "User is not online"
		jz	loc_100066D0
		lea	esi, [esi+0]
		ja	loc_100068E3
		cmp	eax, 80000003h
		jnz	short loc_100067E2
		mov	edx, offset aNotAuthorized ; "Not authorized"
		jmp	loc_100066D0
; ---------------------------------------------------------------------------

loc_100067B7:				; CODE XREF: mwError+A0j
		cmp	eax, 80000010h
		mov	edx, offset aVersionIsNotSu ; "Version is not supported"
		jz	loc_100066D0
		cmp	eax, 80000011h
		mov	edx, offset aUserIsInvalidO ; "User is invalid or not trusted"
		jz	loc_100066D0
		cmp	eax, 8000000Eh
		jz	loc_10006896

loc_100067E2:				; CODE XREF: mwError+63j mwError+BDj ...
		mov	[esp+18h+var_10], eax
		mov	[esp+18h+Format], offset Format	; "0x%08x"
		mov	[esp+18h+Dest],	offset Dest ; Dest
		call	sprintf
		mov	edx, offset Dest
		mov	ds:byte_1002102A, 0
		jmp	loc_100066D0
; ---------------------------------------------------------------------------

loc_1000680B:				; CODE XREF: mwError+127j
		cmp	eax, 1
		mov	edx, offset aRequestDelayed ; "Request delayed"
		jz	loc_100066D0
		jb	loc_100068AA
		cmp	eax, 80000000h
		jnz	short loc_100067E2
		mov	edx, offset aGeneralFailure ; "General failure"
		jmp	loc_100066D0
; ---------------------------------------------------------------------------

loc_10006830:				; CODE XREF: mwError+35j
		cmp	eax, 8000022Bh
		mov	edx, offset aServerMisconfi ; "Server misconfiguration"
		jz	loc_100066D0
		cmp	eax, 80002000h
		mov	edx, offset aUserIsNotOnlin ; "User is not online"
		jz	loc_100066D0
		cmp	eax, 80000228h
		jnz	short loc_100067E2
		mov	edx, offset aLoginToTwoDiff ; "Login to	two different servers concurre"...
		jmp	loc_100066D0
; ---------------------------------------------------------------------------

loc_10006861:				; CODE XREF: mwError+DCj
		cmp	eax, 80000217h
		mov	edx, offset aTheGuestNameIs ; "The guest name is currently being used"
		jz	loc_100066D0
		cmp	eax, 80000221h
		mov	edx, offset aConnectionBrok ; "Connection broken"
		jz	loc_100066D0
		cmp	eax, 80000214h
		jnz	loc_100067E2
		mov	edx, offset aLoginVerificat ; "Login verification down or unavailable"
		jmp	loc_100066D0
; ---------------------------------------------------------------------------

loc_10006896:				; CODE XREF: mwError+17Cj
		mov	edx, offset aRequestedProto ; "Requested protocol is not supported"
		jmp	loc_100066D0
; ---------------------------------------------------------------------------

loc_100068A0:				; CODE XREF: mwError+47j
		mov	edx, offset aAlreadyLoggedI ; "Already logged in elsewhere"
		jmp	loc_100066D0
; ---------------------------------------------------------------------------

loc_100068AA:				; CODE XREF: mwError+1B9j
		mov	edx, offset aSuccess ; "Success"
		jmp	loc_100066D0
; ---------------------------------------------------------------------------

loc_100068B4:				; CODE XREF: mwError+F0j
		mov	edx, offset aConnectionRefu ; "Connection refused"
		jmp	loc_100066D0
; ---------------------------------------------------------------------------

loc_100068BE:				; CODE XREF: mwError+B2j
		cmp	eax, 80000200h
		mov	edx, offset aVersionMismatc ; "Version mismatch"
		jz	loc_100066D0
		cmp	eax, 80000209h
		jnz	loc_100067E2
		mov	edx, offset aMessageIsTooLa ; "Message is too large"
		jmp	loc_100066D0
; ---------------------------------------------------------------------------

loc_100068E3:				; CODE XREF: mwError+140j
		cmp	eax, 8000000Bh
		mov	edx, offset aRequestedChann ; "Requested channel is not	supported"
		jz	loc_100066D0
		cmp	eax, 8000000Ch
		jnz	loc_100067E2
		mov	edx, offset aRequestedCha_0 ; "Requested channel already exists"
		jmp	loc_100066D0
mwError		endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10006910	proc near		; CODE XREF: mwMessage_free+15p
					; mwMessage_get+C8p ...

var_8		= dword	ptr -8

		push	ebp
		add	eax, 8
		mov	ebp, esp
		sub	esp, 8
		mov	[esp+8+var_8], eax
		call	mwOpaque_clear
		leave
		retn
sub_10006910	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 185. mwMessage_free

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwMessage_free
mwMessage_free	proc near		; CODE XREF: sub_10001E60+54p
					; sub_10001E60+99p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_0]
		test	esi, esi
		jz	loc_10006A30
		mov	eax, esi
		call	sub_10006910
		movzx	eax, word ptr [esi]
		cmp	ax, 9
		jz	loc_10006B73
		jbe	short loc_100069B4
		cmp	ax, 19h
		lea	esi, [esi+0]
		jz	loc_10006A50
		ja	loc_10006A67
		cmp	ax, 0Bh
		jz	loc_10006B85
		cmp	ax, 18h
		lea	esi, [esi+0]
		jnz	short loc_100069A6
		mov	eax, [esi+10h]
		mov	[esp+18h+var_18], eax
		call	g_free
		mov	eax, [esi+14h]
		mov	dword ptr [esi+10h], 0
		mov	[esp+18h+var_18], eax
		call	g_free
		mov	dword ptr [esi+14h], 0

loc_100069A6:				; CODE XREF: mwMessage_free+50j
					; mwMessage_free+A0j ...
		mov	[ebp+arg_0], esi
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	g_free
; ---------------------------------------------------------------------------

loc_100069B4:				; CODE XREF: mwMessage_free+27j
		cmp	ax, 3
		jz	short loc_10006A37
		ja	loc_10006B00
		cmp	ax, 1
		jz	loc_10006AD5
		cmp	ax, 2
		xchg	ax, ax
		jnz	short loc_100069A6
		lea	eax, [esi+18h]
		mov	[esp+18h+var_18], eax
		call	mwIdBlock_clear
		lea	eax, [esi+30h]
		mov	[esp+18h+var_18], eax
		call	mwOpaque_clear
		lea	eax, [esi+3Ch]
		mov	[esp+18h+var_18], eax
		call	mwLoginInfo_clear
		mov	eax, [esi+64h]
		test	eax, eax
		mov	ebx, eax
		jz	short loc_10006A1E
		lea	esi, [esi+0]

loc_10006A00:				; CODE XREF: mwMessage_free+E9j
		mov	eax, [ebx]
		mov	[esp+18h+var_18], eax
		call	mwEncryptItem_clear
		mov	eax, [ebx]
		mov	[esp+18h+var_18], eax
		call	g_free
		mov	ebx, [ebx+4]
		test	ebx, ebx
		jnz	short loc_10006A00
		mov	eax, [esi+64h]

loc_10006A1E:				; CODE XREF: mwMessage_free+CAj
		mov	[esp+18h+var_18], eax
		call	g_list_free
		jmp	loc_100069A6
; ---------------------------------------------------------------------------
		align 10h

loc_10006A30:				; CODE XREF: mwMessage_free+Dj
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10006A37:				; CODE XREF: mwMessage_free+88j
					; mwMessage_free+1D4j
		lea	eax, [esi+14h]
		mov	[esp+18h+var_18], eax
		call	mwOpaque_clear
		mov	[ebp+arg_0], esi
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	g_free
; ---------------------------------------------------------------------------

loc_10006A50:				; CODE XREF: mwMessage_free+30j
		mov	eax, [esi+10h]
		mov	[esp+18h+var_18], eax
		call	g_free
		mov	dword ptr [esi+10h], 0
		jmp	loc_100069A6
; ---------------------------------------------------------------------------

loc_10006A67:				; CODE XREF: mwMessage_free+36j
		cmp	ax, 8000h
		jz	short loc_10006AE7
		cmp	ax, 8001h
		jz	loc_10006B4D
		cmp	ax, 22h
		nop
		lea	esi, [esi+0]
		jnz	loc_100069A6
		lea	eax, [esi+14h]
		mov	[esp+18h+var_18], eax
		call	mwLoginInfo_clear
		mov	eax, [esi+40h]
		mov	[esp+18h+var_18], eax
		call	g_free
		mov	eax, [esi+44h]
		mov	dword ptr [esi+40h], 0
		test	eax, eax
		jz	loc_100069A6
		xchg	ax, ax

loc_10006AB0:				; CODE XREF: mwMessage_free+19Ej
		mov	eax, [eax]
		mov	[esp+18h+var_18], eax
		call	g_free
		mov	eax, [esi+44h]
		mov	[esp+18h+var_14], eax
		mov	[esp+18h+var_18], eax
		call	g_list_delete_link
		test	eax, eax
		mov	[esi+44h], eax
		jnz	short loc_10006AB0
		jmp	loc_100069A6
; ---------------------------------------------------------------------------

loc_10006AD5:				; CODE XREF: mwMessage_free+94j
		mov	eax, [esi+14h]
		mov	[esp+18h+var_18], eax
		call	g_free
		mov	dword ptr [esi+14h], 0

loc_10006AE7:				; CODE XREF: mwMessage_free+13Bj
		lea	eax, [esi+1Ch]
		mov	[esp+18h+var_18], eax
		call	mwOpaque_clear
		mov	[ebp+arg_0], esi
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	g_free
; ---------------------------------------------------------------------------

loc_10006B00:				; CODE XREF: mwMessage_free+8Aj
		cmp	ax, 4
		jz	loc_10006A37
		cmp	ax, 6
		jnz	loc_100069A6
		lea	eax, [esi+1Ch]
		mov	[esp+18h+var_18], eax
		call	mwOpaque_clear
		lea	eax, [esi+28h]
		mov	[esp+18h+var_18], eax
		call	mwLoginInfo_clear
		mov	eax, [esi+50h]
		test	eax, eax
		jz	loc_100069A6
		mov	[esp+18h+var_18], eax
		call	mwEncryptItem_clear
		mov	eax, [esi+50h]
		mov	[esp+18h+var_18], eax
		call	g_free
		jmp	loc_100069A6
; ---------------------------------------------------------------------------

loc_10006B4D:				; CODE XREF: mwMessage_free+141j
		lea	eax, [esi+10h]
		mov	[esp+18h+var_18], eax
		call	mwLoginInfo_clear
		lea	eax, [esi+34h]
		mov	[esp+18h+var_18], eax
		call	mwPrivacyInfo_clear
		lea	eax, [esi+40h]
		mov	[esp+18h+var_18], eax
		call	mwUserStatus_clear
		jmp	loc_100069A6
; ---------------------------------------------------------------------------

loc_10006B73:				; CODE XREF: mwMessage_free+21j
		lea	eax, [esi+10h]
		mov	[esp+18h+var_18], eax
		call	mwUserStatus_clear
		xchg	ax, ax
		jmp	loc_100069A6
; ---------------------------------------------------------------------------

loc_10006B85:				; CODE XREF: mwMessage_free+40j
		lea	eax, [esi+10h]
		mov	[esp+18h+var_18], eax
		call	mwPrivacyInfo_clear
		jmp	loc_100069A6
mwMessage_free	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 188. mwMessage_put

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwMessage_put
mwMessage_put	proc near		; CODE XREF: mwSession_send+31p

var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 2Ch
		mov	edi, [ebp+arg_0]
		mov	esi, [ebp+arg_4]
		test	edi, edi
		jz	loc_100071C9
		test	esi, esi
		jz	loc_100071EA
		movzx	eax, word ptr [esi]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint16_put
		movzx	eax, word ptr [esi+2]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint16_put
		mov	eax, [esi+4]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint32_put
		cmp	word ptr [esi+2], 0
		js	loc_10006D40
		movzx	eax, word ptr [esi]
		cmp	ax, 6
		jz	loc_10006D60

loc_10006C05:				; CODE XREF: mwMessage_put+1B6j
		jbe	short loc_10006C50
		cmp	ax, 11h
		nop
		lea	esi, [esi+0]
		jz	loc_10007055
		ja	short loc_10006C93
		cmp	ax, 9
		lea	esi, [esi+0]
		jz	loc_10006E5D
		cmp	ax, 0Bh
		lea	esi, [esi+0]
		jnz	short loc_10006C41
		lea	eax, [esi+10h]
		mov	[esp+38h+var_34], eax
		mov	[esp+38h+var_38], edi
		call	mwPrivacyInfo_put

loc_10006C41:				; CODE XREF: mwMessage_put+90j
					; mwMessage_put+D0j ...
		add	esp, 2Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10006C50:				; CODE XREF: mwMessage_put:loc_10006C05j
		cmp	ax, 2
		jz	loc_10006E71
		jbe	short loc_10006CD5
		cmp	ax, 3
		jz	loc_10007032
		cmp	ax, 4
		lea	esi, [esi+0]
		jnz	short loc_10006C41
		movzx	eax, word ptr [esi+10h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint16_put
		lea	eax, [esi+14h]
		mov	[esp+38h+var_34], eax
		mov	[esp+38h+var_38], edi
		call	mwOpaque_put
		jmp	short loc_10006C41
; ---------------------------------------------------------------------------

loc_10006C93:				; CODE XREF: mwMessage_put+76j
		cmp	ax, 22h
		jz	loc_100070D1
		cmp	ax, 8000h
		jz	loc_10007069
		cmp	ax, 18h
		nop
		lea	esi, [esi+0]
		jnz	short loc_10006C41
		mov	eax, [esi+10h]
		mov	[esp+38h+var_38], edi ;	int
		mov	[esp+38h+var_34], eax ;	char *
		call	mwString_put
		mov	eax, [esi+14h]
		mov	[esp+38h+var_38], edi ;	int
		mov	[esp+38h+var_34], eax ;	char *
		call	mwString_put
		jmp	loc_10006C41
; ---------------------------------------------------------------------------

loc_10006CD5:				; CODE XREF: mwMessage_put+BAj
		test	ax, ax
		jz	loc_10006F8C
		sub	ax, 1
		jnz	loc_10006C41
		movzx	eax, word ptr [esi+10h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint16_put
		mov	eax, [esi+14h]
		mov	[esp+38h+var_38], edi ;	int
		mov	[esp+38h+var_34], eax ;	char *
		call	mwString_put
		lea	eax, [esi+1Ch]
		mov	[esp+38h+var_34], eax
		mov	[esp+38h+var_38], edi
		call	mwOpaque_put
		movzx	eax, word ptr [esi+18h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint16_put
		mov	[esp+38h+var_34], 0
		mov	[esp+38h+var_38], edi
		call	guint16_put
		jmp	loc_10006C41
; ---------------------------------------------------------------------------
		align 10h

loc_10006D40:				; CODE XREF: mwMessage_put+52j
		lea	eax, [esi+8]
		mov	[esp+38h+var_34], eax
		mov	[esp+38h+var_38], edi
		call	mwOpaque_put
		movzx	eax, word ptr [esi]
		cmp	ax, 6
		jnz	loc_10006C05
		lea	esi, [esi+0]

loc_10006D60:				; CODE XREF: mwMessage_put+5Fj
		mov	eax, [esi+10h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint32_put
		mov	eax, [esi+14h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint32_put
		mov	eax, [esi+18h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint32_put
		lea	eax, [esi+1Ch]
		mov	[esp+38h+var_34], eax
		mov	[esp+38h+var_38], edi
		call	mwOpaque_put
		mov	eax, [esi+24h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	gboolean_put
		mov	ecx, [esi+24h]
		test	ecx, ecx
		jnz	loc_100071B5

loc_10006DB6:				; CODE XREF: mwMessage_put+624j
		movzx	eax, word ptr [esi+4Ch]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint16_put
		mov	edx, [esi+50h]
		test	edx, edx
		jz	short loc_10006E25
		call	mwPutBuffer_new
		mov	ebx, eax
		mov	eax, [esi+50h]
		mov	[esp+38h+var_38], ebx
		mov	[esp+38h+var_34], eax
		call	mwEncryptItem_put
		movzx	eax, word ptr [esi+54h]
		mov	[esp+38h+var_38], ebx
		mov	[esp+38h+var_34], eax
		call	guint16_put
		mov	eax, [esi+58h]
		mov	[esp+38h+var_38], ebx
		mov	[esp+38h+var_34], eax
		call	gboolean_put
		mov	[esp+38h+var_34], ebx

loc_10006E06:				; CODE XREF: mwMessage_put+3E7j
		lea	ebx, [ebp+var_14]
		mov	[esp+38h+var_38], ebx
		call	mwPutBuffer_finalize
		mov	[esp+38h+var_34], ebx
		mov	[esp+38h+var_38], edi
		call	mwOpaque_put
		mov	[esp+38h+var_38], ebx
		call	mwOpaque_clear

loc_10006E25:				; CODE XREF: mwMessage_put+22Bj
					; mwMessage_put+378j
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], 0
		call	guint32_put
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], 0
		call	guint32_put
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], 7
		call	guint16_put
		add	esp, 2Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10006E5D:				; CODE XREF: mwMessage_put+80j
		lea	eax, [esi+10h]
		mov	[esp+38h+var_34], eax
		mov	[esp+38h+var_38], edi
		call	mwUserStatus_put
		jmp	loc_10006C41
; ---------------------------------------------------------------------------

loc_10006E71:				; CODE XREF: mwMessage_put+B4j
		mov	eax, [esi+10h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint32_put
		mov	eax, [esi+14h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint32_put
		lea	eax, [esi+18h]
		mov	[esp+38h+var_34], eax
		mov	[esp+38h+var_38], edi
		call	mwIdBlock_put
		mov	eax, [esi+20h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint32_put
		mov	eax, [esi+24h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint32_put
		mov	eax, [esi+28h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint32_put
		mov	eax, [esi+2Ch]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint32_put
		lea	eax, [esi+30h]
		mov	[esp+38h+var_34], eax
		mov	[esp+38h+var_38], edi
		call	mwOpaque_put
		mov	eax, [esi+38h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	gboolean_put
		mov	ebx, [esi+38h]
		test	ebx, ebx
		jnz	loc_100071A1

loc_10006F03:				; CODE XREF: mwMessage_put+610j
		movzx	eax, word ptr [esi+60h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint16_put
		mov	eax, [esi+64h]
		test	eax, eax
		jz	loc_10006E25
		mov	[esp+38h+var_38], eax
		call	g_list_length
		mov	ebx, eax
		call	mwPutBuffer_new
		mov	[ebp+var_20], eax
		mov	[esp+38h+var_34], ebx
		mov	[esp+38h+var_38], eax
		call	guint32_put
		mov	ebx, [esi+64h]
		test	ebx, ebx
		jz	short loc_10006F5B

loc_10006F43:				; CODE XREF: mwMessage_put+3B9j
		mov	eax, [ebx]
		mov	[esp+38h+var_34], eax
		mov	eax, [ebp+var_20]
		mov	[esp+38h+var_38], eax
		call	mwEncryptItem_put
		mov	ebx, [ebx+4]
		test	ebx, ebx
		jnz	short loc_10006F43

loc_10006F5B:				; CODE XREF: mwMessage_put+3A1j
		movzx	eax, word ptr [esi+68h]
		mov	[esp+38h+var_34], eax
		mov	eax, [ebp+var_20]
		mov	[esp+38h+var_38], eax
		call	guint16_put
		mov	eax, [esi+6Ch]
		mov	[esp+38h+var_34], eax
		mov	eax, [ebp+var_20]
		mov	[esp+38h+var_38], eax
		call	gboolean_put
		mov	eax, [ebp+var_20]
		mov	[esp+38h+var_34], eax
		jmp	loc_10006E06
; ---------------------------------------------------------------------------

loc_10006F8C:				; CODE XREF: mwMessage_put+138j
		movzx	eax, word ptr [esi+10h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint16_put
		movzx	eax, word ptr [esi+12h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint16_put
		mov	eax, [esi+4]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint32_put
		mov	eax, [esi+14h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint32_put
		movzx	eax, word ptr [esi+18h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint16_put
		mov	eax, [esi+1Ch]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint32_put
		cmp	word ptr [esi+10h], 1Dh
		jbe	loc_10006C41
		cmp	word ptr [esi+12h], 1Ch
		jbe	loc_10006C41
		movzx	eax, word ptr [esi+20h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint16_put
		mov	eax, [esi+24h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint32_put
		mov	eax, [esi+28h]
		mov	[esp+38h+var_38], edi ;	int
		mov	[esp+38h+var_34], eax ;	char *
		call	mwString_put
		jmp	loc_10006C41
; ---------------------------------------------------------------------------

loc_10007032:				; CODE XREF: mwMessage_put+C0j
		mov	eax, [esi+10h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint32_put
		lea	eax, [esi+14h]
		mov	[esp+38h+var_34], eax
		mov	[esp+38h+var_38], edi
		call	mwOpaque_put
		jmp	loc_10006C41
; ---------------------------------------------------------------------------

loc_10007055:				; CODE XREF: mwMessage_put+70j
		mov	eax, [esi+10h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint32_put
		jmp	loc_10006C41
; ---------------------------------------------------------------------------

loc_10007069:				; CODE XREF: mwMessage_put+101j
		movzx	eax, word ptr [esi+10h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint16_put
		movzx	eax, word ptr [esi+12h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint16_put
		mov	eax, [esi+14h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint32_put
		cmp	word ptr [esi+10h], 1Dh
		jbe	loc_10006C41
		cmp	word ptr [esi+12h], 18h
		jbe	loc_10006C41
		mov	eax, [esi+18h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint32_put
		lea	eax, [esi+1Ch]
		mov	[esp+38h+var_34], eax
		mov	[esp+38h+var_38], edi
		call	mwOpaque_put
		jmp	loc_10006C41
; ---------------------------------------------------------------------------

loc_100070D1:				; CODE XREF: mwMessage_put+F7j
		mov	[ebp+var_14], 0
		mov	eax, [esi+10h]
		mov	[ebp+var_10], 0
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	gboolean_put
		mov	eax, [esi+10h]
		test	eax, eax
		jnz	loc_1000718D

loc_100070F9:				; CODE XREF: mwMessage_put+5FCj
		movzx	eax, word ptr [esi+38h]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint16_put
		call	mwPutBuffer_new
		mov	ebx, eax
		mov	eax, [esi+3Ch]
		mov	[esp+38h+var_38], ebx
		mov	[esp+38h+var_34], eax
		call	gboolean_put
		mov	eax, [esi+40h]
		mov	[esp+38h+var_38], ebx ;	int
		mov	[esp+38h+var_34], eax ;	char *
		call	mwString_put
		mov	[esp+38h+var_34], ebx
		lea	ebx, [ebp+var_14]
		mov	[esp+38h+var_38], ebx
		call	mwPutBuffer_finalize
		mov	[esp+38h+var_34], ebx
		mov	[esp+38h+var_38], edi
		call	mwOpaque_put
		mov	[esp+38h+var_38], ebx
		call	mwOpaque_clear
		mov	eax, [esi+44h]
		mov	[esp+38h+var_38], eax
		call	g_list_length
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint32_put
		mov	ebx, [esi+44h]
		test	ebx, ebx
		jz	loc_10006C41

loc_10007173:				; CODE XREF: mwMessage_put+5E6j
		mov	eax, [ebx]
		mov	[esp+38h+var_38], edi ;	int
		mov	[esp+38h+var_34], eax ;	char *
		call	mwString_put
		mov	ebx, [ebx+4]
		test	ebx, ebx
		jnz	short loc_10007173
		jmp	loc_10006C41
; ---------------------------------------------------------------------------

loc_1000718D:				; CODE XREF: mwMessage_put+553j
		lea	eax, [esi+14h]
		mov	[esp+38h+var_34], eax
		mov	[esp+38h+var_38], edi
		call	mwLoginInfo_put
		jmp	loc_100070F9
; ---------------------------------------------------------------------------

loc_100071A1:				; CODE XREF: mwMessage_put+35Dj
		lea	eax, [esi+3Ch]
		mov	[esp+38h+var_34], eax
		mov	[esp+38h+var_38], edi
		call	mwLoginInfo_put
		jmp	loc_10006F03
; ---------------------------------------------------------------------------

loc_100071B5:				; CODE XREF: mwMessage_put+210j
		lea	eax, [esi+28h]
		mov	[esp+38h+var_34], eax
		mov	[esp+38h+var_38], edi
		call	mwLoginInfo_put
		jmp	loc_10006DB6
; ---------------------------------------------------------------------------

loc_100071C9:				; CODE XREF: mwMessage_put+11j
		mov	[esp+38h+var_30], offset aBNull_0 ; "b != NULL"
		mov	[esp+38h+var_34], offset aMwmessage_put	; "mwMessage_put"
		mov	[esp+38h+var_38], offset aMeanwhile_2 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10006C41
; ---------------------------------------------------------------------------

loc_100071EA:				; CODE XREF: mwMessage_put+19j
		mov	[esp+38h+var_30], offset aMsgNull_0 ; "msg != NULL"
		mov	[esp+38h+var_34], offset aMwmessage_put	; "mwMessage_put"
		mov	[esp+38h+var_38], offset aMeanwhile_2 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10006C41
mwMessage_put	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 187. mwMessage_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwMessage_new
mwMessage_new	proc near		; CODE XREF: mwChannel_destroy+4Bp
					; mwChannel_sendEncrypted+21p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		cmp	eax, 0Bh
		jz	loc_10007380
		jbe	short loc_10007283
		cmp	eax, 19h
		jz	loc_100073D0
		lea	esi, [esi+0]
		jbe	loc_100072C0
		cmp	eax, 8000h
		nop
		lea	esi, [esi+0]
		jz	loc_100073A6
		cmp	eax, 8001h
		nop
		lea	esi, [esi+0]
		jz	loc_10007393
		cmp	eax, 22h
		jz	loc_1000732F

loc_1000725F:				; CODE XREF: mwMessage_new+99j
					; mwMessage_new+C9j
		mov	[esp+18h+var_C], eax
		mov	[esp+18h+var_10], offset aUnknownMessage ; "unknown message type 0x%02x\n"
		mov	[esp+18h+var_14], 10h
		mov	[esp+18h+var_18], offset aMeanwhile_2 ;	"meanwhile"
		call	g_log
		xor	eax, eax
		leave
		retn
; ---------------------------------------------------------------------------

loc_10007283:				; CODE XREF: mwMessage_new+12j
		cmp	eax, 3
		jz	loc_10007368
		lea	esi, [esi+0]
		jbe	short loc_100072F2
		cmp	eax, 6
		jz	loc_10007355
		cmp	eax, 9
		xchg	ax, ax
		jz	loc_10007342
		cmp	eax, 4
		jnz	short loc_1000725F
		mov	[esp+18h+var_18], 1Ch
		call	g_malloc0
		mov	word ptr [eax],	4
		leave
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_100072C0:				; CODE XREF: mwMessage_new+20j
		cmp	eax, 16h
		jz	loc_100073F6
		cmp	eax, 18h
		lea	esi, [esi+0]
		jz	loc_100073E3
		cmp	eax, 11h
		jnz	loc_1000725F
		mov	[esp+18h+var_18], 14h
		call	g_malloc0
		mov	word ptr [eax],	11h
		leave
		retn
; ---------------------------------------------------------------------------

loc_100072F2:				; CODE XREF: mwMessage_new+80j
		cmp	eax, 1
		jz	loc_100073B9
		nop
		lea	esi, [esi+0]
		jbe	short loc_1000731C
		mov	[esp+18h+var_18], 70h
		lea	esi, [esi+0]
		call	g_malloc0
		mov	word ptr [eax],	2
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000731C:				; CODE XREF: mwMessage_new+F0j
		mov	[esp+18h+var_18], 2Ch
		call	g_malloc0
		mov	word ptr [eax],	0
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000732F:				; CODE XREF: mwMessage_new+49j
		mov	[esp+18h+var_18], 48h
		call	g_malloc0
		mov	word ptr [eax],	22h
		leave
		retn
; ---------------------------------------------------------------------------

loc_10007342:				; CODE XREF: mwMessage_new+90j
		mov	[esp+18h+var_18], 1Ch
		call	g_malloc0
		mov	word ptr [eax],	9
		leave
		retn
; ---------------------------------------------------------------------------

loc_10007355:				; CODE XREF: mwMessage_new+85j
		mov	[esp+18h+var_18], 5Ch
		call	g_malloc0
		mov	word ptr [eax],	6
		leave
		retn
; ---------------------------------------------------------------------------

loc_10007368:				; CODE XREF: mwMessage_new+76j
		mov	[esp+18h+var_18], 1Ch
		call	g_malloc0
		mov	word ptr [eax],	3
		leave
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10007380:				; CODE XREF: mwMessage_new+Cj
		mov	[esp+18h+var_18], 1Ch
		call	g_malloc0
		mov	word ptr [eax],	0Bh
		leave
		retn
; ---------------------------------------------------------------------------

loc_10007393:				; CODE XREF: mwMessage_new+40j
		mov	[esp+18h+var_18], 4Ch
		call	g_malloc0
		mov	word ptr [eax],	8001h
		leave
		retn
; ---------------------------------------------------------------------------

loc_100073A6:				; CODE XREF: mwMessage_new+30j
		mov	[esp+18h+var_18], 24h
		call	g_malloc0
		mov	word ptr [eax],	8000h
		leave
		retn
; ---------------------------------------------------------------------------

loc_100073B9:				; CODE XREF: mwMessage_new+E5j
		mov	[esp+18h+var_18], 24h
		call	g_malloc0
		mov	word ptr [eax],	1
		leave
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_100073D0:				; CODE XREF: mwMessage_new+17j
		mov	[esp+18h+var_18], 14h
		call	g_malloc0
		mov	word ptr [eax],	19h
		leave
		retn
; ---------------------------------------------------------------------------

loc_100073E3:				; CODE XREF: mwMessage_new+C0j
		mov	[esp+18h+var_18], 18h
		call	g_malloc0
		mov	word ptr [eax],	18h
		leave
		retn
; ---------------------------------------------------------------------------

loc_100073F6:				; CODE XREF: mwMessage_new+B3j
		mov	[esp+18h+var_18], 10h
		call	g_malloc0
		mov	word ptr [eax],	16h
		leave
		retn
mwMessage_new	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10007410	proc near		; CODE XREF: mwMessage_get+11Dp
					; mwMessage_get+1D1p ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		movzx	ecx, word ptr [edx]
		mov	[eax], cx
		movzx	ecx, word ptr [edx+2]
		mov	[eax+2], cx
		mov	ecx, [edx+4]
		add	edx, 8
		mov	[eax+4], ecx
		add	eax, 8
		mov	[esp+8+var_4], edx
		mov	[esp+8+var_8], eax
		call	mwOpaque_clone
		leave
		retn
sub_10007410	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 186. mwMessage_get

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwMessage_get
mwMessage_get	proc near		; CODE XREF: sub_10009A60+48p

var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_4C		= dword	ptr -4Ch
var_34		= word ptr -34h
var_32		= word ptr -32h
var_30		= byte ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_E		= byte ptr -0Eh
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 4Ch
		mov	edi, [ebp+arg_0]
		test	edi, edi
		jz	loc_10007D7F
		mov	[ebp+var_2C], 0
		mov	[ebp+var_28], 0
		mov	[esp+58h+var_58], edi
		call	mwGetBuffer_error
		test	eax, eax
		jz	loc_10007591

loc_10007472:				; CODE XREF: mwMessage_get+183j
					; mwMessage_get+198j
		mov	[esp+58h+var_58], edi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_10007D54
		movzx	eax, [ebp+var_34]
		cmp	ax, 0Bh
		jz	loc_10007A20
		jbe	loc_10007517
		cmp	ax, 19h
		jz	loc_10007A5A
		jbe	loc_100075E0
		cmp	ax, 8000h
		lea	esi, [esi+0]
		jz	loc_10007B98
		cmp	ax, 8001h
		lea	esi, [esi+0]
		jz	loc_10007B31
		cmp	ax, 22h
		jz	loc_10007890

loc_100074D0:				; CODE XREF: mwMessage_get+10Aj
					; mwMessage_get+1BAj
		movzx	eax, ax
		xor	esi, esi
		mov	[esp+58h+var_4C], eax
		mov	[esp+58h+var_50], offset aUnknownMessa_0 ; "unknown message type 0x%02x, no parse h"...
		mov	[esp+58h+var_54], 10h
		mov	[esp+58h+var_58], offset aMeanwhile_2 ;	"meanwhile"
		call	g_log

loc_100074F5:				; CODE XREF: mwMessage_get+12Cj
					; mwMessage_get+14Cj ...
		mov	[esp+58h+var_58], edi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_10007990

loc_10007505:				; CODE XREF: mwMessage_get+574j
		lea	eax, [ebp+var_34]
		call	sub_10006910

loc_1000750D:				; CODE XREF: mwMessage_get+93Aj
					; mwMessage_get+95Dj
		add	esp, 4Ch
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10007517:				; CODE XREF: mwMessage_get+50j
		cmp	ax, 3
		jz	loc_10007A84
		jbe	loc_10007640
		cmp	ax, 6
		nop
		lea	esi, [esi+0]
		jz	loc_10007C5E
		cmp	ax, 9
		lea	esi, [esi+0]
		jz	loc_10007C24
		cmp	ax, 4
		jnz	short loc_100074D0
		mov	[esp+58h+var_58], 1Ch
		call	g_malloc0
		lea	edx, [ebp+var_34]
		mov	esi, eax
		call	sub_10007410
		mov	[esp+58h+var_58], edi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	short loc_100074F5
		lea	eax, [esi+10h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint16_get
		lea	eax, [esi+14h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwOpaque_get
		jmp	loc_100074F5
; ---------------------------------------------------------------------------

loc_10007591:				; CODE XREF: mwMessage_get+2Cj
		lea	eax, [ebp+var_34]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint16_get
		lea	eax, [ebp+var_32]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint16_get
		lea	eax, [ebp+var_30]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint32_get
		cmp	[ebp+var_32], 0
		jns	loc_10007472
		lea	eax, [ebp+var_2C]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwOpaque_get
		jmp	loc_10007472
; ---------------------------------------------------------------------------
		align 10h

loc_100075E0:				; CODE XREF: mwMessage_get+60j
		cmp	ax, 16h
		jz	loc_10007B16
		cmp	ax, 18h
		xchg	ax, ax
		jz	loc_10007ACD
		cmp	ax, 11h
		jnz	loc_100074D0
		mov	[esp+58h+var_58], 14h
		call	g_malloc0
		lea	edx, [ebp+var_34]
		mov	esi, eax
		call	sub_10007410
		mov	[esp+58h+var_58], edi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_100074F5
		lea	eax, [esi+10h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint32_get
		jmp	loc_100074F5
; ---------------------------------------------------------------------------
		align 10h

loc_10007640:				; CODE XREF: mwMessage_get+E1j
		cmp	ax, 1
		jz	loc_100079B9
		lea	esi, [esi+0]
		jbe	loc_100077C3
		mov	[esp+58h+var_58], 70h
		lea	esi, [esi+0]
		call	g_malloc0
		lea	edx, [ebp+var_34]
		mov	esi, eax
		call	sub_10007410
		mov	[esp+58h+var_58], edi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_100074F5
		lea	eax, [esi+10h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint32_get
		lea	eax, [esi+14h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint32_get
		lea	eax, [esi+18h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwIdBlock_get
		lea	eax, [esi+20h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint32_get
		lea	eax, [esi+24h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint32_get
		lea	eax, [esi+28h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint32_get
		lea	eax, [esi+2Ch]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint32_get
		lea	eax, [esi+30h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwOpaque_get
		lea	eax, [esi+38h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	gboolean_get
		mov	eax, [esi+38h]
		test	eax, eax
		jnz	loc_10007DA2

loc_10007711:				; CODE XREF: mwMessage_get+971j
		mov	[esp+58h+var_58], edi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_100074F5
		lea	eax, [esi+60h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint16_get
		lea	eax, [ebp+var_14]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint32_get
		cmp	[ebp+var_14], 6
		jbe	loc_100074F5
		lea	eax, [ebp+var_18]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint32_get
		jmp	short loc_10007792
; ---------------------------------------------------------------------------

loc_1000775A:				; CODE XREF: mwMessage_get+35Ej
		mov	[esp+58h+var_58], edi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	short loc_100077A0
		mov	[esp+58h+var_58], 0Ch
		call	g_malloc0
		mov	[esp+58h+var_58], edi
		mov	ebx, eax
		mov	[esp+58h+var_54], eax
		call	mwEncryptItem_get
		mov	[esp+58h+var_54], ebx
		mov	eax, [esi+64h]
		mov	[esp+58h+var_58], eax
		call	g_list_append
		mov	[esi+64h], eax

loc_10007792:				; CODE XREF: mwMessage_get+318j
		mov	eax, [ebp+var_18]
		sub	eax, 1
		mov	[ebp+var_18], eax
		add	eax, 1
		jnz	short loc_1000775A

loc_100077A0:				; CODE XREF: mwMessage_get+324j
		lea	eax, [esi+68h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint16_get
		lea	eax, [esi+6Ch]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	gboolean_get
		jmp	loc_100074F5
; ---------------------------------------------------------------------------

loc_100077C3:				; CODE XREF: mwMessage_get+210j
		mov	[esp+58h+var_58], 2Ch
		call	g_malloc0
		lea	edx, [ebp+var_34]
		mov	esi, eax
		call	sub_10007410
		mov	[esp+58h+var_58], edi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_100074F5
		lea	eax, [esi+10h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint16_get
		lea	eax, [esi+12h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint16_get
		lea	eax, [esi+4]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint32_get
		lea	eax, [esi+14h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint32_get
		lea	eax, [esi+18h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint16_get
		lea	eax, [esi+1Ch]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint32_get
		cmp	word ptr [esi+10h], 1Dh
		jbe	loc_100074F5
		cmp	word ptr [esi+12h], 1Ch
		jbe	loc_100074F5
		lea	eax, [esi+20h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint16_get
		lea	eax, [esi+24h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint32_get
		lea	eax, [esi+28h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwString_get
		jmp	loc_100074F5
; ---------------------------------------------------------------------------
		align 10h

loc_10007890:				; CODE XREF: mwMessage_get+8Aj
		mov	[esp+58h+var_58], 48h
		call	g_malloc0
		lea	edx, [ebp+var_34]
		mov	esi, eax
		call	sub_10007410
		lea	eax, [esi+10h]
		mov	[esp+58h+var_54], eax
		mov	[ebp+var_24], 0
		mov	[ebp+var_20], 0
		mov	[esp+58h+var_58], edi
		call	gboolean_get
		mov	eax, [esi+10h]
		test	eax, eax
		jnz	loc_10007D40

loc_100078CE:				; CODE XREF: mwMessage_get+90Fj
		lea	eax, [esi+38h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint16_get
		lea	eax, [ebp+var_24]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwOpaque_get
		lea	eax, [ebp+var_24]
		mov	[esp+58h+var_58], eax
		call	mwGetBuffer_wrap
		mov	ebx, eax
		lea	eax, [esi+3Ch]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], ebx
		call	gboolean_get
		lea	eax, [esi+40h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], ebx
		call	mwString_get
		mov	[esp+58h+var_58], ebx
		call	mwGetBuffer_free
		lea	eax, [ebp+var_24]
		mov	[esp+58h+var_58], eax
		call	mwOpaque_clear
		lea	eax, [ebp+var_18]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint32_get
		mov	eax, [ebp+var_18]
		sub	eax, 1
		mov	[ebp+var_18], eax
		add	eax, 1
		jz	loc_100074F5
		lea	ebx, [ebp+var_1C]
		xchg	ax, ax

loc_10007950:				; CODE XREF: mwMessage_get+544j
		mov	[ebp+var_1C], 0
		mov	[esp+58h+var_54], ebx
		mov	[esp+58h+var_58], edi
		call	mwString_get
		mov	eax, [ebp+var_1C]
		mov	[esp+58h+var_54], eax
		mov	eax, [esi+44h]
		mov	[esp+58h+var_58], eax
		call	g_list_prepend
		mov	[esi+44h], eax
		mov	eax, [ebp+var_18]
		sub	eax, 1
		mov	[ebp+var_18], eax
		add	eax, 1
		jnz	short loc_10007950
		jmp	loc_100074F5
; ---------------------------------------------------------------------------
		align 10h

loc_10007990:				; CODE XREF: mwMessage_get+BFj
		movzx	eax, [ebp+var_34]
		mov	[esp+58h+var_50], offset aProblemParsing ; "problem parsing message type 0x%02x, no"...
		mov	[esp+58h+var_54], 10h
		mov	[esp+58h+var_58], offset aMeanwhile_2 ;	"meanwhile"
		mov	[esp+58h+var_4C], eax
		call	g_log
		jmp	loc_10007505
; ---------------------------------------------------------------------------

loc_100079B9:				; CODE XREF: mwMessage_get+204j
		mov	[esp+58h+var_58], 24h
		call	g_malloc0
		lea	edx, [ebp+var_34]
		mov	esi, eax
		call	sub_10007410
		mov	[esp+58h+var_58], edi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_100074F5
		lea	eax, [esi+10h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint16_get
		lea	eax, [esi+14h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwString_get
		lea	eax, [esi+1Ch]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwOpaque_get
		lea	eax, [esi+18h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint16_get
		jmp	loc_100074F5
; ---------------------------------------------------------------------------

loc_10007A20:				; CODE XREF: mwMessage_get+4Aj
		mov	[esp+58h+var_58], 1Ch
		call	g_malloc0
		lea	edx, [ebp+var_34]
		mov	esi, eax
		call	sub_10007410
		mov	[esp+58h+var_58], edi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_100074F5
		lea	eax, [esi+10h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwPrivacyInfo_get
		jmp	loc_100074F5
; ---------------------------------------------------------------------------

loc_10007A5A:				; CODE XREF: mwMessage_get+5Aj
		mov	[esp+58h+var_58], 14h
		call	g_malloc0
		lea	edx, [ebp+var_34]
		mov	esi, eax
		call	sub_10007410
		lea	eax, [esi+10h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwString_get
		jmp	loc_100074F5
; ---------------------------------------------------------------------------

loc_10007A84:				; CODE XREF: mwMessage_get+DBj
		mov	[esp+58h+var_58], 1Ch
		call	g_malloc0
		lea	edx, [ebp+var_34]
		mov	esi, eax
		call	sub_10007410
		mov	[esp+58h+var_58], edi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_100074F5
		lea	eax, [esi+10h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint32_get
		lea	eax, [esi+14h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwOpaque_get
		jmp	loc_100074F5
; ---------------------------------------------------------------------------

loc_10007ACD:				; CODE XREF: mwMessage_get+1B0j
		mov	[esp+58h+var_58], 18h
		call	g_malloc0
		lea	edx, [ebp+var_34]
		mov	esi, eax
		call	sub_10007410
		mov	[esp+58h+var_58], edi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_100074F5
		lea	eax, [esi+10h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwString_get
		lea	eax, [esi+14h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwString_get
		jmp	loc_100074F5
; ---------------------------------------------------------------------------

loc_10007B16:				; CODE XREF: mwMessage_get+1A4j
		mov	[esp+58h+var_58], 10h
		call	g_malloc0
		lea	edx, [ebp+var_34]
		mov	esi, eax
		call	sub_10007410
		jmp	loc_100074F5
; ---------------------------------------------------------------------------

loc_10007B31:				; CODE XREF: mwMessage_get+80j
		mov	[esp+58h+var_58], 4Ch
		call	g_malloc0
		lea	edx, [ebp+var_34]
		mov	esi, eax
		call	sub_10007410
		mov	[esp+58h+var_58], edi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_100074F5
		lea	eax, [esi+10h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwLoginInfo_get
		lea	eax, [ebp+var_E]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint16_get
		lea	eax, [esi+34h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwPrivacyInfo_get
		lea	eax, [esi+40h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwUserStatus_get
		jmp	loc_100074F5
; ---------------------------------------------------------------------------

loc_10007B98:				; CODE XREF: mwMessage_get+70j
		mov	[esp+58h+var_58], 24h
		call	g_malloc0
		lea	edx, [ebp+var_34]
		mov	esi, eax
		call	sub_10007410
		mov	[esp+58h+var_58], edi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_100074F5
		lea	eax, [esi+10h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint16_get
		lea	eax, [esi+12h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint16_get
		lea	eax, [esi+14h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint32_get
		cmp	word ptr [esi+10h], 1Dh
		jbe	loc_100074F5
		cmp	word ptr [esi+12h], 18h
		jbe	loc_100074F5
		lea	eax, [esi+18h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint32_get
		lea	eax, [esi+1Ch]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwOpaque_get
		jmp	loc_100074F5
; ---------------------------------------------------------------------------

loc_10007C24:				; CODE XREF: mwMessage_get+100j
		mov	[esp+58h+var_58], 1Ch
		call	g_malloc0
		lea	edx, [ebp+var_34]
		mov	esi, eax
		call	sub_10007410
		mov	[esp+58h+var_58], edi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_100074F5
		lea	eax, [esi+10h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwUserStatus_get
		jmp	loc_100074F5
; ---------------------------------------------------------------------------

loc_10007C5E:				; CODE XREF: mwMessage_get+F0j
		mov	[esp+58h+var_58], 5Ch
		call	g_malloc0
		lea	edx, [ebp+var_34]
		mov	esi, eax
		call	sub_10007410
		mov	[esp+58h+var_58], edi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_100074F5
		lea	eax, [esi+10h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint32_get
		lea	eax, [esi+14h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint32_get
		lea	eax, [esi+18h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint32_get
		lea	eax, [esi+1Ch]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwOpaque_get
		lea	eax, [esi+24h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	gboolean_get
		mov	eax, [esi+24h]
		test	eax, eax
		jnz	loc_10007DB6

loc_10007CDA:				; CODE XREF: mwMessage_get+985j
		mov	[esp+58h+var_58], edi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_100074F5
		lea	eax, [esi+4Ch]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint16_get
		lea	eax, [ebp+var_18]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint32_get
		cmp	[ebp+var_18], 5
		ja	loc_10007DCA

loc_10007D12:				; CODE XREF: mwMessage_get+9A5j
		cmp	[ebp+var_18], 8
		jbe	loc_100074F5
		lea	eax, [esi+54h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	guint16_get
		lea	eax, [esi+58h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	gboolean_get
		jmp	loc_100074F5
; ---------------------------------------------------------------------------
		align 10h

loc_10007D40:				; CODE XREF: mwMessage_get+488j
		lea	eax, [esi+14h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwLoginInfo_get
		jmp	loc_100078CE
; ---------------------------------------------------------------------------

loc_10007D54:				; CODE XREF: mwMessage_get+3Cj
		lea	eax, [ebp+var_34]
		xor	esi, esi
		call	sub_10006910
		mov	[esp+58h+var_50], offset aProblemParsi_0 ; "problem parsing message head from buffe"...
		mov	[esp+58h+var_54], 10h
		mov	[esp+58h+var_58], offset aMeanwhile_2 ;	"meanwhile"
		call	g_log
		jmp	loc_1000750D
; ---------------------------------------------------------------------------

loc_10007D7F:				; CODE XREF: mwMessage_get+Ej
		mov	[esp+58h+var_50], offset aBNull_0 ; "b != NULL"
		xor	esi, esi
		mov	[esp+58h+var_54], offset aMwmessage_get	; "mwMessage_get"
		mov	[esp+58h+var_58], offset aMeanwhile_2 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000750D
; ---------------------------------------------------------------------------

loc_10007DA2:				; CODE XREF: mwMessage_get+2CBj
		lea	eax, [esi+3Ch]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwLoginInfo_get
		jmp	loc_10007711
; ---------------------------------------------------------------------------

loc_10007DB6:				; CODE XREF: mwMessage_get+894j
		lea	eax, [esi+28h]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwLoginInfo_get
		jmp	loc_10007CDA
; ---------------------------------------------------------------------------

loc_10007DCA:				; CODE XREF: mwMessage_get+8CCj
		mov	[esp+58h+var_58], 0Ch
		call	g_malloc0
		mov	[esi+50h], eax
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mwEncryptItem_get
		jmp	loc_10007D12
mwMessage_get	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 308. mwService_removeClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwService_removeClientData
mwService_removeClientData proc	near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_10007E21
		mov	edx, [ebx+34h]
		test	edx, edx
		jz	short loc_10007E14
		mov	eax, [ebx+30h]
		mov	[esp+18h+var_18], eax
		call	edx
		mov	dword ptr [ebx+34h], 0

loc_10007E14:				; CODE XREF: mwService_removeClientData+13j
		mov	dword ptr [ebx+30h], 0

loc_10007E1B:				; CODE XREF: mwService_removeClientData+4Dj
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10007E21:				; CODE XREF: mwService_removeClientData+Cj
		mov	[esp+18h+var_10], offset aSrvcNull_0 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwservice_remo ; "mwService_removeClientData"
		mov	[esp+18h+var_18], offset aMeanwhile_3 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10007E1B
mwService_removeClientData endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 297. mwService_getClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwService_getClientData
mwService_getClientData	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10007E52
		mov	eax, [eax+30h]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10007E52:				; CODE XREF: mwService_getClientData+Bj
		mov	[esp+18h+var_10], offset aSrvcNull_0 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwservice_getc ; "mwService_getClientData"
		mov	[esp+18h+var_18], offset aMeanwhile_3 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwService_getClientData	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 309. mwService_setClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwService_setClientData
mwService_setClientData	proc near

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		mov	ecx, [ebp+arg_8]
		test	eax, eax
		jz	short loc_10007E98
		mov	[eax+30h], edx
		mov	[eax+34h], ecx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10007E98:				; CODE XREF: mwService_setClientData+Ej
		mov	[ebp+arg_8], offset aSrvcNull_0	; "srvc	!= NULL"
		mov	[ebp+arg_4], offset aMwservice_setc ; "mwService_setClientData"
		mov	[ebp+arg_0], offset aMeanwhile_3 ; "meanwhile"
		pop	ebp
		jmp	g_return_if_fail_warning
mwService_setClientData	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 301. mwService_getState

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwService_getState
mwService_getState proc	near		; CODE XREF: mwService_stop+15p
					; mwService_stop+22p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10007ED2
		mov	eax, [eax+4]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10007ED2:				; CODE XREF: mwService_getState+Bj
		mov	[esp+18h+var_10], offset aSrvcNull_0 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwservice_gets ; "mwService_getState"
		mov	[esp+18h+var_18], offset aMeanwhile_3 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwService_getState endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 303. mwService_init

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwService_init
mwService_init	proc near		; CODE XREF: mwServiceAware_new+93p
					; mwServiceConference_new+3Ep ...

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		mov	ecx, [ebp+arg_8]
		test	eax, eax
		jz	short loc_10007F26
		test	edx, edx
		jz	short loc_10007F41
		test	ecx, ecx
		jz	short loc_10007F5C
		mov	[eax+8], edx
		mov	[eax], ecx
		mov	dword ptr [eax+4], 0
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10007F26:				; CODE XREF: mwService_init+Ej
		mov	[ebp+arg_8], offset aSrvcNull_0	; "srvc	!= NULL"
		mov	[ebp+arg_4], offset aMwservice_init ; "mwService_init"
		mov	[ebp+arg_0], offset aMeanwhile_3 ; "meanwhile"
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_10007F41:				; CODE XREF: mwService_init+12j
		mov	[ebp+arg_8], offset aSessNull ;	"sess != NULL"
		mov	[ebp+arg_4], offset aMwservice_init ; "mwService_init"
		mov	[ebp+arg_0], offset aMeanwhile_3 ; "meanwhile"
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_10007F5C:				; CODE XREF: mwService_init+16j
		mov	[ebp+arg_8], offset aType0x00 ;	"type != 0x00"
		mov	[ebp+arg_4], offset aMwservice_init ; "mwService_init"
		mov	[ebp+arg_0], offset aMeanwhile_3 ; "meanwhile"
		pop	ebp
		jmp	g_return_if_fail_warning
mwService_init	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 300. mwService_getSession

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwService_getSession
mwService_getSession proc near		; CODE XREF: mwConference_open+37p
					; sub_1000D580+4Bp ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10007F92
		mov	eax, [eax+8]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10007F92:				; CODE XREF: mwService_getSession+Bj
		mov	[esp+18h+var_10], offset aSNull	; "s !=	NULL"
		mov	[esp+18h+var_14], offset aMwservice_ge_0 ; "mwService_getSession"
		mov	[esp+18h+var_18], offset aMeanwhile_3 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwService_getSession endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 298. mwService_getDesc

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwService_getDesc
mwService_getDesc proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10007FDA
		mov	ecx, [eax+10h]
		test	ecx, ecx
		jz	short loc_10007FFA
		mov	[ebp+arg_0], eax
		leave
		jmp	ecx
; ---------------------------------------------------------------------------

loc_10007FDA:				; CODE XREF: mwService_getDesc+Bj
		mov	[esp+18h+var_10], offset aSNull	; "s !=	NULL"
		mov	[esp+18h+var_14], offset aMwservice_getd ; "mwService_getDesc"
		mov	[esp+18h+var_18], offset aMeanwhile_3 ;	"meanwhile"
		call	g_return_if_fail_warning

locret_10007FF6:			; CODE XREF: mwService_getDesc+56j
		leave
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_10007FFA:				; CODE XREF: mwService_getDesc+12j
		mov	[esp+18h+var_10], offset aSGet_descNull	; "s->get_desc != NULL"
		mov	[esp+18h+var_14], offset aMwservice_getd ; "mwService_getDesc"
		mov	[esp+18h+var_18], offset aMeanwhile_3 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short locret_10007FF6
mwService_getDesc endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 299. mwService_getName

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwService_getName
mwService_getName proc near		; CODE XREF: mwService_stopped+2Ap
					; mwService_stopped+3Bp ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000803A
		mov	ecx, [eax+0Ch]
		test	ecx, ecx
		jz	short loc_1000805A
		mov	[ebp+arg_0], eax
		leave
		jmp	ecx
; ---------------------------------------------------------------------------

loc_1000803A:				; CODE XREF: mwService_getName+Bj
		mov	[esp+18h+var_10], offset aSNull	; "s !=	NULL"
		mov	[esp+18h+var_14], offset aMwservice_getn ; "mwService_getName"
		mov	[esp+18h+var_18], offset aMeanwhile_3 ;	"meanwhile"
		call	g_return_if_fail_warning

locret_10008056:			; CODE XREF: mwService_getName+56j
		leave
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1000805A:				; CODE XREF: mwService_getName+12j
		mov	[esp+18h+var_10], offset aSGet_nameNull	; "s->get_name != NULL"
		mov	[esp+18h+var_14], offset aMwservice_getn ; "mwService_getName"
		mov	[esp+18h+var_18], offset aMeanwhile_3 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short locret_10008056
mwService_getName endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 302. mwService_getType

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwService_getType
mwService_getType proc near		; CODE XREF: mwChannel_setService+20p
					; mwSession_addService+2Cp ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10008091
		mov	eax, [eax]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10008091:				; CODE XREF: mwService_getType+Bj
		mov	[esp+18h+var_10], offset aSNull	; "s !=	NULL"
		mov	[esp+18h+var_14], offset aMwservice_gett ; "mwService_getType"
		mov	[esp+18h+var_18], offset aMeanwhile_3 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwService_getType endp

; ---------------------------------------------------------------------------
		jmp	short mwService_stopped
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 313. mwService_stopped

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwService_stopped
mwService_stopped proc near		; CODE XREF: .text:100080B1j
					; mwService_stop+8Cj ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_10008128
		mov	eax, [ebx+4]
		test	eax, eax
		jnz	short loc_100080E0

loc_100080D5:				; CODE XREF: mwService_stopped+84j
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_100080E0:				; CODE XREF: mwService_stopped+13j
		mov	dword ptr [ebx+4], 0
		mov	[esp+18h+var_18], ebx
		call	mwService_getName
		mov	edx, offset aNull_0 ; "(null)"
		test	eax, eax
		jz	short loc_10008102
		mov	[esp+18h+var_18], ebx
		call	mwService_getName
		mov	edx, eax

loc_10008102:				; CODE XREF: mwService_stopped+36j
		mov	[esp+18h+var_C], edx
		mov	[esp+18h+var_10], offset aStoppedService ; "stopped service %s"
		mov	[esp+18h+var_14], 20h
		mov	[esp+18h+var_18], offset aMeanwhile_3 ;	"meanwhile"
		call	g_log
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10008128:				; CODE XREF: mwService_stopped+Cj
		mov	[esp+18h+var_10], offset aSrvcNull_0 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwservice_stop ; "mwService_stopped"
		mov	[esp+18h+var_18], offset aMeanwhile_3 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100080D5
mwService_stopped endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 312. mwService_stop

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwService_stop
mwService_stop	proc near		; CODE XREF: mwService_free+11p
					; mwSession_stop+65p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	loc_100081E1
		mov	[esp+18h+var_18], ebx
		call	mwService_getState
		sub	eax, 1
		jz	short loc_1000817B
		mov	[esp+18h+var_18], ebx
		call	mwService_getState
		test	eax, eax
		jnz	short loc_10008181

loc_1000817B:				; CODE XREF: mwService_stop+1Dj
					; mwService_stop+ADj
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10008181:				; CODE XREF: mwService_stop+29j
		mov	dword ptr [ebx+4], 1
		mov	[esp+18h+var_18], ebx
		call	mwService_getName
		mov	edx, offset aNull_0 ; "(null)"
		test	eax, eax
		jz	short loc_100081A3
		mov	[esp+18h+var_18], ebx
		call	mwService_getName
		mov	edx, eax

loc_100081A3:				; CODE XREF: mwService_stop+47j
		mov	[esp+18h+var_C], edx
		mov	[esp+18h+var_10], offset aStoppingServic ; "stopping service %s"
		mov	[esp+18h+var_14], 20h
		mov	[esp+18h+var_18], offset aMeanwhile_3 ;	"meanwhile"
		call	g_log
		mov	ecx, [ebx+28h]
		test	ecx, ecx
		jz	short loc_100081D4
		mov	[ebp+arg_0], ebx
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	ecx
; ---------------------------------------------------------------------------

loc_100081D4:				; CODE XREF: mwService_stop+78j
		mov	[ebp+arg_0], ebx
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	mwService_stopped
; ---------------------------------------------------------------------------

loc_100081E1:				; CODE XREF: mwService_stop+Cj
		mov	[esp+18h+var_10], offset aSrvcNull_0 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwservice_st_0 ; "mwService_stop"
		mov	[esp+18h+var_18], offset aMeanwhile_3 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000817B
mwService_stop	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 296. mwService_free

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwService_free
mwService_free	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_1000824E
		mov	[esp+18h+var_18], ebx
		call	mwService_stop
		mov	eax, [ebx+2Ch]
		test	eax, eax
		jz	short loc_10008232
		mov	[esp+18h+var_18], ebx
		call	eax

loc_10008232:				; CODE XREF: mwService_free+1Bj
		mov	edx, [ebx+34h]
		test	edx, edx
		jz	short loc_10008241
		mov	eax, [ebx+30h]
		mov	[esp+18h+var_18], eax
		call	edx

loc_10008241:				; CODE XREF: mwService_free+27j
		mov	[ebp+arg_0], ebx
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	g_free
; ---------------------------------------------------------------------------

loc_1000824E:				; CODE XREF: mwService_free+Cj
		mov	[esp+18h+var_10], offset aSrvcNull_0 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwservice_free ; "mwService_free"
		mov	[esp+18h+var_18], offset aMeanwhile_3 ;	"meanwhile"
		call	g_return_if_fail_warning
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
mwService_free	endp

; Exported entry 295. mwService_error

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwService_error
mwService_error	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	loc_10008301
		mov	[esp+18h+var_18], ebx
		call	mwService_getState
		sub	eax, 1
		jz	short loc_1000829B
		mov	[esp+18h+var_18], ebx
		call	mwService_getState
		test	eax, eax
		jnz	short loc_100082A1

loc_1000829B:				; CODE XREF: mwService_error+1Dj
					; mwService_error+ADj
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100082A1:				; CODE XREF: mwService_error+29j
		mov	dword ptr [ebx+4], 4
		mov	[esp+18h+var_18], ebx
		call	mwService_getName
		mov	edx, offset aNull_0 ; "(null)"
		test	eax, eax
		jz	short loc_100082C3
		mov	[esp+18h+var_18], ebx
		call	mwService_getName
		mov	edx, eax

loc_100082C3:				; CODE XREF: mwService_error+47j
		mov	[esp+18h+var_C], edx
		mov	[esp+18h+var_10], offset aErrorInService ; "error in service %s"
		mov	[esp+18h+var_14], 20h
		mov	[esp+18h+var_18], offset aMeanwhile_3 ;	"meanwhile"
		call	g_log
		mov	ecx, [ebx+28h]
		test	ecx, ecx
		jz	short loc_100082F4
		mov	[ebp+arg_0], ebx
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	ecx
; ---------------------------------------------------------------------------

loc_100082F4:				; CODE XREF: mwService_error+78j
		mov	[ebp+arg_0], ebx
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	mwService_stopped
; ---------------------------------------------------------------------------

loc_10008301:				; CODE XREF: mwService_error+Cj
		mov	[esp+18h+var_10], offset aSrvcNull_0 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwservice_erro ; "mwService_error"
		mov	[esp+18h+var_18], offset aMeanwhile_3 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000829B
mwService_error	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 311. mwService_started

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwService_started
mwService_started proc near		; CODE XREF: mwService_start+7Bj
					; sub_1000C8B0+88j ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_10008386
		mov	dword ptr [ebx+4], 2
		mov	[esp+18h+var_18], ebx
		call	mwService_getName
		mov	edx, offset aNull_0 ; "(null)"
		test	eax, eax
		jz	short loc_10008360
		mov	[esp+18h+var_18], ebx
		call	mwService_getName
		mov	edx, eax

loc_10008360:				; CODE XREF: mwService_started+24j
		mov	[esp+18h+var_C], edx
		mov	[esp+18h+var_10], offset aStartedService ; "started service %s"
		mov	[esp+18h+var_14], 20h
		mov	[esp+18h+var_18], offset aMeanwhile_3 ;	"meanwhile"
		call	g_log

loc_10008380:				; CODE XREF: mwService_started+72j
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10008386:				; CODE XREF: mwService_started+Cj
		mov	[esp+18h+var_10], offset aSrvcNull_0 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwservice_star ; "mwService_started"
		mov	[esp+18h+var_18], offset aMeanwhile_3 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10008380
mwService_started endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 310. mwService_start

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwService_start
mwService_start	proc near		; CODE XREF: sub_10009A60+463p
					; sub_10009A60+555p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_10008430
		mov	[esp+18h+var_18], ebx
		call	mwService_getState
		test	eax, eax
		jz	short loc_100083D0

loc_100083CA:				; CODE XREF: mwService_start+9Cj
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100083D0:				; CODE XREF: mwService_start+18j
		mov	dword ptr [ebx+4], 3
		mov	[esp+18h+var_18], ebx
		call	mwService_getName
		mov	edx, offset aNull_0 ; "(null)"
		test	eax, eax
		jz	short loc_100083F2
		mov	[esp+18h+var_18], ebx
		call	mwService_getName
		mov	edx, eax

loc_100083F2:				; CODE XREF: mwService_start+36j
		mov	[esp+18h+var_C], edx
		mov	[esp+18h+var_10], offset aStartingServic ; "starting service %s"
		mov	[esp+18h+var_14], 20h
		mov	[esp+18h+var_18], offset aMeanwhile_3 ;	"meanwhile"
		call	g_log
		mov	ecx, [ebx+24h]
		test	ecx, ecx
		jz	short loc_10008423
		mov	[ebp+arg_0], ebx
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	ecx
; ---------------------------------------------------------------------------

loc_10008423:				; CODE XREF: mwService_start+67j
		mov	[ebp+arg_0], ebx
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	mwService_started
; ---------------------------------------------------------------------------

loc_10008430:				; CODE XREF: mwService_start+Cj
		mov	[esp+18h+var_10], offset aSrvcNull_0 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwservice_st_1 ; "mwService_start"
		mov	[esp+18h+var_18], offset aMeanwhile_3 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_100083CA
mwService_start	endp

; ---------------------------------------------------------------------------
		jmp	short mwService_recv
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 304. mwService_recv

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwService_recv
mwService_recv	proc near		; CODE XREF: sub_10001DA0+84p
					; sub_10001DA0+B9p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_E		= word ptr -0Eh
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_C]
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		mov	[ebp+var_14], eax
		movzx	eax, word ptr [ebp+arg_8]
		test	esi, esi
		mov	[ebp+var_E], ax
		jz	short loc_100084DD
		test	edi, edi
		jz	short loc_10008503
		mov	edx, [ebp+var_14]
		test	edx, edx
		jz	short loc_1000850C
		mov	ebx, [esi+8]
		mov	[esp+18h+var_18], edi
		call	mwChannel_getSession
		cmp	ebx, eax
		jnz	short loc_10008515
		mov	ecx, [esi+20h]
		test	ecx, ecx
		jz	short loc_100084D0
		mov	eax, [ebp+var_14]
		mov	[ebp+arg_4], edi
		mov	ebx, [ebp+var_C]
		mov	[ebp+arg_0], esi
		mov	edi, [ebp+var_4]
		mov	esi, [ebp+var_8]
		mov	[ebp+arg_C], eax
		movzx	eax, [ebp+var_E]
		mov	[ebp+arg_8], eax
		mov	esp, ebp
		pop	ebp
		jmp	ecx
; ---------------------------------------------------------------------------
		align 10h

loc_100084D0:				; CODE XREF: mwService_recv+46j
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100084DD:				; CODE XREF: mwService_recv+25j
		mov	[ebp+arg_8], offset aSNull ; "s	!= NULL"

loc_100084E4:				; CODE XREF: mwService_recv+AAj
					; mwService_recv+B3j ...
		mov	[ebp+arg_4], offset aMwservice_recv ; "mwService_recv"
		mov	ebx, [ebp+var_C]
		mov	[ebp+arg_0], offset aMeanwhile_3 ; "meanwhile"
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_10008503:				; CODE XREF: mwService_recv+29j
		mov	[ebp+arg_8], offset aChanNull_1	; "chan	!= NULL"
		jmp	short loc_100084E4
; ---------------------------------------------------------------------------

loc_1000850C:				; CODE XREF: mwService_recv+30j
		mov	[ebp+arg_8], offset aDataNull_1	; "data	!= NULL"
		jmp	short loc_100084E4
; ---------------------------------------------------------------------------

loc_10008515:				; CODE XREF: mwService_recv+3Fj
		mov	[ebp+arg_8], offset aSSessionMwchan ; "s->session == mwChannel_getSession(chan"...
		jmp	short loc_100084E4
mwService_recv	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 307. mwService_recvDestroy

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwService_recvDestroy
mwService_recvDestroy proc near		; CODE XREF: mwChannel_recvDestroy+4Fp

var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_0]
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		test	edi, edi
		mov	[ebp+var_10], eax
		jz	short loc_1000859F
		test	esi, esi
		jz	loc_100085C5
		mov	ecx, [ebp+var_10]
		test	ecx, ecx
		jz	loc_100085CE
		mov	ebx, [edi+8]
		mov	[esp+18h+var_18], esi
		call	mwChannel_getSession
		cmp	ebx, eax
		jnz	short loc_100085D7
		mov	[esp+18h+var_18], esi
		call	mwChannel_getId
		mov	edx, [ebp+var_10]
		cmp	eax, [edx+4]
		jnz	short loc_100085E0
		mov	ecx, [edi+1Ch]
		test	ecx, ecx
		jz	short loc_10008592
		mov	eax, [ebp+var_10]
		mov	[ebp+arg_4], esi
		mov	ebx, [ebp+var_C]
		mov	[ebp+arg_0], edi
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	[ebp+arg_8], eax
		mov	esp, ebp
		pop	ebp
		jmp	ecx
; ---------------------------------------------------------------------------

loc_10008592:				; CODE XREF: mwService_recvDestroy+56j
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000859F:				; CODE XREF: mwService_recvDestroy+1Dj
		mov	[ebp+arg_8], offset aSNull ; "s	!= NULL"

loc_100085A6:				; CODE XREF: mwService_recvDestroy+ACj
					; mwService_recvDestroy+B5j ...
		mov	[ebp+arg_4], offset aMwservice_re_0 ; "mwService_recvDestroy"
		mov	ebx, [ebp+var_C]
		mov	[ebp+arg_0], offset aMeanwhile_3 ; "meanwhile"
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_100085C5:				; CODE XREF: mwService_recvDestroy+21j
		mov	[ebp+arg_8], offset aChanNull_1	; "chan	!= NULL"
		jmp	short loc_100085A6
; ---------------------------------------------------------------------------

loc_100085CE:				; CODE XREF: mwService_recvDestroy+2Cj
		mov	[ebp+arg_8], offset aMsgNull_1 ; "msg != NULL"
		jmp	short loc_100085A6
; ---------------------------------------------------------------------------

loc_100085D7:				; CODE XREF: mwService_recvDestroy+3Fj
		mov	[ebp+arg_8], offset aSSessionMwchan ; "s->session == mwChannel_getSession(chan"...
		jmp	short loc_100085A6
; ---------------------------------------------------------------------------

loc_100085E0:				; CODE XREF: mwService_recvDestroy+4Fj
		mov	[ebp+arg_8], offset aMwchannel_ge_8 ; "mwChannel_getId(chan) ==	msg->head.chan"...
		jmp	short loc_100085A6
mwService_recvDestroy endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 305. mwService_recvAccept

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwService_recvAccept
mwService_recvAccept proc near		; CODE XREF: mwChannel_recvAccept+158p

var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_0]
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		test	edi, edi
		mov	[ebp+var_10], eax
		jz	short loc_1000866F
		test	esi, esi
		jz	loc_10008695
		mov	ebx, [ebp+var_10]
		test	ebx, ebx
		jz	loc_1000869E
		mov	ebx, [edi+8]
		mov	[esp+18h+var_18], esi
		call	mwChannel_getSession
		cmp	ebx, eax
		jnz	short loc_100086A7
		mov	[esp+18h+var_18], esi
		call	mwChannel_getId
		mov	edx, [ebp+var_10]
		cmp	eax, [edx+4]
		jnz	short loc_100086B0
		mov	ecx, [edi+18h]
		test	ecx, ecx
		jz	short loc_10008662
		mov	eax, [ebp+var_10]
		mov	[ebp+arg_4], esi
		mov	ebx, [ebp+var_C]
		mov	[ebp+arg_0], edi
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	[ebp+arg_8], eax
		mov	esp, ebp
		pop	ebp
		jmp	ecx
; ---------------------------------------------------------------------------

loc_10008662:				; CODE XREF: mwService_recvAccept+56j
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000866F:				; CODE XREF: mwService_recvAccept+1Dj
		mov	[ebp+arg_8], offset aSNull ; "s	!= NULL"

loc_10008676:				; CODE XREF: mwService_recvAccept+ACj
					; mwService_recvAccept+B5j ...
		mov	[ebp+arg_4], offset aMwservice_re_1 ; "mwService_recvAccept"
		mov	ebx, [ebp+var_C]
		mov	[ebp+arg_0], offset aMeanwhile_3 ; "meanwhile"
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_10008695:				; CODE XREF: mwService_recvAccept+21j
		mov	[ebp+arg_8], offset aChanNull_1	; "chan	!= NULL"
		jmp	short loc_10008676
; ---------------------------------------------------------------------------

loc_1000869E:				; CODE XREF: mwService_recvAccept+2Cj
		mov	[ebp+arg_8], offset aMsgNull_1 ; "msg != NULL"
		jmp	short loc_10008676
; ---------------------------------------------------------------------------

loc_100086A7:				; CODE XREF: mwService_recvAccept+3Fj
		mov	[ebp+arg_8], offset aSSessionMwchan ; "s->session == mwChannel_getSession(chan"...
		jmp	short loc_10008676
; ---------------------------------------------------------------------------

loc_100086B0:				; CODE XREF: mwService_recvAccept+4Fj
		mov	[ebp+arg_8], offset aMwchannel_ge_8 ; "mwChannel_getId(chan) ==	msg->head.chan"...
		jmp	short loc_10008676
mwService_recvAccept endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 306. mwService_recvCreate

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwService_recvCreate
mwService_recvCreate proc near		; CODE XREF: mwChannel_recvCreate+143p

var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		test	esi, esi
		mov	[ebp+var_10], eax
		jz	loc_10008762
		test	edi, edi
		jz	loc_10008788
		mov	eax, [ebp+var_10]
		test	eax, eax
		jz	loc_10008791
		mov	ebx, [esi+8]
		mov	[esp+18h+var_18], edi
		call	mwChannel_getSession
		cmp	ebx, eax
		jnz	loc_1000879A
		mov	[esp+18h+var_18], edi
		call	mwChannel_getId
		mov	edx, [ebp+var_10]
		cmp	eax, [edx+14h]
		jnz	loc_100087A3
		mov	ecx, [esi+14h]
		test	ecx, ecx
		jz	short loc_10008740
		mov	eax, [ebp+var_10]
		mov	[ebp+arg_4], edi
		mov	ebx, [ebp+var_C]
		mov	[ebp+arg_0], esi
		mov	edi, [ebp+var_4]
		mov	esi, [ebp+var_8]
		mov	[ebp+arg_8], eax
		mov	esp, ebp
		pop	ebp
		jmp	ecx
; ---------------------------------------------------------------------------
		align 10h

loc_10008740:				; CODE XREF: mwService_recvCreate+62j
		mov	[ebp+arg_0], edi
		mov	ebx, [ebp+var_C]
		mov	[ebp+arg_8], 0
		mov	esi, [ebp+var_8]
		mov	[ebp+arg_4], 80000000h
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	mwChannel_destroy
; ---------------------------------------------------------------------------

loc_10008762:				; CODE XREF: mwService_recvCreate+1Dj
		mov	[ebp+arg_8], offset aSNull ; "s	!= NULL"

loc_10008769:				; CODE XREF: mwService_recvCreate+CFj
					; mwService_recvCreate+D8j ...
		mov	[ebp+arg_4], offset aMwservice_re_2 ; "mwService_recvCreate"
		mov	ebx, [ebp+var_C]
		mov	[ebp+arg_0], offset aMeanwhile_3 ; "meanwhile"
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_10008788:				; CODE XREF: mwService_recvCreate+25j
		mov	[ebp+arg_8], offset aChanNull_1	; "chan	!= NULL"
		jmp	short loc_10008769
; ---------------------------------------------------------------------------

loc_10008791:				; CODE XREF: mwService_recvCreate+30j
		mov	[ebp+arg_8], offset aMsgNull_1 ; "msg != NULL"
		jmp	short loc_10008769
; ---------------------------------------------------------------------------

loc_1000879A:				; CODE XREF: mwService_recvCreate+43j
		mov	[ebp+arg_8], offset aSSessionMwchan ; "s->session == mwChannel_getSession(chan"...
		jmp	short loc_10008769
; ---------------------------------------------------------------------------

loc_100087A3:				; CODE XREF: mwService_recvCreate+57j
		mov	[ebp+arg_8], offset aMwchannel_ge_9 ; "mwChannel_getId(chan) ==	msg->channel"
		jmp	short loc_10008769
mwService_recvCreate endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100087B0	proc near		; CODE XREF: sub_100091A0+46p
					; sub_100091A0+9Cp ...
		push	ebp
		cmp	eax, 0Ah	; switch 11 cases
		mov	ebp, esp
		jbe	short loc_100087C0

loc_100087B8:				; CODE XREF: sub_100087B0:loc_100087C0j
					; DATA XREF: .rdata:off_1001D7E4o
		pop	ebp		; jumptable 100087C0 default case
		mov	eax, offset aUnknown_0 ; "UNKNOWN"
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_100087C0:				; CODE XREF: sub_100087B0+6j
		jmp	ds:off_1001D7E4[eax*4] ; switch	jump
; ---------------------------------------------------------------------------

loc_100087C7:				; CODE XREF: sub_100087B0:loc_100087C0j
					; DATA XREF: .rdata:off_1001D7E4o
		pop	ebp		; jumptable 100087C0 case 10
		mov	eax, offset aForcingLogin ; "forcing login"
		retn
; ---------------------------------------------------------------------------

loc_100087CE:				; CODE XREF: sub_100087B0:loc_100087C0j
					; DATA XREF: .rdata:off_1001D7E4o
		pop	ebp		; jumptable 100087C0 case 0
		mov	eax, offset aStarting ;	"starting"
		retn
; ---------------------------------------------------------------------------

loc_100087D5:				; CODE XREF: sub_100087B0:loc_100087C0j
					; DATA XREF: .rdata:off_1001D7E4o
		pop	ebp		; jumptable 100087C0 case 1
		mov	eax, offset aHandshakeSent ; "handshake	sent"
		retn
; ---------------------------------------------------------------------------

loc_100087DC:				; CODE XREF: sub_100087B0:loc_100087C0j
					; DATA XREF: .rdata:off_1001D7E4o
		pop	ebp		; jumptable 100087C0 case 2
		mov	eax, offset aHandshakeAckno ; "handshake acknowledged"
		retn
; ---------------------------------------------------------------------------

loc_100087E3:				; CODE XREF: sub_100087B0:loc_100087C0j
					; DATA XREF: .rdata:off_1001D7E4o
		pop	ebp		; jumptable 100087C0 case 3
		mov	eax, offset aLoginSent ; "login	sent"
		retn
; ---------------------------------------------------------------------------

loc_100087EA:				; CODE XREF: sub_100087B0:loc_100087C0j
					; DATA XREF: .rdata:off_1001D7E4o
		pop	ebp		; jumptable 100087C0 case 4
		mov	eax, offset aLoginRedirecte ; "login redirected"
		retn
; ---------------------------------------------------------------------------

loc_100087F1:				; CODE XREF: sub_100087B0:loc_100087C0j
					; DATA XREF: .rdata:off_1001D7E4o
		pop	ebp		; jumptable 100087C0 case 5
		mov	eax, offset aLoginAcknowled ; "login acknowledged"
		retn
; ---------------------------------------------------------------------------

loc_100087F8:				; CODE XREF: sub_100087B0:loc_100087C0j
					; DATA XREF: .rdata:off_1001D7E4o
		pop	ebp		; jumptable 100087C0 case 6
		mov	eax, offset aStarted ; "started"
		retn
; ---------------------------------------------------------------------------

loc_100087FF:				; CODE XREF: sub_100087B0:loc_100087C0j
					; DATA XREF: .rdata:off_1001D7E4o
		pop	ebp		; jumptable 100087C0 case 7
		mov	eax, offset aStopping ;	"stopping"
		retn
; ---------------------------------------------------------------------------

loc_10008806:				; CODE XREF: sub_100087B0:loc_100087C0j
					; DATA XREF: .rdata:off_1001D7E4o
		pop	ebp		; jumptable 100087C0 case 8
		mov	eax, offset aStopped ; "stopped"
		retn
sub_100087B0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 318. mwSession_getChannels

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_getChannels
mwSession_getChannels proc near		; CODE XREF: mwChannel_recvDestroy+59p
					; mwChannel_destroy+34p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10008822
		mov	eax, [eax+54h]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10008822:				; CODE XREF: mwSession_getChannels+Bj
		mov	[esp+18h+var_10], offset aSessionNull_0	; "session != NULL"
		mov	[esp+18h+var_14], offset aMwsession_getc ; "mwSession_getChannels"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSession_getChannels endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 329. mwSession_getStateInfo

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_getStateInfo
mwSession_getStateInfo proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10008862
		mov	eax, [eax+8]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10008862:				; CODE XREF: mwSession_getStateInfo+Bj
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	[esp+18h+var_14], offset aMwsession_gets ; "mwSession_getStateInfo"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSession_getStateInfo endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 328. mwSession_getState

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_getState
mwSession_getState proc	near		; CODE XREF: sub_100091A0+2Ap
					; mwSession_senseService+20p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_100088A2
		mov	eax, [eax+4]
		leave
		retn
; ---------------------------------------------------------------------------

loc_100088A2:				; CODE XREF: mwSession_getState+Bj
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	[esp+18h+var_14], offset aMwsession_ge_0 ; "mwSession_getState"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 9
		leave
		retn
mwSession_getState endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 330. mwSession_getUserStatus

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_getUserStatus
mwSession_getUserStatus	proc near	; CODE XREF: sub_10011730+20p
					; sub_10011730+257p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_100088E2
		leave
		add	eax, 3Ch
		retn
; ---------------------------------------------------------------------------

loc_100088E2:				; CODE XREF: mwSession_getUserStatus+Bj
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	[esp+18h+var_14], offset aMwsession_getu ; "mwSession_getUserStatus"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSession_getUserStatus	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 324. mwSession_getPrivacyInfo

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_getPrivacyInfo
mwSession_getPrivacyInfo proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10008922
		leave
		add	eax, 48h
		retn
; ---------------------------------------------------------------------------

loc_10008922:				; CODE XREF: mwSession_getPrivacyInfo+Bj
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	[esp+18h+var_14], offset aMwsession_getp ; "mwSession_getPrivacyInfo"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSession_getPrivacyInfo endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 323. mwSession_getLoginInfo

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_getLoginInfo
mwSession_getLoginInfo proc near	; CODE XREF: sub_100041A0+1Ap
					; mwPlace_getTitle+33p	...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10008962
		leave
		add	eax, 18h
		retn
; ---------------------------------------------------------------------------

loc_10008962:				; CODE XREF: mwSession_getLoginInfo+Bj
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	[esp+18h+var_14], offset aMwsession_getl ; "mwSession_getLoginInfo"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSession_getLoginInfo endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 322. mwSession_getHandler

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_getHandler
mwSession_getHandler proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_100089A1
		mov	eax, [eax]
		leave
		retn
; ---------------------------------------------------------------------------

loc_100089A1:				; CODE XREF: mwSession_getHandler+Bj
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	[esp+18h+var_14], offset aMwsession_geth ; "mwSession_getHandler"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSession_getHandler endp

; ---------------------------------------------------------------------------
		jmp	short sub_100089D0
; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100089D0	proc near		; CODE XREF: .text:100089C1j
					; mwSession_sendKeepalive+19p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h

		push	ebp
		mov	ebp, esp
		push	ebx
		mov	ebx, eax
		sub	esp, 14h
		test	eax, eax
		jz	short loc_100089FC
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_10008A1F
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_10008A42
		mov	[esp+18h+var_10], ecx
		mov	[esp+18h+var_14], edx
		mov	[esp+18h+var_18], ebx
		call	eax

loc_100089F6:				; CODE XREF: sub_100089D0+4Dj
					; sub_100089D0+70j ...
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100089FC:				; CODE XREF: sub_100089D0+Bj
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	[esp+18h+var_14], offset aIo_write ; "io_write"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFFFFFh
		jmp	short loc_100089F6
; ---------------------------------------------------------------------------

loc_10008A1F:				; CODE XREF: sub_100089D0+11j
		mov	[esp+18h+var_10], offset aSHandlerNull ; "s->handler !=	NULL"
		mov	[esp+18h+var_14], offset aIo_write ; "io_write"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFFFFFh
		jmp	short loc_100089F6
; ---------------------------------------------------------------------------

loc_10008A42:				; CODE XREF: sub_100089D0+17j
		mov	[esp+18h+var_10], offset aSHandlerIo_wri ; "s->handler->io_write != NULL"
		mov	[esp+18h+var_14], offset aIo_write ; "io_write"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFFFFFh
		jmp	short loc_100089F6
sub_100089D0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 339. mwSession_sendKeepalive

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_sendKeepalive
mwSession_sendKeepalive	proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1		= byte ptr -1
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_1], 80h
		test	eax, eax
		jz	short loc_10008A90
		lea	edx, [ebp+var_1]
		mov	ecx, 1
		call	sub_100089D0
		leave
		retn
; ---------------------------------------------------------------------------

loc_10008A90:				; CODE XREF: mwSession_sendKeepalive+Fj
		mov	[esp+28h+var_20], offset aSNull_0 ; "s != NULL"
		mov	[esp+28h+var_24], offset aMwsession_send ; "mwSession_sendKeepalive"
		mov	[esp+28h+var_28], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFFFFFh
		leave
		retn
mwSession_sendKeepalive	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 334. mwSession_removeClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_removeClientData
mwSession_removeClientData proc	near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10008AD9
		add	eax, 64h
		mov	[ebp+arg_0], eax
		leave
		jmp	mw_datum_clear
; ---------------------------------------------------------------------------

loc_10008AD9:				; CODE XREF: mwSession_removeClientData+Bj
		mov	[esp+18h+var_10], offset aSessionNull_0	; "session != NULL"
		mov	[esp+18h+var_14], offset aMwsession_remo ; "mwSession_removeClientData"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwSession_removeClientData endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 321. mwSession_getClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_getClientData
mwSession_getClientData	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10008B19
		add	eax, 64h
		mov	[ebp+arg_0], eax
		leave
		jmp	mw_datum_get
; ---------------------------------------------------------------------------

loc_10008B19:				; CODE XREF: mwSession_getClientData+Bj
		mov	[esp+18h+var_10], offset aSessionNull_0	; "session != NULL"
		mov	[esp+18h+var_14], offset aMwsession_ge_1 ; "mwSession_getClientData"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSession_getClientData	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 341. mwSession_setClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_setClientData
mwSession_setClientData	proc near

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	edx, [ebp+arg_8]
		test	eax, eax
		jz	short loc_10008B62
		add	eax, 64h
		mov	[ebp+arg_8], edx
		mov	[ebp+arg_4], ecx
		mov	[ebp+arg_0], eax
		pop	ebp
		jmp	mw_datum_set
; ---------------------------------------------------------------------------

loc_10008B62:				; CODE XREF: mwSession_setClientData+Ej
		mov	[ebp+arg_8], offset aSessionNull_0 ; "session != NULL"
		mov	[ebp+arg_4], offset aMwsession_setc ; "mwSession_setClientData"
		mov	[ebp+arg_0], offset aMeanwhile_4 ; "meanwhile"
		pop	ebp
		jmp	g_return_if_fail_warning
mwSession_setClientData	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 335. mwSession_removeProperty

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_removeProperty
mwSession_removeProperty proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	eax, eax
		jz	short loc_10008BA7
		mov	eax, [eax+60h]
		test	eax, eax
		jz	short loc_10008BC5
		test	edx, edx
		jz	short loc_10008BE3
		mov	[ebp+arg_4], edx
		mov	[ebp+arg_0], eax
		leave
		jmp	g_hash_table_remove
; ---------------------------------------------------------------------------

loc_10008BA7:				; CODE XREF: mwSession_removeProperty+Ej
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	[esp+18h+var_14], offset aMwsession_re_0 ; "mwSession_removeProperty"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
; ---------------------------------------------------------------------------

loc_10008BC5:				; CODE XREF: mwSession_removeProperty+15j
		mov	[esp+18h+var_10], offset aSAttributesNul ; "s->attributes != NULL"
		mov	[esp+18h+var_14], offset aMwsession_re_0 ; "mwSession_removeProperty"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
; ---------------------------------------------------------------------------

loc_10008BE3:				; CODE XREF: mwSession_removeProperty+19j
		mov	[esp+18h+var_10], offset aKeyNull_0 ; "key != NULL"
		mov	[esp+18h+var_14], offset aMwsession_re_0 ; "mwSession_removeProperty"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwSession_removeProperty endp

; ---------------------------------------------------------------------------
		jmp	short mwSession_removeCipher
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 333. mwSession_removeCipher

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_removeCipher
mwSession_removeCipher proc near	; CODE XREF: .text:10008C01j

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_C], ebx
		movzx	edx, [ebp+arg_4]
		mov	[ebp+var_4], edi
		test	esi, esi
		jz	short loc_10008C64
		mov	eax, [esi+5Ch]
		test	eax, eax
		jz	short loc_10008C84
		movzx	ebx, dx
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+var_18], eax
		call	g_hash_table_lookup
		test	eax, eax
		mov	edi, eax
		jz	short loc_10008C55
		mov	[esp+18h+var_14], ebx
		mov	eax, [esi+5Ch]
		mov	[esp+18h+var_18], eax
		call	g_hash_table_remove

loc_10008C55:				; CODE XREF: mwSession_removeCipher+34j
					; mwSession_removeCipher+72j ...
		mov	eax, edi
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10008C64:				; CODE XREF: mwSession_removeCipher+18j
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		xor	edi, edi
		mov	[esp+18h+var_14], offset aMwsession_re_1 ; "mwSession_removeCipher"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10008C55
; ---------------------------------------------------------------------------

loc_10008C84:				; CODE XREF: mwSession_removeCipher+1Fj
		mov	[esp+18h+var_10], offset aSCiphersNull ; "s->ciphers !=	NULL"
		xor	edi, edi
		mov	[esp+18h+var_14], offset aMwsession_re_1 ; "mwSession_removeCipher"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10008C55
mwSession_removeCipher endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 319. mwSession_getCipher

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_getCipher
mwSession_getCipher proc near		; CODE XREF: mwChannel_recvCreate+1B9p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	edx, [ebp+arg_0]
		movzx	eax, word ptr [ebp+arg_4]
		test	edx, edx
		jz	short loc_10008CD7
		mov	edx, [edx+5Ch]
		test	edx, edx
		jz	short loc_10008CF7
		movzx	eax, ax
		mov	[ebp+arg_4], eax
		mov	[ebp+arg_0], edx
		leave
		jmp	g_hash_table_lookup
; ---------------------------------------------------------------------------

loc_10008CD7:				; CODE XREF: mwSession_getCipher+Fj
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	[esp+18h+var_14], offset aMwsession_ge_2 ; "mwSession_getCipher"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning

locret_10008CF3:			; CODE XREF: mwSession_getCipher+63j
		leave
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_10008CF7:				; CODE XREF: mwSession_getCipher+16j
		mov	[esp+18h+var_10], offset aSCiphersNull ; "s->ciphers !=	NULL"
		mov	[esp+18h+var_14], offset aMwsession_ge_2 ; "mwSession_getCipher"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short locret_10008CF3
mwSession_getCipher endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 336. mwSession_removeService

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_removeService
mwSession_removeService	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_C], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_4]
		mov	[ebp+var_8], esi
		test	ebx, ebx
		jz	short loc_10008D70
		mov	eax, [ebx+58h]
		test	eax, eax
		jz	short loc_10008D90
		mov	[esp+18h+var_14], edi
		mov	[esp+18h+var_18], eax
		call	g_hash_table_lookup
		test	eax, eax
		mov	esi, eax
		jz	short loc_10008D61
		mov	[esp+18h+var_14], edi
		mov	eax, [ebx+58h]
		mov	[esp+18h+var_18], eax
		call	g_hash_table_remove

loc_10008D61:				; CODE XREF: mwSession_removeService+30j
					; mwSession_removeService+6Ej ...
		mov	eax, esi
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10008D70:				; CODE XREF: mwSession_removeService+17j
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		xor	esi, esi
		mov	[esp+18h+var_14], offset aMwsession_re_2 ; "mwSession_removeService"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10008D61
; ---------------------------------------------------------------------------

loc_10008D90:				; CODE XREF: mwSession_removeService+1Ej
		mov	[esp+18h+var_10], offset aSServicesNull	; "s->services != NULL"
		xor	esi, esi
		mov	[esp+18h+var_14], offset aMwsession_re_2 ; "mwSession_removeService"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10008D61
mwSession_removeService	endp

; Exported entry 326. mwSession_getService

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_getService
mwSession_getService proc near		; CODE XREF: mwChannel_getService+19p
					; mwChannel_recvAccept+BEp ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	eax, eax
		jz	short loc_10008DD3
		mov	eax, [eax+58h]
		test	eax, eax
		jz	short loc_10008DF3
		mov	[ebp+arg_4], edx
		mov	[ebp+arg_0], eax
		leave
		jmp	g_hash_table_lookup
; ---------------------------------------------------------------------------

loc_10008DD3:				; CODE XREF: mwSession_getService+Ej
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	[esp+18h+var_14], offset aMwsession_ge_3 ; "mwSession_getService"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning

locret_10008DEF:			; CODE XREF: mwSession_getService+5Fj
		leave
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_10008DF3:				; CODE XREF: mwSession_getService+15j
		mov	[esp+18h+var_10], offset aSServicesNull	; "s->services != NULL"
		mov	[esp+18h+var_14], offset aMwsession_ge_3 ; "mwSession_getService"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short locret_10008DEF
mwSession_getService endp

; ---------------------------------------------------------------------------
		jmp	short sub_10008E20
; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10008E20	proc near		; CODE XREF: .text:10008E11j
					; mwSession_getProperty+1Cj ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[esp+8+var_4], edx
		mov	eax, [eax+60h]
		mov	[esp+8+var_8], eax
		call	g_hash_table_lookup
		xor	edx, edx
		test	eax, eax
		jz	short locret_10008E3D
		mov	edx, [eax]

locret_10008E3D:			; CODE XREF: sub_10008E20+19j
		leave
		mov	eax, edx
		retn
sub_10008E20	endp

; ---------------------------------------------------------------------------
		jmp	short mwSession_getProperty
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 325. mwSession_getProperty

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_getProperty
mwSession_getProperty proc near		; CODE XREF: .text:10008E41j
					; mwConference_open+12Fp ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	eax, eax
		jz	short loc_10008E6E
		mov	ecx, [eax+60h]
		test	ecx, ecx
		jz	short loc_10008E8E
		test	edx, edx
		jz	short loc_10008EAC
		leave
		jmp	short sub_10008E20
; ---------------------------------------------------------------------------

loc_10008E6E:				; CODE XREF: mwSession_getProperty+Ej
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	[esp+18h+var_14], offset aMwsession_ge_4 ; "mwSession_getProperty"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning

locret_10008E8A:			; CODE XREF: mwSession_getProperty+5Aj
					; mwSession_getProperty+78j
		leave
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_10008E8E:				; CODE XREF: mwSession_getProperty+15j
		mov	[esp+18h+var_10], offset aSAttributesNul ; "s->attributes != NULL"
		mov	[esp+18h+var_14], offset aMwsession_ge_4 ; "mwSession_getProperty"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short locret_10008E8A
; ---------------------------------------------------------------------------

loc_10008EAC:				; CODE XREF: mwSession_getProperty+19j
		mov	[esp+18h+var_10], offset aKeyNull_0 ; "key != NULL"
		mov	[esp+18h+var_14], offset aMwsession_ge_4 ; "mwSession_getProperty"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short locret_10008E8A
mwSession_getProperty endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10008ED0	proc near		; CODE XREF: mwSession_setProperty+25j
					; sub_10009A60+1DAp ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], edi
		mov	edi, eax
		mov	eax, [ebp+arg_0]
		mov	[esp+18h+var_18], ecx
		mov	[ebp+var_C], ebx
		mov	[ebp+var_8], esi
		mov	esi, edx
		mov	[esp+18h+var_14], eax
		call	mw_datum_new
		mov	[esp+18h+var_18], esi
		mov	ebx, eax
		call	g_strdup
		mov	[esp+18h+var_10], ebx
		mov	[esp+18h+var_14], eax
		mov	eax, [edi+60h]
		mov	[esp+18h+var_18], eax
		call	g_hash_table_insert
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
sub_10008ED0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 343. mwSession_setProperty

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_setProperty
mwSession_setProperty proc near

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	ebx
		mov	eax, [ebp+arg_0]
		mov	ebx, [ebp+arg_4]
		mov	ecx, [ebp+arg_8]
		mov	edx, [ebp+arg_C]
		test	eax, eax
		jz	short loc_10008F47
		cmp	dword ptr [eax+60h], 0
		jz	short loc_10008F63
		test	ebx, ebx
		jz	short loc_10008F6C
		mov	[ebp+arg_0], edx
		mov	edx, ebx
		pop	ebx
		pop	ebp
		jmp	short sub_10008ED0
; ---------------------------------------------------------------------------

loc_10008F47:				; CODE XREF: mwSession_setProperty+12j
		mov	[ebp+arg_8], offset aSNull_0 ; "s != NULL"

loc_10008F4E:				; CODE XREF: mwSession_setProperty+4Aj
					; mwSession_setProperty+53j
		mov	[ebp+arg_4], offset aMwsession_setp ; "mwSession_setProperty"
		mov	[ebp+arg_0], offset aMeanwhile_4 ; "meanwhile"
		pop	ebx
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_10008F63:				; CODE XREF: mwSession_setProperty+18j
		mov	[ebp+arg_8], offset aSAttributesNul ; "s->attributes !=	NULL"
		jmp	short loc_10008F4E
; ---------------------------------------------------------------------------

loc_10008F6C:				; CODE XREF: mwSession_setProperty+1Cj
		mov	[ebp+arg_8], offset aKeyNull_0 ; "key != NULL"
		jmp	short loc_10008F4E
mwSession_setProperty endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 320. mwSession_getCiphers

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_getCiphers
mwSession_getCiphers proc near		; CODE XREF: mwChannel_populateSupportedCipherInstances+18p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10008F9D
		mov	eax, [eax+5Ch]
		test	eax, eax
		jz	short loc_10008FBD
		mov	[ebp+arg_0], eax
		leave
		jmp	map_collect_values
; ---------------------------------------------------------------------------

loc_10008F9D:				; CODE XREF: mwSession_getCiphers+Bj
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	[esp+18h+var_14], offset aMwsession_ge_5 ; "mwSession_getCiphers"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning

locret_10008FB9:			; CODE XREF: mwSession_getCiphers+59j
		leave
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_10008FBD:				; CODE XREF: mwSession_getCiphers+12j
		mov	[esp+18h+var_10], offset aSCiphersNull ; "s->ciphers !=	NULL"
		mov	[esp+18h+var_14], offset aMwsession_ge_5 ; "mwSession_getCiphers"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short locret_10008FB9
mwSession_getCiphers endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 327. mwSession_getServices

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_getServices
mwSession_getServices proc near		; CODE XREF: mwSession_stop+4Ep
					; sub_10009A60+53Fp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10008FFD
		mov	eax, [eax+58h]
		test	eax, eax
		jz	short loc_1000901D
		mov	[ebp+arg_0], eax
		leave
		jmp	map_collect_values
; ---------------------------------------------------------------------------

loc_10008FFD:				; CODE XREF: mwSession_getServices+Bj
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	[esp+18h+var_14], offset aMwsession_ge_6 ; "mwSession_getServices"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning

locret_10009019:			; CODE XREF: mwSession_getServices+59j
		leave
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1000901D:				; CODE XREF: mwSession_getServices+12j
		mov	[esp+18h+var_10], offset aSServicesNull	; "s->services != NULL"
		mov	[esp+18h+var_14], offset aMwsession_ge_6 ; "mwSession_getServices"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short locret_10009019
mwSession_getServices endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 314. mwSession_addCipher

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_addCipher
mwSession_addCipher proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_0]
		mov	ebx, [ebp+arg_4]
		test	esi, esi
		jz	loc_10009135
		test	ebx, ebx
		jz	loc_10009158
		mov	eax, [esi+5Ch]
		test	eax, eax
		jz	loc_1000917B
		mov	[esp+18h+var_18], ebx
		call	mwCipher_getType
		movzx	eax, ax
		mov	[esp+18h+var_14], eax
		mov	eax, [esi+5Ch]
		mov	[esp+18h+var_18], eax
		call	g_hash_table_lookup
		test	eax, eax
		jz	short loc_100090D0
		mov	[esp+18h+var_18], ebx
		call	mwCipher_getName
		mov	edx, offset aNull_1 ; "(null)"
		test	eax, eax
		jz	short loc_100090A2
		mov	[esp+18h+var_18], ebx
		call	mwCipher_getName
		mov	edx, eax

loc_100090A2:				; CODE XREF: mwSession_addCipher+56j
		mov	[esp+18h+var_C], edx
		mov	[esp+18h+var_10], offset aCipherSIsAlrea ; "cipher %s is already added,	apparently"
		mov	[esp+18h+var_14], 20h
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_log
		xor	eax, eax

loc_100090C4:				; CODE XREF: mwSession_addCipher+113j
					; mwSession_addCipher+136j ...
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_100090D0:				; CODE XREF: mwSession_addCipher+45j
		mov	[esp+18h+var_18], ebx
		call	mwCipher_getName
		mov	edx, offset aNull_1 ; "(null)"
		test	eax, eax
		jz	short loc_100090EB
		mov	[esp+18h+var_18], ebx
		call	mwCipher_getName
		mov	edx, eax

loc_100090EB:				; CODE XREF: mwSession_addCipher+9Fj
		mov	[esp+18h+var_C], edx
		mov	[esp+18h+var_10], offset aAddingCipherS	; "adding cipher %s"
		mov	[esp+18h+var_14], 20h
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_log
		mov	[esp+18h+var_18], ebx
		call	mwCipher_getType
		mov	[esp+18h+var_10], ebx
		movzx	eax, ax
		mov	[esp+18h+var_14], eax
		mov	eax, [esi+5Ch]
		mov	[esp+18h+var_18], eax
		call	g_hash_table_insert
		add	esp, 10h
		mov	eax, 1
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10009135:				; CODE XREF: mwSession_addCipher+10j
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	[esp+18h+var_14], offset aMwsession_addc ; "mwSession_addCipher"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		jmp	loc_100090C4
; ---------------------------------------------------------------------------

loc_10009158:				; CODE XREF: mwSession_addCipher+18j
		mov	[esp+18h+var_10], offset aCNull	; "c !=	NULL"
		mov	[esp+18h+var_14], offset aMwsession_addc ; "mwSession_addCipher"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		jmp	loc_100090C4
; ---------------------------------------------------------------------------

loc_1000917B:				; CODE XREF: mwSession_addCipher+23j
		mov	[esp+18h+var_10], offset aSCiphersNull ; "s->ciphers !=	NULL"
		mov	[esp+18h+var_14], offset aMwsession_addc ; "mwSession_addCipher"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		jmp	loc_100090C4
mwSession_addCipher endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100091A0	proc near		; CODE XREF: mwSession_forceLogin+25p
					; mwSession_stop+46p ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		test	eax, eax
		mov	[ebp+var_C], ebx
		mov	ebx, ecx
		mov	[ebp+var_8], esi
		mov	esi, eax
		mov	[ebp+var_4], edi
		mov	edi, edx
		jz	loc_100092AA
		mov	edx, [eax]
		test	edx, edx
		jz	loc_100092CB
		mov	[esp+28h+var_28], eax
		call	mwSession_getState
		cmp	eax, edi
		jz	short loc_10009225
		cmp	edi, 4
		mov	[esi+4], edi
		mov	[esi+8], ebx
		jz	loc_10009267
		jnb	short loc_10009232

loc_100091E4:				; CODE XREF: sub_100091A0+98j
		mov	eax, edi
		call	sub_100087B0
		mov	[esp+28h+var_20], offset aSessionStateS	; "session state: %s"
		mov	[esp+28h+var_24], 20h
		mov	[esp+28h+var_28], offset aMeanwhile_4 ;	"meanwhile"
		mov	[esp+28h+var_1C], eax
		call	g_log

loc_1000920B:				; CODE XREF: sub_100091A0+C5j
					; sub_100091A0+105j
		mov	eax, [esi]
		test	eax, eax
		jz	short loc_10009225
		mov	eax, [eax+0Ch]
		test	eax, eax
		jz	short loc_10009225
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_24], edi
		mov	[esp+28h+var_28], esi
		call	eax

loc_10009225:				; CODE XREF: sub_100091A0+31j
					; sub_100091A0+6Fj ...
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10009232:				; CODE XREF: sub_100091A0+42j
		lea	eax, [edi-7]
		cmp	eax, 1
		ja	short loc_100091E4
		mov	eax, edi
		call	sub_100087B0
		mov	[esp+28h+var_18], ebx
		mov	[esp+28h+var_20], offset aSessionStateS0 ; "session state: %s (0x%08x)"
		mov	[esp+28h+var_24], 20h
		mov	[esp+28h+var_28], offset aMeanwhile_4 ;	"meanwhile"
		mov	[esp+28h+var_1C], eax
		call	g_log
		jmp	short loc_1000920B
; ---------------------------------------------------------------------------

loc_10009267:				; CODE XREF: sub_100091A0+3Cj
		test	ebx, ebx
		mov	eax, offset aNull_1 ; "(null)"
		cmovnz	eax, ebx
		mov	[ebp+var_10], eax
		mov	eax, 4
		call	sub_100087B0
		mov	edx, [ebp+var_10]
		mov	[esp+28h+var_20], offset aSessionStateSS ; "session state: %s (%s)"
		mov	[esp+28h+var_24], 20h
		mov	[esp+28h+var_28], offset aMeanwhile_4 ;	"meanwhile"
		mov	[esp+28h+var_18], edx
		mov	[esp+28h+var_1C], eax
		call	g_log
		jmp	loc_1000920B
; ---------------------------------------------------------------------------

loc_100092AA:				; CODE XREF: sub_100091A0+17j
		mov	[esp+28h+var_20], offset aSNull_0 ; "s != NULL"
		mov	[esp+28h+var_24], offset aState_0 ; "state"
		mov	[esp+28h+var_28], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10009225
; ---------------------------------------------------------------------------

loc_100092CB:				; CODE XREF: sub_100091A0+21j
		mov	[esp+28h+var_20], offset aSHandlerNull ; "s->handler !=	NULL"
		mov	[esp+28h+var_24], offset aState_0 ; "state"
		mov	[esp+28h+var_28], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10009225
sub_100091A0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100092F0	proc near		; CODE XREF: mwSession_send+A5p
					; sub_10009A60+13Bp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_C], ebx
		mov	[ebp+var_8], esi
		mov	esi, eax
		mov	[ebp+var_4], edi
		mov	eax, [eax]
		mov	edi, edx
		lea	ebx, [esi+3Ch]
		mov	[esp+18h+var_18], ebx
		mov	[ebp+var_10], eax
		call	mwUserStatus_clear
		lea	eax, [edi+10h]
		mov	[esp+18h+var_14], eax
		mov	[esp+18h+var_18], ebx
		call	mwUserStatus_clone
		mov	ecx, [ebp+var_10]
		test	ecx, ecx
		jz	short loc_10009338
		mov	edx, [ebp+var_10]
		mov	eax, [edx+14h]
		test	eax, eax
		jz	short loc_10009338
		mov	[esp+18h+var_18], esi
		call	eax

loc_10009338:				; CODE XREF: sub_100092F0+37j
					; sub_100092F0+41j
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
sub_100092F0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 337. mwSession_send

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_send
mwSession_send	proc near		; CODE XREF: sub_10001E60+91p
					; mwChannel_destroy+93p ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_C], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_4]
		mov	[ebp+var_8], esi
		test	ebx, ebx
		jz	loc_100093FC
		xor	esi, esi
		test	edi, edi
		jz	short loc_100093DE
		call	mwPutBuffer_new
		mov	[esp+28h+var_24], edi
		mov	ebx, eax
		mov	[esp+28h+var_28], eax
		call	mwMessage_put
		mov	[esp+28h+var_24], ebx
		lea	ebx, [ebp+var_14]
		mov	[esp+28h+var_28], ebx
		call	mwPutBuffer_finalize
		call	mwPutBuffer_new
		mov	[esp+28h+var_24], ebx
		mov	esi, eax
		mov	[esp+28h+var_28], eax
		call	mwOpaque_put
		mov	[esp+28h+var_28], ebx
		call	mwOpaque_clear
		mov	[esp+28h+var_24], esi
		mov	[esp+28h+var_28], ebx
		call	mwPutBuffer_finalize
		mov	ecx, [ebp+var_14]
		mov	edx, [ebp+var_10]
		mov	eax, [ebp+arg_0]
		call	sub_100089D0
		mov	[esp+28h+var_28], ebx
		mov	esi, eax
		call	mwOpaque_clear
		test	esi, esi
		jnz	short loc_100093DE
		cmp	word ptr [edi],	9
		jz	short loc_100093F0

loc_100093DE:				; CODE XREF: mwSession_send+21j
					; mwSession_send+86j ...
		mov	eax, esi
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_100093F0:				; CODE XREF: mwSession_send+8Cj
		mov	eax, [ebp+arg_0]
		mov	edx, edi
		call	sub_100092F0
		jmp	short loc_100093DE
; ---------------------------------------------------------------------------

loc_100093FC:				; CODE XREF: mwSession_send+17j
		mov	[esp+28h+var_20], offset aSNull_0 ; "s != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwsession_se_0 ; "mwSession_send"
		mov	[esp+28h+var_28], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100093DE
mwSession_send	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 340. mwSession_senseService

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_senseService
mwSession_senseService proc near	; CODE XREF: mwSession_addService+8Cp
					; sub_10013C90+4Cj ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		test	esi, esi
		jz	short loc_1000947B
		test	edi, edi
		jz	short loc_100094A4
		mov	[esp+18h+var_18], esi
		call	mwSession_getState
		cmp	eax, 6
		jnz	short loc_100094C2
		mov	[esp+18h+var_18], 11h
		call	mwMessage_new
		mov	[eax+10h], edi
		mov	ebx, eax
		mov	[esp+18h+var_18], esi
		mov	[esp+18h+var_14], eax
		call	mwSession_send
		mov	esi, [ebp+var_8]
		mov	[ebp+arg_0], ebx
		mov	edi, [ebp+var_4]
		mov	ebx, [ebp+var_C]
		mov	esp, ebp
		pop	ebp
		jmp	mwMessage_free
; ---------------------------------------------------------------------------

loc_1000947B:				; CODE XREF: mwSession_senseService+17j
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	[esp+18h+var_14], offset aMwsession_sens ; "mwSession_senseService"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning

loc_10009497:				; CODE XREF: mwSession_senseService+A0j
					; mwSession_senseService+BEj
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100094A4:				; CODE XREF: mwSession_senseService+1Bj
		mov	[esp+18h+var_10], offset aSrvc0x00 ; "srvc != 0x00"
		mov	[esp+18h+var_14], offset aMwsession_sens ; "mwSession_senseService"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10009497
; ---------------------------------------------------------------------------

loc_100094C2:				; CODE XREF: mwSession_senseService+28j
		mov	[esp+18h+var_10], offset aMwsession_isst ; "mwSession_isStarted(s)"
		mov	[esp+18h+var_14], offset aMwsession_sens ; "mwSession_senseService"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10009497
mwSession_senseService endp

; Exported entry 315. mwSession_addService

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_addService
mwSession_addService proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	ebx, [ebp+arg_0]
		mov	esi, [ebp+arg_4]
		test	ebx, ebx
		jz	loc_10009578
		test	esi, esi
		jz	loc_10009598
		mov	eax, [ebx+58h]
		test	eax, eax
		jz	loc_100095BB
		mov	[esp+18h+var_18], esi
		call	mwService_getType
		mov	[esp+18h+var_14], eax
		mov	eax, [ebx+58h]
		mov	[esp+18h+var_18], eax
		call	g_hash_table_lookup
		xor	edx, edx
		test	eax, eax
		jz	short loc_10009530

loc_10009526:				; CODE XREF: mwSession_addService+7Bj
					; mwSession_addService+96j ...
		add	esp, 10h
		mov	eax, edx
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10009530:				; CODE XREF: mwSession_addService+44j
		mov	[esp+18h+var_18], esi
		call	mwService_getType
		mov	[esp+18h+var_10], esi
		mov	[esp+18h+var_14], eax
		mov	eax, [ebx+58h]
		mov	[esp+18h+var_18], eax
		call	g_hash_table_insert
		mov	[esp+18h+var_18], ebx
		call	mwSession_getState
		mov	edx, 1
		cmp	eax, 6
		jnz	short loc_10009526
		mov	[esp+18h+var_18], esi
		call	mwService_getType
		mov	[esp+18h+var_18], ebx
		mov	[esp+18h+var_14], eax
		call	mwSession_senseService
		mov	edx, 1
		jmp	short loc_10009526
; ---------------------------------------------------------------------------

loc_10009578:				; CODE XREF: mwSession_addService+10j
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	[esp+18h+var_14], offset aMwsession_adds ; "mwSession_addService"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	edx, edx
		jmp	short loc_10009526
; ---------------------------------------------------------------------------

loc_10009598:				; CODE XREF: mwSession_addService+18j
		mov	[esp+18h+var_10], offset aSrvNull ; "srv != NULL"
		mov	[esp+18h+var_14], offset aMwsession_adds ; "mwSession_addService"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	edx, edx
		jmp	loc_10009526
; ---------------------------------------------------------------------------

loc_100095BB:				; CODE XREF: mwSession_addService+23j
		mov	[esp+18h+var_10], offset aSServicesNull	; "s->services != NULL"
		mov	[esp+18h+var_14], offset aMwsession_adds ; "mwSession_addService"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	edx, edx
		jmp	loc_10009526
mwSession_addService endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 344. mwSession_setUserStatus

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_setUserStatus
mwSession_setUserStatus	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_0]
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		test	edi, edi
		jz	short loc_1000963F
		test	esi, esi
		jz	short loc_10009662
		mov	[esp+18h+var_18], 9
		call	mwMessage_new
		mov	[esp+18h+var_14], esi
		mov	ebx, eax
		lea	eax, [eax+10h]
		mov	[esp+18h+var_18], eax
		call	mwUserStatus_clone
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+var_18], edi
		call	mwSession_send
		mov	[esp+18h+var_18], ebx
		mov	esi, eax
		call	mwMessage_free

loc_10009630:				; CODE XREF: mwSession_setUserStatus+80j
					; mwSession_setUserStatus+A3j
		mov	eax, esi
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000963F:				; CODE XREF: mwSession_setUserStatus+17j
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+18h+var_14], offset aMwsession_setu ; "mwSession_setUserStatus"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10009630
; ---------------------------------------------------------------------------

loc_10009662:				; CODE XREF: mwSession_setUserStatus+1Bj
		mov	[esp+18h+var_10], offset aStatNull_0 ; "stat !=	NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+18h+var_14], offset aMwsession_setu ; "mwSession_setUserStatus"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10009630
mwSession_setUserStatus	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 342. mwSession_setPrivacyInfo

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_setPrivacyInfo
mwSession_setPrivacyInfo proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_0]
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		test	edi, edi
		jz	short loc_100096EF
		test	esi, esi
		jz	short loc_10009712
		mov	[esp+18h+var_18], 0Bh
		call	mwMessage_new
		mov	[esp+18h+var_14], esi
		mov	ebx, eax
		lea	eax, [eax+10h]
		mov	[esp+18h+var_18], eax
		call	mwPrivacyInfo_clone
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+var_18], edi
		call	mwSession_send
		mov	[esp+18h+var_18], ebx
		mov	esi, eax
		call	mwMessage_free

loc_100096E0:				; CODE XREF: mwSession_setPrivacyInfo+80j
					; mwSession_setPrivacyInfo+A3j
		mov	eax, esi
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100096EF:				; CODE XREF: mwSession_setPrivacyInfo+17j
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+18h+var_14], offset aMwsession_se_1 ; "mwSession_setPrivacyInfo"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100096E0
; ---------------------------------------------------------------------------

loc_10009712:				; CODE XREF: mwSession_setPrivacyInfo+1Bj
		mov	[esp+18h+var_10], offset aPrivacyNull ;	"privacy != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+18h+var_14], offset aMwsession_se_1 ; "mwSession_setPrivacyInfo"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100096E0
mwSession_setPrivacyInfo endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 338. mwSession_sendAnnounce

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_sendAnnounce
mwSession_sendAnnounce proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_0]
		test	esi, esi
		jz	short loc_100097AA
		mov	[esp+18h+var_18], esi
		call	mwSession_getState
		cmp	eax, 6
		jnz	short loc_100097CD
		mov	[esp+18h+var_18], 22h
		call	mwMessage_new
		mov	ebx, eax
		mov	eax, [ebp+arg_C]
		mov	[ebx+44h], eax
		mov	eax, [ebp+arg_4]
		mov	[ebx+3Ch], eax
		mov	eax, [ebp+arg_8]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[ebx+40h], eax
		mov	[esp+18h+var_18], esi
		mov	[esp+18h+var_14], ebx
		call	mwSession_send
		mov	dword ptr [ebx+44h], 0
		mov	[esp+18h+var_18], ebx
		mov	esi, eax
		call	mwMessage_free

loc_100097A1:				; CODE XREF: mwSession_sendAnnounce+8Bj
					; mwSession_sendAnnounce+AEj
		add	esp, 10h
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100097AA:				; CODE XREF: mwSession_sendAnnounce+Dj
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+18h+var_14], offset aMwsession_se_2 ; "mwSession_sendAnnounce"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100097A1
; ---------------------------------------------------------------------------

loc_100097CD:				; CODE XREF: mwSession_sendAnnounce+1Aj
		mov	[esp+18h+var_10], offset aMwsession_isst ; "mwSession_isStarted(s)"
		mov	esi, 0FFFFFFFFh
		mov	[esp+18h+var_14], offset aMwsession_se_2 ; "mwSession_sendAnnounce"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100097A1
mwSession_sendAnnounce endp

; Exported entry 316. mwSession_forceLogin

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_forceLogin
mwSession_forceLogin proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_0]
		test	esi, esi
		jz	short loc_10009847
		mov	[esp+18h+var_18], esi
		call	mwSession_getState
		cmp	eax, 4
		jnz	short loc_1000986A
		xor	ecx, ecx
		mov	edx, 0Ah
		mov	eax, esi
		call	sub_100091A0
		mov	[esp+18h+var_18], 16h
		call	mwMessage_new
		mov	[esp+18h+var_18], esi
		mov	ebx, eax
		mov	[esp+18h+var_14], eax
		call	mwSession_send
		mov	[esp+18h+var_18], ebx
		mov	esi, eax
		call	mwMessage_free

loc_1000983E:				; CODE XREF: mwSession_forceLogin+78j
					; mwSession_forceLogin+9Bj
		add	esp, 10h
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10009847:				; CODE XREF: mwSession_forceLogin+Dj
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+18h+var_14], offset aMwsession_forc ; "mwSession_forceLogin"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000983E
; ---------------------------------------------------------------------------

loc_1000986A:				; CODE XREF: mwSession_forceLogin+1Aj
		mov	[esp+18h+var_10], offset aMwsession_is_0 ; "mwSession_isState(s, mwSession_LOGIN_RE"...
		mov	esi, 0FFFFFFFFh
		mov	[esp+18h+var_14], offset aMwsession_forc ; "mwSession_forceLogin"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000983E
mwSession_forceLogin endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10009890	proc near		; CODE XREF: mwSession_stop+AAp
					; mwSession_recv+F7p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h

		push	ebp
		mov	ebp, esp
		push	ebx
		mov	ebx, eax
		sub	esp, 14h
		test	eax, eax
		jz	short loc_100098C3
		mov	eax, [eax+0Ch]
		mov	[esp+18h+var_18], eax
		call	g_free
		mov	dword ptr [ebx+0Ch], 0
		mov	dword ptr [ebx+10h], 0
		mov	dword ptr [ebx+14h], 0

loc_100098BD:				; CODE XREF: sub_10009890+4Fj
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100098C3:				; CODE XREF: sub_10009890+Bj
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	[esp+18h+var_14], offset aSession_buf_fr ; "session_buf_free"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100098BD
sub_10009890	endp

; ---------------------------------------------------------------------------
		jmp	short mwSession_stop
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 346. mwSession_stop

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_stop
mwSession_stop	proc near		; CODE XREF: .text:100098E1j
					; sub_10009A60+10Ap ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	esi, [ebp+arg_0]
		mov	eax, [ebp+arg_4]
		test	esi, esi
		mov	[ebp+var_10], eax
		jz	loc_10009A00
		mov	[esp+28h+var_28], esi
		call	mwSession_getState
		cmp	eax, 8
		jz	loc_100099D0
		mov	[esp+28h+var_28], esi
		call	mwSession_getState
		cmp	eax, 7
		jz	loc_100099D0
		mov	ecx, [ebp+var_10]
		mov	edx, 7
		mov	eax, esi
		call	sub_100091A0
		mov	[esp+28h+var_28], esi
		call	mwSession_getServices
		test	eax, eax
		mov	edi, eax
		jz	loc_100099F4
		mov	ebx, eax
		nop

loc_10009950:				; CODE XREF: mwSession_stop+6Fj
		mov	eax, [ebx]
		mov	[esp+28h+var_28], eax
		call	mwService_stop
		mov	ebx, [ebx+4]
		test	ebx, ebx
		jnz	short loc_10009950
		mov	[esp+28h+var_28], edi

loc_10009964:				; CODE XREF: mwSession_stop+10Bj
		call	g_list_free
		mov	[esp+28h+var_28], 3
		call	mwMessage_new
		mov	ebx, eax
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+var_10]
		mov	[ebx+10h], eax
		mov	[esp+28h+var_24], ebx
		mov	[esp+28h+var_28], esi
		call	mwSession_send
		mov	[esp+28h+var_28], ebx
		call	mwMessage_free
		mov	eax, esi
		call	sub_10009890
		mov	eax, [esi]
		test	eax, eax
		jz	short loc_10009A1E
		mov	eax, [eax+4]
		test	eax, eax
		jz	loc_10009A3F
		mov	[esp+28h+var_28], esi
		call	eax

loc_100099B5:				; CODE XREF: mwSession_stop+14Aj
					; mwSession_stop+16Bj
		mov	ecx, [ebp+var_10]
		mov	eax, esi
		add	esp, 1Ch
		pop	ebx
		mov	edx, 8
		pop	esi
		pop	edi
		pop	ebp
		jmp	sub_100091A0
; ---------------------------------------------------------------------------
		align 10h

loc_100099D0:				; CODE XREF: mwSession_stop+25j
					; mwSession_stop+36j
		mov	[esp+28h+var_20], offset aAttemptedToSto ; "attempted to stop session that is alrea"...
		mov	[esp+28h+var_24], 80h
		mov	[esp+28h+var_28], offset aMeanwhile_4 ;	"meanwhile"
		call	g_log

loc_100099EC:				; CODE XREF: mwSession_stop+12Cj
		add	esp, 1Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100099F4:				; CODE XREF: mwSession_stop+57j
		mov	[esp+28h+var_28], 0
		jmp	loc_10009964
; ---------------------------------------------------------------------------

loc_10009A00:				; CODE XREF: mwSession_stop+14j
		mov	[esp+28h+var_20], offset aSNull_0 ; "s != NULL"
		mov	[esp+28h+var_24], offset aMwsession_stop ; "mwSession_stop"
		mov	[esp+28h+var_28], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100099EC
; ---------------------------------------------------------------------------

loc_10009A1E:				; CODE XREF: mwSession_stop+B3j
		mov	[esp+28h+var_20], offset aSHandlerNull ; "s->handler !=	NULL"
		mov	[esp+28h+var_24], offset aIo_close ; "io_close"
		mov	[esp+28h+var_28], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_100099B5
; ---------------------------------------------------------------------------

loc_10009A3F:				; CODE XREF: mwSession_stop+BAj
		mov	[esp+28h+var_20], offset aSHandlerIo_clo ; "s->handler->io_close != NULL"
		mov	[esp+28h+var_24], offset aIo_close ; "io_close"
		mov	[esp+28h+var_28], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_100099B5
mwSession_stop	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10009A60	proc near		; CODE XREF: mwSession_recv+EFp
					; mwSession_recv+21Fp ...

Str		= dword	ptr -78h
var_74		= dword	ptr -74h
var_70		= dword	ptr -70h
var_6C		= dword	ptr -6Ch
var_68		= dword	ptr -68h
var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_4C		= dword	ptr -4Ch
var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= byte ptr -24h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_11		= byte ptr -11h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 78h
		test	eax, eax
		mov	[ebp+var_4], edi
		mov	edi, eax
		mov	[ebp+var_C], ebx
		mov	[ebp+var_8], esi
		mov	[ebp+var_1C], ecx
		mov	[ebp+var_18], edx
		jz	loc_1000A173
		test	edx, edx
		jz	loc_1000A1B5
		test	ecx, ecx
		jnz	short loc_10009A98

loc_10009A8B:				; CODE XREF: sub_10009A60+18Ej
					; sub_10009A60+72Fj ...
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10009A98:				; CODE XREF: sub_10009A60+29j
		lea	esi, [ebp+var_1C]
		mov	[esp+78h+Str], esi
		call	mwGetBuffer_wrap
		mov	ebx, eax
		mov	[esp+78h+Str], eax
		call	mwMessage_get
		mov	[esp+78h+Str], ebx
		mov	[ebp+var_58], eax
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_10009B71

loc_10009AC0:				; CODE XREF: sub_10009A60+121j
		mov	[esp+78h+Str], ebx
		call	mwGetBuffer_free
		mov	eax, [ebp+var_58]
		test	eax, eax
		jz	loc_1000A1D6
		mov	edx, [ebp+var_58]
		movzx	eax, word ptr [edx]
		cmp	ax, 0Bh
		jz	loc_1000A005
		jbe	short loc_10009B30
		cmp	ax, 19h
		jz	loc_10009FDC
		nop
		ja	loc_10009BA2
		cmp	ax, 11h
		lea	esi, [esi+0]
		jz	loc_10009EA6
		cmp	ax, 18h
		lea	esi, [esi+0]
		jnz	loc_10009BC0
		mov	eax, [ebp+var_58]
		mov	edx, 4
		mov	ecx, [eax+10h]
		mov	eax, edi
		call	sub_100091A0
		jmp	loc_10009BE3
; ---------------------------------------------------------------------------
		align 10h

loc_10009B30:				; CODE XREF: sub_10009A60+83j
		cmp	ax, 4
		jz	loc_10009EF6
		lea	esi, [esi+0]
		ja	short loc_10009B86
		cmp	ax, 2
		jz	loc_10009ECD
		cmp	ax, 3
		jnz	short loc_10009BC0
		mov	edx, [ebp+var_58]
		mov	eax, [edx+4]
		test	eax, eax
		jnz	loc_1000A08F
		mov	eax, [edx+10h]
		mov	[esp+78h+Str], edi
		mov	[esp+78h+var_74], eax
		call	mwSession_stop
		jmp	short loc_10009BE3
; ---------------------------------------------------------------------------

loc_10009B71:				; CODE XREF: sub_10009A60+5Aj
		mov	[esp+78h+var_74], offset aParsingOfMessa ; "parsing of message failed"
		mov	[esp+78h+Str], esi
		call	mw_mailme_opaque
		jmp	loc_10009AC0
; ---------------------------------------------------------------------------

loc_10009B86:				; CODE XREF: sub_10009A60+E0j
		cmp	ax, 6
		jz	loc_10009E75
		cmp	ax, 9
		jnz	short loc_10009BC0
		mov	edx, [ebp+var_58]
		mov	eax, edi
		call	sub_100092F0
		jmp	short loc_10009BE3
; ---------------------------------------------------------------------------

loc_10009BA2:				; CODE XREF: sub_10009A60+90j
		cmp	ax, 8000h
		jz	short loc_10009BF3
		cmp	ax, 8001h
		lea	esi, [esi+0]
		jz	loc_10009F60
		cmp	ax, 22h
		jz	loc_10009F27

loc_10009BC0:				; CODE XREF: sub_10009A60+B0j
					; sub_10009A60+F0j ...
		movzx	eax, ax
		mov	[esp+78h+var_6C], eax
		mov	[esp+78h+var_70], offset aUnknownMessa_1 ; "unknown message type 0x%04x, no handler"
		mov	[esp+78h+var_74], 10h
		mov	[esp+78h+Str], offset aMeanwhile_4 ; "meanwhile"
		call	g_log

loc_10009BE3:				; CODE XREF: sub_10009A60+C8j
					; sub_10009A60+10Fj ...
		mov	eax, [ebp+var_58]
		mov	[esp+78h+Str], eax
		call	mwMessage_free
		jmp	loc_10009A8B
; ---------------------------------------------------------------------------

loc_10009BF3:				; CODE XREF: sub_10009A60+146j
		mov	[esp+78h+Str], edi
		call	mwSession_getState
		sub	eax, 1
		xchg	ax, ax
		jnz	loc_1000A05D

loc_10009C06:				; CODE XREF: sub_10009A60+608j
		mov	[esp+78h+Str], edi
		call	mwSession_getState
		cmp	eax, 0Ah
		jz	loc_1000A194
		xor	ecx, ecx
		mov	edx, 2
		mov	eax, edi
		call	sub_100091A0
		mov	eax, [ebp+var_58]
		mov	edx, offset aServer_version ; "server.version.major"
		movzx	ecx, word ptr [eax+10h]
		mov	eax, edi
		mov	[esp+78h+Str], 0
		call	sub_10008ED0
		mov	edx, [ebp+var_58]
		mov	eax, edi
		movzx	ecx, word ptr [edx+12h]
		mov	edx, offset aServer_versi_0 ; "server.version.minor"
		mov	[esp+78h+Str], 0
		call	sub_10008ED0
		mov	[esp+78h+Str], 1
		call	mwMessage_new
		mov	edx, offset aClient_id ; "client.id"
		mov	[ebp+var_54], eax
		mov	eax, edi
		call	sub_10008E20
		mov	ecx, [ebp+var_54]
		mov	edx, offset aSession_auth_u ; "session.auth.user"
		mov	[ecx+10h], ax
		mov	eax, edi
		call	sub_10008E20
		mov	[esp+78h+Str], eax
		call	g_strdup
		mov	edx, [ebp+var_54]
		mov	[edx+14h], eax
		mov	edx, offset aSession_auth_p ; "session.auth.password"
		mov	eax, edi
		call	sub_10008E20
		mov	ecx, [ebp+var_58]
		cmp	dword ptr [ecx+1Ch], 3Fh
		mov	[ebp+var_40], eax
		jbe	loc_1000A0BA
		mov	eax, [ebp+var_54]
		mov	esi, [ecx+18h]
		mov	word ptr [eax+18h], 4
		call	mwMpi_new
		mov	[ebp+var_44], eax
		call	mwMpi_new
		mov	[ebp+var_48], eax
		call	mwMpi_new
		mov	[ebp+var_4C], eax
		call	mwMpi_new
		lea	edx, [ebp+var_24]
		mov	[esp+78h+Str], edx
		mov	[ebp+var_50], eax
		call	mwIV_init
		mov	ecx, [ebp+var_48]
		mov	eax, [ebp+var_44]
		mov	[esp+78h+var_74], ecx
		mov	[esp+78h+Str], eax
		call	mwMpi_randDHKeypair
		mov	eax, [ebp+var_58]
		mov	edx, [ebp+var_4C]
		add	eax, 1Ch
		mov	[esp+78h+var_74], eax
		mov	[esp+78h+Str], edx
		call	mwMpi_import
		mov	edx, [ebp+var_50]
		mov	ecx, [ebp+var_44]
		mov	eax, [ebp+var_4C]
		mov	[esp+78h+Str], edx
		mov	[esp+78h+var_70], ecx
		mov	[esp+78h+var_74], eax
		call	mwMpi_calculateDHShared
		call	mwPutBuffer_new
		mov	[esp+78h+var_74], esi
		lea	esi, [ebp+var_34]
		mov	ebx, eax
		mov	[esp+78h+Str], eax
		call	guint32_put
		mov	ecx, [ebp+var_40]
		mov	[esp+78h+Str], ebx ; int
		mov	[esp+78h+var_74], ecx ;	char *
		call	mwString_put
		lea	eax, [ebp+var_3C]
		mov	[esp+78h+Str], eax
		mov	[esp+78h+var_74], ebx
		call	mwPutBuffer_finalize
		mov	edx, [ebp+var_50]
		mov	[esp+78h+var_74], esi
		mov	[esp+78h+Str], edx
		call	mwMpi_export
		lea	eax, [ebp+var_3C]
		mov	[esp+78h+var_6C], eax
		mov	eax, [ebp+var_30]
		lea	edx, [ebp+var_24]
		lea	ecx, [ebp+var_2C]
		mov	[esp+78h+var_70], edx
		mov	[esp+78h+var_68], ecx
		sub	eax, 10h
		add	eax, [ebp+var_34]
		mov	[esp+78h+var_74], 10h
		mov	[esp+78h+Str], eax
		call	mwEncrypt
		mov	[esp+78h+Str], esi
		call	mwOpaque_clear
		mov	ecx, [ebp+var_48]
		mov	[esp+78h+var_74], esi
		mov	[esp+78h+Str], ecx
		call	mwMpi_export
		call	mwPutBuffer_new
		mov	[esp+78h+var_74], 1
		mov	ebx, eax
		mov	[esp+78h+Str], eax
		call	guint16_put
		mov	[esp+78h+var_74], esi
		mov	[esp+78h+Str], ebx
		call	mwOpaque_put
		lea	eax, [ebp+var_2C]
		mov	[esp+78h+var_74], eax
		mov	[esp+78h+Str], ebx
		call	mwOpaque_put
		mov	eax, [ebp+var_54]
		mov	[esp+78h+var_74], ebx
		add	eax, 1Ch
		mov	[esp+78h+Str], eax
		call	mwPutBuffer_finalize
		lea	edx, [ebp+var_3C]
		mov	[esp+78h+Str], edx
		call	mwOpaque_clear
		mov	[esp+78h+Str], esi
		call	mwOpaque_clear
		lea	ecx, [ebp+var_2C]
		mov	[esp+78h+Str], ecx
		call	mwOpaque_clear
		mov	eax, [ebp+var_44]
		mov	[esp+78h+Str], eax
		call	mwMpi_free
		mov	edx, [ebp+var_48]
		mov	[esp+78h+Str], edx
		call	mwMpi_free
		mov	ecx, [ebp+var_4C]
		mov	[esp+78h+Str], ecx
		call	mwMpi_free
		mov	eax, [ebp+var_50]
		mov	[esp+78h+Str], eax
		call	mwMpi_free

loc_10009E3E:				; CODE XREF: sub_10009A60+70Ej
		mov	eax, [ebp+var_54]
		mov	[esp+78h+Str], edi
		mov	[esp+78h+var_74], eax
		call	mwSession_send
		mov	edx, [ebp+var_54]
		mov	[esp+78h+Str], edx
		mov	ebx, eax
		call	mwMessage_free
		test	ebx, ebx
		jnz	loc_10009BE3
		xor	ecx, ecx
		mov	edx, 3
		mov	eax, edi
		call	sub_100091A0
		jmp	loc_10009BE3
; ---------------------------------------------------------------------------

loc_10009E75:				; CODE XREF: sub_10009A60+12Aj
		mov	edx, [ebp+var_58]
		mov	eax, [edx+4]
		mov	[esp+78h+var_74], eax
		mov	eax, [edi+54h]
		mov	[esp+78h+Str], eax
		call	mwChannel_find
		test	eax, eax
		jz	loc_1000A218
		mov	ecx, [ebp+var_58]
		mov	[esp+78h+Str], eax
		mov	[esp+78h+var_74], ecx
		call	mwChannel_recvAccept
		jmp	loc_10009BE3
; ---------------------------------------------------------------------------

loc_10009EA6:				; CODE XREF: sub_10009A60+A0j
		mov	edx, [ebp+var_58]
		mov	eax, [edx+10h]
		mov	[esp+78h+Str], edi
		mov	[esp+78h+var_74], eax
		call	mwSession_getService
		test	eax, eax
		jz	loc_10009BE3
		mov	[esp+78h+Str], eax
		call	mwService_start
		jmp	loc_10009BE3
; ---------------------------------------------------------------------------

loc_10009ECD:				; CODE XREF: sub_10009A60+E6j
		mov	edx, [ebp+var_58]
		mov	eax, [edx+14h]
		mov	[esp+78h+var_74], eax
		mov	eax, [edi+54h]
		mov	[esp+78h+Str], eax
		call	mwChannel_newIncoming
		mov	ecx, [ebp+var_58]
		mov	[esp+78h+var_74], ecx
		mov	[esp+78h+Str], eax
		call	mwChannel_recvCreate
		jmp	loc_10009BE3
; ---------------------------------------------------------------------------

loc_10009EF6:				; CODE XREF: sub_10009A60+D4j
		mov	edx, [ebp+var_58]
		mov	eax, [edx+4]
		mov	[esp+78h+var_74], eax
		mov	eax, [edi+54h]
		mov	[esp+78h+Str], eax
		call	mwChannel_find
		test	eax, eax
		jz	loc_10009BE3
		mov	ecx, [ebp+var_58]
		mov	[esp+78h+Str], eax
		mov	[esp+78h+var_74], ecx
		call	mwChannel_recv
		jmp	loc_10009BE3
; ---------------------------------------------------------------------------

loc_10009F27:				; CODE XREF: sub_10009A60+15Aj
		mov	eax, [edi]
		test	eax, eax
		jz	loc_10009BE3
		mov	edx, [eax+1Ch]
		test	edx, edx
		jz	loc_10009BE3
		mov	ecx, [ebp+var_58]
		mov	eax, [ecx+40h]
		mov	[esp+78h+var_6C], eax
		mov	eax, [ecx+3Ch]
		mov	[esp+78h+Str], edi
		mov	[esp+78h+var_70], eax
		mov	eax, ecx
		add	eax, 14h
		mov	[esp+78h+var_74], eax
		call	edx
		jmp	loc_10009BE3
; ---------------------------------------------------------------------------

loc_10009F60:				; CODE XREF: sub_10009A60+150j
		mov	[esp+78h+Str], edi
		call	mwSession_getState
		cmp	eax, 3
		jnz	loc_1000A1F7
		lea	ebx, [edi+18h]
		mov	[esp+78h+Str], ebx
		call	mwLoginInfo_clear
		mov	eax, [ebp+var_58]
		mov	[esp+78h+Str], ebx
		add	eax, 10h
		mov	[esp+78h+var_74], eax
		call	mwLoginInfo_clone
		xor	ecx, ecx
		mov	edx, 5
		mov	eax, edi
		call	sub_100091A0
		mov	[esp+78h+Str], edi
		call	mwSession_getServices
		test	eax, eax
		mov	esi, eax
		jz	short loc_10009FC1
		mov	ebx, eax
		lea	esi, [esi+0]

loc_10009FB0:				; CODE XREF: sub_10009A60+55Fj
		mov	eax, [ebx]
		mov	[esp+78h+Str], eax
		call	mwService_start
		mov	ebx, [ebx+4]
		test	ebx, ebx
		jnz	short loc_10009FB0

loc_10009FC1:				; CODE XREF: sub_10009A60+548j
		mov	[esp+78h+Str], esi
		call	g_list_free
		xor	ecx, ecx
		mov	edx, 6
		mov	eax, edi
		call	sub_100091A0
		jmp	loc_10009BE3
; ---------------------------------------------------------------------------

loc_10009FDC:				; CODE XREF: sub_10009A60+89j
		mov	eax, [edi]
		test	eax, eax
		jz	loc_10009BE3
		mov	edx, [eax+18h]
		test	edx, edx
		jz	loc_10009BE3
		mov	ecx, [ebp+var_58]
		mov	eax, [ecx+10h]
		mov	[esp+78h+Str], edi
		mov	[esp+78h+var_74], eax
		call	edx
		jmp	loc_10009BE3
; ---------------------------------------------------------------------------

loc_1000A005:				; CODE XREF: sub_10009A60+7Dj
		lea	ebx, [edi+48h]
		mov	esi, [edi]
		mov	[esp+78h+var_70], offset aSet_privacy_li ; "SET_PRIVACY_LIST"
		mov	[esp+78h+var_74], 40h
		mov	[esp+78h+Str], offset aMeanwhile_4 ; "meanwhile"
		call	g_log
		mov	[esp+78h+Str], ebx
		call	mwPrivacyInfo_clear
		mov	eax, [ebp+var_58]
		mov	[esp+78h+Str], ebx
		add	eax, 10h
		mov	[esp+78h+var_74], eax
		call	mwPrivacyInfo_clone
		test	esi, esi
		jz	loc_10009BE3
		mov	eax, [esi+10h]
		test	eax, eax
		jz	loc_10009BE3
		mov	[esp+78h+Str], edi
		call	eax
		jmp	loc_10009BE3
; ---------------------------------------------------------------------------

loc_1000A05D:				; CODE XREF: sub_10009A60+1A0j
		mov	[esp+78h+Str], edi
		call	mwSession_getState
		cmp	eax, 0Ah
		jz	loc_10009C06
		mov	[esp+78h+var_70], offset aMwsession_is_1 ; "mwSession_isState(s, mwSession_HANDSHAK"...
		mov	[esp+78h+var_74], offset aHandshake_ack_ ; "HANDSHAKE_ACK_recv"
		mov	[esp+78h+Str], offset aMeanwhile_4 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10009BE3
; ---------------------------------------------------------------------------

loc_1000A08F:				; CODE XREF: sub_10009A60+FAj
		mov	[esp+78h+var_74], eax
		mov	eax, [edi+54h]
		mov	[esp+78h+Str], eax
		call	mwChannel_find
		test	eax, eax
		jz	loc_10009BE3
		mov	ecx, [ebp+var_58]
		mov	[esp+78h+Str], eax
		mov	[esp+78h+var_74], ecx
		call	mwChannel_recvDestroy
		jmp	loc_10009BE3
; ---------------------------------------------------------------------------

loc_1000A0BA:				; CODE XREF: sub_10009A60+24Bj
		mov	edx, [ebp+var_54]
		lea	ecx, [ebp+var_24]
		lea	ebx, [ebp+var_11]
		lea	esi, [ebp+var_34]
		mov	word ptr [edx+18h], 2
		mov	[esp+78h+Str], ecx
		call	mwIV_init
		mov	[esp+78h+Str], ebx
		mov	[esp+78h+var_74], 5
		call	mwKeyRandom
		mov	eax, [ebp+var_40]
		mov	[ebp+var_28], ebx
		mov	[ebp+var_2C], 5
		mov	[ebp+var_34], 0
		mov	[ebp+var_30], 0
		mov	[esp+78h+Str], eax ; Str
		call	strlen
		mov	edx, [ebp+var_40]
		lea	ecx, [ebp+var_24]
		mov	[esp+78h+var_70], ecx
		mov	[esp+78h+Str], ebx
		mov	[esp+78h+var_68], esi
		mov	[ebp+var_38], edx
		mov	[esp+78h+var_74], 5
		mov	[ebp+var_3C], eax
		lea	eax, [ebp+var_3C]
		mov	[esp+78h+var_6C], eax
		call	mwEncrypt
		call	mwPutBuffer_new
		mov	ebx, eax
		lea	eax, [ebp+var_2C]
		mov	[esp+78h+var_74], eax
		mov	[esp+78h+Str], ebx
		call	mwOpaque_put
		mov	[esp+78h+var_74], esi
		mov	[esp+78h+Str], ebx
		call	mwOpaque_put
		mov	eax, [ebp+var_54]
		mov	[esp+78h+var_74], ebx
		add	eax, 1Ch
		mov	[esp+78h+Str], eax
		call	mwPutBuffer_finalize
		mov	[esp+78h+Str], esi
		call	mwOpaque_clear
		jmp	loc_10009E3E
; ---------------------------------------------------------------------------

loc_1000A173:				; CODE XREF: sub_10009A60+19j
		mov	[esp+78h+var_70], offset aSNull_0 ; "s != NULL"
		mov	[esp+78h+var_74], offset aSession_proces ; "session_process"
		mov	[esp+78h+Str], offset aMeanwhile_4 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10009A8B
; ---------------------------------------------------------------------------

loc_1000A194:				; CODE XREF: sub_10009A60+1B1j
		xor	ecx, ecx
		mov	eax, edi
		mov	edx, 2
		call	sub_100091A0
		xor	ecx, ecx
		mov	edx, 3
		mov	eax, edi
		call	sub_100091A0
		jmp	loc_10009BE3
; ---------------------------------------------------------------------------

loc_1000A1B5:				; CODE XREF: sub_10009A60+21j
		mov	[esp+78h+var_70], offset aBufNull ; "buf != NULL"
		mov	[esp+78h+var_74], offset aSession_proces ; "session_process"
		mov	[esp+78h+Str], offset aMeanwhile_4 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10009A8B
; ---------------------------------------------------------------------------

loc_1000A1D6:				; CODE XREF: sub_10009A60+6Dj
		mov	[esp+78h+var_70], offset aMsgNull_2 ; "msg != NULL"
		mov	[esp+78h+var_74], offset aSession_proces ; "session_process"
		mov	[esp+78h+Str], offset aMeanwhile_4 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10009A8B
; ---------------------------------------------------------------------------

loc_1000A1F7:				; CODE XREF: sub_10009A60+50Bj
		mov	[esp+78h+var_70], offset aMwsession_is_2 ; "mwSession_isState(s, mwSession_LOGIN)"
		mov	[esp+78h+var_74], offset aLogin_ack_recv ; "LOGIN_ACK_recv"
		mov	[esp+78h+Str], offset aMeanwhile_4 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10009BE3
; ---------------------------------------------------------------------------

loc_1000A218:				; CODE XREF: sub_10009A60+42Cj
		mov	[esp+78h+var_70], offset aChanNull_2 ; "chan !=	NULL"
		mov	[esp+78h+var_74], offset aChannel_accept ; "CHANNEL_ACCEPT_recv"
		mov	[esp+78h+Str], offset aMeanwhile_4 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10009BE3
sub_10009A60	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 332. mwSession_recv

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl mwSession_recv(int, int, size_t)
		public mwSession_recv
mwSession_recv	proc near

Dst		= dword	ptr -38h
Src		= dword	ptr -34h
Size		= dword	ptr -30h
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 2Ch
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	loc_1000A48B
		mov	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_1000A29F
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_28], eax

loc_1000A261:				; CODE XREF: mwSession_recv+116j
		mov	ecx, [ebp+arg_0]
		mov	edi, [ebp+var_28]
		mov	esi, [ebp+arg_8]
		mov	edx, [ecx+10h]
		test	edx, edx
		jz	short loc_1000A2AF
		mov	ecx, [ebp+arg_0]
		mov	ebx, edx
		mov	eax, [ecx+14h]
		sub	ebx, eax
		cmp	ebx, [ebp+arg_8]
		jbe	short loc_1000A2FA
		mov	edx, [ebp+arg_8]
		add	eax, [ecx+0Ch]
		mov	[esp+38h+Src], edi ; Src
		mov	[esp+38h+Size],	edx ; Size
		mov	[esp+38h+Dst], eax ; Dst
		call	memcpy
		mov	ecx, [ebp+arg_0]
		mov	eax, [ebp+arg_8]
		add	[ecx+14h], eax

loc_1000A29F:				; CODE XREF: mwSession_recv+19j
					; mwSession_recv+6Aj ...
		add	esp, 2Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000A2A7:				; CODE XREF: mwSession_recv+72j
		sub	esi, 1
		jz	short loc_1000A29F
		add	edi, 1

loc_1000A2AF:				; CODE XREF: mwSession_recv+2Fj
		cmp	byte ptr [edi],	0
		js	short loc_1000A2A7
		cmp	esi, 3
		mov	[ebp+var_14], esi
		mov	[ebp+var_10], edi
		ja	loc_1000A35B
		mov	[esp+38h+Dst], 4
		call	g_malloc0
		mov	edx, [ebp+arg_0]
		mov	[edx+0Ch], eax
		mov	[esp+38h+Size],	esi ; Size
		mov	[esp+38h+Src], edi ; Src
		mov	[esp+38h+Dst], eax ; Dst
		call	memcpy
		mov	ecx, [ebp+arg_0]
		mov	dword ptr [ecx+10h], 4
		mov	[ecx+14h], esi
		add	esp, 2Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000A2FA:				; CODE XREF: mwSession_recv+3Ej
		mov	edx, [ebp+arg_0]
		add	eax, [edx+0Ch]
		mov	[esp+38h+Size],	ebx ; Size
		mov	[esp+38h+Src], edi ; Src
		mov	[esp+38h+Dst], eax ; Dst
		call	memcpy
		mov	edx, [ebp+arg_0]
		mov	ecx, [ebp+arg_8]
		mov	eax, [edx+10h]
		sub	ecx, ebx
		mov	[ebp+var_24], ecx
		cmp	eax, 4
		jz	short loc_1000A38E
		lea	ecx, [eax-4]
		mov	eax, [ebp+arg_0]
		mov	edx, [eax+0Ch]
		add	edx, 4
		call	sub_10009A60
		mov	eax, [ebp+arg_0]
		call	sub_10009890

loc_1000A33C:				; CODE XREF: mwSession_recv+14Cj
					; mwSession_recv+227j ...
		mov	eax, [ebp+var_24]
		test	eax, eax
		jz	loc_1000A29F
		mov	edx, [ebp+var_24]
		sub	[ebp+arg_8], edx
		mov	ecx, [ebp+arg_8]
		add	[ebp+var_28], ecx
		mov	[ebp+arg_8], edx
		jmp	loc_1000A261
; ---------------------------------------------------------------------------

loc_1000A35B:				; CODE XREF: mwSession_recv+7Dj
		lea	eax, [ebp+var_14]
		mov	[esp+38h+Dst], eax
		call	mwGetBuffer_wrap
		mov	ebx, eax
		mov	[esp+38h+Dst], eax
		call	guint32_peek
		mov	[ebp+var_20], eax
		mov	[esp+38h+Dst], ebx
		call	mwGetBuffer_free
		mov	eax, [ebp+var_20]
		test	eax, eax
		jnz	loc_1000A417
		sub	esi, 4
		mov	[ebp+var_24], esi
		jmp	short loc_1000A33C
; ---------------------------------------------------------------------------

loc_1000A38E:				; CODE XREF: mwSession_recv+E1j
		mov	eax, [edx+0Ch]
		lea	ecx, [ebp+var_14]
		add	edi, ebx
		mov	[ebp+var_14], 4
		mov	[ebp+var_10], eax
		mov	[esp+38h+Dst], ecx
		call	mwGetBuffer_wrap
		mov	ebx, eax
		mov	[esp+38h+Dst], eax
		call	guint32_peek
		mov	[esp+38h+Dst], ebx
		mov	esi, eax
		call	mwGetBuffer_free
		cmp	[ebp+var_24], esi
		jnb	loc_1000A450
		add	esi, 4
		mov	[esp+38h+Dst], esi
		call	g_malloc
		mov	edx, [ebp+arg_0]
		mov	ebx, eax
		mov	eax, [edx+0Ch]
		mov	eax, [eax]
		mov	[ebx], eax
		mov	ecx, [ebp+var_24]
		lea	eax, [ebx+4]
		mov	[esp+38h+Src], edi ; Src
		mov	[esp+38h+Dst], eax ; Dst
		mov	[esp+38h+Size],	ecx ; Size
		call	memcpy
		mov	eax, [ebp+arg_0]
		call	sub_10009890
		mov	eax, [ebp+arg_0]
		mov	edx, [ebp+arg_0]
		mov	[eax+0Ch], ebx
		mov	[eax+10h], esi
		mov	eax, [ebp+var_24]
		add	eax, 4
		mov	[edx+14h], eax
		add	esp, 2Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000A417:				; CODE XREF: mwSession_recv+140j
		mov	ebx, [ebp+var_20]
		add	ebx, 4
		cmp	ebx, esi
		jbe	short loc_1000A46C
		mov	[esp+38h+Dst], ebx
		call	g_malloc
		mov	edx, [ebp+arg_0]
		mov	[edx+0Ch], eax
		mov	[esp+38h+Size],	esi ; Size
		mov	[esp+38h+Src], edi ; Src
		mov	[esp+38h+Dst], eax ; Dst
		call	memcpy
		mov	ecx, [ebp+arg_0]
		mov	[ecx+10h], ebx
		mov	[ecx+14h], esi
		add	esp, 2Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000A450:				; CODE XREF: mwSession_recv+17Fj
		mov	eax, [ebp+arg_0]
		call	sub_10009890
		mov	eax, [ebp+arg_0]
		mov	ecx, esi
		mov	edx, edi
		call	sub_10009A60
		sub	[ebp+var_24], esi
		jmp	loc_1000A33C
; ---------------------------------------------------------------------------

loc_1000A46C:				; CODE XREF: mwSession_recv+1DFj
		mov	eax, [ebp+arg_0]
		lea	edx, [edi+4]
		sub	esi, 4
		mov	ecx, [ebp+var_20]
		call	sub_10009A60
		mov	eax, [ebp+var_20]
		mov	[ebp+var_24], esi
		sub	[ebp+var_24], eax
		jmp	loc_1000A33C
; ---------------------------------------------------------------------------

loc_1000A48B:				; CODE XREF: mwSession_recv+Ej
		mov	[esp+38h+Size],	offset aSNull_0	; "s !=	NULL"
		mov	[esp+38h+Src], offset aMwsession_recv ;	"mwSession_recv"
		mov	[esp+38h+Dst], offset aMeanwhile_4 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000A29F
mwSession_recv	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 345. mwSession_start

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_start
mwSession_start	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_C], ebx
		mov	[ebp+var_4], edi
		test	esi, esi
		jz	loc_1000A608
		mov	[esp+18h+var_18], esi
		call	mwSession_getState
		cmp	eax, 8
		jnz	loc_1000A629
		mov	[esp+18h+var_18], esi
		call	mwSession_getState
		cmp	eax, 6
		jz	short loc_1000A4F4
		mov	[esp+18h+var_18], esi
		call	mwSession_getState
		test	eax, eax
		jnz	short loc_1000A520

loc_1000A4F4:				; CODE XREF: mwSession_start+36j
					; mwSession_start+7Bj ...
		mov	[esp+18h+var_10], offset aAttemptedToSta ; "attempted to start session that is alre"...
		mov	[esp+18h+var_14], 80h
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_log

loc_1000A510:				; CODE XREF: mwSession_start+153j
					; mwSession_start+174j	...
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_1000A520:				; CODE XREF: mwSession_start+42j
		mov	[esp+18h+var_18], esi
		call	mwSession_getState
		sub	eax, 1
		jz	short loc_1000A4F4
		mov	[esp+18h+var_18], esi
		call	mwSession_getState
		cmp	eax, 2
		jz	short loc_1000A4F4
		mov	[esp+18h+var_18], esi
		call	mwSession_getState
		cmp	eax, 3
		jz	short loc_1000A4F4
		mov	[esp+18h+var_18], esi
		call	mwSession_getState
		cmp	eax, 5
		jz	short loc_1000A4F4
		mov	[esp+18h+var_18], esi
		call	mwSession_getState
		cmp	eax, 4
		nop
		jz	short loc_1000A4F4
		mov	[esp+18h+var_18], esi
		call	mwSession_getState
		cmp	eax, 0Ah
		jz	short loc_1000A4F4
		xor	ecx, ecx
		xor	edx, edx
		mov	eax, esi
		call	sub_100091A0
		mov	[esp+18h+var_18], 0
		call	mwMessage_new
		mov	edx, offset aClient_version ; "client.version.major"
		mov	edi, eax
		mov	eax, esi
		call	sub_10008E20
		mov	edx, offset aClient_versi_0 ; "client.version.minor"
		mov	[edi+10h], ax
		mov	eax, esi
		call	sub_10008E20
		mov	edx, offset aClient_id ; "client.id"
		mov	[edi+12h], ax
		mov	eax, esi
		call	sub_10008E20
		mov	edx, offset aClient_ip ; "client.ip"
		mov	[edi+18h], ax
		mov	eax, esi
		call	sub_10008E20
		cmp	word ptr [edi+10h], 1Dh
		mov	[edi+1Ch], eax
		jbe	short loc_1000A5D9
		cmp	word ptr [edi+12h], 1Ch
		ja	loc_1000A664

loc_1000A5D9:				; CODE XREF: mwSession_start+11Cj
					; mwSession_start+1C9j
		mov	[esp+18h+var_14], edi
		mov	[esp+18h+var_18], esi
		call	mwSession_send
		mov	[esp+18h+var_18], edi
		mov	ebx, eax
		call	mwMessage_free
		test	ebx, ebx
		jz	short loc_1000A64A
		mov	[esp+18h+var_14], 80000221h
		mov	[esp+18h+var_18], esi
		call	mwSession_stop
		jmp	loc_1000A510
; ---------------------------------------------------------------------------

loc_1000A608:				; CODE XREF: mwSession_start+14j
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	[esp+18h+var_14], offset aMwsession_star ; "mwSession_start"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000A510
; ---------------------------------------------------------------------------

loc_1000A629:				; CODE XREF: mwSession_start+25j
		mov	[esp+18h+var_10], offset aMwsession_is_3 ; "mwSession_isStopped(s)"
		mov	[esp+18h+var_14], offset aMwsession_star ; "mwSession_start"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000A510
; ---------------------------------------------------------------------------

loc_1000A64A:				; CODE XREF: mwSession_start+141j
		mov	ebx, [ebp+var_C]
		mov	eax, esi
		xor	ecx, ecx
		mov	esi, [ebp+var_8]
		mov	edx, 1
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	sub_100091A0
; ---------------------------------------------------------------------------

loc_1000A664:				; CODE XREF: mwSession_start+123j
		mov	word ptr [edi+20h], 100h
		mov	edx, offset aClient_host ; "client.host"
		mov	eax, esi
		call	sub_10008E20
		mov	[edi+28h], eax
		jmp	loc_1000A5D9
mwSession_start	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 317. mwSession_free

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_free
mwSession_free	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	loc_1000A740
		mov	[esp+18h+var_18], ebx
		call	mwSession_getState
		cmp	eax, 8
		jz	short loc_1000A6C7
		mov	eax, [ebx+4]
		call	sub_100087B0
		mov	[esp+18h+var_10], offset aSessionIsNotSt ; "session is not stopped (state: %s),	pro"...
		mov	[esp+18h+var_14], 80h
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		mov	[esp+18h+var_C], eax
		call	g_log

loc_1000A6C7:				; CODE XREF: mwSession_free+1Dj
		mov	eax, [ebx]
		test	eax, eax
		jz	short loc_1000A6D9
		mov	eax, [eax+8]
		test	eax, eax
		jz	short loc_1000A6D9
		mov	[esp+18h+var_18], ebx
		call	eax

loc_1000A6D9:				; CODE XREF: mwSession_free+4Bj
					; mwSession_free+52j
		mov	eax, ebx
		mov	dword ptr [ebx], 0
		call	sub_10009890
		mov	eax, [ebx+54h]
		mov	[esp+18h+var_18], eax
		call	mwChannelSet_free
		mov	eax, [ebx+58h]
		mov	[esp+18h+var_18], eax
		call	g_hash_table_destroy
		mov	eax, [ebx+5Ch]
		mov	[esp+18h+var_18], eax
		call	g_hash_table_destroy
		mov	eax, [ebx+60h]
		mov	[esp+18h+var_18], eax
		call	g_hash_table_destroy
		lea	eax, [ebx+18h]
		mov	[esp+18h+var_18], eax
		call	mwLoginInfo_clear
		lea	eax, [ebx+3Ch]
		mov	[esp+18h+var_18], eax
		call	mwUserStatus_clear
		lea	eax, [ebx+48h]
		mov	[esp+18h+var_18], eax
		call	mwPrivacyInfo_clear
		mov	[ebp+arg_0], ebx
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	g_free
; ---------------------------------------------------------------------------

loc_1000A740:				; CODE XREF: mwSession_free+Cj
		mov	[esp+18h+var_10], offset aSNull_0 ; "s != NULL"
		mov	[esp+18h+var_14], offset aMwsession_free ; "mwSession_free"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
mwSession_free	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 331. mwSession_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSession_new
mwSession_new	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	loc_1000A860
		mov	ecx, [ebx]
		test	ecx, ecx
		jz	loc_1000A880
		mov	edx, [ebx+4]
		test	edx, edx
		jz	loc_1000A8A0
		mov	[esp+18h+var_18], 6Ch
		call	g_malloc0
		mov	dword ptr [eax+4], 8
		mov	esi, eax
		mov	[eax], ebx
		mov	[esp+18h+var_18], eax
		call	mwChannelSet_new
		mov	[esi+54h], eax
		mov	[esp+18h+var_14], offset loc_1001A918
		mov	[esp+18h+var_18], offset loc_1001A910
		call	g_hash_table_new
		mov	[esi+58h], eax
		mov	[esp+18h+var_14], offset loc_1001A918
		mov	[esp+18h+var_18], offset loc_1001A910
		call	g_hash_table_new
		mov	[esi+5Ch], eax
		mov	[esp+18h+var_C], offset	mw_datum_free
		mov	[esp+18h+var_10], offset g_free
		mov	[esp+18h+var_14], offset loc_1001A988
		mov	[esp+18h+var_18], offset g_str_hash
		call	g_hash_table_new_full
		mov	ecx, 1Eh
		mov	edx, offset aClient_version ; "client.version.major"
		mov	[esi+60h], eax
		mov	eax, esi
		mov	[esp+18h+var_18], 0
		call	sub_10008ED0
		mov	ecx, 1Dh
		mov	edx, offset aClient_versi_0 ; "client.version.minor"
		mov	eax, esi
		mov	[esp+18h+var_18], 0
		call	sub_10008ED0
		mov	ecx, 1700h
		mov	edx, offset aClient_id ; "client.id"
		mov	eax, esi
		mov	[esp+18h+var_18], 0
		call	sub_10008ED0

loc_1000A857:				; CODE XREF: mwSession_new+10Ej
					; mwSession_new+12Ej ...
		add	esp, 10h
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000A860:				; CODE XREF: mwSession_new+Dj
		mov	[esp+18h+var_10], offset aHandlerNull ;	"handler != NULL"
		xor	esi, esi
		mov	[esp+18h+var_14], offset aMwsession_new	; "mwSession_new"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000A857
; ---------------------------------------------------------------------------

loc_1000A880:				; CODE XREF: mwSession_new+17j
		mov	[esp+18h+var_10], offset aHandlerIo_writ ; "handler->io_write != NULL"
		xor	esi, esi
		mov	[esp+18h+var_14], offset aMwsession_new	; "mwSession_new"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000A857
; ---------------------------------------------------------------------------

loc_1000A8A0:				; CODE XREF: mwSession_new+22j
		mov	[esp+18h+var_10], offset aHandlerIo_clos ; "handler->io_close != NULL"
		xor	esi, esi
		mov	[esp+18h+var_14], offset aMwsession_new	; "mwSession_new"
		mov	[esp+18h+var_18], offset aMeanwhile_4 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000A857
mwSession_new	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000A8C0	proc near		; DATA XREF: mwServiceAware_new+C2o
		push	ebp
		mov	eax, offset aPresenceAwaren ; "Presence	Awareness"
		mov	ebp, esp
		pop	ebp
		retn
sub_1000A8C0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000A8D0	proc near		; DATA XREF: mwServiceAware_new+C9o
		push	ebp
		mov	eax, offset aBuddyListServi ; "Buddy list service with support for ser"...
		mov	ebp, esp
		pop	ebp
		retn
sub_1000A8D0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000A8E0	proc near		; DATA XREF: mwAwareList_getWatchedAttributes+2Co

arg_0		= dword	ptr  8
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	edx, [ebp+arg_8]
		mov	ecx, [edx]
		lea	eax, [ecx+4]
		mov	[edx], eax
		mov	eax, [ebp+arg_0]
		mov	[ecx], eax
		pop	ebp
		retn
sub_1000A8E0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  28. mwAwareList_getHandler

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareList_getHandler
mwAwareList_getHandler proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000A912
		mov	eax, [eax+0Ch]
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000A912:				; CODE XREF: mwAwareList_getHandler+Bj
		mov	[esp+18h+var_10], offset aListNull ; "list != NULL"
		mov	[esp+18h+var_14], offset aMwawarelist_ge ; "mwAwareList_getHandler"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwAwareList_getHandler endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  16. mwAwareAttribute_asOpaque

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareAttribute_asOpaque
mwAwareAttribute_asOpaque proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000A952
		leave
		add	eax, 4
		retn
; ---------------------------------------------------------------------------

loc_1000A952:				; CODE XREF: mwAwareAttribute_asOpaque+Bj
		mov	[esp+18h+var_10], offset aAttribNull ; "attrib != NULL"
		mov	[esp+18h+var_14], offset aMwawareattribu ; "mwAwareAttribute_asOpaque"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwAwareAttribute_asOpaque endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  18. mwAwareAttribute_getKey

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareAttribute_getKey
mwAwareAttribute_getKey	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000A991
		mov	eax, [eax]
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000A991:				; CODE XREF: mwAwareAttribute_getKey+Bj
		mov	[esp+18h+var_10], offset aAttribNull ; "attrib != NULL"
		mov	[esp+18h+var_14], offset aMwawareattri_0 ; "mwAwareAttribute_getKey"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwAwareAttribute_getKey	endp

; ---------------------------------------------------------------------------
		jmp	short sub_1000A9C0
; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000A9C0	proc near		; CODE XREF: .text:1000A9B1j
					; mwAwareList_removeAware+65p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		test	eax, eax
		jz	short loc_1000A9E3
		mov	eax, [eax+4]
		test	eax, eax
		jz	short loc_1000AA03
		test	edx, edx
		jz	short loc_1000AA23
		mov	[esp+18h+var_14], edx
		mov	[esp+18h+var_18], eax
		call	g_hash_table_lookup
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000A9E3:				; CODE XREF: sub_1000A9C0+8j
		mov	[esp+18h+var_10], offset aListNull ; "list != NULL"
		mov	[esp+18h+var_14], offset aList_aware_fin ; "list_aware_find"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000AA03:				; CODE XREF: sub_1000A9C0+Fj
		mov	[esp+18h+var_10], offset aListEntriesNul ; "list->entries != NULL"
		mov	[esp+18h+var_14], offset aList_aware_fin ; "list_aware_find"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000AA23:				; CODE XREF: sub_1000A9C0+13j
		mov	[esp+18h+var_10], offset aSrchNull ; "srch != NULL"
		mov	[esp+18h+var_14], offset aList_aware_fin ; "list_aware_find"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
sub_1000A9C0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000AA50	proc near		; CODE XREF: mwServiceAware_getText+14p
					; mwServiceAware_getAttribute+20p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		test	eax, eax
		jz	short loc_1000AA73
		mov	eax, [eax+3Ch]
		test	eax, eax
		jz	short loc_1000AA93
		test	edx, edx
		jz	short loc_1000AAB3
		mov	[esp+18h+var_14], edx
		mov	[esp+18h+var_18], eax
		call	g_hash_table_lookup
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000AA73:				; CODE XREF: sub_1000AA50+8j
		mov	[esp+18h+var_10], offset aSrvcNull_1 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aAware_find ; "aware_find"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000AA93:				; CODE XREF: sub_1000AA50+Fj
		mov	[esp+18h+var_10], offset aSrvcEntriesNul ; "srvc->entries != NULL"
		mov	[esp+18h+var_14], offset aAware_find ; "aware_find"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000AAB3:				; CODE XREF: sub_1000AA50+13j
		mov	[esp+18h+var_10], offset aSrchNull ; "srch != NULL"
		mov	[esp+18h+var_14], offset aAware_find ; "aware_find"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
sub_1000AA50	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 260. mwServiceAware_getText

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceAware_getText
mwServiceAware_getText proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	eax, eax
		jz	short loc_1000AB06
		test	edx, edx
		jz	short loc_1000AB26
		call	sub_1000AA50
		xor	edx, edx
		test	eax, eax
		jz	short locret_1000AB02
		mov	edx, [eax+20h]

locret_1000AB02:			; CODE XREF: mwServiceAware_getText+1Dj
					; mwServiceAware_getText+44j ...
		leave
		mov	eax, edx
		retn
; ---------------------------------------------------------------------------

loc_1000AB06:				; CODE XREF: mwServiceAware_getText+Ej
		mov	[esp+18h+var_10], offset aSrvcNull_1 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwserviceaware ; "mwServiceAware_getText"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	edx, edx
		jmp	short locret_1000AB02
; ---------------------------------------------------------------------------

loc_1000AB26:				; CODE XREF: mwServiceAware_getText+12j
		mov	[esp+18h+var_10], offset aUserNull_0 ; "user !=	NULL"
		mov	[esp+18h+var_14], offset aMwserviceaware ; "mwServiceAware_getText"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	edx, edx
		jmp	short locret_1000AB02
mwServiceAware_getText endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 259. mwServiceAware_getAttribute

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceAware_getAttribute
mwServiceAware_getAttribute proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		mov	ebx, [ebp+arg_8]
		test	eax, eax
		jz	short loc_1000AB8C
		test	edx, edx
		jz	short loc_1000ABB0
		test	ebx, ebx
		jz	short loc_1000ABCE
		lea	esi, [esi+0]
		call	sub_1000AA50
		test	eax, eax
		jz	short loc_1000ABEC
		mov	[ebp+arg_4], ebx
		mov	eax, [eax+2Ch]
		mov	[ebp+arg_0], eax
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	g_hash_table_lookup
; ---------------------------------------------------------------------------

loc_1000AB8C:				; CODE XREF: mwServiceAware_getAttribute+12j
		mov	[esp+18h+var_10], offset aSrvcNull_1 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwserviceawa_0 ; "mwServiceAware_getAttribute"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning

loc_1000ABA8:				; CODE XREF: mwServiceAware_getAttribute+7Cj
					; mwServiceAware_getAttribute+9Aj ...
		add	esp, 14h
		xor	eax, eax
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000ABB0:				; CODE XREF: mwServiceAware_getAttribute+16j
		mov	[esp+18h+var_10], offset aUserNull_0 ; "user !=	NULL"
		mov	[esp+18h+var_14], offset aMwserviceawa_0 ; "mwServiceAware_getAttribute"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000ABA8
; ---------------------------------------------------------------------------

loc_1000ABCE:				; CODE XREF: mwServiceAware_getAttribute+1Aj
		mov	[esp+18h+var_10], offset aKey0x00 ; "key != 0x00"
		mov	[esp+18h+var_14], offset aMwserviceawa_0 ; "mwServiceAware_getAttribute"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000ABA8
; ---------------------------------------------------------------------------

loc_1000ABEC:				; CODE XREF: mwServiceAware_getAttribute+27j
		mov	[esp+18h+var_10], offset aAwareNull ; "aware !=	NULL"
		mov	[esp+18h+var_14], offset aMwserviceawa_0 ; "mwServiceAware_getAttribute"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000ABA8
mwServiceAware_getAttribute endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000AC10	proc near		; CODE XREF: mwServiceAware_setStatus+67p
					; sub_1000C570+229p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h

		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, edx
		push	ebx
		sub	esp, 10h
		call	sub_1000AA50
		test	eax, eax
		mov	ebx, eax
		jz	short loc_1000AC5F
		mov	[esp+18h+var_18], eax
		call	mwAwareSnapshot_clear
		mov	[esp+18h+var_18], ebx
		mov	[esp+18h+var_14], esi
		call	mwAwareSnapshot_clone
		mov	ebx, [ebx+28h]
		test	ebx, ebx
		jz	short loc_1000AC5F

loc_1000AC40:				; CODE XREF: sub_1000AC10+4Dj
		mov	edx, [ebx]
		mov	eax, [edx+0Ch]
		test	eax, eax
		jz	short loc_1000AC58
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_1000AC58
		mov	[esp+18h+var_14], esi
		mov	[esp+18h+var_18], edx
		call	eax

loc_1000AC58:				; CODE XREF: sub_1000AC10+37j
					; sub_1000AC10+3Dj
		mov	ebx, [ebx+4]
		test	ebx, ebx
		jnz	short loc_1000AC40

loc_1000AC5F:				; CODE XREF: sub_1000AC10+13j
					; sub_1000AC10+2Ej
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
sub_1000AC10	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 266. mwServiceAware_setStatus

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceAware_setStatus
mwServiceAware_setStatus proc near

var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_2C		= word ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= word ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 44h
		mov	ebx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		mov	ecx, [ebp+arg_8]
		test	ebx, ebx
		jz	short loc_1000ACE2
		test	edx, edx
		jz	short loc_1000AD00
		test	ecx, ecx
		jz	loc_1000AD1E
		movzx	eax, word ptr [edx]
		mov	[ebp+var_1C], 1
		mov	[ebp+var_2C], ax
		mov	eax, [edx+4]
		mov	[ebp+var_28], eax
		mov	eax, [edx+8]
		lea	edx, [ebp+var_2C]
		mov	[ebp+var_20], 0
		mov	[ebp+var_18], 0
		mov	[ebp+var_24], eax
		movzx	eax, word ptr [ecx]
		mov	[ebp+var_14], ax
		mov	eax, [ecx+4]
		mov	[ebp+var_10], eax
		mov	eax, [ecx+8]
		mov	[ebp+var_8], 0
		mov	[ebp+var_C], eax
		mov	eax, ebx
		call	sub_1000AC10

loc_1000ACDC:				; CODE XREF: mwServiceAware_setStatus+8Ej
					; mwServiceAware_setStatus+ACj	...
		add	esp, 44h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000ACE2:				; CODE XREF: mwServiceAware_setStatus+12j
		mov	[esp+48h+var_40], offset aSrvcNull_1 ; "srvc !=	NULL"
		mov	[esp+48h+var_44], offset aMwserviceawa_1 ; "mwServiceAware_setStatus"
		mov	[esp+48h+var_48], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000ACDC
; ---------------------------------------------------------------------------

loc_1000AD00:				; CODE XREF: mwServiceAware_setStatus+16j
		mov	[esp+48h+var_40], offset aUserNull_0 ; "user !=	NULL"
		mov	[esp+48h+var_44], offset aMwserviceawa_1 ; "mwServiceAware_setStatus"
		mov	[esp+48h+var_48], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000ACDC
; ---------------------------------------------------------------------------

loc_1000AD1E:				; CODE XREF: mwServiceAware_setStatus+1Aj
		mov	[esp+48h+var_40], offset aStatNull_1 ; "stat !=	NULL"
		mov	[esp+48h+var_44], offset aMwserviceawa_1 ; "mwServiceAware_setStatus"
		mov	[esp+48h+var_48], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000ACDC
mwServiceAware_setStatus endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  33. mwAwareList_removeClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareList_removeClientData
mwAwareList_removeClientData proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000AD59
		add	eax, 10h
		mov	[ebp+arg_0], eax
		leave
		jmp	mw_datum_clear
; ---------------------------------------------------------------------------

loc_1000AD59:				; CODE XREF: mwAwareList_removeClientData+Bj
		mov	[esp+18h+var_10], offset aListNull ; "list != NULL"
		mov	[esp+18h+var_14], offset aMwawarelist_re ; "mwAwareList_removeClientData"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwAwareList_removeClientData endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  27. mwAwareList_getClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareList_getClientData
mwAwareList_getClientData proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000AD99
		add	eax, 10h
		mov	[ebp+arg_0], eax
		leave
		jmp	mw_datum_get
; ---------------------------------------------------------------------------

loc_1000AD99:				; CODE XREF: mwAwareList_getClientData+Bj
		mov	[esp+18h+var_10], offset aListNull ; "list != NULL"
		mov	[esp+18h+var_14], offset aMwawarelist__0 ; "mwAwareList_getClientData"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwAwareList_getClientData endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  34. mwAwareList_setClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareList_setClientData
mwAwareList_setClientData proc near

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	edx, [ebp+arg_8]
		test	eax, eax
		jz	short loc_1000ADE2
		add	eax, 10h
		mov	[ebp+arg_8], edx
		mov	[ebp+arg_4], ecx
		mov	[ebp+arg_0], eax
		pop	ebp
		jmp	mw_datum_set
; ---------------------------------------------------------------------------

loc_1000ADE2:				; CODE XREF: mwAwareList_setClientData+Ej
		mov	[ebp+arg_8], offset aListNull ;	"list != NULL"
		mov	[ebp+arg_4], offset aMwawarelist_se ; "mwAwareList_setClientData"
		mov	[ebp+arg_0], offset aMeanwhile_5 ; "meanwhile"
		pop	ebp
		jmp	g_return_if_fail_warning
mwAwareList_setClientData endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 267. mwServiceAware_unsetAttribute

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceAware_unsetAttribute
mwServiceAware_unsetAttribute proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_10		= byte ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 20h
		call	mwPutBuffer_new
		mov	[esp+28h+var_24], 0
		mov	ebx, eax
		mov	[esp+28h+var_28], eax
		call	guint32_put
		mov	eax, [ebp+arg_4]
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	guint32_put
		mov	[esp+28h+var_24], ebx
		lea	ebx, [ebp+var_10]
		mov	[esp+28h+var_28], ebx
		call	mwPutBuffer_finalize
		mov	eax, [ebp+arg_0]
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_24], 0CAh
		mov	eax, [eax+48h]
		mov	[esp+28h+var_28], eax
		call	mwChannel_send
		mov	[esp+28h+var_28], ebx
		mov	esi, eax
		call	mwOpaque_clear
		add	esp, 20h
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	ebp
		retn
mwServiceAware_unsetAttribute endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000AE70	proc near		; CODE XREF: sub_1000AEB0+20p
					; sub_1000AFE0+BCp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h

		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, eax
		push	ebx
		mov	ebx, edx
		sub	esp, 10h
		mov	[esp+18h+var_18], edx
		call	g_list_length
		mov	[esp+18h+var_18], esi
		mov	[esp+18h+var_14], eax
		call	guint32_put
		test	ebx, ebx
		jz	short loc_1000AEA9

loc_1000AE94:				; CODE XREF: sub_1000AE70+37j
		mov	eax, [ebx]
		mov	[esp+18h+var_18], esi
		mov	[esp+18h+var_14], eax
		call	mwAwareIdBlock_put
		mov	ebx, [ebx+4]
		test	ebx, ebx
		jnz	short loc_1000AE94

loc_1000AEA9:				; CODE XREF: sub_1000AE70+22j
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
sub_1000AE70	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000AEB0	proc near		; CODE XREF: mwAwareList_addAware+C8p
					; sub_1000C8B0+65p

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= byte ptr -14h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_C], ebx
		mov	[ebp+var_8], esi
		mov	esi, edx
		mov	[ebp+var_4], edi
		mov	edi, eax
		call	mwPutBuffer_new
		test	edi, edi
		mov	ebx, eax
		jz	short loc_1000AF11
		mov	edx, esi
		call	sub_1000AE70
		mov	[esp+28h+var_24], ebx
		lea	ebx, [ebp+var_14]
		mov	[esp+28h+var_28], ebx
		call	mwPutBuffer_finalize
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_24], 68h
		mov	[esp+28h+var_28], edi
		call	mwChannel_send
		mov	[esp+28h+var_28], ebx
		mov	esi, eax
		call	mwOpaque_clear

loc_1000AF02:				; CODE XREF: sub_1000AEB0+7Fj
		mov	eax, esi
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000AF11:				; CODE XREF: sub_1000AEB0+1Cj
		mov	[esp+28h+var_20], offset aChanNull_3 ; "chan !=	NULL"
		xor	esi, esi
		mov	[esp+28h+var_24], offset aSend_add ; "send_add"
		mov	[esp+28h+var_28], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000AF02
sub_1000AEB0	endp

; ---------------------------------------------------------------------------
		jmp	short sub_1000AF40
; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000AF40	proc near		; CODE XREF: .text:1000AF31j
					; DATA XREF: mwAwareList_addAware+1A2o

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		lea	eax, [ebx+4]
		mov	[esp+8+var_8], eax
		call	mwOpaque_clear
		mov	[ebp+arg_0], ebx
		add	esp, 4
		pop	ebx
		pop	ebp
		jmp	g_free
sub_1000AF40	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000AF70	proc near		; CODE XREF: sub_1000BA90+59p
					; DATA XREF: mwServiceAware_new+5Do

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebx+4]
		mov	[esp+8+var_8], eax
		call	g_list_free
		mov	[ebp+arg_0], ebx
		add	esp, 4
		pop	ebx
		pop	ebp
		jmp	g_free
sub_1000AF70	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000AFA0	proc near		; CODE XREF: sub_1000AFE0+88p
					; DATA XREF: mwServiceAware_new+36o

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		mov	[esp+8+var_8], ebx
		call	mwAwareSnapshot_clear
		mov	eax, [ebx+28h]
		mov	[esp+8+var_8], eax
		call	g_list_free
		mov	eax, [ebx+2Ch]
		mov	[esp+8+var_8], eax
		call	g_hash_table_destroy
		mov	[ebp+arg_0], ebx
		add	esp, 4
		pop	ebx
		pop	ebp
		jmp	g_free
sub_1000AFA0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000AFE0	proc near		; CODE XREF: mwAwareList_removeAllAware+4Aj
					; mwAwareList_removeAware+B5j

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_18		= byte ptr -18h
var_10		= dword	ptr -10h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		mov	ebx, eax
		sub	esp, 1Ch
		mov	edx, [eax+3Ch]
		mov	[ebp+var_10], 0
		test	edx, edx
		jz	loc_1000B0D8
		mov	[esp+28h+var_20], offset aBringOutYourDe ; "bring out your dead	*clang*"
		mov	[esp+28h+var_24], 40h
		mov	[esp+28h+var_28], offset aMeanwhile_5 ;	"meanwhile"
		call	g_log
		lea	eax, [ebp+var_10]
		mov	[esp+28h+var_20], eax
		mov	[esp+28h+var_24], offset sub_1000B220
		mov	eax, [ebx+3Ch]
		mov	[esp+28h+var_28], eax
		call	g_hash_table_foreach_steal
		mov	eax, [ebp+var_10]
		test	eax, eax
		jz	loc_1000B0D8
		mov	[esp+28h+var_28], ebx
		call	mwService_getState
		cmp	eax, 3
		jz	short loc_1000B089
		mov	[esp+28h+var_28], ebx
		xor	esi, esi
		call	mwService_getState
		cmp	eax, 2
		jz	short loc_1000B089

loc_1000B05A:				; CODE XREF: sub_1000AFE0+F6j
					; sub_1000AFE0+122j
		mov	eax, [ebp+var_10]
		test	eax, eax
		mov	ebx, eax
		jz	short loc_1000B077

loc_1000B063:				; CODE XREF: sub_1000AFE0+92j
		mov	eax, [ebx]
		mov	[esp+28h+var_28], eax
		call	sub_1000AFA0
		mov	ebx, [ebx+4]
		test	ebx, ebx
		jnz	short loc_1000B063
		mov	eax, [ebp+var_10]

loc_1000B077:				; CODE XREF: sub_1000AFE0+81j
		mov	[esp+28h+var_28], eax
		call	g_list_free
		add	esp, 1Ch
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000B089:				; CODE XREF: sub_1000AFE0+69j
					; sub_1000AFE0+78j
		mov	edi, [ebx+48h]
		mov	esi, [ebp+var_10]
		call	mwPutBuffer_new
		test	edi, edi
		mov	ebx, eax
		jz	short loc_1000B0E4
		mov	edx, esi
		call	sub_1000AE70
		mov	[esp+28h+var_24], ebx
		lea	ebx, [ebp+var_18]
		mov	[esp+28h+var_28], ebx
		call	mwPutBuffer_finalize
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_24], 69h
		mov	[esp+28h+var_28], edi
		call	mwChannel_send
		mov	[esp+28h+var_28], ebx
		mov	esi, eax
		call	mwOpaque_clear
		test	esi, esi
		setnz	al
		movzx	esi, al
		jmp	short loc_1000B05A
; ---------------------------------------------------------------------------

loc_1000B0D8:				; CODE XREF: sub_1000AFE0+17j
					; sub_1000AFE0+58j
		xor	esi, esi
		add	esp, 1Ch
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000B0E4:				; CODE XREF: sub_1000AFE0+B8j
		mov	[esp+28h+var_20], offset aChanNull_3 ; "chan !=	NULL"
		xor	esi, esi
		mov	[esp+28h+var_24], offset aSend_rem ; "send_rem"
		mov	[esp+28h+var_28], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000B05A
sub_1000AFE0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  31. mwAwareList_removeAllAware

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareList_removeAllAware
mwAwareList_removeAllAware proc	near	; CODE XREF: mwAwareList_free+57p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_4], esi
		test	ebx, ebx
		jz	short loc_1000B15F
		mov	esi, [ebx]
		test	esi, esi
		jz	short loc_1000B18A
		mov	eax, [ebx+4]
		test	eax, eax
		jz	short loc_1000B14F
		mov	[esp+18h+var_18], eax
		mov	[esp+18h+var_10], ebx
		mov	[esp+18h+var_14], offset sub_1000B2A0
		call	g_hash_table_foreach
		mov	eax, [ebx+4]
		mov	[esp+18h+var_18], eax
		call	g_hash_table_destroy

loc_1000B14F:				; CODE XREF: mwAwareList_removeAllAware+1Ej
		mov	ebx, [ebp+var_8]
		mov	eax, esi
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	sub_1000AFE0
; ---------------------------------------------------------------------------

loc_1000B15F:				; CODE XREF: mwAwareList_removeAllAware+11j
		mov	[esp+18h+var_10], offset aListNull ; "list != NULL"
		mov	[esp+18h+var_14], offset aMwawarelist__1 ; "mwAwareList_removeAllAware"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning

loc_1000B17B:				; CODE XREF: mwAwareList_removeAllAware+96j
		mov	ebx, [ebp+var_8]
		mov	eax, 0FFFFFFFFh
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000B18A:				; CODE XREF: mwAwareList_removeAllAware+17j
		mov	[esp+18h+var_10], offset aSrvcNull_1 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwawarelist__1 ; "mwAwareList_removeAllAware"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000B17B
mwAwareList_removeAllAware endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000B1B0	proc near		; DATA XREF: sub_1000BA90+3Ao

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		xor	eax, eax
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_4]
		mov	ecx, [ebx+4]
		test	ecx, ecx
		jz	short loc_1000B1D0
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_1000B1D0:				; CODE XREF: sub_1000B1B0+11j
		mov	eax, [ebp+arg_0]
		mov	[esp+18h+var_10], offset aRemoving0x08x	; " removing 0x%08x"
		mov	[esp+18h+var_14], 40h
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		mov	[esp+18h+var_C], eax
		call	g_log
		mov	[esp+18h+var_14], ebx
		mov	edx, [ebp+arg_8]
		mov	eax, [edx]
		mov	[esp+18h+var_18], eax
		call	g_list_append
		mov	edx, [ebp+arg_8]
		mov	[edx], eax
		add	esp, 14h
		mov	eax, 1
		pop	ebx
		pop	ebp
		retn
sub_1000B1B0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000B220	proc near		; DATA XREF: sub_1000AFE0+40o

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		xor	eax, eax
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_4]
		mov	edx, [ebx+28h]
		test	edx, edx
		jz	short loc_1000B240
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_1000B240:				; CODE XREF: sub_1000B220+11j
		mov	edx, [ebx+8]
		mov	ecx, offset aNull_2 ; "(null)"
		mov	eax, [ebx+4]
		mov	[esp+18h+var_10], offset aRemovingSS ; " removing %s, %s"
		mov	[esp+18h+var_14], 40h
		test	edx, edx
		cmovz	edx, ecx
		test	eax, eax
		cmovz	eax, ecx
		mov	[esp+18h+var_8], edx
		mov	[esp+18h+var_C], eax
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_log
		mov	[esp+18h+var_14], ebx
		mov	edx, [ebp+arg_8]
		mov	eax, [edx]
		mov	[esp+18h+var_18], eax
		call	g_list_append
		mov	edx, [ebp+arg_8]
		mov	[edx], eax
		add	esp, 14h
		mov	eax, 1
		pop	ebx
		pop	ebp
		retn
sub_1000B220	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000B2A0	proc near		; DATA XREF: mwAwareList_removeAllAware+27o

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_4]
		mov	eax, [ebp+arg_8]
		mov	[esp+18h+var_14], eax
		mov	eax, [ebx+28h]
		mov	[esp+18h+var_18], eax
		call	g_list_remove
		mov	[ebx+28h], eax
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
sub_1000B2A0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000B2D0	proc near		; DATA XREF: mwAwareList_unwatchAllAttributes+23o

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_4]
		mov	eax, [ebp+arg_8]
		mov	[esp+18h+var_14], eax
		mov	eax, [ebx+4]
		mov	[esp+18h+var_18], eax
		call	g_list_remove
		mov	[ebx+4], eax
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
sub_1000B2D0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  32. mwAwareList_removeAware

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareList_removeAware
mwAwareList_removeAware	proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	eax, [ebp+arg_0]
		mov	edi, [ebp+arg_4]
		test	eax, eax
		mov	[ebp+var_14], eax
		jz	loc_1000B3BA
		mov	edx, [ebp+var_14]
		mov	edx, [edx]
		test	edx, edx
		mov	[ebp+var_10], edx
		jnz	short loc_1000B35A
		jmp	loc_1000B3E3
; ---------------------------------------------------------------------------
		align 10h

loc_1000B330:				; CODE XREF: mwAwareList_removeAware+6Ej
		mov	eax, [ebp+var_14]
		mov	[esp+28h+var_24], eax
		mov	eax, [ebx+28h]
		mov	[esp+28h+var_28], eax
		call	g_list_remove
		mov	[ebx+28h], eax
		mov	[esp+28h+var_24], esi
		mov	edx, [ebp+var_14]
		mov	eax, [edx+4]
		mov	[esp+28h+var_28], eax
		call	g_hash_table_remove

loc_1000B357:				; CODE XREF: mwAwareList_removeAware+A9j
		mov	edi, [edi+4]

loc_1000B35A:				; CODE XREF: mwAwareList_removeAware+24j
		test	edi, edi
		jz	short loc_1000B3AB
		mov	esi, [edi]
		mov	eax, [ebp+var_14]
		mov	edx, esi
		call	sub_1000A9C0
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_1000B330
		mov	eax, [esi+8]
		mov	ecx, offset aNull_2 ; "(null)"
		mov	edx, [esi+4]
		mov	[esp+28h+var_20], offset aBuddySSNotInLi ; "buddy %s, %s not in	list"
		mov	[esp+28h+var_24], 10h
		test	eax, eax
		cmovz	eax, ecx
		test	edx, edx
		cmovz	edx, ecx
		mov	[esp+28h+var_18], eax
		mov	[esp+28h+var_1C], edx
		mov	[esp+28h+var_28], offset aMeanwhile_5 ;	"meanwhile"
		call	g_log
		jmp	short loc_1000B357
; ---------------------------------------------------------------------------

loc_1000B3AB:				; CODE XREF: mwAwareList_removeAware+5Cj
		mov	eax, [ebp+var_10]
		add	esp, 1Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		jmp	sub_1000AFE0
; ---------------------------------------------------------------------------

loc_1000B3BA:				; CODE XREF: mwAwareList_removeAware+14j
		mov	[esp+28h+var_20], offset aListNull ; "list != NULL"
		mov	[esp+28h+var_24], offset aMwawarelist__2 ; "mwAwareList_removeAware"
		mov	[esp+28h+var_28], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning

loc_1000B3D6:				; CODE XREF: mwAwareList_removeAware+FFj
		add	esp, 1Ch
		mov	eax, 0FFFFFFFFh
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000B3E3:				; CODE XREF: mwAwareList_removeAware+26j
		mov	[esp+28h+var_20], offset aSrvcNull_1 ; "srvc !=	NULL"
		mov	[esp+28h+var_24], offset aMwawarelist__2 ; "mwAwareList_removeAware"
		mov	[esp+28h+var_28], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000B3D6
mwAwareList_removeAware	endp

; ---------------------------------------------------------------------------
		jmp	short mwAwareList_new
; ---------------------------------------------------------------------------
		align 10h
; Exported entry  30. mwAwareList_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareList_new
mwAwareList_new	proc near		; CODE XREF: .text:1000B401j

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_C], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_4]
		mov	[ebp+var_8], esi
		test	ebx, ebx
		jz	short loc_1000B461
		test	edi, edi
		jz	short loc_1000B481
		mov	[esp+18h+var_18], 18h
		call	g_malloc0
		mov	[eax], ebx
		mov	esi, eax
		mov	[eax+0Ch], edi
		mov	[esp+18h+var_14], eax
		mov	eax, [ebx+44h]
		mov	[esp+18h+var_18], eax
		call	g_list_prepend
		mov	[ebx+44h], eax

loc_1000B452:				; CODE XREF: mwAwareList_new+6Fj
					; mwAwareList_new+8Fj
		mov	eax, esi
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000B461:				; CODE XREF: mwAwareList_new+17j
		mov	[esp+18h+var_10], offset aSrvcNull_1 ; "srvc !=	NULL"
		xor	esi, esi
		mov	[esp+18h+var_14], offset aMwawarelist_ne ; "mwAwareList_new"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000B452
; ---------------------------------------------------------------------------

loc_1000B481:				; CODE XREF: mwAwareList_new+1Bj
		mov	[esp+18h+var_10], offset aHandlerNull_0	; "handler != NULL"
		xor	esi, esi
		mov	[esp+18h+var_14], offset aMwawarelist_ne ; "mwAwareList_new"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000B452
mwAwareList_new	endp

; ---------------------------------------------------------------------------
		jmp	short sub_1000B4B0
; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000B4B0	proc near		; CODE XREF: .text:1000B4A1j
					; mwAwareList_watchAttributeArray+33p ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_C], ebx
		mov	ebx, eax
		mov	[ebp+var_8], esi
		mov	esi, edx
		mov	[ebp+var_4], edi
		mov	ecx, [eax+8]
		test	ecx, ecx
		jz	short loc_1000B531

loc_1000B4CA:				; CODE XREF: sub_1000B4B0+98j
		mov	eax, [ebx+8]
		mov	[esp+28h+var_24], esi
		mov	[esp+28h+var_28], eax
		call	g_hash_table_lookup
		test	eax, eax
		jz	short loc_1000B4F0

loc_1000B4DD:				; CODE XREF: sub_1000B4B0+7Fj
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_1000B4F0:				; CODE XREF: sub_1000B4B0+2Bj
		mov	eax, [ebx]
		mov	[esp+28h+var_24], esi
		mov	[ebp+var_10], eax
		mov	eax, [eax+40h]
		mov	[esp+28h+var_28], eax
		call	g_hash_table_lookup
		test	eax, eax
		mov	edi, eax
		jz	short loc_1000B54A

loc_1000B50A:				; CODE XREF: sub_1000B4B0+C0j
		mov	eax, [ebx+8]
		mov	[esp+28h+var_20], edi
		mov	[esp+28h+var_24], esi
		mov	[esp+28h+var_28], eax
		call	g_hash_table_insert
		mov	[esp+28h+var_24], ebx
		mov	eax, [edi+4]
		mov	[esp+28h+var_28], eax
		call	g_list_prepend
		mov	[edi+4], eax
		jmp	short loc_1000B4DD
; ---------------------------------------------------------------------------

loc_1000B531:				; CODE XREF: sub_1000B4B0+18j
		mov	[esp+28h+var_24], offset loc_1001A918
		mov	[esp+28h+var_28], offset loc_1001A910
		call	g_hash_table_new
		mov	[ebx+8], eax
		jmp	short loc_1000B4CA
; ---------------------------------------------------------------------------

loc_1000B54A:				; CODE XREF: sub_1000B4B0+58j
		mov	[esp+28h+var_28], 8
		call	g_malloc0
		mov	edx, [ebp+var_10]
		mov	[eax], esi
		mov	edi, eax
		mov	[esp+28h+var_20], eax
		mov	[esp+28h+var_24], esi
		mov	eax, [edx+40h]
		mov	[esp+28h+var_28], eax
		call	g_hash_table_insert
		jmp	short loc_1000B50A
sub_1000B4B0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  25. mwAwareList_addAware

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareList_addAware
mwAwareList_addAware proc near		; CODE XREF: sub_1000B7C0+4Dp

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	eax, [ebp+arg_0]
		mov	esi, [ebp+arg_4]
		test	eax, eax
		jz	loc_1000B772
		mov	eax, [ebp+arg_0]
		mov	eax, [eax]
		test	eax, eax
		mov	[ebp+var_18], eax
		jz	loc_1000B798
		test	esi, esi
		mov	[ebp+var_10], eax
		mov	[ebp+var_14], 0
		jnz	short loc_1000B5C8
		jmp	loc_1000B6C8
; ---------------------------------------------------------------------------
		align 10h

loc_1000B5C0:				; CODE XREF: mwAwareList_addAware+7Fj
		mov	edx, [ebp+arg_0]
		mov	edx, [edx]
		mov	[ebp+var_10], edx

loc_1000B5C8:				; CODE XREF: mwAwareList_addAware+33j
		mov	ebx, [esi]
		mov	eax, [ebx+4]
		test	eax, eax
		jz	loc_1000B6D4
		cmp	byte ptr [eax],	0
		jz	loc_1000B6F5
		mov	edx, [ebp+arg_0]
		mov	edi, [edx+4]
		test	edi, edi
		jz	loc_1000B6A9

loc_1000B5EC:				; CODE XREF: mwAwareList_addAware+143j
		mov	eax, [ebp+arg_0]
		mov	edx, ebx
		call	sub_1000A9C0
		test	eax, eax
		jz	short loc_1000B651

loc_1000B5FA:				; CODE XREF: mwAwareList_addAware+124j
					; mwAwareList_addAware+170j ...
		mov	esi, [esi+4]
		test	esi, esi
		jnz	short loc_1000B5C0

loc_1000B601:				; CODE XREF: mwAwareList_addAware+14Fj
		mov	eax, [ebp+var_18]
		mov	[esp+28h+var_28], eax
		call	mwService_getState
		cmp	eax, 3
		jz	short loc_1000B638
		mov	edx, [ebp+var_18]
		mov	[esp+28h+var_28], edx
		call	mwService_getState
		cmp	eax, 2
		jz	short loc_1000B638

loc_1000B621:				; CODE XREF: mwAwareList_addAware+BDj
		xor	ebx, ebx

loc_1000B623:				; CODE XREF: mwAwareList_addAware+CFj
		mov	eax, [ebp+var_14]
		mov	[esp+28h+var_28], eax
		call	g_list_free

loc_1000B62E:				; CODE XREF: mwAwareList_addAware+213j
					; mwAwareList_addAware+239j
		add	esp, 1Ch
		mov	eax, ebx
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000B638:				; CODE XREF: mwAwareList_addAware+8Fj
					; mwAwareList_addAware+9Fj
		mov	ebx, [ebp+var_14]
		test	ebx, ebx
		jz	short loc_1000B621
		mov	edx, [ebp+var_18]
		mov	eax, [edx+48h]
		mov	edx, [ebp+var_14]
		call	sub_1000AEB0
		mov	ebx, eax
		jmp	short loc_1000B623
; ---------------------------------------------------------------------------

loc_1000B651:				; CODE XREF: mwAwareList_addAware+78j
		mov	eax, [ebp+var_10]
		mov	edx, ebx
		call	sub_1000AA50
		test	eax, eax
		mov	edi, eax
		jz	loc_1000B716

loc_1000B665:				; CODE XREF: mwAwareList_addAware+1EDj
		mov	eax, [ebp+arg_0]
		mov	[esp+28h+var_24], eax
		mov	eax, [edi+28h]
		mov	[esp+28h+var_28], eax
		call	g_list_append
		mov	edx, [ebp+arg_0]
		mov	[edi+28h], eax
		mov	[esp+28h+var_20], edi
		mov	[esp+28h+var_24], edi
		mov	eax, [edx+4]
		mov	[esp+28h+var_28], eax
		call	g_hash_table_insert
		mov	eax, [esi]
		mov	[esp+28h+var_24], eax
		mov	eax, [ebp+var_14]
		mov	[esp+28h+var_28], eax
		call	g_list_prepend
		mov	[ebp+var_14], eax
		jmp	loc_1000B5FA
; ---------------------------------------------------------------------------

loc_1000B6A9:				; CODE XREF: mwAwareList_addAware+66j
		mov	[esp+28h+var_24], offset mwAwareIdBlock_equal
		mov	[esp+28h+var_28], offset mwAwareIdBlock_hash
		call	g_hash_table_new
		mov	edx, [ebp+arg_0]
		mov	[edx+4], eax
		jmp	loc_1000B5EC
; ---------------------------------------------------------------------------

loc_1000B6C8:				; CODE XREF: mwAwareList_addAware+35j
		mov	[ebp+var_14], 0
		jmp	loc_1000B601
; ---------------------------------------------------------------------------

loc_1000B6D4:				; CODE XREF: mwAwareList_addAware+4Fj
		mov	[esp+28h+var_20], offset aIdUserNull ; "id->user != NULL"
		mov	[esp+28h+var_24], offset aList_add ; "list_add"
		mov	[esp+28h+var_28], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000B5FA
; ---------------------------------------------------------------------------

loc_1000B6F5:				; CODE XREF: mwAwareList_addAware+58j
		mov	[esp+28h+var_20], offset aStrlenIdUser0	; "strlen(id->user) > 0"
		mov	[esp+28h+var_24], offset aList_add ; "list_add"
		mov	[esp+28h+var_28], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000B5FA
; ---------------------------------------------------------------------------

loc_1000B716:				; CODE XREF: mwAwareList_addAware+DFj
		mov	[esp+28h+var_28], 30h
		call	g_malloc0
		mov	[esp+28h+var_1C], offset sub_1000AF40
		mov	[esp+28h+var_20], 0
		mov	[esp+28h+var_24], offset loc_1001A918
		mov	[esp+28h+var_28], offset loc_1001A910
		mov	edi, eax
		call	g_hash_table_new_full
		mov	[edi+2Ch], eax
		mov	[esp+28h+var_24], ebx
		mov	[esp+28h+var_28], edi
		call	mwAwareIdBlock_clone
		mov	edx, [ebp+var_10]
		mov	[esp+28h+var_20], edi
		mov	[esp+28h+var_24], edi
		mov	eax, [edx+3Ch]
		mov	[esp+28h+var_28], eax
		call	g_hash_table_insert
		jmp	loc_1000B665
; ---------------------------------------------------------------------------

loc_1000B772:				; CODE XREF: mwAwareList_addAware+11j
		mov	[esp+28h+var_20], offset aListNull ; "list != NULL"
		mov	ebx, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwawarelist_ad ; "mwAwareList_addAware"
		mov	[esp+28h+var_28], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000B62E
; ---------------------------------------------------------------------------

loc_1000B798:				; CODE XREF: mwAwareList_addAware+21j
		mov	[esp+28h+var_20], offset aSrvcNull_1 ; "srvc !=	NULL"
		mov	ebx, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwawarelist_ad ; "mwAwareList_addAware"
		mov	[esp+28h+var_28], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000B62E
mwAwareList_addAware endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000B7C0	proc near		; CODE XREF: sub_1000C570+21Fp
					; sub_1000C570+277p

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= word ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, edx
		push	ebx
		sub	esp, 20h
		mov	edx, [edx+0Ch]
		mov	[ebp+var_14], 3
		mov	[ebp+var_C], 0
		mov	[ebp+var_10], edx
		lea	edx, [ebp+var_14]
		call	sub_1000AA50
		test	eax, eax
		mov	ebx, eax
		jz	short loc_1000B828
		mov	[esp+28h+var_24], esi
		mov	[esp+28h+var_28], 0
		call	g_list_prepend
		mov	ebx, [ebx+28h]
		test	ebx, ebx
		mov	esi, eax
		jz	short loc_1000B819

loc_1000B804:				; CODE XREF: sub_1000B7C0+57j
		mov	[esp+28h+var_24], esi
		mov	eax, [ebx]
		mov	[esp+28h+var_28], eax
		call	mwAwareList_addAware
		mov	ebx, [ebx+4]
		test	ebx, ebx
		jnz	short loc_1000B804

loc_1000B819:				; CODE XREF: sub_1000B7C0+42j
		mov	[esp+28h+var_28], esi
		call	g_list_free

loc_1000B821:				; CODE XREF: sub_1000B7C0+84j
		add	esp, 20h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000B828:				; CODE XREF: sub_1000B7C0+29j
		mov	[esp+28h+var_20], offset aGrpNull ; "grp != NULL"
		mov	[esp+28h+var_24], offset aGroup_member_r ; "group_member_recv"
		mov	[esp+28h+var_28], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000B821
sub_1000B7C0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  29. mwAwareList_getWatchedAttributes

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareList_getWatchedAttributes
mwAwareList_getWatchedAttributes proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_1000B8A2
		mov	eax, [ebx+8]
		test	eax, eax
		jz	short loc_1000B8C2
		mov	[esp+28h+var_28], eax
		call	g_hash_table_size
		lea	eax, ds:4[eax*4]
		mov	[esp+28h+var_28], eax
		call	g_malloc0
		mov	[esp+28h+var_24], offset sub_1000A8E0
		mov	[ebp+var_8], eax
		lea	eax, [ebp+var_8]
		mov	[esp+28h+var_20], eax
		mov	eax, [ebx+8]
		mov	[esp+28h+var_28], eax
		call	g_hash_table_foreach
		mov	eax, [ebp+var_8]

loc_1000B89C:				; CODE XREF: mwAwareList_getWatchedAttributes+70j
					; mwAwareList_getWatchedAttributes+90j
		add	esp, 24h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000B8A2:				; CODE XREF: mwAwareList_getWatchedAttributes+Cj
		mov	[esp+28h+var_20], offset aListNull ; "list != NULL"
		mov	[esp+28h+var_24], offset aMwawarelist__3 ; "mwAwareList_getWatchedAttributes"
		mov	[esp+28h+var_28], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		jmp	short loc_1000B89C
; ---------------------------------------------------------------------------

loc_1000B8C2:				; CODE XREF: mwAwareList_getWatchedAttributes+13j
		mov	[esp+28h+var_20], offset aListAttribsNul ; "list->attribs != NULL"
		mov	[esp+28h+var_24], offset aMwawarelist__3 ; "mwAwareList_getWatchedAttributes"
		mov	[esp+28h+var_28], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		jmp	short loc_1000B89C
mwAwareList_getWatchedAttributes endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000B8F0	proc near		; CODE XREF: mwAwareList_watchAttributeArray+2Aj
					; sub_1000BA90+9Ap ...

var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_20		= dword	ptr -20h
var_14		= byte ptr -14h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 2Ch
		test	eax, eax
		mov	[ebp+var_20], eax
		jz	loc_1000B9B0
		mov	eax, [ebp+var_20]
		mov	eax, [eax+48h]
		test	eax, eax
		jz	loc_1000B9D3
		mov	edx, [ebp+var_20]
		mov	eax, [edx+40h]
		mov	[esp+38h+var_38], eax
		call	map_collect_keys
		mov	esi, eax
		mov	[esp+38h+var_38], eax
		call	g_list_length
		mov	ebx, eax
		call	mwPutBuffer_new
		mov	[esp+38h+var_34], 0
		mov	edi, eax
		mov	[esp+38h+var_38], eax
		call	guint32_put
		mov	[esp+38h+var_34], ebx
		mov	[esp+38h+var_38], edi
		call	guint32_put
		test	esi, esi
		jz	short loc_1000B973

loc_1000B953:				; CODE XREF: sub_1000B8F0+81j
		mov	eax, [esi]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint32_put
		mov	[esp+38h+var_34], esi
		mov	[esp+38h+var_38], esi
		call	g_list_delete_link
		test	eax, eax
		mov	esi, eax
		jnz	short loc_1000B953

loc_1000B973:				; CODE XREF: sub_1000B8F0+61j
		lea	ebx, [ebp+var_14]
		mov	[esp+38h+var_34], edi
		mov	[esp+38h+var_38], ebx
		call	mwPutBuffer_finalize
		mov	edx, [ebp+var_20]
		mov	[esp+38h+var_30], ebx
		mov	[esp+38h+var_34], 0CBh
		mov	eax, [edx+48h]
		mov	[esp+38h+var_38], eax
		call	mwChannel_send
		mov	[esp+38h+var_38], ebx
		mov	esi, eax
		call	mwOpaque_clear

loc_1000B9A6:				; CODE XREF: sub_1000B8F0+E1j
					; sub_1000B8F0+101j
		add	esp, 2Ch
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000B9B0:				; CODE XREF: sub_1000B8F0+Ej
		mov	[esp+38h+var_30], offset aSrvcNull_1 ; "srvc !=	NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+38h+var_34], offset aSend_attrib_li ; "send_attrib_list"
		mov	[esp+38h+var_38], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000B9A6
; ---------------------------------------------------------------------------

loc_1000B9D3:				; CODE XREF: sub_1000B8F0+1Cj
		mov	[esp+38h+var_30], offset aSrvcChannelNul ; "srvc->channel != NULL"
		xor	esi, esi
		mov	[esp+38h+var_34], offset aSend_attrib_li ; "send_attrib_list"
		mov	[esp+38h+var_38], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000B9A6
sub_1000B8F0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  38. mwAwareList_watchAttributeArray

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareList_watchAttributeArray
mwAwareList_watchAttributeArray	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	esi, esi
		jz	short loc_1000BA43
		mov	eax, [esi]
		test	eax, eax
		jz	short loc_1000BA6D
		xor	ecx, ecx
		test	edx, edx
		jz	short loc_1000BA64
		mov	ebx, [edx]
		test	ebx, ebx
		jnz	short loc_1000BA2F
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	sub_1000B8F0
; ---------------------------------------------------------------------------

loc_1000BA2F:				; CODE XREF: mwAwareList_watchAttributeArray+22j
					; mwAwareList_watchAttributeArray+41j
		mov	edx, ebx
		mov	eax, esi
		call	sub_1000B4B0
		mov	edx, ebx
		mov	eax, esi
		call	sub_1000B4B0
		jmp	short loc_1000BA2F
; ---------------------------------------------------------------------------

loc_1000BA43:				; CODE XREF: mwAwareList_watchAttributeArray+10j
		mov	[esp+18h+var_10], offset aListNull ; "list != NULL"
		mov	[esp+18h+var_14], offset aMwawarelist_wa ; "mwAwareList_watchAttributeArray"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	ecx, 0FFFFFFFFh

loc_1000BA64:				; CODE XREF: mwAwareList_watchAttributeArray+1Cj
					; mwAwareList_watchAttributeArray+8Ej
		add	esp, 10h
		mov	eax, ecx
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000BA6D:				; CODE XREF: mwAwareList_watchAttributeArray+16j
		mov	[esp+18h+var_10], offset aListServiceNul ; "list->service != NULL"
		mov	[esp+18h+var_14], offset aMwawarelist_wa ; "mwAwareList_watchAttributeArray"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	ecx, 0FFFFFFFFh
		jmp	short loc_1000BA64
mwAwareList_watchAttributeArray	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000BA90	proc near		; CODE XREF: mwAwareList_unwatchAllAttributes+46j
					; mwAwareList_unwatchAttributeArray+2Aj ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		push	ebx
		mov	ebx, eax
		sub	esp, 24h
		mov	eax, [eax+40h]
		mov	[ebp+var_8], 0
		test	eax, eax
		jz	short loc_1000BB04
		mov	[esp+28h+var_20], offset aCollectingDead ; "collecting dead attributes"
		mov	[esp+28h+var_24], 40h
		mov	[esp+28h+var_28], offset aMeanwhile_5 ;	"meanwhile"
		call	g_log
		lea	eax, [ebp+var_8]
		mov	[esp+28h+var_20], eax
		mov	[esp+28h+var_24], offset sub_1000B1B0
		mov	eax, [ebx+40h]
		mov	[esp+28h+var_28], eax
		call	g_hash_table_foreach_steal
		mov	eax, [ebp+var_8]
		test	eax, eax
		jz	short loc_1000BB04

loc_1000BAE4:				; CODE XREF: sub_1000BA90+72j
		mov	eax, [eax]
		mov	[esp+28h+var_28], eax
		call	sub_1000AF70
		mov	eax, [ebp+var_8]
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_28], eax
		call	g_list_delete_link
		test	eax, eax
		mov	[ebp+var_8], eax
		jnz	short loc_1000BAE4

loc_1000BB04:				; CODE XREF: sub_1000BA90+15j
					; sub_1000BA90+52j
		mov	[esp+28h+var_28], ebx
		call	mwService_getState
		cmp	eax, 3
		jz	short loc_1000BB28
		mov	[esp+28h+var_28], ebx
		call	mwService_getState
		xor	edx, edx
		cmp	eax, 2
		jz	short loc_1000BB28
		add	esp, 24h
		mov	eax, edx
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000BB28:				; CODE XREF: sub_1000BA90+7Fj
					; sub_1000BA90+8Ej
		mov	eax, ebx
		call	sub_1000B8F0
		add	esp, 24h
		pop	ebx
		pop	ebp
		mov	edx, eax
		mov	eax, edx
		retn
sub_1000BA90	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  35. mwAwareList_unwatchAllAttributes

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareList_unwatchAllAttributes
mwAwareList_unwatchAllAttributes proc near ; CODE XREF:	mwAwareList_free+4Fp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_4], esi
		test	ebx, ebx
		jz	short loc_1000BB8B
		mov	eax, [ebx+8]
		mov	esi, [ebx]
		test	eax, eax
		jz	short loc_1000BB7B
		mov	[esp+18h+var_18], eax
		mov	[esp+18h+var_10], ebx
		mov	[esp+18h+var_14], offset sub_1000B2D0
		call	g_hash_table_foreach
		mov	eax, [ebx+8]
		mov	[esp+18h+var_18], eax
		call	g_hash_table_destroy

loc_1000BB7B:				; CODE XREF: mwAwareList_unwatchAllAttributes+1Aj
		mov	ebx, [ebp+var_8]
		mov	eax, esi
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	sub_1000BA90
; ---------------------------------------------------------------------------

loc_1000BB8B:				; CODE XREF: mwAwareList_unwatchAllAttributes+11j
		mov	[esp+18h+var_10], offset aListNull ; "list != NULL"
		mov	[esp+18h+var_14], offset aMwawarelist_un ; "mwAwareList_unwatchAllAttributes"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	ebx, [ebp+var_8]
		mov	eax, 0FFFFFFFFh
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
mwAwareList_unwatchAllAttributes endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  36. mwAwareList_unwatchAttributeArray

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareList_unwatchAttributeArray
mwAwareList_unwatchAttributeArray proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	esi, esi
		jz	short loc_1000BC03
		mov	eax, [esi]
		test	eax, eax
		jz	short loc_1000BC2D
		xor	ecx, ecx
		test	edx, edx
		jz	short loc_1000BC24
		mov	ebx, [edx]
		test	ebx, ebx
		jnz	short loc_1000BBEF
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	sub_1000BA90
; ---------------------------------------------------------------------------

loc_1000BBEF:				; CODE XREF: mwAwareList_unwatchAttributeArray+22j
					; mwAwareList_unwatchAttributeArray+41j
		mov	edx, ebx
		mov	eax, esi
		call	sub_1000B4B0
		mov	edx, ebx
		mov	eax, esi
		call	sub_1000B4B0
		jmp	short loc_1000BBEF
; ---------------------------------------------------------------------------

loc_1000BC03:				; CODE XREF: mwAwareList_unwatchAttributeArray+10j
		mov	[esp+18h+var_10], offset aListNull ; "list != NULL"
		mov	[esp+18h+var_14], offset aMwawarelist__4 ; "mwAwareList_unwatchAttributeArray"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	ecx, 0FFFFFFFFh

loc_1000BC24:				; CODE XREF: mwAwareList_unwatchAttributeArray+1Cj
					; mwAwareList_unwatchAttributeArray+8Ej
		add	esp, 10h
		mov	eax, ecx
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000BC2D:				; CODE XREF: mwAwareList_unwatchAttributeArray+16j
		mov	[esp+18h+var_10], offset aListServiceNul ; "list->service != NULL"
		mov	[esp+18h+var_14], offset aMwawarelist__4 ; "mwAwareList_unwatchAttributeArray"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	ecx, 0FFFFFFFFh
		jmp	short loc_1000BC24
mwAwareList_unwatchAttributeArray endp

; Exported entry  37. mwAwareList_unwatchAttributes

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareList_unwatchAttributes
mwAwareList_unwatchAttributes proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	edi, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	edi, edi
		jz	loc_1000BD09
		mov	eax, [edi]
		test	eax, eax
		jz	loc_1000BD2C
		lea	eax, [ebp+arg_8]
		test	edx, edx
		mov	[ebp+var_10], eax
		jz	short loc_1000BCC9
		mov	ebx, edx
		lea	esi, [esi+0]

loc_1000BC80:				; CODE XREF: mwAwareList_unwatchAttributes+77j
					; mwAwareList_unwatchAttributes+B1j
		mov	eax, [edi+8]
		test	eax, eax
		jz	short loc_1000BCD8
		mov	[esp+28h+var_24], ebx
		mov	[esp+28h+var_28], eax
		call	g_hash_table_lookup
		test	eax, eax
		mov	esi, eax
		jz	short loc_1000BCD8
		mov	[esp+28h+var_24], ebx
		mov	eax, [edi+8]
		mov	[esp+28h+var_28], eax
		call	g_hash_table_remove
		mov	[esp+28h+var_24], edi
		mov	eax, [esi+4]
		mov	[esp+28h+var_28], eax
		call	g_list_remove
		mov	edx, [ebp+var_10]
		mov	ebx, [edx]
		mov	[esi+4], eax
		lea	eax, [edx+4]
		mov	[ebp+var_10], eax
		test	ebx, ebx
		jnz	short loc_1000BC80

loc_1000BCC9:				; CODE XREF: mwAwareList_unwatchAttributes+29j
					; mwAwareList_unwatchAttributes+B7j
		mov	eax, [edi]
		call	sub_1000BA90

loc_1000BCD0:				; CODE XREF: mwAwareList_unwatchAttributes+DAj
					; mwAwareList_unwatchAttributes+FDj
		add	esp, 1Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000BCD8:				; CODE XREF: mwAwareList_unwatchAttributes+35j
					; mwAwareList_unwatchAttributes+47j
		mov	[esp+28h+var_20], offset aWatchNull ; "watch !=	NULL"
		mov	[esp+28h+var_24], offset aWatch_remove ; "watch_remove"
		mov	[esp+28h+var_28], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	edx, [ebp+var_10]
		mov	ebx, [edx]
		lea	eax, [edx+4]
		mov	[ebp+var_10], eax
		test	ebx, ebx
		jnz	loc_1000BC80
		jmp	short loc_1000BCC9
; ---------------------------------------------------------------------------

loc_1000BD09:				; CODE XREF: mwAwareList_unwatchAttributes+11j
		mov	[esp+28h+var_20], offset aListNull ; "list != NULL"
		mov	[esp+28h+var_24], offset aMwawarelist__5 ; "mwAwareList_unwatchAttributes"
		mov	[esp+28h+var_28], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFFFFFh
		jmp	short loc_1000BCD0
; ---------------------------------------------------------------------------

loc_1000BD2C:				; CODE XREF: mwAwareList_unwatchAttributes+1Bj
		mov	[esp+28h+var_20], offset aListServiceNul ; "list->service != NULL"
		mov	[esp+28h+var_24], offset aMwawarelist__5 ; "mwAwareList_unwatchAttributes"
		mov	[esp+28h+var_28], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFFFFFh
		jmp	short loc_1000BCD0
mwAwareList_unwatchAttributes endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  39. mwAwareList_watchAttributes

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareList_watchAttributes
mwAwareList_watchAttributes proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	ebx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_1000BD94
		mov	eax, [ebx]
		test	eax, eax
		jz	short loc_1000BDB7
		lea	eax, [ebp+arg_8]
		test	edx, edx
		mov	[ebp+var_8], eax
		jz	short loc_1000BD87

loc_1000BD71:				; CODE XREF: mwAwareList_watchAttributes+35j
		mov	eax, ebx
		call	sub_1000B4B0
		mov	edx, [ebp+var_8]
		lea	eax, [edx+4]
		mov	edx, [edx]
		mov	[ebp+var_8], eax
		test	edx, edx
		jnz	short loc_1000BD71

loc_1000BD87:				; CODE XREF: mwAwareList_watchAttributes+1Fj
		mov	eax, [ebx]
		call	sub_1000B8F0

loc_1000BD8E:				; CODE XREF: mwAwareList_watchAttributes+65j
					; mwAwareList_watchAttributes+88j
		add	esp, 24h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000BD94:				; CODE XREF: mwAwareList_watchAttributes+Fj
		mov	[esp+28h+var_20], offset aListNull ; "list != NULL"
		mov	[esp+28h+var_24], offset aMwawarelist__6 ; "mwAwareList_watchAttributes"
		mov	[esp+28h+var_28], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFFFFFh
		jmp	short loc_1000BD8E
; ---------------------------------------------------------------------------

loc_1000BDB7:				; CODE XREF: mwAwareList_watchAttributes+15j
		mov	[esp+28h+var_20], offset aListServiceNul ; "list->service != NULL"
		mov	[esp+28h+var_24], offset aMwawarelist__6 ; "mwAwareList_watchAttributes"
		mov	[esp+28h+var_28], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFFFFFh
		jmp	short loc_1000BD8E
mwAwareList_watchAttributes endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  26. mwAwareList_free

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareList_free
mwAwareList_free proc near		; CODE XREF: sub_1000BEA0+15p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_1000BE50
		mov	esi, [ebx]
		test	esi, esi
		jz	short loc_1000BE73
		mov	[esp+18h+var_14], ebx
		mov	eax, [esi+44h]
		mov	[esp+18h+var_18], eax
		call	g_list_remove_all
		mov	[esi+44h], eax
		mov	eax, [ebx+0Ch]
		test	eax, eax
		jz	short loc_1000BE21
		mov	eax, [eax+8]
		test	eax, eax
		jz	short loc_1000BE21
		mov	[esp+18h+var_18], ebx
		call	eax
		mov	dword ptr [ebx+0Ch], 0

loc_1000BE21:				; CODE XREF: mwAwareList_free+2Cj
					; mwAwareList_free+33j
		lea	eax, [ebx+10h]
		mov	[esp+18h+var_18], eax
		call	mw_datum_clear
		mov	[esp+18h+var_18], ebx
		call	mwAwareList_unwatchAllAttributes
		mov	[esp+18h+var_18], ebx
		call	mwAwareList_removeAllAware
		mov	dword ptr [ebx], 0
		mov	[ebp+arg_0], ebx
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	g_free
; ---------------------------------------------------------------------------

loc_1000BE50:				; CODE XREF: mwAwareList_free+Dj
		mov	[esp+18h+var_10], offset aListNull ; "list != NULL"
		mov	[esp+18h+var_14], offset aMwawarelist_fr ; "mwAwareList_free"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning

loc_1000BE6C:				; CODE XREF: mwAwareList_free+AFj
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000BE73:				; CODE XREF: mwAwareList_free+13j
		mov	[esp+18h+var_10], offset aListServiceNul ; "list->service != NULL"
		mov	[esp+18h+var_14], offset aMwawarelist_fr ; "mwAwareList_free"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000BE6C
mwAwareList_free endp

; ---------------------------------------------------------------------------
		jmp	short sub_1000BEA0
; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000BEA0	proc near		; CODE XREF: .text:1000BE91j
					; DATA XREF: mwServiceAware_new+BBo

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jnz	short loc_1000BEBA
		jmp	short loc_1000BEEB
; ---------------------------------------------------------------------------

loc_1000BEB0:				; CODE XREF: sub_1000BEA0+1Fj
		mov	eax, [eax]
		mov	[esp+18h+var_18], eax
		call	mwAwareList_free

loc_1000BEBA:				; CODE XREF: sub_1000BEA0+Cj
		mov	eax, [ebx+44h]
		test	eax, eax
		jnz	short loc_1000BEB0
		mov	eax, [ebx+3Ch]
		mov	[esp+18h+var_18], eax
		call	g_hash_table_destroy
		mov	eax, [ebx+40h]
		mov	dword ptr [ebx+3Ch], 0
		mov	[esp+18h+var_18], eax
		call	g_hash_table_destroy
		mov	dword ptr [ebx+40h], 0

loc_1000BEE5:				; CODE XREF: sub_1000BEA0+67j
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000BEEB:				; CODE XREF: sub_1000BEA0+Ej
		mov	[esp+18h+var_10], offset aSrvcNull_1 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aClear	; "clear"
		mov	[esp+18h+var_18], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000BEE5
sub_1000BEA0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  17. mwAwareAttribute_asString

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareAttribute_asString
mwAwareAttribute_asString proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		xor	eax, eax
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	edx, [ebp+arg_0]
		test	edx, edx
		jz	short loc_1000BF4E
		lea	eax, [edx+4]
		mov	[ebp+var_8], 0
		mov	[esp+28h+var_28], eax
		call	mwGetBuffer_wrap
		mov	ebx, eax
		lea	eax, [ebp+var_8]
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_28], ebx
		call	mwString_get
		mov	[esp+28h+var_28], ebx
		call	mwGetBuffer_free
		mov	eax, [ebp+var_8]

loc_1000BF4E:				; CODE XREF: mwAwareAttribute_asString+Ej
		add	esp, 24h
		pop	ebx
		pop	ebp
		retn
mwAwareAttribute_asString endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  15. mwAwareAttribute_asInteger

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareAttribute_asInteger
mwAwareAttribute_asInteger proc	near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_A		= word ptr -0Ah
arg_0		= dword	ptr  8

		push	ebp
		xor	eax, eax
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 20h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_1000BFA8
		lea	eax, [ebx+4]
		mov	[ebp+var_10], 0
		mov	[esp+28h+var_28], eax
		call	mwGetBuffer_wrap
		mov	esi, eax
		mov	eax, [ebx+4]
		cmp	eax, 3
		ja	short loc_1000BFB0
		jz	short loc_1000BFC1
		cmp	eax, 2
		jz	short loc_1000C013
		test	eax, eax
		jnz	short loc_1000BFF5

loc_1000BF98:				; CODE XREF: mwAwareAttribute_asInteger+5Fj
					; mwAwareAttribute_asInteger+93j ...
		mov	[esp+28h+var_28], esi
		nop
		lea	esi, [esi+0]
		call	mwGetBuffer_free
		mov	eax, [ebp+var_10]

loc_1000BFA8:				; CODE XREF: mwAwareAttribute_asInteger+Fj
		add	esp, 20h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_1000BFB0:				; CODE XREF: mwAwareAttribute_asInteger+2Bj
		lea	eax, [ebp+var_10]
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_28], esi
		call	guint32_get
		jmp	short loc_1000BF98
; ---------------------------------------------------------------------------

loc_1000BFC1:				; CODE XREF: mwAwareAttribute_asInteger+2Dj
		lea	eax, [ebp+var_14]
		mov	[ebp+var_14], 0
		mov	[ebp+var_A], 0
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_28], esi
		call	gboolean_get

loc_1000BFDD:				; CODE XREF: mwAwareAttribute_asInteger+B9j
		lea	eax, [ebp+var_A]
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_28], esi
		call	guint16_get
		movzx	eax, [ebp+var_A]
		mov	[ebp+var_10], eax
		jmp	short loc_1000BF98
; ---------------------------------------------------------------------------

loc_1000BFF5:				; CODE XREF: mwAwareAttribute_asInteger+36j
		lea	eax, [ebp+var_14]
		mov	[esp+28h+var_24], eax
		mov	[ebp+var_14], 0
		mov	[esp+28h+var_28], esi
		call	gboolean_get
		mov	eax, [ebp+var_14]
		mov	[ebp+var_10], eax
		jmp	short loc_1000BF98
; ---------------------------------------------------------------------------

loc_1000C013:				; CODE XREF: mwAwareAttribute_asInteger+32j
		mov	[ebp+var_A], 0
		jmp	short loc_1000BFDD
mwAwareAttribute_asInteger endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  14. mwAwareAttribute_asBoolean

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAwareAttribute_asBoolean
mwAwareAttribute_asBoolean proc	near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_A		= word ptr -0Ah
arg_0		= dword	ptr  8

		push	ebp
		xor	eax, eax
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 20h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_1000C078
		lea	eax, [ebx+4]
		mov	[esp+28h+var_28], eax
		call	mwGetBuffer_wrap
		mov	esi, eax
		mov	eax, [ebx+4]
		cmp	eax, 3
		ja	short loc_1000C095
		cmp	eax, 1
		jbe	short loc_1000C080
		lea	eax, [ebp+var_A]
		mov	[esp+28h+var_24], eax
		mov	[ebp+var_A], 0
		mov	[esp+28h+var_28], esi
		call	guint16_get
		xor	eax, eax
		cmp	[ebp+var_A], 0
		setnz	al
		mov	[ebp+var_10], eax

loc_1000C06D:				; CODE XREF: mwAwareAttribute_asBoolean+62j
					; mwAwareAttribute_asBoolean+73j ...
		mov	[esp+28h+var_28], esi
		call	mwGetBuffer_free
		mov	eax, [ebp+var_10]

loc_1000C078:				; CODE XREF: mwAwareAttribute_asBoolean+Fj
		add	esp, 20h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_1000C080:				; CODE XREF: mwAwareAttribute_asBoolean+29j
		test	eax, eax
		jz	short loc_1000C06D
		lea	eax, [ebp+var_10]
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_28], esi
		call	gboolean_get
		jmp	short loc_1000C06D
; ---------------------------------------------------------------------------

loc_1000C095:				; CODE XREF: mwAwareAttribute_asBoolean+24j
		lea	eax, [ebp+var_14]
		mov	[esp+28h+var_24], eax
		mov	[ebp+var_14], 0
		mov	[esp+28h+var_28], esi
		call	guint32_get
		xor	eax, eax
		cmp	[ebp+var_14], 0
		setnz	al
		mov	[ebp+var_10], eax
		jmp	short loc_1000C06D
mwAwareAttribute_asBoolean endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 262. mwServiceAware_setAttribute

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceAware_setAttribute
mwServiceAware_setAttribute proc near	; CODE XREF: mwServiceAware_setAttributeString+3Ep
					; mwServiceAware_setAttributeInteger+3Ep ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_10		= byte ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 20h
		mov	esi, [ebp+arg_8]
		call	mwPutBuffer_new
		mov	[esp+28h+var_24], 0
		mov	ebx, eax
		mov	[esp+28h+var_28], eax
		call	guint32_put
		mov	eax, [esi]
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	guint32_put
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], 0
		call	guint32_put
		mov	eax, [ebp+arg_4]
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	guint32_put
		mov	[esp+28h+var_24], esi
		mov	[esp+28h+var_28], ebx
		call	mwOpaque_put
		mov	[esp+28h+var_24], ebx
		lea	ebx, [ebp+var_10]
		mov	[esp+28h+var_28], ebx
		call	mwPutBuffer_finalize
		mov	eax, [ebp+arg_0]
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_24], 0C9h
		mov	eax, [eax+48h]
		mov	[esp+28h+var_28], eax
		call	mwChannel_send
		mov	[esp+28h+var_28], ebx
		mov	esi, eax
		call	mwOpaque_clear
		add	esp, 20h
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	ebp
		retn
mwServiceAware_setAttribute endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 265. mwServiceAware_setAttributeString

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl mwServiceAware_setAttributeString(int, int, char *)
		public mwServiceAware_setAttributeString
mwServiceAware_setAttributeString proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_10		= byte ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 20h
		call	mwPutBuffer_new
		mov	ebx, eax
		mov	eax, [ebp+arg_8]
		mov	[esp+28h+var_28], ebx ;	int
		mov	[esp+28h+var_24], eax ;	char *
		call	mwString_put
		mov	[esp+28h+var_24], ebx
		lea	ebx, [ebp+var_10]
		mov	[esp+28h+var_28], ebx
		call	mwPutBuffer_finalize
		mov	eax, [ebp+arg_4]
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_24], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+28h+var_28], eax
		call	mwServiceAware_setAttribute
		mov	[esp+28h+var_28], ebx
		mov	esi, eax
		call	mwOpaque_clear
		add	esp, 20h
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	ebp
		retn
mwServiceAware_setAttributeString endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 264. mwServiceAware_setAttributeInteger

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceAware_setAttributeInteger
mwServiceAware_setAttributeInteger proc	near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_10		= byte ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 20h
		call	mwPutBuffer_new
		mov	ebx, eax
		mov	eax, [ebp+arg_8]
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	guint32_put
		mov	[esp+28h+var_24], ebx
		lea	ebx, [ebp+var_10]
		mov	[esp+28h+var_28], ebx
		call	mwPutBuffer_finalize
		mov	eax, [ebp+arg_4]
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_24], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+28h+var_28], eax
		call	mwServiceAware_setAttribute
		mov	[esp+28h+var_28], ebx
		mov	esi, eax
		call	mwOpaque_clear
		add	esp, 20h
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	ebp
		retn
mwServiceAware_setAttributeInteger endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 263. mwServiceAware_setAttributeBoolean

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceAware_setAttributeBoolean
mwServiceAware_setAttributeBoolean proc	near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_10		= byte ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 20h
		call	mwPutBuffer_new
		mov	[esp+28h+var_24], 0
		mov	ebx, eax
		mov	[esp+28h+var_28], eax
		call	gboolean_put
		mov	eax, [ebp+arg_8]
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	gboolean_put
		mov	[esp+28h+var_24], ebx
		lea	ebx, [ebp+var_10]
		mov	[esp+28h+var_28], ebx
		call	mwPutBuffer_finalize
		mov	eax, [ebp+arg_4]
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_24], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+28h+var_28], eax
		call	mwServiceAware_setAttribute
		mov	[esp+28h+var_28], ebx
		mov	esi, eax
		call	mwOpaque_clear
		add	esp, 20h
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	ebp
		retn
mwServiceAware_setAttributeBoolean endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 261. mwServiceAware_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceAware_new
mwServiceAware_new proc	near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_0]
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		test	edi, edi
		jz	loc_1000C36F
		test	esi, esi
		jz	loc_1000C38F
		mov	[esp+28h+var_28], 4Ch
		call	g_malloc0
		mov	[eax+38h], esi
		mov	ebx, eax
		mov	[esp+28h+var_1C], offset sub_1000AFA0
		mov	[esp+28h+var_20], 0
		mov	[esp+28h+var_24], offset mwAwareIdBlock_equal
		mov	[esp+28h+var_28], offset mwAwareIdBlock_hash
		call	g_hash_table_new_full
		mov	[ebx+3Ch], eax
		mov	[esp+28h+var_1C], offset sub_1000AF70
		mov	[esp+28h+var_20], 0
		mov	[esp+28h+var_24], offset loc_1001A918
		mov	[esp+28h+var_28], offset loc_1001A910
		call	g_hash_table_new_full
		mov	[ebx+40h], eax
		mov	[esp+28h+var_20], 11h
		mov	[esp+28h+var_24], edi
		mov	[esp+28h+var_28], ebx
		call	mwService_init
		mov	dword ptr [ebx+18h], offset sub_1000C8B0
		mov	dword ptr [ebx+1Ch], offset sub_1000C890
		mov	dword ptr [ebx+20h], offset sub_1000C570
		mov	dword ptr [ebx+24h], offset sub_1000C3F0
		mov	dword ptr [ebx+28h], offset sub_1000C3B0
		mov	dword ptr [ebx+2Ch], offset sub_1000BEA0
		mov	dword ptr [ebx+0Ch], offset sub_1000A8C0
		mov	dword ptr [ebx+10h], offset sub_1000A8D0

loc_1000C360:				; CODE XREF: mwServiceAware_new+FDj
					; mwServiceAware_new+11Dj
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000C36F:				; CODE XREF: mwServiceAware_new+17j
		mov	[esp+28h+var_20], offset aSessionNull_1	; "session != NULL"
		xor	ebx, ebx
		mov	[esp+28h+var_24], offset aMwserviceawa_2 ; "mwServiceAware_new"
		mov	[esp+28h+var_28], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000C360
; ---------------------------------------------------------------------------

loc_1000C38F:				; CODE XREF: mwServiceAware_new+1Fj
		mov	[esp+28h+var_20], offset aHandlerNull_0	; "handler != NULL"
		xor	ebx, ebx
		mov	[esp+28h+var_24], offset aMwserviceawa_2 ; "mwServiceAware_new"
		mov	[esp+28h+var_28], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000C360
mwServiceAware_new endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000C3B0	proc near		; DATA XREF: mwServiceAware_new+B4o

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebx+48h]
		test	eax, eax
		jz	short loc_1000C3E0
		mov	[esp+18h+var_10], 0
		mov	[esp+18h+var_14], 0
		mov	[esp+18h+var_18], eax
		call	mwChannel_destroy
		mov	dword ptr [ebx+48h], 0

loc_1000C3E0:				; CODE XREF: sub_1000C3B0+Fj
		mov	[ebp+arg_0], ebx
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	mwService_stopped
sub_1000C3B0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000C3F0	proc near		; DATA XREF: mwServiceAware_new+ADo

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_0]
		mov	eax, [esi+8]
		mov	[esp+18h+var_18], eax
		call	mwSession_getChannels
		mov	[esp+18h+var_18], eax
		call	mwChannel_newOutgoing
		mov	[esp+18h+var_14], esi
		mov	ebx, eax
		mov	[esp+18h+var_18], eax
		call	mwChannel_setService
		mov	[esp+18h+var_14], 11h
		mov	[esp+18h+var_18], ebx
		call	mwChannel_setProtoType
		mov	[esp+18h+var_14], 30005h
		mov	[esp+18h+var_18], ebx
		call	mwChannel_setProtoVer
		mov	[esp+18h+var_18], ebx
		call	mwChannel_create
		test	eax, eax
		jnz	short loc_1000C456
		test	ebx, ebx
		jz	short loc_1000C456
		mov	[esi+48h], ebx
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000C456:				; CODE XREF: sub_1000C3F0+56j
					; sub_1000C3F0+5Aj
		mov	[ebp+arg_0], esi
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	mwService_stopped
sub_1000C3F0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000C470	proc near		; CODE XREF: sub_1000C570+B1p
					; sub_1000C570+1BBp

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h

		push	ebp
		mov	ebp, esp
		push	edi
		mov	edi, ecx
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	[ebp+var_18], edx
		call	sub_1000AA50
		test	eax, eax
		mov	esi, eax
		jz	loc_1000C550
		mov	eax, [edi]
		mov	[ebp+var_10], eax
		mov	eax, [esi+2Ch]
		test	eax, eax
		jz	loc_1000C524
		mov	edx, [ebp+var_10]
		mov	[esp+28h+var_28], eax
		mov	[esp+28h+var_24], edx
		call	g_hash_table_lookup
		test	eax, eax
		mov	[ebp+var_14], eax
		jz	short loc_1000C524

loc_1000C4B3:				; CODE XREF: sub_1000C470+DBj
		mov	ebx, [ebp+var_14]
		add	ebx, 4
		mov	[esp+28h+var_28], ebx
		call	mwOpaque_clear
		lea	eax, [edi+4]
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_28], ebx
		call	mwOpaque_clone
		mov	edi, [esi+28h]
		test	edi, edi
		jz	short loc_1000C51C

loc_1000C4D7:				; CODE XREF: sub_1000C470+AAj
		mov	esi, [edi]
		mov	ebx, [esi+0Ch]
		test	ebx, ebx
		jz	short loc_1000C515
		mov	eax, [ebx+4]
		test	eax, eax
		jz	short loc_1000C515
		mov	eax, [esi+8]
		test	eax, eax
		jz	short loc_1000C515
		mov	edx, [ebp+var_10]
		mov	[esp+28h+var_28], eax
		mov	[esp+28h+var_24], edx
		call	g_hash_table_lookup
		test	eax, eax
		jz	short loc_1000C515
		mov	eax, [ebp+var_14]
		mov	edx, [ebp+var_18]
		mov	[esp+28h+var_28], esi
		mov	[esp+28h+var_20], eax
		mov	[esp+28h+var_24], edx
		call	dword ptr [ebx+4]

loc_1000C515:				; CODE XREF: sub_1000C470+6Ej
					; sub_1000C470+75j ...
		mov	edi, [edi+4]
		test	edi, edi
		jnz	short loc_1000C4D7

loc_1000C51C:				; CODE XREF: sub_1000C470+65j
					; sub_1000C470+FCj
		add	esp, 1Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000C524:				; CODE XREF: sub_1000C470+27j
					; sub_1000C470+41j
		mov	[esp+28h+var_28], 0Ch
		call	g_malloc0
		mov	edx, [ebp+var_10]
		mov	[ebp+var_14], eax
		mov	[eax], edx
		mov	[esp+28h+var_20], eax
		mov	[esp+28h+var_24], edx
		mov	eax, [esi+2Ch]
		mov	[esp+28h+var_28], eax
		call	g_hash_table_insert
		jmp	loc_1000C4B3
; ---------------------------------------------------------------------------

loc_1000C550:				; CODE XREF: sub_1000C470+17j
		mov	[esp+28h+var_20], offset aAwareNull ; "aware !=	NULL"
		mov	[esp+28h+var_24], offset aAttrib_recv ;	"attrib_recv"
		mov	[esp+28h+var_28], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000C51C
sub_1000C470	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000C570	proc near		; DATA XREF: mwServiceAware_new+A6o

var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= word ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= word ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 2Ch
		mov	edx, [ebp+arg_0]
		movzx	esi, [ebp+arg_8]
		mov	eax, [edx+48h]
		cmp	eax, [ebp+arg_4]
		jnz	loc_1000C82B
		mov	edx, [ebp+arg_0]
		mov	ebx, [edx+8]
		mov	[esp+38h+var_38], eax
		call	mwChannel_getSession
		cmp	ebx, eax
		jnz	loc_1000C84C
		mov	edi, [ebp+arg_C]
		test	edi, edi
		jz	loc_1000C86D
		mov	eax, [ebp+arg_C]
		mov	[esp+38h+var_38], eax
		call	mwGetBuffer_wrap
		cmp	si, 259h
		mov	edi, eax
		jz	loc_1000C6B7
		jbe	short loc_1000C640
		cmp	si, 25Bh
		lea	esi, [esi+0]
		jz	short loc_1000C630
		jnb	loc_1000C679
		lea	eax, [ebp+var_14]
		lea	esi, [ebp+var_2C]
		lea	ebx, [ebp+var_20]
		mov	[esp+38h+var_34], eax
		mov	[ebp+var_20], 0
		mov	[ebp+var_1C], 0
		mov	[ebp+var_18], 0
		mov	[esp+38h+var_38], edi
		call	guint32_get
		mov	[esp+38h+var_34], esi
		mov	[esp+38h+var_38], edi
		call	mwAwareIdBlock_get
		mov	[esp+38h+var_34], ebx
		mov	[esp+38h+var_38], edi
		call	guint32_get
		mov	eax, [ebp+arg_0]
		mov	ecx, ebx
		mov	edx, esi
		call	sub_1000C470
		mov	[esp+38h+var_38], esi
		call	mwAwareIdBlock_clear
		xchg	ax, ax

loc_1000C630:				; CODE XREF: sub_1000C570+60j
					; sub_1000C570+107j ...
		mov	[esp+38h+var_38], edi
		call	mwGetBuffer_free

loc_1000C638:				; CODE XREF: sub_1000C570+2D7j
					; sub_1000C570+2F8j ...
		add	esp, 2Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000C640:				; CODE XREF: sub_1000C570+55j
		cmp	si, 1F5h
		jz	loc_1000C7C1
		cmp	si, 1F6h
		jz	short loc_1000C687
		cmp	si, 1F4h
		jz	loc_1000C748

loc_1000C65D:				; CODE XREF: sub_1000C570+113j
		mov	edx, [ebp+arg_C]
		movzx	eax, si
		mov	[esp+38h+var_30], eax
		mov	[esp+38h+var_34], offset aUnknownMessa_2 ; "unknown message in aware service: 0x%04"...
		mov	[esp+38h+var_38], edx
		call	mw_mailme_opaque
		jmp	short loc_1000C630
; ---------------------------------------------------------------------------

loc_1000C679:				; CODE XREF: sub_1000C570+62j
		lea	eax, [esi-25Dh]
		cmp	ax, 2
		ja	short loc_1000C65D
		jmp	short loc_1000C630
; ---------------------------------------------------------------------------

loc_1000C687:				; CODE XREF: sub_1000C570+E0j
		lea	ebx, [ebp+var_2C]
		mov	[ebp+var_2C], 0
		mov	[ebp+var_28], 0
		mov	[ebp+var_24], 0
		mov	[esp+38h+var_34], ebx
		mov	[esp+38h+var_38], eax
		call	mwAwareIdBlock_get
		mov	[esp+38h+var_38], ebx
		call	mwAwareIdBlock_clear
		jmp	loc_1000C630
; ---------------------------------------------------------------------------

loc_1000C6B7:				; CODE XREF: sub_1000C570+4Fj
		lea	ebx, [ebp+var_10]
		lea	esi, [ebp+var_2C]
		mov	[esp+38h+var_38], eax
		mov	[esp+38h+var_34], ebx
		call	guint32_get
		mov	[esp+38h+var_34], esi
		mov	[esp+38h+var_38], edi
		call	mwAwareIdBlock_get
		mov	[esp+38h+var_34], ebx
		mov	[esp+38h+var_38], edi
		call	guint32_get
		lea	eax, [ebp+var_14]
		mov	[esp+38h+var_34], eax
		mov	[esp+38h+var_38], edi
		call	guint32_get
		mov	[esp+38h+var_34], ebx
		lea	ebx, [ebp+var_20]
		mov	[esp+38h+var_38], edi
		call	guint32_get
		mov	[esp+38h+var_34], ebx
		mov	[esp+38h+var_38], edi
		call	guint32_get
		mov	edx, [ebp+var_14]
		test	edx, edx
		jnz	loc_1000C817
		mov	[ebp+var_1C], 0
		mov	[ebp+var_18], 0

loc_1000C724:				; CODE XREF: sub_1000C570+2B6j
		mov	eax, [ebp+arg_0]
		mov	ecx, ebx
		mov	edx, esi
		call	sub_1000C470
		mov	[esp+38h+var_38], esi
		call	mwAwareIdBlock_clear
		lea	eax, [ebp+var_1C]
		mov	[esp+38h+var_38], eax
		call	mwOpaque_clear
		jmp	loc_1000C630
; ---------------------------------------------------------------------------

loc_1000C748:				; CODE XREF: sub_1000C570+E7j
		mov	[esp+38h+var_38], 28h
		call	g_malloc0
		mov	[esp+38h+var_38], edi
		mov	ebx, eax
		lea	eax, [ebp+var_10]
		mov	[esp+38h+var_34], eax
		call	guint32_get
		jmp	short loc_1000C7A6
; ---------------------------------------------------------------------------

loc_1000C767:				; CODE XREF: sub_1000C570+242j
		mov	[esp+38h+var_34], ebx
		mov	[esp+38h+var_38], edi
		call	mwAwareSnapshot_get
		mov	[esp+38h+var_38], edi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_1000C802
		mov	esi, [ebx+0Ch]
		test	esi, esi
		jz	short loc_1000C794
		mov	eax, [ebp+arg_0]
		mov	edx, ebx
		call	sub_1000B7C0

loc_1000C794:				; CODE XREF: sub_1000C570+218j
		mov	eax, [ebp+arg_0]
		mov	edx, ebx
		call	sub_1000AC10
		mov	[esp+38h+var_38], ebx
		call	mwAwareSnapshot_clear

loc_1000C7A6:				; CODE XREF: sub_1000C570+1F5j
		mov	eax, [ebp+var_10]
		sub	eax, 1
		mov	[ebp+var_10], eax
		add	eax, 1
		jnz	short loc_1000C767
		mov	[esp+38h+var_38], ebx
		call	g_free
		jmp	loc_1000C630
; ---------------------------------------------------------------------------

loc_1000C7C1:				; CODE XREF: sub_1000C570+D5j
		mov	[esp+38h+var_38], 28h
		call	g_malloc0
		mov	[esp+38h+var_38], edi
		mov	ebx, eax
		mov	[esp+38h+var_34], eax
		call	mwAwareSnapshot_get
		mov	ecx, [ebx+0Ch]
		test	ecx, ecx
		jz	short loc_1000C7EC
		mov	eax, [ebp+arg_0]
		mov	edx, ebx
		call	sub_1000B7C0

loc_1000C7EC:				; CODE XREF: sub_1000C570+270j
		mov	[esp+38h+var_38], edi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	short loc_1000C802
		mov	eax, [ebp+arg_0]
		mov	edx, ebx
		call	sub_1000AC10

loc_1000C802:				; CODE XREF: sub_1000C570+20Dj
					; sub_1000C570+286j
		mov	[esp+38h+var_38], ebx
		call	mwAwareSnapshot_clear
		mov	[esp+38h+var_38], ebx
		call	g_free
		jmp	loc_1000C630
; ---------------------------------------------------------------------------

loc_1000C817:				; CODE XREF: sub_1000C570+1A0j
		lea	edx, [ebp+var_1C]
		mov	[esp+38h+var_34], edx
		mov	[esp+38h+var_38], edi
		call	mwOpaque_get
		jmp	loc_1000C724
; ---------------------------------------------------------------------------

loc_1000C82B:				; CODE XREF: sub_1000C570+16j
		mov	[esp+38h+var_30], offset aSrvc_awareChan ; "srvc_aware->channel	== chan"
		mov	[esp+38h+var_34], offset aRecv ; "recv"
		mov	[esp+38h+var_38], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000C638
; ---------------------------------------------------------------------------

loc_1000C84C:				; CODE XREF: sub_1000C570+2Cj
		mov	[esp+38h+var_30], offset aSrvcSessionMwc ; "srvc->session == mwChannel_getSession(c"...
		mov	[esp+38h+var_34], offset aRecv ; "recv"
		mov	[esp+38h+var_38], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000C638
; ---------------------------------------------------------------------------

loc_1000C86D:				; CODE XREF: sub_1000C570+37j
		mov	[esp+38h+var_30], offset aDataNull_2 ; "data !=	NULL"
		mov	[esp+38h+var_34], offset aRecv ; "recv"
		mov	[esp+38h+var_38], offset aMeanwhile_5 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000C638
sub_1000C570	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000C890	proc near		; DATA XREF: mwServiceAware_new+9Fo

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+48h], 0
		pop	ebp
		jmp	mwService_stop
sub_1000C890	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000C8B0	proc near		; DATA XREF: mwServiceAware_new+98o

var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_0]
		mov	[ebp+var_C], ebx
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_8], esi
		mov	esi, [edi+48h]
		test	esi, esi
		jz	short loc_1000C93D
		cmp	esi, eax
		jnz	loc_1000C963
		mov	[esp+18h+var_18], edi
		call	mwService_getState
		cmp	eax, 3
		nop
		jz	short loc_1000C904
		mov	[ebp+arg_0], esi
		mov	ebx, [ebp+var_C]
		mov	[ebp+arg_8], 0
		mov	esi, [ebp+var_8]
		mov	[ebp+arg_4], 80000000h
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	mwChannel_destroy
; ---------------------------------------------------------------------------

loc_1000C904:				; CODE XREF: sub_1000C8B0+30j
		mov	eax, [edi+3Ch]
		mov	[esp+18h+var_18], eax
		call	map_collect_values
		mov	edx, eax
		mov	ebx, eax
		mov	eax, esi
		call	sub_1000AEB0
		mov	[esp+18h+var_18], ebx
		call	g_list_free
		mov	eax, edi
		call	sub_1000B8F0
		mov	ebx, [ebp+var_C]
		mov	[ebp+arg_0], edi
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	mwService_started
; ---------------------------------------------------------------------------

loc_1000C93D:				; CODE XREF: sub_1000C8B0+1Aj
		mov	[ebp+arg_8], offset aSrvcChannelNul ; "srvc->channel !=	NULL"

loc_1000C944:				; CODE XREF: sub_1000C8B0+BAj
		mov	[ebp+arg_4], offset aRecv_accept ; "recv_accept"
		mov	ebx, [ebp+var_C]
		mov	[ebp+arg_0], offset aMeanwhile_5 ; "meanwhile"
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_1000C963:				; CODE XREF: sub_1000C8B0+1Ej
		mov	[ebp+arg_8], offset aSrvcChannelCha ; "srvc->channel ==	chan"
		jmp	short loc_1000C944
sub_1000C8B0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000C970	proc near		; DATA XREF: mwServiceConference_new+58o
		push	ebp
		mov	ebp, esp
		pop	ebp
		retn
sub_1000C970	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000C980	proc near		; DATA XREF: mwServiceConference_new+74o
		push	ebp
		mov	eax, offset aBasicConferenc ; "Basic Conferencing"
		mov	ebp, esp
		pop	ebp
		retn
sub_1000C980	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000C990	proc near		; DATA XREF: mwServiceConference_new+7Bo
		push	ebp
		mov	eax, offset aMultiUserPlain ; "Multi-user plain-text conferencing"
		mov	ebp, esp
		pop	ebp
		retn
sub_1000C990	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 269. mwServiceConference_getHandler

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceConference_getHandler
mwServiceConference_getHandler proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000C9B2
		mov	eax, [eax+38h]
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000C9B2:				; CODE XREF: mwServiceConference_getHandler+Bj
		mov	[esp+18h+var_10], offset aSrvcNull_2 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwserviceconfe ; "mwServiceConference_getHandler"
		mov	[esp+18h+var_18], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwServiceConference_getHandler endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 105. mwConference_getTitle

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConference_getTitle
mwConference_getTitle proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000C9F2
		mov	eax, [eax+10h]
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000C9F2:				; CODE XREF: mwConference_getTitle+Bj
		mov	[esp+18h+var_10], offset aConfNull ; "conf != NULL"
		mov	[esp+18h+var_14], offset aMwconference_g ; "mwConference_getTitle"
		mov	[esp+18h+var_18], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwConference_getTitle endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 103. mwConference_getName

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConference_getName
mwConference_getName proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000CA32
		mov	eax, [eax+0Ch]
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000CA32:				; CODE XREF: mwConference_getName+Bj
		mov	[esp+18h+var_10], offset aConfNull ; "conf != NULL"
		mov	[esp+18h+var_14], offset aMwconference_0 ; "mwConference_getName"
		mov	[esp+18h+var_18], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwConference_getName endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 104. mwConference_getService

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConference_getService
mwConference_getService	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000CA72
		mov	eax, [eax+4]
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000CA72:				; CODE XREF: mwConference_getService+Bj
		mov	[esp+18h+var_10], offset aConfNull ; "conf != NULL"
		mov	[esp+18h+var_14], offset aMwconference_1 ; "mwConference_getService"
		mov	[esp+18h+var_18], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwConference_getService	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000CAA0	proc near		; CODE XREF: sub_1000D220+1Ap
					; sub_1000D750+13p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		test	eax, eax
		jz	short loc_1000CACF
		test	edx, edx
		jz	short loc_1000CAEF
		mov	eax, [eax+3Ch]
		test	eax, eax
		jnz	short loc_1000CABE
		jmp	short locret_1000CAC9
; ---------------------------------------------------------------------------

loc_1000CAB7:				; CODE XREF: sub_1000CAA0+23j
		mov	eax, [eax+4]
		test	eax, eax
		jz	short locret_1000CAC9

loc_1000CABE:				; CODE XREF: sub_1000CAA0+13j
		mov	ecx, [eax]
		cmp	[ecx+8], edx
		jnz	short loc_1000CAB7

locret_1000CAC5:			; CODE XREF: sub_1000CAA0+4Dj
					; sub_1000CAA0+6Dj
		leave
		mov	eax, ecx
		retn
; ---------------------------------------------------------------------------

locret_1000CAC9:			; CODE XREF: sub_1000CAA0+15j
					; sub_1000CAA0+1Cj
		leave
		xor	ecx, ecx
		mov	eax, ecx
		retn
; ---------------------------------------------------------------------------

loc_1000CACF:				; CODE XREF: sub_1000CAA0+8j
		mov	[esp+18h+var_10], offset aSrvcNull_2 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aConf_find ; "conf_find"
		mov	[esp+18h+var_18], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	ecx, ecx
		jmp	short locret_1000CAC5
; ---------------------------------------------------------------------------

loc_1000CAEF:				; CODE XREF: sub_1000CAA0+Cj
		mov	[esp+18h+var_10], offset aChanNull_4 ; "chan !=	NULL"
		mov	[esp+18h+var_14], offset aConf_find ; "conf_find"
		mov	[esp+18h+var_18], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	ecx, ecx
		jmp	short locret_1000CAC5
sub_1000CAA0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 268. mwServiceConference_getConferences

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceConference_getConferences
mwServiceConference_getConferences proc	near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000CB29
		mov	eax, [eax+3Ch]
		mov	[ebp+arg_0], eax
		leave
		jmp	g_list_copy
; ---------------------------------------------------------------------------

loc_1000CB29:				; CODE XREF: mwServiceConference_getConferences+Bj
		mov	[esp+18h+var_10], offset aSrvcNull_2 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwservicecon_0 ; "mwServiceConference_getConferences"
		mov	[esp+18h+var_18], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwServiceConference_getConferences endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 109. mwConference_removeClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConference_removeClientData
mwConference_removeClientData proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000CB69
		add	eax, 3Ch
		mov	[ebp+arg_0], eax
		leave
		jmp	mw_datum_clear
; ---------------------------------------------------------------------------

loc_1000CB69:				; CODE XREF: mwConference_removeClientData+Bj
		mov	[esp+18h+var_10], offset aConferenceNull ; "conference != NULL"
		mov	[esp+18h+var_14], offset aMwconference_r ; "mwConference_removeClientData"
		mov	[esp+18h+var_18], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwConference_removeClientData endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 101. mwConference_getClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConference_getClientData
mwConference_getClientData proc	near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000CBA9
		add	eax, 3Ch
		mov	[ebp+arg_0], eax
		leave
		jmp	mw_datum_get
; ---------------------------------------------------------------------------

loc_1000CBA9:				; CODE XREF: mwConference_getClientData+Bj
		mov	[esp+18h+var_10], offset aConferenceNull ; "conference != NULL"
		mov	[esp+18h+var_14], offset aMwconference_2 ; "mwConference_getClientData"
		mov	[esp+18h+var_18], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwConference_getClientData endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 112. mwConference_setClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConference_setClientData
mwConference_setClientData proc	near

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	edx, [ebp+arg_8]
		test	eax, eax
		jz	short loc_1000CBF2
		add	eax, 3Ch
		mov	[ebp+arg_8], edx
		mov	[ebp+arg_4], ecx
		mov	[ebp+arg_0], eax
		pop	ebp
		jmp	mw_datum_set
; ---------------------------------------------------------------------------

loc_1000CBF2:				; CODE XREF: mwConference_setClientData+Ej
		mov	[ebp+arg_8], offset aConferenceNull ; "conference != NULL"
		mov	[ebp+arg_4], offset aMwconference_s ; "mwConference_setClientData"
		mov	[ebp+arg_0], offset aMeanwhile_6 ; "meanwhile"
		pop	ebp
		jmp	g_return_if_fail_warning
mwConference_setClientData endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 111. mwConference_sendTyping

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConference_sendTyping
mwConference_sendTyping	proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_10		= byte ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 20h
		mov	esi, [ebp+arg_0]
		test	esi, esi
		jz	loc_1000CCC4
		mov	eax, [esi+8]
		test	eax, eax
		jz	loc_1000CCE7
		cmp	dword ptr [esi], 3
		jnz	loc_1000CD0A
		call	mwPutBuffer_new
		mov	[esp+28h+var_24], 2
		mov	ebx, eax
		mov	[esp+28h+var_28], eax
		call	guint32_put
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], 1
		call	guint32_put
		xor	eax, eax
		cmp	[ebp+arg_4], 0
		mov	[esp+28h+var_28], ebx
		setz	al
		mov	[esp+28h+var_24], eax
		call	guint32_put
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], 0
		call	mwOpaque_put
		mov	[esp+28h+var_24], ebx
		lea	ebx, [ebp+var_10]
		mov	[esp+28h+var_28], ebx
		call	mwPutBuffer_finalize
		mov	[esp+28h+var_1C], 0
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_24], 4
		mov	eax, [esi+8]
		mov	[esp+28h+var_28], eax
		call	mwChannel_sendEncrypted
		mov	[esp+28h+var_28], ebx
		mov	esi, eax
		call	mwOpaque_clear

loc_1000CCBB:				; CODE XREF: mwConference_sendTyping+D5j
					; mwConference_sendTyping+F8j ...
		add	esp, 20h
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000CCC4:				; CODE XREF: mwConference_sendTyping+Dj
		mov	[esp+28h+var_20], offset aConfNull ; "conf != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwconference_3 ; "mwConference_sendTyping"
		mov	[esp+28h+var_28], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000CCBB
; ---------------------------------------------------------------------------

loc_1000CCE7:				; CODE XREF: mwConference_sendTyping+18j
		mov	[esp+28h+var_20], offset aConfChannelNul ; "conf->channel != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwconference_3 ; "mwConference_sendTyping"
		mov	[esp+28h+var_28], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000CCBB
; ---------------------------------------------------------------------------

loc_1000CD0A:				; CODE XREF: mwConference_sendTyping+21j
		mov	[esp+28h+var_20], offset aConfStateMwcon ; "conf->state	== mwConference_OPEN"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwconference_3 ; "mwConference_sendTyping"
		mov	[esp+28h+var_28], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000CCBB
mwConference_sendTyping	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 110. mwConference_sendText

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl mwConference_sendText(int, char *)
		public mwConference_sendText
mwConference_sendText proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_10		= byte ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 20h
		mov	esi, [ebp+arg_0]
		test	esi, esi
		jz	short loc_1000CDB1
		mov	edx, [esi+8]
		test	edx, edx
		jz	loc_1000CDD4
		call	mwPutBuffer_new
		mov	[esp+28h+var_24], 1
		mov	ebx, eax
		mov	[esp+28h+var_28], eax
		call	guint32_put
		mov	eax, [ebp+arg_4]
		mov	[esp+28h+var_28], ebx ;	int
		mov	[esp+28h+var_24], eax ;	char *
		call	mwString_put
		mov	[esp+28h+var_24], ebx
		lea	ebx, [ebp+var_10]
		mov	[esp+28h+var_28], ebx
		call	mwPutBuffer_finalize
		mov	[esp+28h+var_1C], 0
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_24], 4
		mov	eax, [esi+8]
		mov	[esp+28h+var_28], eax
		call	mwChannel_sendEncrypted
		mov	[esp+28h+var_28], ebx
		mov	esi, eax
		call	mwOpaque_clear

loc_1000CDA8:				; CODE XREF: mwConference_sendText+A2j
					; mwConference_sendText+C5j
		add	esp, 20h
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000CDB1:				; CODE XREF: mwConference_sendText+Dj
		mov	[esp+28h+var_20], offset aConfNull ; "conf != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwconference_4 ; "mwConference_sendText"
		mov	[esp+28h+var_28], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000CDA8
; ---------------------------------------------------------------------------

loc_1000CDD4:				; CODE XREF: mwConference_sendText+14j
		mov	[esp+28h+var_20], offset aConfChannelNul ; "conf->channel != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwconference_4 ; "mwConference_sendText"
		mov	[esp+28h+var_28], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000CDA8
mwConference_sendText endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 106. mwConference_invite

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl mwConference_invite(int, int, char *)
		public mwConference_invite
mwConference_invite proc near

var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_14		= byte ptr -14h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 2Ch
		mov	edi, [ebp+arg_0]
		mov	esi, [ebp+arg_4]
		test	edi, edi
		jz	loc_1000CEBC
		mov	ecx, [edi+8]
		test	ecx, ecx
		jz	loc_1000CEDF
		test	esi, esi
		jz	loc_1000CF02
		call	mwPutBuffer_new
		mov	[esp+38h+var_34], esi
		mov	ebx, eax
		mov	[esp+38h+var_38], eax
		call	mwIdBlock_put
		mov	[esp+38h+var_38], ebx
		mov	[esp+38h+var_34], 0
		call	guint16_put
		mov	[esp+38h+var_38], ebx
		mov	[esp+38h+var_34], 0
		call	guint32_put
		mov	eax, [ebp+arg_8]
		mov	[esp+38h+var_38], ebx ;	int
		mov	[esp+38h+var_34], eax ;	char *
		call	mwString_put
		mov	eax, [esi]
		mov	[esp+38h+var_38], ebx ;	int
		mov	[esp+38h+var_34], eax ;	char *
		call	mwString_put
		mov	[esp+38h+var_34], ebx
		lea	ebx, [ebp+var_14]
		mov	[esp+38h+var_38], ebx
		call	mwPutBuffer_finalize
		mov	[esp+38h+var_2C], 0
		mov	[esp+38h+var_30], ebx
		mov	[esp+38h+var_34], 1
		mov	eax, [edi+8]
		mov	[esp+38h+var_38], eax
		call	mwChannel_sendEncrypted
		mov	[esp+38h+var_38], ebx
		mov	esi, eax
		call	mwOpaque_clear

loc_1000CEB2:				; CODE XREF: mwConference_invite+DDj
					; mwConference_invite+100j ...
		add	esp, 2Ch
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000CEBC:				; CODE XREF: mwConference_invite+11j
		mov	[esp+38h+var_30], offset aConfNull ; "conf != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+38h+var_34], offset aMwconference_i ; "mwConference_invite"
		mov	[esp+38h+var_38], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000CEB2
; ---------------------------------------------------------------------------

loc_1000CEDF:				; CODE XREF: mwConference_invite+1Cj
		mov	[esp+38h+var_30], offset aConfChannelNul ; "conf->channel != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+38h+var_34], offset aMwconference_i ; "mwConference_invite"
		mov	[esp+38h+var_38], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000CEB2
; ---------------------------------------------------------------------------

loc_1000CF02:				; CODE XREF: mwConference_invite+24j
		mov	[esp+38h+var_30], offset aWhoNull ; "who != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+38h+var_34], offset aMwconference_i ; "mwConference_invite"
		mov	[esp+38h+var_38], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000CEB2
mwConference_invite endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  99. mwConference_accept

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConference_accept
mwConference_accept proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000CF7E
		cmp	dword ptr [eax], 2
		jnz	short loc_1000CFA1
		mov	ebx, [eax+8]
		mov	[esp+18h+var_18], ebx
		call	mwChannel_accept
		test	eax, eax
		jz	short loc_1000CF58

loc_1000CF52:				; CODE XREF: mwConference_accept+6Fj
					; mwConference_accept+92j
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000CF58:				; CODE XREF: mwConference_accept+20j
		mov	[esp+18h+var_18], ebx
		mov	[esp+18h+var_C], 0
		mov	[esp+18h+var_10], 0
		mov	[esp+18h+var_14], 2
		call	mwChannel_sendEncrypted
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000CF7E:				; CODE XREF: mwConference_accept+Cj
		mov	[esp+18h+var_10], offset aConfNull ; "conf != NULL"
		mov	[esp+18h+var_14], offset aMwconference_a ; "mwConference_accept"
		mov	[esp+18h+var_18], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFFFFFh
		jmp	short loc_1000CF52
; ---------------------------------------------------------------------------

loc_1000CFA1:				; CODE XREF: mwConference_accept+11j
		mov	[esp+18h+var_10], offset aConfStateMwc_0 ; "conf->state	== mwConference_INVITED"
		mov	[esp+18h+var_14], offset aMwconference_a ; "mwConference_accept"
		mov	[esp+18h+var_18], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFFFFFh
		jmp	short loc_1000CF52
mwConference_accept endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000CFD0	proc near		; CODE XREF: mwConference_destroy+73p
					; sub_1000D130+13p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		mov	ebx, eax
		sub	esp, 10h
		test	eax, eax
		jz	short loc_1000D02F
		mov	esi, [eax+4]
		mov	eax, [eax+38h]
		test	eax, eax
		jz	short loc_1000CFF0
		mov	[esp+18h+var_18], eax
		call	g_hash_table_destroy

loc_1000CFF0:				; CODE XREF: sub_1000CFD0+16j
		mov	[esp+18h+var_14], ebx
		mov	eax, [esi+3Ch]
		mov	[esp+18h+var_18], eax
		call	g_list_remove_all
		lea	eax, [ebx+3Ch]
		mov	[esp+18h+var_18], eax
		call	mw_datum_clear
		mov	eax, [ebx+0Ch]
		mov	[esp+18h+var_18], eax
		call	g_free
		mov	eax, [ebx+10h]
		mov	[esp+18h+var_18], eax
		call	g_free
		mov	[esp+18h+var_18], ebx
		call	g_free

loc_1000D028:				; CODE XREF: sub_1000CFD0+7Bj
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000D02F:				; CODE XREF: sub_1000CFD0+Cj
		mov	[esp+18h+var_10], offset aConfNull ; "conf != NULL"
		mov	[esp+18h+var_14], offset aConf_free ; "conf_free"
		mov	[esp+18h+var_18], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000D028
sub_1000CFD0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 100. mwConference_destroy

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl mwConference_destroy(int,	int, char *)
		public mwConference_destroy
mwConference_destroy proc near		; CODE XREF: sub_1000D220+6Dj
					; sub_1000D750+390p ...

Str		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_8]
		mov	[ebp+var_C], ebx
		mov	[ebp+var_14], 0
		test	esi, esi
		mov	[ebp+var_10], 0
		jz	short loc_1000D0E7
		mov	ebx, [esi+4]
		test	ebx, ebx
		jz	loc_1000D10A
		mov	[esp+28h+var_24], esi
		mov	eax, [ebx+3Ch]
		mov	[esp+28h+Str], eax
		call	g_list_remove_all
		mov	[ebx+3Ch], eax
		mov	eax, [esi+8]
		xor	ebx, ebx
		test	eax, eax
		jz	short loc_1000D0C1
		test	edi, edi
		jz	short loc_1000D0A6
		cmp	byte ptr [edi],	0
		jnz	short loc_1000D0D7

loc_1000D0A6:				; CODE XREF: mwConference_destroy+4Fj
					; mwConference_destroy+95j
		lea	eax, [ebp+var_14]
		mov	[esp+28h+var_20], eax
		mov	eax, [ebp+arg_4]
		mov	[esp+28h+var_24], eax
		mov	eax, [esi+8]
		mov	[esp+28h+Str], eax
		call	mwChannel_destroy
		mov	ebx, eax

loc_1000D0C1:				; CODE XREF: mwConference_destroy+4Bj
		mov	eax, esi
		call	sub_1000CFD0

loc_1000D0C8:				; CODE XREF: mwConference_destroy+B8j
					; mwConference_destroy+DBj
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000D0D7:				; CODE XREF: mwConference_destroy+54j
		mov	[esp+28h+Str], edi ; Str
		call	strlen
		mov	[ebp+var_10], edi
		mov	[ebp+var_14], eax
		jmp	short loc_1000D0A6
; ---------------------------------------------------------------------------

loc_1000D0E7:				; CODE XREF: mwConference_destroy+25j
		mov	[esp+28h+var_20], offset aConfNull ; "conf != NULL"
		mov	ebx, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwconference_d ; "mwConference_destroy"
		mov	[esp+28h+Str], offset aMeanwhile_6 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000D0C8
; ---------------------------------------------------------------------------

loc_1000D10A:				; CODE XREF: mwConference_destroy+2Cj
		mov	[esp+28h+var_20], offset aSrvcNull_2 ; "srvc !=	NULL"
		mov	ebx, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwconference_d ; "mwConference_destroy"
		mov	[esp+28h+Str], offset aMeanwhile_6 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000D0C8
mwConference_destroy endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000D130	proc near		; DATA XREF: mwServiceConference_new+6Do

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebx+3Ch]
		test	eax, eax
		jz	short loc_1000D14F

loc_1000D141:				; CODE XREF: sub_1000D130+1Dj
		mov	eax, [eax]
		call	sub_1000CFD0
		mov	eax, [ebx+3Ch]
		test	eax, eax
		jnz	short loc_1000D141

loc_1000D14F:				; CODE XREF: sub_1000D130+Fj
		mov	eax, [ebx+38h]
		test	eax, eax
		jz	short loc_1000D162
		mov	eax, [eax+1Ch]
		test	eax, eax
		jz	short loc_1000D162
		mov	[esp+8+var_8], ebx
		call	eax

loc_1000D162:				; CODE XREF: sub_1000D130+24j
					; sub_1000D130+2Bj
		mov	dword ptr [ebx+38h], 0
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
sub_1000D130	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000D170	proc near		; CODE XREF: sub_1000D220+38p
					; mwConference_open+F4p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		test	eax, eax
		jz	short loc_1000D1F5
		cmp	[eax], edx
		jz	short locret_1000D1BB
		cmp	edx, 5		; switch 6 cases
		mov	ecx, offset aUnknown_1 ; "UNKNOWN"
		mov	[eax], edx
		jbe	short loc_1000D1C0

loc_1000D18A:				; CODE XREF: sub_1000D170+60j
					; sub_1000D170+67j ...
		mov	eax, [eax+0Ch]	; jumptable 1000D1C0 default case
		mov	edx, offset aNull_3 ; "(null)"
		mov	[esp+18h+var_8], ecx
		mov	[esp+18h+var_10], offset aConferenceSSta ; "conference %s state: %s"
		mov	[esp+18h+var_14], 20h
		test	eax, eax
		cmovz	eax, edx
		mov	[esp+18h+var_C], eax
		mov	[esp+18h+var_18], offset aMeanwhile_6 ;	"meanwhile"
		call	g_log

locret_1000D1BB:			; CODE XREF: sub_1000D170+Cj
		leave
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_1000D1C0:				; CODE XREF: sub_1000D170+18j
		jmp	ds:off_1001E698[edx*4] ; switch	jump
; ---------------------------------------------------------------------------

loc_1000D1C7:				; CODE XREF: sub_1000D170:loc_1000D1C0j
					; DATA XREF: .rdata:off_1001E698o
		mov	ecx, offset aError_0 ; jumptable 1000D1C0 case 5
		lea	esi, [esi+0]
		jmp	short loc_1000D18A ; jumptable 1000D1C0	default	case
; ---------------------------------------------------------------------------

loc_1000D1D2:				; CODE XREF: sub_1000D170:loc_1000D1C0j
					; DATA XREF: .rdata:off_1001E698o
		mov	ecx, offset aClosing_0 ; jumptable 1000D1C0 case 4
		jmp	short loc_1000D18A ; jumptable 1000D1C0	default	case
; ---------------------------------------------------------------------------

loc_1000D1D9:				; CODE XREF: sub_1000D170:loc_1000D1C0j
					; DATA XREF: .rdata:off_1001E698o
		mov	ecx, offset aOpen_0 ; jumptable	1000D1C0 case 3
		jmp	short loc_1000D18A ; jumptable 1000D1C0	default	case
; ---------------------------------------------------------------------------

loc_1000D1E0:				; CODE XREF: sub_1000D170:loc_1000D1C0j
					; DATA XREF: .rdata:off_1001E698o
		mov	ecx, offset aInvited ; jumptable 1000D1C0 case 2
		jmp	short loc_1000D18A ; jumptable 1000D1C0	default	case
; ---------------------------------------------------------------------------

loc_1000D1E7:				; CODE XREF: sub_1000D170:loc_1000D1C0j
					; DATA XREF: .rdata:off_1001E698o
		mov	ecx, offset aPending ; jumptable 1000D1C0 case 1
		jmp	short loc_1000D18A ; jumptable 1000D1C0	default	case
; ---------------------------------------------------------------------------

loc_1000D1EE:				; CODE XREF: sub_1000D170:loc_1000D1C0j
					; DATA XREF: .rdata:off_1001E698o
		mov	ecx, offset aNew_0 ; jumptable 1000D1C0	case 0
		jmp	short loc_1000D18A ; jumptable 1000D1C0	default	case
; ---------------------------------------------------------------------------

loc_1000D1F5:				; CODE XREF: sub_1000D170+8j
		mov	[esp+18h+var_10], offset aConfNull ; "conf != NULL"
		mov	[esp+18h+var_14], offset aConf_state ; "conf_state"
		mov	[esp+18h+var_18], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
sub_1000D170	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000D220	proc near		; DATA XREF: mwServiceConference_new+5Fo

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_C], ebx
		mov	ebx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		mov	[ebp+var_8], esi
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_8]
		mov	eax, ebx
		call	sub_1000CAA0
		mov	ebx, [ebx+38h]
		test	eax, eax
		mov	esi, eax
		jz	short loc_1000D292
		cmp	dword ptr [edi+10h], 1
		mov	dword ptr [eax+8], 0
		sbb	edx, edx
		add	edx, 5
		call	sub_1000D170
		mov	edx, [ebx+8]
		test	edx, edx
		jz	short loc_1000D270
		mov	eax, [edi+10h]
		mov	[esp+18h+var_18], esi
		mov	[esp+18h+var_14], eax
		call	edx

loc_1000D270:				; CODE XREF: sub_1000D220+42j
		mov	[ebp+arg_0], esi
		mov	ebx, [ebp+var_C]
		mov	[ebp+arg_8], 0
		mov	esi, [ebp+var_8]
		mov	[ebp+arg_4], 0
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	mwConference_destroy
; ---------------------------------------------------------------------------

loc_1000D292:				; CODE XREF: sub_1000D220+26j
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
sub_1000D220	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 108. mwConference_open

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConference_open
mwConference_open proc near

Seed		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	edi, [ebp+arg_0]
		test	edi, edi
		jz	loc_1000D458
		mov	eax, [edi+4]
		test	eax, eax
		jz	loc_1000D47E
		mov	ecx, [edi]
		test	ecx, ecx
		jnz	loc_1000D4A4
		mov	edx, [edi+8]
		test	edx, edx
		jnz	loc_1000D4CA
		mov	[esp+28h+Seed],	eax
		call	mwService_getSession
		test	eax, eax
		mov	[ebp+var_14], eax
		jz	loc_1000D4F0
		mov	eax, [edi+0Ch]
		test	eax, eax
		jz	loc_1000D3BC

loc_1000D2F2:				; CODE XREF: mwConference_open+1B3j
		mov	eax, [ebp+var_14]
		mov	[esp+28h+Seed],	eax
		call	mwSession_getChannels
		mov	[esp+28h+Seed],	eax
		call	mwChannel_newOutgoing
		mov	esi, eax
		mov	eax, [edi+4]
		mov	[esp+28h+Seed],	esi
		mov	[esp+28h+var_24], eax
		call	mwChannel_setService
		mov	[esp+28h+var_24], 10h
		mov	[esp+28h+Seed],	esi
		call	mwChannel_setProtoType
		mov	[esp+28h+var_24], 2
		mov	[esp+28h+Seed],	esi
		call	mwChannel_setProtoVer
		call	mwPutBuffer_new
		mov	ebx, eax
		mov	eax, [edi+0Ch]
		mov	[esp+28h+Seed],	ebx ; int
		mov	[esp+28h+var_24], eax ;	char *
		call	mwString_put
		mov	eax, [edi+10h]
		mov	[esp+28h+Seed],	ebx ; int
		mov	[esp+28h+var_24], eax ;	char *
		call	mwString_put
		mov	[esp+28h+Seed],	ebx
		mov	[esp+28h+var_24], 0
		call	guint32_put
		mov	[esp+28h+Seed],	esi
		call	mwChannel_getAddtlCreate
		mov	[esp+28h+var_24], ebx
		mov	[esp+28h+Seed],	eax
		call	mwPutBuffer_finalize
		mov	[esp+28h+Seed],	esi
		call	mwChannel_create
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_1000D3A6
		mov	edx, 1
		mov	eax, edi
		call	sub_1000D170
		mov	[edi+8], esi

loc_1000D39C:				; CODE XREF: mwConference_open+1D9j
					; mwConference_open+1FFj ...
		add	esp, 1Ch
		mov	eax, ebx
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000D3A6:				; CODE XREF: mwConference_open+EBj
		mov	eax, edi
		mov	edx, 5
		call	sub_1000D170
		add	esp, 1Ch
		mov	eax, ebx
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000D3BC:				; CODE XREF: mwConference_open+4Cj
		mov	[esp+28h+var_24], offset aSession_auth_0 ; "session.auth.user"
		mov	eax, [ebp+var_14]
		mov	esi, offset aMeanwhile_6 ; "meanwhile"
		mov	[esp+28h+Seed],	eax
		call	mwSession_getProperty
		test	eax, eax
		cmovnz	esi, eax
		call	clock
		mov	ebx, eax
		call	rand
		add	eax, ebx
		mov	[esp+28h+Seed],	eax ; Seed
		call	srand
		call	rand
		mov	ebx, eax
		call	rand
		mov	[ebp+var_10], eax
		mov	[esp+28h+Seed],	0 ; Time
		call	time
		movzx	ecx, byte ptr [ebp+var_10]
		movzx	edx, bl
		shl	edx, 8
		mov	[esp+28h+var_24], esi
		mov	[esp+28h+Seed],	offset aS08x04x	; "%s(%08x,%04x)"
		or	edx, ecx
		mov	[esp+28h+var_1C], edx
		mov	[esp+28h+var_20], eax
		call	g_strdup_printf
		mov	[esp+28h+var_20], offset aGeneratedRando ; "generated random conference	name: '%s'"
		mov	[esp+28h+var_24], 80h
		mov	[esp+28h+Seed],	offset aMeanwhile_6 ; "meanwhile"
		mov	ebx, eax
		mov	[esp+28h+var_1C], eax
		call	g_log
		mov	[edi+0Ch], ebx
		jmp	loc_1000D2F2
; ---------------------------------------------------------------------------

loc_1000D458:				; CODE XREF: mwConference_open+Ej
		mov	[esp+28h+var_20], offset aConfNull ; "conf != NULL"
		mov	ebx, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwconference_o ; "mwConference_open"
		mov	[esp+28h+Seed],	offset aMeanwhile_6 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000D39C
; ---------------------------------------------------------------------------

loc_1000D47E:				; CODE XREF: mwConference_open+19j
		mov	[esp+28h+var_20], offset aConfServiceNul ; "conf->service != NULL"
		mov	ebx, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwconference_o ; "mwConference_open"
		mov	[esp+28h+Seed],	offset aMeanwhile_6 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000D39C
; ---------------------------------------------------------------------------

loc_1000D4A4:				; CODE XREF: mwConference_open+23j
		mov	[esp+28h+var_20], offset aConfStateMwc_1 ; "conf->state	== mwConference_NEW"
		mov	ebx, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwconference_o ; "mwConference_open"
		mov	[esp+28h+Seed],	offset aMeanwhile_6 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000D39C
; ---------------------------------------------------------------------------

loc_1000D4CA:				; CODE XREF: mwConference_open+2Ej
		mov	[esp+28h+var_20], offset aConfChannelN_0 ; "conf->channel == NULL"
		mov	ebx, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwconference_o ; "mwConference_open"
		mov	[esp+28h+Seed],	offset aMeanwhile_6 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000D39C
; ---------------------------------------------------------------------------

loc_1000D4F0:				; CODE XREF: mwConference_open+41j
		mov	[esp+28h+var_20], offset aSessionNull_2	; "session != NULL"
		mov	ebx, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwconference_o ; "mwConference_open"
		mov	[esp+28h+Seed],	offset aMeanwhile_6 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000D39C
mwConference_open endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 102. mwConference_getMembers

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConference_getMembers
mwConference_getMembers	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000D53D
		mov	eax, [eax+38h]
		test	eax, eax
		jz	short loc_1000D55D
		mov	[ebp+arg_0], eax
		leave
		jmp	map_collect_values
; ---------------------------------------------------------------------------

loc_1000D53D:				; CODE XREF: mwConference_getMembers+Bj
		mov	[esp+18h+var_10], offset aConfNull ; "conf != NULL"
		mov	[esp+18h+var_14], offset aMwconference_5 ; "mwConference_getMembers"
		mov	[esp+18h+var_18], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning

locret_1000D559:			; CODE XREF: mwConference_getMembers+59j
		leave
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1000D55D:				; CODE XREF: mwConference_getMembers+12j
		mov	[esp+18h+var_10], offset aConfMembersNul ; "conf->members != NULL"
		mov	[esp+18h+var_14], offset aMwconference_5 ; "mwConference_getMembers"
		mov	[esp+18h+var_18], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short locret_1000D559
mwConference_getMembers	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000D580	proc near		; CODE XREF: mwConference_new+Ep
					; sub_1000DC50+16p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		mov	esi, eax
		push	ebx
		sub	esp, 10h
		mov	[esp+18h+var_18], 44h
		call	g_malloc0
		mov	[eax+4], esi
		mov	ebx, eax
		mov	dword ptr [eax], 0
		mov	[esp+18h+var_C], offset	sub_1000D650
		mov	[esp+18h+var_10], 0
		mov	[esp+18h+var_14], offset loc_1001A918
		mov	[esp+18h+var_18], offset loc_1001A910
		call	g_hash_table_new_full
		mov	[esp+18h+var_18], esi
		mov	[ebx+38h], eax
		call	mwService_getSession
		mov	[esp+18h+var_14], offset aSession_auth_0 ; "session.auth.user"
		mov	[esp+18h+var_18], eax
		call	mwSession_getProperty
		mov	eax, [esi+3Ch]
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+var_18], eax
		call	g_list_prepend
		mov	[esi+3Ch], eax
		add	esp, 10h
		mov	eax, ebx
		pop	ebx
		pop	esi
		pop	ebp
		retn
sub_1000D580	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 107. mwConference_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConference_new
mwConference_new proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000D62B
		call	sub_1000D580
		mov	ebx, eax
		mov	eax, [ebp+arg_4]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[ebx+10h], eax

loc_1000D623:				; CODE XREF: mwConference_new+49j
		mov	eax, ebx
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000D62B:				; CODE XREF: mwConference_new+Cj
		mov	[esp+18h+var_10], offset aSrvcNull_2 ; "srvc !=	NULL"
		xor	ebx, ebx
		mov	[esp+18h+var_14], offset aMwconference_n ; "mwConference_new"
		mov	[esp+18h+var_18], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000D623
mwConference_new endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000D650	proc near		; CODE XREF: sub_1000D750+171p
					; sub_1000D750+2B1p
					; DATA XREF: ...

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		mov	[esp+8+var_8], ebx
		call	mwLoginInfo_clear
		mov	[ebp+arg_0], ebx
		add	esp, 4
		pop	ebx
		pop	ebp
		jmp	g_free
sub_1000D650	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 270. mwServiceConference_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceConference_new
mwServiceConference_new	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		test	esi, esi
		jz	short loc_1000D704
		test	edi, edi
		jz	loc_1000D724
		mov	[esp+18h+var_18], 40h
		call	g_malloc0
		mov	[esp+18h+var_10], 80000010h
		mov	[esp+18h+var_14], esi
		mov	ebx, eax
		mov	[esp+18h+var_18], eax
		call	mwService_init
		mov	dword ptr [ebx+24h], offset sub_1000DDB0
		mov	dword ptr [ebx+28h], offset sub_1000DD70
		mov	dword ptr [ebx+14h], offset sub_1000DC50
		mov	dword ptr [ebx+18h], offset sub_1000C970
		mov	dword ptr [ebx+1Ch], offset sub_1000D220
		mov	dword ptr [ebx+20h], offset sub_1000D750
		mov	dword ptr [ebx+2Ch], offset sub_1000D130
		mov	dword ptr [ebx+0Ch], offset sub_1000C980
		mov	dword ptr [ebx+10h], offset sub_1000C990
		mov	[ebx+38h], edi

loc_1000D6F5:				; CODE XREF: mwServiceConference_new+B2j
					; mwServiceConference_new+D2j
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000D704:				; CODE XREF: mwServiceConference_new+17j
		mov	[esp+18h+var_10], offset aSessionNull_2	; "session != NULL"
		xor	ebx, ebx
		mov	[esp+18h+var_14], offset aMwservicecon_1 ; "mwServiceConference_new"
		mov	[esp+18h+var_18], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000D6F5
; ---------------------------------------------------------------------------

loc_1000D724:				; CODE XREF: mwServiceConference_new+1Bj
		mov	[esp+18h+var_10], offset aHandlerNull_1	; "handler != NULL"
		xor	ebx, ebx
		mov	[esp+18h+var_14], offset aMwservicecon_1 ; "mwServiceConference_new"
		mov	[esp+18h+var_18], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000D6F5
mwServiceConference_new	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000D750	proc near		; DATA XREF: mwServiceConference_new+66o

var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_30		= dword	ptr -30h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= word ptr -10h
var_E		= byte ptr -0Eh
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= word ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 3Ch
		mov	edx, [ebp+arg_4]
		mov	eax, [ebp+arg_0]
		movzx	ebx, [ebp+arg_8]
		call	sub_1000CAA0
		test	eax, eax
		mov	edi, eax
		jz	loc_1000DBA3
		mov	eax, [ebp+arg_C]
		mov	[esp+48h+var_48], eax
		call	mwGetBuffer_wrap
		cmp	bx, 2
		mov	esi, eax
		jz	loc_1000D9A0
		jbe	short loc_1000D7B0
		cmp	bx, 3
		nop
		jz	loc_1000DA0B
		cmp	bx, 4
		lea	esi, [esi+0]
		jz	loc_1000D8FE

loc_1000D7A6:				; CODE XREF: sub_1000D750+63j
					; sub_1000D750+1B8j ...
		add	esp, 3Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_1000D7B0:				; CODE XREF: sub_1000D750+39j
		test	bx, bx
		jnz	short loc_1000D7A6
		mov	eax, [edi+0Ch]
		mov	[esp+48h+var_48], eax
		call	g_free
		mov	eax, [edi+10h]
		mov	[esp+48h+var_48], eax
		call	g_free
		lea	eax, [edi+0Ch]
		mov	dword ptr [edi+0Ch], 0
		mov	dword ptr [edi+10h], 0
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], esi
		call	mwString_get
		lea	eax, [edi+10h]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], esi
		call	mwString_get
		lea	eax, [ebp+var_E]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], esi
		call	guint16_get
		lea	eax, [ebp+var_1C]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], esi
		call	guint32_get
		lea	eax, [ebp+var_14]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], esi
		call	guint32_get
		mov	[esp+48h+var_48], esi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_1000DAB1
		mov	eax, [ebp+var_14]
		mov	[ebp+var_30], 0
		sub	eax, 1
		mov	[ebp+var_14], eax
		add	eax, 1
		jz	short loc_1000D8C6
		mov	[ebp+var_30], 0
		jmp	short loc_1000D889
; ---------------------------------------------------------------------------

loc_1000D852:				; CODE XREF: sub_1000D750+16Cj
		mov	[esp+48h+var_40], ebx
		movzx	eax, [ebp+var_10]
		mov	[esp+48h+var_44], eax
		mov	eax, [edi+38h]
		mov	[esp+48h+var_48], eax
		call	g_hash_table_insert
		mov	[esp+48h+var_44], ebx
		mov	ecx, [ebp+var_30]
		mov	[esp+48h+var_48], ecx
		call	g_list_append
		mov	[ebp+var_30], eax
		mov	eax, [ebp+var_14]
		sub	eax, 1
		mov	[ebp+var_14], eax
		add	eax, 1
		jz	short loc_1000D8C6

loc_1000D889:				; CODE XREF: sub_1000D750+100j
		mov	[esp+48h+var_48], 24h
		call	g_malloc0
		lea	edx, [ebp+var_10]
		mov	[esp+48h+var_44], edx
		mov	[esp+48h+var_48], esi
		mov	ebx, eax
		call	guint16_get
		mov	[esp+48h+var_44], ebx
		mov	[esp+48h+var_48], esi
		call	mwLoginInfo_get
		mov	[esp+48h+var_48], esi
		call	mwGetBuffer_error
		test	eax, eax
		jz	short loc_1000D852
		mov	[esp+48h+var_48], ebx
		call	sub_1000D650

loc_1000D8C6:				; CODE XREF: sub_1000D750+F7j
					; sub_1000D750+137j
		mov	edx, 3
		mov	eax, edi
		call	sub_1000D170
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+38h]
		mov	eax, [eax+4]
		test	eax, eax
		jz	short loc_1000D8EB
		mov	ecx, [ebp+var_30]
		mov	[esp+48h+var_48], edi
		mov	[esp+48h+var_44], ecx
		call	eax

loc_1000D8EB:				; CODE XREF: sub_1000D750+18Dj
		mov	eax, [ebp+var_30]
		mov	[esp+48h+var_48], eax
		call	g_list_free
		add	esp, 3Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000D8FE:				; CODE XREF: sub_1000D750+50j
		mov	[esp+48h+var_48], eax
		call	mwGetBuffer_remaining
		test	eax, eax
		jz	loc_1000D7A6
		lea	eax, [ebp+var_10]
		lea	ebx, [ebp+var_14]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], esi
		call	guint16_get
		mov	[esp+48h+var_44], ebx
		mov	[esp+48h+var_48], esi
		call	guint32_get
		mov	[esp+48h+var_44], ebx
		mov	[esp+48h+var_48], esi
		call	guint32_get
		mov	[esp+48h+var_48], esi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_1000D7A6
		movzx	eax, [ebp+var_10]
		mov	[esp+48h+var_44], eax
		mov	eax, [edi+38h]
		mov	[esp+48h+var_48], eax
		call	g_hash_table_lookup
		test	eax, eax
		mov	ebx, eax
		jz	loc_1000DBF0
		mov	eax, [ebp+var_14]
		cmp	eax, 1
		jz	loc_1000DAEA
		cmp	eax, 2
		jz	loc_1000DB41
		mov	[esp+48h+var_3C], eax
		mov	[esp+48h+var_40], offset aUnknownMessa_3 ; "unknown message type 0x%4x received	in "...
		mov	[esp+48h+var_44], 10h
		mov	[esp+48h+var_48], offset aMeanwhile_6 ;	"meanwhile"
		call	g_log
		jmp	loc_1000D7A6
; ---------------------------------------------------------------------------
		align 10h

loc_1000D9A0:				; CODE XREF: sub_1000D750+33j
		cmp	dword ptr [edi], 1
		jz	loc_1000D7A6
		mov	[esp+48h+var_48], 24h
		call	g_malloc0
		mov	[esp+48h+var_48], esi
		mov	ebx, eax
		lea	eax, [ebp+var_10]
		mov	[esp+48h+var_44], eax
		call	guint16_get
		mov	[esp+48h+var_44], ebx
		mov	[esp+48h+var_48], esi
		call	mwLoginInfo_get
		mov	[esp+48h+var_48], esi
		call	mwGetBuffer_error
		test	eax, eax
		jz	loc_1000DA7B
		mov	[esp+48h+var_40], offset aFailedParsingJ ; "failed parsing JOIN	message	in conferen"...
		mov	[esp+48h+var_44], 10h
		mov	[esp+48h+var_48], offset aMeanwhile_6 ;	"meanwhile"
		call	g_log
		mov	[esp+48h+var_48], ebx
		call	sub_1000D650
		jmp	loc_1000D7A6
; ---------------------------------------------------------------------------

loc_1000DA0B:				; CODE XREF: sub_1000D750+40j
		mov	[ebp+var_10], 0
		lea	eax, [ebp+var_10]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], esi
		call	guint16_get
		mov	[esp+48h+var_48], esi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_1000D7A6
		movzx	eax, [ebp+var_10]
		mov	[esp+48h+var_44], eax
		mov	eax, [edi+38h]
		mov	[esp+48h+var_48], eax
		call	g_hash_table_lookup
		test	eax, eax
		mov	edx, eax
		jz	loc_1000D7A6
		mov	ecx, [ebp+arg_0]
		mov	eax, [ecx+38h]
		mov	eax, [eax+10h]
		test	eax, eax
		jz	short loc_1000DA63
		mov	[esp+48h+var_44], edx
		mov	[esp+48h+var_48], edi
		call	eax

loc_1000DA63:				; CODE XREF: sub_1000D750+308j
		movzx	eax, [ebp+var_10]
		mov	[esp+48h+var_44], eax
		mov	eax, [edi+38h]
		mov	[esp+48h+var_48], eax
		call	g_hash_table_remove
		jmp	loc_1000D7A6
; ---------------------------------------------------------------------------

loc_1000DA7B:				; CODE XREF: sub_1000D750+28Cj
		mov	[esp+48h+var_40], ebx
		movzx	eax, [ebp+var_10]
		mov	[esp+48h+var_44], eax
		mov	eax, [edi+38h]
		mov	[esp+48h+var_48], eax
		call	g_hash_table_insert
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+38h]
		mov	eax, [eax+0Ch]
		test	eax, eax
		jz	loc_1000D7A6
		mov	[esp+48h+var_44], ebx
		mov	[esp+48h+var_48], edi
		call	eax
		jmp	loc_1000D7A6
; ---------------------------------------------------------------------------

loc_1000DAB1:				; CODE XREF: sub_1000D750+DEj
		mov	[esp+48h+var_40], offset aErrorParsingWe ; "error parsing welcome message for confe"...
		mov	[esp+48h+var_44], 10h
		mov	[esp+48h+var_48], offset aMeanwhile_6 ;	"meanwhile"
		call	g_log
		mov	[esp+48h+var_40], 0 ; char *
		mov	[esp+48h+var_44], 80000000h ; int
		mov	[esp+48h+var_48], edi ;	int
		call	mwConference_destroy
		jmp	loc_1000D7A6
; ---------------------------------------------------------------------------

loc_1000DAEA:				; CODE XREF: sub_1000D750+21Bj
		mov	[ebp+var_18], 0
		lea	eax, [ebp+var_18]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], esi
		call	mwString_get
		mov	[esp+48h+var_48], esi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_1000DC20
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+38h]
		mov	edx, [ebp+var_18]
		test	edx, edx
		jz	short loc_1000DB34
		mov	eax, [eax+14h]
		test	eax, eax
		jz	short loc_1000DB34
		mov	[esp+48h+var_40], edx
		mov	[esp+48h+var_44], ebx
		mov	[esp+48h+var_48], edi
		call	eax
		mov	edx, [ebp+var_18]

loc_1000DB34:				; CODE XREF: sub_1000D750+3CBj
					; sub_1000D750+3D2j
		mov	[esp+48h+var_48], edx
		call	g_free
		jmp	loc_1000D7A6
; ---------------------------------------------------------------------------

loc_1000DB41:				; CODE XREF: sub_1000D750+224j
		lea	eax, [ebp+var_1C]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], esi
		call	guint32_get
		lea	eax, [ebp+var_20]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], esi
		call	guint32_get
		mov	[esp+48h+var_48], esi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_1000D7A6
		mov	edx, [ebp+var_1C]
		cmp	edx, 1
		jz	short loc_1000DBC4
		mov	eax, [ebp+var_20]
		mov	[esp+48h+var_3C], edx
		mov	[esp+48h+var_40], offset aUnknownDataMes ; "unknown data message type (0x%08x, 0x%0"...
		mov	[esp+48h+var_44], 20h
		mov	[esp+48h+var_38], eax
		mov	[esp+48h+var_48], offset aMeanwhile_6 ;	"meanwhile"
		call	g_log
		jmp	loc_1000D7A6
; ---------------------------------------------------------------------------

loc_1000DBA3:				; CODE XREF: sub_1000D750+1Cj
		mov	[esp+48h+var_40], offset aConfNull ; "conf != NULL"
		mov	[esp+48h+var_44], offset aRecv_0 ; "recv"
		mov	[esp+48h+var_48], offset aMeanwhile_6 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000D7A6
; ---------------------------------------------------------------------------

loc_1000DBC4:				; CODE XREF: sub_1000D750+425j
		mov	ecx, [ebp+arg_0]
		mov	eax, [ecx+38h]
		mov	edx, [eax+18h]
		test	edx, edx
		jz	loc_1000D7A6
		xor	eax, eax
		cmp	[ebp+var_20], 0
		mov	[esp+48h+var_44], ebx
		mov	[esp+48h+var_48], edi
		setz	al
		mov	[esp+48h+var_40], eax
		call	edx
		jmp	loc_1000D7A6
; ---------------------------------------------------------------------------

loc_1000DBF0:				; CODE XREF: sub_1000D750+20Fj
		movzx	eax, [ebp+var_10]
		mov	[esp+48h+var_38], eax
		mov	eax, [ebp+var_14]
		mov	[esp+48h+var_40], offset aReceivedMessag ; "received message type 0x%04x from unkno"...
		mov	[esp+48h+var_44], 10h
		mov	[esp+48h+var_48], offset aMeanwhile_6 ;	"meanwhile"
		mov	[esp+48h+var_3C], eax
		call	g_log
		jmp	loc_1000D7A6
; ---------------------------------------------------------------------------

loc_1000DC20:				; CODE XREF: sub_1000D750+3BAj
		mov	[esp+48h+var_40], offset aFailedToParseT ; "failed to parse text message in confere"...
		mov	[esp+48h+var_44], 10h
		mov	[esp+48h+var_48], offset aMeanwhile_6 ;	"meanwhile"
		call	g_log
		mov	eax, [ebp+var_18]
		mov	[esp+48h+var_48], eax
		call	g_free
		jmp	loc_1000D7A6
sub_1000D750	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000DC50	proc near		; DATA XREF: mwServiceConference_new+51o

var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_20		= dword	ptr -20h
var_14		= byte ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 2Ch
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_10], 0
		lea	ebx, [ebp+var_14]
		call	sub_1000D580
		mov	edi, eax
		mov	eax, [ebp+arg_4]
		mov	[edi+8], eax
		mov	eax, [ebp+arg_8]
		add	eax, 30h
		mov	[esp+38h+var_38], eax
		call	mwGetBuffer_wrap
		mov	[esp+38h+var_34], ebx
		mov	esi, eax
		mov	[esp+38h+var_38], eax
		call	guint32_get
		lea	eax, [edi+0Ch]
		mov	[esp+38h+var_34], eax
		mov	[esp+38h+var_38], esi
		call	mwString_get
		lea	eax, [edi+10h]
		mov	[esp+38h+var_34], eax
		mov	[esp+38h+var_38], esi
		call	mwString_get
		mov	[esp+38h+var_34], ebx
		mov	[esp+38h+var_38], esi
		call	guint32_get
		lea	eax, [edi+14h]
		mov	[ebp+var_20], eax
		mov	[esp+38h+var_34], eax
		mov	[esp+38h+var_38], esi
		call	mwLoginInfo_get
		mov	[esp+38h+var_34], ebx
		mov	[esp+38h+var_38], esi
		call	guint32_get
		lea	eax, [ebp+var_10]
		mov	[esp+38h+var_34], eax
		mov	[esp+38h+var_38], esi
		call	mwString_get
		mov	[esp+38h+var_38], esi
		call	mwGetBuffer_error
		test	eax, eax
		jz	short loc_1000DD41
		mov	[esp+38h+var_30], offset aFailureParsing ; "failure parsing addtl for conference in"...
		mov	[esp+38h+var_34], 10h
		mov	[esp+38h+var_38], offset aMeanwhile_6 ;	"meanwhile"
		call	g_log
		mov	[esp+38h+var_30], 0 ; char *
		mov	[esp+38h+var_34], 80000000h ; int
		mov	[esp+38h+var_38], edi ;	int
		call	mwConference_destroy

loc_1000DD26:				; CODE XREF: sub_1000DC50+107j
					; sub_1000DC50+11Cj
		mov	[esp+38h+var_38], esi
		call	mwGetBuffer_free
		mov	eax, [ebp+var_10]
		mov	[esp+38h+var_38], eax
		call	g_free
		add	esp, 2Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000DD41:				; CODE XREF: sub_1000DC50+A0j
		mov	eax, [ebp+arg_0]
		mov	edx, 2
		mov	ebx, [eax+38h]
		mov	eax, edi
		call	sub_1000D170
		mov	edx, [ebx]
		test	edx, edx
		jz	short loc_1000DD26
		mov	eax, [ebp+var_10]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_30], eax
		mov	eax, [ebp+var_20]
		mov	[esp+38h+var_34], eax
		call	edx
		jmp	short loc_1000DD26
sub_1000DC50	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000DD70	proc near		; DATA XREF: mwServiceConference_new+4Ao

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebx+3Ch]
		test	eax, eax
		jz	short loc_1000DDA2

loc_1000DD81:				; CODE XREF: sub_1000DD70+30j
		mov	[esp+18h+var_10], 0 ; char *
		mov	[esp+18h+var_14], 0 ; int
		mov	eax, [eax]
		mov	[esp+18h+var_18], eax ;	int
		call	mwConference_destroy
		mov	eax, [ebx+3Ch]
		test	eax, eax
		jnz	short loc_1000DD81

loc_1000DDA2:				; CODE XREF: sub_1000DD70+Fj
		mov	[ebp+arg_0], ebx
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	mwService_stopped
sub_1000DD70	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000DDB0	proc near		; DATA XREF: mwServiceConference_new+43o
		push	ebp
		mov	ebp, esp
		pop	ebp
		jmp	mwService_started
sub_1000DDB0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000DDC0	proc near		; DATA XREF: mwServiceDirectory_new+47o
		push	ebp
		mov	eax, offset aAddressBookAnd ; "Address Book and	Directory"
		mov	ebp, esp
		pop	ebp
		retn
sub_1000DDC0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000DDD0	proc near		; DATA XREF: mwServiceDirectory_new+4Eo
		push	ebp
		mov	eax, offset aAddressBookDir ; "Address book directory service for user"...
		mov	ebp, esp
		pop	ebp
		retn
sub_1000DDD0	endp

; ---------------------------------------------------------------------------
		align 10h
		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	dword ptr [esp], 20h
		mov	[ebp-0Ch], ebx
		mov	[ebp-8], esi
		mov	esi, [ebp+8]
		mov	[ebp-4], edi
		mov	edi, [ebp+0Ch]
		call	g_malloc0
		mov	ebx, eax
		mov	eax, [esi]
		mov	[esp+8], ebx
		mov	[esp+4], edi
		mov	[ebx+4], esi
		mov	[ebx], eax
		mov	eax, [esi+0Ch]
		mov	[ebx+0Ch], edi
		mov	[esp], eax
		call	g_hash_table_insert
		mov	eax, ebx
		mov	esi, [ebp-8]
		mov	ebx, [ebp-0Ch]
		mov	edi, [ebp-4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000DE30	proc near		; CODE XREF: mwDirectory_previous+43p
					; mwDirectory_next+43p	...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	edx, [eax]
		mov	ebx, [edx+40h]
		add	ebx, 1
		mov	[edx+40h], ebx
		mov	[eax+10h], ebx
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+var_10], eax
		mov	eax, [edx+44h]
		mov	[esp+18h+var_18], eax
		call	g_hash_table_insert
		mov	eax, ebx
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
sub_1000DE30	endp

; ---------------------------------------------------------------------------
		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	edx, [ebp+8]
		mov	eax, [edx+8]
		mov	[esp+4], eax
		mov	eax, [edx]
		mov	eax, [eax+48h]
		mov	[esp], eax
		call	g_hash_table_remove
		leave
		retn
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 129. mwDirectory_getAddressBook

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwDirectory_getAddressBook
mwDirectory_getAddressBook proc	near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000DE92
		mov	eax, [eax+4]
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000DE92:				; CODE XREF: mwDirectory_getAddressBook+Bj
		mov	[esp+18h+var_10], offset aDirNull ; "dir != NULL"
		mov	[esp+18h+var_14], offset aMwdirectory_ge ; "mwDirectory_getAddressBook"
		mov	[esp+18h+var_18], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwDirectory_getAddressBook endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 131. mwDirectory_getService

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwDirectory_getService
mwDirectory_getService proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000DED8
		mov	eax, [eax+4]
		test	eax, eax
		jz	short loc_1000DEF8
		mov	eax, [eax]
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000DED8:				; CODE XREF: mwDirectory_getService+Bj
		mov	[esp+18h+var_10], offset aDirNull ; "dir != NULL"
		mov	[esp+18h+var_14], offset aMwdirectory__0 ; "mwDirectory_getService"
		mov	[esp+18h+var_18], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000DEF8:				; CODE XREF: mwDirectory_getService+12j
		mov	[esp+18h+var_10], offset aDirBookNull ;	"dir->book != NULL"
		mov	[esp+18h+var_14], offset aMwdirectory__0 ; "mwDirectory_getService"
		mov	[esp+18h+var_18], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwDirectory_getService endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 132. mwDirectory_getState

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwDirectory_getState
mwDirectory_getState proc near		; CODE XREF: mwDirectory_destroy+1Dp
					; mwDirectory_destroy+2Cp ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000DF32
		mov	eax, [eax+8]
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000DF32:				; CODE XREF: mwDirectory_getState+Bj
		mov	[esp+18h+var_10], offset aDirNull ; "dir != NULL"
		mov	[esp+18h+var_14], offset aMwdirectory__1 ; "mwDirectory_getState"
		mov	[esp+18h+var_18], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 4
		leave
		retn
mwDirectory_getState endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 133. mwDirectory_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwDirectory_new
mwDirectory_new	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_1000DF98
		mov	eax, [ebx]
		test	eax, eax
		jz	short loc_1000DFB8
		mov	[esp+18h+var_18], 20h
		call	g_malloc0
		mov	edx, eax
		mov	eax, [ebx]
		mov	[edx+4], ebx
		mov	dword ptr [edx+8], 0
		mov	[edx], eax

loc_1000DF90:				; CODE XREF: mwDirectory_new+56j
					; mwDirectory_new+76j
		add	esp, 14h
		mov	eax, edx
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000DF98:				; CODE XREF: mwDirectory_new+Cj
		mov	[esp+18h+var_10], offset aBookNull ; "book != NULL"
		mov	[esp+18h+var_14], offset aMwdirectory_ne ; "mwDirectory_new"
		mov	[esp+18h+var_18], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	edx, edx
		jmp	short loc_1000DF90
; ---------------------------------------------------------------------------

loc_1000DFB8:				; CODE XREF: mwDirectory_new+12j
		mov	[esp+18h+var_10], offset aBookServiceNul ; "book->service != NULL"
		mov	[esp+18h+var_14], offset aMwdirectory_ne ; "mwDirectory_new"
		mov	[esp+18h+var_18], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	edx, edx
		jmp	short loc_1000DF90
mwDirectory_new	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  13. mwAddressBook_getName

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAddressBook_getName
mwAddressBook_getName proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000DFF2
		mov	eax, [eax+8]
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000DFF2:				; CODE XREF: mwAddressBook_getName+Bj
		mov	[esp+18h+var_10], offset aBookNull ; "book != NULL"
		mov	[esp+18h+var_14], offset aMwaddressbook_ ; "mwAddressBook_getName"
		mov	[esp+18h+var_18], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwAddressBook_getName endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 273. mwServiceDirectory_getHandler

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceDirectory_getHandler
mwServiceDirectory_getHandler proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000E032
		mov	eax, [eax+38h]
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000E032:				; CODE XREF: mwServiceDirectory_getHandler+Bj
		mov	[esp+18h+var_10], offset aSrvcNull_3 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwservicedirec ; "mwServiceDirectory_getHandler"
		mov	[esp+18h+var_18], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwServiceDirectory_getHandler endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 128. mwDirectory_destroy

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwDirectory_destroy
mwDirectory_destroy proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= byte ptr -14h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_C], ebx
		mov	[ebp+var_4], edi
		test	esi, esi
		jz	loc_1000E134
		mov	[esp+28h+var_28], esi
		call	mwDirectory_getState
		cmp	eax, 2
		jz	short loc_1000E0C0
		mov	[esp+28h+var_28], esi
		xor	edi, edi
		call	mwDirectory_getState
		sub	eax, 1
		jz	short loc_1000E0C0

loc_1000E096:				; CODE XREF: mwDirectory_destroy+CFj
					; mwDirectory_destroy+11Bj ...
		mov	eax, [esi+0Ch]
		mov	[esp+28h+var_24], eax
		mov	eax, [esi+4]
		mov	eax, [eax+0Ch]
		mov	[esp+28h+var_28], eax
		call	g_hash_table_remove

loc_1000E0AB:				; CODE XREF: mwDirectory_destroy+F5j
		mov	eax, edi
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_1000E0C0:				; CODE XREF: mwDirectory_destroy+25j
					; mwDirectory_destroy+34j
		mov	eax, [esi]
		test	eax, eax
		jz	loc_1000E15A
		mov	edi, [eax+3Ch]
		test	edi, edi
		jz	loc_1000E180
		call	mwPutBuffer_new
		mov	ebx, eax
		mov	eax, [esi]
		mov	edx, [eax+40h]
		add	edx, 1
		mov	[eax+40h], edx
		mov	[esp+28h+var_24], edx
		mov	[esp+28h+var_28], ebx
		call	guint32_put
		mov	eax, [esi+0Ch]
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	guint32_put
		mov	[esp+28h+var_24], ebx
		lea	ebx, [ebp+var_14]
		mov	[esp+28h+var_28], ebx
		call	mwPutBuffer_finalize
		mov	[esp+28h+var_28], edi
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_24], 2
		call	mwChannel_send
		mov	[esp+28h+var_28], ebx
		mov	edi, eax
		call	mwOpaque_clear
		jmp	loc_1000E096
; ---------------------------------------------------------------------------

loc_1000E134:				; CODE XREF: mwDirectory_destroy+14j
		mov	[esp+28h+var_20], offset aDirNull ; "dir != NULL"
		mov	edi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwdirectory_de ; "mwDirectory_destroy"
		mov	[esp+28h+var_28], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000E0AB
; ---------------------------------------------------------------------------

loc_1000E15A:				; CODE XREF: mwDirectory_destroy+64j
		mov	[esp+28h+var_20], offset aSrvcNull_3 ; "srvc !=	NULL"
		mov	edi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aDir_close ; "dir_close"
		mov	[esp+28h+var_28], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000E096
; ---------------------------------------------------------------------------

loc_1000E180:				; CODE XREF: mwDirectory_destroy+6Fj
		mov	[esp+28h+var_20], offset aChanNull_5 ; "chan !=	NULL"
		mov	edi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aDir_close ; "dir_close"
		mov	[esp+28h+var_28], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000E096
mwDirectory_destroy endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 275. mwServiceDirectory_refreshAddressBooks

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceDirectory_refreshAddressBooks
mwServiceDirectory_refreshAddressBooks proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= byte ptr -14h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_C], ebx
		mov	[ebp+var_4], edi
		test	esi, esi
		jz	short loc_1000E225
		mov	edi, [esi+3Ch]
		test	edi, edi
		jz	short loc_1000E248
		call	mwPutBuffer_new
		mov	ebx, eax
		mov	eax, [esi+40h]
		add	eax, 1
		mov	[esi+40h], eax
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_28], ebx
		call	guint32_put
		mov	[esp+28h+var_24], ebx
		lea	ebx, [ebp+var_14]
		mov	[esp+28h+var_28], ebx
		call	mwPutBuffer_finalize
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_24], 0
		mov	[esp+28h+var_28], edi
		call	mwChannel_send
		mov	[esp+28h+var_28], ebx
		mov	esi, eax
		call	mwOpaque_clear

loc_1000E216:				; CODE XREF: mwServiceDirectory_refreshAddressBooks+96j
					; mwServiceDirectory_refreshAddressBooks+B9j
		mov	eax, esi
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000E225:				; CODE XREF: mwServiceDirectory_refreshAddressBooks+14j
		mov	[esp+28h+var_20], offset aSrvcNull_3 ; "srvc !=	NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwservicedir_0 ; "mwServiceDirectory_refreshAddressBooks"
		mov	[esp+28h+var_28], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000E216
; ---------------------------------------------------------------------------

loc_1000E248:				; CODE XREF: mwServiceDirectory_refreshAddressBooks+1Bj
		mov	[esp+28h+var_20], offset aChanNull_5 ; "chan !=	NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwservicedir_0 ; "mwServiceDirectory_refreshAddressBooks"
		mov	[esp+28h+var_28], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000E216
mwServiceDirectory_refreshAddressBooks endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 136. mwDirectory_previous

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwDirectory_previous
mwDirectory_previous proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= byte ptr -14h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	esi, [ebp+arg_0]
		test	esi, esi
		jz	loc_1000E32A
		mov	[esp+28h+var_28], esi
		call	mwDirectory_getState
		cmp	eax, 2
		jnz	loc_1000E34D
		mov	eax, [esi]
		test	eax, eax
		jz	loc_1000E370
		mov	edi, [eax+3Ch]
		test	edi, edi
		jz	loc_1000E393
		call	mwPutBuffer_new
		mov	ebx, eax
		mov	eax, esi
		call	sub_1000DE30
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	guint32_put
		mov	eax, [esi+0Ch]
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	guint32_put
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], 61h
		call	guint16_put
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], 1
		call	guint32_put
		mov	[esp+28h+var_24], ebx
		lea	ebx, [ebp+var_14]
		mov	[esp+28h+var_28], ebx
		call	mwPutBuffer_finalize
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_24], 3
		mov	[esp+28h+var_28], edi
		call	mwChannel_send
		mov	[esp+28h+var_28], ebx
		mov	esi, eax
		call	mwOpaque_clear

loc_1000E320:				; CODE XREF: mwDirectory_previous+DBj
					; mwDirectory_previous+FEj ...
		add	esp, 1Ch
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000E32A:				; CODE XREF: mwDirectory_previous+Ej
		mov	[esp+28h+var_20], offset aDirNull ; "dir != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwdirectory_pr ; "mwDirectory_previous"
		mov	[esp+28h+var_28], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000E320
; ---------------------------------------------------------------------------

loc_1000E34D:				; CODE XREF: mwDirectory_previous+1Fj
		mov	[esp+28h+var_20], offset aMw_directory_i ; "MW_DIRECTORY_IS_OPEN(dir)"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwdirectory_pr ; "mwDirectory_previous"
		mov	[esp+28h+var_28], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000E320
; ---------------------------------------------------------------------------

loc_1000E370:				; CODE XREF: mwDirectory_previous+29j
		mov	[esp+28h+var_20], offset aSrvcNull_3 ; "srvc !=	NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwdirectory_pr ; "mwDirectory_previous"
		mov	[esp+28h+var_28], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000E320
; ---------------------------------------------------------------------------

loc_1000E393:				; CODE XREF: mwDirectory_previous+34j
		mov	[esp+28h+var_20], offset aChanNull_5 ; "chan !=	NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwdirectory_pr ; "mwDirectory_previous"
		mov	[esp+28h+var_28], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000E320
mwDirectory_previous endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 134. mwDirectory_next

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwDirectory_next
mwDirectory_next proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= byte ptr -14h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	esi, [ebp+arg_0]
		test	esi, esi
		jz	loc_1000E47A
		mov	[esp+28h+var_28], esi
		call	mwDirectory_getState
		cmp	eax, 2
		jnz	loc_1000E49D
		mov	eax, [esi]
		test	eax, eax
		jz	loc_1000E4C0
		mov	edi, [eax+3Ch]
		test	edi, edi
		jz	loc_1000E4E3
		call	mwPutBuffer_new
		mov	ebx, eax
		mov	eax, esi
		call	sub_1000DE30
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	guint32_put
		mov	eax, [esi+0Ch]
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	guint32_put
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], 0FFFFh
		call	guint16_put
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], 0
		call	guint32_put
		mov	[esp+28h+var_24], ebx
		lea	ebx, [ebp+var_14]
		mov	[esp+28h+var_28], ebx
		call	mwPutBuffer_finalize
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_24], 3
		mov	[esp+28h+var_28], edi
		call	mwChannel_send
		mov	[esp+28h+var_28], ebx
		mov	esi, eax
		call	mwOpaque_clear

loc_1000E470:				; CODE XREF: mwDirectory_next+DBj
					; mwDirectory_next+FEj	...
		add	esp, 1Ch
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000E47A:				; CODE XREF: mwDirectory_next+Ej
		mov	[esp+28h+var_20], offset aDirNull ; "dir != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwdirectory__2 ; "mwDirectory_next"
		mov	[esp+28h+var_28], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000E470
; ---------------------------------------------------------------------------

loc_1000E49D:				; CODE XREF: mwDirectory_next+1Fj
		mov	[esp+28h+var_20], offset aMw_directory_i ; "MW_DIRECTORY_IS_OPEN(dir)"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwdirectory__2 ; "mwDirectory_next"
		mov	[esp+28h+var_28], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000E470
; ---------------------------------------------------------------------------

loc_1000E4C0:				; CODE XREF: mwDirectory_next+29j
		mov	[esp+28h+var_20], offset aSrvcNull_3 ; "srvc !=	NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwdirectory__2 ; "mwDirectory_next"
		mov	[esp+28h+var_28], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000E470
; ---------------------------------------------------------------------------

loc_1000E4E3:				; CODE XREF: mwDirectory_next+34j
		mov	[esp+28h+var_20], offset aChanNull_5 ; "chan !=	NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwdirectory__2 ; "mwDirectory_next"
		mov	[esp+28h+var_28], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000E470
mwDirectory_next endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 138. mwDirectory_search

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl mwDirectory_search(int, char *)
		public mwDirectory_search
mwDirectory_search proc	near

var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_20		= dword	ptr -20h
var_14		= byte ptr -14h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 2Ch
		mov	esi, [ebp+arg_0]
		mov	edi, [ebp+arg_4]
		test	esi, esi
		jz	loc_1000E5F3
		mov	[esp+38h+var_38], esi
		call	mwDirectory_getState
		cmp	eax, 2
		jnz	loc_1000E616
		test	edi, edi
		jz	loc_1000E639
		cmp	byte ptr [edi],	0
		jz	loc_1000E65C
		mov	eax, [esi]
		test	eax, eax
		lea	esi, [esi+0]
		jz	loc_1000E682
		mov	eax, [eax+3Ch]
		test	eax, eax
		mov	[ebp+var_20], eax
		jz	loc_1000E6A8
		call	mwPutBuffer_new
		mov	ebx, eax
		mov	eax, esi
		call	sub_1000DE30
		mov	[esp+38h+var_38], ebx
		mov	[esp+38h+var_34], eax
		call	guint32_put
		mov	eax, [esi+0Ch]
		mov	[esp+38h+var_38], ebx
		mov	[esp+38h+var_34], eax
		call	guint32_put
		mov	[esp+38h+var_38], ebx
		mov	[esp+38h+var_34], 61h
		call	guint16_put
		mov	[esp+38h+var_38], ebx
		mov	[esp+38h+var_34], 8
		call	guint32_put
		mov	[esp+38h+var_38], ebx ;	int
		mov	[esp+38h+var_34], edi ;	char *
		call	mwString_put
		mov	[esp+38h+var_34], ebx
		lea	ebx, [ebp+var_14]
		mov	[esp+38h+var_38], ebx
		call	mwPutBuffer_finalize
		mov	eax, [ebp+var_20]
		mov	[esp+38h+var_30], ebx
		mov	[esp+38h+var_34], 3
		mov	[esp+38h+var_38], eax
		call	mwChannel_send
		mov	[esp+38h+var_38], ebx
		mov	esi, eax
		call	mwOpaque_clear

loc_1000E5E9:				; CODE XREF: mwDirectory_search+104j
					; mwDirectory_search+127j ...
		add	esp, 2Ch
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000E5F3:				; CODE XREF: mwDirectory_search+11j
		mov	[esp+38h+var_30], offset aDirNull ; "dir != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+38h+var_34], offset aMwdirectory_se ; "mwDirectory_search"
		mov	[esp+38h+var_38], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000E5E9
; ---------------------------------------------------------------------------

loc_1000E616:				; CODE XREF: mwDirectory_search+22j
		mov	[esp+38h+var_30], offset aMw_directory_i ; "MW_DIRECTORY_IS_OPEN(dir)"
		mov	esi, 0FFFFFFFFh
		mov	[esp+38h+var_34], offset aMwdirectory_se ; "mwDirectory_search"
		mov	[esp+38h+var_38], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000E5E9
; ---------------------------------------------------------------------------

loc_1000E639:				; CODE XREF: mwDirectory_search+2Aj
		mov	[esp+38h+var_30], offset aQueryNull ; "query !=	NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+38h+var_34], offset aMwdirectory_se ; "mwDirectory_search"
		mov	[esp+38h+var_38], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000E5E9
; ---------------------------------------------------------------------------

loc_1000E65C:				; CODE XREF: mwDirectory_search+33j
		mov	[esp+38h+var_30], offset aQuery0 ; "*query != '\\0'"
		mov	esi, 0FFFFFFFFh
		mov	[esp+38h+var_34], offset aMwdirectory_se ; "mwDirectory_search"
		mov	[esp+38h+var_38], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000E5E9
; ---------------------------------------------------------------------------

loc_1000E682:				; CODE XREF: mwDirectory_search+40j
		mov	[esp+38h+var_30], offset aSrvcNull_3 ; "srvc !=	NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+38h+var_34], offset aMwdirectory_se ; "mwDirectory_search"
		mov	[esp+38h+var_38], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000E5E9
; ---------------------------------------------------------------------------

loc_1000E6A8:				; CODE XREF: mwDirectory_search+4Ej
		mov	[esp+38h+var_30], offset aChanNull_5 ; "chan !=	NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+38h+var_34], offset aMwdirectory_se ; "mwDirectory_search"
		mov	[esp+38h+var_38], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000E5E9
mwDirectory_search endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 135. mwDirectory_open

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwDirectory_open
mwDirectory_open proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= byte ptr -14h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	esi, [ebp+arg_0]
		mov	ebx, [ebp+arg_4]
		test	esi, esi
		jz	loc_1000E7B3
		test	ebx, ebx
		jz	loc_1000E7D6
		mov	[esp+28h+var_28], esi
		call	mwDirectory_getState
		test	eax, eax
		jnz	loc_1000E7F9
		mov	eax, [esi]
		mov	dword ptr [esi+8], 1
		mov	[esi+14h], ebx
		test	eax, eax
		jz	loc_1000E81C
		mov	edi, [eax+3Ch]
		test	edi, edi
		jz	loc_1000E842
		call	mwPutBuffer_new
		mov	ebx, eax
		mov	eax, esi
		call	sub_1000DE30
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	guint32_put
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], 0
		call	gboolean_put
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], 0
		call	guint16_put
		mov	eax, [esi+4]
		mov	eax, [eax+4]
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	guint32_put
		mov	eax, [esi+4]
		mov	eax, [eax+8]
		mov	[esp+28h+var_28], ebx ;	int
		mov	[esp+28h+var_24], eax ;	char *
		call	mwString_put
		mov	[esp+28h+var_24], ebx
		lea	ebx, [ebp+var_14]
		mov	[esp+28h+var_28], ebx
		call	mwPutBuffer_finalize
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_24], 1
		mov	[esp+28h+var_28], edi
		call	mwChannel_send
		mov	[esp+28h+var_28], ebx
		mov	esi, eax
		call	mwOpaque_clear

loc_1000E7A9:				; CODE XREF: mwDirectory_open+104j
					; mwDirectory_open+127j ...
		add	esp, 1Ch
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000E7B3:				; CODE XREF: mwDirectory_open+11j
		mov	[esp+28h+var_20], offset aDirNull ; "dir != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwdirectory_op ; "mwDirectory_open"
		mov	[esp+28h+var_28], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000E7A9
; ---------------------------------------------------------------------------

loc_1000E7D6:				; CODE XREF: mwDirectory_open+19j
		mov	[esp+28h+var_20], offset aCbNull ; "cb != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwdirectory_op ; "mwDirectory_open"
		mov	[esp+28h+var_28], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000E7A9
; ---------------------------------------------------------------------------

loc_1000E7F9:				; CODE XREF: mwDirectory_open+29j
		mov	[esp+28h+var_20], offset aMw_directory_0 ; "MW_DIRECTORY_IS_NEW(dir)"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwdirectory_op ; "mwDirectory_open"
		mov	[esp+28h+var_28], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000E7A9
; ---------------------------------------------------------------------------

loc_1000E81C:				; CODE XREF: mwDirectory_open+3Dj
		mov	[esp+28h+var_20], offset aSrvcNull_3 ; "srvc !=	NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aDir_open ; "dir_open"
		mov	[esp+28h+var_28], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000E7A9
; ---------------------------------------------------------------------------

loc_1000E842:				; CODE XREF: mwDirectory_open+48j
		mov	[esp+28h+var_20], offset aChanNull_5 ; "chan !=	NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aDir_open ; "dir_open"
		mov	[esp+28h+var_28], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000E7A9
mwDirectory_open endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 137. mwDirectory_removeClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwDirectory_removeClientData
mwDirectory_removeClientData proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000E889
		add	eax, 18h
		mov	[ebp+arg_0], eax
		leave
		jmp	mw_datum_clear
; ---------------------------------------------------------------------------

loc_1000E889:				; CODE XREF: mwDirectory_removeClientData+Bj
		mov	[esp+18h+var_10], offset aDirNull ; "dir != NULL"
		mov	[esp+18h+var_14], offset aMwdirectory_re ; "mwDirectory_removeClientData"
		mov	[esp+18h+var_18], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwDirectory_removeClientData endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 130. mwDirectory_getClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwDirectory_getClientData
mwDirectory_getClientData proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000E8C9
		add	eax, 18h
		mov	[ebp+arg_0], eax
		leave
		jmp	mw_datum_get
; ---------------------------------------------------------------------------

loc_1000E8C9:				; CODE XREF: mwDirectory_getClientData+Bj
		mov	[esp+18h+var_10], offset aDirNull ; "dir != NULL"
		mov	[esp+18h+var_14], offset aMwdirectory__3 ; "mwDirectory_getClientData"
		mov	[esp+18h+var_18], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwDirectory_getClientData endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 139. mwDirectory_setClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwDirectory_setClientData
mwDirectory_setClientData proc near

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	edx, [ebp+arg_8]
		test	eax, eax
		jz	short loc_1000E912
		add	eax, 18h
		mov	[ebp+arg_8], edx
		mov	[ebp+arg_4], ecx
		mov	[ebp+arg_0], eax
		pop	ebp
		jmp	mw_datum_set
; ---------------------------------------------------------------------------

loc_1000E912:				; CODE XREF: mwDirectory_setClientData+Ej
		mov	[ebp+arg_8], offset aDirNull ; "dir != NULL"
		mov	[ebp+arg_4], offset aMwdirectory__4 ; "mwDirectory_setClientData"
		mov	[ebp+arg_0], offset aMeanwhile_7 ; "meanwhile"
		pop	ebp
		jmp	g_return_if_fail_warning
mwDirectory_setClientData endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  12. mwAddressBook_getDirectories

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwAddressBook_getDirectories
mwAddressBook_getDirectories proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000E94D
		mov	eax, [eax+0Ch]
		test	eax, eax
		jz	short loc_1000E96D
		mov	[ebp+arg_0], eax
		leave
		jmp	map_collect_values
; ---------------------------------------------------------------------------

loc_1000E94D:				; CODE XREF: mwAddressBook_getDirectories+Bj
		mov	[esp+18h+var_10], offset aBookNull ; "book != NULL"
		mov	[esp+18h+var_14], offset aMwaddressboo_0 ; "mwAddressBook_getDirectories"
		mov	[esp+18h+var_18], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning

locret_1000E969:			; CODE XREF: mwAddressBook_getDirectories+59j
		leave
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1000E96D:				; CODE XREF: mwAddressBook_getDirectories+12j
		mov	[esp+18h+var_10], offset aBookDirsNull ; "book->dirs !=	NULL"
		mov	[esp+18h+var_14], offset aMwaddressboo_0 ; "mwAddressBook_getDirectories"
		mov	[esp+18h+var_18], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short locret_1000E969
mwAddressBook_getDirectories endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 271. mwServiceDirectory_getAddressBooks

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceDirectory_getAddressBooks
mwServiceDirectory_getAddressBooks proc	near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000E9AD
		mov	eax, [eax+48h]
		test	eax, eax
		jz	short loc_1000E9CD
		mov	[ebp+arg_0], eax
		leave
		jmp	map_collect_values
; ---------------------------------------------------------------------------

loc_1000E9AD:				; CODE XREF: mwServiceDirectory_getAddressBooks+Bj
		mov	[esp+18h+var_10], offset aSrvcNull_3 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwservicedir_1 ; "mwServiceDirectory_getAddressBooks"
		mov	[esp+18h+var_18], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning

locret_1000E9C9:			; CODE XREF: mwServiceDirectory_getAddressBooks+59j
		leave
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1000E9CD:				; CODE XREF: mwServiceDirectory_getAddressBooks+12j
		mov	[esp+18h+var_10], offset aSrvcBooksNull	; "srvc->books != NULL"
		mov	[esp+18h+var_14], offset aMwservicedir_1 ; "mwServiceDirectory_getAddressBooks"
		mov	[esp+18h+var_18], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short locret_1000E9C9
mwServiceDirectory_getAddressBooks endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 272. mwServiceDirectory_getDirectories

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceDirectory_getDirectories
mwServiceDirectory_getDirectories proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000EA4C
		mov	eax, [eax+48h]
		test	eax, eax
		jz	short loc_1000EA6C
		mov	[esp+18h+var_18], eax
		xor	esi, esi
		call	map_collect_values
		test	eax, eax
		mov	ebx, eax
		jz	short loc_1000EA43

loc_1000EA16:				; CODE XREF: mwServiceDirectory_getDirectories+51j
		mov	eax, [ebx]
		mov	eax, [eax+0Ch]
		mov	[esp+18h+var_18], eax
		call	map_collect_values
		mov	[esp+18h+var_18], esi
		mov	[esp+18h+var_14], eax
		call	g_list_concat
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+var_18], ebx
		mov	esi, eax
		call	g_list_delete_link
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_1000EA16

loc_1000EA43:				; CODE XREF: mwServiceDirectory_getDirectories+24j
					; mwServiceDirectory_getDirectories+7Aj ...
		add	esp, 10h
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000EA4C:				; CODE XREF: mwServiceDirectory_getDirectories+Dj
		mov	[esp+18h+var_10], offset aSrvcNull_3 ; "srvc !=	NULL"
		xor	esi, esi
		mov	[esp+18h+var_14], offset aMwservicedir_2 ; "mwServiceDirectory_getDirectories"
		mov	[esp+18h+var_18], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000EA43
; ---------------------------------------------------------------------------

loc_1000EA6C:				; CODE XREF: mwServiceDirectory_getDirectories+14j
		mov	[esp+18h+var_10], offset aSrvcBooksNull	; "srvc->books != NULL"
		xor	esi, esi
		mov	[esp+18h+var_14], offset aMwservicedir_2 ; "mwServiceDirectory_getDirectories"
		mov	[esp+18h+var_18], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000EA43
mwServiceDirectory_getDirectories endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 274. mwServiceDirectory_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceDirectory_new
mwServiceDirectory_new proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		test	esi, esi
		jz	loc_1000EB66
		test	edi, edi
		jz	loc_1000EB86
		mov	[esp+28h+var_28], 4Ch
		call	g_malloc0
		mov	[esp+28h+var_20], 1Ah
		mov	[esp+28h+var_24], esi
		mov	ebx, eax
		mov	[esp+28h+var_28], eax
		call	mwService_init
		mov	dword ptr [ebx+0Ch], offset sub_1000DDC0
		mov	dword ptr [ebx+10h], offset sub_1000DDD0
		mov	dword ptr [ebx+24h], offset sub_1000EFA0
		mov	dword ptr [ebx+28h], offset sub_1000EF60
		mov	dword ptr [ebx+2Ch], offset sub_1000EBB0
		mov	dword ptr [ebx+14h], offset sub_1000EF40
		mov	dword ptr [ebx+18h], offset sub_1000EEB0
		mov	dword ptr [ebx+1Ch], offset sub_1000EE90
		mov	dword ptr [ebx+20h], offset sub_1000EC50
		mov	[ebx+38h], edi
		mov	[esp+28h+var_24], offset loc_1001A918
		mov	[esp+28h+var_28], offset loc_1001A910
		call	g_hash_table_new
		mov	[ebx+44h], eax
		mov	[esp+28h+var_1C], offset sub_1000EBF0
		mov	[esp+28h+var_20], 0
		mov	[esp+28h+var_24], offset loc_1001A988
		mov	[esp+28h+var_28], offset g_str_hash
		call	g_hash_table_new_full
		mov	[ebx+48h], eax

loc_1000EB57:				; CODE XREF: mwServiceDirectory_new+F4j
					; mwServiceDirectory_new+114j
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000EB66:				; CODE XREF: mwServiceDirectory_new+17j
		mov	[esp+28h+var_20], offset aSessionNull_3	; "session != NULL"
		xor	ebx, ebx
		mov	[esp+28h+var_24], offset aMwservicedir_3 ; "mwServiceDirectory_new"
		mov	[esp+28h+var_28], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000EB57
; ---------------------------------------------------------------------------

loc_1000EB86:				; CODE XREF: mwServiceDirectory_new+1Fj
		mov	[esp+28h+var_20], offset aHandlerNull_2	; "handler != NULL"
		xor	ebx, ebx
		mov	[esp+28h+var_24], offset aMwservicedir_3 ; "mwServiceDirectory_new"
		mov	[esp+28h+var_28], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000EB57
mwServiceDirectory_new endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000EBB0	proc near		; DATA XREF: mwServiceDirectory_new+63o

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebx+48h]
		test	eax, eax
		jz	short loc_1000EBD0
		mov	[esp+8+var_8], eax
		call	g_hash_table_destroy
		mov	dword ptr [ebx+48h], 0

loc_1000EBD0:				; CODE XREF: sub_1000EBB0+Fj
		mov	eax, [ebx+38h]
		test	eax, eax
		jz	short loc_1000EBE3
		mov	eax, [eax+0Ch]
		test	eax, eax
		jz	short loc_1000EBE3
		mov	[esp+8+var_8], ebx
		call	eax

loc_1000EBE3:				; CODE XREF: sub_1000EBB0+25j
					; sub_1000EBB0+2Cj
		mov	dword ptr [ebx+38h], 0
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
sub_1000EBB0	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000EBF0	proc near		; DATA XREF: mwServiceDirectory_new+A0o

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebx+0Ch]
		mov	[esp+8+var_8], eax
		call	g_hash_table_destroy
		mov	eax, [ebx+8]
		mov	[ebp+arg_0], eax
		add	esp, 4
		pop	ebx
		pop	ebp
		jmp	g_free
sub_1000EBF0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000EC20	proc near		; DATA XREF: sub_1000EC50+154o

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebx+10h]
		mov	[esp+18h+var_14], eax
		mov	eax, [ebx]
		mov	eax, [eax+44h]
		mov	[esp+18h+var_18], eax
		call	g_hash_table_remove
		mov	[ebp+arg_0], ebx
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	g_free
sub_1000EC20	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000EC50	proc near		; DATA XREF: mwServiceDirectory_new+7Fo

var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_30		= dword	ptr -30h
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= byte ptr -18h
var_14		= byte ptr -14h
var_E		= word ptr -0Eh
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= word ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 3Ch
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		mov	ebx, [ebp+arg_C]
		movzx	eax, [ebp+arg_8]
		test	ecx, ecx
		jz	loc_1000EE05
		test	edx, edx
		jz	loc_1000EE26
		mov	ecx, [ebp+arg_0]
		cmp	[ecx+3Ch], edx
		jnz	loc_1000EE47
		test	ebx, ebx
		jz	loc_1000EE68
		test	ax, ax
		lea	esi, [esi+0]
		jz	short loc_1000ECB7
		cmp	ax, 3
		jbe	short loc_1000ECAF
		movzx	eax, ax
		mov	[esp+48h+var_40], eax
		mov	[esp+48h+var_44], offset aMsgType0x04xIn ; "msg	type 0x%04x in directory service"
		mov	[esp+48h+var_48], ebx
		call	mw_mailme_opaque

loc_1000ECAF:				; CODE XREF: sub_1000EC50+46j
					; sub_1000EC50+F9j ...
		add	esp, 3Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000ECB7:				; CODE XREF: sub_1000EC50+40j
		mov	[esp+48h+var_48], ebx
		call	mwGetBuffer_wrap
		mov	edi, eax
		lea	eax, [ebp+var_14]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], edi
		call	guint32_get
		lea	eax, [ebp+var_18]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], edi
		call	guint32_get
		lea	eax, [ebp+var_1C]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], edi
		call	guint32_get
		lea	eax, [ebp+var_20]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], edi
		call	gboolean_get
		lea	eax, [ebp+var_E]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], edi
		call	guint16_get
		mov	edx, [ebp+var_20]
		test	edx, edx
		jnz	short loc_1000ED1E
		cmp	[ebp+var_E], 0
		jz	loc_1000EDEF

loc_1000ED1E:				; CODE XREF: sub_1000EC50+C1j
		mov	[esp+48h+var_48], ebx
		mov	[esp+48h+var_44], offset aReceivedStrang ; "received strange address book list"
		call	mw_mailme_opaque
		mov	[esp+48h+var_48], edi
		call	mwGetBuffer_free
		add	esp, 3Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_1000ED40:				; CODE XREF: sub_1000EC50+1A9j
		mov	eax, [ebp+var_1C]
		sub	eax, 1
		cmp	eax, 0FFFFFFFFh
		jz	loc_1000ECAF
		mov	[ebp+var_1C], eax
		lea	eax, [ebp+var_24]
		mov	[ebp+var_28], 0
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], edi
		call	guint32_get
		lea	edx, [ebp+var_28]
		mov	[esp+48h+var_44], edx
		mov	[esp+48h+var_48], edi
		call	mwString_get
		mov	ecx, [ebp+var_28]
		mov	esi, [ebp+var_24]
		mov	[ebp+var_30], ecx
		mov	[esp+48h+var_48], 10h
		call	g_malloc0
		mov	edx, [ebp+var_30]
		mov	ebx, eax
		mov	eax, [ebp+arg_0]
		mov	[ebx+4], esi
		mov	[ebx], eax
		mov	[esp+48h+var_48], edx
		call	g_strdup
		mov	[ebx+8], eax
		mov	[esp+48h+var_3C], offset sub_1000EC20
		mov	[esp+48h+var_40], 0
		mov	[esp+48h+var_44], offset loc_1001A918
		mov	[esp+48h+var_48], offset loc_1001A910
		call	g_hash_table_new_full
		mov	[ebx+0Ch], eax
		mov	[esp+48h+var_40], ebx
		mov	eax, [ebx+8]
		mov	[esp+48h+var_44], eax
		mov	ecx, [ebp+arg_0]
		mov	eax, [ecx+48h]
		mov	[esp+48h+var_48], eax
		call	g_hash_table_insert
		mov	eax, [ebp+var_28]
		mov	[esp+48h+var_48], eax
		call	g_free

loc_1000EDEF:				; CODE XREF: sub_1000EC50+C8j
		mov	[esp+48h+var_48], edi
		call	mwGetBuffer_error
		test	eax, eax
		jz	loc_1000ED40
		nop
		jmp	loc_1000ECAF
; ---------------------------------------------------------------------------

loc_1000EE05:				; CODE XREF: sub_1000EC50+18j
		mov	[esp+48h+var_40], offset aSrvcNull_3 ; "srvc !=	NULL"
		mov	[esp+48h+var_44], offset aRecv_1 ; "recv"
		mov	[esp+48h+var_48], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000ECAF
; ---------------------------------------------------------------------------

loc_1000EE26:				; CODE XREF: sub_1000EC50+20j
		mov	[esp+48h+var_40], offset aChanNull_5 ; "chan !=	NULL"
		mov	[esp+48h+var_44], offset aRecv_1 ; "recv"
		mov	[esp+48h+var_48], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000ECAF
; ---------------------------------------------------------------------------

loc_1000EE47:				; CODE XREF: sub_1000EC50+2Cj
		mov	[esp+48h+var_40], offset aChanSrvcChanne ; "chan == srvc->channel"
		mov	[esp+48h+var_44], offset aRecv_1 ; "recv"
		mov	[esp+48h+var_48], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000ECAF
; ---------------------------------------------------------------------------

loc_1000EE68:				; CODE XREF: sub_1000EC50+34j
		mov	[esp+48h+var_40], offset aDataNull_3 ; "data !=	NULL"
		mov	[esp+48h+var_44], offset aRecv_1 ; "recv"
		mov	[esp+48h+var_48], offset aMeanwhile_7 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000ECAF
sub_1000EC50	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000EE90	proc near		; DATA XREF: mwServiceDirectory_new+78o

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	dword ptr [eax+3Ch], 0
		pop	ebp
		jmp	mwService_stop
sub_1000EE90	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000EEB0	proc near		; DATA XREF: mwServiceDirectory_new+71o

var_18		= dword	ptr -18h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		mov	eax, [ebp+arg_4]
		mov	ebx, [esi+3Ch]
		test	ebx, ebx
		jz	short loc_1000EF11
		cmp	ebx, eax
		jnz	short loc_1000EF34
		mov	[esp+18h+var_18], esi
		call	mwService_getState
		cmp	eax, 3
		jz	short loc_1000EF00
		mov	[ebp+arg_0], ebx
		mov	esi, [ebp+var_4]
		mov	[ebp+arg_8], 0
		mov	ebx, [ebp+var_8]
		mov	[ebp+arg_4], 80000000h
		mov	esp, ebp
		pop	ebp
		jmp	mwChannel_destroy
; ---------------------------------------------------------------------------
		align 10h

loc_1000EF00:				; CODE XREF: sub_1000EEB0+28j
		mov	[ebp+arg_0], esi
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	mwService_started
; ---------------------------------------------------------------------------

loc_1000EF11:				; CODE XREF: sub_1000EEB0+17j
		mov	[ebp+arg_8], offset aSrvcChannelN_0 ; "srvc->channel !=	NULL"

loc_1000EF18:				; CODE XREF: sub_1000EEB0+8Bj
		mov	[ebp+arg_4], offset aRecv_accept_0 ; "recv_accept"
		mov	ebx, [ebp+var_8]
		mov	[ebp+arg_0], offset aMeanwhile_7 ; "meanwhile"
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_1000EF34:				; CODE XREF: sub_1000EEB0+1Bj
		mov	[ebp+arg_8], offset aSrvcChannelC_0 ; "srvc->channel ==	chan"
		jmp	short loc_1000EF18
sub_1000EEB0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000EF40	proc near		; DATA XREF: mwServiceDirectory_new+6Ao

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		mov	[ebp+arg_8], 0
		mov	[ebp+arg_4], 80000000h
		mov	[ebp+arg_0], eax
		pop	ebp
		jmp	mwChannel_destroy
sub_1000EF40	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000EF60	proc near		; DATA XREF: mwServiceDirectory_new+5Co

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebx+3Ch]
		test	eax, eax
		jz	short loc_1000EF90
		mov	[esp+18h+var_10], 0
		mov	[esp+18h+var_14], 0
		mov	[esp+18h+var_18], eax
		call	mwChannel_destroy
		mov	dword ptr [ebx+3Ch], 0

loc_1000EF90:				; CODE XREF: sub_1000EF60+Fj
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
sub_1000EF60	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000EFA0	proc near		; DATA XREF: mwServiceDirectory_new+55o

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_0]
		mov	[esp+18h+var_18], esi
		call	mwService_getSession
		mov	[esp+18h+var_18], eax
		call	mwSession_getChannels
		mov	[esp+18h+var_18], eax
		call	mwChannel_newOutgoing
		mov	[esp+18h+var_14], esi
		mov	ebx, eax
		mov	[esp+18h+var_18], eax
		call	mwChannel_setService
		mov	[esp+18h+var_14], 1Ch
		mov	[esp+18h+var_18], ebx
		call	mwChannel_setProtoType
		mov	[esp+18h+var_14], 5
		mov	[esp+18h+var_18], ebx
		call	mwChannel_setProtoVer
		mov	[esp+18h+var_18], ebx
		call	mwChannel_create
		test	eax, eax
		jnz	short loc_1000F010
		test	ebx, ebx
		nop
		jz	short loc_1000F010
		mov	[esi+3Ch], ebx
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_1000F010:				; CODE XREF: sub_1000EFA0+5Bj
					; sub_1000EFA0+60j
		mov	[ebp+arg_0], esi
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	mwService_stopped
sub_1000EFA0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000F020	proc near		; DATA XREF: mwServiceFileTransfer_new+5Fo

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebx+38h]
		test	eax, eax
		jz	short loc_1000F03D
		mov	eax, [eax+14h]
		test	eax, eax
		jz	short loc_1000F03D
		mov	[esp+8+var_8], ebx
		call	eax

loc_1000F03D:				; CODE XREF: sub_1000F020+Fj
					; sub_1000F020+16j
		mov	dword ptr [ebx+38h], 0
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
sub_1000F020	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000F050	proc near		; DATA XREF: mwServiceFileTransfer_new+66o
		push	ebp
		mov	eax, offset aFileTransfer ; "File Transfer"
		mov	ebp, esp
		pop	ebp
		retn
sub_1000F050	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000F060	proc near		; DATA XREF: mwServiceFileTransfer_new+6Do
		push	ebp
		mov	eax, offset aProvidesFileTr ; "Provides	file transfer capabilities thr"...
		mov	ebp, esp
		pop	ebp
		retn
sub_1000F060	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 155. mwFileTransfer_getRemaining

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwFileTransfer_getRemaining
mwFileTransfer_getRemaining proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000F082
		mov	eax, [eax+20h]
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000F082:				; CODE XREF: mwFileTransfer_getRemaining+Bj
		mov	[esp+18h+var_10], offset aFtNull ; "ft != NULL"
		mov	[esp+18h+var_14], offset aMwfiletransfer ; "mwFileTransfer_getRemaining"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwFileTransfer_getRemaining endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 153. mwFileTransfer_getFileSize

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwFileTransfer_getFileSize
mwFileTransfer_getFileSize proc	near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000F0C2
		mov	eax, [eax+1Ch]
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000F0C2:				; CODE XREF: mwFileTransfer_getFileSize+Bj
		mov	[esp+18h+var_10], offset aFtNull ; "ft != NULL"
		mov	[esp+18h+var_14], offset aMwfiletransf_0 ; "mwFileTransfer_getFileSize"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwFileTransfer_getFileSize endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 152. mwFileTransfer_getFileName

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwFileTransfer_getFileName
mwFileTransfer_getFileName proc	near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000F102
		mov	eax, [eax+14h]
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000F102:				; CODE XREF: mwFileTransfer_getFileName+Bj
		mov	[esp+18h+var_10], offset aFtNull ; "ft != NULL"
		mov	[esp+18h+var_14], offset aMwfiletransf_1 ; "mwFileTransfer_getFileName"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwFileTransfer_getFileName endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 154. mwFileTransfer_getMessage

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwFileTransfer_getMessage
mwFileTransfer_getMessage proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000F142
		mov	eax, [eax+18h]
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000F142:				; CODE XREF: mwFileTransfer_getMessage+Bj
		mov	[esp+18h+var_10], offset aFtNull ; "ft != NULL"
		mov	[esp+18h+var_14], offset aMwfiletransf_2 ; "mwFileTransfer_getMessage"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwFileTransfer_getMessage endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 158. mwFileTransfer_getUser

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwFileTransfer_getUser
mwFileTransfer_getUser proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000F182
		leave
		add	eax, 8
		retn
; ---------------------------------------------------------------------------

loc_1000F182:				; CODE XREF: mwFileTransfer_getUser+Bj
		mov	[esp+18h+var_10], offset aFtNull ; "ft != NULL"
		mov	[esp+18h+var_14], offset aMwfiletransf_3 ; "mwFileTransfer_getUser"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwFileTransfer_getUser endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 157. mwFileTransfer_getState

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwFileTransfer_getState
mwFileTransfer_getState	proc near	; CODE XREF: mwFileTransfer_send+1Cp
					; mwFileTransfer_close+1Cp ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000F1C2
		mov	eax, [eax+10h]
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000F1C2:				; CODE XREF: mwFileTransfer_getState+Bj
		mov	[esp+18h+var_10], offset aFtNull ; "ft != NULL"
		mov	[esp+18h+var_14], offset aMwfiletransf_4 ; "mwFileTransfer_getState"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 7
		leave
		retn
mwFileTransfer_getState	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 156. mwFileTransfer_getService

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwFileTransfer_getService
mwFileTransfer_getService proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000F201
		mov	eax, [eax]
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000F201:				; CODE XREF: mwFileTransfer_getService+Bj
		mov	[esp+18h+var_10], offset aFtNull ; "ft != NULL"
		mov	[esp+18h+var_14], offset aMwfiletransf_5 ; "mwFileTransfer_getService"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwFileTransfer_getService endp

; ---------------------------------------------------------------------------
		jmp	short mwServiceFileTransfer_getTransfers
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 277. mwServiceFileTransfer_getTransfers

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceFileTransfer_getTransfers
mwServiceFileTransfer_getTransfers proc	near ; CODE XREF: .text:1000F221j

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000F242
		mov	eax, [eax+3Ch]
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000F242:				; CODE XREF: mwServiceFileTransfer_getTransfers+Bj
		mov	[esp+18h+var_10], offset aSrvcNull_4 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwservicefilet ; "mwServiceFileTransfer_getTransfers"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwServiceFileTransfer_getTransfers endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 276. mwServiceFileTransfer_getHandler

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceFileTransfer_getHandler
mwServiceFileTransfer_getHandler proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000F282
		mov	eax, [eax+38h]
		leave
		retn
; ---------------------------------------------------------------------------

loc_1000F282:				; CODE XREF: mwServiceFileTransfer_getHandler+Bj
		mov	[esp+18h+var_10], offset aSrvcNull_4 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwservicefil_0 ; "mwServiceFileTransfer_getHandler"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwServiceFileTransfer_getHandler endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 161. mwFileTransfer_removeClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwFileTransfer_removeClientData
mwFileTransfer_removeClientData	proc near ; CODE XREF: mwFileTransfer_free+50p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000F2C9
		add	eax, 24h
		mov	[ebp+arg_0], eax
		leave
		jmp	mw_datum_clear
; ---------------------------------------------------------------------------

loc_1000F2C9:				; CODE XREF: mwFileTransfer_removeClientData+Bj
		mov	[esp+18h+var_10], offset aFtNull ; "ft != NULL"
		mov	[esp+18h+var_14], offset aMwfiletransf_6 ; "mwFileTransfer_removeClientData"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwFileTransfer_removeClientData	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 151. mwFileTransfer_getClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwFileTransfer_getClientData
mwFileTransfer_getClientData proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000F309
		add	eax, 24h
		mov	[ebp+arg_0], eax
		leave
		jmp	mw_datum_get
; ---------------------------------------------------------------------------

loc_1000F309:				; CODE XREF: mwFileTransfer_getClientData+Bj
		mov	[esp+18h+var_10], offset aFtNull ; "ft != NULL"
		mov	[esp+18h+var_14], offset aMwfiletransf_7 ; "mwFileTransfer_getClientData"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwFileTransfer_getClientData endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 163. mwFileTransfer_setClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwFileTransfer_setClientData
mwFileTransfer_setClientData proc near

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	edx, [ebp+arg_8]
		test	eax, eax
		jz	short loc_1000F352
		add	eax, 24h
		mov	[ebp+arg_8], edx
		mov	[ebp+arg_4], ecx
		mov	[ebp+arg_0], eax
		pop	ebp
		jmp	mw_datum_set
; ---------------------------------------------------------------------------

loc_1000F352:				; CODE XREF: mwFileTransfer_setClientData+Ej
		mov	[ebp+arg_8], offset aFtNull ; "ft != NULL"
		mov	[ebp+arg_4], offset aMwfiletransf_8 ; "mwFileTransfer_setClientData"
		mov	[ebp+arg_0], offset aMeanwhile_8 ; "meanwhile"
		pop	ebp
		jmp	g_return_if_fail_warning
mwFileTransfer_setClientData endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 148. mwFileTransfer_ack

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwFileTransfer_ack
mwFileTransfer_ack proc	near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1000F3B7
		mov	ebx, [eax+4]
		test	ebx, ebx
		jz	short loc_1000F3DA
		mov	[esp+18h+var_18], ebx
		call	mwChannel_getId
		test	eax, eax
		jns	short loc_1000F3FD
		mov	[esp+18h+var_C], 0
		mov	[esp+18h+var_10], 0
		mov	[esp+18h+var_14], 2
		mov	[esp+18h+var_18], ebx
		call	mwChannel_sendEncrypted

loc_1000F3B1:				; CODE XREF: mwFileTransfer_ack+68j
					; mwFileTransfer_ack+8Bj ...
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000F3B7:				; CODE XREF: mwFileTransfer_ack+Cj
		mov	[esp+18h+var_10], offset aFtNull ; "ft != NULL"
		mov	[esp+18h+var_14], offset aMwfiletransf_9 ; "mwFileTransfer_ack"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFFFFFh
		jmp	short loc_1000F3B1
; ---------------------------------------------------------------------------

loc_1000F3DA:				; CODE XREF: mwFileTransfer_ack+13j
		mov	[esp+18h+var_10], offset aChanNull_6 ; "chan !=	NULL"
		mov	[esp+18h+var_14], offset aMwfiletransf_9 ; "mwFileTransfer_ack"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFFFFFh
		jmp	short loc_1000F3B1
; ---------------------------------------------------------------------------

loc_1000F3FD:				; CODE XREF: mwFileTransfer_ack+1Fj
		mov	[esp+18h+var_10], offset aMwchannel_is_0 ; "mwChannel_isIncoming(chan)"
		mov	[esp+18h+var_14], offset aMwfiletransf_9 ; "mwFileTransfer_ack"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFFFFFh
		jmp	short loc_1000F3B1
mwFileTransfer_ack endp

; Exported entry 162. mwFileTransfer_send

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwFileTransfer_send
mwFileTransfer_send proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		test	esi, esi
		jz	short loc_1000F4A1
		mov	[esp+18h+var_18], esi
		call	mwFileTransfer_getState
		cmp	eax, 2
		jnz	short loc_1000F4C4
		mov	ebx, [esi+4]
		test	ebx, ebx
		jz	loc_1000F4E7
		mov	[esp+18h+var_18], ebx
		call	mwChannel_getId
		test	eax, eax
		js	loc_1000F50D
		mov	eax, [edi]
		mov	edx, 0FFFFFFFFh
		cmp	eax, [esi+20h]
		jbe	short loc_1000F480

loc_1000F46D:				; CODE XREF: mwFileTransfer_send+78j
					; mwFileTransfer_send+7Fj ...
		mov	ebx, [ebp+var_C]
		mov	eax, edx
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_1000F480:				; CODE XREF: mwFileTransfer_send+4Bj
		mov	[esp+18h+var_10], edi
		mov	[esp+18h+var_14], 1
		mov	[esp+18h+var_18], ebx
		call	mwChannel_send
		test	eax, eax
		mov	edx, eax
		jnz	short loc_1000F46D
		mov	eax, [edi]
		sub	[esi+20h], eax
		jmp	short loc_1000F46D
; ---------------------------------------------------------------------------

loc_1000F4A1:				; CODE XREF: mwFileTransfer_send+17j
		mov	[esp+18h+var_10], offset aFtNull ; "ft != NULL"
		mov	[esp+18h+var_14], offset aMwfiletrans_10 ; "mwFileTransfer_send"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	edx, 0FFFFFFFFh
		jmp	short loc_1000F46D
; ---------------------------------------------------------------------------

loc_1000F4C4:				; CODE XREF: mwFileTransfer_send+24j
		mov	[esp+18h+var_10], offset aMwfiletrans_11 ; "mwFileTransfer_isOpen(ft)"
		mov	[esp+18h+var_14], offset aMwfiletrans_10 ; "mwFileTransfer_send"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	edx, 0FFFFFFFFh
		jmp	short loc_1000F46D
; ---------------------------------------------------------------------------

loc_1000F4E7:				; CODE XREF: mwFileTransfer_send+2Bj
		mov	[esp+18h+var_10], offset aFtChannelNull	; "ft->channel != NULL"
		mov	[esp+18h+var_14], offset aMwfiletrans_10 ; "mwFileTransfer_send"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	edx, 0FFFFFFFFh
		jmp	loc_1000F46D
; ---------------------------------------------------------------------------

loc_1000F50D:				; CODE XREF: mwFileTransfer_send+3Bj
		mov	[esp+18h+var_10], offset aMwchannel_is_1 ; "mwChannel_isOutgoing(chan)"
		mov	[esp+18h+var_14], offset aMwfiletrans_10 ; "mwFileTransfer_send"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	edx, 0FFFFFFFFh
		jmp	loc_1000F46D
mwFileTransfer_send endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 150. mwFileTransfer_free

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwFileTransfer_free
mwFileTransfer_free proc near		; CODE XREF: sub_1000FDC0+16p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_1000F5C4
		mov	esi, [ebx]
		test	esi, esi
		jz	short loc_1000F567
		mov	[esp+18h+var_14], ebx
		mov	eax, [esi+3Ch]
		mov	[esp+18h+var_18], eax
		call	g_list_remove
		mov	[esi+3Ch], eax

loc_1000F567:				; CODE XREF: mwFileTransfer_free+13j
		mov	eax, [ebx+4]
		test	eax, eax
		jz	short loc_1000F58D
		mov	[esp+18h+var_10], 0
		mov	[esp+18h+var_14], 0
		mov	[esp+18h+var_18], eax
		call	mwChannel_destroy
		mov	dword ptr [ebx+4], 0

loc_1000F58D:				; CODE XREF: mwFileTransfer_free+2Cj
		mov	[esp+18h+var_18], ebx
		call	mwFileTransfer_removeClientData
		lea	eax, [ebx+8]
		mov	[esp+18h+var_18], eax
		call	mwIdBlock_clear
		mov	eax, [ebx+14h]
		mov	[esp+18h+var_18], eax
		call	g_free
		mov	eax, [ebx+18h]
		mov	[esp+18h+var_18], eax
		call	g_free
		mov	[ebp+arg_0], ebx
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	g_free
; ---------------------------------------------------------------------------

loc_1000F5C4:				; CODE XREF: mwFileTransfer_free+Dj
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
mwFileTransfer_free endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000F5D0	proc near		; CODE XREF: mwFileTransfer_close+7Fp
					; mwFileTransfer_offer+184p ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		test	eax, eax
		mov	[ebp+var_C], ebx
		mov	ebx, eax
		mov	[ebp+var_8], esi
		mov	esi, edx
		mov	[ebp+var_4], edi
		jz	loc_1000F682
		cmp	[eax+10h], edx
		jz	short loc_1000F63A
		cmp	edx, 6		; switch 7 cases
		mov	edi, offset aUnknown_2 ; "UNKNOWN"
		jbe	short loc_1000F647

loc_1000F5FA:				; CODE XREF: sub_1000F5D0+83j
					; sub_1000F5D0+8Aj ...
		mov	eax, [ebx+0Ch]	; jumptable 1000F647 default case
		mov	ecx, offset aNull_4 ; "(null)"
		mov	edx, [ebx+8]
		mov	[esp+28h+var_14], edi
		mov	[esp+28h+var_20], offset aSettingFtSSSta ; "setting ft (%s, %s)	state: %s"
		test	eax, eax
		cmovz	eax, ecx
		test	edx, edx
		cmovz	edx, ecx
		mov	[esp+28h+var_18], eax
		mov	[esp+28h+var_1C], edx
		mov	[esp+28h+var_24], 40h
		mov	[esp+28h+var_28], offset aMeanwhile_8 ;	"meanwhile"
		call	g_log
		mov	[ebx+10h], esi

loc_1000F63A:				; CODE XREF: sub_1000F5D0+1Ej
					; sub_1000F5D0+CEj
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000F647:				; CODE XREF: sub_1000F5D0+28j
		jmp	ds:off_1001F054[edx*4] ; switch	jump
; ---------------------------------------------------------------------------

loc_1000F64E:				; CODE XREF: sub_1000F5D0:loc_1000F647j
					; DATA XREF: .rdata:off_1001F054o
		mov	edi, offset aError_1 ; jumptable 1000F647 case 6
		jmp	short loc_1000F5FA ; jumptable 1000F647	default	case
; ---------------------------------------------------------------------------

loc_1000F655:				; CODE XREF: sub_1000F5D0:loc_1000F647j
					; DATA XREF: .rdata:off_1001F054o
		mov	edi, offset aDone ; jumptable 1000F647 case 5
		jmp	short loc_1000F5FA ; jumptable 1000F647	default	case
; ---------------------------------------------------------------------------

loc_1000F65C:				; CODE XREF: sub_1000F5D0:loc_1000F647j
					; DATA XREF: .rdata:off_1001F054o
		mov	edi, offset aCancelledRemot ; jumptable	1000F647 case 4
		jmp	short loc_1000F5FA ; jumptable 1000F647	default	case
; ---------------------------------------------------------------------------

loc_1000F663:				; CODE XREF: sub_1000F5D0:loc_1000F647j
					; DATA XREF: .rdata:off_1001F054o
		mov	edi, offset aCancelledLocal ; jumptable	1000F647 case 3
		jmp	short loc_1000F5FA ; jumptable 1000F647	default	case
; ---------------------------------------------------------------------------

loc_1000F66A:				; CODE XREF: sub_1000F5D0:loc_1000F647j
					; DATA XREF: .rdata:off_1001F054o
		mov	edi, offset aOpen_1 ; jumptable	1000F647 case 2
		jmp	short loc_1000F5FA ; jumptable 1000F647	default	case
; ---------------------------------------------------------------------------

loc_1000F671:				; CODE XREF: sub_1000F5D0:loc_1000F647j
					; DATA XREF: .rdata:off_1001F054o
		mov	edi, offset aPending_0 ; jumptable 1000F647 case 1
		jmp	short loc_1000F5FA ; jumptable 1000F647	default	case
; ---------------------------------------------------------------------------

loc_1000F678:				; CODE XREF: sub_1000F5D0:loc_1000F647j
					; DATA XREF: .rdata:off_1001F054o
		mov	edi, offset aNew_1 ; jumptable 1000F647	case 0
		jmp	loc_1000F5FA	; jumptable 1000F647 default case
; ---------------------------------------------------------------------------

loc_1000F682:				; CODE XREF: sub_1000F5D0+15j
		mov	[esp+28h+var_20], offset aFtNull ; "ft != NULL"
		mov	[esp+28h+var_24], offset aFt_state ; "ft_state"
		mov	[esp+28h+var_28], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000F63A
sub_1000F5D0	endp

; Exported entry 149. mwFileTransfer_close

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwFileTransfer_close
mwFileTransfer_close proc near		; CODE XREF: mwFileTransfer_offer+1B1p
					; mwFileTransfer_accept+ABp ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_C], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_4]
		mov	[ebp+var_8], esi
		test	ebx, ebx
		jz	short loc_1000F726
		mov	[esp+18h+var_18], ebx
		call	mwFileTransfer_getState
		cmp	eax, 2
		jz	short loc_1000F718

loc_1000F6C6:				; CODE XREF: mwFileTransfer_close+84j
		mov	eax, [ebx+4]
		xor	esi, esi
		test	eax, eax
		jz	short loc_1000F6EC
		mov	[esp+18h+var_10], 0
		mov	[esp+18h+var_14], edi
		mov	[esp+18h+var_18], eax
		call	mwChannel_destroy
		mov	dword ptr [ebx+4], 0
		mov	esi, eax

loc_1000F6EC:				; CODE XREF: mwFileTransfer_close+2Dj
		mov	eax, [ebx]
		test	eax, eax
		jz	short loc_1000F749
		mov	eax, [eax+38h]
		test	eax, eax
		jz	short loc_1000F767
		mov	eax, [eax+8]
		test	eax, eax
		jz	short loc_1000F709
		mov	[esp+18h+var_14], edi
		mov	[esp+18h+var_18], ebx
		call	eax

loc_1000F709:				; CODE XREF: mwFileTransfer_close+5Ej
					; mwFileTransfer_close+A7j ...
		mov	eax, esi
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000F718:				; CODE XREF: mwFileTransfer_close+24j
		mov	edx, 3
		mov	eax, ebx
		call	sub_1000F5D0
		jmp	short loc_1000F6C6
; ---------------------------------------------------------------------------

loc_1000F726:				; CODE XREF: mwFileTransfer_close+17j
		mov	[esp+18h+var_10], offset aFtNull ; "ft != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+18h+var_14], offset aMwfiletrans_12 ; "mwFileTransfer_close"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000F709
; ---------------------------------------------------------------------------

loc_1000F749:				; CODE XREF: mwFileTransfer_close+50j
		mov	[esp+18h+var_10], offset aSrvcNull_4 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwfiletrans_12 ; "mwFileTransfer_close"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000F709
; ---------------------------------------------------------------------------

loc_1000F767:				; CODE XREF: mwFileTransfer_close+57j
		mov	[esp+18h+var_10], offset aHandlerNull_3	; "handler != NULL"
		mov	[esp+18h+var_14], offset aMwfiletrans_12 ; "mwFileTransfer_close"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000F709
mwFileTransfer_close endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 160. mwFileTransfer_offer

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwFileTransfer_offer
mwFileTransfer_offer proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		mov	edi, [ebp+arg_0]
		test	edi, edi
		jz	loc_1000F950
		mov	ebx, [edi+4]
		test	ebx, ebx
		jnz	loc_1000F973
		mov	[esp+18h+var_18], edi
		call	mwFileTransfer_getState
		test	eax, eax
		jnz	loc_1000F996
		mov	eax, [edi]
		test	eax, eax
		jz	loc_1000F9B9
		mov	ecx, [eax+38h]
		test	ecx, ecx
		jz	loc_1000F9DF
		mov	[esp+18h+var_18], edi
		call	mwFileTransfer_getState
		test	eax, eax
		jnz	loc_1000FA05
		mov	edx, [edi+4]
		test	edx, edx
		jnz	loc_1000FA26
		mov	eax, [edi]
		mov	[esp+18h+var_18], eax
		call	mwService_getSession
		mov	[esp+18h+var_18], eax
		call	mwSession_getChannels
		mov	[esp+18h+var_18], eax
		call	mwChannel_newOutgoing
		mov	esi, eax
		mov	eax, [edi]
		mov	[esp+18h+var_18], esi
		mov	[esp+18h+var_14], eax
		call	mwChannel_setService
		mov	[esp+18h+var_14], 0
		mov	[esp+18h+var_18], esi
		call	mwChannel_setProtoType
		mov	[esp+18h+var_14], 1
		mov	[esp+18h+var_18], esi
		call	mwChannel_setProtoVer
		mov	[esp+18h+var_18], esi
		call	mwChannel_populateSupportedCipherInstances
		mov	[esp+18h+var_18], esi
		call	mwChannel_getUser
		mov	ebx, eax
		mov	eax, [edi+8]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[ebx+8], eax
		mov	eax, [edi+0Ch]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[ebx+10h], eax
		call	mwPutBuffer_new
		mov	[esp+18h+var_14], 0
		mov	ebx, eax
		mov	[esp+18h+var_18], eax
		call	guint32_put
		mov	eax, [edi+14h]
		mov	[esp+18h+var_18], ebx ;	int
		mov	[esp+18h+var_14], eax ;	char *
		call	mwString_put
		mov	eax, [edi+18h]
		mov	[esp+18h+var_18], ebx ;	int
		mov	[esp+18h+var_14], eax ;	char *
		call	mwString_put
		mov	eax, [edi+1Ch]
		mov	[esp+18h+var_18], ebx
		mov	[esp+18h+var_14], eax
		call	guint32_put
		mov	[esp+18h+var_14], 0
		mov	[esp+18h+var_18], ebx
		call	guint32_put
		mov	[esp+18h+var_14], 0
		mov	[esp+18h+var_18], ebx
		call	guint16_put
		mov	[esp+18h+var_18], esi
		call	mwChannel_getAddtlCreate
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+var_18], eax
		call	mwPutBuffer_finalize
		mov	[esp+18h+var_18], esi
		call	mwChannel_create
		test	eax, eax
		jnz	short loc_1000F923
		test	esi, esi
		mov	[edi+4], esi
		jz	short loc_1000F92A
		mov	[esp+18h+var_10], 0
		mov	[esp+18h+var_14], edi
		mov	[esp+18h+var_18], esi
		call	mwChannel_setServiceData

loc_1000F906:				; CODE XREF: mwFileTransfer_offer+291j
					; mwFileTransfer_offer+2B2j
		mov	eax, [edi+4]
		test	eax, eax
		jz	short loc_1000F92A
		mov	eax, edi
		mov	edx, 1
		call	sub_1000F5D0
		add	esp, 0Ch
		xor	eax, eax
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000F923:				; CODE XREF: mwFileTransfer_offer+159j
		mov	dword ptr [edi+4], 0

loc_1000F92A:				; CODE XREF: mwFileTransfer_offer+160j
					; mwFileTransfer_offer+17Bj
		mov	edx, 6
		mov	eax, edi
		call	sub_1000F5D0
		mov	[esp+18h+var_14], 80000000h
		mov	[esp+18h+var_18], edi
		call	mwFileTransfer_close
		xor	eax, eax

loc_1000F948:				; CODE XREF: mwFileTransfer_offer+1E1j
					; mwFileTransfer_offer+204j ...
		add	esp, 0Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000F950:				; CODE XREF: mwFileTransfer_offer+Ej
		mov	[esp+18h+var_10], offset aFtNull ; "ft != NULL"
		mov	[esp+18h+var_14], offset aMwfiletrans_13 ; "mwFileTransfer_offer"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFFFFFh
		jmp	short loc_1000F948
; ---------------------------------------------------------------------------

loc_1000F973:				; CODE XREF: mwFileTransfer_offer+19j
		mov	[esp+18h+var_10], offset aFtChannelNul_0 ; "ft->channel	== NULL"
		mov	[esp+18h+var_14], offset aMwfiletrans_13 ; "mwFileTransfer_offer"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFFFFFh
		jmp	short loc_1000F948
; ---------------------------------------------------------------------------

loc_1000F996:				; CODE XREF: mwFileTransfer_offer+29j
		mov	[esp+18h+var_10], offset aMwfiletrans_14 ; "mwFileTransfer_isNew(ft)"
		mov	[esp+18h+var_14], offset aMwfiletrans_13 ; "mwFileTransfer_offer"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFFFFFh
		jmp	short loc_1000F948
; ---------------------------------------------------------------------------

loc_1000F9B9:				; CODE XREF: mwFileTransfer_offer+33j
		mov	[esp+18h+var_10], offset aFtServiceNull	; "ft->service != NULL"
		mov	[esp+18h+var_14], offset aMwfiletrans_13 ; "mwFileTransfer_offer"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFFFFFh
		jmp	loc_1000F948
; ---------------------------------------------------------------------------

loc_1000F9DF:				; CODE XREF: mwFileTransfer_offer+3Ej
		mov	[esp+18h+var_10], offset aSrvcHandlerNul ; "srvc->handler != NULL"
		mov	[esp+18h+var_14], offset aMwfiletrans_13 ; "mwFileTransfer_offer"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFFFFFh
		jmp	loc_1000F948
; ---------------------------------------------------------------------------

loc_1000FA05:				; CODE XREF: mwFileTransfer_offer+4Ej
		mov	[esp+18h+var_10], offset aMwfiletrans_14 ; "mwFileTransfer_isNew(ft)"
		mov	[esp+18h+var_14], offset aFt_create_chan ; "ft_create_chan"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000F906
; ---------------------------------------------------------------------------

loc_1000FA26:				; CODE XREF: mwFileTransfer_offer+59j
		mov	[esp+18h+var_10], offset aFtChannelNul_0 ; "ft->channel	== NULL"
		mov	[esp+18h+var_14], offset aFt_create_chan ; "ft_create_chan"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000F906
mwFileTransfer_offer endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 147. mwFileTransfer_accept

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwFileTransfer_accept
mwFileTransfer_accept proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	loc_1000FB0A
		mov	esi, [ebx+4]
		test	esi, esi
		jz	loc_1000FB2D
		mov	[esp+18h+var_18], ebx
		call	mwFileTransfer_getState
		sub	eax, 1
		jnz	loc_1000FB50
		mov	eax, [ebx+4]
		mov	[esp+18h+var_18], eax
		call	mwChannel_getId
		test	eax, eax
		jns	loc_1000FB76
		mov	eax, [ebx+4]
		mov	[esp+18h+var_18], eax
		call	mwChannel_getState
		cmp	eax, 2
		jnz	loc_1000FB9C
		mov	eax, [ebx]
		test	eax, eax
		jz	loc_1000FBC2
		mov	esi, [eax+38h]
		test	esi, esi
		jz	loc_1000FBE8
		mov	eax, [ebx+4]
		mov	[esp+18h+var_18], eax
		call	mwChannel_accept
		test	eax, eax
		mov	edi, eax
		jnz	short loc_1000FAF0
		mov	eax, ebx
		mov	edx, 2
		call	sub_1000F5D0
		mov	eax, [esi+4]
		test	eax, eax
		jz	short loc_1000FAE5
		mov	[esp+18h+var_18], ebx
		call	eax

loc_1000FAE5:				; CODE XREF: mwFileTransfer_accept+8Ej
					; mwFileTransfer_accept+DBj ...
		add	esp, 0Ch
		mov	eax, edi
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_1000FAF0:				; CODE XREF: mwFileTransfer_accept+7Bj
		mov	[esp+18h+var_18], ebx
		mov	[esp+18h+var_14], 80000000h
		call	mwFileTransfer_close
		add	esp, 0Ch
		mov	eax, edi
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000FB0A:				; CODE XREF: mwFileTransfer_accept+Ej
		mov	[esp+18h+var_10], offset aFtNull ; "ft != NULL"
		mov	edi, 0FFFFFFFFh
		mov	[esp+18h+var_14], offset aMwfiletrans_15 ; "mwFileTransfer_accept"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000FAE5
; ---------------------------------------------------------------------------

loc_1000FB2D:				; CODE XREF: mwFileTransfer_accept+19j
		mov	[esp+18h+var_10], offset aFtChannelNull	; "ft->channel != NULL"
		mov	edi, 0FFFFFFFFh
		mov	[esp+18h+var_14], offset aMwfiletrans_15 ; "mwFileTransfer_accept"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000FAE5
; ---------------------------------------------------------------------------

loc_1000FB50:				; CODE XREF: mwFileTransfer_accept+2Aj
		mov	[esp+18h+var_10], offset aMwfiletrans_16 ; "mwFileTransfer_isPending(ft)"
		mov	edi, 0FFFFFFFFh
		mov	[esp+18h+var_14], offset aMwfiletrans_15 ; "mwFileTransfer_accept"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000FAE5
; ---------------------------------------------------------------------------

loc_1000FB76:				; CODE XREF: mwFileTransfer_accept+3Dj
		mov	[esp+18h+var_10], offset aMwchannel_is_2 ; "mwChannel_isIncoming(ft->channel)"
		mov	edi, 0FFFFFFFFh
		mov	[esp+18h+var_14], offset aMwfiletrans_15 ; "mwFileTransfer_accept"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000FAE5
; ---------------------------------------------------------------------------

loc_1000FB9C:				; CODE XREF: mwFileTransfer_accept+51j
		mov	[esp+18h+var_10], offset aMwchannel_isst ; "mwChannel_isState(ft->channel, mwChanne"...
		mov	edi, 0FFFFFFFFh
		mov	[esp+18h+var_14], offset aMwfiletrans_15 ; "mwFileTransfer_accept"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000FAE5
; ---------------------------------------------------------------------------

loc_1000FBC2:				; CODE XREF: mwFileTransfer_accept+5Bj
		mov	[esp+18h+var_10], offset aFtServiceNull	; "ft->service != NULL"
		mov	edi, 0FFFFFFFFh
		mov	[esp+18h+var_14], offset aMwfiletrans_15 ; "mwFileTransfer_accept"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000FAE5
; ---------------------------------------------------------------------------

loc_1000FBE8:				; CODE XREF: mwFileTransfer_accept+66j
		mov	[esp+18h+var_10], offset aSrvcHandlerNul ; "srvc->handler != NULL"
		mov	edi, 0FFFFFFFFh
		mov	[esp+18h+var_14], offset aMwfiletrans_15 ; "mwFileTransfer_accept"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_1000FAE5
mwFileTransfer_accept endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 159. mwFileTransfer_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwFileTransfer_new
mwFileTransfer_new proc	near		; CODE XREF: sub_10010050+B9p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		test	esi, esi
		jz	short loc_1000FC9F
		test	edi, edi
		jz	loc_1000FCBF
		mov	[esp+18h+var_18], 2Ch
		call	g_malloc0
		mov	ebx, eax
		mov	[eax], esi
		lea	eax, [eax+8]
		mov	[esp+18h+var_18], eax
		mov	[esp+18h+var_14], edi
		call	mwIdBlock_clone
		mov	eax, [ebp+arg_C]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[ebx+14h], eax
		mov	eax, [ebp+arg_8]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		xor	edx, edx
		mov	[ebx+18h], eax
		mov	eax, [ebp+arg_10]
		mov	[ebx+20h], eax
		mov	[ebx+1Ch], eax
		mov	eax, ebx
		call	sub_1000F5D0
		mov	[esp+18h+var_14], ebx
		mov	eax, [esi+3Ch]
		mov	[esp+18h+var_18], eax
		call	g_list_prepend
		mov	[esi+3Ch], eax

loc_1000FC90:				; CODE XREF: mwFileTransfer_new+ADj
					; mwFileTransfer_new+CDj
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000FC9F:				; CODE XREF: mwFileTransfer_new+17j
		mov	[esp+18h+var_10], offset aSrvcNull_4 ; "srvc !=	NULL"
		xor	ebx, ebx
		mov	[esp+18h+var_14], offset aMwfiletrans_17 ; "mwFileTransfer_new"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000FC90
; ---------------------------------------------------------------------------

loc_1000FCBF:				; CODE XREF: mwFileTransfer_new+1Bj
		mov	[esp+18h+var_10], offset aWhoNull_0 ; "who != NULL"
		xor	ebx, ebx
		mov	[esp+18h+var_14], offset aMwfiletrans_17 ; "mwFileTransfer_new"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000FC90
mwFileTransfer_new endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 278. mwServiceFileTransfer_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceFileTransfer_new
mwServiceFileTransfer_new proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		test	esi, esi
		jz	short loc_1000FD74
		test	edi, edi
		jz	loc_1000FD94
		mov	[esp+18h+var_18], 40h
		call	g_malloc0
		mov	[esp+18h+var_10], 38h
		mov	[esp+18h+var_14], esi
		mov	ebx, eax
		mov	[esp+18h+var_18], eax
		call	mwService_init
		mov	dword ptr [ebx+14h], offset sub_10010050
		mov	dword ptr [ebx+18h], offset sub_1000FE90
		mov	dword ptr [ebx+1Ch], offset sub_1000FE00
		mov	dword ptr [ebx+20h], offset sub_1000FF10
		mov	dword ptr [ebx+2Ch], offset sub_1000F020
		mov	dword ptr [ebx+0Ch], offset sub_1000F050
		mov	dword ptr [ebx+10h], offset sub_1000F060
		mov	dword ptr [ebx+24h], offset sub_1000FDF0
		mov	dword ptr [ebx+28h], offset sub_1000FDC0
		mov	[ebx+38h], edi

loc_1000FD65:				; CODE XREF: mwServiceFileTransfer_new+B2j
					; mwServiceFileTransfer_new+D2j
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000FD74:				; CODE XREF: mwServiceFileTransfer_new+17j
		mov	[esp+18h+var_10], offset aSessionNull_4	; "session != NULL"
		xor	ebx, ebx
		mov	[esp+18h+var_14], offset aMwservicefil_1 ; "mwServiceFileTransfer_new"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000FD65
; ---------------------------------------------------------------------------

loc_1000FD94:				; CODE XREF: mwServiceFileTransfer_new+1Bj
		mov	[esp+18h+var_10], offset aHandlerNull_3	; "handler != NULL"
		xor	ebx, ebx
		mov	[esp+18h+var_14], offset aMwservicefil_1 ; "mwServiceFileTransfer_new"
		mov	[esp+18h+var_18], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1000FD65
mwServiceFileTransfer_new endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000FDC0	proc near		; DATA XREF: mwServiceFileTransfer_new+7Bo

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebx+3Ch]
		test	eax, eax
		jz	short loc_1000FDE2

loc_1000FDD1:				; CODE XREF: sub_1000FDC0+20j
		mov	eax, [eax]
		mov	[esp+8+var_8], eax
		call	mwFileTransfer_free
		mov	eax, [ebx+3Ch]
		test	eax, eax
		jnz	short loc_1000FDD1

loc_1000FDE2:				; CODE XREF: sub_1000FDC0+Fj
		mov	[ebp+arg_0], ebx
		add	esp, 4
		pop	ebx
		pop	ebp
		jmp	mwService_stopped
sub_1000FDC0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000FDF0	proc near		; DATA XREF: mwServiceFileTransfer_new+74o
		push	ebp
		mov	ebp, esp
		pop	ebp
		jmp	mwService_started
sub_1000FDF0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000FE00	proc near		; DATA XREF: mwServiceFileTransfer_new+51o

var_18		= dword	ptr -18h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	eax, [ebp+arg_8]
		mov	edx, [ebp+arg_4]
		mov	esi, [eax+10h]
		mov	eax, [ebp+arg_0]
		mov	eax, [eax+38h]
		test	eax, eax
		jz	short loc_1000FE5A
		mov	[esp+18h+var_18], edx
		call	mwChannel_getServiceData
		test	eax, eax
		mov	ebx, eax
		jz	short loc_1000FE7A
		mov	dword ptr [eax+4], 0
		mov	[esp+18h+var_18], eax
		call	mwFileTransfer_getState
		cmp	eax, 5
		jz	short loc_1000FE49
		mov	edx, 4
		mov	eax, ebx
		call	sub_1000F5D0

loc_1000FE49:				; CODE XREF: sub_1000FE00+3Bj
		mov	[ebp+arg_4], esi
		mov	[ebp+arg_0], ebx
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	mwFileTransfer_close
; ---------------------------------------------------------------------------

loc_1000FE5A:				; CODE XREF: sub_1000FE00+19j
		mov	[ebp+arg_8], offset aSrvcHandlerNul ; "srvc->handler !=	NULL"

loc_1000FE61:				; CODE XREF: sub_1000FE00+81j
		mov	[ebp+arg_4], offset aRecv_channelde ; "recv_channelDestroy"
		mov	[ebp+arg_0], offset aMeanwhile_8 ; "meanwhile"
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_1000FE7A:				; CODE XREF: sub_1000FE00+27j
		mov	[ebp+arg_8], offset aFtNull ; "ft != NULL"
		jmp	short loc_1000FE61
sub_1000FE00	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000FE90	proc near		; DATA XREF: mwServiceFileTransfer_new+4Ao

var_18		= dword	ptr -18h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		mov	edx, [ebp+arg_4]
		mov	[ebp+var_4], esi
		mov	esi, [eax+38h]
		test	esi, esi
		jz	short loc_1000FEE0
		mov	[esp+18h+var_18], edx
		call	mwChannel_getServiceData
		test	eax, eax
		mov	ebx, eax
		jz	short loc_1000FF03
		mov	edx, 2
		call	sub_1000F5D0
		mov	ecx, [esi+4]
		test	ecx, ecx
		jz	short loc_1000FED6
		mov	[ebp+arg_0], ebx
		mov	esi, [ebp+var_4]
		mov	ebx, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		jmp	ecx
; ---------------------------------------------------------------------------

loc_1000FED6:				; CODE XREF: sub_1000FE90+36j
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000FEE0:				; CODE XREF: sub_1000FE90+17j
		mov	[ebp+arg_8], offset aSrvcHandlerNul ; "srvc->handler !=	NULL"

loc_1000FEE7:				; CODE XREF: sub_1000FE90+7Aj
		mov	[ebp+arg_4], offset aRecv_channelac ; "recv_channelAccept"
		mov	ebx, [ebp+var_8]
		mov	[ebp+arg_0], offset aMeanwhile_8 ; "meanwhile"
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_1000FF03:				; CODE XREF: sub_1000FE90+25j
		mov	[ebp+arg_8], offset aFtNull ; "ft != NULL"
		jmp	short loc_1000FEE7
sub_1000FE90	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1000FF10	proc near		; DATA XREF: mwServiceFileTransfer_new+58o

var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		movzx	ebx, word ptr [ebp+arg_8]
		mov	[ebp+var_8], esi
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_C]
		mov	[esp+18h+var_18], eax
		call	mwChannel_getServiceData
		test	eax, eax
		mov	esi, eax
		jz	loc_1001001A
		cmp	bx, 1
		jz	short loc_1000FF98
		cmp	bx, 2
		jz	short loc_1000FF68
		movzx	eax, bx
		mov	esi, [ebp+var_8]
		mov	[ebp+arg_0], edi
		mov	ebx, [ebp+var_C]
		mov	[ebp+arg_8], eax
		mov	edi, [ebp+var_4]
		mov	[ebp+arg_4], offset aUnknownMessa_4 ; "unknown message in ft service: 0x%04x"
		mov	esp, ebp
		pop	ebp
		jmp	mw_mailme_opaque
; ---------------------------------------------------------------------------

loc_1000FF68:				; CODE XREF: sub_1000FF10+35j
		mov	eax, [eax]
		mov	ebx, [eax+38h]
		mov	eax, [esi+20h]
		test	eax, eax
		jz	loc_10010009

loc_1000FF78:				; CODE XREF: sub_1000FF10+105j
		mov	eax, [ebx+10h]
		test	eax, eax
		jz	short loc_1000FF84
		mov	[esp+18h+var_18], esi
		call	eax

loc_1000FF84:				; CODE XREF: sub_1000FF10+6Dj
		mov	eax, [esi+20h]
		test	eax, eax
		jz	short loc_1000FFE0

loc_1000FF8B:				; CODE XREF: sub_1000FF10+A5j
					; sub_1000FF10+B5j
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1000FF98:				; CODE XREF: sub_1000FF10+2Fj
		mov	eax, [eax]
		mov	ebx, [eax+38h]
		mov	[esp+18h+var_18], esi
		call	mwFileTransfer_getState
		cmp	eax, 2
		jnz	loc_10010040
		mov	edx, [edi]
		mov	eax, [esi+20h]
		cmp	edx, eax
		ja	short loc_1000FF8B
		sub	eax, edx
		test	eax, eax
		mov	[esi+20h], eax
		jz	short loc_1000FFFB

loc_1000FFC0:				; CODE XREF: sub_1000FF10+F7j
		mov	ecx, [ebx+0Ch]
		test	ecx, ecx
		jz	short loc_1000FF8B
		mov	[ebp+arg_4], edi
		mov	ebx, [ebp+var_C]
		mov	[ebp+arg_0], esi
		mov	edi, [ebp+var_4]
		mov	esi, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		jmp	ecx
; ---------------------------------------------------------------------------
		align 10h

loc_1000FFE0:				; CODE XREF: sub_1000FF10+79j
		mov	[ebp+arg_0], esi
		mov	ebx, [ebp+var_C]
		mov	[ebp+arg_4], 0
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	mwFileTransfer_close
; ---------------------------------------------------------------------------

loc_1000FFFB:				; CODE XREF: sub_1000FF10+AEj
		mov	edx, 5
		mov	eax, esi
		call	sub_1000F5D0
		jmp	short loc_1000FFC0
; ---------------------------------------------------------------------------

loc_10010009:				; CODE XREF: sub_1000FF10+62j
		mov	edx, 5
		mov	eax, esi
		call	sub_1000F5D0
		jmp	loc_1000FF78
; ---------------------------------------------------------------------------

loc_1001001A:				; CODE XREF: sub_1000FF10+25j
		mov	[ebp+arg_8], offset aFtNull ; "ft != NULL"
		mov	[ebp+arg_4], offset aRecv_2 ; "recv"

loc_10010028:				; CODE XREF: sub_1000FF10+13Ej
		mov	[ebp+arg_0], offset aMeanwhile_8 ; "meanwhile"
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_10010040:				; CODE XREF: sub_1000FF10+98j
		mov	[ebp+arg_8], offset aMwfiletrans_11 ; "mwFileTransfer_isOpen(ft)"
		mov	[ebp+arg_4], offset aRecv_transfer ; "recv_TRANSFER"
		jmp	short loc_10010028
sub_1000FF10	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10010050	proc near		; DATA XREF: mwServiceFileTransfer_new+43o

var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= byte ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 3Ch
		mov	eax, [ebp+arg_0]
		mov	edi, [ebp+arg_4]
		mov	eax, [eax+38h]
		test	eax, eax
		mov	[ebp+var_30], eax
		jz	loc_10010196
		mov	eax, [ebp+arg_8]
		add	eax, 30h
		mov	[esp+48h+var_48], eax
		call	mwGetBuffer_wrap
		mov	ebx, eax
		lea	eax, [ebp+var_1C]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], ebx
		call	guint32_get
		lea	eax, [ebp+var_10]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], ebx
		call	mwString_get
		lea	eax, [ebp+var_14]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], ebx
		call	mwString_get
		lea	eax, [ebp+var_18]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], ebx
		call	guint32_get
		mov	[esp+48h+var_48], ebx
		call	mwGetBuffer_error
		mov	[esp+48h+var_48], ebx
		mov	esi, eax
		call	mwGetBuffer_free
		test	esi, esi
		jnz	loc_10010160
		mov	[esp+48h+var_48], edi
		call	mwChannel_getUser
		mov	edx, [eax+8]
		mov	[ebp+var_24], edx
		mov	eax, [eax+10h]
		mov	edx, [ebp+arg_0]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_18]
		mov	[esp+48h+var_48], edx
		mov	[esp+48h+var_38], eax
		mov	eax, [ebp+var_10]
		mov	[esp+48h+var_3C], eax
		mov	eax, [ebp+var_14]
		mov	[esp+48h+var_40], eax
		lea	eax, [ebp+var_24]
		mov	[esp+48h+var_44], eax
		call	mwFileTransfer_new
		mov	edx, 1
		mov	ebx, eax
		mov	[eax+4], edi
		call	sub_1000F5D0
		mov	[esp+48h+var_40], 0
		mov	[esp+48h+var_44], ebx
		mov	[esp+48h+var_48], edi
		call	mwChannel_setServiceData
		mov	edx, [ebp+var_30]
		mov	eax, [edx]
		test	eax, eax
		jz	short loc_10010140
		mov	[esp+48h+var_48], ebx
		call	eax
		nop

loc_10010140:				; CODE XREF: sub_10010050+E8j
					; sub_10010050+144j
		mov	eax, [ebp+var_10]
		mov	[esp+48h+var_48], eax
		call	g_free
		mov	eax, [ebp+var_14]
		mov	[esp+48h+var_48], eax
		call	g_free

loc_10010156:				; CODE XREF: sub_10010050+162j
		add	esp, 3Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10010160:				; CODE XREF: sub_10010050+7Dj
		mov	[esp+48h+var_40], offset aBadMalformedAd ; "bad/malformed addtl	in File	Transfer se"...
		mov	[esp+48h+var_44], 10h
		mov	[esp+48h+var_48], offset aMeanwhile_8 ;	"meanwhile"
		call	g_log
		mov	[esp+48h+var_40], 0
		mov	[esp+48h+var_44], 80000000h
		mov	[esp+48h+var_48], edi
		call	mwChannel_destroy
		jmp	short loc_10010140
; ---------------------------------------------------------------------------

loc_10010196:				; CODE XREF: sub_10010050+17j
		mov	[esp+48h+var_40], offset aSrvcHandlerNul ; "srvc->handler != NULL"
		mov	[esp+48h+var_44], offset aRecv_channelcr ; "recv_channelCreate"
		mov	[esp+48h+var_48], offset aMeanwhile_8 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10010156
sub_10010050	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100101C0	proc near		; DATA XREF: mwServiceIm_new+6Ao
		push	ebp
		mov	eax, offset aInstantMessagi ; "Instant Messaging"
		mov	ebp, esp
		pop	ebp
		retn
sub_100101C0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100101D0	proc near		; DATA XREF: mwServiceIm_new+71o
		push	ebp
		mov	eax, offset aImServiceWithS ; "IM service with Standard	and NotesBuddy"...
		mov	ebp, esp
		pop	ebp
		retn
sub_100101D0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 119. mwConversation_getTarget

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConversation_getTarget
mwConversation_getTarget proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_100101F2
		leave
		add	eax, 8
		retn
; ---------------------------------------------------------------------------

loc_100101F2:				; CODE XREF: mwConversation_getTarget+Bj
		mov	[esp+18h+var_10], offset aConvNull ; "conv != NULL"
		mov	[esp+18h+var_14], offset aMwconversation ; "mwConversation_getTarget"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwConversation_getTarget endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 116. mwConversation_getClientType

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConversation_getClientType
mwConversation_getClientType proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10010232
		mov	eax, [eax+18h]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10010232:				; CODE XREF: mwConversation_getClientType+Bj
		mov	[esp+18h+var_10], offset aConvNull ; "conv != NULL"
		mov	[esp+18h+var_14], offset aMwconversati_0 ; "mwConversation_getClientType"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFFFFFh
		leave
		retn
mwConversation_getClientType endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 125. mwConversation_supports

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConversation_supports
mwConversation_supports	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	ecx, ecx
		jz	short loc_10010292
		cmp	edx, 1
		mov	eax, 1
		jbe	short locret_10010290
		xor	al, al
		cmp	edx, 4
		ja	short locret_10010290
		xor	eax, eax
		cmp	dword ptr [ecx+18h], 33453h
		setz	al
		lea	esi, [esi+0]

locret_10010290:			; CODE XREF: mwConversation_supports+18j
					; mwConversation_supports+1Fj
		leave
		retn
; ---------------------------------------------------------------------------

loc_10010292:				; CODE XREF: mwConversation_supports+Ej
		mov	[esp+18h+var_10], offset aConvNull ; "conv != NULL"
		mov	[esp+18h+var_14], offset aMwconversati_1 ; "mwConversation_supports"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwConversation_supports	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 117. mwConversation_getService

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConversation_getService
mwConversation_getService proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_100102D1
		mov	eax, [eax]
		leave
		retn
; ---------------------------------------------------------------------------

loc_100102D1:				; CODE XREF: mwConversation_getService+Bj
		mov	[esp+18h+var_10], offset aConvNull ; "conv != NULL"
		mov	[esp+18h+var_14], offset aMwconversati_2 ; "mwConversation_getService"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwConversation_getService endp

; ---------------------------------------------------------------------------
		jmp	short mwConversation_getState
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 118. mwConversation_getState

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConversation_getState
mwConversation_getState	proc near	; CODE XREF: .text:100102F1j
					; mwConversation_free+11p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10010312
		mov	eax, [eax+14h]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10010312:				; CODE XREF: mwConversation_getState+Bj
		mov	[esp+18h+var_10], offset aConvNull ; "conv != NULL"
		mov	[esp+18h+var_14], offset aMwconversati_3 ; "mwConversation_getState"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 3
		leave
		retn
mwConversation_getState	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 280. mwServiceIm_getClientType

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceIm_getClientType
mwServiceIm_getClientType proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10010352
		mov	eax, [eax+38h]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10010352:				; CODE XREF: mwServiceIm_getClientType+Bj
		mov	[esp+18h+var_10], offset aSrvcNull_5 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwserviceim_ge ; "mwServiceIm_getClientType"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		mov	eax, 0FFFFFFFFh
		leave
		retn
mwServiceIm_getClientType endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 284. mwServiceIm_setClientType

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceIm_setClientType
mwServiceIm_setClientType proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10010395
		mov	edx, [ebp+arg_4]
		mov	[eax+38h], edx
		leave
		retn
; ---------------------------------------------------------------------------

loc_10010395:				; CODE XREF: mwServiceIm_setClientType+Bj
		mov	[esp+18h+var_10], offset aSrvcNull_5 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwserviceim_se ; "mwServiceIm_setClientType"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwServiceIm_setClientType endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 285. mwServiceIm_supports

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceIm_supports
mwServiceIm_supports proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	ecx, ecx
		jz	short loc_100103F2
		cmp	edx, 1
		mov	eax, 1
		jbe	short locret_100103F0
		xor	al, al
		cmp	edx, 5
		ja	short locret_100103F0
		xor	eax, eax
		cmp	dword ptr [ecx+38h], 33453h
		setz	al
		lea	esi, [esi+0]

locret_100103F0:			; CODE XREF: mwServiceIm_supports+18j
					; mwServiceIm_supports+1Fj
		leave
		retn
; ---------------------------------------------------------------------------

loc_100103F2:				; CODE XREF: mwServiceIm_supports+Ej
		mov	[esp+18h+var_10], offset aSrvcNull_5 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwserviceim_su ; "mwServiceIm_supports"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwServiceIm_supports endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 282. mwServiceIm_getHandler

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceIm_getHandler
mwServiceIm_getHandler proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10010432
		mov	eax, [eax+3Ch]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10010432:				; CODE XREF: mwServiceIm_getHandler+Bj
		mov	[esp+18h+var_10], offset aSrvcNull_5 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwserviceim__0 ; "mwServiceIm_getHandler"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwServiceIm_getHandler endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10010460	proc near		; CODE XREF: sub_10010E90+23Cp
					; sub_10010E90+26Dp ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h

		push	ebp
		mov	ebp, esp
		push	ebx
		mov	ebx, eax
		sub	esp, 14h
		test	eax, eax
		jz	short loc_10010494
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_100104B2
		mov	eax, [eax+3Ch]
		test	eax, eax
		jz	short loc_1001048E
		mov	eax, [eax+8]
		test	eax, eax
		jz	short loc_1001048E
		mov	[esp+18h+var_10], ecx
		mov	[esp+18h+var_14], edx
		mov	[esp+18h+var_18], ebx
		call	eax

loc_1001048E:				; CODE XREF: sub_10010460+18j
					; sub_10010460+1Fj ...
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10010494:				; CODE XREF: sub_10010460+Bj
		mov	[esp+18h+var_10], offset aConvNull ; "conv != NULL"
		mov	[esp+18h+var_14], offset aConvo_recv ; "convo_recv"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1001048E
; ---------------------------------------------------------------------------

loc_100104B2:				; CODE XREF: sub_10010460+11j
		mov	[esp+18h+var_10], offset aSrvcNull_5 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aConvo_recv ; "convo_recv"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1001048E
sub_10010460	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100104D0	proc near		; CODE XREF: mwConversation_close+16p
					; sub_10010620+1Ap ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		test	eax, eax
		mov	[ebp+var_C], ebx
		mov	ebx, eax
		mov	[ebp+var_8], esi
		mov	esi, edx
		mov	[ebp+var_4], edi
		jz	short loc_10010561
		cmp	[eax+14h], edx
		jz	short loc_10010540
		cmp	edx, 1
		mov	edi, offset aPending_1 ; "pending"
		jz	short loc_10010500
		jnb	short loc_10010550
		mov	edi, offset aClosed ; "closed"
		lea	esi, [esi+0]

loc_10010500:				; CODE XREF: sub_100104D0+24j
					; sub_100104D0+88j ...
		mov	eax, [ebx+0Ch]
		mov	ecx, offset aNull_5 ; "(null)"
		mov	edx, [ebx+8]
		mov	[esp+28h+var_14], edi
		mov	[esp+28h+var_20], offset aSettingConvers ; "setting conversation (%s, %s) state: %s"
		test	eax, eax
		cmovz	eax, ecx
		test	edx, edx
		cmovz	edx, ecx
		mov	[esp+28h+var_18], eax
		mov	[esp+28h+var_1C], edx
		mov	[esp+28h+var_24], 40h
		mov	[esp+28h+var_28], offset aMeanwhile_9 ;	"meanwhile"
		call	g_log
		mov	[ebx+14h], esi

loc_10010540:				; CODE XREF: sub_100104D0+1Aj
					; sub_100104D0+ADj
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10010550:				; CODE XREF: sub_100104D0+26j
		cmp	edx, 2
		mov	edi, offset aUnknown_3 ; "UNKNOWN"
		jnz	short loc_10010500
		mov	edi, offset aOpen_2 ; "open"
		jmp	short loc_10010500
; ---------------------------------------------------------------------------

loc_10010561:				; CODE XREF: sub_100104D0+15j
		mov	[esp+28h+var_20], offset aConvNull ; "conv != NULL"
		mov	[esp+28h+var_24], offset aConvo_set_stat ; "convo_set_state"
		mov	[esp+28h+var_28], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10010540
sub_100104D0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 113. mwConversation_close

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConversation_close
mwConversation_close proc near		; CODE XREF: mwConversation_free+2Ep
					; sub_100115E0+4Cj

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	ebx, [ebp+arg_0]
		mov	esi, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_100105E1
		xor	edx, edx
		mov	eax, ebx
		call	sub_100104D0
		mov	eax, [ebx]
		test	eax, eax
		jz	short loc_100105FF
		mov	eax, [eax+3Ch]
		test	eax, eax
		jz	short loc_100105B8
		mov	eax, [eax+4]
		test	eax, eax
		jz	short loc_100105B8
		mov	[esp+18h+var_14], esi
		mov	[esp+18h+var_18], ebx
		call	eax

loc_100105B8:				; CODE XREF: mwConversation_close+26j
					; mwConversation_close+2Dj
		mov	eax, [ebx+4]
		test	eax, eax
		jz	short loc_100105DA
		mov	[esp+18h+var_10], 0
		mov	[esp+18h+var_14], esi
		mov	[esp+18h+var_18], eax
		call	mwChannel_destroy
		mov	dword ptr [ebx+4], 0

loc_100105DA:				; CODE XREF: mwConversation_close+3Dj
					; mwConversation_close+7Dj ...
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100105E1:				; CODE XREF: mwConversation_close+10j
		mov	[esp+18h+var_10], offset aConvNull ; "conv != NULL"
		mov	[esp+18h+var_14], offset aMwconversati_4 ; "mwConversation_close"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100105DA
; ---------------------------------------------------------------------------

loc_100105FF:				; CODE XREF: mwConversation_close+1Fj
		mov	[esp+18h+var_10], offset aSrvcNull_5 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwconversati_4 ; "mwConversation_close"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100105DA
mwConversation_close endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10010620	proc near		; CODE XREF: sub_10010E30+1Bj
					; sub_10011730+2FCp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h

		push	ebp
		mov	ebp, esp
		push	ebx
		mov	ebx, eax
		sub	esp, 14h
		test	eax, eax
		jz	short loc_10010659
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_10010677
		mov	eax, ebx
		mov	edx, 2
		call	sub_100104D0
		mov	eax, [ebx]
		mov	eax, [eax+3Ch]
		test	eax, eax
		jz	short loc_10010695
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_10010653
		mov	[esp+18h+var_18], ebx
		call	eax

loc_10010653:				; CODE XREF: sub_10010620+2Cj
					; sub_10010620+55j ...
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10010659:				; CODE XREF: sub_10010620+Bj
		mov	[esp+18h+var_10], offset aConvNull ; "conv != NULL"
		mov	[esp+18h+var_14], offset aConvo_opened ; "convo_opened"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10010653
; ---------------------------------------------------------------------------

loc_10010677:				; CODE XREF: sub_10010620+11j
		mov	[esp+18h+var_10], offset aConvServiceNul ; "conv->service != NULL"
		mov	[esp+18h+var_14], offset aConvo_opened ; "convo_opened"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10010653
; ---------------------------------------------------------------------------

loc_10010695:				; CODE XREF: sub_10010620+26j
		mov	[esp+18h+var_10], offset aHNull	; "h !=	NULL"
		mov	[esp+18h+var_14], offset aConvo_opened ; "convo_opened"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10010653
sub_10010620	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 122. mwConversation_removeClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConversation_removeClientData
mwConversation_removeClientData	proc near ; CODE XREF: sub_10010700+11p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_100106D9
		add	eax, 24h
		mov	[ebp+arg_0], eax
		leave
		jmp	mw_datum_clear
; ---------------------------------------------------------------------------

loc_100106D9:				; CODE XREF: mwConversation_removeClientData+Bj
		mov	[esp+18h+var_10], offset aConvNull ; "conv != NULL"
		mov	[esp+18h+var_14], offset aMwconversati_5 ; "mwConversation_removeClientData"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwConversation_removeClientData	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10010700	proc near		; CODE XREF: mwConversation_free+21j
					; mwConversation_free+3Aj ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], ebx
		mov	ebx, eax
		mov	[ebp+var_4], esi
		mov	[esp+18h+var_18], eax
		call	mwConversation_removeClientData
		mov	esi, [ebx]
		mov	[esp+18h+var_14], ebx
		mov	eax, [esi+40h]
		mov	[esp+18h+var_18], eax
		call	g_list_remove_all
		mov	[esi+40h], eax
		lea	eax, [ebx+8]
		mov	[esp+18h+var_18], eax
		call	mwIdBlock_clear
		mov	[esp+18h+var_18], ebx
		call	g_free
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
sub_10010700	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 114. mwConversation_free

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConversation_free
mwConversation_free proc near		; CODE XREF: sub_10010DF0+16p
					; sub_10011730+2EFp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_1001078F
		mov	[esp+18h+var_18], ebx
		call	mwConversation_getState
		test	eax, eax
		jnz	short loc_10010773
		add	esp, 14h
		mov	eax, ebx
		pop	ebx
		pop	ebp
		jmp	short sub_10010700
; ---------------------------------------------------------------------------

loc_10010773:				; CODE XREF: mwConversation_free+18j
		mov	[esp+18h+var_18], ebx
		mov	[esp+18h+var_14], 0
		call	mwConversation_close
		add	esp, 14h
		mov	eax, ebx
		pop	ebx
		pop	ebp
		jmp	sub_10010700
; ---------------------------------------------------------------------------

loc_1001078F:				; CODE XREF: mwConversation_free+Cj
		mov	[esp+18h+var_10], offset aConvNull ; "conv != NULL"
		mov	[esp+18h+var_14], offset aMwconversati_6 ; "mwConversation_free"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
mwConversation_free endp

; ---------------------------------------------------------------------------
		jmp	short sub_100107C0
; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100107C0	proc near		; CODE XREF: .text:100107B1j
					; DATA XREF: mwServiceIm_new+63o

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebx+40h]
		test	eax, eax
		jz	short loc_100107DF

loc_100107D1:				; CODE XREF: sub_100107C0+1Dj
		mov	eax, [eax]
		call	sub_10010700
		mov	eax, [ebx+40h]
		test	eax, eax
		jnz	short loc_100107D1

loc_100107DF:				; CODE XREF: sub_100107C0+Fj
		mov	eax, [ebx+3Ch]
		test	eax, eax
		jz	short loc_100107F2
		mov	eax, [eax+10h]
		test	eax, eax
		jz	short loc_100107F2
		mov	[esp+8+var_8], ebx
		call	eax

loc_100107F2:				; CODE XREF: sub_100107C0+24j
					; sub_100107C0+2Bj
		mov	dword ptr [ebx+3Ch], 0
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
sub_100107C0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 115. mwConversation_getClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConversation_getClientData
mwConversation_getClientData proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10010819
		add	eax, 24h
		mov	[ebp+arg_0], eax
		leave
		jmp	mw_datum_get
; ---------------------------------------------------------------------------

loc_10010819:				; CODE XREF: mwConversation_getClientData+Bj
		mov	[esp+18h+var_10], offset aConvNull ; "conv != NULL"
		mov	[esp+18h+var_14], offset aMwconversati_7 ; "mwConversation_getClientData"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwConversation_getClientData endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 124. mwConversation_setClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConversation_setClientData
mwConversation_setClientData proc near

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	edx, [ebp+arg_8]
		test	eax, eax
		jz	short loc_10010862
		add	eax, 24h
		mov	[ebp+arg_8], edx
		mov	[ebp+arg_4], ecx
		mov	[ebp+arg_0], eax
		pop	ebp
		jmp	mw_datum_set
; ---------------------------------------------------------------------------

loc_10010862:				; CODE XREF: mwConversation_setClientData+Ej
		mov	[ebp+arg_8], offset aConvNull ;	"conv != NULL"
		mov	[ebp+arg_4], offset aMwconversati_8 ; "mwConversation_setClientData"
		mov	[ebp+arg_0], offset aMeanwhile_9 ; "meanwhile"
		pop	ebp
		jmp	g_return_if_fail_warning
mwConversation_setClientData endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 120. mwConversation_getTargetInfo

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConversation_getTargetInfo
mwConversation_getTargetInfo proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1001089D
		mov	eax, [eax+4]
		test	eax, eax
		jz	short loc_100108BD
		mov	[ebp+arg_0], eax
		leave
		jmp	mwChannel_getUser
; ---------------------------------------------------------------------------

loc_1001089D:				; CODE XREF: mwConversation_getTargetInfo+Bj
		mov	[esp+18h+var_10], offset aConvNull ; "conv != NULL"
		mov	[esp+18h+var_14], offset aMwconversati_9 ; "mwConversation_getTargetInfo"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning

locret_100108B9:			; CODE XREF: mwConversation_getTargetInfo+59j
		leave
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_100108BD:				; CODE XREF: mwConversation_getTargetInfo+12j
		mov	[esp+18h+var_10], offset aConvChannelNul ; "conv->channel != NULL"
		mov	[esp+18h+var_14], offset aMwconversati_9 ; "mwConversation_getTargetInfo"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short locret_100108B9
mwConversation_getTargetInfo endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100108E0	proc near		; CODE XREF: sub_100109C0+2Cp
					; sub_100109C0+4Fp ...

var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= byte ptr -14h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	[ebp+var_8], esi
		mov	esi, edx
		mov	[ebp+var_4], edi
		mov	edi, ecx
		mov	[ebp+var_C], ebx
		mov	[ebp+var_24], eax
		mov	eax, [eax+4]
		test	eax, eax
		mov	[ebp+var_20], eax
		jz	loc_10010993
		call	mwPutBuffer_new
		mov	[esp+38h+var_34], 2
		mov	ebx, eax
		mov	[esp+38h+var_38], eax
		call	guint32_put
		mov	[esp+38h+var_34], esi
		mov	[esp+38h+var_38], ebx
		call	guint32_put
		mov	[esp+38h+var_38], ebx
		mov	[esp+38h+var_34], edi
		call	guint32_put
		mov	eax, [ebp+arg_0]
		mov	[esp+38h+var_38], ebx
		mov	[esp+38h+var_34], eax
		call	mwOpaque_put
		mov	[esp+38h+var_34], ebx
		lea	ebx, [ebp+var_14]
		mov	[esp+38h+var_38], ebx
		call	mwPutBuffer_finalize
		mov	eax, [ebp+var_24]
		mov	edx, [eax+10h]
		mov	[esp+38h+var_30], ebx
		mov	[esp+38h+var_34], 64h
		test	edx, edx
		setz	al
		movzx	eax, al
		mov	[esp+38h+var_2C], eax
		mov	eax, [ebp+var_20]
		mov	[esp+38h+var_38], eax
		call	mwChannel_sendEncrypted
		mov	[esp+38h+var_38], ebx
		mov	esi, eax
		call	mwOpaque_clear

loc_10010984:				; CODE XREF: sub_100108E0+D4j
		mov	eax, esi
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10010993:				; CODE XREF: sub_100108E0+1Ej
		mov	[esp+38h+var_30], offset aChanNull_7 ; "chan !=	NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+38h+var_34], offset aConvo_send_dat ; "convo_send_data"
		mov	[esp+38h+var_38], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10010984
sub_100108E0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100109C0	proc near		; CODE XREF: sub_10010A90+29p
					; sub_10010AE0+29p

Str		= dword	ptr -28h
var_24		= dword	ptr -24h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		mov	ebx, edx
		sub	esp, 1Ch
		mov	[esp+28h+Str], edx ; Str
		mov	[ebp+var_14], ecx
		mov	[ebp+var_10], eax
		call	strlen
		xor	ecx, ecx
		mov	edx, 1388h
		mov	[esp+28h+Str], 0
		mov	esi, eax
		mov	eax, [ebp+var_10]
		call	sub_100108E0
		test	eax, eax
		setz	dl
		test	esi, esi
		jnz	short loc_10010A1C

loc_100109FA:				; CODE XREF: sub_100109C0+9Cj
					; sub_100109C0+C9j
		test	dl, dl
		jz	short loc_10010A14
		mov	eax, [ebp+var_10]
		xor	ecx, ecx
		mov	edx, 1389h
		mov	[esp+28h+Str], 0
		call	sub_100108E0

loc_10010A14:				; CODE XREF: sub_100109C0+3Cj
					; sub_100109C0+5Ej ...
		add	esp, 1Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10010A1C:				; CODE XREF: sub_100109C0+38j
		test	dl, dl
		jz	short loc_10010A14
		cmp	esi, 7FFh
		mov	edi, ebx
		jbe	short loc_10010A6A

loc_10010A2A:				; CODE XREF: sub_100109C0+A8j
		movzx	ebx, byte ptr [edi+800h]
		mov	byte ptr [edi+800h], 0
		mov	eax, [ebp+var_10]
		mov	[esp+28h+var_24], edi
		mov	[esp+28h+Str], eax
		call	[ebp+var_14]
		mov	[edi+800h], bl
		test	eax, eax
		setz	dl
		add	edi, 800h
		sub	esi, 800h
		jz	short loc_100109FA
		test	dl, dl
		jz	short loc_10010A14
		cmp	esi, 7FFh
		ja	short loc_10010A2A

loc_10010A6A:				; CODE XREF: sub_100109C0+68j
		lea	ebx, [esi+edi]
		movzx	esi, byte ptr [ebx]
		mov	byte ptr [ebx],	0
		mov	edx, [ebp+var_10]
		mov	[esp+28h+var_24], edi
		mov	[esp+28h+Str], edx
		call	[ebp+var_14]
		mov	edx, esi
		mov	[ebx], dl
		test	eax, eax
		setz	dl
		jmp	loc_100109FA
sub_100109C0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl sub_10010A90(int,	char *)
sub_10010A90	proc near		; CODE XREF: mwConversation_send+76p
					; DATA XREF: sub_10010A90+24o

Str		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_4]
		mov	[esp+18h+Str], ebx ; Str
		call	strlen
		mov	[ebp+var_8], ebx
		cmp	eax, 800h
		mov	[ebp+var_C], eax
		jbe	short loc_10010AC4
		mov	eax, [ebp+arg_0]
		mov	edx, ebx
		mov	ecx, offset sub_10010A90
		call	sub_100109C0
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10010AC4:				; CODE XREF: sub_10010A90+1Dj
		lea	eax, [ebp+var_C]
		xor	ecx, ecx
		mov	[esp+18h+Str], eax
		mov	eax, [ebp+arg_0]
		mov	edx, 5
		call	sub_100108E0
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
sub_10010A90	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl sub_10010AE0(int,	char *)
sub_10010AE0	proc near		; CODE XREF: mwConversation_send+C3p
					; DATA XREF: sub_10010AE0+24o

Str		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_4]
		mov	[esp+18h+Str], ebx ; Str
		call	strlen
		mov	[ebp+var_8], ebx
		cmp	eax, 800h
		mov	[ebp+var_C], eax
		jbe	short loc_10010B14
		mov	eax, [ebp+arg_0]
		mov	edx, ebx
		mov	ecx, offset sub_10010AE0
		call	sub_100109C0
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10010B14:				; CODE XREF: sub_10010AE0+1Dj
		lea	eax, [ebp+var_C]
		xor	ecx, ecx
		mov	[esp+18h+Str], eax
		mov	eax, [ebp+arg_0]
		mov	edx, 4
		call	sub_100108E0
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
sub_10010AE0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 123. mwConversation_send

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl mwConversation_send(int, int, char *)
		public mwConversation_send
mwConversation_send proc near

Str		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 20h
		mov	esi, [ebp+arg_0]
		mov	ebx, [ebp+arg_4]
		test	esi, esi
		jz	loc_10010C96
		mov	[esp+28h+Str], esi
		call	mwConversation_getState
		cmp	eax, 2
		jnz	loc_10010CBC
		mov	ecx, [esi+4]
		test	ecx, ecx
		jz	loc_10010CE2
		cmp	ebx, 4		; switch 5 cases
		jbe	short loc_10010B95
		mov	[esp+28h+var_1C], ebx ;	jumptable 10010B95 default case
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_20], offset aUnsupportedImS ; "unsupported	IM Send	Type, 0x%x"
		mov	[esp+28h+var_24], 10h
		mov	[esp+28h+Str], offset aMeanwhile_9 ; "meanwhile"
		call	g_log

loc_10010B8C:				; CODE XREF: mwConversation_send+187j
					; mwConversation_send+1ADj ...
		add	esp, 20h
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10010B95:				; CODE XREF: mwConversation_send+35j
		jmp	ds:off_1001F594[ebx*4] ; switch	jump
; ---------------------------------------------------------------------------

loc_10010B9C:				; CODE XREF: mwConversation_send:loc_10010B95j
					; DATA XREF: .rdata:off_1001F594o
		mov	eax, [ebp+arg_8] ; jumptable 10010B95 case 4
		mov	[esp+28h+Str], esi ; int
		mov	[esp+28h+var_24], eax ;	char *
		call	sub_10010A90
		add	esp, 20h
		pop	ebx
		mov	esi, eax
		mov	eax, esi
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10010BB6:				; CODE XREF: mwConversation_send:loc_10010B95j
					; DATA XREF: .rdata:off_1001F594o
		mov	eax, [ebp+arg_8] ; jumptable 10010B95 case 3
		mov	[esp+28h+Str], eax ; Str
		call	strlen
		xor	ecx, ecx
		mov	edx, 3
		mov	[ebp+var_10], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_C], eax
		lea	eax, [ebp+var_10]
		mov	[esp+28h+Str], eax
		mov	eax, esi
		call	sub_100108E0
		add	esp, 20h
		pop	ebx
		mov	esi, eax
		mov	eax, esi
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10010BE9:				; CODE XREF: mwConversation_send:loc_10010B95j
					; DATA XREF: .rdata:off_1001F594o
		mov	eax, [ebp+arg_8] ; jumptable 10010B95 case 2
		mov	[esp+28h+Str], esi ; int
		mov	[esp+28h+var_24], eax ;	char *
		call	sub_10010AE0
		add	esp, 20h
		pop	ebx
		mov	esi, eax
		mov	eax, esi
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10010C03:				; CODE XREF: mwConversation_send:loc_10010B95j
					; DATA XREF: .rdata:off_1001F594o
		xor	ecx, ecx	; jumptable 10010B95 case 1
		mov	eax, esi
		cmp	[ebp+arg_8], 0
		mov	edx, 1
		mov	[esp+28h+Str], 0
		setz	cl
		call	sub_100108E0
		add	esp, 20h
		pop	ebx
		mov	esi, eax
		mov	eax, esi
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10010C2A:				; CODE XREF: mwConversation_send:loc_10010B95j
					; DATA XREF: .rdata:off_1001F594o
		call	mwPutBuffer_new	; jumptable 10010B95 case 0
		mov	[esp+28h+var_24], 1
		mov	ebx, eax
		mov	[esp+28h+Str], eax
		call	guint32_put
		mov	eax, [ebp+arg_8]
		mov	[esp+28h+Str], ebx ; int
		mov	[esp+28h+var_24], eax ;	char *
		call	mwString_put
		mov	[esp+28h+var_24], ebx
		lea	ebx, [ebp+var_10]
		mov	[esp+28h+Str], ebx
		call	mwPutBuffer_finalize
		xor	eax, eax
		cmp	dword ptr [esi+10h], 0
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_24], 64h
		setz	al
		mov	[esp+28h+var_1C], eax
		mov	eax, [esi+4]
		mov	[esp+28h+Str], eax
		call	mwChannel_sendEncrypted
		mov	[esp+28h+Str], ebx
		mov	esi, eax
		call	mwOpaque_clear
		add	esp, 20h
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10010C96:				; CODE XREF: mwConversation_send+10j
		mov	[esp+28h+var_20], offset aConvNull ; "conv != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwconversat_10 ; "mwConversation_send"
		mov	[esp+28h+Str], offset aMeanwhile_9 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10010B8C
; ---------------------------------------------------------------------------

loc_10010CBC:				; CODE XREF: mwConversation_send+21j
		mov	[esp+28h+var_20], offset aMwconversat_11 ; "mwConversation_isOpen(conv)"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwconversat_10 ; "mwConversation_send"
		mov	[esp+28h+Str], offset aMeanwhile_9 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10010B8C
; ---------------------------------------------------------------------------

loc_10010CE2:				; CODE XREF: mwConversation_send+2Cj
		mov	[esp+28h+var_20], offset aConvChannelNul ; "conv->channel != NULL"
		mov	esi, 0FFFFFFFFh
		mov	[esp+28h+var_24], offset aMwconversat_10 ; "mwConversation_send"
		mov	[esp+28h+Str], offset aMeanwhile_9 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10010B8C
mwConversation_send endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 283. mwServiceIm_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceIm_new
mwServiceIm_new	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		test	esi, esi
		jz	loc_10010DAF
		test	edi, edi
		jz	loc_10010DCF
		mov	[esp+18h+var_18], 44h
		call	g_malloc0
		mov	[esp+18h+var_10], 1000h
		mov	[esp+18h+var_14], esi
		mov	ebx, eax
		mov	[esp+18h+var_18], eax
		call	mwService_init
		mov	dword ptr [ebx+14h], offset sub_10011730
		mov	dword ptr [ebx+18h], offset sub_10010E30
		mov	dword ptr [ebx+1Ch], offset sub_100115E0
		mov	dword ptr [ebx+20h], offset sub_10010E90
		mov	dword ptr [ebx+2Ch], offset sub_100107C0
		mov	dword ptr [ebx+0Ch], offset sub_100101C0
		mov	dword ptr [ebx+10h], offset sub_100101D0
		mov	dword ptr [ebx+24h], offset sub_10010E20
		mov	dword ptr [ebx+28h], offset sub_10010DF0
		mov	dword ptr [ebx+38h], 1
		mov	[ebx+3Ch], edi

loc_10010DA0:				; CODE XREF: mwServiceIm_new+BDj
					; mwServiceIm_new+DDj
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10010DAF:				; CODE XREF: mwServiceIm_new+17j
		mov	[esp+18h+var_10], offset aSessionNull_5	; "session != NULL"
		xor	ebx, ebx
		mov	[esp+18h+var_14], offset aMwserviceim_ne ; "mwServiceIm_new"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10010DA0
; ---------------------------------------------------------------------------

loc_10010DCF:				; CODE XREF: mwServiceIm_new+1Fj
		mov	[esp+18h+var_10], offset aHndlNull ; "hndl != NULL"
		xor	ebx, ebx
		mov	[esp+18h+var_14], offset aMwserviceim_ne ; "mwServiceIm_new"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10010DA0
mwServiceIm_new	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10010DF0	proc near		; DATA XREF: mwServiceIm_new+7Fo

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebx+40h]
		test	eax, eax
		jz	short loc_10010E12

loc_10010E01:				; CODE XREF: sub_10010DF0+20j
		mov	eax, [eax]
		mov	[esp+8+var_8], eax
		call	mwConversation_free
		mov	eax, [ebx+40h]
		test	eax, eax
		jnz	short loc_10010E01

loc_10010E12:				; CODE XREF: sub_10010DF0+Fj
		mov	[ebp+arg_0], ebx
		add	esp, 4
		pop	ebx
		pop	ebp
		jmp	mwService_stopped
sub_10010DF0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10010E20	proc near		; DATA XREF: mwServiceIm_new+78o
		push	ebp
		mov	ebp, esp
		pop	ebp
		jmp	mwService_started
sub_10010E20	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10010E30	proc near		; DATA XREF: mwServiceIm_new+4Eo

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_4]
		mov	[esp+18h+var_18], ebx
		call	mwChannel_getServiceData
		test	eax, eax
		jz	short loc_10010E50
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	sub_10010620
; ---------------------------------------------------------------------------

loc_10010E50:				; CODE XREF: sub_10010E30+14j
		mov	[esp+18h+var_10], offset aReceivedChanne ; "received channel accept for	non-existan"...
		mov	[esp+18h+var_14], 10h
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_log
		mov	[ebp+arg_8], 0
		mov	[ebp+arg_4], 80000000h
		mov	[ebp+arg_0], ebx
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	mwChannel_destroy
sub_10010E30	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10010E90	proc near		; DATA XREF: mwServiceIm_new+5Co

var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_4C		= dword	ptr -4Ch
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_E		= word ptr -0Eh
arg_4		= dword	ptr  0Ch
arg_8		= word ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 4Ch
		cmp	[ebp+arg_8], 64h
		jnz	loc_100112F3
		mov	eax, [ebp+arg_C]
		mov	[esp+58h+var_58], eax
		call	mwGetBuffer_wrap
		mov	esi, eax
		lea	eax, [ebp+var_14]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], esi
		call	guint32_get
		mov	[esp+58h+var_58], esi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_10010FA8
		mov	eax, [ebp+var_14]
		cmp	eax, 1
		jz	short loc_10010F20
		cmp	eax, 2
		jz	loc_10010FD4
		mov	[esp+58h+var_4C], eax
		mov	[esp+58h+var_50], offset aUnknownMessa_5 ; "unknown message type 0x%08x	for IM serv"...
		mov	[esp+58h+var_54], 10h
		mov	[esp+58h+var_58], offset aMeanwhile_9 ;	"meanwhile"
		call	g_log

loc_10010F01:				; CODE XREF: sub_10010E90+ABj
					; sub_10010E90+19Aj ...
		mov	[esp+58h+var_58], esi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	short loc_10010F80

loc_10010F0D:				; CODE XREF: sub_10010E90+EBj
					; sub_10010E90+113j
		mov	[esp+58h+var_58], esi
		call	mwGetBuffer_free

loc_10010F15:				; CODE XREF: sub_10010E90+47Fj
		add	esp, 4Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10010F20:				; CODE XREF: sub_10010E90+46j
		mov	[ebp+var_20], 0
		lea	eax, [ebp+var_20]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], esi
		call	mwString_get
		mov	eax, [ebp+var_20]
		test	eax, eax
		jz	short loc_10010F01
		mov	eax, [ebp+arg_4]
		mov	[esp+58h+var_58], eax
		call	mwChannel_getServiceData
		test	eax, eax
		jz	short loc_10010F66
		mov	edx, [eax+1Ch]
		test	edx, edx
		jz	loc_100110C7
		mov	eax, [ebp+var_20]
		mov	[esp+58h+var_58], edx
		mov	[esp+58h+var_54], eax
		call	g_string_append

loc_10010F66:				; CODE XREF: sub_10010E90+BAj
					; sub_10010E90+241j
		mov	eax, [ebp+var_20]
		mov	[esp+58h+var_58], eax
		call	g_free
		mov	[esp+58h+var_58], esi
		call	mwGetBuffer_error
		test	eax, eax
		jz	short loc_10010F0D
		lea	esi, [esi+0]

loc_10010F80:				; CODE XREF: sub_10010E90+7Bj
		mov	eax, [ebp+var_14]
		mov	[esp+58h+var_50], offset aFailedToParseM ; "failed to parse message type 0x%08x	for"...
		mov	[esp+58h+var_54], 10h
		mov	[esp+58h+var_58], offset aMeanwhile_9 ;	"meanwhile"
		mov	[esp+58h+var_4C], eax
		call	g_log
		jmp	loc_10010F0D
; ---------------------------------------------------------------------------

loc_10010FA8:				; CODE XREF: sub_10010E90+3Aj
		mov	[esp+58h+var_50], offset aFailedToPars_0 ; "failed to parse message for	IM service"
		mov	[esp+58h+var_54], 10h
		mov	[esp+58h+var_58], offset aMeanwhile_9 ;	"meanwhile"
		call	g_log
		mov	[esp+58h+var_58], esi
		call	mwGetBuffer_free
		add	esp, 4Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10010FD4:				; CODE XREF: sub_10010E90+4Bj
		mov	[ebp+var_3C], 0
		lea	eax, [ebp+var_18]
		mov	[ebp+var_38], 0
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], esi
		call	guint32_get
		lea	eax, [ebp+var_1C]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], esi
		call	guint32_get
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], esi
		call	mwOpaque_get
		mov	[esp+58h+var_58], esi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	short loc_10011087
		mov	eax, [ebp+arg_4]
		mov	[esp+58h+var_58], eax
		call	mwChannel_getServiceData
		test	eax, eax
		mov	edi, eax
		jz	loc_10010F01
		mov	edx, [ebp+var_18]
		cmp	edx, 5
		jz	loc_100112A7
		ja	short loc_10011097
		cmp	edx, 3
		jz	loc_1001113E
		mov	esi, esi
		lea	edi, [edi+0]
		jbe	loc_10011121
		mov	eax, [ebp+var_3C]
		test	eax, eax
		nop
		lea	esi, [esi+0]
		jz	short loc_10011087
		mov	edx, [edi+1Ch]
		test	edx, edx
		jz	loc_10011366
		mov	[esp+58h+var_50], eax
		mov	eax, [ebp+var_38]
		mov	[esp+58h+var_58], edx
		mov	[esp+58h+var_54], eax
		call	g_string_append_len
		mov	dword ptr [edi+20h], 2

loc_10011087:				; CODE XREF: sub_10010E90+189j
					; sub_10010E90+1D0j ...
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_58], eax
		call	mwOpaque_clear
		jmp	loc_10010F01
; ---------------------------------------------------------------------------

loc_10011097:				; CODE XREF: sub_10010E90+1ACj
		cmp	edx, 0Ah
		jz	loc_1001116D
		ja	short loc_100110D6
		cmp	edx, 6
		jz	short loc_10011087

loc_100110A7:				; CODE XREF: sub_10010E90+258j
					; sub_10010E90+294j
		mov	eax, [ebp+var_1C]
		mov	[esp+58h+var_50], edx
		mov	[esp+58h+var_54], offset aUnknownDataM_0 ; "unknown data message type in IM service"...
		mov	[esp+58h+var_4C], eax
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_58], eax
		call	mw_mailme_opaque
		jmp	short loc_10011087
; ---------------------------------------------------------------------------

loc_100110C7:				; CODE XREF: sub_10010E90+C1j
		mov	ecx, [ebp+var_20]
		xor	edx, edx
		call	sub_10010460
		jmp	loc_10010F66
; ---------------------------------------------------------------------------

loc_100110D6:				; CODE XREF: sub_10010E90+210j
		cmp	edx, 1388h
		jz	loc_100112D4
		cmp	edx, 1389h
		jnz	short loc_100110A7
		mov	eax, [eax+1Ch]
		test	eax, eax
		nop
		jz	loc_100113CF
		mov	ecx, [eax]
		mov	eax, edi
		mov	edx, [edi+20h]
		call	sub_10010460
		mov	[esp+58h+var_54], 1
		mov	eax, [edi+1Ch]
		mov	[esp+58h+var_58], eax
		call	g_string_free
		mov	dword ptr [edi+1Ch], 0
		jmp	loc_10011087
; ---------------------------------------------------------------------------

loc_10011121:				; CODE XREF: sub_10010E90+1C0j
		cmp	edx, 1
		jnz	short loc_100110A7
		xor	ecx, ecx
		mov	edx, 1
		cmp	[ebp+var_1C], 0
		setz	cl
		call	sub_10010460
		jmp	loc_10011087
; ---------------------------------------------------------------------------

loc_1001113E:				; CODE XREF: sub_10010E90+1B1j
		mov	eax, [ebp+var_3C]
		mov	[esp+58h+var_54], eax
		mov	eax, [ebp+var_38]
		mov	[esp+58h+var_58], eax
		call	g_strndup
		mov	edx, 3
		mov	ebx, eax
		mov	ecx, eax
		mov	eax, edi
		call	sub_10010460
		mov	[esp+58h+var_58], ebx
		call	g_free
		jmp	loc_10011087
; ---------------------------------------------------------------------------

loc_1001116D:				; CODE XREF: sub_10010E90+20Aj
		mov	[esp+58h+var_50], offset aConvo_invite ; "convo_invite"
		mov	[esp+58h+var_54], 40h
		mov	[esp+58h+var_58], offset aMeanwhile_9 ;	"meanwhile"
		call	g_log
		mov	eax, [edi]
		mov	eax, [eax+3Ch]
		test	eax, eax
		mov	[ebp+var_40], eax
		jz	loc_10011432
		mov	eax, [ebp+var_40]
		mov	eax, [eax+0Ch]
		test	eax, eax
		jz	loc_10011411
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_58], eax
		call	mwGetBuffer_wrap
		mov	[esp+58h+var_54], 4
		mov	ebx, eax
		mov	[esp+58h+var_58], eax
		call	mwGetBuffer_advance
		lea	eax, [ebp+var_20]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], ebx
		call	mwString_get
		lea	eax, [ebp+var_28]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], ebx
		call	mwString_get
		mov	[esp+58h+var_54], 13h
		mov	[esp+58h+var_58], ebx
		call	mwGetBuffer_advance
		lea	eax, [ebp+var_24]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], ebx
		call	mwString_get
		lea	eax, [ebp+var_2C]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], ebx
		call	mwString_get
		lea	eax, [ebp+var_30]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], ebx
		call	mwString_get
		mov	eax, [ebp+var_2C]
		mov	[esp+58h+var_58], eax
		call	g_free
		mov	eax, [ebp+var_30]
		mov	[esp+58h+var_58], eax
		call	g_free
		lea	eax, [ebp+var_E]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], ebx
		call	guint16_get
		cmp	[ebp+var_E], 0
		jz	short loc_10011256
		mov	eax, [edi+8]
		test	eax, eax
		jz	loc_10011392

loc_10011256:				; CODE XREF: sub_10010E90+3B9j
					; sub_10010E90+53Aj
		mov	[esp+58h+var_58], ebx
		call	mwGetBuffer_error
		test	eax, eax
		jz	loc_10011314
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_54], offset aProblemWithPla ; "problem with place invite over IM servi"...
		mov	[esp+58h+var_58], eax
		call	mw_mailme_opaque

loc_10011279:				; CODE XREF: sub_10010E90+4A2j
		mov	[esp+58h+var_58], ebx
		call	mwGetBuffer_free
		mov	eax, [ebp+var_28]
		mov	[esp+58h+var_58], eax
		call	g_free
		mov	eax, [ebp+var_20]
		mov	[esp+58h+var_58], eax
		call	g_free
		mov	eax, [ebp+var_24]
		mov	[esp+58h+var_58], eax
		call	g_free
		jmp	loc_10011087
; ---------------------------------------------------------------------------

loc_100112A7:				; CODE XREF: sub_10010E90+1A6j
		mov	edx, [eax+1Ch]
		test	edx, edx
		jz	loc_10011337
		mov	eax, [ebp+var_3C]
		mov	[esp+58h+var_50], eax
		mov	eax, [ebp+var_38]
		mov	[esp+58h+var_58], edx
		mov	[esp+58h+var_54], eax
		call	g_string_append_len
		mov	dword ptr [edi+20h], 4
		jmp	loc_10011087
; ---------------------------------------------------------------------------

loc_100112D4:				; CODE XREF: sub_10010E90+24Cj
		mov	ebx, [eax+1Ch]
		test	ebx, ebx
		jnz	loc_100113F0
		mov	[esp+58h+var_58], 0
		call	g_string_new
		mov	[edi+1Ch], eax
		jmp	loc_10011087
; ---------------------------------------------------------------------------

loc_100112F3:				; CODE XREF: sub_10010E90+Ej
		mov	[esp+58h+var_50], offset aTypeMsg_messag ; "type == msg_MESSAGE"
		mov	[esp+58h+var_54], offset aRecv_3 ; "recv"
		mov	[esp+58h+var_58], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10010F15
; ---------------------------------------------------------------------------

loc_10011314:				; CODE XREF: sub_10010E90+3D0j
		mov	eax, [ebp+var_24]
		mov	[esp+58h+var_4C], eax
		mov	eax, [ebp+var_20]
		mov	[esp+58h+var_50], eax
		mov	eax, [ebp+var_28]
		mov	[esp+58h+var_58], edi
		mov	[esp+58h+var_54], eax
		mov	eax, [ebp+var_40]
		call	dword ptr [eax+0Ch]
		jmp	loc_10011279
; ---------------------------------------------------------------------------

loc_10011337:				; CODE XREF: sub_10010E90+41Cj
		mov	eax, [ebp+var_3C]
		mov	[esp+58h+var_54], eax
		mov	eax, [ebp+var_38]
		mov	[esp+58h+var_58], eax
		call	g_strndup
		mov	edx, 4
		mov	ebx, eax
		mov	ecx, eax
		mov	eax, edi
		call	sub_10010460
		mov	[esp+58h+var_58], ebx
		call	g_free
		jmp	loc_10011087
; ---------------------------------------------------------------------------

loc_10011366:				; CODE XREF: sub_10010E90+1D7j
		mov	[esp+58h+var_54], eax
		mov	eax, [ebp+var_38]
		mov	[esp+58h+var_58], eax
		call	g_strndup
		mov	edx, 2
		mov	ebx, eax
		mov	ecx, eax
		mov	eax, edi
		call	sub_10010460
		mov	[esp+58h+var_58], ebx
		call	g_free
		jmp	loc_10011087
; ---------------------------------------------------------------------------

loc_10011392:				; CODE XREF: sub_10010E90+3C0j
		lea	eax, [edi+8]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], ebx
		call	mwString_get
		lea	eax, [ebp+var_34]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], ebx
		call	mwString_get
		mov	eax, [ebp+var_34]
		mov	[esp+58h+var_58], eax
		call	g_free
		lea	eax, [edi+0Ch]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], ebx
		call	mwString_get
		jmp	loc_10011256
; ---------------------------------------------------------------------------

loc_100113CF:				; CODE XREF: sub_10010E90+260j
		mov	[esp+58h+var_50], offset aConvMultiNull	; "conv->multi != NULL"
		mov	[esp+58h+var_54], offset aConvo_multi_st ; "convo_multi_stop"
		mov	[esp+58h+var_58], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10011087
; ---------------------------------------------------------------------------

loc_100113F0:				; CODE XREF: sub_10010E90+449j
		mov	[esp+58h+var_50], offset aConvMultiNul_0 ; "conv->multi	== NULL"
		mov	[esp+58h+var_54], offset aConvo_multi__0 ; "convo_multi_start"
		mov	[esp+58h+var_58], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10011087
; ---------------------------------------------------------------------------

loc_10011411:				; CODE XREF: sub_10010E90+311j
		mov	[esp+58h+var_50], offset aHandlerPlace_i ; "handler->place_invite != NULL"
		mov	[esp+58h+var_54], offset aConvo_invite_0 ; "convo_invite"
		mov	[esp+58h+var_58], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10011087
; ---------------------------------------------------------------------------

loc_10011432:				; CODE XREF: sub_10010E90+303j
		mov	[esp+58h+var_50], offset aHandlerNull_4	; "handler != NULL"
		mov	[esp+58h+var_54], offset aConvo_invite_0 ; "convo_invite"
		mov	[esp+58h+var_58], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10011087
sub_10010E90	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10011460	proc near		; CODE XREF: sub_100115E0+99j
					; mwConversation_open+2Dj

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h

		push	ebp
		mov	ebp, esp
		push	edi
		mov	edi, eax
		push	esi
		push	ebx
		sub	esp, 0Ch
		test	eax, eax
		jz	loc_1001157F
		mov	[esp+18h+var_18], eax
		call	mwConversation_getState
		sub	eax, 1
		jnz	loc_1001159D
		mov	eax, [edi+4]
		test	eax, eax
		jnz	loc_100115BB
		mov	eax, [edi]
		mov	[esp+18h+var_18], eax
		call	mwService_getSession
		mov	[esp+18h+var_18], eax
		call	mwSession_getChannels
		mov	[esp+18h+var_18], eax
		call	mwChannel_newOutgoing
		mov	esi, eax
		mov	eax, [edi]
		mov	[esp+18h+var_18], esi
		mov	[esp+18h+var_14], eax
		call	mwChannel_setService
		mov	[esp+18h+var_14], 1000h
		mov	[esp+18h+var_18], esi
		call	mwChannel_setProtoType
		mov	[esp+18h+var_14], 3
		mov	[esp+18h+var_18], esi
		call	mwChannel_setProtoVer
		mov	[esp+18h+var_18], esi
		call	mwChannel_populateSupportedCipherInstances
		mov	[esp+18h+var_18], esi
		call	mwChannel_getUser
		mov	ebx, eax
		mov	eax, [edi+8]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[ebx+8], eax
		mov	eax, [edi+0Ch]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[ebx+10h], eax
		call	mwPutBuffer_new
		mov	[esp+18h+var_14], 1
		mov	ebx, eax
		mov	[esp+18h+var_18], eax
		call	guint32_put
		mov	eax, [edi+18h]
		mov	[esp+18h+var_18], ebx
		mov	[esp+18h+var_14], eax
		call	guint32_put
		mov	[esp+18h+var_18], esi
		call	mwChannel_getAddtlCreate
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+var_18], eax
		call	mwPutBuffer_finalize
		mov	[esp+18h+var_18], esi
		call	mwChannel_create
		test	eax, eax
		jnz	short loc_10011570
		test	esi, esi
		mov	[edi+4], esi
		jz	short loc_10011577
		mov	[esp+18h+var_14], edi
		mov	[esp+18h+var_18], esi
		mov	[esp+18h+var_10], 0
		call	mwChannel_setServiceData
		add	esp, 0Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10011570:				; CODE XREF: sub_10011460+EBj
		mov	dword ptr [edi+4], 0

loc_10011577:				; CODE XREF: sub_10011460+F2j
					; sub_10011460+13Bj ...
		add	esp, 0Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1001157F:				; CODE XREF: sub_10011460+Dj
		mov	[esp+18h+var_10], offset aCNull_0 ; "c != NULL"
		mov	[esp+18h+var_14], offset aConvo_create_c ; "convo_create_chan"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10011577
; ---------------------------------------------------------------------------

loc_1001159D:				; CODE XREF: sub_10011460+1Ej
		mov	[esp+18h+var_10], offset aMwconversat_12 ; "mwConversation_isPending(c)"
		mov	[esp+18h+var_14], offset aConvo_create_c ; "convo_create_chan"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10011577
; ---------------------------------------------------------------------------

loc_100115BB:				; CODE XREF: sub_10011460+29j
		mov	[esp+18h+var_10], offset aCChannelNull ; "c->channel ==	NULL"
		mov	[esp+18h+var_14], offset aConvo_create_c ; "convo_create_chan"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10011577
sub_10011460	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100115E0	proc near		; DATA XREF: mwServiceIm_new+55o

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_8]
		mov	[esp+18h+var_18], esi
		call	mwChannel_getServiceData
		test	eax, eax
		mov	ebx, eax
		jz	short loc_1001167E
		mov	dword ptr [eax+4], 0
		mov	[esp+18h+var_18], esi
		call	mwChannel_getState
		cmp	eax, 5
		jz	short loc_10011631

loc_10011617:				; CODE XREF: sub_100115E0+55j
		mov	eax, [edi+10h]

loc_1001161A:				; CODE XREF: sub_100115E0+66j
		mov	[ebp+arg_0], ebx
		mov	esi, [ebp+var_8]
		mov	[ebp+arg_4], eax
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	mwConversation_close
; ---------------------------------------------------------------------------

loc_10011631:				; CODE XREF: sub_100115E0+35j
		cmp	dword ptr [ebx+18h], 1
		jz	short loc_10011617
		mov	eax, [edi+10h]
		cmp	eax, 80002005h
		jz	short loc_10011648
		cmp	eax, 8000000Dh
		jnz	short loc_1001161A

loc_10011648:				; CODE XREF: sub_100115E0+5Fj
		mov	[esp+18h+var_10], offset aFallingBackOnA ; "falling back on a plaintext	conversatio"...
		mov	[esp+18h+var_14], 80h
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_log
		mov	eax, ebx
		mov	dword ptr [ebx+18h], 1
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	sub_10011460
; ---------------------------------------------------------------------------

loc_1001167E:				; CODE XREF: sub_100115E0+21j
		mov	[ebp+arg_8], offset aCNull_0 ; "c != NULL"
		mov	ebx, [ebp+var_C]
		mov	[ebp+arg_4], offset aRecv_channel_0 ; "recv_channelDestroy"
		mov	esi, [ebp+var_8]
		mov	[ebp+arg_0], offset aMeanwhile_9 ; "meanwhile"
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	g_return_if_fail_warning
sub_100115E0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 121. mwConversation_open

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwConversation_open
mwConversation_open proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_100116E2
		mov	[esp+18h+var_18], ebx
		call	mwConversation_getState
		test	eax, eax
		jnz	short loc_10011704
		mov	eax, ebx
		mov	edx, 1
		call	sub_100104D0
		add	esp, 14h
		mov	eax, ebx
		pop	ebx
		pop	ebp
		jmp	sub_10011460
; ---------------------------------------------------------------------------

loc_100116E2:				; CODE XREF: mwConversation_open+Cj
		mov	[esp+18h+var_10], offset aConvNull ; "conv != NULL"
		mov	[esp+18h+var_14], offset aMwconversat_13 ; "mwConversation_open"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning

loc_100116FE:				; CODE XREF: mwConversation_open+70j
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10011704:				; CODE XREF: mwConversation_open+18j
		mov	[esp+18h+var_10], offset aMwconversat_14 ; "mwConversation_isClosed(conv)"
		mov	[esp+18h+var_14], offset aMwconversat_13 ; "mwConversation_open"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100116FE
mwConversation_open endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10011730	proc near		; DATA XREF: mwServiceIm_new+47o

var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 3Ch
		mov	eax, [ebp+arg_0]
		mov	edi, [ebp+arg_4]
		mov	eax, [eax+3Ch]
		mov	[esp+48h+var_48], edi
		mov	[ebp+var_24], eax
		call	mwChannel_getSession
		mov	[esp+48h+var_48], eax
		call	mwSession_getUserStatus
		mov	[esp+48h+var_48], edi
		mov	[ebp+var_20], eax
		call	mwChannel_getServiceId
		mov	[esp+48h+var_48], edi
		mov	[ebp+var_10], eax
		call	mwChannel_getProtoType
		mov	[esp+48h+var_48], edi
		mov	[ebp+var_14], eax
		call	mwChannel_getProtoVer
		mov	edx, [ebp+var_10]
		mov	ecx, [ebp+var_14]
		cmp	edx, 1000h
		jz	short loc_100117D0

loc_10011784:				; CODE XREF: sub_10011730+A6j
					; sub_10011730+ABj
		mov	[esp+48h+var_34], eax
		mov	[esp+48h+var_38], ecx
		mov	[esp+48h+var_3C], edx
		mov	[esp+48h+var_40], offset aUnacceptableSe ; "unacceptable service, proto, ver: 0x%08"...
		mov	[esp+48h+var_44], 10h
		mov	[esp+48h+var_48], offset aMeanwhile_9 ;	"meanwhile"
		call	g_log
		mov	[esp+48h+var_40], 0
		mov	[esp+48h+var_44], 8000000Dh
		mov	[esp+48h+var_48], edi
		call	mwChannel_destroy

loc_100117C4:				; CODE XREF: sub_10011730+13Cj
					; sub_10011730+172j ...
		add	esp, 3Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_100117D0:				; CODE XREF: sub_10011730+52j
		cmp	ecx, 1000h
		jnz	short loc_10011784
		cmp	eax, 3
		jnz	short loc_10011784
		mov	eax, [ebp+arg_8]
		add	eax, 30h
		mov	[esp+48h+var_48], eax
		call	mwGetBuffer_wrap
		mov	ebx, eax
		lea	eax, [ebp+var_10]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], ebx
		call	guint32_get
		lea	eax, [ebp+var_14]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], ebx
		call	guint32_get
		mov	[esp+48h+var_48], ebx
		call	mwGetBuffer_error
		mov	[esp+48h+var_48], ebx
		mov	esi, eax
		call	mwGetBuffer_free
		test	esi, esi
		jnz	loc_100118A7
		mov	edx, [ebp+var_10]
		cmp	edx, 1
		jz	short loc_10011871
		mov	eax, [ebp+var_14]
		mov	[esp+48h+var_3C], edx
		mov	[esp+48h+var_40], offset aUnknownParams0 ; "unknown params: 0x%08x, 0x%08x"
		mov	[esp+48h+var_44], 20h
		mov	[esp+48h+var_38], eax
		mov	[esp+48h+var_48], offset aMeanwhile_9 ;	"meanwhile"
		call	g_log
		mov	[esp+48h+var_40], 0
		mov	[esp+48h+var_44], 80002005h
		mov	[esp+48h+var_48], edi
		call	mwChannel_destroy
		jmp	loc_100117C4
; ---------------------------------------------------------------------------

loc_10011871:				; CODE XREF: sub_10011730+FBj
		mov	eax, [ebp+var_14]
		cmp	eax, 19h
		jz	loc_10011A36
		cmp	eax, 1
		jz	short loc_100118E0
		mov	edx, [ebp+arg_0]
		cmp	eax, [edx+38h]
		jz	short loc_100118E0
		mov	[esp+48h+var_40], 0
		mov	[esp+48h+var_44], 80002005h
		mov	[esp+48h+var_48], edi
		call	mwChannel_destroy
		jmp	loc_100117C4
; ---------------------------------------------------------------------------

loc_100118A7:				; CODE XREF: sub_10011730+EFj
		mov	[esp+48h+var_40], offset aBadMalformed_0 ; "bad/malformed addtl	in IM service"
		mov	[esp+48h+var_44], 10h
		mov	[esp+48h+var_48], offset aMeanwhile_9 ;	"meanwhile"
		call	g_log
		mov	[esp+48h+var_40], 0
		mov	[esp+48h+var_44], 80000000h
		mov	[esp+48h+var_48], edi
		call	mwChannel_destroy
		jmp	loc_100117C4
; ---------------------------------------------------------------------------

loc_100118E0:				; CODE XREF: sub_10011730+150j
					; sub_10011730+158j
		mov	eax, [ebp+var_20]
		cmp	word ptr [eax],	80h
		jz	loc_10011A61

loc_100118EE:				; CODE XREF: sub_10011730+32Cj
		mov	[esp+48h+var_48], edi
		call	mwChannel_getUser
		mov	edx, [eax+8]
		mov	[ebp+var_1C], edx
		mov	eax, [eax+10h]
		mov	[esp+48h+var_48], 2Ch
		mov	[ebp+var_18], eax
		call	g_malloc0
		mov	edx, [ebp+arg_0]
		mov	[ebp+var_28], eax
		mov	[eax], edx
		mov	[esp+48h+var_44], eax
		mov	eax, [edx+40h]
		mov	[esp+48h+var_48], eax
		call	g_list_prepend
		mov	edx, [ebp+arg_0]
		mov	[edx+40h], eax
		mov	eax, [ebp+var_28]
		mov	[eax+4], edi
		lea	eax, [ebp+var_1C]
		mov	[esp+48h+var_44], eax
		mov	eax, [ebp+var_28]
		add	eax, 8
		mov	[esp+48h+var_48], eax
		call	mwIdBlock_clone
		mov	eax, [ebp+var_14]
		mov	edx, [ebp+var_28]
		mov	[edx+18h], eax
		mov	eax, [ebp+var_28]
		mov	edx, 1
		call	sub_100104D0
		mov	eax, [ebp+var_28]
		mov	[esp+48h+var_40], 0
		mov	[esp+48h+var_44], eax
		mov	eax, [eax+4]
		mov	[esp+48h+var_48], eax
		call	mwChannel_setServiceData
		mov	eax, [ebp+var_28]
		mov	edi, [eax+4]
		mov	[esp+48h+var_48], edi
		call	mwChannel_getSession
		mov	[esp+48h+var_48], eax
		call	mwSession_getUserStatus
		mov	ebx, eax
		call	mwPutBuffer_new
		mov	[esp+48h+var_44], 1
		mov	esi, eax
		mov	[esp+48h+var_48], eax
		call	guint32_put
		mov	edx, [ebp+var_28]
		mov	eax, [edx+18h]
		mov	[esp+48h+var_48], esi
		mov	[esp+48h+var_44], eax
		call	guint32_put
		mov	[esp+48h+var_44], 2
		mov	[esp+48h+var_48], esi
		call	guint32_put
		mov	[esp+48h+var_44], ebx
		mov	[esp+48h+var_48], esi
		call	mwUserStatus_put
		mov	[esp+48h+var_48], edi
		call	mwChannel_getAddtlAccept
		mov	ebx, eax
		mov	[esp+48h+var_48], eax
		call	mwOpaque_clear
		mov	[esp+48h+var_44], esi
		mov	[esp+48h+var_48], ebx
		call	mwPutBuffer_finalize
		mov	[esp+48h+var_48], edi
		call	mwChannel_accept
		test	eax, eax
		jz	short loc_10011A29
		mov	[esp+48h+var_40], offset aSendingImChann ; "sending IM channel accept failed"
		mov	[esp+48h+var_44], 10h
		mov	[esp+48h+var_48], offset aMeanwhile_9 ;	"meanwhile"
		call	g_log
		mov	eax, [ebp+var_28]
		mov	[esp+48h+var_48], eax
		call	mwConversation_free
		jmp	loc_100117C4
; ---------------------------------------------------------------------------

loc_10011A29:				; CODE XREF: sub_10011730+2CBj
		mov	eax, [ebp+var_28]
		call	sub_10010620
		jmp	loc_100117C4
; ---------------------------------------------------------------------------

loc_10011A36:				; CODE XREF: sub_10011730+147j
		mov	edx, [ebp+var_24]
		mov	eax, [edx+0Ch]
		test	eax, eax
		jz	short loc_10011A9A
		mov	[esp+48h+var_40], offset aAcceptingPlace ; "accepting place-invite channel"
		mov	[esp+48h+var_44], 40h
		mov	[esp+48h+var_48], offset aMeanwhile_9 ;	"meanwhile"
		call	g_log
		jmp	loc_100118EE
; ---------------------------------------------------------------------------

loc_10011A61:				; CODE XREF: sub_10011730+1B8j
		mov	[esp+48h+var_40], offset aRejectingImCha ; "rejecting IM channel due to	DND status"
		mov	[esp+48h+var_44], 40h
		mov	[esp+48h+var_48], offset aMeanwhile_9 ;	"meanwhile"
		call	g_log
		mov	[esp+48h+var_40], 0
		mov	[esp+48h+var_44], 80002001h
		mov	[esp+48h+var_48], edi
		call	mwChannel_destroy
		jmp	loc_100117C4
; ---------------------------------------------------------------------------

loc_10011A9A:				; CODE XREF: sub_10011730+30Ej
		mov	[esp+48h+var_40], offset aRejectingPlace ; "rejecting place-invite channel"
		mov	[esp+48h+var_44], 40h
		mov	[esp+48h+var_48], offset aMeanwhile_9 ;	"meanwhile"
		call	g_log
		mov	[esp+48h+var_40], 0
		mov	[esp+48h+var_44], 80002005h
		mov	[esp+48h+var_48], edi
		call	mwChannel_destroy
		jmp	loc_100117C4
sub_10011730	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10011AE0	proc near		; CODE XREF: mwServiceIm_getConversation+21p
					; mwServiceIm_findConversation+15j

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h

		push	ebp
		mov	ebp, esp
		push	edi
		mov	edi, edx
		push	esi
		push	ebx
		sub	esp, 0Ch
		mov	ebx, [eax+40h]
		test	ebx, ebx
		jnz	short loc_10011AFB
		jmp	short loc_10011B1A
; ---------------------------------------------------------------------------

loc_10011AF4:				; CODE XREF: sub_10011AE0+2Ej
		mov	ebx, [ebx+4]
		test	ebx, ebx
		jz	short loc_10011B1A

loc_10011AFB:				; CODE XREF: sub_10011AE0+10j
		mov	esi, [ebx]
		mov	[esp+18h+var_14], edi
		lea	eax, [esi+8]
		mov	[esp+18h+var_18], eax
		call	mwIdBlock_equal
		test	eax, eax
		jz	short loc_10011AF4
		add	esp, 0Ch
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10011B1A:				; CODE XREF: sub_10011AE0+12j
					; sub_10011AE0+19j
		xor	esi, esi
		add	esp, 0Ch
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
sub_10011AE0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 281. mwServiceIm_getConversation

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceIm_getConversation
mwServiceIm_getConversation proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_C], ebx
		mov	ebx, [ebp+arg_4]
		mov	[ebp+var_4], edi
		test	esi, esi
		jz	short loc_10011BAB
		test	ebx, ebx
		jz	short loc_10011BCB
		mov	edx, ebx
		mov	eax, esi
		call	sub_10011AE0
		test	eax, eax
		mov	edi, eax
		jz	short loc_10011B6B

loc_10011B5C:				; CODE XREF: mwServiceIm_getConversation+79j
					; mwServiceIm_getConversation+99j ...
		mov	eax, edi
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10011B6B:				; CODE XREF: mwServiceIm_getConversation+2Aj
		mov	[esp+18h+var_18], 2Ch
		call	g_malloc0
		mov	edi, eax
		mov	[eax], esi
		lea	eax, [eax+8]
		mov	[esp+18h+var_18], eax
		mov	[esp+18h+var_14], ebx
		call	mwIdBlock_clone
		mov	eax, [esi+38h]
		mov	dword ptr [edi+14h], 0
		mov	[edi+18h], eax
		mov	[esp+18h+var_14], edi
		mov	eax, [esi+40h]
		mov	[esp+18h+var_18], eax
		call	g_list_prepend
		mov	[esi+40h], eax
		jmp	short loc_10011B5C
; ---------------------------------------------------------------------------

loc_10011BAB:				; CODE XREF: mwServiceIm_getConversation+17j
		mov	[esp+18h+var_10], offset aSrvcNull_5 ; "srvc !=	NULL"
		xor	edi, edi
		mov	[esp+18h+var_14], offset aMwserviceim__1 ; "mwServiceIm_getConversation"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10011B5C
; ---------------------------------------------------------------------------

loc_10011BCB:				; CODE XREF: mwServiceIm_getConversation+1Bj
		mov	[esp+18h+var_10], offset aToNull_0 ; "to != NULL"
		xor	edi, edi
		mov	[esp+18h+var_14], offset aMwserviceim__1 ; "mwServiceIm_getConversation"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10011B5C
mwServiceIm_getConversation endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 279. mwServiceIm_findConversation

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceIm_findConversation
mwServiceIm_findConversation proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	eax, eax
		jz	short loc_10011C0A
		test	edx, edx
		jz	short loc_10011C2A
		leave
		jmp	sub_10011AE0
; ---------------------------------------------------------------------------

loc_10011C0A:				; CODE XREF: mwServiceIm_findConversation+Ej
		mov	[esp+18h+var_10], offset aSrvcNull_5 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwserviceim_fi ; "mwServiceIm_findConversation"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning

locret_10011C26:			; CODE XREF: mwServiceIm_findConversation+56j
		leave
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_10011C2A:				; CODE XREF: mwServiceIm_findConversation+12j
		mov	[esp+18h+var_10], offset aToNull_0 ; "to != NULL"
		mov	[esp+18h+var_14], offset aMwserviceim_fi ; "mwServiceIm_findConversation"
		mov	[esp+18h+var_18], offset aMeanwhile_9 ;	"meanwhile"
		call	g_return_if_fail_warning
		jmp	short locret_10011C26
mwServiceIm_findConversation endp

; ---------------------------------------------------------------------------
		align 10h
		push	ebp
		mov	ebp, esp
		mov	edx, [ebp+8]
		pop	ebp
		mov	ds:dword_10021044, 0
		mov	eax, [edx+10h]
		mov	ds:dword_10021030, eax
		movzx	eax, word ptr [edx+18h]
		mov	ds:word_10021034, ax
		mov	eax, [edx+8]
		mov	ds:dword_10021038, eax
		mov	eax, [edx+14h]
		mov	ds:dword_1002103C, eax
		mov	eax, [edx+0Ch]
		mov	ds:dword_10021040, eax
		mov	eax, offset dword_10021030
		retn
; ---------------------------------------------------------------------------
		jmp	short sub_10011CA0
; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10011CA0	proc near		; CODE XREF: .text:10011C91j
					; DATA XREF: mwServicePlace_new+77o
		push	ebp
		mov	eax, offset aPlacesConferen ; "Places Conferencing"
		mov	ebp, esp
		pop	ebp
		retn
sub_10011CA0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10011CB0	proc near		; DATA XREF: mwServicePlace_new+7Eo
		push	ebp
		mov	eax, offset aBarebonesConfe ; "Barebones conferencing via Places"
		mov	ebp, esp
		pop	ebp
		retn
sub_10011CB0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 206. mwPlace_getService

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwPlace_getService
mwPlace_getService proc	near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10011CD1
		mov	eax, [eax]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10011CD1:				; CODE XREF: mwPlace_getService+Bj
		mov	[esp+18h+var_10], offset aPlaceNull ; "place !=	NULL"
		mov	[esp+18h+var_14], offset aMwplace_getser ; "mwPlace_getService"
		mov	[esp+18h+var_18], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwPlace_getService endp

; ---------------------------------------------------------------------------
		jmp	short mwServicePlace_getPlaces
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 287. mwServicePlace_getPlaces

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServicePlace_getPlaces
mwServicePlace_getPlaces proc near	; CODE XREF: .text:10011CF1j

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10011D12
		mov	eax, [eax+3Ch]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10011D12:				; CODE XREF: mwServicePlace_getPlaces+Bj
		mov	[esp+18h+var_10], offset aSrvcNull_6 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwserviceplace ; "mwServicePlace_getPlaces"
		mov	[esp+18h+var_18], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwServicePlace_getPlaces endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 286. mwServicePlace_getHandler

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServicePlace_getHandler
mwServicePlace_getHandler proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10011D52
		mov	eax, [eax+38h]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10011D52:				; CODE XREF: mwServicePlace_getHandler+Bj
		mov	[esp+18h+var_10], offset aSrvcNull_6 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwservicepla_0 ; "mwServicePlace_getHandler"
		mov	[esp+18h+var_18], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwServicePlace_getHandler endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 211. mwPlace_removeClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwPlace_removeClientData
mwPlace_removeClientData proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10011D99
		add	eax, 24h
		mov	[ebp+arg_0], eax
		leave
		jmp	mw_datum_clear
; ---------------------------------------------------------------------------

loc_10011D99:				; CODE XREF: mwPlace_removeClientData+Bj
		mov	[esp+18h+var_10], offset aPlaceNull ; "place !=	NULL"
		mov	[esp+18h+var_14], offset aMwplace_remove ; "mwPlace_removeClientData"
		mov	[esp+18h+var_18], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwPlace_removeClientData endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 203. mwPlace_getClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwPlace_getClientData
mwPlace_getClientData proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10011DD9
		add	eax, 24h
		mov	[ebp+arg_0], eax
		leave
		jmp	mw_datum_get
; ---------------------------------------------------------------------------

loc_10011DD9:				; CODE XREF: mwPlace_getClientData+Bj
		mov	[esp+18h+var_10], offset aPlaceNull ; "place !=	NULL"
		mov	[esp+18h+var_14], offset aMwplace_getcli ; "mwPlace_getClientData"
		mov	[esp+18h+var_18], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwPlace_getClientData endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 214. mwPlace_setClientData

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwPlace_setClientData
mwPlace_setClientData proc near

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	edx, [ebp+arg_8]
		test	eax, eax
		jz	short loc_10011E22
		add	eax, 24h
		mov	[ebp+arg_8], edx
		mov	[ebp+arg_4], ecx
		mov	[ebp+arg_0], eax
		pop	ebp
		jmp	mw_datum_set
; ---------------------------------------------------------------------------

loc_10011E22:				; CODE XREF: mwPlace_setClientData+Ej
		mov	[ebp+arg_8], offset aPlaceNull ; "place	!= NULL"
		mov	[ebp+arg_4], offset aMwplace_setcli ; "mwPlace_setClientData"
		mov	[ebp+arg_0], offset aMeanwhile_10 ; "meanwhile"
		pop	ebp
		jmp	g_return_if_fail_warning
mwPlace_setClientData endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 215. mwPlace_unsetAttribute

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwPlace_unsetAttribute
mwPlace_unsetAttribute proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_C], ebx
		mov	[ebp+var_8], esi
		lea	esi, [ebp+var_14]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_0]
		mov	[ebp+var_14], 0
		mov	[ebp+var_10], 0
		call	mwPutBuffer_new
		mov	ebx, eax
		mov	eax, [edi+18h]
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	guint32_put
		mov	eax, [ebp+arg_4]
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	guint32_put
		mov	[esp+28h+var_20], esi
		mov	[esp+28h+var_24], 0Ah
		mov	eax, [edi+8]
		mov	[esp+28h+var_28], eax
		call	mwChannel_send
		mov	[esp+28h+var_28], esi
		mov	ebx, eax
		call	mwOpaque_clear
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
mwPlace_unsetAttribute endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 213. mwPlace_setAttribute

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwPlace_setAttribute
mwPlace_setAttribute proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_C], ebx
		mov	[ebp+var_8], esi
		lea	esi, [ebp+var_14]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_0]
		mov	[ebp+var_14], 0
		mov	[ebp+var_10], 0
		call	mwPutBuffer_new
		mov	ebx, eax
		mov	eax, [edi+18h]
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	guint32_put
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], 0
		call	guint32_put
		mov	eax, [ebp+arg_4]
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	guint32_put
		mov	eax, [ebp+arg_8]
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	mwOpaque_put
		mov	[esp+28h+var_20], esi
		mov	[esp+28h+var_24], 0Ah
		mov	eax, [edi+8]
		mov	[esp+28h+var_28], eax
		call	mwChannel_send
		mov	[esp+28h+var_28], esi
		mov	ebx, eax
		call	mwOpaque_clear
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
mwPlace_setAttribute endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 208. mwPlace_legacyInvite

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl mwPlace_legacyInvite(int,	int, char *)
		public mwPlace_legacyInvite
mwPlace_legacyInvite proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 20h
		mov	esi, [ebp+arg_4]
		mov	[ebp+var_10], 0
		mov	[ebp+var_C], 0
		call	mwPutBuffer_new
		mov	[esp+28h+var_24], esi
		mov	ebx, eax
		mov	[esp+28h+var_28], eax
		call	mwIdBlock_put
		mov	eax, [esi]
		mov	[esp+28h+var_28], ebx ;	int
		mov	[esp+28h+var_24], eax ;	char *
		call	mwString_put
		mov	eax, [esi]
		mov	[esp+28h+var_28], ebx ;	int
		mov	[esp+28h+var_24], eax ;	char *
		call	mwString_put
		mov	eax, [ebp+arg_8]
		mov	[esp+28h+var_28], ebx ;	int
		mov	[esp+28h+var_24], eax ;	char *
		call	mwString_put
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], 0
		call	gboolean_put
		mov	[esp+28h+var_24], ebx
		lea	ebx, [ebp+var_10]
		mov	[esp+28h+var_28], ebx
		call	mwPutBuffer_finalize
		mov	eax, [ebp+arg_0]
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_24], 5
		mov	eax, [eax+8]
		mov	[esp+28h+var_28], eax
		call	mwChannel_send
		mov	[esp+28h+var_28], ebx
		mov	esi, eax
		call	mwOpaque_clear
		add	esp, 20h
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	ebp
		retn
mwPlace_legacyInvite endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 212. mwPlace_sendText

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl mwPlace_sendText(int, char *)
		public mwPlace_sendText
mwPlace_sendText proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_C], ebx
		mov	[ebp+var_8], esi
		lea	esi, [ebp+var_14]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_0]
		mov	[ebp+var_14], 0
		mov	[ebp+var_10], 0
		call	mwPutBuffer_new
		mov	[esp+28h+var_24], 1
		mov	ebx, eax
		mov	[esp+28h+var_28], eax
		call	guint32_put
		mov	eax, [ebp+arg_4]
		mov	[esp+28h+var_28], ebx ;	int
		mov	[esp+28h+var_24], eax ;	char *
		call	mwString_put
		mov	[esp+28h+var_24], ebx
		mov	[esp+28h+var_28], esi
		call	mwPutBuffer_finalize
		call	mwPutBuffer_new
		mov	ebx, eax
		mov	eax, [edi+1Ch]
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	guint32_put
		mov	[esp+28h+var_24], esi
		mov	[esp+28h+var_28], ebx
		call	mwOpaque_put
		mov	[esp+28h+var_28], esi
		call	mwOpaque_clear
		mov	[esp+28h+var_24], ebx
		mov	[esp+28h+var_28], esi
		call	mwPutBuffer_finalize
		mov	[esp+28h+var_20], esi
		mov	[esp+28h+var_24], 3
		mov	eax, [edi+8]
		mov	[esp+28h+var_28], eax
		call	mwChannel_send
		mov	[esp+28h+var_28], esi
		mov	ebx, eax
		call	mwOpaque_clear
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
mwPlace_sendText endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 204. mwPlace_getMembers

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwPlace_getMembers
mwPlace_getMembers proc	near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10012157
		mov	eax, [eax+14h]
		test	eax, eax
		jz	loc_10012177
		mov	[esp+28h+var_28], eax
		call	map_collect_values
		test	eax, eax
		mov	edi, eax
		jz	short loc_1001214D
		mov	esi, eax
		nop
		lea	esi, [esi+0]

loc_10012100:				; CODE XREF: mwPlace_getMembers+7Bj
		mov	ecx, [esi]
		mov	ebx, offset aNull_6 ; "(null)"
		mov	edx, [ecx+0Ch]
		lea	eax, [ecx+8]
		mov	[esi], eax
		mov	eax, [ecx+8]
		test	edx, edx
		cmovz	edx, ebx
		test	eax, eax
		cmovz	eax, ebx
		mov	[esp+28h+var_14], edx
		mov	[esp+28h+var_18], eax
		mov	eax, [ecx]
		mov	[esp+28h+var_20], offset aCollectedMembe ; "collected member %u: %s, %s"
		mov	[esp+28h+var_24], 40h
		mov	[esp+28h+var_28], offset aMeanwhile_10 ; "meanwhile"
		mov	[esp+28h+var_1C], eax
		call	g_log
		mov	esi, [esi+4]
		test	esi, esi
		jnz	short loc_10012100

loc_1001214D:				; CODE XREF: mwPlace_getMembers+27j
					; mwPlace_getMembers+A5j ...
		add	esp, 1Ch
		mov	eax, edi
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10012157:				; CODE XREF: mwPlace_getMembers+Ej
		mov	[esp+28h+var_20], offset aPlaceNull ; "place !=	NULL"
		xor	edi, edi
		mov	[esp+28h+var_24], offset aMwplace_getmem ; "mwPlace_getMembers"
		mov	[esp+28h+var_28], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1001214D
; ---------------------------------------------------------------------------

loc_10012177:				; CODE XREF: mwPlace_getMembers+15j
		mov	[esp+28h+var_20], offset aPlaceMembersNu ; "place->members != NULL"
		xor	edi, edi
		mov	[esp+28h+var_24], offset aMwplace_getmem ; "mwPlace_getMembers"
		mov	[esp+28h+var_28], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1001214D
mwPlace_getMembers endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100121A0	proc near		; CODE XREF: sub_10012250+Ep
					; mwPlace_destroy+18p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		test	eax, eax
		jz	loc_1001222C
		cmp	[eax+4], edx
		jz	short locret_100121F1
		cmp	edx, 6		; switch 7 cases
		mov	ecx, offset aUnknown_4 ; "UNKNOWN"
		mov	[eax+4], edx
		jbe	short loc_100121F3

loc_100121C0:				; CODE XREF: sub_100121A0+60j
					; sub_100121A0+67j ...
		mov	eax, [eax+0Ch]	; jumptable 100121F3 default case
		mov	edx, offset aNull_6 ; "(null)"
		mov	[esp+18h+var_8], ecx
		mov	[esp+18h+var_10], offset aPlaceSStateS ; "place	%s state: %s"
		mov	[esp+18h+var_14], 20h
		test	eax, eax
		cmovz	eax, edx
		mov	[esp+18h+var_C], eax
		mov	[esp+18h+var_18], offset aMeanwhile_10 ; "meanwhile"
		call	g_log

locret_100121F1:			; CODE XREF: sub_100121A0+11j
		leave
		retn
; ---------------------------------------------------------------------------

loc_100121F3:				; CODE XREF: sub_100121A0+1Ej
		jmp	ds:off_1001FC80[edx*4] ; switch	jump
; ---------------------------------------------------------------------------

loc_100121FA:				; CODE XREF: sub_100121A0:loc_100121F3j
					; DATA XREF: .rdata:off_1001FC80o
		mov	ecx, offset aError_2 ; jumptable 100121F3 case 6
		nop
		jmp	short loc_100121C0 ; jumptable 100121F3	default	case
; ---------------------------------------------------------------------------

loc_10012202:				; CODE XREF: sub_100121A0:loc_100121F3j
					; DATA XREF: .rdata:off_1001FC80o
		mov	ecx, offset aClosing_1 ; jumptable 100121F3 case 5
		jmp	short loc_100121C0 ; jumptable 100121F3	default	case
; ---------------------------------------------------------------------------

loc_10012209:				; CODE XREF: sub_100121A0:loc_100121F3j
					; DATA XREF: .rdata:off_1001FC80o
		mov	ecx, offset aOpen_3 ; jumptable	100121F3 case 4
		jmp	short loc_100121C0 ; jumptable 100121F3	default	case
; ---------------------------------------------------------------------------

loc_10012210:				; CODE XREF: sub_100121A0:loc_100121F3j
					; DATA XREF: .rdata:off_1001FC80o
		mov	ecx, offset aJoined ; jumptable	100121F3 case 3
		jmp	short loc_100121C0 ; jumptable 100121F3	default	case
; ---------------------------------------------------------------------------

loc_10012217:				; CODE XREF: sub_100121A0:loc_100121F3j
					; DATA XREF: .rdata:off_1001FC80o
		mov	ecx, offset aJoining ; jumptable 100121F3 case 2
		jmp	short loc_100121C0 ; jumptable 100121F3	default	case
; ---------------------------------------------------------------------------

loc_1001221E:				; CODE XREF: sub_100121A0:loc_100121F3j
					; DATA XREF: .rdata:off_1001FC80o
		mov	ecx, offset aPending_2 ; jumptable 100121F3 case 1
		jmp	short loc_100121C0 ; jumptable 100121F3	default	case
; ---------------------------------------------------------------------------

loc_10012225:				; CODE XREF: sub_100121A0:loc_100121F3j
					; DATA XREF: .rdata:off_1001FC80o
		mov	ecx, offset aNew_2 ; jumptable 100121F3	case 0
		jmp	short loc_100121C0 ; jumptable 100121F3	default	case
; ---------------------------------------------------------------------------

loc_1001222C:				; CODE XREF: sub_100121A0+8j
		mov	[esp+18h+var_10], offset aPlaceNull ; "place !=	NULL"
		mov	[esp+18h+var_14], offset aPlace_state ;	"place_state"
		mov	[esp+18h+var_18], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
sub_100121A0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10012250	proc near		; CODE XREF: sub_10012AC0+560p

var_8		= dword	ptr -8

		push	ebp
		mov	edx, 4
		mov	ebp, esp
		push	ebx
		mov	ebx, eax
		sub	esp, 4
		call	sub_100121A0
		mov	eax, [ebx]
		mov	eax, [eax+38h]
		test	eax, eax
		jz	short loc_10012277
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_10012277
		mov	[esp+8+var_8], ebx
		call	eax

loc_10012277:				; CODE XREF: sub_10012250+1Aj
					; sub_10012250+20j
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
sub_10012250	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10012280	proc near		; CODE XREF: mwPlace_destroy+46p
					; sub_10012360+24p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		mov	ebx, eax
		sub	esp, 10h
		test	eax, eax
		jz	short loc_100122DA
		mov	esi, [eax]
		test	esi, esi
		jz	short loc_100122E1
		mov	[esp+18h+var_14], eax
		mov	eax, [esi+3Ch]
		mov	[esp+18h+var_18], eax
		call	g_list_remove_all
		mov	[esi+3Ch], eax
		lea	eax, [ebx+24h]
		mov	[esp+18h+var_18], eax
		call	mw_datum_clear
		mov	eax, [ebx+14h]
		mov	[esp+18h+var_18], eax
		call	g_hash_table_destroy
		mov	eax, [ebx+0Ch]
		mov	[esp+18h+var_18], eax
		call	g_free
		mov	eax, [ebx+10h]
		mov	[esp+18h+var_18], eax
		call	g_free
		mov	[esp+18h+var_18], ebx
		call	g_free

loc_100122DA:				; CODE XREF: sub_10012280+Cj
					; sub_10012280+7Dj
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100122E1:				; CODE XREF: sub_10012280+12j
		mov	[esp+18h+var_10], offset aSrvcNull_6 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aPlace_free ; "place_free"
		mov	[esp+18h+var_18], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100122DA
sub_10012280	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 202. mwPlace_destroy

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwPlace_destroy
mwPlace_destroy	proc near		; CODE XREF: sub_10012900+6Aj
					; sub_100133C0+1Ep

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	edx, 5
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_4], esi
		xor	esi, esi
		mov	eax, ebx
		call	sub_100121A0
		mov	eax, [ebx+8]
		test	eax, eax
		jz	short loc_10012344
		mov	edx, [ebp+arg_4]
		mov	[esp+18h+var_10], 0
		mov	[esp+18h+var_18], eax
		mov	[esp+18h+var_14], edx
		call	mwChannel_destroy
		mov	dword ptr [ebx+8], 0
		mov	esi, eax

loc_10012344:				; CODE XREF: mwPlace_destroy+22j
		mov	eax, ebx
		call	sub_10012280
		mov	eax, esi
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
mwPlace_destroy	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10012360	proc near		; DATA XREF: mwServicePlace_new+70o

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebx+38h]
		test	eax, eax
		jz	short loc_10012389
		mov	eax, [eax+1Ch]
		test	eax, eax
		jz	short loc_10012389
		mov	[esp+8+var_8], ebx
		call	eax
		lea	esi, [esi+0]
		jmp	short loc_10012389
; ---------------------------------------------------------------------------

loc_10012382:				; CODE XREF: sub_10012360+30j
		mov	eax, [eax]
		call	sub_10012280

loc_10012389:				; CODE XREF: sub_10012360+Fj
					; sub_10012360+16j ...
		mov	eax, [ebx+3Ch]
		test	eax, eax
		xchg	ax, ax
		jnz	short loc_10012382
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
sub_10012360	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 207. mwPlace_getTitle

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwPlace_getTitle
mwPlace_getTitle proc near		; CODE XREF: mwPlace_open+9Cp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		test	esi, esi
		jz	short loc_10012421
		mov	ebx, [esi+10h]
		test	ebx, ebx
		jz	short loc_100123C6

loc_100123BA:				; CODE XREF: mwPlace_getTitle+78j
		mov	eax, ebx

loc_100123BC:				; CODE XREF: mwPlace_getTitle+9Fj
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100123C6:				; CODE XREF: mwPlace_getTitle+18j
		mov	eax, [esi]
		mov	[esp+18h+var_18], eax
		call	mwService_getSession
		mov	[esp+18h+var_18], eax
		call	mwSession_getLoginInfo
		test	eax, eax
		jz	short loc_1001241A
		mov	eax, [eax+0Ch]
		test	eax, eax
		jz	short loc_1001241A

loc_100123E3:				; CODE XREF: mwPlace_getTitle+7Fj
		mov	[esp+18h+var_14], eax
		mov	[esp+18h+var_18], offset aSSConference ; "%s's Conference"
		call	g_strdup_printf
		mov	[esp+18h+var_10], offset aGeneratedConfe ; "generated conference title:	%s"
		mov	[esp+18h+var_14], 80h
		mov	[esp+18h+var_18], offset aMeanwhile_10 ; "meanwhile"
		mov	ebx, eax
		mov	[esp+18h+var_C], eax
		call	g_log
		mov	[esi+10h], ebx
		jmp	short loc_100123BA
; ---------------------------------------------------------------------------

loc_1001241A:				; CODE XREF: mwPlace_getTitle+3Aj
					; mwPlace_getTitle+41j
		mov	eax, offset aMeanwhile_11 ; "Meanwhile"
		jmp	short loc_100123E3
; ---------------------------------------------------------------------------

loc_10012421:				; CODE XREF: mwPlace_getTitle+11j
		mov	[esp+18h+var_10], offset aPlaceNull ; "place !=	NULL"
		mov	[esp+18h+var_14], offset aMwplace_gettit ; "mwPlace_getTitle"
		mov	[esp+18h+var_18], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		jmp	loc_100123BC
mwPlace_getTitle endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 205. mwPlace_getName

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwPlace_getName
mwPlace_getName	proc near		; CODE XREF: mwPlace_open+88p

Seed		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_C], ebx
		mov	[ebp+var_4], edi
		test	esi, esi
		jz	loc_10012539
		mov	ebx, [esi+0Ch]
		test	ebx, ebx
		jz	short loc_10012480

loc_10012471:				; CODE XREF: mwPlace_getName+D8j
		mov	eax, ebx

loc_10012473:				; CODE XREF: mwPlace_getName+107j
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10012480:				; CODE XREF: mwPlace_getName+1Fj
		mov	eax, [esi]
		mov	[esp+28h+Seed],	eax
		call	mwService_getSession
		mov	[esp+28h+Seed],	eax
		call	mwSession_getLoginInfo
		test	eax, eax
		jz	loc_1001252D
		mov	eax, [eax+8]
		test	eax, eax
		mov	[ebp+var_10], eax
		jz	loc_1001252D

loc_100124A8:				; CODE XREF: mwPlace_getName+E4j
		call	clock
		mov	ebx, eax
		call	rand
		add	eax, ebx
		mov	[esp+28h+Seed],	eax ; Seed
		call	srand
		call	rand
		mov	ebx, eax
		call	rand
		mov	[esp+28h+Seed],	0 ; Time
		mov	edi, eax
		call	time
		movzx	edx, bl
		mov	ecx, edi
		and	ecx, 0FFh
		shl	edx, 8
		or	edx, ecx
		mov	[esp+28h+var_1C], edx
		mov	[esp+28h+Seed],	offset aS08x04x_0 ; "%s(%08x,%04x)"
		mov	[esp+28h+var_20], eax
		mov	eax, [ebp+var_10]
		mov	[esp+28h+var_24], eax
		call	g_strdup_printf
		mov	[esp+28h+var_20], offset aGeneratedRan_0 ; "generated random conference	name: '%s'"
		mov	[esp+28h+var_24], 80h
		mov	[esp+28h+Seed],	offset aMeanwhile_10 ; "meanwhile"
		mov	ebx, eax
		mov	[esp+28h+var_1C], eax
		call	g_log
		mov	[esi+0Ch], ebx
		jmp	loc_10012471
; ---------------------------------------------------------------------------

loc_1001252D:				; CODE XREF: mwPlace_getName+44j
					; mwPlace_getName+52j
		mov	[ebp+var_10], offset aMeanwhile_10 ; "meanwhile"
		jmp	loc_100124A8
; ---------------------------------------------------------------------------

loc_10012539:				; CODE XREF: mwPlace_getName+14j
		mov	[esp+28h+var_20], offset aPlaceNull ; "place !=	NULL"
		mov	[esp+28h+var_24], offset aMwplace_getnam ; "mwPlace_getName"
		mov	[esp+28h+Seed],	offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		jmp	loc_10012473
mwPlace_getName	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 210. mwPlace_open

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwPlace_open
mwPlace_open	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		mov	edi, [ebp+arg_0]
		test	edi, edi
		jz	loc_10012686
		mov	eax, [edi]
		test	eax, eax
		jz	loc_100126A9
		mov	[esp+18h+var_18], eax
		call	mwService_getSession
		test	eax, eax
		jz	loc_100126CC
		mov	[esp+18h+var_18], eax
		call	mwSession_getChannels
		test	eax, eax
		jz	loc_100126F2
		mov	[esp+18h+var_18], eax
		call	mwChannel_newOutgoing
		mov	esi, eax
		mov	eax, [edi]
		mov	[esp+18h+var_18], esi
		mov	[esp+18h+var_14], eax
		call	mwChannel_setService
		mov	[esp+18h+var_14], 0
		mov	[esp+18h+var_18], esi
		call	mwChannel_setProtoType
		mov	[esp+18h+var_14], 5
		mov	[esp+18h+var_18], esi
		call	mwChannel_setProtoVer
		mov	[esp+18h+var_18], esi
		call	mwChannel_populateSupportedCipherInstances
		call	mwPutBuffer_new
		mov	[esp+18h+var_18], edi
		mov	ebx, eax
		call	mwPlace_getName
		mov	[esp+18h+var_18], ebx ;	int
		mov	[esp+18h+var_14], eax ;	char *
		call	mwString_put
		mov	[esp+18h+var_18], edi
		call	mwPlace_getTitle
		mov	[esp+18h+var_18], ebx ;	int
		mov	[esp+18h+var_14], eax ;	char *
		call	mwString_put
		mov	[esp+18h+var_18], ebx
		mov	[esp+18h+var_14], 0
		call	guint32_put
		mov	[esp+18h+var_18], esi
		call	mwChannel_getAddtlCreate
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+var_18], eax
		call	mwPutBuffer_finalize
		mov	[esp+18h+var_18], esi
		call	mwChannel_create
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_10012670
		mov	edx, 1
		mov	eax, edi
		call	sub_100121A0
		mov	[edi+8], esi
		mov	[esp+18h+var_10], 0
		mov	[esp+18h+var_14], edi
		mov	[esp+18h+var_18], esi
		call	mwChannel_setServiceData

loc_10012662:				; CODE XREF: mwPlace_open+147j
					; mwPlace_open+16Aj ...
		add	esp, 0Ch
		mov	eax, ebx
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10012670:				; CODE XREF: mwPlace_open+DDj
		mov	eax, edi
		mov	edx, 6
		call	sub_100121A0
		add	esp, 0Ch
		mov	eax, ebx
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10012686:				; CODE XREF: mwPlace_open+Ej
		mov	[esp+18h+var_10], offset aPNull	; "p !=	NULL"
		mov	ebx, 0FFFFFFFFh
		mov	[esp+18h+var_14], offset aMwplace_open ; "mwPlace_open"
		mov	[esp+18h+var_18], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10012662
; ---------------------------------------------------------------------------

loc_100126A9:				; CODE XREF: mwPlace_open+18j
		mov	[esp+18h+var_10], offset aPServiceNull ; "p->service !=	NULL"
		mov	ebx, 0FFFFFFFFh
		mov	[esp+18h+var_14], offset aMwplace_open ; "mwPlace_open"
		mov	[esp+18h+var_18], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10012662
; ---------------------------------------------------------------------------

loc_100126CC:				; CODE XREF: mwPlace_open+28j
		mov	[esp+18h+var_10], offset aSessionNull_6	; "session != NULL"
		mov	ebx, 0FFFFFFFFh
		mov	[esp+18h+var_14], offset aMwplace_open ; "mwPlace_open"
		mov	[esp+18h+var_18], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10012662
; ---------------------------------------------------------------------------

loc_100126F2:				; CODE XREF: mwPlace_open+38j
		mov	[esp+18h+var_10], offset aCsNull_0 ; "cs != NULL"
		mov	ebx, 0FFFFFFFFh
		mov	[esp+18h+var_14], offset aMwplace_open ; "mwPlace_open"
		mov	[esp+18h+var_18], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10012662
mwPlace_open	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 209. mwPlace_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwPlace_new
mwPlace_new	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_0]
		test	esi, esi
		jz	short loc_100127A4
		mov	[esp+18h+var_18], 2Ch
		call	g_malloc0
		mov	ebx, eax
		mov	[eax], esi
		mov	eax, [ebp+arg_4]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[ebx+0Ch], eax
		mov	eax, [ebp+arg_8]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	dword ptr [ebx+4], 0
		mov	[ebx+10h], eax
		mov	[esp+18h+var_C], offset	sub_100127D0
		mov	[esp+18h+var_10], 0
		mov	[esp+18h+var_14], offset loc_1001A918
		mov	[esp+18h+var_18], offset loc_1001A910
		call	g_hash_table_new_full
		mov	[ebx+14h], eax
		mov	[esp+18h+var_14], ebx
		mov	eax, [esi+3Ch]
		mov	[esp+18h+var_18], eax
		call	g_list_prepend
		mov	[esi+3Ch], eax

loc_1001279B:				; CODE XREF: mwPlace_new+A2j
		add	esp, 10h
		mov	eax, ebx
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100127A4:				; CODE XREF: mwPlace_new+Dj
		mov	[esp+18h+var_10], offset aSrvcNull_6 ; "srvc !=	NULL"
		xor	ebx, ebx
		mov	[esp+18h+var_14], offset aMwplace_new ;	"mwPlace_new"
		mov	[esp+18h+var_18], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1001279B
mwPlace_new	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100127D0	proc near		; DATA XREF: mwPlace_new+42o

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		lea	eax, [ebx+8]
		mov	[esp+8+var_8], eax
		call	mwIdBlock_clear
		mov	eax, [ebx+10h]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	eax, [ebx+14h]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	eax, [ebx+24h]
		mov	[esp+8+var_8], eax
		call	g_free
		mov	[ebp+arg_0], ebx
		add	esp, 4
		pop	ebx
		pop	ebp
		jmp	g_free
sub_100127D0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 288. mwServicePlace_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServicePlace_new
mwServicePlace_new proc	near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_0]
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		test	edi, edi
		jz	short loc_100128B4
		test	esi, esi
		jz	loc_100128D4
		mov	[esp+18h+var_18], 40h
		call	g_malloc0
		mov	ebx, eax
		mov	[eax+38h], esi
		mov	[esp+18h+var_10], 80000022h
		mov	[esp+18h+var_14], edi
		mov	[esp+18h+var_18], eax
		call	mwService_init
		mov	dword ptr [ebx+24h], 0
		mov	dword ptr [ebx+28h], offset sub_100133C0
		mov	dword ptr [ebx+14h], 0
		mov	dword ptr [ebx+18h], offset sub_100129A0
		mov	dword ptr [ebx+1Ch], offset sub_10012900
		mov	dword ptr [ebx+20h], offset sub_10012AC0
		mov	dword ptr [ebx+2Ch], offset sub_10012360
		mov	dword ptr [ebx+0Ch], offset sub_10011CA0
		mov	dword ptr [ebx+10h], offset sub_10011CB0

loc_100128A5:				; CODE XREF: mwServicePlace_new+B2j
					; mwServicePlace_new+D2j
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100128B4:				; CODE XREF: mwServicePlace_new+17j
		mov	[esp+18h+var_10], offset aSessionNull_6	; "session != NULL"
		xor	ebx, ebx
		mov	[esp+18h+var_14], offset aMwservicepla_1 ; "mwServicePlace_new"
		mov	[esp+18h+var_18], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100128A5
; ---------------------------------------------------------------------------

loc_100128D4:				; CODE XREF: mwServicePlace_new+1Bj
		mov	[esp+18h+var_10], offset aHandlerNull_5	; "handler != NULL"
		xor	ebx, ebx
		mov	[esp+18h+var_14], offset aMwservicepla_1 ; "mwServicePlace_new"
		mov	[esp+18h+var_18], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100128A5
mwServicePlace_new endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10012900	proc near		; DATA XREF: mwServicePlace_new+62o

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		mov	edi, [ebp+arg_8]
		test	esi, esi
		jz	short loc_1001296F
		mov	[esp+18h+var_18], eax
		call	mwChannel_getServiceData
		test	eax, eax
		mov	ebx, eax
		jz	short loc_10012995
		mov	edx, 6
		call	sub_100121A0
		mov	eax, [esi+38h]
		mov	dword ptr [ebx+8], 0
		test	eax, eax
		jz	short loc_10012955
		mov	edx, [eax+4]
		test	edx, edx
		jz	short loc_10012955
		mov	eax, [edi+10h]
		mov	[esp+18h+var_18], ebx
		mov	[esp+18h+var_14], eax
		call	edx

loc_10012955:				; CODE XREF: sub_10012900+40j
					; sub_10012900+47j
		mov	eax, [edi+10h]
		mov	esi, [ebp+var_8]
		mov	[ebp+arg_0], ebx
		mov	edi, [ebp+var_4]
		mov	ebx, [ebp+var_C]
		mov	[ebp+arg_4], eax
		mov	esp, ebp
		pop	ebp
		jmp	mwPlace_destroy
; ---------------------------------------------------------------------------

loc_1001296F:				; CODE XREF: sub_10012900+1Aj
		mov	[ebp+arg_8], offset aSrvcNull_6	; "srvc	!= NULL"

loc_10012976:				; CODE XREF: sub_10012900+9Cj
		mov	[ebp+arg_4], offset aRecv_channel_1 ; "recv_channelDestroy"
		mov	ebx, [ebp+var_C]
		mov	[ebp+arg_0], offset aMeanwhile_10 ; "meanwhile"
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_10012995:				; CODE XREF: sub_10012900+28j
		mov	[ebp+arg_8], offset aPlaceNull ; "place	!= NULL"
		jmp	short loc_10012976
sub_10012900	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100129A0	proc near		; DATA XREF: mwServicePlace_new+5Bo

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	loc_10012A7A
		mov	eax, [ebp+arg_4]
		mov	[esp+28h+var_28], eax
		call	mwChannel_getServiceData
		test	eax, eax
		mov	edi, eax
		jz	loc_10012A98
		mov	[ebp+var_14], 0
		mov	[ebp+var_10], 0
		call	mwPutBuffer_new
		mov	[esp+28h+var_24], 0
		mov	ebx, eax
		mov	[esp+28h+var_28], eax
		call	gboolean_put
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], 1
		call	guint16_put
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], 2
		call	guint16_put
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], 1
		call	guint16_put
		mov	[esp+28h+var_24], ebx
		lea	ebx, [ebp+var_14]
		mov	[esp+28h+var_28], ebx
		call	mwPutBuffer_finalize
		mov	[esp+28h+var_20], ebx
		mov	[esp+28h+var_24], 0
		mov	eax, [edi+8]
		mov	[esp+28h+var_28], eax
		call	mwChannel_send
		mov	[esp+28h+var_28], ebx
		mov	esi, eax
		call	mwOpaque_clear
		test	esi, esi
		jnz	short loc_10012A66
		mov	edx, 2
		mov	eax, edi
		call	sub_100121A0

loc_10012A5E:				; CODE XREF: sub_100129A0+F6j
					; sub_100129A0+114j
		add	esp, 1Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10012A66:				; CODE XREF: sub_100129A0+B0j
		mov	eax, edi
		mov	edx, 6
		call	sub_100121A0
		add	esp, 1Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10012A7A:				; CODE XREF: sub_100129A0+Ej
		mov	[esp+28h+var_20], offset aSrvcNull_6 ; "srvc !=	NULL"
		mov	[esp+28h+var_24], offset aRecv_channel_2 ; "recv_channelAccept"
		mov	[esp+28h+var_28], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10012A5E
; ---------------------------------------------------------------------------

loc_10012A98:				; CODE XREF: sub_100129A0+23j
		mov	[esp+28h+var_20], offset aPlaceNull ; "place !=	NULL"
		mov	[esp+28h+var_24], offset aRecv_channel_2 ; "recv_channelAccept"
		mov	[esp+28h+var_28], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10012A5E
sub_100129A0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10012AC0	proc near		; DATA XREF: mwServicePlace_new+69o

var_68		= dword	ptr -68h
var_64		= dword	ptr -64h
var_60		= dword	ptr -60h
var_5C		= dword	ptr -5Ch
var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_4C		= dword	ptr -4Ch
var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= word ptr -10h
var_E		= word ptr -0Eh
arg_4		= dword	ptr  0Ch
arg_8		= word ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 5Ch
		mov	eax, [ebp+arg_4]
		movzx	ebx, [ebp+arg_8]
		mov	[esp+68h+var_68], eax
		call	mwChannel_getServiceData
		test	eax, eax
		mov	esi, eax
		jz	loc_100130F7
		mov	eax, [ebp+arg_C]
		mov	[esp+68h+var_68], eax
		call	mwGetBuffer_wrap
		movzx	edx, bx
		cmp	bx, 15h		; switch 22 cases
		mov	[ebp+var_58], edx
		mov	edi, eax
		jbe	short loc_10012B36

loc_10012AFB:				; CODE XREF: sub_10012AC0:loc_10012B36j
					; DATA XREF: .rdata:off_1001FE7Co
		mov	eax, [esi+0Ch]	; jumptable 10012B36 default case
		mov	edx, offset aNull_6 ; "(null)"
		mov	[esp+68h+var_64], offset aReceivedUnknow ; "Received unknown message type 0x%x on p"...
		test	eax, eax
		cmovz	eax, edx
		mov	edx, [ebp+arg_C]
		mov	[esp+68h+var_5C], eax
		mov	eax, [ebp+var_58]
		mov	[esp+68h+var_68], edx
		mov	[esp+68h+var_60], eax
		call	mw_mailme_opaque

loc_10012B26:				; CODE XREF: sub_10012AC0:loc_10012B36j
					; sub_10012AC0+28Ej ...
		mov	[esp+68h+var_68], edi ;	jumptable 10012B36 case	21
		call	mwGetBuffer_free

loc_10012B2E:				; CODE XREF: sub_10012AC0+653j
		add	esp, 5Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10012B36:				; CODE XREF: sub_10012AC0+39j
		jmp	ds:off_1001FE7C[edx*4] ; switch	jump
; ---------------------------------------------------------------------------

loc_10012B3D:				; CODE XREF: sub_10012AC0:loc_10012B36j
					; DATA XREF: .rdata:off_1001FE7Co
		lea	eax, [ebp+var_E] ; jumptable 10012B36 case 20
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint16_get
		mov	[esp+68h+var_68], edi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_100132FA
		movzx	eax, [ebp+var_E]
		cmp	ax, 1
		jz	loc_10012FA5
		jnb	loc_10012F20
		mov	eax, [esi]
		mov	[esp+68h+var_68], eax
		call	mwService_getSession
		mov	[esp+68h+var_64], offset aServer_versi_1 ; "server.version.major"
		mov	ebx, eax
		mov	[esp+68h+var_68], eax
		call	mwSession_getProperty
		mov	[esp+68h+var_64], offset aServer_versi_2 ; "server.version.minor"
		mov	[esp+68h+var_68], ebx
		mov	[ebp+var_44], eax
		call	mwSession_getProperty
		cmp	[ebp+var_44], 1Eh
		jz	loc_10012F89

loc_10012BA9:				; CODE XREF: sub_10012AC0+4E0j
		xor	eax, eax
		cmp	[ebp+var_44], 1Eh
		setnle	al
		mov	[ebp+var_48], eax

loc_10012BB5:				; CODE XREF: sub_10012AC0+4D5j
		mov	[esp+68h+var_64], 4
		mov	[esp+68h+var_68], edi
		call	mwGetBuffer_advance
		lea	eax, [ebp+var_24]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		mov	eax, [esi+1Ch]
		cmp	eax, [ebp+var_24]
		jnz	loc_1001331B
		mov	[esp+68h+var_64], 8
		mov	[esp+68h+var_68], edi
		call	mwGetBuffer_advance
		lea	eax, [ebp+var_20]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		mov	[esp+68h+var_64], 8
		mov	[esp+68h+var_68], edi
		call	mwGetBuffer_advance
		jmp	short loc_10012C26
; ---------------------------------------------------------------------------

loc_10012C11:				; CODE XREF: sub_10012AC0+210j
					; sub_10012AC0+225j
		mov	[esp+68h+var_60], ebx
		mov	eax, [ebx]
		mov	[esp+68h+var_64], eax
		mov	eax, [esi+14h]
		mov	[esp+68h+var_68], eax
		call	g_hash_table_insert

loc_10012C26:				; CODE XREF: sub_10012AC0+14Fj
		mov	eax, [ebp+var_20]
		sub	eax, 1
		mov	[ebp+var_20], eax
		add	eax, 1
		jz	loc_10013014
		mov	[esp+68h+var_68], 28h
		call	g_malloc0
		mov	[esp+68h+var_64], 4
		mov	[esp+68h+var_68], edi
		mov	ebx, eax
		call	mwGetBuffer_advance
		mov	[esp+68h+var_64], ebx
		mov	[esp+68h+var_68], edi
		call	guint32_get
		lea	eax, [ebx+4]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint16_get
		lea	eax, [ebx+8]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	mwIdBlock_get
		lea	eax, [ebx+10h]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	mwString_get
		lea	eax, [ebx+14h]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	mwString_get
		lea	eax, [ebx+18h]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint16_get
		lea	eax, [ebx+1Ch]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		lea	eax, [ebx+20h]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		mov	eax, [ebp+var_48]
		test	eax, eax
		jz	loc_10012C11
		lea	eax, [ebx+24h]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	mwString_get
		jmp	loc_10012C11
; ---------------------------------------------------------------------------

loc_10012CEA:				; CODE XREF: sub_10012AC0:loc_10012B36j
					; DATA XREF: .rdata:off_1001FE7Co
		mov	eax, [esi]	; jumptable 10012B36 case 4
		cmp	dword ptr [esi+4], 4
		mov	[ebp+var_1C], 0
		mov	[ebp+var_4C], eax
		jnz	loc_100132D9
		lea	eax, [ebp+var_14]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		mov	eax, [ebp+var_14]
		mov	[esp+68h+var_64], eax
		mov	eax, [esi+14h]
		mov	[esp+68h+var_68], eax
		call	g_hash_table_lookup
		test	eax, eax
		mov	ebx, eax
		jz	loc_100132B8
		lea	eax, [ebp+var_18]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		lea	eax, [ebp+var_24]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		mov	eax, [ebp+var_24]
		test	eax, eax
		jz	loc_10012B26	; jumptable 10012B36 case 21
		lea	eax, [ebp+var_20]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		lea	eax, [ebp+var_1C]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	mwString_get
		mov	edx, [ebp+var_4C]
		mov	eax, [edx+38h]
		test	eax, eax
		jz	short loc_10012D96
		mov	edx, [eax+18h]
		test	edx, edx
		jz	short loc_10012D96
		mov	eax, [ebp+var_1C]
		mov	[esp+68h+var_68], esi
		mov	[esp+68h+var_60], eax
		lea	eax, [ebx+8]
		mov	[esp+68h+var_64], eax
		call	edx

loc_10012D96:				; CODE XREF: sub_10012AC0+2BAj
					; sub_10012AC0+2C1j
		mov	eax, [ebp+var_1C]
		mov	[esp+68h+var_68], eax
		call	g_free
		jmp	loc_10012B26	; jumptable 10012B36 case 21
; ---------------------------------------------------------------------------

loc_10012DA6:				; CODE XREF: sub_10012AC0:loc_10012B36j
					; DATA XREF: .rdata:off_1001FE7Co
		lea	eax, [ebp+var_14] ; jumptable 10012B36 case 0
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		lea	eax, [ebp+var_18]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		mov	eax, [ebp+var_14]
		mov	[esi+18h], eax
		mov	eax, [ebp+var_18]
		mov	[esi+1Ch], eax
		jmp	loc_10012B26	; jumptable 10012B36 case 21
; ---------------------------------------------------------------------------

loc_10012DD5:				; CODE XREF: sub_10012AC0:loc_10012B36j
					; DATA XREF: .rdata:off_1001FE7Co
		lea	eax, [ebp+var_18] ; jumptable 10012B36 case 2
		mov	[esp+68h+var_64], eax
		mov	[ebp+var_18], 0
		mov	[ebp+var_14], 0
		mov	[esp+68h+var_68], edi
		call	guint32_get
		lea	eax, [ebp+var_14]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		mov	eax, [ebp+var_18]
		mov	[esp+68h+var_68], edi
		mov	[esp+68h+var_64], eax
		call	mwGetBuffer_advance
		mov	eax, [ebp+var_14]
		test	eax, eax
		jnz	loc_10012B26	; jumptable 10012B36 case 21
		mov	eax, [esi+10h]
		test	eax, eax
		jz	short loc_10012E2A
		mov	[esp+68h+var_68], eax
		call	g_free

loc_10012E2A:				; CODE XREF: sub_10012AC0+360j
		mov	[esp+68h+var_64], 2
		mov	[esp+68h+var_68], edi
		call	mwGetBuffer_advance
		lea	eax, [esi+10h]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	mwString_get
		mov	edx, 3
		mov	eax, esi
		call	sub_100121A0
		mov	eax, [esi+1Ch]
		mov	[ebp+var_28], 0
		mov	[ebp+var_2C], 0
		mov	[ebp+var_50], eax
		call	mwPutBuffer_new
		mov	[esp+68h+var_64], 2
		mov	ebx, eax
		mov	[esp+68h+var_68], eax
		call	guint16_put
		mov	edx, [ebp+var_50]
		mov	[esp+68h+var_68], ebx
		mov	[esp+68h+var_64], edx
		call	guint32_put
		mov	[esp+68h+var_68], ebx
		mov	[esp+68h+var_64], 0
		call	gboolean_put
		mov	eax, [esi+20h]
		add	eax, 1
		mov	[esi+20h], eax
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], ebx
		call	guint32_put
		mov	[esp+68h+var_64], ebx
		lea	ebx, [ebp+var_2C]
		mov	[esp+68h+var_68], ebx
		call	mwPutBuffer_finalize
		mov	[esp+68h+var_60], ebx
		mov	[esp+68h+var_64], 14h
		mov	eax, [esi+8]
		mov	[esp+68h+var_68], eax
		call	mwChannel_send
		mov	[esp+68h+var_68], ebx
		mov	[ebp+var_54], eax
		call	mwOpaque_clear
		mov	edx, [ebp+var_54]
		test	edx, edx
		jz	loc_10012B26	; jumptable 10012B36 case 21

loc_10012EF0:				; CODE XREF: sub_10012AC0+464j
					; sub_10012AC0+580j ...
		mov	eax, [esi+0Ch]
		mov	edx, offset aNull_6 ; "(null)"
		mov	[esp+68h+var_64], offset aTroublingParsi ; "Troubling parsing message type 0x0%x on"...
		test	eax, eax
		cmovz	eax, edx
		mov	edx, [ebp+arg_C]
		mov	[esp+68h+var_5C], eax
		mov	eax, [ebp+var_58]
		mov	[esp+68h+var_68], edx
		mov	[esp+68h+var_60], eax
		call	mw_mailme_opaque
		jmp	loc_10012B26	; jumptable 10012B36 case 21
; ---------------------------------------------------------------------------

loc_10012F20:				; CODE XREF: sub_10012AC0+AAj
		cmp	ax, 3
		jnz	short loc_10012EF0
		mov	eax, [esi]
		mov	[esp+68h+var_68], edi
		mov	[ebp+var_30], eax
		lea	eax, [ebp+var_24]
		mov	[esp+68h+var_64], eax
		call	guint32_get
		mov	eax, [ebp+var_24]
		mov	[esp+68h+var_64], eax
		mov	eax, [esi+14h]
		mov	[esp+68h+var_68], eax
		call	g_hash_table_lookup
		test	eax, eax
		mov	ebx, eax
		jz	loc_10012B26	; jumptable 10012B36 case 21
		mov	edx, [ebp+var_30]
		mov	eax, [edx+38h]
		test	eax, eax
		jz	short loc_10012F73

loc_10012F60:				; CODE XREF: sub_10012AC0+715j
		mov	edx, [eax+0Ch]
		test	edx, edx
		jz	short loc_10012F73
		lea	eax, [ebx+8]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], esi
		call	edx

loc_10012F73:				; CODE XREF: sub_10012AC0+49Ej
					; sub_10012AC0+4A5j ...
		mov	eax, [ebx]
		mov	[esp+68h+var_64], eax
		mov	eax, [esi+14h]
		mov	[esp+68h+var_68], eax
		call	g_hash_table_remove
		jmp	loc_10012B26	; jumptable 10012B36 case 21
; ---------------------------------------------------------------------------

loc_10012F89:				; CODE XREF: sub_10012AC0+E3j
		cmp	eax, 213Eh
		mov	[ebp+var_48], 1
		jg	loc_10012BB5
		nop
		lea	esi, [esi+0]
		jmp	loc_10012BA9
; ---------------------------------------------------------------------------

loc_10012FA5:				; CODE XREF: sub_10012AC0+A4j
		lea	eax, [ebp+var_10]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint16_get
		mov	[esp+68h+var_68], edi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_1001333C
		movzx	eax, [ebp+var_10]
		cmp	ax, 1
		jz	loc_10013182
		jnb	short loc_1001302A
		mov	eax, [esi]
		mov	[esp+68h+var_68], edi
		mov	[ebp+var_40], eax
		lea	eax, [ebp+var_20]
		mov	[esp+68h+var_64], eax
		call	guint32_get
		mov	ecx, [ebp+var_20]
		test	ecx, ecx
		jnz	loc_100131E0
		mov	[esp+68h+var_60], offset aSection_peer_j ; "SECTION_PEER_JOIN with section 0x00"
		mov	[esp+68h+var_64], 40h
		mov	[esp+68h+var_68], offset aMeanwhile_10 ; "meanwhile"
		call	g_log
		jmp	loc_10012B26	; jumptable 10012B36 case 21
; ---------------------------------------------------------------------------

loc_10013014:				; CODE XREF: sub_10012AC0+172j
		cmp	dword ptr [esi+4], 4
		jz	loc_10012B26	; jumptable 10012B36 case 21

loc_1001301E:				; CODE XREF: sub_10012AC0+7F3j
		mov	eax, esi
		call	sub_10012250
		jmp	loc_10012B26	; jumptable 10012B36 case 21
; ---------------------------------------------------------------------------

loc_1001302A:				; CODE XREF: sub_10012AC0+512j
		cmp	ax, 3
		xchg	ax, ax
		jz	loc_10013118
		cmp	ax, 4
		lea	esi, [esi+0]
		jnz	loc_10012EF0
		mov	eax, [esi]
		lea	ebx, [ebp+var_2C]
		mov	[ebp+var_2C], 0
		mov	[ebp+var_28], 0
		mov	[esp+68h+var_68], edi
		mov	[ebp+var_34], eax
		lea	eax, [ebp+var_20]
		mov	[esp+68h+var_64], eax
		call	guint32_get
		mov	[esp+68h+var_64], 4
		mov	[esp+68h+var_68], edi
		call	mwGetBuffer_advance
		mov	[esp+68h+var_64], ebx
		mov	[esp+68h+var_68], edi
		call	mwOpaque_get
		mov	[esp+68h+var_64], 4
		mov	[esp+68h+var_68], edi
		call	mwGetBuffer_advance
		lea	eax, [ebp+var_24]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		mov	eax, [ebp+var_20]
		mov	[esp+68h+var_64], eax
		mov	eax, [esi+14h]
		mov	[esp+68h+var_68], eax
		call	g_hash_table_lookup
		test	eax, eax
		mov	ecx, eax
		jz	loc_1001337E
		mov	edx, [ebp+var_34]
		mov	eax, [edx+38h]
		test	eax, eax
		jz	short loc_100130EA
		mov	edx, [eax+10h]
		test	edx, edx
		jz	short loc_100130EA
		mov	eax, [ebp+var_24]
		mov	[esp+68h+var_5C], ebx
		mov	[esp+68h+var_68], esi
		mov	[esp+68h+var_60], eax
		lea	eax, [ecx+8]
		mov	[esp+68h+var_64], eax
		call	edx

loc_100130EA:				; CODE XREF: sub_10012AC0+60Aj
					; sub_10012AC0+611j
		mov	[esp+68h+var_68], ebx
		call	mwOpaque_clear
		jmp	loc_10012B26	; jumptable 10012B36 case 21
; ---------------------------------------------------------------------------

loc_100130F7:				; CODE XREF: sub_10012AC0+1Cj
		mov	[esp+68h+var_60], offset aPlaceNull ; "place !=	NULL"
		mov	[esp+68h+var_64], offset aRecv_4 ; "recv"
		mov	[esp+68h+var_68], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10012B2E
; ---------------------------------------------------------------------------

loc_10013118:				; CODE XREF: sub_10012AC0+570j
		lea	eax, [ebp+var_24]
		mov	ebx, [esi]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		lea	eax, [ebp+var_20]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		mov	eax, [ebp+var_24]
		mov	[esp+68h+var_64], eax
		mov	eax, [esi+14h]
		mov	[esp+68h+var_68], eax
		call	g_hash_table_lookup
		test	eax, eax
		mov	ecx, eax
		jz	loc_1001335D
		mov	eax, [ebx+38h]
		test	eax, eax
		jz	loc_10012B26	; jumptable 10012B36 case 21
		mov	edx, [eax+14h]
		test	edx, edx
		jz	loc_10012B26	; jumptable 10012B36 case 21
		mov	eax, [ebp+var_20]
		mov	[esp+68h+var_68], esi
		mov	[esp+68h+var_60], eax
		lea	eax, [ecx+8]
		mov	[esp+68h+var_64], eax
		call	edx
		jmp	loc_10012B26	; jumptable 10012B36 case 21
; ---------------------------------------------------------------------------

loc_10013182:				; CODE XREF: sub_10012AC0+50Cj
		mov	eax, [esi]
		mov	[esp+68h+var_68], edi
		mov	[ebp+var_38], eax
		lea	eax, [ebp+var_20]
		mov	[esp+68h+var_64], eax
		call	guint32_get
		mov	eax, [esi+1Ch]
		cmp	eax, [ebp+var_20]
		jnz	loc_1001339F
		lea	eax, [ebp+var_24]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		mov	eax, [ebp+var_24]
		mov	[esp+68h+var_64], eax
		mov	eax, [esi+14h]
		mov	[esp+68h+var_68], eax
		call	g_hash_table_lookup
		test	eax, eax
		mov	ebx, eax
		jz	loc_10012B26	; jumptable 10012B36 case 21
		mov	edx, [ebp+var_38]
		mov	eax, [edx+38h]
		test	eax, eax
		jnz	loc_10012F60
		jmp	loc_10012F73
; ---------------------------------------------------------------------------

loc_100131E0:				; CODE XREF: sub_10012AC0+52Dj
		mov	[esp+68h+var_64], 4
		mov	[esp+68h+var_68], edi
		call	mwGetBuffer_advance
		mov	[esp+68h+var_68], 28h
		call	g_malloc0
		mov	[esp+68h+var_68], edi
		mov	ebx, eax
		mov	[esp+68h+var_64], eax
		call	guint32_get
		lea	eax, [ebx+4]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint16_get
		lea	edx, [ebx+8]
		mov	[ebp+var_3C], edx
		mov	[esp+68h+var_64], edx
		mov	[esp+68h+var_68], edi
		call	mwIdBlock_get
		lea	eax, [ebx+10h]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	mwString_get
		lea	eax, [ebx+14h]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	mwString_get
		lea	eax, [ebx+18h]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint16_get
		lea	eax, [ebx+1Ch]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		lea	eax, [ebx+20h]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		mov	[esp+68h+var_60], ebx
		mov	eax, [ebx]
		mov	[esp+68h+var_64], eax
		mov	eax, [esi+14h]
		mov	[esp+68h+var_68], eax
		call	g_hash_table_insert
		mov	edx, [ebp+var_40]
		mov	eax, [edx+38h]
		test	eax, eax
		jz	short loc_100132A8
		mov	eax, [eax+8]
		test	eax, eax
		jz	short loc_100132A8
		mov	edx, [ebp+var_3C]
		mov	[esp+68h+var_68], esi
		mov	[esp+68h+var_64], edx
		call	eax

loc_100132A8:				; CODE XREF: sub_10012AC0+7D3j
					; sub_10012AC0+7DAj
		mov	eax, [ebx]
		cmp	eax, [esi+18h]
		jnz	loc_10012B26	; jumptable 10012B36 case 21
		jmp	loc_1001301E
; ---------------------------------------------------------------------------

loc_100132B8:				; CODE XREF: sub_10012AC0+265j
		mov	[esp+68h+var_60], offset aPmNull ; "pm != NULL"
		mov	[esp+68h+var_64], offset aRecv_message ; "recv_MESSAGE"
		mov	[esp+68h+var_68], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10012EF0
; ---------------------------------------------------------------------------

loc_100132D9:				; CODE XREF: sub_10012AC0+23Aj
		mov	[esp+68h+var_60], offset aPlaceStateMwpl ; "place->state == mwPlace_OPEN"
		mov	[esp+68h+var_64], offset aRecv_message ; "recv_MESSAGE"
		mov	[esp+68h+var_68], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10012EF0
; ---------------------------------------------------------------------------

loc_100132FA:				; CODE XREF: sub_10012AC0+96j
		mov	[esp+68h+var_60], offset aMwgetbuffer__2 ; "! mwGetBuffer_error(b)"
		mov	[esp+68h+var_64], offset aRecv_section ; "recv_SECTION"
		mov	[esp+68h+var_68], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10012EF0
; ---------------------------------------------------------------------------

loc_1001331B:				; CODE XREF: sub_10012AC0+11Aj
		mov	[esp+68h+var_60], offset aSecPlaceSectio ; "sec	== place->section"
		mov	[esp+68h+var_64], offset aRecv_section_l ; "recv_SECTION_LIST"
		mov	[esp+68h+var_68], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10012EF0
; ---------------------------------------------------------------------------

loc_1001333C:				; CODE XREF: sub_10012AC0+4FEj
		mov	[esp+68h+var_60], offset aMwgetbuffer__2 ; "! mwGetBuffer_error(b)"
		mov	[esp+68h+var_64], offset aRecv_section_p ; "recv_SECTION_PEER"
		mov	[esp+68h+var_68], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10012EF0
; ---------------------------------------------------------------------------

loc_1001335D:				; CODE XREF: sub_10012AC0+68Ej
		mov	[esp+68h+var_60], offset aPmNull ; "pm != NULL"
		mov	[esp+68h+var_64], offset aRecv_section_0 ; "recv_SECTION_PEER_CLEAR_ATTR"
		mov	[esp+68h+var_68], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10012EF0
; ---------------------------------------------------------------------------

loc_1001337E:				; CODE XREF: sub_10012AC0+5FCj
		mov	[esp+68h+var_60], offset aPmNull ; "pm != NULL"
		mov	[esp+68h+var_64], offset aRecv_section_1 ; "recv_SECTION_PEER_SET_ATTR"
		mov	[esp+68h+var_68], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10012EF0
; ---------------------------------------------------------------------------

loc_1001339F:				; CODE XREF: sub_10012AC0+6DCj
		mov	[esp+68h+var_60], offset aSectionPlaceSe ; "section == place->section"
		mov	[esp+68h+var_64], offset aRecv_section_2 ; "recv_SECTION_PEER_PART"
		mov	[esp+68h+var_68], offset aMeanwhile_10 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10012B26	; jumptable 10012B36 case 21
sub_10012AC0	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100133C0	proc near		; DATA XREF: mwServicePlace_new+4Do

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebx+3Ch]
		test	eax, eax
		jz	short loc_100133EA

loc_100133D1:				; CODE XREF: sub_100133C0+28j
		mov	[esp+18h+var_14], 0
		mov	eax, [eax]
		mov	[esp+18h+var_18], eax
		call	mwPlace_destroy
		mov	eax, [ebx+3Ch]
		test	eax, eax
		jnz	short loc_100133D1

loc_100133EA:				; CODE XREF: sub_100133C0+Fj
		mov	[ebp+arg_0], ebx
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	mwService_stopped
sub_100133C0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10013400	proc near		; DATA XREF: mwServiceResolve_new+31o
		push	ebp
		mov	eax, offset aIdentityResolu ; "Identity	Resolution"
		mov	ebp, esp
		pop	ebp
		retn
sub_10013400	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10013410	proc near		; DATA XREF: mwServiceResolve_new+38o
		push	ebp
		mov	eax, offset aResolvesShortI ; "Resolves	short IDs to full IDs"
		mov	ebp, esp
		pop	ebp
		retn
sub_10013410	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 289. mwServiceResolve_cancelResolve

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceResolve_cancelResolve
mwServiceResolve_cancelResolve proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	eax, eax
		jz	short loc_10013443
		mov	eax, [eax+3Ch]
		test	eax, eax
		jz	short loc_10013461
		mov	[ebp+arg_4], edx
		mov	[ebp+arg_0], eax
		leave
		jmp	g_hash_table_remove
; ---------------------------------------------------------------------------

loc_10013443:				; CODE XREF: mwServiceResolve_cancelResolve+Ej
		mov	[esp+18h+var_10], offset aSrvcNull_7 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aMwserviceresol ; "mwServiceResolve_cancelResolve"
		mov	[esp+18h+var_18], offset aMeanwhile_12 ; "meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
; ---------------------------------------------------------------------------

loc_10013461:				; CODE XREF: mwServiceResolve_cancelResolve+15j
		mov	[esp+18h+var_10], offset aSrvcSearchesNu ; "srvc->searches != NULL"
		mov	[esp+18h+var_14], offset aMwserviceresol ; "mwServiceResolve_cancelResolve"
		mov	[esp+18h+var_18], offset aMeanwhile_12 ; "meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwServiceResolve_cancelResolve endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10013480	proc near		; CODE XREF: mwServiceResolve_resolve+130p
					; DATA XREF: sub_100137E0+6Co

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_100134AA
		mov	edx, [ebx+10h]
		test	edx, edx
		jz	short loc_1001349D
		mov	eax, [ebx+0Ch]
		mov	[esp+18h+var_18], eax
		call	edx

loc_1001349D:				; CODE XREF: sub_10013480+13j
		mov	[ebp+arg_0], ebx
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	g_free
; ---------------------------------------------------------------------------

loc_100134AA:				; CODE XREF: sub_10013480+Cj
		mov	[esp+18h+var_10], offset aSearchNull ; "search != NULL"
		mov	[esp+18h+var_14], offset aSearch_free ;	"search_free"
		mov	[esp+18h+var_18], offset aMeanwhile_12 ; "meanwhile"
		call	g_return_if_fail_warning
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
sub_10013480	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 291. mwServiceResolve_resolve

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceResolve_resolve
mwServiceResolve_resolve proc near

var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 2Ch
		mov	ecx, [ebp+arg_0]
		mov	ebx, [ebp+arg_4]
		mov	edi, [ebp+arg_C]
		mov	[ebp+var_14], 0
		test	ecx, ecx
		mov	[ebp+var_10], 0
		jz	loc_1001364F
		test	edi, edi
		jz	loc_1001362F
		mov	[esp+38h+var_38], ebx
		call	g_list_length
		test	eax, eax
		mov	[ebp+var_20], eax
		jle	loc_1001360F
		mov	[esp+38h+var_38], 14h
		call	g_malloc0
		mov	esi, eax
		mov	eax, [ebp+arg_0]
		mov	[esi+8], edi
		mov	[esi], eax
		mov	eax, [eax+40h]
		lea	esi, [esi+0]

loc_10013530:				; CODE XREF: mwServiceResolve_resolve+71j
		mov	edx, [ebp+arg_0]
		mov	[esi+4], eax
		add	eax, 1
		mov	[edx+40h], eax
		mov	edx, [esi+4]
		test	edx, edx
		jz	short loc_10013530
		mov	edx, [ebp+arg_14]
		mov	eax, [ebp+arg_10]
		mov	[esi+10h], edx
		mov	[esi+0Ch], eax
		call	mwPutBuffer_new
		mov	[esp+38h+var_34], 0
		mov	edi, eax
		mov	[esp+38h+var_38], eax
		call	guint32_put
		mov	eax, [esi+4]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint32_put
		mov	eax, [ebp+var_20]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	guint32_put
		test	ebx, ebx
		jz	short loc_1001359D

loc_10013588:				; CODE XREF: mwServiceResolve_resolve+CBj
		mov	eax, [ebx]
		mov	[esp+38h+var_38], edi ;	int
		mov	[esp+38h+var_34], eax ;	char *
		call	mwString_put
		mov	ebx, [ebx+4]
		test	ebx, ebx
		jnz	short loc_10013588

loc_1001359D:				; CODE XREF: mwServiceResolve_resolve+B6j
		mov	edx, [ebp+arg_8]
		lea	ebx, [ebp+var_14]
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], edx
		call	guint32_put
		mov	[esp+38h+var_34], edi
		mov	[esp+38h+var_38], ebx
		call	mwPutBuffer_finalize
		mov	[esp+38h+var_30], ebx
		mov	[esp+38h+var_34], 2
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+38h]
		mov	[esp+38h+var_38], eax
		call	mwChannel_send
		test	eax, eax
		jnz	short loc_100135FD
		mov	[esp+38h+var_30], esi
		mov	eax, [esi+4]
		mov	[esp+38h+var_34], eax
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+3Ch]
		mov	[esp+38h+var_38], eax
		call	g_hash_table_insert
		mov	eax, [esi+4]

loc_100135F5:				; CODE XREF: mwServiceResolve_resolve+15Dj
					; mwServiceResolve_resolve+17Dj ...
		add	esp, 2Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100135FD:				; CODE XREF: mwServiceResolve_resolve+107j
		mov	[esp+38h+var_38], esi
		call	sub_10013480
		add	esp, 2Ch
		xor	eax, eax
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1001360F:				; CODE XREF: mwServiceResolve_resolve+3Dj
		mov	[esp+38h+var_30], offset aCount0 ; "count > 0"
		mov	[esp+38h+var_34], offset aMwserviceres_0 ; "mwServiceResolve_resolve"
		mov	[esp+38h+var_38], offset aMeanwhile_12 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		jmp	short loc_100135F5
; ---------------------------------------------------------------------------

loc_1001362F:				; CODE XREF: mwServiceResolve_resolve+2Aj
		mov	[esp+38h+var_30], offset aHandlerNull_6	; "handler != NULL"
		mov	[esp+38h+var_34], offset aMwserviceres_0 ; "mwServiceResolve_resolve"
		mov	[esp+38h+var_38], offset aMeanwhile_12 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		jmp	short loc_100135F5
; ---------------------------------------------------------------------------

loc_1001364F:				; CODE XREF: mwServiceResolve_resolve+22j
		mov	[esp+38h+var_30], offset aSrvcNull_7 ; "srvc !=	NULL"
		mov	[esp+38h+var_34], offset aMwserviceres_0 ; "mwServiceResolve_resolve"
		mov	[esp+38h+var_38], offset aMeanwhile_12 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		jmp	short loc_100135F5
mwServiceResolve_resolve endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 290. mwServiceResolve_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceResolve_new
mwServiceResolve_new proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_0]
		test	esi, esi
		jz	short loc_100136E9
		mov	[esp+18h+var_18], 44h
		call	g_malloc0
		mov	[esp+18h+var_10], 15h
		mov	[esp+18h+var_14], esi
		mov	ebx, eax
		mov	[esp+18h+var_18], eax
		call	mwService_init
		mov	dword ptr [ebx+0Ch], offset sub_10013400
		mov	dword ptr [ebx+10h], offset sub_10013410
		mov	dword ptr [ebx+14h], offset sub_10013740
		mov	dword ptr [ebx+18h], offset sub_10013D20
		mov	dword ptr [ebx+1Ch], offset sub_10013C90
		mov	dword ptr [ebx+20h], offset sub_100138B0
		mov	dword ptr [ebx+24h], offset sub_100137E0
		mov	dword ptr [ebx+28h], offset sub_10013760
		mov	dword ptr [ebx+2Ch], offset sub_10013710

loc_100136E0:				; CODE XREF: mwServiceResolve_new+97j
		add	esp, 10h
		mov	eax, ebx
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100136E9:				; CODE XREF: mwServiceResolve_new+Dj
		mov	[esp+18h+var_10], offset aSessionNull_7	; "session != NULL"
		xor	ebx, ebx
		mov	[esp+18h+var_14], offset aMwserviceres_1 ; "mwServiceResolve_new"
		mov	[esp+18h+var_18], offset aMeanwhile_12 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100136E0
mwServiceResolve_new endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10013710	proc near		; DATA XREF: mwServiceResolve_new+69o

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebx+3Ch]
		test	eax, eax
		jz	short loc_10013730
		mov	[esp+8+var_8], eax
		call	g_hash_table_destroy
		mov	dword ptr [ebx+3Ch], 0

loc_10013730:				; CODE XREF: sub_10013710+Fj
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
sub_10013710	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10013740	proc near		; DATA XREF: mwServiceResolve_new+3Fo

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_4]
		mov	[ebp+arg_8], 0
		mov	[ebp+arg_4], 80000000h
		mov	[ebp+arg_0], eax
		pop	ebp
		jmp	mwChannel_destroy
sub_10013740	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10013760	proc near		; DATA XREF: mwServiceResolve_new+62o

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_100137B3
		mov	eax, [ebx+38h]
		test	eax, eax
		jz	short loc_10013794
		mov	[esp+18h+var_10], 0
		mov	[esp+18h+var_14], 0
		mov	[esp+18h+var_18], eax
		call	mwChannel_destroy
		mov	dword ptr [ebx+38h], 0

loc_10013794:				; CODE XREF: sub_10013760+13j
		mov	eax, [ebx+3Ch]
		mov	[esp+18h+var_18], eax
		call	g_hash_table_destroy
		mov	dword ptr [ebx+3Ch], 0
		mov	[ebp+arg_0], ebx
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	mwService_stopped
; ---------------------------------------------------------------------------

loc_100137B3:				; CODE XREF: sub_10013760+Cj
		mov	[esp+18h+var_10], offset aSrvcNull_7 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aStop ; "stop"
		mov	[esp+18h+var_18], offset aMeanwhile_12 ; "meanwhile"
		call	g_return_if_fail_warning
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
sub_10013760	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100137E0	proc near		; DATA XREF: mwServiceResolve_new+5Bo

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_0]
		test	esi, esi
		jz	loc_1001388E
		mov	[esp+18h+var_18], esi
		call	mwService_getSession
		mov	[esp+18h+var_18], eax
		call	mwSession_getChannels
		mov	[esp+18h+var_18], eax
		call	mwChannel_newOutgoing
		mov	[esp+18h+var_14], esi
		mov	ebx, eax
		mov	[esp+18h+var_18], eax
		call	mwChannel_setService
		mov	[esp+18h+var_14], 15h
		mov	[esp+18h+var_18], ebx
		call	mwChannel_setProtoType
		mov	[esp+18h+var_14], 0
		mov	[esp+18h+var_18], ebx
		call	mwChannel_setProtoVer
		mov	[esp+18h+var_18], ebx
		call	mwChannel_create
		test	eax, eax
		jnz	short loc_10013880
		test	ebx, ebx
		jz	short loc_10013880
		mov	[esi+38h], ebx
		mov	[esp+18h+var_C], offset	sub_10013480
		mov	[esp+18h+var_10], 0
		mov	[esp+18h+var_14], offset loc_1001A918
		mov	[esp+18h+var_18], offset loc_1001A910
		call	g_hash_table_new_full
		mov	[esi+3Ch], eax

loc_10013873:				; CODE XREF: sub_100137E0+CAj
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10013880:				; CODE XREF: sub_100137E0+63j
					; sub_100137E0+67j
		mov	[ebp+arg_0], esi
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	mwService_stopped
; ---------------------------------------------------------------------------

loc_1001388E:				; CODE XREF: sub_100137E0+Dj
		mov	[esp+18h+var_10], offset aSrvcNull_7 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aStart	; "start"
		mov	[esp+18h+var_18], offset aMeanwhile_12 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10013873
sub_100137E0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100138B0	proc near		; DATA XREF: mwServiceResolve_new+54o

var_68		= dword	ptr -68h
var_64		= dword	ptr -64h
var_60		= dword	ptr -60h
var_5C		= dword	ptr -5Ch
var_58		= dword	ptr -58h
var_4C		= dword	ptr -4Ch
var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_24		= dword	ptr -24h
var_20		= byte ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= byte ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= word ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 5Ch
		mov	esi, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		mov	ecx, [ebp+arg_C]
		movzx	eax, [ebp+arg_8]
		test	esi, esi
		jz	loc_10013C41
		test	edx, edx
		jz	loc_10013C20
		mov	ebx, [ebp+arg_0]
		cmp	[ebx+38h], edx
		jnz	loc_10013BFF
		test	ecx, ecx
		jz	loc_10013C62
		cmp	ax, 2
		xchg	ax, ax
		jz	short loc_10013911
		movzx	eax, ax
		mov	[esp+68h+var_60], eax
		mov	[esp+68h+var_64], offset aUnknownMessa_6 ; "unknown message in resolve service:	0x%"...
		mov	[esp+68h+var_68], ecx
		call	mw_mailme_opaque

loc_10013909:				; CODE XREF: sub_100138B0+36Bj
					; sub_100138B0+38Cj ...
		add	esp, 5Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10013911:				; CODE XREF: sub_100138B0+40j
		mov	[esp+68h+var_68], ecx
		call	mwGetBuffer_wrap
		mov	edi, eax
		lea	eax, [ebp+var_10]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		lea	eax, [ebp+var_14]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		lea	eax, [ebp+var_18]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		lea	eax, [ebp+var_1C]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		mov	[esp+68h+var_68], edi
		call	mwGetBuffer_error
		test	eax, eax
		jnz	loc_10013B62
		mov	eax, [ebp+var_14]
		mov	[esp+68h+var_64], eax
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+3Ch]
		mov	[esp+68h+var_68], eax
		call	g_hash_table_lookup
		test	eax, eax
		mov	[ebp+var_48], eax
		jz	loc_10013BD7
		mov	ebx, [ebp+var_1C]
		mov	[ebp+var_44], 0
		test	ebx, ebx
		mov	[ebp+var_40], ebx
		jz	loc_10013A90
		mov	[ebp+var_30], 0

loc_100139A3:				; CODE XREF: sub_100138B0+1DAj
		mov	[esp+68h+var_68], 0Ch
		lea	ebx, [ebp+var_24]
		call	g_malloc0
		mov	[ebp+var_4C], eax
		lea	eax, [ebp+var_20]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		mov	edx, [ebp+var_4C]
		mov	[esp+68h+var_68], edi
		mov	[esp+68h+var_64], edx
		call	guint32_get
		mov	eax, [ebp+var_4C]
		mov	[esp+68h+var_68], edi
		add	eax, 4
		mov	[esp+68h+var_64], eax
		call	mwString_get
		mov	[esp+68h+var_64], ebx
		mov	[esp+68h+var_68], edi
		call	guint32_get
		mov	eax, [ebp+var_24]
		mov	[ebp+var_38], 0
		test	eax, eax
		mov	[ebp+var_3C], eax
		jz	short loc_10013A65
		xor	esi, esi

loc_10013A04:				; CODE XREF: sub_100138B0+1B3j
		mov	[esp+68h+var_68], 10h
		add	esi, 1
		call	g_malloc0
		mov	[esp+68h+var_68], edi
		mov	ebx, eax
		mov	[esp+68h+var_64], eax
		call	mwString_get
		lea	eax, [ebx+4]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	mwString_get
		lea	eax, [ebx+8]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	mwString_get
		lea	eax, [ebx+0Ch]
		mov	[esp+68h+var_64], eax
		mov	[esp+68h+var_68], edi
		call	guint32_get
		mov	[esp+68h+var_64], ebx
		mov	edx, [ebp+var_38]
		mov	[esp+68h+var_68], edx
		call	g_list_append
		cmp	esi, [ebp+var_3C]
		mov	[ebp+var_38], eax
		jnz	short loc_10013A04

loc_10013A65:				; CODE XREF: sub_100138B0+150j
		mov	ebx, [ebp+var_4C]
		mov	eax, [ebp+var_38]
		mov	[ebx+8], eax
		mov	[esp+68h+var_64], ebx
		mov	edx, [ebp+var_44]
		mov	[esp+68h+var_68], edx
		call	g_list_append
		mov	ebx, [ebp+var_40]
		add	[ebp+var_30], 1
		cmp	[ebp+var_30], ebx
		mov	[ebp+var_44], eax
		jnz	loc_100139A3

loc_10013A90:				; CODE XREF: sub_100138B0+E6j
		mov	[esp+68h+var_68], edi
		call	mwGetBuffer_error
		test	eax, eax
		jz	loc_10013B8E
		mov	[esp+68h+var_60], offset aErrorParsingSe ; "error parsing search results"
		mov	[esp+68h+var_64], 10h
		mov	[esp+68h+var_68], offset aMeanwhile_12 ; "meanwhile"
		call	g_log

loc_10013ABC:				; CODE XREF: sub_100138B0+322j
		mov	ebx, [ebp+var_44]
		test	ebx, ebx
		jz	short loc_10013B3D

loc_10013AC3:				; CODE XREF: sub_100138B0+28Bj
		mov	edx, [ebp+var_44]
		mov	edx, [edx]
		mov	eax, [edx+4]
		mov	[ebp+var_34], edx
		mov	[esp+68h+var_68], eax
		call	g_free
		mov	ebx, [ebp+var_34]
		mov	esi, [ebx+8]
		test	esi, esi
		jz	short loc_10013B1C

loc_10013AE0:				; CODE XREF: sub_100138B0+26Aj
		mov	ebx, [esi]
		mov	eax, [ebx]
		mov	[esp+68h+var_68], eax
		call	g_free
		mov	eax, [ebx+4]
		mov	[esp+68h+var_68], eax
		call	g_free
		mov	eax, [ebx+8]
		mov	[esp+68h+var_68], eax
		call	g_free
		mov	[esp+68h+var_68], ebx
		call	g_free
		mov	[esp+68h+var_64], esi
		mov	[esp+68h+var_68], esi
		call	g_list_delete_link
		test	eax, eax
		mov	esi, eax
		jnz	short loc_10013AE0

loc_10013B1C:				; CODE XREF: sub_100138B0+22Ej
		mov	eax, [ebp+var_34]
		mov	[esp+68h+var_68], eax
		call	g_free
		mov	edx, [ebp+var_44]
		mov	[esp+68h+var_64], edx
		mov	[esp+68h+var_68], edx
		call	g_list_delete_link
		test	eax, eax
		mov	[ebp+var_44], eax
		jnz	short loc_10013AC3

loc_10013B3D:				; CODE XREF: sub_100138B0+211j
		mov	eax, [ebp+var_14]
		mov	[esp+68h+var_64], eax
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebx+3Ch]
		mov	[esp+68h+var_68], eax
		call	g_hash_table_remove

loc_10013B52:				; CODE XREF: sub_100138B0+34Aj
		mov	[esp+68h+var_68], edi
		call	mwGetBuffer_free
		add	esp, 5Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10013B62:				; CODE XREF: sub_100138B0+B1j
		mov	[esp+68h+var_60], offset aErrorParsing_0 ; "error parsing search result"
		mov	[esp+68h+var_64], 10h
		mov	[esp+68h+var_68], offset aMeanwhile_12 ; "meanwhile"
		call	g_log
		mov	[esp+68h+var_68], edi
		call	mwGetBuffer_free
		add	esp, 5Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10013B8E:				; CODE XREF: sub_100138B0+1EAj
		mov	[esp+68h+var_60], offset aTriggeringHand ; "triggering handler"
		mov	[esp+68h+var_64], 80h
		mov	[esp+68h+var_68], offset aMeanwhile_12 ; "meanwhile"
		call	g_log
		mov	edx, [ebp+var_48]
		mov	eax, [edx+0Ch]
		mov	[esp+68h+var_58], eax
		mov	ebx, [ebp+var_44]
		mov	[esp+68h+var_5C], ebx
		mov	eax, [ebp+var_18]
		mov	[esp+68h+var_60], eax
		mov	eax, [ebp+var_14]
		mov	[esp+68h+var_64], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+68h+var_68], eax
		call	dword ptr [edx+8]
		jmp	loc_10013ABC
; ---------------------------------------------------------------------------

loc_10013BD7:				; CODE XREF: sub_100138B0+D1j
		mov	eax, [ebp+var_14]
		mov	[esp+68h+var_60], offset aNoSearchFound0 ; "no search found: 0x%x"
		mov	[esp+68h+var_64], 80h
		mov	[esp+68h+var_68], offset aMeanwhile_12 ; "meanwhile"
		mov	[esp+68h+var_5C], eax
		call	g_log
		jmp	loc_10013B52
; ---------------------------------------------------------------------------

loc_10013BFF:				; CODE XREF: sub_100138B0+2Cj
		mov	[esp+68h+var_60], offset aChanSrvcChan_0 ; "chan == srvc->channel"
		mov	[esp+68h+var_64], offset aRecv_5 ; "recv"
		mov	[esp+68h+var_68], offset aMeanwhile_12 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10013909
; ---------------------------------------------------------------------------

loc_10013C20:				; CODE XREF: sub_100138B0+20j
		mov	[esp+68h+var_60], offset aChanNull_8 ; "chan !=	NULL"
		mov	[esp+68h+var_64], offset aRecv_5 ; "recv"
		mov	[esp+68h+var_68], offset aMeanwhile_12 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10013909
; ---------------------------------------------------------------------------

loc_10013C41:				; CODE XREF: sub_100138B0+18j
		mov	[esp+68h+var_60], offset aSrvcNull_7 ; "srvc !=	NULL"
		mov	[esp+68h+var_64], offset aRecv_5 ; "recv"
		mov	[esp+68h+var_68], offset aMeanwhile_12 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10013909
; ---------------------------------------------------------------------------

loc_10013C62:				; CODE XREF: sub_100138B0+34j
		mov	[esp+68h+var_60], offset aDataNull_4 ; "data !=	NULL"
		mov	[esp+68h+var_64], offset aRecv_5 ; "recv"
		mov	[esp+68h+var_68], offset aMeanwhile_12 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_10013909
sub_100138B0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10013C90	proc near		; DATA XREF: mwServiceResolve_new+4Do

var_18		= dword	ptr -18h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_10013CE1
		test	eax, eax
		jz	short loc_10013D01
		cmp	[ebx+38h], eax
		jnz	short loc_10013D0A
		mov	dword ptr [ebx+38h], 0
		mov	[esp+18h+var_18], ebx
		call	mwService_stop
		mov	[esp+18h+var_18], ebx
		call	mwService_getSession
		test	eax, eax
		mov	esi, eax
		jz	short loc_10013D13
		mov	[esp+18h+var_18], ebx
		call	mwService_getType
		mov	[ebp+arg_0], esi
		mov	[ebp+arg_4], eax
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	mwSession_senseService
; ---------------------------------------------------------------------------

loc_10013CE1:				; CODE XREF: sub_10013C90+10j
		mov	[ebp+arg_8], offset aSrvcNull_7	; "srvc	!= NULL"

loc_10013CE8:				; CODE XREF: sub_10013C90+78j
					; sub_10013C90+81j ...
		mov	[ebp+arg_4], offset aRecv_destroy ; "recv_destroy"
		mov	[ebp+arg_0], offset aMeanwhile_12 ; "meanwhile"
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_10013D01:				; CODE XREF: sub_10013C90+14j
		mov	[ebp+arg_8], offset aChanNull_8	; "chan	!= NULL"
		jmp	short loc_10013CE8
; ---------------------------------------------------------------------------

loc_10013D0A:				; CODE XREF: sub_10013C90+19j
		mov	[ebp+arg_8], offset aChanSrvcChan_0 ; "chan == srvc->channel"
		jmp	short loc_10013CE8
; ---------------------------------------------------------------------------

loc_10013D13:				; CODE XREF: sub_10013C90+36j
		mov	[ebp+arg_8], offset aSessionNull_7 ; "session != NULL"
		jmp	short loc_10013CE8
sub_10013C90	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10013D20	proc near		; DATA XREF: mwServiceResolve_new+46o

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	eax, eax
		jz	short loc_10013D3F
		test	edx, edx
		jz	short loc_10013D5A
		cmp	[eax+38h], edx
		jnz	short loc_10013D75
		mov	[ebp+arg_0], eax
		pop	ebp
		jmp	mwService_started
; ---------------------------------------------------------------------------

loc_10013D3F:				; CODE XREF: sub_10013D20+Bj
		mov	[ebp+arg_8], offset aSrvcNull_7	; "srvc	!= NULL"
		mov	[ebp+arg_4], offset aRecv_accept_1 ; "recv_accept"
		mov	[ebp+arg_0], offset aMeanwhile_12 ; "meanwhile"
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_10013D5A:				; CODE XREF: sub_10013D20+Fj
		mov	[ebp+arg_8], offset aChanNull_8	; "chan	!= NULL"
		mov	[ebp+arg_4], offset aRecv_accept_1 ; "recv_accept"
		mov	[ebp+arg_0], offset aMeanwhile_12 ; "meanwhile"
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_10013D75:				; CODE XREF: sub_10013D20+14j
		mov	[ebp+arg_8], offset aChanSrvcChan_0 ; "chan == srvc->channel"
		mov	[ebp+arg_4], offset aRecv_accept_1 ; "recv_accept"
		mov	[ebp+arg_0], offset aMeanwhile_12 ; "meanwhile"
		pop	ebp
		jmp	g_return_if_fail_warning
sub_10013D20	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10013D90	proc near		; DATA XREF: mwServiceStorage_new+2Eo
		push	ebp
		mov	eax, offset aUserStorage ; "User Storage"
		mov	ebp, esp
		pop	ebp
		retn
sub_10013D90	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10013DA0	proc near		; DATA XREF: mwServiceStorage_new+35o
		push	ebp
		mov	eax, offset aStoresUserData ; "Stores user data	and settings on	the se"...
		mov	ebp, esp
		pop	ebp
		retn
sub_10013DA0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10013DB0	proc near		; CODE XREF: mwServiceStorage_save+20p
					; mwServiceStorage_load+20p

var_18		= dword	ptr -18h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[esp+18h+var_18], 1Ch
		mov	[ebp+var_C], ebx
		mov	ebx, eax
		mov	[ebp+var_8], esi
		mov	esi, edx
		mov	[ebp+var_4], edi
		mov	edi, ecx
		call	g_malloc0
		mov	edx, [ebx+40h]
		add	edx, 1
		mov	[ebx+40h], edx
		mov	[eax], edx
		mov	edx, [ebp+arg_0]
		mov	[eax+0Ch], esi
		mov	[eax+10h], edi
		mov	[eax+14h], edx
		mov	edx, [ebp+arg_4]
		mov	[eax+18h], edx
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
sub_10013DB0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 353. mwStorageUnit_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwStorageUnit_new
mwStorageUnit_new proc near

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[esp+8+var_8], 0Ch
		call	g_malloc0
		mov	edx, [ebp+arg_0]
		mov	[eax], edx
		leave
		retn
mwStorageUnit_new endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 355. mwStorageUnit_newInteger

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwStorageUnit_newInteger
mwStorageUnit_newInteger proc near	; CODE XREF: mwStorageUnit_newBoolean+4j

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[esp+18h+var_18], 0Ch
		mov	[ebp+var_8], ebx
		mov	[ebp+var_4], esi
		call	g_malloc0
		mov	ebx, eax
		mov	eax, [ebp+arg_0]
		mov	[ebx], eax
		call	mwPutBuffer_new
		mov	esi, eax
		mov	eax, [ebp+arg_4]
		mov	[esp+18h+var_18], esi
		mov	[esp+18h+var_14], eax
		call	guint32_put
		lea	eax, [ebx+4]
		mov	[esp+18h+var_14], esi
		mov	[esp+18h+var_18], eax
		call	mwPutBuffer_finalize
		mov	eax, ebx
		mov	esi, [ebp+var_4]
		mov	ebx, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn
mwStorageUnit_newInteger endp

; Exported entry 354. mwStorageUnit_newBoolean

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwStorageUnit_newBoolean
mwStorageUnit_newBoolean proc near
		push	ebp
		mov	ebp, esp
		pop	ebp
		jmp	short mwStorageUnit_newInteger
mwStorageUnit_newBoolean endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10013E80	proc near		; CODE XREF: mwServiceStorage_save+5Fj
					; mwServiceStorage_load+5Fj ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h

		push	ebp
		mov	ebp, esp
		push	edi
		mov	edi, eax
		push	esi
		mov	esi, edx
		push	ebx
		sub	esp, 1Ch
		mov	[ebp+var_14], 0
		mov	[ebp+var_10], 0
		call	mwPutBuffer_new
		mov	ebx, eax
		mov	eax, [esi]
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	guint32_put
		mov	[esp+28h+var_24], 1
		mov	[esp+28h+var_28], ebx
		call	guint32_put
		cmp	dword ptr [esi+8], 6
		jz	short loc_10013F30
		mov	eax, [esi+0Ch]
		mov	eax, [eax]
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	guint32_put

loc_10013ED7:				; CODE XREF: sub_10013E80+E8j
		mov	[esp+28h+var_24], ebx
		lea	ebx, [ebp+var_14]
		mov	[esp+28h+var_28], ebx
		call	mwPutBuffer_finalize
		mov	[esp+28h+var_20], ebx
		mov	eax, [esi+8]
		mov	[esp+28h+var_28], edi
		mov	[esp+28h+var_24], eax
		call	mwChannel_send
		mov	[esp+28h+var_28], ebx
		mov	edi, eax
		call	mwOpaque_clear
		test	edi, edi
		jnz	short loc_10013F20
		mov	eax, [esi+8]
		cmp	eax, 6
		jz	short loc_10013F70
		cmp	eax, 4
		jnz	short loc_10013F20
		mov	dword ptr [esi+8], 5
		nop
		lea	esi, [esi+0]

loc_10013F20:				; CODE XREF: sub_10013E80+85j
					; sub_10013E80+92j
		add	esp, 1Ch
		mov	eax, edi
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10013F30:				; CODE XREF: sub_10013E80+44j
		mov	eax, [esi+0Ch]
		mov	eax, [eax+4]
		mov	[esp+28h+var_28], ebx
		add	eax, 14h
		mov	[esp+28h+var_24], eax
		call	guint32_put
		mov	eax, [esi+0Ch]
		mov	eax, [eax]
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	guint32_put
		mov	eax, [esi+0Ch]
		mov	[esp+28h+var_28], ebx
		add	eax, 4
		mov	[esp+28h+var_24], eax
		call	mwOpaque_put
		jmp	loc_10013ED7
; ---------------------------------------------------------------------------
		align 10h

loc_10013F70:				; CODE XREF: sub_10013E80+8Dj
		mov	dword ptr [esi+8], 7
		mov	eax, edi
		add	esp, 1Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
sub_10013E80	endp

; ---------------------------------------------------------------------------
		jmp	short mwServiceStorage_save
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 294. mwServiceStorage_save

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceStorage_save
mwServiceStorage_save proc near		; CODE XREF: .text:10013F81j

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	eax, [ebp+arg_10]
		mov	esi, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		mov	ecx, [ebp+arg_8]
		mov	[esp+18h+var_14], eax
		mov	eax, [ebp+arg_C]
		mov	[esp+18h+var_18], eax
		mov	eax, esi
		call	sub_10013DB0
		mov	dword ptr [eax+8], 6
		mov	ebx, eax
		mov	[esp+18h+var_14], eax
		mov	eax, [esi+38h]
		mov	[esp+18h+var_18], eax
		call	g_list_append
		mov	[esi+38h], eax
		mov	[esp+18h+var_18], esi
		call	mwService_getState
		cmp	eax, 2
		jz	short loc_10013FE4
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10013FE4:				; CODE XREF: mwServiceStorage_save+4Bj
		mov	eax, [esi+3Ch]
		mov	edx, ebx
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	sub_10013E80
mwServiceStorage_save endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 292. mwServiceStorage_load

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceStorage_load
mwServiceStorage_load proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	eax, [ebp+arg_10]
		mov	esi, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		mov	ecx, [ebp+arg_8]
		mov	[esp+18h+var_14], eax
		mov	eax, [ebp+arg_C]
		mov	[esp+18h+var_18], eax
		mov	eax, esi
		call	sub_10013DB0
		mov	dword ptr [eax+8], 4
		mov	ebx, eax
		mov	[esp+18h+var_14], eax
		mov	eax, [esi+38h]
		mov	[esp+18h+var_18], eax
		call	g_list_append
		mov	[esi+38h], eax
		mov	[esp+18h+var_18], esi
		call	mwService_getState
		cmp	eax, 2
		jz	short loc_10014054
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10014054:				; CODE XREF: mwServiceStorage_load+4Bj
		mov	eax, [esi+3Ch]
		mov	edx, ebx
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	sub_10013E80
mwServiceStorage_load endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 351. mwStorageUnit_free

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwStorageUnit_free
mwStorageUnit_free proc	near		; CODE XREF: sub_100140A0+2Cp

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_10014096
		lea	eax, [ebx+4]
		mov	[esp+8+var_8], eax
		call	mwOpaque_clear
		mov	[ebp+arg_0], ebx
		add	esp, 4
		pop	ebx
		pop	ebp
		jmp	g_free
; ---------------------------------------------------------------------------

loc_10014096:				; CODE XREF: mwStorageUnit_free+Cj
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
mwStorageUnit_free endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100140A0	proc near		; CODE XREF: sub_100143A0+16p
					; sub_100143F0+42p ...

var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		push	ebx
		mov	ebx, eax
		sub	esp, 4
		mov	edx, [eax+18h]
		test	edx, edx
		jz	short loc_100140C6
		mov	eax, [eax+14h]
		mov	[esp+8+var_8], eax
		call	edx
		mov	dword ptr [ebx+14h], 0
		mov	dword ptr [ebx+18h], 0

loc_100140C6:				; CODE XREF: sub_100140A0+Ej
		mov	eax, [ebx+0Ch]
		mov	[esp+8+var_8], eax
		call	mwStorageUnit_free
		mov	[esp+8+var_8], ebx
		call	g_free
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
sub_100140A0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 349. mwStorageUnit_asOpaque

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwStorageUnit_asOpaque
mwStorageUnit_asOpaque proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_100140F2
		leave
		add	eax, 4
		retn
; ---------------------------------------------------------------------------

loc_100140F2:				; CODE XREF: mwStorageUnit_asOpaque+Bj
		mov	[esp+18h+var_10], offset aItemNull ; "item != NULL"
		mov	[esp+18h+var_14], offset aMwstorageunit_ ; "mwStorageUnit_asOpaque"
		mov	[esp+18h+var_18], offset aMeanwhile_13 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwStorageUnit_asOpaque endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 352. mwStorageUnit_getKey

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwStorageUnit_getKey
mwStorageUnit_getKey proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10014131
		mov	eax, [eax]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10014131:				; CODE XREF: mwStorageUnit_getKey+Bj
		mov	[esp+18h+var_10], offset aItemNull ; "item != NULL"
		mov	[esp+18h+var_14], offset aMwstorageuni_0 ; "mwStorageUnit_getKey"
		mov	[esp+18h+var_18], offset aMeanwhile_13 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwStorageUnit_getKey endp

; ---------------------------------------------------------------------------
		jmp	short mwStorageUnit_asString
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 350. mwStorageUnit_asString

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwStorageUnit_asString
mwStorageUnit_asString proc near	; CODE XREF: .text:10014151j

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], 0
		test	eax, eax
		jz	short loc_100141CE
		add	eax, 4
		mov	[esp+28h+var_28], eax
		call	mwGetBuffer_wrap
		mov	ebx, eax
		lea	eax, [ebp+var_8]
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_28], ebx
		call	mwString_get
		mov	[esp+28h+var_28], ebx
		call	mwGetBuffer_error
		test	eax, eax
		jnz	short loc_100141B0

loc_1001419D:				; CODE XREF: mwStorageUnit_asString+6Cj
		mov	[esp+28h+var_28], ebx
		call	mwGetBuffer_free
		mov	eax, [ebp+var_8]

loc_100141A8:				; CODE XREF: mwStorageUnit_asString+8Cj
		add	esp, 24h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_100141B0:				; CODE XREF: mwStorageUnit_asString+3Bj
		mov	[esp+28h+var_20], offset aErrorObtaining ; "error obtaining string value from opaqu"...
		mov	[esp+28h+var_24], 80h
		mov	[esp+28h+var_28], offset aMeanwhile_13 ; "meanwhile"
		call	g_log
		jmp	short loc_1001419D
; ---------------------------------------------------------------------------

loc_100141CE:				; CODE XREF: mwStorageUnit_asString+13j
		mov	[esp+28h+var_20], offset aItemNull ; "item != NULL"
		mov	[esp+28h+var_24], offset aMwstorageuni_1 ; "mwStorageUnit_asString"
		mov	[esp+28h+var_28], offset aMeanwhile_13 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		jmp	short loc_100141A8
mwStorageUnit_asString endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 348. mwStorageUnit_asInteger

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwStorageUnit_asInteger
mwStorageUnit_asInteger	proc near	; CODE XREF: mwStorageUnit_asBoolean+13p

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 20h
		mov	eax, [ebp+arg_0]
		mov	esi, [ebp+arg_4]
		test	eax, eax
		jz	short loc_1001423D
		add	eax, 4
		mov	[esp+28h+var_28], eax
		call	mwGetBuffer_wrap
		mov	ebx, eax
		lea	eax, [ebp+var_C]
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_28], ebx
		call	guint32_get
		mov	[esp+28h+var_28], ebx
		call	mwGetBuffer_error
		mov	[esp+28h+var_28], ebx
		test	eax, eax
		cmovz	esi, [ebp+var_C]
		call	mwGetBuffer_free

loc_10014234:				; CODE XREF: mwStorageUnit_asInteger+69j
		add	esp, 20h
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1001423D:				; CODE XREF: mwStorageUnit_asInteger+10j
		mov	[esp+28h+var_20], offset aItemNull ; "item != NULL"
		mov	[esp+28h+var_24], offset aMwstorageuni_2 ; "mwStorageUnit_asInteger"
		mov	[esp+28h+var_28], offset aMeanwhile_13 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10014234
mwStorageUnit_asInteger	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 347. mwStorageUnit_asBoolean

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwStorageUnit_asBoolean
mwStorageUnit_asBoolean	proc near

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+arg_4]
		mov	[esp+8+var_4], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+8+var_8], eax
		call	mwStorageUnit_asInteger
		leave
		test	eax, eax
		setnz	al
		movzx	eax, al
		retn
mwStorageUnit_asBoolean	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 357. mwStorageUnit_newString

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl mwStorageUnit_newString(int, char	*)
		public mwStorageUnit_newString
mwStorageUnit_newString	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[esp+18h+var_18], 0Ch
		mov	[ebp+var_8], ebx
		mov	[ebp+var_4], esi
		call	g_malloc0
		mov	ebx, eax
		mov	eax, [ebp+arg_0]
		mov	[ebx], eax
		call	mwPutBuffer_new
		mov	esi, eax
		mov	eax, [ebp+arg_4]
		mov	[esp+18h+var_18], esi ;	int
		mov	[esp+18h+var_14], eax ;	char *
		call	mwString_put
		lea	eax, [ebx+4]
		mov	[esp+18h+var_14], esi
		mov	[esp+18h+var_18], eax
		call	mwPutBuffer_finalize
		mov	eax, ebx
		mov	esi, [ebp+var_4]
		mov	ebx, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn
mwStorageUnit_newString	endp

; Exported entry 356. mwStorageUnit_newOpaque

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwStorageUnit_newOpaque
mwStorageUnit_newOpaque	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[esp+18h+var_18], 0Ch
		mov	[ebp+var_8], ebx
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_4]
		call	g_malloc0
		test	esi, esi
		mov	ebx, eax
		mov	eax, [ebp+arg_0]
		mov	[ebx], eax
		jz	short loc_10014315
		lea	eax, [ebx+4]
		mov	[esp+18h+var_14], esi
		mov	[esp+18h+var_18], eax
		call	mwOpaque_clone

loc_10014315:				; CODE XREF: mwStorageUnit_newOpaque+24j
		mov	eax, ebx
		mov	esi, [ebp+var_4]
		mov	ebx, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn
mwStorageUnit_newOpaque	endp

; ---------------------------------------------------------------------------
		jmp	short mwServiceStorage_new
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 293. mwServiceStorage_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwServiceStorage_new
mwServiceStorage_new proc near		; CODE XREF: .text:10014321j

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	[esp+18h+var_18], 44h
		call	g_malloc0
		mov	[esp+18h+var_10], 18h
		mov	ebx, eax
		mov	eax, [ebp+arg_0]
		mov	[esp+18h+var_18], ebx
		mov	[esp+18h+var_14], eax
		call	mwService_init
		mov	eax, ebx
		mov	dword ptr [ebx+0Ch], offset sub_10013D90
		mov	dword ptr [ebx+10h], offset sub_10013DA0
		mov	dword ptr [ebx+18h], offset sub_100148C0
		mov	dword ptr [ebx+1Ch], offset sub_10014830
		mov	dword ptr [ebx+20h], offset sub_10014530
		mov	dword ptr [ebx+24h], offset sub_10014490
		mov	dword ptr [ebx+28h], offset sub_100143F0
		mov	dword ptr [ebx+2Ch], offset sub_100143A0
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
mwServiceStorage_new endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100143A0	proc near		; DATA XREF: mwServiceStorage_new+5Fo

var_18		= dword	ptr -18h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_0]
		mov	eax, [esi+38h]
		test	eax, eax
		mov	ebx, eax
		jz	short loc_100143C5

loc_100143B4:				; CODE XREF: sub_100143A0+20j
		mov	eax, [ebx]
		call	sub_100140A0
		mov	ebx, [ebx+4]
		test	ebx, ebx
		jnz	short loc_100143B4
		mov	eax, [esi+38h]

loc_100143C5:				; CODE XREF: sub_100143A0+12j
		mov	[esp+18h+var_18], eax
		call	g_list_free
		mov	dword ptr [esi+38h], 0
		mov	dword ptr [esi+40h], 0
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
sub_100143A0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100143F0	proc near		; DATA XREF: mwServiceStorage_new+58o

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_0]
		test	esi, esi
		jz	short loc_10014465
		mov	eax, [esi+3Ch]
		test	eax, eax
		jz	short loc_10014425
		mov	[esp+18h+var_10], 0
		mov	[esp+18h+var_14], 0
		mov	[esp+18h+var_18], eax
		call	mwChannel_destroy
		mov	dword ptr [esi+3Ch], 0

loc_10014425:				; CODE XREF: sub_100143F0+14j
		mov	eax, [esi+38h]
		test	eax, eax
		mov	ebx, eax
		jz	short loc_10014441
		xchg	ax, ax

loc_10014430:				; CODE XREF: sub_100143F0+4Cj
		mov	eax, [ebx]
		call	sub_100140A0
		mov	ebx, [ebx+4]
		test	ebx, ebx
		jnz	short loc_10014430
		mov	eax, [esi+38h]

loc_10014441:				; CODE XREF: sub_100143F0+3Cj
		mov	[esp+18h+var_18], eax
		call	g_list_free
		mov	dword ptr [esi+38h], 0
		mov	dword ptr [esi+40h], 0
		mov	[ebp+arg_0], esi
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	mwService_stopped
; ---------------------------------------------------------------------------

loc_10014465:				; CODE XREF: sub_100143F0+Dj
		mov	[esp+18h+var_10], offset aSrvcNull_8 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aStop_0 ; "stop"
		mov	[esp+18h+var_18], offset aMeanwhile_13 ; "meanwhile"
		call	g_return_if_fail_warning
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
sub_100143F0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10014490	proc near		; DATA XREF: mwServiceStorage_new+51o

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_0]
		test	esi, esi
		jz	short loc_1001450E
		mov	[esp+18h+var_18], esi
		call	mwService_getSession
		mov	[esp+18h+var_18], eax
		call	mwSession_getChannels
		mov	[esp+18h+var_18], eax
		call	mwChannel_newOutgoing
		mov	[esp+18h+var_14], esi
		mov	ebx, eax
		mov	[esp+18h+var_18], eax
		call	mwChannel_setService
		mov	[esp+18h+var_14], 25h
		mov	[esp+18h+var_18], ebx
		call	mwChannel_setProtoType
		mov	[esp+18h+var_14], 1
		mov	[esp+18h+var_18], ebx
		call	mwChannel_setProtoVer
		mov	[esp+18h+var_18], ebx
		call	mwChannel_create
		test	eax, eax
		jnz	short loc_10014500
		test	ebx, ebx
		jz	short loc_10014500
		mov	[esi+3Ch], ebx

loc_100144F8:				; CODE XREF: sub_10014490+9Aj
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10014500:				; CODE XREF: sub_10014490+5Fj
					; sub_10014490+63j
		mov	[ebp+arg_0], esi
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	mwService_stopped
; ---------------------------------------------------------------------------

loc_1001450E:				; CODE XREF: sub_10014490+Dj
		mov	[esp+18h+var_10], offset aSrvcNull_8 ; "srvc !=	NULL"
		mov	[esp+18h+var_14], offset aStart_0 ; "start"
		mov	[esp+18h+var_18], offset aMeanwhile_13 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100144F8
sub_10014490	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10014530	proc near		; DATA XREF: mwServiceStorage_new+4Ao

var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_26		= word ptr -26h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_18		= byte ptr -18h
var_14		= dword	ptr -14h
var_10		= byte ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= word ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 3Ch
		mov	ecx, [ebp+arg_0]
		movzx	edx, [ebp+arg_8]
		mov	eax, [ebp+arg_4]
		test	ecx, ecx
		mov	[ebp+var_26], dx
		jz	loc_100147CD
		test	eax, eax
		jz	loc_100147AC
		mov	edx, [ebp+arg_0]
		cmp	[edx+3Ch], eax
		jnz	loc_1001478B
		mov	edx, [ebp+arg_C]
		test	edx, edx
		jz	loc_100147EE
		mov	eax, [ebp+arg_C]
		mov	[esp+48h+var_48], eax
		call	mwGetBuffer_wrap
		mov	edi, eax
		mov	[esp+48h+var_48], eax
		call	guint32_peek
		mov	edx, [ebp+arg_0]
		mov	esi, eax
		mov	eax, [edx+38h]
		test	eax, eax
		jnz	short loc_1001459F
		jmp	loc_1001468A
; ---------------------------------------------------------------------------

loc_10014594:				; CODE XREF: sub_10014530+73j
		mov	eax, [eax+4]
		test	eax, eax
		jz	loc_1001468A

loc_1001459F:				; CODE XREF: sub_10014530+5Dj
		mov	ebx, [eax]
		cmp	esi, [ebx]
		jnz	short loc_10014594
		movzx	eax, [ebp+var_26]
		cmp	[ebx+8], eax
		mov	[ebp+var_2C], eax
		jnz	loc_1001480F
		mov	[esp+48h+var_48], edi
		call	mwGetBuffer_error
		test	eax, eax
		jz	loc_100146DA

loc_100145C5:				; CODE XREF: sub_10014530+1CCj
					; sub_10014530+1E6j ...
		mov	[esp+48h+var_48], edi
		call	mwGetBuffer_error
		test	eax, eax
		nop
		jnz	loc_100146BA
		mov	esi, [ebx+0Ch]
		mov	edx, [ebx+4]
		mov	eax, [esi]
		mov	[ebp+var_20], edx
		mov	ecx, [esi+4]
		mov	edx, offset aLoaded ; "loaded"
		mov	[ebp+var_24], eax
		mov	eax, [ebx+8]
		cmp	eax, 5
		jz	short loc_10014608
		ja	loc_10014760
		cmp	eax, 4
		jz	loc_10014781

loc_10014603:				; CODE XREF: sub_10014530+246j
		mov	edx, offset aUnknown_5 ; "UNKNOWN"

loc_10014608:				; CODE XREF: sub_10014530+C2j
					; sub_10014530+238j ...
		mov	[esp+48h+var_30], ecx
		mov	eax, [ebp+var_20]
		mov	[esp+48h+var_34], eax
		mov	eax, [ebp+var_24]
		mov	[esp+48h+var_3C], edx
		mov	[esp+48h+var_40], offset aStorageRequest ; "storage request %s:	key = 0x%x, result "...
		mov	[esp+48h+var_44], 20h
		mov	[esp+48h+var_38], eax
		mov	[esp+48h+var_48], offset aMeanwhile_13 ; "meanwhile"
		call	g_log
		mov	edx, [ebx+10h]
		test	edx, edx
		jz	short loc_1001465B
		mov	eax, [ebx+14h]
		mov	[esp+48h+var_40], esi
		mov	[esp+48h+var_3C], eax
		mov	eax, [ebx+4]
		mov	[esp+48h+var_44], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+48h+var_48], eax
		call	edx

loc_1001465B:				; CODE XREF: sub_10014530+10Fj
					; sub_10014530+1A8j
		mov	[esp+48h+var_48], edi
		call	mwGetBuffer_free
		mov	[esp+48h+var_44], ebx
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+38h]
		mov	[esp+48h+var_48], eax
		call	g_list_remove_all
		mov	edx, [ebp+arg_0]
		mov	[edx+38h], eax
		mov	eax, ebx
		call	sub_100140A0
		add	esp, 3Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1001468A:				; CODE XREF: sub_10014530+5Fj
					; sub_10014530+69j
		mov	[esp+48h+var_3C], esi
		mov	[esp+48h+var_40], offset aCouldnTFindReq ; "couldn't find request 0x%x in storage s"...
		mov	[esp+48h+var_44], 10h
		mov	[esp+48h+var_48], offset aMeanwhile_13 ; "meanwhile"
		call	g_log
		mov	[esp+48h+var_48], edi
		call	mwGetBuffer_free

loc_100146B2:				; CODE XREF: sub_10014530+277j
					; sub_10014530+298j ...
		add	esp, 3Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100146BA:				; CODE XREF: sub_10014530+A0j
		mov	edx, [ebp+var_2C]
		mov	[esp+48h+var_40], esi
		mov	[esp+48h+var_44], offset aStorageReque_0 ; "storage request 0x%x, type:	0x%x"
		mov	[esp+48h+var_3C], edx
		mov	eax, [ebp+arg_C]
		mov	[esp+48h+var_48], eax
		call	mw_mailme_opaque
		jmp	short loc_1001465B
; ---------------------------------------------------------------------------

loc_100146DA:				; CODE XREF: sub_10014530+8Fj
		lea	eax, [ebp+var_10]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], edi
		call	guint32_get
		lea	eax, [ebx+4]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], edi
		call	guint32_get
		cmp	dword ptr [ebx+8], 5
		jnz	loc_100145C5
		lea	eax, [ebp+var_14]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], edi
		call	guint32_get
		mov	eax, [ebp+var_14]
		test	eax, eax
		jz	loc_100145C5
		lea	eax, [ebp+var_18]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], edi
		call	guint32_get
		mov	eax, [ebx+0Ch]
		mov	[esp+48h+var_48], edi
		mov	[esp+48h+var_44], eax
		call	guint32_get
		mov	eax, [ebx+0Ch]
		add	eax, 4
		mov	[esp+48h+var_48], eax
		call	mwOpaque_clear
		mov	eax, [ebx+0Ch]
		mov	[esp+48h+var_48], edi
		add	eax, 4
		mov	[esp+48h+var_44], eax
		call	mwOpaque_get
		jmp	loc_100145C5
; ---------------------------------------------------------------------------
		align 10h

loc_10014760:				; CODE XREF: sub_10014530+C4j
		cmp	eax, 6
		mov	edx, offset aSave ; "save"
		jz	loc_10014608
		cmp	eax, 7
		mov	edx, offset aSaved ; "saved"
		jnz	loc_10014603
		jmp	loc_10014608
; ---------------------------------------------------------------------------

loc_10014781:				; CODE XREF: sub_10014530+CDj
		mov	edx, offset aLoad ; "load"
		jmp	loc_10014608
; ---------------------------------------------------------------------------

loc_1001478B:				; CODE XREF: sub_10014530+2Dj
		mov	[esp+48h+var_40], offset aChanSrvc_storC ; "chan == srvc_stor->channel"
		mov	[esp+48h+var_44], offset aRecv_6 ; "recv"
		mov	[esp+48h+var_48], offset aMeanwhile_13 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_100146B2
; ---------------------------------------------------------------------------

loc_100147AC:				; CODE XREF: sub_10014530+21j
		mov	[esp+48h+var_40], offset aChanNull_9 ; "chan !=	NULL"
		mov	[esp+48h+var_44], offset aRecv_6 ; "recv"
		mov	[esp+48h+var_48], offset aMeanwhile_13 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_100146B2
; ---------------------------------------------------------------------------

loc_100147CD:				; CODE XREF: sub_10014530+19j
		mov	[esp+48h+var_40], offset aSrvcNull_8 ; "srvc !=	NULL"
		mov	[esp+48h+var_44], offset aRecv_6 ; "recv"
		mov	[esp+48h+var_48], offset aMeanwhile_13 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_100146B2
; ---------------------------------------------------------------------------

loc_100147EE:				; CODE XREF: sub_10014530+38j
		mov	[esp+48h+var_40], offset aDataNull_5 ; "data !=	NULL"
		mov	[esp+48h+var_44], offset aRecv_6 ; "recv"
		mov	[esp+48h+var_48], offset aMeanwhile_13 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_100146B2
; ---------------------------------------------------------------------------

loc_1001480F:				; CODE XREF: sub_10014530+7Fj
		mov	[esp+48h+var_40], offset aReqActionType	; "req->action == type"
		mov	[esp+48h+var_44], offset aRecv_6 ; "recv"
		mov	[esp+48h+var_48], offset aMeanwhile_13 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	loc_100146B2
sub_10014530	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10014830	proc near		; DATA XREF: mwServiceStorage_new+43o

var_18		= dword	ptr -18h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_4], esi
		mov	eax, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_10014883
		test	eax, eax
		jz	short loc_100148A6
		mov	[esp+18h+var_18], ebx
		call	mwService_getSession
		test	eax, eax
		mov	esi, eax
		jz	short loc_100148AF
		mov	dword ptr [ebx+3Ch], 0
		mov	[esp+18h+var_18], ebx
		call	mwService_stop
		mov	[esp+18h+var_18], ebx
		call	mwService_getType
		mov	ebx, [ebp+var_8]
		mov	[ebp+arg_0], esi
		mov	esi, [ebp+var_4]
		mov	[ebp+arg_4], eax
		mov	esp, ebp
		pop	ebp
		jmp	mwSession_senseService
; ---------------------------------------------------------------------------

loc_10014883:				; CODE XREF: sub_10014830+14j
		mov	[ebp+arg_8], offset aSrvcNull_8	; "srvc	!= NULL"

loc_1001488A:				; CODE XREF: sub_10014830+7Dj
					; sub_10014830+86j
		mov	[ebp+arg_4], offset aRecv_channel_3 ; "recv_channelDestroy"
		mov	ebx, [ebp+var_8]
		mov	[ebp+arg_0], offset aMeanwhile_13 ; "meanwhile"
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_100148A6:				; CODE XREF: sub_10014830+18j
		mov	[ebp+arg_8], offset aChanNull_9	; "chan	!= NULL"
		jmp	short loc_1001488A
; ---------------------------------------------------------------------------

loc_100148AF:				; CODE XREF: sub_10014830+26j
		mov	[ebp+arg_8], offset aSessionNull_8 ; "session != NULL"
		jmp	short loc_1001488A
sub_10014830	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100148C0	proc near		; DATA XREF: mwServiceStorage_new+3Co

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		mov	esi, [ebp+arg_0]
		mov	eax, [ebp+arg_4]
		test	esi, esi
		jz	short loc_1001491A
		test	eax, eax
		jz	short loc_10014944
		mov	edi, [esi+3Ch]
		cmp	edi, eax
		jnz	short loc_1001493B
		mov	ebx, [esi+38h]
		test	ebx, ebx
		jnz	short loc_100148F3
		jmp	short loc_1001490B
; ---------------------------------------------------------------------------

loc_100148E7:				; CODE XREF: sub_100148C0+3Bj
		cmp	eax, 4
		jz	short loc_100148FD
		mov	ebx, [ebx+4]
		test	ebx, ebx
		jz	short loc_1001490B

loc_100148F3:				; CODE XREF: sub_100148C0+23j
					; sub_100148C0+49j
		mov	edx, [ebx]
		mov	eax, [edx+8]
		cmp	eax, 6
		jnz	short loc_100148E7

loc_100148FD:				; CODE XREF: sub_100148C0+2Aj
		mov	eax, edi
		call	sub_10013E80
		mov	ebx, [ebx+4]
		test	ebx, ebx
		jnz	short loc_100148F3

loc_1001490B:				; CODE XREF: sub_100148C0+25j
					; sub_100148C0+31j
		mov	[ebp+arg_0], esi
		add	esp, 0Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		jmp	mwService_started
; ---------------------------------------------------------------------------

loc_1001491A:				; CODE XREF: sub_100148C0+11j
		mov	[ebp+arg_8], offset aSrvcNull_8	; "srvc	!= NULL"

loc_10014921:				; CODE XREF: sub_100148C0+82j
					; sub_100148C0+8Bj
		mov	[ebp+arg_4], offset aRecv_channel_4 ; "recv_channelAccept"
		mov	[ebp+arg_0], offset aMeanwhile_13 ; "meanwhile"
		add	esp, 0Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_1001493B:				; CODE XREF: sub_100148C0+1Cj
		mov	[ebp+arg_8], offset aChanSrvc_storC ; "chan == srvc_stor->channel"
		jmp	short loc_10014921
; ---------------------------------------------------------------------------

loc_10014944:				; CODE XREF: sub_100148C0+15j
		mov	[ebp+arg_8], offset aChanNull_9	; "chan	!= NULL"
		jmp	short loc_10014921
sub_100148C0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10014950	proc near		; CODE XREF: sub_10014E40+184p
					; sub_10014E40+196p ...
		push	ebp
		test	eax, eax
		mov	ebp, esp
		push	ebx
		mov	ebx, edx
		jz	short loc_10014980
		movzx	edx, byte ptr [eax]
		test	dl, dl
		jnz	short loc_1001496E
		jmp	short loc_10014980
; ---------------------------------------------------------------------------

loc_10014963:				; CODE XREF: sub_10014950+20j
		movzx	edx, byte ptr [eax+1]
		add	eax, 1
		test	dl, dl
		jz	short loc_10014980

loc_1001496E:				; CODE XREF: sub_10014950+Fj
					; sub_10014950+2Dj
		cmp	dl, bl
		jnz	short loc_10014963
		movzx	edx, byte ptr [eax+1]
		mov	[eax], cl
		add	eax, 1
		test	dl, dl
		jnz	short loc_1001496E
		nop

loc_10014980:				; CODE XREF: sub_10014950+8j
					; sub_10014950+11j ...
		pop	ebx
		pop	ebp
		retn
sub_10014950	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 250. mwSametimeUser_getAlias

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeUser_getAlias
mwSametimeUser_getAlias	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_100149A2
		mov	eax, [eax+14h]
		leave
		retn
; ---------------------------------------------------------------------------

loc_100149A2:				; CODE XREF: mwSametimeUser_getAlias+Bj
		mov	[esp+18h+var_10], offset aUNull	; "u !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimeuser ; "mwSametimeUser_getAlias"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSametimeUser_getAlias	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 253. mwSametimeUser_getShortName

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeUser_getShortName
mwSametimeUser_getShortName proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_100149E2
		mov	eax, [eax+10h]
		leave
		retn
; ---------------------------------------------------------------------------

loc_100149E2:				; CODE XREF: mwSametimeUser_getShortName+Bj
		mov	[esp+18h+var_10], offset aUNull	; "u !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimeus_0 ; "mwSametimeUser_getShortName"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSametimeUser_getShortName endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 251. mwSametimeUser_getCommunity

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeUser_getCommunity
mwSametimeUser_getCommunity proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10014A22
		mov	eax, [eax+0Ch]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10014A22:				; CODE XREF: mwSametimeUser_getCommunity+Bj
		mov	[esp+18h+var_10], offset aUNull	; "u !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimeus_1 ; "mwSametimeUser_getCommunity"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSametimeUser_getCommunity endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 255. mwSametimeUser_getUser

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeUser_getUser
mwSametimeUser_getUser proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10014A62
		mov	eax, [eax+8]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10014A62:				; CODE XREF: mwSametimeUser_getUser+Bj
		mov	[esp+18h+var_10], offset aUNull	; "u !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimeus_2 ; "mwSametimeUser_getUser"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSametimeUser_getUser endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 254. mwSametimeUser_getType

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeUser_getType
mwSametimeUser_getType proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10014AA2
		mov	eax, [eax+4]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10014AA2:				; CODE XREF: mwSametimeUser_getType+Bj
		mov	[esp+18h+var_10], offset aUNull	; "u !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimeus_3 ; "mwSametimeUser_getType"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSametimeUser_getType endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 252. mwSametimeUser_getGroup

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeUser_getGroup
mwSametimeUser_getGroup	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10014AE1
		mov	eax, [eax]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10014AE1:				; CODE XREF: mwSametimeUser_getGroup+Bj
		mov	[esp+18h+var_10], offset aUNull	; "u !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimeus_4 ; "mwSametimeUser_getGroup"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSametimeUser_getGroup	endp

; ---------------------------------------------------------------------------
		jmp	short mwSametimeGroup_getList
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 227. mwSametimeGroup_getList

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeGroup_getList
mwSametimeGroup_getList	proc near	; CODE XREF: .text:10014B01j

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10014B21
		mov	eax, [eax]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10014B21:				; CODE XREF: mwSametimeGroup_getList+Bj
		mov	[esp+18h+var_10], offset aGNull	; "g !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimegrou ; "mwSametimeGroup_getList"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSametimeGroup_getList	endp

; ---------------------------------------------------------------------------
		jmp	short mwSametimeGroup_isOpen
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 231. mwSametimeGroup_isOpen

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeGroup_isOpen
mwSametimeGroup_isOpen proc near	; CODE XREF: .text:10014B41j

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10014B62
		mov	eax, [eax+10h]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10014B62:				; CODE XREF: mwSametimeGroup_isOpen+Bj
		mov	[esp+18h+var_10], offset aGNull	; "g !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimegr_0 ; "mwSametimeGroup_isOpen"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSametimeGroup_isOpen endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 234. mwSametimeGroup_setOpen

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeGroup_setOpen
mwSametimeGroup_setOpen	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10014BA5
		mov	edx, [ebp+arg_4]
		mov	[eax+10h], edx
		leave
		retn
; ---------------------------------------------------------------------------

loc_10014BA5:				; CODE XREF: mwSametimeGroup_setOpen+Bj
		mov	[esp+18h+var_10], offset aGNull	; "g !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimegr_1 ; "mwSametimeGroup_setOpen"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwSametimeGroup_setOpen	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 226. mwSametimeGroup_getAlias

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeGroup_getAlias
mwSametimeGroup_getAlias proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10014BE2
		mov	eax, [eax+0Ch]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10014BE2:				; CODE XREF: mwSametimeGroup_getAlias+Bj
		mov	[esp+18h+var_10], offset aGNull	; "g !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimegr_2 ; "mwSametimeGroup_getAlias"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSametimeGroup_getAlias endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 228. mwSametimeGroup_getName

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeGroup_getName
mwSametimeGroup_getName	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10014C22
		mov	eax, [eax+8]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10014C22:				; CODE XREF: mwSametimeGroup_getName+Bj
		mov	[esp+18h+var_10], offset aGNull	; "g !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimegr_3 ; "mwSametimeGroup_getName"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSametimeGroup_getName	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 229. mwSametimeGroup_getType

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeGroup_getType
mwSametimeGroup_getType	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10014C62
		mov	eax, [eax+4]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10014C62:				; CODE XREF: mwSametimeGroup_getType+Bj
		mov	[esp+18h+var_10], offset aGNull	; "g !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimegr_4 ; "mwSametimeGroup_getType"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSametimeGroup_getType	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 240. mwSametimeList_getMicro

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeList_getMicro
mwSametimeList_getMicro	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10014CA2
		mov	eax, [eax+8]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10014CA2:				; CODE XREF: mwSametimeList_getMicro+Bj
		mov	[esp+18h+var_10], offset aLNull	; "l !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimelist ; "mwSametimeList_getMicro"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSametimeList_getMicro	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 246. mwSametimeList_setMicro

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeList_setMicro
mwSametimeList_setMicro	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10014CE5
		mov	edx, [ebp+arg_4]
		mov	[eax+8], edx
		leave
		retn
; ---------------------------------------------------------------------------

loc_10014CE5:				; CODE XREF: mwSametimeList_setMicro+Bj
		mov	[esp+18h+var_10], offset aLNull	; "l !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimeli_0 ; "mwSametimeList_setMicro"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwSametimeList_setMicro	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 241. mwSametimeList_getMinor

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeList_getMinor
mwSametimeList_getMinor	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10014D22
		mov	eax, [eax+4]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10014D22:				; CODE XREF: mwSametimeList_getMinor+Bj
		mov	[esp+18h+var_10], offset aLNull	; "l !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimeli_1 ; "mwSametimeList_getMinor"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSametimeList_getMinor	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 247. mwSametimeList_setMinor

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeList_setMinor
mwSametimeList_setMinor	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10014D65
		mov	edx, [ebp+arg_4]
		mov	[eax+4], edx
		leave
		retn
; ---------------------------------------------------------------------------

loc_10014D65:				; CODE XREF: mwSametimeList_setMinor+Bj
		mov	[esp+18h+var_10], offset aLNull	; "l !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimeli_2 ; "mwSametimeList_setMinor"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwSametimeList_setMinor	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 239. mwSametimeList_getMajor

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeList_getMajor
mwSametimeList_getMajor	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10014DA1
		mov	eax, [eax]
		leave
		retn
; ---------------------------------------------------------------------------

loc_10014DA1:				; CODE XREF: mwSametimeList_getMajor+Bj
		mov	[esp+18h+var_10], offset aLNull	; "l !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimeli_3 ; "mwSametimeList_getMajor"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSametimeList_getMajor	endp

; ---------------------------------------------------------------------------
		jmp	short mwSametimeList_setMajor
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 245. mwSametimeList_setMajor

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeList_setMajor
mwSametimeList_setMajor	proc near	; CODE XREF: .text:10014DC1j

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10014DE4
		mov	edx, [ebp+arg_4]
		mov	[eax], edx
		leave
		retn
; ---------------------------------------------------------------------------

loc_10014DE4:				; CODE XREF: mwSametimeList_setMajor+Bj
		mov	[esp+18h+var_10], offset aLNull	; "l !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimeli_4 ; "mwSametimeList_setMajor"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mwSametimeList_setMajor	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 243. mwSametimeList_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeList_new
mwSametimeList_new proc	near		; CODE XREF: mwSametimeList_load+13p

var_8		= dword	ptr -8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	[esp+8+var_8], 10h
		call	g_malloc0
		mov	dword ptr [eax], 3
		mov	dword ptr [eax+4], 1
		mov	dword ptr [eax+8], 3
		leave
		retn
mwSametimeList_new endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_10014E40	proc near		; CODE XREF: mwSametimeList_get+30p
					; mwSametimeList_load+1Ep

Src		= dword	ptr -48h
Format		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
Str		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h

		push	ebp
		mov	ebp, esp
		push	edi
		mov	edi, eax
		push	esi
		push	ebx
		sub	esp, 3Ch
		mov	[ebp+var_34], edx
		mov	[ebp+var_30], 0

loc_10014E55:				; CODE XREF: sub_10014E40+B6j
					; sub_10014E40+12Ej ...
		movzx	eax, byte ptr [edi]
		test	al, al
		jz	short loc_10014E86
		mov	ecx, ds:g_ascii_table
		movzx	eax, al
		mov	edx, [ecx]
		test	byte ptr [edx+eax*2+1],	1
		jz	short loc_10014E8E
		mov	esi, edi
		jmp	short loc_10014E7C
; ---------------------------------------------------------------------------

loc_10014E72:				; CODE XREF: sub_10014E40+44j
		movzx	eax, al
		test	byte ptr [edx+eax*2+1],	1
		jz	short loc_10014E90

loc_10014E7C:				; CODE XREF: sub_10014E40+30j
		add	esi, 1
		movzx	eax, byte ptr [esi]
		test	al, al
		jnz	short loc_10014E72

loc_10014E86:				; CODE XREF: sub_10014E40+1Aj
					; sub_10014E40+7Aj
		add	esp, 3Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10014E8E:				; CODE XREF: sub_10014E40+2Cj
		mov	esi, edi

loc_10014E90:				; CODE XREF: sub_10014E40+3Aj
		movzx	eax, byte ptr [esi+1]
		lea	edi, [esi+1]
		test	al, al
		jnz	short loc_10014EAE
		jmp	short loc_10014EB8
; ---------------------------------------------------------------------------
		align 10h

loc_10014EA0:				; CODE XREF: sub_10014E40+70j
		cmp	al, 0Dh
		jz	short loc_10014EB2
		add	edi, 1
		movzx	eax, byte ptr [edi]
		test	al, al
		jz	short loc_10014EB8

loc_10014EAE:				; CODE XREF: sub_10014E40+59j
		cmp	al, 0Ah
		jnz	short loc_10014EA0

loc_10014EB2:				; CODE XREF: sub_10014E40+62j
		mov	byte ptr [edi],	0
		add	edi, 1

loc_10014EB8:				; CODE XREF: sub_10014E40+5Bj
					; sub_10014E40+6Cj
		test	esi, esi
		jz	short loc_10014E86
		movzx	eax, byte ptr [esi]
		cmp	al, 55h
		jz	loc_10014F73
		cmp	al, 56h
		jz	short loc_10014EFB
		cmp	al, 47h
		lea	esi, [esi+0]
		jz	loc_10015070
		mov	[esp+48h+var_3C], esi
		mov	[esp+48h+var_40], offset aUnknownSametim ; "unknown sametime list data line:\n%s"
		mov	[esp+48h+Format], 10h
		mov	[esp+48h+Src], offset aMeanwhile_14 ; "meanwhile"
		call	g_log
		jmp	loc_10014E55
; ---------------------------------------------------------------------------

loc_10014EFB:				; CODE XREF: sub_10014E40+89j
		lea	eax, [ebp+var_18]
		mov	[esp+48h+var_38], eax
		lea	eax, [ebp+var_14]
		mov	[esp+48h+var_3C], eax
		lea	eax, [ebp+var_10]
		mov	[ebp+var_10], 0
		mov	[ebp+var_14], 0
		mov	[ebp+var_18], 0
		mov	[esp+48h+var_40], eax
		mov	[esp+48h+Format], offset aVersionU_U_U ; "Version=%u.%u.%u\n"
		mov	[esp+48h+Src], esi ; Src
		call	sscanf
		cmp	eax, 3
		jz	short loc_10014F5A
		mov	[esp+48h+var_3C], esi
		mov	[esp+48h+var_40], offset aStrangeSametim ; "strange sametime list version line:\n%s"
		mov	[esp+48h+Format], 10h
		mov	[esp+48h+Src], offset aMeanwhile_14 ; "meanwhile"
		call	g_log

loc_10014F5A:				; CODE XREF: sub_10014E40+F8j
		mov	eax, [ebp+var_10]
		mov	edx, [ebp+var_34]
		mov	[edx], eax
		mov	eax, [ebp+var_14]
		mov	[edx+4], eax
		mov	eax, [ebp+var_18]
		mov	[edx+8], eax
		jmp	loc_10014E55
; ---------------------------------------------------------------------------

loc_10014F73:				; CODE XREF: sub_10014E40+81j
		mov	[esp+48h+Src], esi ; Str
		call	strlen
		mov	ebx, eax
		mov	[esp+48h+Src], eax
		call	g_malloc0
		mov	[esp+48h+Src], ebx
		mov	[ebp+var_20], eax
		call	g_malloc0
		mov	ecx, [ebp+var_20]
		mov	[esp+48h+Format], offset aUSS ;	"U %s %s"
		mov	[esp+48h+Src], esi ; Src
		mov	[esp+48h+var_40], ecx
		mov	[ebp+var_24], eax
		mov	[esp+48h+var_3C], eax
		call	sscanf
		sub	eax, 1
		jle	loc_10015204

loc_10014FB7:				; CODE XREF: sub_10014E40+3E4j
		mov	eax, [ebp+var_20]
		mov	ecx, 20h
		mov	edx, 3Bh
		call	sub_10014950
		mov	eax, [ebp+var_24]
		mov	edx, 3Bh
		mov	ecx, 20h
		call	sub_10014950
		mov	edx, [ebp+var_20]
		test	edx, edx
		jz	short loc_10014FEE
		mov	eax, [ebp+var_20]
		cmp	byte ptr [eax],	0
		jnz	loc_100151DF

loc_10014FEE:				; CODE XREF: sub_10014E40+1A0j
					; sub_10014E40+3B1j
		mov	esi, 31h

loc_10014FF3:				; CODE XREF: sub_10014E40+3BFj
		mov	eax, [ebp+var_24]
		test	eax, eax
		jz	short loc_10015006
		mov	edx, [ebp+var_24]
		cmp	byte ptr [edx],	0
		jnz	loc_100151AF

loc_10015006:				; CODE XREF: sub_10014E40+1B8j
					; sub_10014E40+381j ...
		mov	[ebp+var_28], 0

loc_1001500D:				; CODE XREF: sub_10014E40+394j
		mov	[esp+48h+Src], 18h
		call	g_malloc0
		mov	edx, [ebp+var_20]
		mov	ecx, esi
		cmp	cl, 31h
		mov	ebx, eax
		mov	eax, [ebp+var_30]
		mov	[ebx+8], edx
		mov	[ebx], eax
		mov	eax, 1
		jz	short loc_1001503C
		xor	eax, eax
		cmp	cl, 32h
		setz	al
		add	eax, eax

loc_1001503C:				; CODE XREF: sub_10014E40+1F0j
		mov	[ebx+4], eax
		mov	eax, [ebp+var_24]
		mov	edx, [ebp+var_28]
		mov	[ebx+10h], eax
		mov	[esp+48h+Src], edx
		call	g_strdup
		mov	ecx, [ebp+var_30]
		mov	[ebx+14h], eax
		mov	[esp+48h+Format], ebx
		mov	eax, [ecx+14h]
		mov	[esp+48h+Src], eax
		call	g_list_append
		mov	edx, [ebp+var_30]
		mov	[edx+14h], eax
		jmp	loc_10014E55
; ---------------------------------------------------------------------------

loc_10015070:				; CODE XREF: sub_10014E40+90j
		mov	byte ptr [ebp+var_10], 4Fh
		mov	[esp+48h+Src], esi ; Str
		call	strlen
		mov	ebx, eax
		mov	[esp+48h+Src], eax
		call	g_malloc0
		mov	[esp+48h+Src], ebx
		mov	[ebp+Str], eax
		call	g_malloc0
		mov	ecx, [ebp+Str]
		mov	[esp+48h+Format], offset aGSSC ; "G %s %s %c\n"
		mov	[esp+48h+Src], esi ; Src
		mov	[esp+48h+var_40], ecx
		mov	ebx, eax
		lea	eax, [ebp+var_10]
		mov	[esp+48h+var_38], eax
		mov	[esp+48h+var_3C], ebx
		call	sscanf
		cmp	eax, 2
		jle	loc_10015141

loc_100150BE:				; CODE XREF: sub_10014E40+321j
		mov	eax, [ebp+Str]
		mov	ecx, 20h
		mov	edx, 3Bh
		call	sub_10014950
		mov	ecx, 20h
		mov	edx, 3Bh
		mov	eax, ebx
		call	sub_10014950
		mov	ecx, [ebp+Str]
		test	ecx, ecx
		jz	short loc_100150F0
		mov	eax, [ebp+Str]
		cmp	byte ptr [eax],	0
		jnz	short loc_10015166

loc_100150F0:				; CODE XREF: sub_10014E40+2A6j
		mov	[esp+48h+Src], 18h
		call	g_malloc0
		mov	edx, [ebp+var_34]
		mov	ecx, [ebp+Str]
		mov	[ebp+var_30], eax
		mov	[eax], edx
		mov	[eax+8], ecx

loc_1001510A:				; CODE XREF: sub_10014E40+35Aj
		mov	eax, 1

loc_1001510F:				; CODE XREF: sub_10014E40+36Aj
		mov	edx, [ebp+var_30]
		mov	ecx, [ebp+var_34]
		mov	[edx+4], eax
		xor	eax, eax
		cmp	byte ptr [ebp+var_10], 4Fh
		mov	[edx+0Ch], ebx
		setz	al
		mov	[edx+10h], eax
		mov	[esp+48h+Format], edx
		mov	eax, [ecx+0Ch]
		mov	[esp+48h+Src], eax
		call	g_list_append
		mov	edx, [ebp+var_34]
		mov	[edx+0Ch], eax
		jmp	loc_10014E55
; ---------------------------------------------------------------------------

loc_10015141:				; CODE XREF: sub_10014E40+278j
		mov	[esp+48h+var_3C], esi
		mov	[esp+48h+var_40], offset aStrangeSamet_0 ; "strange sametime list group	line:\n%s"
		mov	[esp+48h+Format], 10h
		mov	[esp+48h+Src], offset aMeanwhile_14 ; "meanwhile"
		call	g_log
		jmp	loc_100150BE
; ---------------------------------------------------------------------------

loc_10015166:				; CODE XREF: sub_10014E40+2AEj
		mov	[esp+48h+Src], eax ; Str
		call	strlen
		mov	edx, [ebp+Str]
		lea	eax, [edx+eax-1]
		movzx	esi, byte ptr [eax]
		mov	byte ptr [eax],	0
		mov	[esp+48h+Src], 18h
		call	g_malloc0
		mov	ecx, [ebp+var_34]
		mov	edx, [ebp+Str]
		mov	[eax], ecx
		mov	ecx, esi
		cmp	cl, 32h
		mov	[ebp+var_30], eax
		mov	[eax+8], edx
		jz	loc_1001510A
		xor	eax, eax
		cmp	cl, 33h
		setz	al
		add	eax, eax
		jmp	loc_1001510F
; ---------------------------------------------------------------------------

loc_100151AF:				; CODE XREF: sub_10014E40+1C0j
		mov	[esp+48h+Format], 2Ch ;	Ch
		mov	[esp+48h+Src], edx ; Str
		call	strrchr
		test	eax, eax
		jz	loc_10015006
		lea	ecx, [eax+1]
		mov	byte ptr [eax],	0
		mov	[ebp+var_28], ecx
		cmp	byte ptr [eax+1], 0
		jnz	loc_1001500D
		jmp	loc_10015006
; ---------------------------------------------------------------------------

loc_100151DF:				; CODE XREF: sub_10014E40+1A8j
		mov	[esp+48h+Format], offset SubStr	; "::"
		mov	[esp+48h+Src], eax ; Str
		call	strstr
		test	eax, eax
		jz	loc_10014FEE
		movzx	esi, byte ptr [eax-1]
		mov	byte ptr [eax-1], 0
		jmp	loc_10014FF3
; ---------------------------------------------------------------------------

loc_10015204:				; CODE XREF: sub_10014E40+171j
		mov	[esp+48h+var_3C], esi
		mov	[esp+48h+var_40], offset aStrangeSamet_1 ; "strange sametime list user line:\n%s"
		mov	[esp+48h+Format], 10h
		mov	[esp+48h+Src], offset aMeanwhile_14 ; "meanwhile"
		call	g_log
		jmp	loc_10014FB7
sub_10014E40	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 237. mwSametimeList_get

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeList_get
mwSametimeList_get proc	near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_8		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	ebx, [ebp+arg_4]
		mov	edx, [ebp+arg_0]
		mov	[ebp+var_8], 0
		test	ebx, ebx
		jz	short loc_10015276
		test	edx, edx
		jz	short loc_10015294
		lea	eax, [ebp+var_8]
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_28], edx
		call	mwString_get
		mov	eax, [ebp+var_8]
		mov	edx, ebx
		call	sub_10014E40
		mov	eax, [ebp+var_8]
		mov	[esp+28h+var_28], eax
		call	g_free

loc_10015270:				; CODE XREF: mwSametimeList_get+62j
					; mwSametimeList_get+80j
		add	esp, 24h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10015276:				; CODE XREF: mwSametimeList_get+16j
		mov	[esp+28h+var_20], offset aLNull	; "l !=	NULL"
		mov	[esp+28h+var_24], offset aMwsametimeli_5 ; "mwSametimeList_get"
		mov	[esp+28h+var_28], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10015270
; ---------------------------------------------------------------------------

loc_10015294:				; CODE XREF: mwSametimeList_get+1Aj
		mov	[esp+28h+var_20], offset aBNull_1 ; "b != NULL"
		mov	[esp+28h+var_24], offset aMwsametimeli_5 ; "mwSametimeList_get"
		mov	[esp+28h+var_28], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10015270
mwSametimeList_get endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 242. mwSametimeList_load

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeList_load
mwSametimeList_load proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		test	esi, esi
		jz	short loc_100152EF
		call	mwSametimeList_new
		mov	ebx, eax
		mov	edx, eax
		mov	eax, esi
		call	sub_10014E40

loc_100152E3:				; CODE XREF: mwSametimeList_load+4Dj
		mov	eax, ebx
		mov	esi, [ebp+var_4]
		mov	ebx, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100152EF:				; CODE XREF: mwSametimeList_load+11j
		mov	[esp+18h+var_10], offset aDataNull_6 ; "data !=	NULL"
		xor	ebx, ebx
		mov	[esp+18h+var_14], offset aMwsametimeli_6 ; "mwSametimeList_load"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100152E3
mwSametimeList_load endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 257. mwSametimeUser_setAlias

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeUser_setAlias
mwSametimeUser_setAlias	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_1001533D
		mov	eax, [ebx+14h]
		mov	[esp+18h+var_18], eax
		call	g_free
		mov	eax, [ebp+arg_4]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[ebx+14h], eax

loc_10015337:				; CODE XREF: mwSametimeUser_setAlias+49j
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1001533D:				; CODE XREF: mwSametimeUser_setAlias+Cj
		mov	[esp+18h+var_10], offset aUNull	; "u !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimeus_5 ; "mwSametimeUser_setAlias"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10015337
mwSametimeUser_setAlias	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 258. mwSametimeUser_setShortName

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeUser_setShortName
mwSametimeUser_setShortName proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_1001538D
		mov	eax, [ebx+10h]
		mov	[esp+18h+var_18], eax
		call	g_free
		mov	eax, [ebp+arg_4]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[ebx+10h], eax

loc_10015387:				; CODE XREF: mwSametimeUser_setShortName+49j
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1001538D:				; CODE XREF: mwSametimeUser_setShortName+Cj
		mov	[esp+18h+var_10], offset aUNull	; "u !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimeus_6 ; "mwSametimeUser_setShortName"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10015387
mwSametimeUser_setShortName endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 233. mwSametimeGroup_setAlias

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeGroup_setAlias
mwSametimeGroup_setAlias proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_100153DD
		mov	eax, [ebx+0Ch]
		mov	[esp+18h+var_18], eax
		call	g_free
		mov	eax, [ebp+arg_4]
		mov	[esp+18h+var_18], eax
		call	g_strdup
		mov	[ebx+0Ch], eax

loc_100153D7:				; CODE XREF: mwSametimeGroup_setAlias+49j
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100153DD:				; CODE XREF: mwSametimeGroup_setAlias+Cj
		mov	[esp+18h+var_10], offset aGNull	; "g !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimegr_5 ; "mwSametimeGroup_setAlias"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100153D7
mwSametimeGroup_setAlias endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 232. mwSametimeGroup_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeGroup_new
mwSametimeGroup_new proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_C], ebx
		mov	ebx, [ebp+arg_8]
		mov	[ebp+var_4], edi
		test	esi, esi
		jz	short loc_1001546B
		test	ebx, ebx
		jz	short loc_1001548B
		cmp	byte ptr [ebx],	0
		jz	loc_100154AB
		mov	[esp+18h+var_18], 18h
		lea	esi, [esi+0]
		call	g_malloc0
		mov	edi, eax
		mov	[eax], esi
		mov	eax, [ebp+arg_4]
		mov	[edi+4], eax
		mov	[esp+18h+var_18], ebx
		call	g_strdup
		mov	[edi+8], eax
		mov	[esp+18h+var_14], edi
		mov	eax, [esi+0Ch]
		mov	[esp+18h+var_18], eax
		call	g_list_append
		mov	[esi+0Ch], eax

loc_1001545C:				; CODE XREF: mwSametimeGroup_new+89j
					; mwSametimeGroup_new+A9j ...
		mov	eax, edi
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1001546B:				; CODE XREF: mwSametimeGroup_new+17j
		mov	[esp+18h+var_10], offset aListNull_0 ; "list !=	NULL"
		xor	edi, edi
		mov	[esp+18h+var_14], offset aMwsametimegr_6 ; "mwSametimeGroup_new"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1001545C
; ---------------------------------------------------------------------------

loc_1001548B:				; CODE XREF: mwSametimeGroup_new+1Bj
		mov	[esp+18h+var_10], offset aNameNull ; "name != NULL"
		xor	edi, edi
		mov	[esp+18h+var_14], offset aMwsametimegr_6 ; "mwSametimeGroup_new"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1001545C
; ---------------------------------------------------------------------------

loc_100154AB:				; CODE XREF: mwSametimeGroup_new+20j
		mov	[esp+18h+var_10], offset aName0	; "*name != '\\0'"
		xor	edi, edi
		mov	[esp+18h+var_14], offset aMwsametimegr_6 ; "mwSametimeGroup_new"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_1001545C
mwSametimeGroup_new endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100154D0	proc near		; CODE XREF: mwSametimeList_put+1Dp
					; mwSametimeList_store+Ep

var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		mov	ebx, eax
		sub	esp, 3Ch
		test	eax, eax
		jz	loc_10015708
		mov	[esp+48h+var_48], 0
		call	g_string_new
		mov	[ebp+var_24], eax
		mov	eax, [ebx+8]
		mov	[esp+48h+var_38], eax
		mov	eax, [ebx+4]
		mov	[esp+48h+var_3C], eax
		mov	eax, [ebx]
		mov	[esp+48h+var_44], offset aVersionU_U_U_0 ; "Version=%u.%u.%u\r\n"
		mov	[esp+48h+var_40], eax
		mov	eax, [ebp+var_24]
		mov	[esp+48h+var_48], eax
		call	g_string_append_printf
		mov	ebx, [ebx+0Ch]
		test	ebx, ebx
		mov	[ebp+var_20], ebx
		jz	loc_100156E9

loc_10015527:				; CODE XREF: sub_100154D0+213j
		mov	eax, [ebp+var_20]
		mov	esi, 32h
		mov	ebx, [eax]
		mov	eax, [ebx+8]
		mov	[esp+48h+var_48], eax
		call	g_strdup
		mov	[ebp+var_10], eax
		mov	eax, [ebx+0Ch]
		test	eax, eax
		cmovz	eax, [ebp+var_10]
		mov	[esp+48h+var_48], eax
		call	g_strdup
		mov	[ebp+var_18], eax
		mov	eax, [ebx+4]
		cmp	eax, 1
		jz	short loc_1001556A
		cmp	eax, 2
		mov	si, 33h
		mov	eax, 39h
		cmovnz	esi, eax

loc_1001556A:				; CODE XREF: sub_100154D0+89j
		mov	eax, [ebp+var_10]
		mov	ecx, 3Bh
		mov	edx, 20h
		call	sub_10014950
		mov	eax, [ebp+var_18]
		mov	ecx, 3Bh
		mov	edx, 20h
		call	sub_10014950
		cmp	dword ptr [ebx+10h], 1
		mov	[esp+48h+var_3C], esi
		mov	[esp+48h+var_44], offset aGSCSC	; "G %s%c %s %c\r\n"
		sbb	eax, eax
		and	eax, 0FFFFFFF4h
		add	eax, 4Fh
		mov	[esp+48h+var_34], eax
		mov	eax, [ebp+var_18]
		mov	[esp+48h+var_38], eax
		mov	eax, [ebp+var_10]
		mov	[esp+48h+var_40], eax
		mov	eax, [ebp+var_24]
		mov	[esp+48h+var_48], eax
		call	g_string_append_printf
		mov	ebx, [ebx+14h]
		test	ebx, ebx
		mov	[ebp+var_1C], ebx
		jz	loc_100156C2

loc_100155D1:				; CODE XREF: sub_100154D0+1ECj
		mov	eax, [ebp+var_1C]
		mov	ebx, [eax]
		mov	eax, [ebx+8]
		mov	[esp+48h+var_48], eax
		call	g_strdup
		mov	[ebp+var_14], eax
		mov	eax, [ebx+10h]
		mov	[esp+48h+var_48], eax
		call	g_strdup
		mov	esi, eax
		mov	eax, [ebx+14h]
		mov	[esp+48h+var_48], eax
		call	g_strdup
		mov	edi, eax
		mov	eax, [ebx+4]
		mov	ebx, 31h
		cmp	eax, 1
		jz	short loc_10015618
		cmp	eax, 2
		mov	bl, 32h
		mov	eax, 39h
		cmovnz	ebx, eax

loc_10015618:				; CODE XREF: sub_100154D0+139j
		mov	eax, [ebp+var_14]
		test	eax, eax
		jz	short loc_10015631
		mov	eax, [ebp+var_14]
		mov	ecx, 3Bh
		mov	edx, 20h
		call	sub_10014950

loc_10015631:				; CODE XREF: sub_100154D0+14Dj
		test	esi, esi
		jz	short loc_10015646
		mov	ecx, 3Bh
		mov	edx, 20h
		mov	eax, esi
		call	sub_10014950

loc_10015646:				; CODE XREF: sub_100154D0+163j
		test	edi, edi
		jz	loc_100156F4
		mov	eax, edi
		mov	ecx, 3Bh
		mov	edx, 20h
		call	sub_10014950
		test	esi, esi
		mov	eax, edi
		jnz	short loc_1001566E
		mov	esi, edi
		mov	eax, offset byte_100205E1
		xor	edi, edi

loc_1001566E:				; CODE XREF: sub_100154D0+193j
					; sub_100154D0+233j
		mov	edx, esi

loc_10015670:				; CODE XREF: sub_100154D0+22Dj
		mov	[esp+48h+var_34], eax
		mov	eax, [ebp+var_14]
		mov	[esp+48h+var_38], edx
		mov	[esp+48h+var_3C], ebx
		mov	[esp+48h+var_44], offset aUSCSS	; "U %s%c:: %s,%s\r\n"
		mov	[esp+48h+var_40], eax
		mov	eax, [ebp+var_24]
		mov	[esp+48h+var_48], eax
		call	g_string_append_printf
		mov	eax, [ebp+var_14]
		mov	[esp+48h+var_48], eax
		call	g_free
		mov	[esp+48h+var_48], esi
		call	g_free
		mov	[esp+48h+var_48], edi
		call	g_free
		mov	eax, [ebp+var_1C]
		mov	eax, [eax+4]
		test	eax, eax
		mov	[ebp+var_1C], eax
		jnz	loc_100155D1

loc_100156C2:				; CODE XREF: sub_100154D0+FBj
		mov	eax, [ebp+var_10]
		mov	[esp+48h+var_48], eax
		call	g_free
		mov	eax, [ebp+var_18]
		mov	[esp+48h+var_48], eax
		call	g_free
		mov	eax, [ebp+var_20]
		mov	eax, [eax+4]
		test	eax, eax
		mov	[ebp+var_20], eax
		jnz	loc_10015527

loc_100156E9:				; CODE XREF: sub_100154D0+51j
					; sub_100154D0+25Bj
		mov	eax, [ebp+var_24]
		add	esp, 3Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100156F4:				; CODE XREF: sub_100154D0+178j
		mov	edx, offset byte_100205E1
		test	esi, esi
		mov	eax, edx
		jz	loc_10015670
		jmp	loc_1001566E
; ---------------------------------------------------------------------------

loc_10015708:				; CODE XREF: sub_100154D0+Dj
		mov	[esp+48h+var_40], offset aLNull	; "l !=	NULL"
		mov	[esp+48h+var_44], offset aList_store ; "list_store"
		mov	[esp+48h+var_48], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		mov	[ebp+var_24], 0
		jmp	short loc_100156E9
sub_100154D0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 244. mwSametimeList_put

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeList_put
mwSametimeList_put proc	near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_0]
		mov	[ebp+var_C], ebx
		mov	[ebp+var_8], esi
		test	eax, eax
		jz	short loc_10015791
		test	edi, edi
		jz	short loc_100157BA
		call	sub_100154D0
		movzx	ebx, word ptr [eax+4]
		mov	esi, eax
		mov	[esp+18h+var_18], edi
		mov	[esp+18h+var_14], ebx
		call	guint16_put
		mov	[esp+18h+var_10], ebx ;	size_t
		mov	eax, [esi]
		mov	[esp+18h+var_18], edi ;	int
		mov	[esp+18h+var_14], eax ;	void *
		call	mwPutBuffer_write
		mov	ebx, [ebp+var_C]
		mov	[ebp+arg_0], esi
		mov	edi, [ebp+var_4]
		mov	[ebp+arg_4], 1
		mov	esi, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		jmp	g_string_free
; ---------------------------------------------------------------------------

loc_10015791:				; CODE XREF: mwSametimeList_put+17j
		mov	[esp+18h+var_10], offset aLNull	; "l !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimeli_7 ; "mwSametimeList_put"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning

loc_100157AD:				; CODE XREF: mwSametimeList_put+A6j
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100157BA:				; CODE XREF: mwSametimeList_put+1Bj
		mov	[esp+18h+var_10], offset aBNull_1 ; "b != NULL"
		mov	[esp+18h+var_14], offset aMwsametimeli_7 ; "mwSametimeList_put"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100157AD
mwSametimeList_put endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 248. mwSametimeList_store

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeList_store
mwSametimeList_store proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1001580D
		call	sub_100154D0
		mov	ebx, [eax]
		mov	[esp+18h+var_14], 0
		mov	[esp+18h+var_18], eax
		call	g_string_free

loc_10015805:				; CODE XREF: mwSametimeList_store+4Bj
		mov	eax, ebx
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1001580D:				; CODE XREF: mwSametimeList_store+Cj
		mov	[esp+18h+var_10], offset aLNull	; "l !=	NULL"
		xor	ebx, ebx
		mov	[esp+18h+var_14], offset aMwsametimeli_8 ; "mwSametimeList_store"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10015805
mwSametimeList_store endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 249. mwSametimeUser_free

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeUser_free
mwSametimeUser_free proc near		; CODE XREF: mwSametimeGroup_free+35p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_10015886
		mov	esi, [ebx]
		test	esi, esi
		jz	short loc_100158A9
		mov	[esp+18h+var_14], ebx
		mov	eax, [esi+14h]
		mov	[esp+18h+var_18], eax
		call	g_list_remove
		mov	[esi+14h], eax
		lea	eax, [ebx+8]
		mov	[esp+18h+var_18], eax
		call	mwIdBlock_clear
		mov	eax, [ebx+10h]
		mov	[esp+18h+var_18], eax
		call	g_free
		mov	eax, [ebx+14h]
		mov	[esp+18h+var_18], eax
		call	g_free
		mov	[ebp+arg_0], ebx
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	g_free
; ---------------------------------------------------------------------------

loc_10015886:				; CODE XREF: mwSametimeUser_free+Dj
		mov	[esp+18h+var_10], offset aUNull	; "u !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimeus_7 ; "mwSametimeUser_free"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning

loc_100158A2:				; CODE XREF: mwSametimeUser_free+95j
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100158A9:				; CODE XREF: mwSametimeUser_free+13j
		mov	[esp+18h+var_10], offset aUGroupNull ; "u->group != NULL"
		mov	[esp+18h+var_14], offset aMwsametimeus_7 ; "mwSametimeUser_free"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_100158A2
mwSametimeUser_free endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 225. mwSametimeGroup_free

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeGroup_free
mwSametimeGroup_free proc near		; CODE XREF: mwSametimeList_free+15p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_10015935
		mov	esi, [ebx]
		test	esi, esi
		jz	short loc_10015958
		mov	[esp+18h+var_14], ebx
		mov	eax, [esi+0Ch]
		mov	[esp+18h+var_18], eax
		call	g_list_remove
		mov	[esi+0Ch], eax
		mov	eax, [ebx+14h]
		test	eax, eax
		jz	short loc_10015911
		xchg	ax, ax

loc_10015900:				; CODE XREF: mwSametimeGroup_free+3Fj
		mov	eax, [eax]
		mov	[esp+18h+var_18], eax
		call	mwSametimeUser_free
		mov	eax, [ebx+14h]
		test	eax, eax
		jnz	short loc_10015900

loc_10015911:				; CODE XREF: mwSametimeGroup_free+2Cj
		mov	eax, [ebx+8]
		mov	[esp+18h+var_18], eax
		call	g_free
		mov	eax, [ebx+0Ch]
		mov	[esp+18h+var_18], eax
		call	g_free
		mov	[ebp+arg_0], ebx
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		jmp	g_free
; ---------------------------------------------------------------------------

loc_10015935:				; CODE XREF: mwSametimeGroup_free+Dj
		mov	[esp+18h+var_10], offset aGNull	; "g !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimegr_7 ; "mwSametimeGroup_free"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning

loc_10015951:				; CODE XREF: mwSametimeGroup_free+A4j
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10015958:				; CODE XREF: mwSametimeGroup_free+13j
		mov	[esp+18h+var_10], offset aGListNull ; "g->list != NULL"
		mov	[esp+18h+var_14], offset aMwsametimegr_7 ; "mwSametimeGroup_free"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10015951
mwSametimeGroup_free endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 236. mwSametimeList_free

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeList_free
mwSametimeList_free proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jnz	short loc_1001599A
		jmp	short loc_100159AE
; ---------------------------------------------------------------------------

loc_10015990:				; CODE XREF: mwSametimeList_free+1Fj
		mov	eax, [eax]
		mov	[esp+18h+var_18], eax
		call	mwSametimeGroup_free

loc_1001599A:				; CODE XREF: mwSametimeList_free+Cj
		mov	eax, [ebx+0Ch]
		test	eax, eax
		jnz	short loc_10015990
		mov	[ebp+arg_0], ebx
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	g_free
; ---------------------------------------------------------------------------

loc_100159AE:				; CODE XREF: mwSametimeList_free+Ej
		mov	[esp+18h+var_10], offset aLNull	; "l !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimeli_9 ; "mwSametimeList_free"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
mwSametimeList_free endp

; Exported entry 256. mwSametimeUser_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeUser_new
mwSametimeUser_new proc	near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_8]
		mov	[ebp+var_C], ebx
		test	esi, esi
		jz	short loc_10015A33
		test	edi, edi
		jz	short loc_10015A53
		mov	[esp+18h+var_18], 18h
		call	g_malloc0
		mov	ebx, eax
		mov	[eax], esi
		mov	eax, [ebp+arg_4]
		mov	[ebx+4], eax
		lea	eax, [ebx+8]
		mov	[esp+18h+var_18], eax
		mov	[esp+18h+var_14], edi
		call	mwIdBlock_clone
		mov	[esp+18h+var_14], ebx
		mov	eax, [esi+14h]
		mov	[esp+18h+var_18], eax
		call	g_list_append
		mov	[esi+14h], eax

loc_10015A24:				; CODE XREF: mwSametimeUser_new+81j
					; mwSametimeUser_new+A1j
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10015A33:				; CODE XREF: mwSametimeUser_new+17j
		mov	[esp+18h+var_10], offset aGroupNull ; "group !=	NULL"
		xor	ebx, ebx
		mov	[esp+18h+var_14], offset aMwsametimeus_8 ; "mwSametimeUser_new"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10015A24
; ---------------------------------------------------------------------------

loc_10015A53:				; CODE XREF: mwSametimeUser_new+1Bj
		mov	[esp+18h+var_10], offset aIdNull_0 ; "id != NULL"
		xor	ebx, ebx
		mov	[esp+18h+var_14], offset aMwsametimeus_8 ; "mwSametimeUser_new"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10015A24
mwSametimeUser_new endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 224. mwSametimeGroup_findUser

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeGroup_findUser
mwSametimeGroup_findUser proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		mov	eax, [ebp+arg_0]
		mov	edi, [ebp+arg_4]
		test	eax, eax
		jz	short loc_10015AD4
		test	edi, edi
		jz	short loc_10015AF4
		mov	ebx, [eax+14h]
		test	ebx, ebx
		jnz	short loc_10015AA9
		xchg	ax, ax
		jmp	short loc_10015AC8
; ---------------------------------------------------------------------------

loc_10015AA2:				; CODE XREF: mwSametimeGroup_findUser+3Cj
		mov	ebx, [ebx+4]
		test	ebx, ebx
		jz	short loc_10015AC8

loc_10015AA9:				; CODE XREF: mwSametimeGroup_findUser+1Cj
		mov	esi, [ebx]
		mov	[esp+18h+var_18], edi
		lea	eax, [esi+8]
		mov	[esp+18h+var_14], eax
		call	mwIdBlock_equal
		test	eax, eax
		jz	short loc_10015AA2

loc_10015ABE:				; CODE XREF: mwSametimeGroup_findUser+72j
					; mwSametimeGroup_findUser+92j
		add	esp, 0Ch
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10015AC8:				; CODE XREF: mwSametimeGroup_findUser+20j
					; mwSametimeGroup_findUser+27j
		xor	esi, esi
		add	esp, 0Ch
		mov	eax, esi
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10015AD4:				; CODE XREF: mwSametimeGroup_findUser+11j
		mov	[esp+18h+var_10], offset aGNull	; "g !=	NULL"
		xor	esi, esi
		mov	[esp+18h+var_14], offset aMwsametimegr_8 ; "mwSametimeGroup_findUser"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10015ABE
; ---------------------------------------------------------------------------

loc_10015AF4:				; CODE XREF: mwSametimeGroup_findUser+15j
		mov	[esp+18h+var_10], offset aUserNull_1 ; "user !=	NULL"
		xor	esi, esi
		mov	[esp+18h+var_14], offset aMwsametimegr_8 ; "mwSametimeGroup_findUser"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10015ABE
mwSametimeGroup_findUser endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 230. mwSametimeGroup_getUsers

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeGroup_getUsers
mwSametimeGroup_getUsers proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10015B39
		mov	eax, [eax+14h]
		mov	[ebp+arg_0], eax
		leave
		jmp	g_list_copy
; ---------------------------------------------------------------------------

loc_10015B39:				; CODE XREF: mwSametimeGroup_getUsers+Bj
		mov	[esp+18h+var_10], offset aGNull	; "g !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimegr_9 ; "mwSametimeGroup_getUsers"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSametimeGroup_getUsers endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 238. mwSametimeList_getGroups

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mwSametimeList_getGroups
mwSametimeList_getGroups proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_10015B79
		mov	eax, [eax+0Ch]
		mov	[ebp+arg_0], eax
		leave
		jmp	g_list_copy
; ---------------------------------------------------------------------------

loc_10015B79:				; CODE XREF: mwSametimeList_getGroups+Bj
		mov	[esp+18h+var_10], offset aLNull	; "l !=	NULL"
		mov	[esp+18h+var_14], offset aMwsametimel_10 ; "mwSametimeList_getGroups"
		mov	[esp+18h+var_18], offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		xor	eax, eax
		leave
		retn
mwSametimeList_getGroups endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 235. mwSametimeList_findGroup

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl mwSametimeList_findGroup(int, char *)
		public mwSametimeList_findGroup
mwSametimeList_findGroup proc near

Str1		= dword	ptr -18h
Str2		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		mov	eax, [ebp+arg_0]
		mov	esi, [ebp+arg_4]
		test	eax, eax
		jz	loc_10015C42
		test	esi, esi
		jz	short loc_10015C22
		cmp	byte ptr [esi],	0
		jz	short loc_10015C02
		mov	ebx, [eax+0Ch]
		test	ebx, ebx
		jnz	short loc_10015BD7
		jmp	short loc_10015BF6
; ---------------------------------------------------------------------------
		align 10h

loc_10015BD0:				; CODE XREF: mwSametimeList_findGroup+4Aj
		mov	ebx, [ebx+4]
		test	ebx, ebx
		jz	short loc_10015BF6

loc_10015BD7:				; CODE XREF: mwSametimeList_findGroup+25j
		mov	edi, [ebx]
		mov	eax, [edi+8]
		mov	[esp+18h+Str2],	esi ; Str2
		mov	[esp+18h+Str1],	eax ; Str1
		call	strcmp
		test	eax, eax
		jnz	short loc_10015BD0

loc_10015BEC:				; CODE XREF: mwSametimeList_findGroup+80j
					; mwSametimeList_findGroup+A0j	...
		add	esp, 0Ch
		mov	eax, edi
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10015BF6:				; CODE XREF: mwSametimeList_findGroup+27j
					; mwSametimeList_findGroup+35j
		xor	edi, edi
		add	esp, 0Ch
		mov	eax, edi
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10015C02:				; CODE XREF: mwSametimeList_findGroup+1Ej
		mov	[esp+18h+var_10], offset aName0	; "*name != '\\0'"
		xor	edi, edi
		mov	[esp+18h+Str2],	offset aMwsametimel_11 ; "mwSametimeList_findGroup"
		mov	[esp+18h+Str1],	offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10015BEC
; ---------------------------------------------------------------------------

loc_10015C22:				; CODE XREF: mwSametimeList_findGroup+19j
		mov	[esp+18h+var_10], offset aNameNull ; "name != NULL"
		xor	edi, edi
		mov	[esp+18h+Str2],	offset aMwsametimel_11 ; "mwSametimeList_findGroup"
		mov	[esp+18h+Str1],	offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10015BEC
; ---------------------------------------------------------------------------

loc_10015C42:				; CODE XREF: mwSametimeList_findGroup+11j
		mov	[esp+18h+var_10], offset aLNull	; "l !=	NULL"
		xor	edi, edi
		mov	[esp+18h+Str2],	offset aMwsametimel_11 ; "mwSametimeList_findGroup"
		mov	[esp+18h+Str1],	offset aMeanwhile_14 ; "meanwhile"
		call	g_return_if_fail_warning
		jmp	short loc_10015BEC
mwSametimeList_findGroup endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 374. mw_debug_datav

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_debug_datav
mw_debug_datav	proc near		; CODE XREF: mw_mailme_datav+4j
					; mw_debug_opaquev+27p	...

var_68		= dword	ptr -68h
var_64		= dword	ptr -64h
var_60		= dword	ptr -60h
var_5C		= dword	ptr -5Ch
var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_4C		= dword	ptr -4Ch
var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 5Ch
		mov	eax, [ebp+arg_8]
		mov	esi, [ebp+arg_0]
		mov	edi, [ebp+arg_4]
		mov	[ebp+var_10], eax
		mov	eax, [ebp+arg_C]
		test	esi, esi
		mov	[ebp+var_14], eax
		jz	loc_10015E0E

loc_10015C93:				; CODE XREF: mw_debug_datav+1A0j
		mov	[esp+68h+var_68], 0
		call	g_string_new
		mov	ebx, eax
		mov	eax, [ebp+var_10]
		test	eax, eax
		jz	short loc_10015CE0
		mov	eax, [ebp+var_14]
		mov	[esp+68h+var_64], eax
		mov	eax, [ebp+var_10]
		mov	[esp+68h+var_68], eax
		call	g_strdup_vprintf
		mov	[ebp+var_18], eax
		mov	[esp+68h+var_60], eax
		mov	[esp+68h+var_64], offset aS ; "%s\n"
		mov	[esp+68h+var_68], ebx
		call	g_string_append_printf
		mov	eax, [ebp+var_18]
		mov	[esp+68h+var_68], eax
		call	g_free
		lea	esi, [esi+0]

loc_10015CE0:				; CODE XREF: mw_debug_datav+36j
					; mw_debug_datav+180j
		cmp	edi, 0Fh
		jbe	loc_10015E37
		movzx	eax, byte ptr [esi+0Fh]
		mov	[esp+68h+var_24], eax
		movzx	eax, byte ptr [esi+0Eh]
		mov	[esp+68h+var_28], eax
		movzx	eax, byte ptr [esi+0Dh]
		mov	[esp+68h+var_2C], eax
		movzx	eax, byte ptr [esi+0Ch]
		mov	[esp+68h+var_30], eax
		movzx	eax, byte ptr [esi+0Bh]
		mov	[esp+68h+var_34], eax
		movzx	eax, byte ptr [esi+0Ah]
		mov	[esp+68h+var_38], eax
		movzx	eax, byte ptr [esi+9]
		mov	[esp+68h+var_3C], eax
		movzx	eax, byte ptr [esi+8]
		mov	[esp+68h+var_40], eax
		movzx	eax, byte ptr [esi+7]
		mov	[esp+68h+var_44], eax
		movzx	eax, byte ptr [esi+6]
		mov	[esp+68h+var_48], eax
		movzx	eax, byte ptr [esi+5]
		mov	[esp+68h+var_4C], eax
		movzx	eax, byte ptr [esi+4]
		mov	[esp+68h+var_50], eax
		movzx	eax, byte ptr [esi+3]
		mov	[esp+68h+var_54], eax
		movzx	eax, byte ptr [esi+2]
		mov	[esp+68h+var_58], eax
		movzx	eax, byte ptr [esi+1]
		mov	[esp+68h+var_5C], eax
		movzx	eax, byte ptr [esi]
		add	esi, 10h
		mov	[esp+68h+var_64], offset a02x02x02x02x02 ; "%02x%02x %02x%02x %02x%02x %02x%02x	%02"...
		mov	[esp+68h+var_60], eax
		mov	[esp+68h+var_68], ebx
		call	g_string_append_printf
		sub	edi, 10h
		jnz	short loc_10015DE0

loc_10015D80:				; CODE XREF: mw_debug_datav+224j
					; mw_debug_datav+25Fj
		cmp	edi, 1
		jbe	short loc_10015DAA
		movzx	eax, byte ptr [esi+1]
		sub	edi, 2
		mov	[esp+68h+var_5C], eax
		movzx	eax, byte ptr [esi]
		add	esi, 2
		mov	[esp+68h+var_64], offset a02x02x ; "%02x%02x "
		mov	[esp+68h+var_68], ebx
		mov	[esp+68h+var_60], eax
		call	g_string_append_printf

loc_10015DAA:				; CODE XREF: mw_debug_datav+113j
		test	edi, edi
		jnz	short loc_10015DF5

loc_10015DAE:				; CODE XREF: mw_debug_datav+19Cj
		mov	eax, [ebx]
		mov	[esp+68h+var_64], 80h
		mov	[esp+68h+var_68], offset aMeanwhile_15 ; "meanwhile"
		mov	[esp+68h+var_60], eax
		call	g_log
		mov	[ebp+arg_4], 1
		mov	[ebp+arg_0], ebx
		add	esp, 5Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		jmp	g_string_free
; ---------------------------------------------------------------------------
		align 10h

loc_10015DE0:				; CODE XREF: mw_debug_datav+10Ej
		mov	[esp+68h+var_64], offset asc_100209D1 ;	"\n"
		mov	[esp+68h+var_68], ebx
		call	g_string_append
		jmp	loc_10015CE0
; ---------------------------------------------------------------------------

loc_10015DF5:				; CODE XREF: mw_debug_datav+13Cj
		movzx	eax, byte ptr [esi]
		mov	[esp+68h+var_64], offset a02x ;	"%02x"
		mov	[esp+68h+var_68], ebx
		mov	[esp+68h+var_60], eax
		call	g_string_append_printf
		jmp	short loc_10015DAE
; ---------------------------------------------------------------------------

loc_10015E0E:				; CODE XREF: mw_debug_datav+1Dj
		test	edi, edi
		jz	loc_10015C93
		mov	[ebp+arg_8], offset aBufNullLen0 ; "buf	!= NULL	|| len == 0"
		mov	[ebp+arg_4], offset aMw_debug_datav ; "mw_debug_datav"
		mov	[ebp+arg_0], offset aMeanwhile_15 ; "meanwhile"
		add	esp, 5Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		jmp	g_return_if_fail_warning
; ---------------------------------------------------------------------------

loc_10015E37:				; CODE XREF: mw_debug_datav+73j
		cmp	edi, 7
		jbe	short loc_10015E91
		movzx	eax, byte ptr [esi+7]
		sub	edi, 8
		mov	[esp+68h+var_44], eax
		movzx	eax, byte ptr [esi+6]
		mov	[esp+68h+var_48], eax
		movzx	eax, byte ptr [esi+5]
		mov	[esp+68h+var_4C], eax
		movzx	eax, byte ptr [esi+4]
		mov	[esp+68h+var_50], eax
		movzx	eax, byte ptr [esi+3]
		mov	[esp+68h+var_54], eax
		movzx	eax, byte ptr [esi+2]
		mov	[esp+68h+var_58], eax
		movzx	eax, byte ptr [esi+1]
		mov	[esp+68h+var_5C], eax
		movzx	eax, byte ptr [esi]
		add	esi, 8
		mov	[esp+68h+var_64], offset a02x02x02x02x_0 ; "%02x%02x %02x%02x %02x%02x %02x%02x	"
		mov	[esp+68h+var_68], ebx
		mov	[esp+68h+var_60], eax
		call	g_string_append_printf

loc_10015E91:				; CODE XREF: mw_debug_datav+1CAj
		cmp	edi, 3
		jbe	loc_10015D80
		movzx	eax, byte ptr [esi+3]
		sub	edi, 4
		mov	[esp+68h+var_54], eax
		movzx	eax, byte ptr [esi+2]
		mov	[esp+68h+var_58], eax
		movzx	eax, byte ptr [esi+1]
		mov	[esp+68h+var_5C], eax
		movzx	eax, byte ptr [esi]
		add	esi, 4
		mov	[esp+68h+var_64], offset a02x02x02x02x ; "%02x%02x %02x%02x "
		mov	[esp+68h+var_68], ebx
		mov	[esp+68h+var_60], eax
		call	g_string_append_printf
		jmp	loc_10015D80
mw_debug_datav	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 378. mw_mailme_datav

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mailme_datav
mw_mailme_datav	proc near		; CODE XREF: mw_mailme_opaquev+23p
					; mw_mailme_data+24p
		push	ebp
		mov	ebp, esp
		pop	ebp
		jmp	mw_debug_datav
mw_mailme_datav	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 380. mw_mailme_opaquev

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mailme_opaquev
mw_mailme_opaquev proc near		; CODE XREF: mw_mailme_opaque+1Dp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_8]
		mov	edx, [ebp+arg_0]
		mov	[esp+18h+var_C], eax
		mov	eax, [ebp+arg_4]
		mov	[esp+18h+var_10], eax
		mov	eax, [edx]
		mov	[esp+18h+var_14], eax
		mov	eax, [edx+4]
		mov	[esp+18h+var_18], eax
		call	mw_mailme_datav
		leave
		retn
mw_mailme_opaquev endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 379. mw_mailme_opaque

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mailme_opaque
mw_mailme_opaque proc near		; CODE XREF: sub_10009A60+11Cp
					; sub_1000C570+102p ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		lea	eax, [ebp+arg_8]
		mov	[ebp+var_4], eax
		mov	[esp+28h+var_20], eax
		mov	eax, [ebp+arg_4]
		mov	[esp+28h+var_24], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+28h+var_28], eax
		call	mw_mailme_opaquev
		leave
		retn
mw_mailme_opaque endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 377. mw_mailme_data

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mailme_data
mw_mailme_data	proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= byte ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		lea	eax, [ebp+arg_C]
		mov	[ebp+var_4], eax
		mov	[esp+28h+var_1C], eax
		mov	eax, [ebp+arg_8]
		mov	[esp+28h+var_20], eax
		mov	eax, [ebp+arg_4]
		mov	[esp+28h+var_24], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+28h+var_28], eax
		call	mw_mailme_datav
		leave
		retn
mw_mailme_data	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 376. mw_debug_opaquev

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_debug_opaquev
mw_debug_opaquev proc near		; CODE XREF: mw_debug_opaque+21p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	edx, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	eax, [ebp+arg_8]
		test	edx, edx
		jz	short loc_10015FAE
		mov	[esp+18h+var_C], eax
		mov	[esp+18h+var_10], ecx
		mov	eax, [edx]
		mov	[esp+18h+var_14], eax
		mov	eax, [edx+4]
		mov	[esp+18h+var_18], eax
		call	mw_debug_datav
		leave
		retn
; ---------------------------------------------------------------------------

loc_10015FAE:				; CODE XREF: mw_debug_opaquev+11j
		mov	[ebp+arg_8], offset aONull_1 ; "o != NULL"
		mov	[ebp+arg_4], offset aMw_debug_opaqu ; "mw_debug_opaquev"
		mov	[ebp+arg_0], offset aMeanwhile_15 ; "meanwhile"
		leave
		jmp	g_return_if_fail_warning
mw_debug_opaquev endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 375. mw_debug_opaque

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_debug_opaque
mw_debug_opaque	proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= byte ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	edx, [ebp+arg_0]
		test	edx, edx
		jz	short loc_10015FF8
		lea	eax, [ebp+arg_8]
		mov	[ebp+var_4], eax
		mov	[esp+28h+var_20], eax
		mov	eax, [ebp+arg_4]
		mov	[esp+28h+var_28], edx
		mov	[esp+28h+var_24], eax
		call	mw_debug_opaquev
		leave
		retn
; ---------------------------------------------------------------------------

loc_10015FF8:				; CODE XREF: mw_debug_opaque+Bj
		mov	[esp+28h+var_20], offset aONull_1 ; "o != NULL"
		mov	[esp+28h+var_24], offset aMw_debug_opa_0 ; "mw_debug_opaque"
		mov	[esp+28h+var_28], offset aMeanwhile_15 ; "meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mw_debug_opaque	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 373. mw_debug_data

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_debug_data
mw_debug_data	proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= byte ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	edx, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		test	edx, edx
		jz	short loc_10016050

loc_10016030:				; CODE XREF: mw_debug_data+32j
		lea	eax, [ebp+arg_C]
		mov	[ebp+var_4], eax
		mov	[esp+28h+var_1C], eax
		mov	eax, [ebp+arg_8]
		mov	[esp+28h+var_24], ecx
		mov	[esp+28h+var_28], edx
		mov	[esp+28h+var_20], eax
		call	mw_debug_datav
		leave
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10016050:				; CODE XREF: mw_debug_data+Ej
		test	ecx, ecx
		jz	short loc_10016030
		mov	[esp+28h+var_20], offset aBufNullLen0 ;	"buf !=	NULL ||	len == 0"
		mov	[esp+28h+var_24], offset aMw_debug_data	; "mw_debug_data"
		mov	[esp+28h+var_28], offset aMeanwhile_15 ; "meanwhile"
		call	g_return_if_fail_warning
		leave
		retn
mw_debug_data	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 372. mw_datum_set

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_datum_set
mw_datum_set	proc near		; CODE XREF: mwChannel_setServiceData+1Dj
					; mwSession_setClientData+1Dj ...

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		mov	[eax], edx
		mov	edx, [ebp+arg_8]
		mov	[eax+4], edx
		pop	ebp
		retn
mw_datum_set	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 370. mw_datum_get

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_datum_get
mw_datum_get	proc near		; CODE XREF: mwChannel_getServiceData+14j
					; mwSession_getClientData+14j ...

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		pop	ebp
		mov	eax, [eax]
		retn
mw_datum_get	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 368. mw_datum_clear

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_datum_clear
mw_datum_clear	proc near		; CODE XREF: mwChannel_removeServiceData+14j
					; mwSession_removeClientData+14j ...

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		mov	edx, [ebx+4]
		test	edx, edx
		jz	short loc_100160CF
		mov	eax, [ebx]
		mov	[esp+8+var_8], eax
		call	edx
		mov	dword ptr [ebx+4], 0

loc_100160CF:				; CODE XREF: mw_datum_clear+Fj
		mov	dword ptr [ebx], 0
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
mw_datum_clear	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 369. mw_datum_free

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_datum_free
mw_datum_free	proc near		; DATA XREF: mwSession_new+78o

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		mov	[esp+8+var_8], ebx
		call	mw_datum_clear
		mov	[ebp+arg_0], ebx
		add	esp, 4
		pop	ebx
		pop	ebp
		jmp	g_free
mw_datum_free	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 371. mw_datum_new

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_datum_new
mw_datum_new	proc near		; CODE XREF: sub_10008ED0+1Dp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	[esp+18h+var_18], 8
		call	g_malloc
		mov	ebx, eax
		mov	eax, [ebp+arg_4]
		mov	[esp+18h+var_18], ebx
		mov	[esp+18h+var_10], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+18h+var_14], eax
		call	mw_datum_set
		mov	eax, ebx
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
mw_datum_new	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  11. map_collect_values

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public map_collect_values
map_collect_values proc	near		; CODE XREF: mwSession_getCiphers+18j
					; mwSession_getServices+18j ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		lea	eax, [ebp+var_4]
		mov	[esp+28h+var_20], eax
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_4], 0
		mov	[esp+28h+var_24], offset sub_100161A0
		mov	[esp+28h+var_28], eax
		call	g_hash_table_foreach
		mov	eax, [ebp+var_4]
		leave
		retn
map_collect_values endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry  10. map_collect_keys

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public map_collect_keys
map_collect_keys proc near		; CODE XREF: sub_1000B8F0+2Bp

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		lea	eax, [ebp+var_4]
		mov	[esp+28h+var_20], eax
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_4], 0
		mov	[esp+28h+var_24], offset sub_100161D0
		mov	[esp+28h+var_28], eax
		call	g_hash_table_foreach
		mov	eax, [ebp+var_4]
		leave
		retn
map_collect_keys endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100161A0	proc near		; DATA XREF: map_collect_values+17o

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_8]
		mov	eax, [ebp+arg_4]
		mov	[esp+18h+var_14], eax
		mov	eax, [ebx]
		mov	[esp+18h+var_18], eax
		call	g_list_append
		mov	[ebx], eax
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
sub_100161A0	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_100161D0	proc near		; DATA XREF: map_collect_keys+17o

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
arg_0		= dword	ptr  8
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_8]
		mov	eax, [ebp+arg_0]
		mov	[esp+18h+var_14], eax
		mov	eax, [ebx]
		mov	[esp+18h+var_18], eax
		call	g_list_append
		mov	[ebx], eax
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
sub_100161D0	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 406. mw_mp_get_prec

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_get_prec
mw_mp_get_prec	proc near
		push	ebp
		mov	eax, dword_1001B060
		mov	ebp, esp
		pop	ebp
		retn
mw_mp_get_prec	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 429. mw_mp_set_prec

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_set_prec
mw_mp_set_prec	proc near

arg_0		= dword	ptr  8

		push	ebp
		mov	eax, 20h
		mov	ebp, esp
		mov	edx, [ebp+arg_0]
		pop	ebp
		test	edx, edx
		cmovnz	eax, edx
		mov	dword_1001B060,	eax
		retn
mw_mp_set_prec	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 393. mw_mp_cmw_mp_z

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_cmw_mp_z
mw_mp_cmw_mp_z	proc near		; CODE XREF: mw_mp_radix_size+35p
					; s_mw_mp_div+1Ap ...

arg_0		= dword	ptr  8

		push	ebp
		mov	eax, 0FFFFFFFFh
		mov	ebp, esp
		mov	edx, [ebp+arg_0]
		cmp	byte ptr [edx],	1
		jz	short loc_1001624B
		cmp	dword ptr [edx+8], 1
		mov	eax, 1
		jz	short loc_10016250

loc_1001624B:				; CODE XREF: mw_mp_cmw_mp_z+Ej
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10016250:				; CODE XREF: mw_mp_cmw_mp_z+19j
		mov	eax, [edx+0Ch]
		pop	ebp
		cmp	word ptr [eax],	0
		setnz	al
		movzx	eax, al
		retn
mw_mp_cmw_mp_z	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 434. mw_mp_strerror

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_strerror
mw_mp_strerror	proc near

arg_0		= dword	ptr  8

		push	ebp
		mov	ecx, offset aUnknownResultC ; "unknown result code"
		mov	ebp, esp
		mov	edx, [ebp+arg_0]
		lea	eax, [edx+5]
		cmp	eax, 5
		ja	short loc_10016283
		mov	eax, edx
		sar	eax, 1Fh
		xor	edx, eax
		sub	edx, eax
		mov	ecx, ds:off_10020E3C[edx*4]

loc_10016283:				; CODE XREF: mw_mp_strerror+11j
		pop	ebp
		mov	eax, ecx
		retn
mw_mp_strerror	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 448. s_mw_mp_clamp

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_clamp
s_mw_mp_clamp	proc near		; CODE XREF: s_mw_mp_mod_2d+56j
					; s_mw_mp_sub_d+79p ...

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebx+8]
		lea	ecx, [eax+eax]
		add	ecx, [ebx+0Ch]
		cmp	eax, 1
		lea	edx, [ecx-2]
		jbe	short loc_100162D9
		cmp	word ptr [ecx-2], 0
		jnz	short loc_100162D3
		lea	edx, [ecx-4]
		jmp	short loc_100162BD
; ---------------------------------------------------------------------------

loc_100162B4:				; CODE XREF: s_mw_mp_clamp+33j
		cmp	word ptr [edx],	0
		jnz	short loc_100162D3
		sub	edx, 2

loc_100162BD:				; CODE XREF: s_mw_mp_clamp+22j
		sub	eax, 1
		cmp	eax, 1
		jnz	short loc_100162B4

loc_100162C5:				; CODE XREF: s_mw_mp_clamp+50j
		cmp	word ptr [edx],	0
		mov	eax, 1
		jnz	short loc_100162D3
		mov	byte ptr [ebx],	0

loc_100162D3:				; CODE XREF: s_mw_mp_clamp+1Dj
					; s_mw_mp_clamp+28j ...
		mov	[ebx+8], eax
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100162D9:				; CODE XREF: s_mw_mp_clamp+16j
		jnz	short loc_100162D3
		nop
		lea	esi, [esi+0]
		jmp	short loc_100162C5
s_mw_mp_clamp	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 455. s_mw_mp_exch

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_exch
s_mw_mp_exch	proc near		; CODE XREF: mw_mp_exch+1Bj
					; mw_mp_sub+1B1p ...

var_D		= byte ptr -0Dh
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_C], ebx
		mov	ecx, [ebp+arg_4]
		mov	[ebp+var_8], esi
		mov	[ebp+var_4], edi
		movzx	edx, byte ptr [eax]
		mov	edi, [eax+4]
		mov	esi, [eax+8]
		mov	ebx, [eax+0Ch]
		mov	[ebp+var_D], dl
		mov	edx, [ecx]
		mov	[eax], edx
		mov	edx, [ecx+4]
		mov	[eax+4], edx
		mov	edx, [ecx+8]
		mov	[eax+8], edx
		mov	edx, [ecx+0Ch]
		mov	[eax+0Ch], edx
		movzx	eax, [ebp+var_D]
		mov	[ecx+0Ch], ebx
		mov	[ecx+8], esi
		mov	[ecx+4], edi
		mov	[ecx], al
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
s_mw_mp_exch	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 460. s_mw_mp_mod_2d

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_mod_2d
s_mw_mp_mod_2d	proc near		; CODE XREF: mw_mp_div_2d+82p
					; s_mw_mp_div+6Ap ...

arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		mov	edi, [ebp+arg_0]
		movzx	ecx, [ebp+arg_4]
		mov	ebx, [edi+8]
		mov	eax, ecx
		mov	esi, [edi+0Ch]
		shr	ax, 4
		movzx	edx, ax
		cmp	edx, ebx
		jnb	short loc_100163AB
		and	ecx, 0Fh
		mov	eax, 1
		shl	eax, cl
		sub	eax, 1
		and	[esi+edx*2], ax
		lea	eax, [edx+1]
		cmp	ebx, eax
		jbe	short loc_1001639F
		lea	edx, [esi+eax*2]
		nop
		lea	esi, [esi+0]

loc_10016390:				; CODE XREF: s_mw_mp_mod_2d+4Dj
		add	eax, 1
		mov	word ptr [edx],	0
		add	edx, 2
		cmp	ebx, eax
		ja	short loc_10016390

loc_1001639F:				; CODE XREF: s_mw_mp_mod_2d+36j
		mov	[ebp+arg_0], edi
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		jmp	s_mw_mp_clamp
; ---------------------------------------------------------------------------

loc_100163AB:				; CODE XREF: s_mw_mp_mod_2d+1Ej
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
s_mw_mp_mod_2d	endp

; Exported entry 472. s_mw_mp_sub_d

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_sub_d
s_mw_mp_sub_d	proc near		; CODE XREF: mw_mp_sub_d+5Fp
					; mw_mp_add_d+6Bj

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch

		push	ebp
		xor	ecx, ecx
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 8
		mov	eax, [ebp+arg_0]
		mov	eax, [eax+8]
		mov	[ebp+var_10], eax
		mov	eax, [ebp+arg_0]
		mov	edi, [eax+0Ch]
		movzx	eax, [ebp+arg_4]
		movzx	edx, word ptr [edi]
		add	edx, 10000h
		sub	edx, eax
		mov	eax, edx
		shr	eax, 10h
		test	eax, eax
		setz	cl
		test	cl, cl
		mov	ebx, ecx
		mov	[edi], dx
		jz	short loc_10016423
		cmp	[ebp+var_10], 1
		jbe	short loc_10016423
		mov	esi, 2

loc_100163F7:				; CODE XREF: s_mw_mp_sub_d+71j
		movzx	eax, word ptr [edi+esi*2-2]
		add	eax, 10000h
		sub	eax, ecx
		xor	ecx, ecx
		mov	edx, eax
		shr	edx, 10h
		test	edx, edx
		setz	cl
		cmp	[ebp+var_10], esi
		mov	ebx, ecx
		mov	[edi+esi*2-2], ax
		setnbe	al
		add	esi, 1
		test	cl, al
		jnz	short loc_100163F7

loc_10016423:				; CODE XREF: s_mw_mp_sub_d+3Aj
					; s_mw_mp_sub_d+40j
		mov	eax, [ebp+arg_0]
		mov	[esp+14h+var_14], eax
		call	s_mw_mp_clamp
		mov	eax, ebx
		add	esp, 8
		shl	eax, 1Fh
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		sar	eax, 1Fh
		and	eax, 0FFFFFFFDh
		retn
s_mw_mp_sub_d	endp

; ---------------------------------------------------------------------------
		jmp	short s_mw_mp_sub
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 471. s_mw_mp_sub

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_sub
s_mw_mp_sub	proc near		; CODE XREF: .text:10016441j
					; mw_mp_sub+EEp ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_10], 0
		mov	edx, [eax+8]
		mov	esi, [eax+0Ch]
		mov	[ebp+var_14], edx
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+var_14]
		mov	ebx, [edx+0Ch]
		xor	edx, edx
		test	eax, eax
		jz	short loc_100164B8
		mov	ecx, ebx
		xor	edi, edi
		nop

loc_10016480:				; CODE XREF: s_mw_mp_sub+5Ej
		movzx	eax, word ptr [esi]
		mov	edx, 10000h
		add	esi, 2
		sub	edx, eax
		movzx	eax, word ptr [ecx]
		sub	eax, [ebp+var_10]
		add	edx, eax
		xor	eax, eax
		mov	[ecx], dx
		shr	edx, 10h
		add	ecx, 2
		test	edx, edx
		setz	al
		add	edi, 1
		cmp	edi, [ebp+var_14]
		mov	[ebp+var_10], eax
		jnz	short loc_10016480
		mov	eax, [ebp+var_14]
		lea	ebx, [ebx+eax*2]
		mov	edx, eax

loc_100164B8:				; CODE XREF: s_mw_mp_sub+29j
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		cmp	ecx, edx
		jbe	short loc_100164E8

loc_100164C2:				; CODE XREF: s_mw_mp_sub+96j
		movzx	eax, word ptr [ebx]
		add	eax, 10000h
		sub	eax, [ebp+var_10]
		mov	[ebx], ax
		shr	eax, 10h
		add	ebx, 2
		test	eax, eax
		setz	al
		add	edx, 1
		movzx	eax, al
		cmp	edx, ecx
		mov	[ebp+var_10], eax
		jnz	short loc_100164C2

loc_100164E8:				; CODE XREF: s_mw_mp_sub+70j
		mov	edx, [ebp+arg_0]
		mov	[esp+18h+var_18], edx
		call	s_mw_mp_clamp
		mov	eax, [ebp+var_10]
		add	esp, 0Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		neg	eax
		and	eax, 0FFFFFFFDh
		retn
s_mw_mp_sub	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 449. s_mw_mp_cmp

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_cmp
s_mw_mp_cmp	proc near		; CODE XREF: mw_mp_cmw_mp_mag+1Bj
					; mw_mp_cmp+23p ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	edx, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		mov	[esp+8+var_8], ebx
		mov	[esp+8+var_4], esi
		mov	eax, [edx+8]
		cmp	eax, [ecx+8]
		jbe	short loc_1001653B

loc_1001652B:				; CODE XREF: s_mw_mp_cmp+49j
					; s_mw_mp_cmp+5Cj
		mov	eax, 1

loc_10016530:				; CODE XREF: s_mw_mp_cmp+70j
					; s_mw_mp_cmp+77j
		mov	ebx, [esp+8+var_8]
		mov	esi, [esp+8+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1001653B:				; CODE XREF: s_mw_mp_cmp+19j
		jb	short loc_10016582
		mov	esi, eax
		mov	ebx, [edx+0Ch]
		sub	esi, 1
		mov	edx, [ecx+0Ch]
		js	short loc_1001657E
		lea	eax, [esi+esi]
		lea	edx, [eax+edx]
		lea	ecx, [ebx+eax]
		movzx	eax, word ptr [edx]
		cmp	[ecx], ax
		ja	short loc_1001652B
		jb	short loc_10016582
		mov	eax, edx
		jmp	short loc_10016579
; ---------------------------------------------------------------------------

loc_10016561:				; CODE XREF: s_mw_mp_cmp+6Cj
		movzx	ebx, word ptr [ecx-2]
		movzx	edx, word ptr [eax-2]
		cmp	bx, dx
		ja	short loc_1001652B
		sub	ecx, 2
		sub	eax, 2
		cmp	bx, dx
		jb	short loc_10016582

loc_10016579:				; CODE XREF: s_mw_mp_cmp+4Fj
		sub	esi, 1
		jns	short loc_10016561

loc_1001657E:				; CODE XREF: s_mw_mp_cmp+38j
		xor	eax, eax
		jmp	short loc_10016530
; ---------------------------------------------------------------------------

loc_10016582:				; CODE XREF: s_mw_mp_cmp:loc_1001653Bj
					; s_mw_mp_cmp+4Bj ...
		mov	eax, 0FFFFFFFFh
		jmp	short loc_10016530
s_mw_mp_cmp	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 450. s_mw_mp_cmw_mp_d

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_cmw_mp_d
s_mw_mp_cmw_mp_d proc near		; CODE XREF: mw_mp_read_radix+FCp
					; mw_mp_cmw_mp_d+20j ...

arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch

		push	ebp
		mov	edx, 1
		mov	ebp, esp
		mov	eax, [ebp+arg_0]
		push	ebx
		movzx	ebx, [ebp+arg_4]
		cmp	dword ptr [eax+8], 1
		mov	ecx, [eax+0Ch]
		jbe	short loc_100165AE

loc_100165A9:				; CODE XREF: s_mw_mp_cmw_mp_d+26j
					; s_mw_mp_cmw_mp_d+2Ej
		pop	ebx
		mov	eax, edx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100165AE:				; CODE XREF: s_mw_mp_cmw_mp_d+17j
		cmp	[ecx], bx
		mov	edx, 0FFFFFFFFh
		jb	short loc_100165A9
		setnbe	al
		movzx	edx, al
		jmp	short loc_100165A9
s_mw_mp_cmw_mp_d endp

; Exported entry 457. s_mw_mp_ispow2

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_ispow2
s_mw_mp_ispow2	proc near		; CODE XREF: s_mw_mp_div+35p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		mov	eax, [ebp+arg_0]
		mov	esi, [eax+8]
		mov	edx, [eax+0Ch]
		movzx	eax, word ptr [edx+esi*2-2]
		test	ax, ax
		jz	short loc_100165EC
		xor	ebx, ebx
		test	al, 1
		jz	short loc_100165E7
		jmp	short loc_100165F5
; ---------------------------------------------------------------------------

loc_100165E0:				; CODE XREF: s_mw_mp_ispow2+2Aj
		add	ebx, 1
		test	al, 1
		jnz	short loc_100165F5

loc_100165E7:				; CODE XREF: s_mw_mp_ispow2+1Cj
		shr	ax, 1
		jnz	short loc_100165E0

loc_100165EC:				; CODE XREF: s_mw_mp_ispow2+16j
					; s_mw_mp_ispow2+39j ...
		pop	ebx
		mov	eax, 0FFFFFFFFh
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100165F5:				; CODE XREF: s_mw_mp_ispow2+1Ej
					; s_mw_mp_ispow2+25j
		sub	ax, 1
		jnz	short loc_100165EC
		mov	ecx, esi
		sub	ecx, 2
		js	short loc_10016623
		lea	eax, [edx+ecx*2]
		cmp	word ptr [eax],	0
		mov	edx, eax
		jnz	short loc_100165EC
		sub	ecx, 1
		js	short loc_10016623

loc_10016612:				; CODE XREF: s_mw_mp_ispow2+61j
		movzx	eax, word ptr [edx-2]
		sub	edx, 2
		test	ax, ax
		jnz	short loc_100165EC
		sub	ecx, 1
		jns	short loc_10016612

loc_10016623:				; CODE XREF: s_mw_mp_ispow2+40j
					; s_mw_mp_ispow2+50j
		shl	esi, 4
		lea	eax, [ebx+esi-10h]
		pop	ebx
		pop	esi
		pop	ebp
		retn
s_mw_mp_ispow2	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 458. s_mw_mp_ispow2d

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_ispow2d
s_mw_mp_ispow2d	proc near		; CODE XREF: mw_mp_div_d+3Dp

arg_0		= word ptr  8

		push	ebp
		xor	edx, edx
		mov	ebp, esp
		movzx	eax, [ebp+arg_0]
		test	al, 1
		jnz	short loc_1001664A
		lea	esi, [esi+0]

loc_10016640:				; CODE XREF: s_mw_mp_ispow2d+18j
		shr	ax, 1
		add	edx, 1
		test	al, 1
		jz	short loc_10016640

loc_1001664A:				; CODE XREF: s_mw_mp_ispow2d+Bj
		sub	ax, 1
		mov	eax, 0FFFFFFFFh
		pop	ebp
		cmovnz	edx, eax
		mov	eax, edx
		retn
s_mw_mp_ispow2d	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 466. s_mw_mp_outlen

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_outlen
s_mw_mp_outlen	proc near		; CODE XREF: mw_mp_value_radix_size+2Cj
					; mw_mp_radix_size+28p

var_18		= qword	ptr -18h
var_10		= qword	ptr -10h
var_8		= dword	ptr -8
var_4		= word ptr -4
var_2		= word ptr -2
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	dword ptr [esp+18h+var_18], 0
		mov	dword ptr [esp+18h+var_18+4], 40000000h
		call	log
		fstp	[ebp+var_10]
		fild	[ebp+arg_4]
		fstp	[esp+18h+var_18]
		call	log
		fild	[ebp+arg_0]
		fxch	st(1)
		fdivr	[ebp+var_10]
		fnstcw	[ebp+var_2]
		movzx	eax, [ebp+var_2]
		mov	ah, 0Ch
		mov	[ebp+var_4], ax
		fst	[ebp+var_10]
		fmulp	st(1), st
		fadd	ds:flt_10020E54
		fldcw	[ebp+var_4]
		fistp	[ebp+var_8]
		fldcw	[ebp+var_2]
		mov	eax, [ebp+var_8]
		leave
		retn
s_mw_mp_outlen	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 473. s_mw_mp_todigit

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_todigit
s_mw_mp_todigit	proc near		; CODE XREF: mw_mp_toradix+B8p

C		= dword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	edx, [ebp+arg_0]
		mov	ecx, [ebp+arg_4]
		test	edx, edx
		js	short locret_100166E7
		cmp	edx, ecx
		jge	short locret_100166E7
		mov	eax, ds:off_10020DC8
		cmp	ecx, 24h
		movzx	eax, byte ptr [eax+edx]
		jle	short loc_100166F0

loc_100166E2:				; CODE XREF: s_mw_mp_todigit+35j
		movsx	eax, al

locret_100166E5:			; CODE XREF: s_mw_mp_todigit+45j
		leave
		retn
; ---------------------------------------------------------------------------

locret_100166E7:			; CODE XREF: s_mw_mp_todigit+Ej
					; s_mw_mp_todigit+12j
		leave
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_100166F0:				; CODE XREF: s_mw_mp_todigit+20j
		mov	edx, [ebp+arg_8]
		test	edx, edx
		jz	short loc_100166E2
		movsx	eax, al
		mov	[esp+8+C], eax	; C
		call	tolower
		movsx	eax, al
		jmp	short locret_100166E5
s_mw_mp_todigit	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 474. s_mw_mp_tovalue

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_tovalue
s_mw_mp_tovalue	proc near		; CODE XREF: mw_mp_char2value+Bj
					; mw_mp_read_radix+82p	...

C		= dword	ptr -18h
Type		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= byte ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_4]
		movzx	eax, [ebp+arg_0]
		mov	[ebp+var_C], ebx
		mov	[ebp+var_8], esi
		cmp	edi, 24h
		movsx	ebx, al
		jle	short loc_100167A5

loc_1001672E:				; CODE XREF: s_mw_mp_tovalue+A0j
		lea	eax, [ebx-30h]
		cmp	eax, 9
		jbe	short loc_10016758
		mov	esi, ds:__mb_cur_max
		cmp	dword ptr [esi], 1
		jz	short loc_10016777
		mov	[esp+18h+Type],	1 ; Type
		mov	[esp+18h+C], ebx ; C
		call	_isctype
		test	eax, eax
		jz	short loc_10016789

loc_10016755:				; CODE XREF: s_mw_mp_tovalue+77j
		lea	eax, [ebx-37h]

loc_10016758:				; CODE XREF: s_mw_mp_tovalue+24j
					; s_mw_mp_tovalue+93j
		mov	edx, eax
		shr	edx, 1Fh

loc_1001675D:				; CODE XREF: s_mw_mp_tovalue+C3j
					; s_mw_mp_tovalue+CCj
		cmp	eax, edi
		jge	short loc_10016765
		test	dl, dl
		jz	short loc_1001676A

loc_10016765:				; CODE XREF: s_mw_mp_tovalue+4Fj
					; s_mw_mp_tovalue+C8j
		mov	eax, 0FFFFFFFFh

loc_1001676A:				; CODE XREF: s_mw_mp_tovalue+53j
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10016777:				; CODE XREF: s_mw_mp_tovalue+2Fj
		mov	eax, ds:_pctype
		mov	eax, [eax]
		movzx	eax, word ptr [eax+ebx*2]
		and	eax, 1
		test	eax, eax
		jnz	short loc_10016755

loc_10016789:				; CODE XREF: s_mw_mp_tovalue+43j
		cmp	dword ptr [esi], 1
		jnz	short loc_100167B5
		mov	eax, ds:_pctype
		mov	eax, [eax]
		movzx	eax, word ptr [eax+ebx*2]
		and	eax, 2
		test	eax, eax
		jz	short loc_100167C9

loc_100167A0:				; CODE XREF: s_mw_mp_tovalue+B7j
		lea	eax, [ebx-3Dh]
		jmp	short loc_10016758
; ---------------------------------------------------------------------------

loc_100167A5:				; CODE XREF: s_mw_mp_tovalue+1Cj
		mov	[esp+18h+C], ebx ; C
		call	toupper
		mov	ebx, eax
		nop
		jmp	loc_1001672E
; ---------------------------------------------------------------------------

loc_100167B5:				; CODE XREF: s_mw_mp_tovalue+7Cj
		mov	[esp+18h+Type],	2 ; Type
		mov	[esp+18h+C], ebx ; C
		call	_isctype
		test	eax, eax
		jnz	short loc_100167A0

loc_100167C9:				; CODE XREF: s_mw_mp_tovalue+8Ej
		xor	edx, edx
		cmp	ebx, 2Bh
		mov	eax, 3Eh
		jz	short loc_1001675D
		cmp	ebx, 2Fh
		jnz	short loc_10016765
		mov	al, 3Fh
		jmp	loc_1001675D
s_mw_mp_tovalue	endp

; ---------------------------------------------------------------------------
		jmp	short mw_mp_char2value
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 386. mw_mp_char2value

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_char2value
mw_mp_char2value proc near		; CODE XREF: .text:100167E1j

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		movsx	eax, byte ptr [ebp+arg_0]
		mov	[ebp+arg_0], eax
		pop	ebp
		jmp	s_mw_mp_tovalue
mw_mp_char2value endp

; Exported entry 469. s_mw_mp_rshd

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_rshd
s_mw_mp_rshd	proc near		; CODE XREF: s_mw_mp_div_2d+31p
					; s_mw_mp_reduce+52p ...

Dst		= dword	ptr -28h
Val		= dword	ptr -24h
Size		= dword	ptr -20h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	eax, [ebp+arg_4]
		mov	esi, [ebp+arg_0]
		test	eax, eax
		mov	[ebp+var_10], eax
		jz	short loc_10016895
		cmp	eax, [esi+8]
		jnb	short loc_1001686F
		mov	edx, [ebp+var_10]
		mov	ecx, [esi+0Ch]
		mov	edi, [esi+8]
		mov	eax, edx
		add	eax, eax
		mov	ebx, ecx
		sub	ebx, eax
		lea	esi, [esi+0]

loc_10016830:				; CODE XREF: s_mw_mp_rshd+3Dj
		movzx	eax, word ptr [ecx+edx*2]
		mov	[ebx+edx*2], ax
		add	edx, 1
		cmp	edi, edx
		ja	short loc_10016830
		mov	eax, edx
		sub	eax, [ebp+var_10]
		cmp	eax, edi
		jnb	short loc_10016860
		lea	edx, [ecx+eax*2]
		nop
		lea	esi, [esi+0]

loc_10016850:				; CODE XREF: s_mw_mp_rshd+5Ej
		mov	word ptr [edx],	0
		add	eax, 1
		add	edx, 2
		cmp	[esi+8], eax
		ja	short loc_10016850

loc_10016860:				; CODE XREF: s_mw_mp_rshd+46j
		mov	[ebp+arg_0], esi
		add	esp, 1Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		jmp	s_mw_mp_clamp
; ---------------------------------------------------------------------------

loc_1001686F:				; CODE XREF: s_mw_mp_rshd+19j
		mov	eax, [esi+4]
		mov	edx, [esi+0Ch]
		mov	[esp+28h+Val], 0 ; Val
		add	eax, eax
		mov	[esp+28h+Size],	eax ; Size
		mov	[esp+28h+Dst], edx ; Dst
		call	memset
		mov	dword ptr [esi+8], 1
		mov	byte ptr [esi],	0

loc_10016895:				; CODE XREF: s_mw_mp_rshd+14j
		add	esp, 1Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
s_mw_mp_rshd	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 453. s_mw_mp_div_2d

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_div_2d
s_mw_mp_div_2d	proc near		; CODE XREF: s_mw_mp_div_2+14p
					; mw_mp_div_2d+51p ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_1E		= word ptr -1Eh
var_1C		= dword	ptr -1Ch
var_16		= word ptr -16h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	eax, [ebp+arg_0]
		movzx	ebx, [ebp+arg_4]
		mov	edx, [eax+0Ch]
		mov	[ebp+var_1C], eax
		mov	eax, ebx
		mov	edi, ebx
		shr	ax, 4
		and	edi, 0Fh
		movzx	eax, ax
		mov	[ebp+var_14], edx
		mov	[esp+28h+var_24], eax
		mov	ecx, [ebp+var_1C]
		mov	[esp+28h+var_28], ecx
		call	s_mw_mp_rshd
		mov	edx, [ebp+var_1C]
		mov	eax, 1
		mov	ecx, edi
		shl	eax, cl
		sub	eax, 1
		mov	[ebp+var_16], ax
		mov	eax, [edx+8]
		mov	esi, eax
		sub	esi, 1
		js	short loc_10016934
		mov	ecx, [ebp+var_14]
		mov	[ebp+var_10], 10h
		sub	[ebp+var_10], edi
		lea	ebx, [ecx+eax*2]
		xor	eax, eax

loc_10016905:				; CODE XREF: s_mw_mp_div_2d+92j
		movzx	edx, word ptr [ebx-2]
		movzx	ecx, byte ptr [ebp+var_10]
		mov	[ebp+var_1E], dx
		movzx	edx, ax
		movzx	eax, [ebp+var_1E]
		shl	edx, cl
		mov	ecx, edi
		sar	eax, cl
		or	edx, eax
		movzx	eax, [ebp+var_16]
		mov	[ebx-2], dx
		sub	ebx, 2
		and	ax, [ebp+var_1E]
		sub	esi, 1
		jns	short loc_10016905

loc_10016934:				; CODE XREF: s_mw_mp_div_2d+51j
		mov	eax, [ebp+var_1C]
		mov	[ebp+arg_0], eax
		add	esp, 1Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		jmp	s_mw_mp_clamp
s_mw_mp_div_2d	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 452. s_mw_mp_div_2

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_div_2
s_mw_mp_div_2	proc near		; CODE XREF: mw_mp_div_2+2Fp
					; mw_mp_sqrt+12Ap ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+arg_0]
		mov	[esp+8+var_4], 1
		mov	[esp+8+var_8], eax
		call	s_mw_mp_div_2d
		leave
		retn
s_mw_mp_div_2	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 444. mw_mp_zero

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_zero
mw_mp_zero	proc near		; CODE XREF: mw_mp_set+19p
					; s_mw_mp_2expt+24p ...

Dst		= dword	ptr -18h
Val		= dword	ptr -14h
Size		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_100169A4
		mov	eax, [ebx+4]
		mov	edx, [ebx+0Ch]
		mov	[esp+18h+Val], 0 ; Val
		add	eax, eax
		mov	[esp+18h+Size],	eax ; Size
		mov	[esp+18h+Dst], edx ; Dst
		call	memset
		mov	dword ptr [ebx+8], 1
		mov	byte ptr [ebx],	0

loc_100169A4:				; CODE XREF: mw_mp_zero+Cj
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
mw_mp_zero	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 427. mw_mp_set

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_set
mw_mp_set	proc near		; CODE XREF: mw_mp_div+77p
					; s_mw_mp_reduce+10Fp ...

var_18		= dword	ptr -18h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_100169D4
		mov	[esp+18h+var_18], ebx
		call	mw_mp_zero
		mov	eax, [ebx+0Ch]
		mov	[eax], si

loc_100169D4:				; CODE XREF: mw_mp_set+14j
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
mw_mp_set	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 456. s_mw_mp_grow

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_grow
s_mw_mp_grow	proc near		; CODE XREF: s_mw_mp_mul_2+73p
					; s_mw_mp_pad+37p ...

NumOfElements	= dword	ptr -18h
SizeOfElements	= dword	ptr -14h
Size		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		xor	eax, eax
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_C], ebx
		mov	ebx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		mov	[ebp+var_8], esi
		mov	[ebp+var_4], edi
		cmp	[ebx+4], edx
		jb	short loc_10016A09

loc_100169FC:				; CODE XREF: s_mw_mp_grow+57j
					; s_mw_mp_grow+88j
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10016A09:				; CODE XREF: s_mw_mp_grow+1Aj
		mov	ecx, dword_1001B060
		mov	[esp+18h+SizeOfElements], 2 ; SizeOfElements
		lea	edx, [ecx+edx-1]
		mov	eax, edx
		xor	edx, edx
		div	ecx
		mov	edi, eax
		imul	edi, ecx
		mov	[esp+18h+NumOfElements], edi ; NumOfElements
		call	calloc
		mov	esi, eax
		mov	eax, 0FFFFFFFEh
		test	esi, esi
		jz	short loc_100169FC
		mov	eax, [ebx+8]
		mov	edx, [ebx+0Ch]
		mov	[esp+18h+NumOfElements], esi ; Dst
		add	eax, eax
		mov	[esp+18h+Size],	eax ; Size
		mov	[esp+18h+SizeOfElements], edx ;	Src
		call	memcpy
		mov	eax, [ebx+0Ch]
		test	eax, eax
		jz	short loc_10016A60
		mov	[esp+18h+NumOfElements], eax ; Memory
		call	free

loc_10016A60:				; CODE XREF: s_mw_mp_grow+76j
		xor	eax, eax
		mov	[ebx+0Ch], esi
		mov	[ebx+4], edi
		jmp	short loc_100169FC
s_mw_mp_grow	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 462. s_mw_mp_mul_2

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_mul_2
s_mw_mp_mul_2	proc near		; CODE XREF: mw_mp_mul_2+38j
					; mw_mp_sqrt+F8p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		mov	eax, [ebp+arg_0]
		mov	edx, [eax+8]
		mov	edi, [eax+0Ch]
		test	edx, edx
		mov	[ebp+var_10], edx
		jz	short loc_10016AF4
		xor	ecx, ecx
		xor	esi, esi
		xor	eax, eax
		nop

loc_10016A90:				; CODE XREF: s_mw_mp_mul_2+3Dj
		lea	edx, [edi+eax*2]
		add	ecx, 1
		movzx	eax, word ptr [edx]
		mov	ebx, eax
		add	eax, eax
		or	eax, esi
		shr	bx, 0Fh
		cmp	ecx, [ebp+var_10]
		mov	esi, ebx
		mov	[edx], ax
		mov	eax, ecx
		jnz	short loc_10016A90
		test	bx, bx
		jz	short loc_10016AF4
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+4]
		cmp	[ebp+var_10], eax
		jnb	short loc_10016AD9

loc_10016ABF:				; CODE XREF: s_mw_mp_mul_2+82j
		mov	eax, [ebp+arg_0]
		mov	edx, [ebp+var_10]
		add	dword ptr [eax+8], 1
		xor	eax, eax
		mov	word ptr [edi+edx*2], 1

loc_10016AD1:				; CODE XREF: s_mw_mp_mul_2+7Aj
		add	esp, 0Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10016AD9:				; CODE XREF: s_mw_mp_mul_2+4Dj
		add	eax, 1
		mov	[esp+18h+var_14], eax
		mov	[esp+18h+var_18], edx
		call	s_mw_mp_grow
		test	eax, eax
		jnz	short loc_10016AD1
		mov	eax, [ebp+arg_0]
		mov	edi, [eax+0Ch]
		jmp	short loc_10016ABF
; ---------------------------------------------------------------------------

loc_10016AF4:				; CODE XREF: s_mw_mp_mul_2+17j
					; s_mw_mp_mul_2+42j
		add	esp, 0Ch
		xor	eax, eax
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
s_mw_mp_mul_2	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 467. s_mw_mp_pad

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_pad
s_mw_mp_pad	proc near		; CODE XREF: s_mw_mp_2expt+33p
					; s_mw_mp_add+B5p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		xor	eax, eax
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_4]
		cmp	[esi+8], ebx
		jnb	short loc_10016B23
		cmp	ebx, [esi+4]
		ja	short loc_10016B30

loc_10016B1E:				; CODE XREF: s_mw_mp_pad+3Ej
		mov	[esi+8], ebx
		xor	eax, eax

loc_10016B23:				; CODE XREF: s_mw_mp_pad+17j
					; s_mw_mp_pad+40j
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10016B30:				; CODE XREF: s_mw_mp_pad+1Cj
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+var_18], esi
		call	s_mw_mp_grow
		test	eax, eax
		jz	short loc_10016B1E
		jmp	short loc_10016B23
s_mw_mp_pad	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 445. s_mw_mp_2expt

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_2expt
s_mw_mp_2expt	proc near		; CODE XREF: mw_mp_2expt+1Bj
					; mw_mp_gcd+1CFp

var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_28		= word ptr -28h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		movzx	eax, [ebp+arg_4]
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	[ebp+var_C], ebx
		mov	[ebp+var_28], ax
		shr	ax, 4
		movzx	edi, ax
		mov	[esp+38h+var_38], esi
		call	mw_mp_zero
		lea	eax, [edi+1]
		mov	[esp+38h+var_34], eax
		mov	[esp+38h+var_38], esi
		call	s_mw_mp_pad
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_10016BA5
		movzx	ecx, [ebp+var_28]
		lea	eax, [edi+edi]
		mov	edx, 1
		add	eax, [esi+0Ch]
		and	ecx, 0Fh
		shl	edx, cl
		or	[eax], dx

loc_10016BA5:				; CODE XREF: s_mw_mp_2expt+3Cj
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
s_mw_mp_2expt	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 446. s_mw_mp_add

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_add
s_mw_mp_add	proc near		; CODE XREF: mw_mp_sub+5Bp
					; mw_mp_sub+109p ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	ebx, [ebp+arg_4]
		mov	edx, [ebp+arg_0]
		mov	eax, [ebx+8]
		cmp	eax, [edx+8]
		mov	[ebp+var_10], eax
		ja	loc_10016C94

loc_10016BDE:				; CODE XREF: s_mw_mp_add+E4j
		mov	ecx, [ebp+arg_0]
		mov	esi, [ebp+var_10]
		mov	ebx, [ebx+0Ch]
		mov	ecx, [ecx+0Ch]
		test	esi, esi
		mov	[ebp+var_14], ecx
		jz	short loc_10016C53
		xor	edi, edi
		xor	esi, esi

loc_10016BF5:				; CODE XREF: s_mw_mp_add+54j
		movzx	eax, word ptr [ebx]
		add	esi, 1
		add	ebx, 2
		movzx	edx, word ptr [ecx]
		add	eax, edx
		lea	eax, [edi+eax]
		mov	edi, eax
		mov	[ecx], ax
		shr	edi, 10h
		add	ecx, 2
		cmp	esi, [ebp+var_10]
		jnz	short loc_10016BF5
		mov	eax, [ebp+var_10]
		test	edi, edi
		mov	ecx, [ebp+var_14]
		lea	edx, [ecx+eax*2]
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+8]
		setnz	al
		jz	short loc_10016C33
		mov	ebx, [ebp+var_10]
		cmp	ebx, ecx
		jb	short loc_10016C38

loc_10016C33:				; CODE XREF: s_mw_mp_add+6Aj
		mov	ebx, [ebp+var_10]
		jmp	short loc_10016C64
; ---------------------------------------------------------------------------

loc_10016C38:				; CODE XREF: s_mw_mp_add+71j
					; s_mw_mp_add+A2j
		movzx	eax, word ptr [edx]
		add	ebx, 1
		lea	eax, [edi+eax]
		mov	edi, eax
		shr	edi, 10h
		mov	[edx], ax
		add	edx, 2
		test	edi, edi
		setnz	al
		jnz	short loc_10016C60

loc_10016C53:				; CODE XREF: s_mw_mp_add+2Fj
					; s_mw_mp_add+A6j
		xor	edx, edx

loc_10016C55:				; CODE XREF: s_mw_mp_add+BEj
					; s_mw_mp_add+EAj
		add	esp, 1Ch
		mov	eax, edx
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10016C60:				; CODE XREF: s_mw_mp_add+91j
		cmp	ecx, ebx
		ja	short loc_10016C38

loc_10016C64:				; CODE XREF: s_mw_mp_add+76j
		test	al, al
		jz	short loc_10016C53
		lea	eax, [ecx+1]
		mov	[esp+28h+var_24], eax
		mov	edx, [ebp+arg_0]
		mov	[esp+28h+var_28], edx
		call	s_mw_mp_pad
		test	eax, eax
		mov	edx, eax
		jnz	short loc_10016C55
		mov	ecx, [ebp+arg_0]
		mov	eax, [ecx+0Ch]
		mov	[eax+ebx*2], di
		add	esp, 1Ch
		mov	eax, edx
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10016C94:				; CODE XREF: s_mw_mp_add+18j
		mov	[esp+28h+var_28], edx
		mov	[esp+28h+var_24], eax
		call	s_mw_mp_pad
		test	eax, eax
		mov	edx, eax
		jz	loc_10016BDE
		jmp	short loc_10016C55
s_mw_mp_add	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 464. s_mw_mp_mul_d

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_mul_d
s_mw_mp_mul_d	proc near		; CODE XREF: mw_mp_read_radix+BAp
					; mw_mp_mul_d+66j ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		mov	eax, [ebp+arg_0]
		movzx	edi, [ebp+arg_4]
		mov	esi, [eax+8]
		mov	ebx, [eax+0Ch]
		lea	edx, [esi+esi]
		movzx	eax, word ptr [ebx+edx-2]
		mov	[ebp+var_10], edx
		imul	eax, edi
		shr	eax, 10h
		test	eax, eax
		jnz	short loc_10016D26

loc_10016CDB:				; CODE XREF: s_mw_mp_mul_d+92j
		test	esi, esi
		jz	short loc_10016D11
		xor	ecx, ecx
		xor	edx, edx

loc_10016CE3:				; CODE XREF: s_mw_mp_mul_d+4Bj
		movzx	eax, word ptr [ebx+edx*2]
		imul	eax, edi
		lea	eax, [ecx+eax]
		mov	[ebx+edx*2], ax
		mov	ecx, eax
		add	edx, 1
		shr	ecx, 10h
		cmp	edx, esi
		jnz	short loc_10016CE3
		test	ecx, ecx
		jz	short loc_10016D11
		mov	eax, [ebp+var_10]
		mov	edx, [ebp+arg_0]
		mov	[ebx+eax], cx
		lea	eax, [esi+1]
		mov	[edx+8], eax

loc_10016D11:				; CODE XREF: s_mw_mp_mul_d+2Dj
					; s_mw_mp_mul_d+4Fj
		mov	eax, [ebp+arg_0]
		mov	[esp+18h+var_18], eax
		call	s_mw_mp_clamp
		xor	eax, eax

loc_10016D1E:				; CODE XREF: s_mw_mp_mul_d+8Aj
		add	esp, 0Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10016D26:				; CODE XREF: s_mw_mp_mul_d+29j
		lea	eax, [esi+1]
		mov	[esp+18h+var_14], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+18h+var_18], eax
		call	s_mw_mp_pad
		test	eax, eax
		jnz	short loc_10016D1E
		mov	edx, [ebp+arg_0]
		mov	ebx, [edx+0Ch]
		jmp	short loc_10016CDB
s_mw_mp_mul_d	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 447. s_mw_mp_add_d

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_add_d
s_mw_mp_add_d	proc near		; CODE XREF: mw_mp_read_radix+D0p
					; mw_mp_set_int+64p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		mov	eax, [ebp+arg_0]
		mov	ecx, [eax+0Ch]
		mov	edi, [eax+8]
		movzx	eax, [ebp+arg_4]
		movzx	edx, word ptr [ecx]
		add	eax, edx
		mov	ebx, eax
		shr	ebx, 10h
		cmp	edi, 1
		mov	[ecx], ax
		mov	eax, ebx
		ja	short loc_10016D81

loc_10016D7A:				; CODE XREF: s_mw_mp_add_d+38j
		mov	esi, 1
		jmp	short loc_10016DA9
; ---------------------------------------------------------------------------

loc_10016D81:				; CODE XREF: s_mw_mp_add_d+28j
		test	bl, bl
		mov	esi, 1
		jz	short loc_10016D7A
		lea	esi, [esi+0]

loc_10016D90:				; CODE XREF: s_mw_mp_add_d+92j
		movzx	eax, word ptr [ecx+esi*2]
		lea	eax, [ebx+eax]
		mov	[ecx+esi*2], ax
		mov	ebx, eax
		add	esi, 1
		shr	ebx, 10h
		cmp	edi, esi
		mov	eax, ebx
		ja	short loc_10016DE0

loc_10016DA9:				; CODE XREF: s_mw_mp_add_d+2Fj
		test	al, al
		jz	short loc_10016DE4
		mov	edx, [ebp+arg_0]
		mov	eax, [edx+8]
		mov	[esp+18h+var_18], edx
		add	eax, 1
		mov	[esp+18h+var_14], eax
		call	s_mw_mp_pad
		test	eax, eax
		mov	edx, eax
		jnz	short loc_10016DE6
		mov	ecx, [ebp+arg_0]
		mov	eax, [ecx+0Ch]
		mov	[eax+esi*2], bx
		add	esp, 0Ch
		mov	eax, edx
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10016DE0:				; CODE XREF: s_mw_mp_add_d+57j
		test	bl, bl
		jnz	short loc_10016D90

loc_10016DE4:				; CODE XREF: s_mw_mp_add_d+5Bj
		xor	edx, edx

loc_10016DE6:				; CODE XREF: s_mw_mp_add_d+76j
		add	esp, 0Ch
		mov	eax, edx
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
s_mw_mp_add_d	endp

; Exported entry 459. s_mw_mp_lshd

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_lshd
s_mw_mp_lshd	proc near		; CODE XREF: s_mw_mp_mul_2d+20p
					; s_mw_mp_div+125p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		mov	edi, [ebp+arg_4]
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_10], 0
		test	edi, edi
		jnz	short loc_10016E15

loc_10016E0A:				; CODE XREF: s_mw_mp_lshd+3Bj
		mov	eax, [ebp+var_10]
		add	esp, 0Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10016E15:				; CODE XREF: s_mw_mp_lshd+18j
		mov	eax, edi
		add	eax, [ebx+8]
		mov	[esp+18h+var_18], ebx
		mov	[esp+18h+var_14], eax
		call	s_mw_mp_pad
		test	eax, eax
		mov	[ebp+var_10], eax
		jnz	short loc_10016E0A
		mov	eax, [ebx+8]
		mov	esi, [ebx+0Ch]
		sub	eax, 1
		mov	ebx, eax
		sub	ebx, edi
		js	short loc_10016E59
		lea	eax, [ebx+edi]
		lea	ecx, [esi+ebx*2]
		lea	edx, [esi+eax*2]

loc_10016E45:				; CODE XREF: s_mw_mp_lshd+67j
		movzx	eax, word ptr [ecx]
		sub	ebx, 1
		sub	ecx, 2
		mov	[edx], ax
		sub	edx, 2
		cmp	ebx, 0FFFFFFFFh
		jnz	short loc_10016E45

loc_10016E59:				; CODE XREF: s_mw_mp_lshd+4Aj
		xor	eax, eax
		xor	edx, edx
		lea	esi, [esi+0]

loc_10016E60:				; CODE XREF: s_mw_mp_lshd+7Dj
		add	eax, 1
		cmp	eax, edi
		mov	word ptr [esi+edx*2], 0
		mov	edx, eax
		jnz	short loc_10016E60
		mov	eax, [ebp+var_10]
		add	esp, 0Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
s_mw_mp_lshd	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 463. s_mw_mp_mul_2d

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_mul_2d
s_mw_mp_mul_2d	proc near		; CODE XREF: s_mw_mp_norm+3Ap
					; s_mw_mp_norm+46p ...

var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_26		= word ptr -26h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_12		= word ptr -12h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 2Ch
		movzx	ebx, [ebp+arg_4]
		mov	eax, ebx
		shr	ax, 4
		movzx	eax, ax
		mov	[esp+38h+var_34], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+38h+var_38], eax
		call	s_mw_mp_lshd
		test	eax, eax
		mov	[ebp+var_18], eax
		jnz	loc_10016F64
		mov	ecx, [ebp+arg_0]
		mov	edi, ebx
		mov	al, 1
		mov	edx, [ebp+arg_0]
		and	edi, 0Fh
		mov	[ebp+var_1C], 10h
		mov	[ebp+var_24], edi
		mov	ecx, [ecx+8]
		mov	edx, [edx+0Ch]
		sub	[ebp+var_1C], edi
		mov	[ebp+var_10], ecx
		mov	ebx, [ebp+var_10]
		mov	ecx, edi
		mov	[ebp+var_30], edx
		mov	edi, [ebp+var_30]
		shl	eax, cl
		sub	eax, 1
		movzx	ecx, byte ptr [ebp+var_1C]
		movzx	edx, ax
		add	ebx, ebx
		mov	[ebp+var_12], ax
		movzx	eax, word ptr [edi+ebx-2]
		mov	[ebp+var_20], ebx
		sar	eax, cl
		test	edx, eax
		jnz	short loc_10016F6F

loc_10016EFE:				; CODE XREF: s_mw_mp_mul_2d+111j
		mov	edi, [ebp+var_10]
		test	edi, edi
		jz	short loc_10016F59
		xor	ebx, ebx
		xor	esi, esi
		xor	eax, eax
		nop
		lea	esi, [esi+0]

loc_10016F10:				; CODE XREF: s_mw_mp_mul_2d+C1j
		mov	edx, [ebp+var_30]
		add	esi, 1
		movzx	ecx, byte ptr [ebp+var_1C]
		lea	eax, [edx+eax*2]
		movzx	edx, word ptr [eax]
		mov	edi, edx
		sar	edi, cl
		movzx	ecx, byte ptr [ebp+var_24]
		mov	[ebp+var_2C], edi
		and	di, [ebp+var_12]
		shl	edx, cl
		or	ebx, edx
		cmp	esi, [ebp+var_10]
		mov	[eax], bx
		mov	eax, esi
		mov	ebx, edi
		mov	[ebp+var_26], di
		jnz	short loc_10016F10
		test	di, di
		jz	short loc_10016F59
		mov	edx, [ebp+arg_0]
		mov	ebx, [ebp+var_30]
		mov	eax, [ebp+var_20]
		add	dword ptr [edx+8], 1
		mov	[ebx+eax], di

loc_10016F59:				; CODE XREF: s_mw_mp_mul_2d+83j
					; s_mw_mp_mul_2d+C6j
		mov	ecx, [ebp+arg_0]
		mov	[esp+38h+var_38], ecx
		call	s_mw_mp_clamp

loc_10016F64:				; CODE XREF: s_mw_mp_mul_2d+2Aj
					; s_mw_mp_mul_2d+119j
		mov	eax, [ebp+var_18]
		add	esp, 2Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10016F6F:				; CODE XREF: s_mw_mp_mul_2d+7Cj
		mov	eax, [ebp+var_10]
		mov	ebx, [ebp+arg_0]
		add	eax, 1
		mov	[esp+38h+var_34], eax
		mov	[esp+38h+var_38], ebx
		call	s_mw_mp_grow
		test	eax, eax
		jnz	short loc_10016F96
		mov	edi, [ebp+arg_0]
		mov	edi, [edi+0Ch]
		mov	[ebp+var_30], edi
		jmp	loc_10016EFE
; ---------------------------------------------------------------------------

loc_10016F96:				; CODE XREF: s_mw_mp_mul_2d+106j
		mov	[ebp+var_18], eax
		jmp	short loc_10016F64
s_mw_mp_mul_2d	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 465. s_mw_mp_norm

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_norm
s_mw_mp_norm	proc near		; CODE XREF: s_mw_mp_div+E9p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	esi, [ebp+arg_4]
		mov	edx, [esi+8]
		mov	eax, [esi+0Ch]
		movzx	edx, word ptr [eax+edx*2-2]
		test	dx, dx
		js	short loc_10016FF4
		xor	eax, eax
		lea	esi, [esi+0]

loc_10016FC0:				; CODE XREF: s_mw_mp_norm+26j
		add	eax, 1
		add	dx, dx
		jns	short loc_10016FC0
		test	ax, ax
		jz	short loc_10016FF4
		movzx	ebx, ax
		mov	[esp+18h+var_14], ebx
		mov	eax, [ebp+arg_0]
		mov	[esp+18h+var_18], eax
		call	s_mw_mp_mul_2d
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+var_18], esi
		call	s_mw_mp_mul_2d
		add	esp, 10h
		mov	eax, ebx
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10016FF4:				; CODE XREF: s_mw_mp_norm+19j
					; s_mw_mp_norm+2Bj
		xor	ebx, ebx
		add	esp, 10h
		mov	eax, ebx
		pop	ebx
		pop	esi
		pop	ebp
		retn
s_mw_mp_norm	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 387. mw_mp_clear

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_clear
mw_mp_clear	proc near		; CODE XREF: mwMpi_free+11p
					; sub_10003890+3Ap ...

Memory		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_10017032
		mov	eax, [ebx+0Ch]
		test	eax, eax
		jz	short loc_10017024
		mov	[esp+8+Memory],	eax ; Memory
		call	free
		mov	dword ptr [ebx+0Ch], 0

loc_10017024:				; CODE XREF: mw_mp_clear+13j
		mov	dword ptr [ebx+8], 0
		mov	dword ptr [ebx+4], 0

loc_10017032:				; CODE XREF: mw_mp_clear+Cj
		add	esp, 4
		pop	ebx
		pop	ebp
		retn
mw_mp_clear	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 442. mw_mp_value_radix_size

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_value_radix_size
mw_mp_value_radix_size proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		mov	eax, [ebp+arg_8]
		test	ecx, ecx
		js	short loc_10017071
		test	edx, edx
		jle	short loc_10017071
		cmp	eax, 1
		jle	short loc_10017071
		cmp	eax, 40h
		nop
		jg	short loc_10017071
		imul	edx, ecx
		mov	[ebp+arg_4], eax
		mov	[ebp+arg_0], edx
		leave
		jmp	s_mw_mp_outlen
; ---------------------------------------------------------------------------

loc_10017071:				; CODE XREF: mw_mp_value_radix_size+11j
					; mw_mp_value_radix_size+15j ...
		mov	[esp+18h+var_10], 9F0h
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aNum0Qty0Radix2 ; "num	>= 0 &&	qty > 0	&& radix >= 2 && ra"...
		call	_assert
mw_mp_value_radix_size endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 424. mw_mp_read_radix

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_read_radix
mw_mp_read_radix proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_14		= dword	ptr -14h
var_D		= byte ptr -0Dh
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	edi, [ebp+arg_0]
		test	edi, edi
		jz	loc_100171A0
		mov	eax, [ebp+arg_4]
		test	eax, eax
		jz	loc_100171A0
		cmp	[ebp+arg_8], 1
		jle	loc_100171A0
		cmp	[ebp+arg_8], 40h
		lea	esi, [esi+0]
		jg	loc_100171A0
		mov	[esp+28h+var_28], edi
		xor	esi, esi
		call	mw_mp_zero
		mov	edx, [ebp+arg_4]
		movzx	eax, byte ptr [edx]
		mov	ebx, edx
		test	al, al
		jnz	short loc_10017105
		jmp	loc_100171DA
; ---------------------------------------------------------------------------

loc_100170E1:				; CODE XREF: mw_mp_read_radix+89j
		movzx	eax, byte ptr [ebx]
		cmp	al, 2Dh
		jz	loc_100171BC
		cmp	al, 2Bh
		xchg	ax, ax
		jz	loc_100171C8
		mov	ebx, [ebp+arg_4]
		add	esi, 1
		add	ebx, esi
		movzx	eax, byte ptr [ebx]
		test	al, al
		jz	short loc_10017126

loc_10017105:				; CODE XREF: mw_mp_read_radix+4Aj
		mov	edx, [ebp+arg_8]
		movsx	eax, al
		mov	[esp+28h+var_28], eax
		mov	[esp+28h+var_24], edx
		call	s_mw_mp_tovalue
		test	eax, eax
		js	short loc_100170E1
		movzx	eax, byte ptr [ebx]
		cmp	al, 2Dh
		jz	loc_100171BC

loc_10017126:				; CODE XREF: mw_mp_read_radix+73j
		cmp	al, 2Bh
		jz	loc_100171C8

loc_1001712E:				; CODE XREF: mw_mp_read_radix+13Bj
					; mw_mp_read_radix+14Cj
		mov	[ebp+var_D], 0

loc_10017132:				; CODE XREF: mw_mp_read_radix+133j
		movzx	eax, word ptr [ebp+arg_8]
		add	esi, [ebp+arg_4]
		mov	[ebp+var_14], eax
		jmp	short loc_10017169
; ---------------------------------------------------------------------------
		align 10h

loc_10017140:				; CODE XREF: mw_mp_read_radix+EFj
		mov	edx, [ebp+var_14]
		mov	[esp+28h+var_28], edi
		mov	[esp+28h+var_24], edx
		call	s_mw_mp_mul_d
		test	eax, eax
		jnz	short loc_10017198
		movzx	eax, bx
		add	esi, 1
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_28], edi
		call	s_mw_mp_add_d
		test	eax, eax
		jnz	short loc_10017198

loc_10017169:				; CODE XREF: mw_mp_read_radix+ACj
		mov	eax, [ebp+arg_8]
		mov	[esp+28h+var_24], eax
		movsx	eax, byte ptr [esi]
		mov	[esp+28h+var_28], eax
		call	s_mw_mp_tovalue
		test	eax, eax
		mov	ebx, eax
		jns	short loc_10017140
		mov	[esp+28h+var_24], 0
		mov	[esp+28h+var_28], edi
		call	s_mw_mp_cmw_mp_d
		test	eax, eax
		jnz	short loc_100171D0
		mov	byte ptr [edi],	0

loc_10017198:				; CODE XREF: mw_mp_read_radix+C1j
					; mw_mp_read_radix+D7j	...
		add	esp, 1Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100171A0:				; CODE XREF: mw_mp_read_radix+Ej
					; mw_mp_read_radix+19j	...
		mov	[esp+28h+var_20], 9ACh
		mov	[esp+28h+var_24], offset aMpi_c	; "mpi.c"
		mov	[esp+28h+var_28], offset aMpVoid0StrVoid ; "mp != ((void *)0) && str !=	((void *)0)"...
		call	_assert
; ---------------------------------------------------------------------------

loc_100171BC:				; CODE XREF: mw_mp_read_radix+56j
					; mw_mp_read_radix+90j
		add	esi, 1
		mov	[ebp+var_D], 1
		jmp	loc_10017132
; ---------------------------------------------------------------------------

loc_100171C8:				; CODE XREF: mw_mp_read_radix+60j
					; mw_mp_read_radix+98j
		add	esi, 1
		jmp	loc_1001712E
; ---------------------------------------------------------------------------

loc_100171D0:				; CODE XREF: mw_mp_read_radix+103j
		movzx	edx, [ebp+var_D]
		xor	eax, eax
		mov	[edi], dl
		jmp	short loc_10017198
; ---------------------------------------------------------------------------

loc_100171DA:				; CODE XREF: mw_mp_read_radix+4Cj
		xor	esi, esi
		jmp	loc_1001712E
mw_mp_read_radix endp

; ---------------------------------------------------------------------------
		jmp	short mw_mp_count_bits
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 395. mw_mp_count_bits

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_count_bits
mw_mp_count_bits proc near		; CODE XREF: .text:100171E1j
					; mw_mp_radix_size+19p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	short loc_10017226
		mov	eax, [ebx+8]
		mov	edx, eax
		shl	edx, 4
		lea	ecx, [edx-10h]
		mov	edx, [ebx+0Ch]
		movzx	eax, word ptr [edx+eax*2-2]
		test	ax, ax
		jz	short loc_1001721E

loc_10017216:				; CODE XREF: mw_mp_count_bits+2Cj
		add	ecx, 1
		shr	ax, 1
		jnz	short loc_10017216

loc_1001721E:				; CODE XREF: mw_mp_count_bits+24j
		add	esp, 14h
		mov	eax, ecx
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10017226:				; CODE XREF: mw_mp_count_bits+Cj
		mov	[esp+18h+var_10], 98Ah
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aMpVoid0 ; "mp	!= ((void *)0)"
		call	_assert
mw_mp_count_bits endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 423. mw_mp_radix_size

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_radix_size
mw_mp_radix_size proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_0]
		mov	[ebp+var_C], ebx
		mov	[ebp+var_8], esi
		test	edi, edi
		jz	short loc_100172A2
		mov	[esp+18h+var_18], edi
		call	mw_mp_count_bits
		mov	edx, [ebp+arg_4]
		mov	[esp+18h+var_14], edx
		mov	[esp+18h+var_18], eax
		call	s_mw_mp_outlen
		mov	[esp+18h+var_18], edi
		mov	esi, eax
		lea	ebx, [eax+1]
		call	mw_mp_cmw_mp_z
		lea	edx, [esi+2]
		mov	edi, [ebp+var_4]
		mov	esi, [ebp+var_8]
		add	eax, 1
		cmovle	ebx, edx
		mov	eax, ebx
		mov	ebx, [ebp+var_C]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100172A2:				; CODE XREF: mw_mp_radix_size+14j
		mov	[esp+18h+var_10], 9D8h
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aMpVoid0 ; "mp	!= ((void *)0)"
		call	_assert
mw_mp_radix_size endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 439. mw_mp_to_unsigned_bin

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_to_unsigned_bin
mw_mp_to_unsigned_bin proc near		; CODE XREF: sub_10003DD0+2Cp
					; mw_mp_to_signed_bin+23j

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	eax, [ebp+arg_0]
		mov	ebx, [ebp+arg_4]
		test	eax, eax
		jz	loc_10017365
		test	ebx, ebx
		jz	loc_10017365
		mov	ecx, [eax+0Ch]
		mov	eax, [eax+8]
		lea	eax, [ecx+eax*2]
		lea	esi, [eax-2]
		cmp	ecx, esi
		jz	short loc_10017351
		jnb	loc_10017381
		mov	edx, ebx

loc_100172F6:				; CODE XREF: mw_mp_to_unsigned_bin+4Aj
		movzx	eax, word ptr [ecx]
		add	ecx, 2
		mov	[edx], al
		shr	ax, 8
		mov	[edx+1], al
		add	edx, 2
		cmp	esi, ecx
		ja	short loc_100172F6

loc_1001730C:				; CODE XREF: mw_mp_to_unsigned_bin+C3j
		movzx	eax, word ptr [esi]
		test	ax, ax
		jz	short loc_10017322

loc_10017314:				; CODE XREF: mw_mp_to_unsigned_bin+60j
					; mw_mp_to_unsigned_bin+A3j
		mov	[edx], al
		shr	ax, 8
		add	edx, 1
		test	ax, ax
		jnz	short loc_10017314

loc_10017322:				; CODE XREF: mw_mp_to_unsigned_bin+52j
		lea	eax, [edx-1]
		cmp	ebx, eax
		jnb	short loc_10017348
		lea	ecx, [edx-2]
		lea	esi, [esi+0]

loc_10017330:				; CODE XREF: mw_mp_to_unsigned_bin+86j
		movzx	eax, byte ptr [ebx]
		movzx	edx, byte ptr [ecx+1]
		mov	[ebx], dl
		add	ebx, 1
		mov	[ecx+1], al
		mov	eax, ecx
		sub	ecx, 1
		cmp	ebx, eax
		jb	short loc_10017330

loc_10017348:				; CODE XREF: mw_mp_to_unsigned_bin+67j
					; mw_mp_to_unsigned_bin+9Bj
		add	esp, 10h
		xor	eax, eax
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10017351:				; CODE XREF: mw_mp_to_unsigned_bin+2Cj
		cmp	word ptr [eax-2], 0
		jnz	short loc_1001735D
		mov	byte ptr [ebx],	0
		jmp	short loc_10017348
; ---------------------------------------------------------------------------

loc_1001735D:				; CODE XREF: mw_mp_to_unsigned_bin+96j
		movzx	eax, word ptr [eax-2]
		mov	edx, ebx
		jmp	short loc_10017314
; ---------------------------------------------------------------------------

loc_10017365:				; CODE XREF: mw_mp_to_unsigned_bin+10j
					; mw_mp_to_unsigned_bin+18j
		mov	[esp+18h+var_10], 952h
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aMpVoid0StrVo_0 ; "mp != ((void *)0) && str !=	((void *)0)"
		call	_assert
; ---------------------------------------------------------------------------

loc_10017381:				; CODE XREF: mw_mp_to_unsigned_bin+2Ej
		mov	edx, ebx
		jmp	short loc_1001730C
mw_mp_to_unsigned_bin endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 441. mw_mp_unsigned_bin_size

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_unsigned_bin_size
mw_mp_unsigned_bin_size	proc near	; CODE XREF: sub_10003DD0+13p
					; mw_mp_signed_bin_size+10p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	edx, [ebp+arg_0]
		test	edx, edx
		jz	short loc_100173D7
		mov	eax, [edx+8]
		cmp	eax, 1
		jz	short loc_100173C7
		mov	ecx, [edx+0Ch]

loc_100173A8:				; CODE XREF: mw_mp_unsigned_bin_size+43j
		add	eax, eax
		lea	edx, [eax-2]
		movzx	eax, word ptr [ecx+eax-2]
		test	ax, ax
		jz	short locret_100173C3

loc_100173B7:				; CODE XREF: mw_mp_unsigned_bin_size+31j
		shr	ax, 8
		add	edx, 1
		test	ax, ax
		jnz	short loc_100173B7

locret_100173C3:			; CODE XREF: mw_mp_unsigned_bin_size+25j
					; mw_mp_unsigned_bin_size+45j
		leave
		mov	eax, edx
		retn
; ---------------------------------------------------------------------------

loc_100173C7:				; CODE XREF: mw_mp_unsigned_bin_size+13j
		mov	ecx, [edx+0Ch]
		mov	edx, 1
		cmp	word ptr [ecx],	0
		jnz	short loc_100173A8
		jmp	short locret_100173C3
; ---------------------------------------------------------------------------

loc_100173D7:				; CODE XREF: mw_mp_unsigned_bin_size+Bj
		mov	[esp+18h+var_10], 937h
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aMpVoid0 ; "mp	!= ((void *)0)"
		call	_assert
mw_mp_unsigned_bin_size	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 438. mw_mp_to_signed_bin

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_to_signed_bin
mw_mp_to_signed_bin proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	ecx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	ecx, ecx
		jz	short loc_10017428
		test	edx, edx
		jz	short loc_10017428
		movzx	eax, byte ptr [ecx]
		mov	[edx], al
		lea	eax, [edx+1]
		mov	[ebp+arg_4], eax
		mov	[ebp+arg_0], ecx
		leave
		jmp	mw_mp_to_unsigned_bin
; ---------------------------------------------------------------------------

loc_10017428:				; CODE XREF: mw_mp_to_signed_bin+Ej
					; mw_mp_to_signed_bin+12j
		mov	[esp+18h+var_10], 906h
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aMpVoid0StrVo_0 ; "mp != ((void *)0) && str !=	((void *)0)"
		call	_assert
mw_mp_to_signed_bin endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 430. mw_mp_signed_bin_size

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_signed_bin_size
mw_mp_signed_bin_size proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_1001746A
		mov	[esp+18h+var_18], eax
		call	mw_mp_unsigned_bin_size
		leave
		add	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_1001746A:				; CODE XREF: mw_mp_signed_bin_size+Bj
		mov	[esp+18h+var_10], 8FAh
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aMpVoid0 ; "mp	!= ((void *)0)"
		call	_assert
mw_mp_signed_bin_size endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 413. mw_mp_isodd

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_isodd
mw_mp_isodd	proc near		; CODE XREF: mw_mp_iseven+Cp
					; mw_mp_gcd+11Fp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		test	eax, eax
		jz	short loc_100174A8
		mov	eax, [eax+0Ch]
		movzx	eax, word ptr [eax]
		leave
		and	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_100174A8:				; CODE XREF: mw_mp_isodd+Bj
		mov	[esp+18h+var_10], 764h
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aAVoid0 ; "a != ((void	*)0)"
		call	_assert
mw_mp_isodd	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 412. mw_mp_iseven

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_iseven
mw_mp_iseven	proc near		; CODE XREF: mw_mp_xgcd+1A7p
					; mw_mp_xgcd+1B3p ...

var_8		= dword	ptr -8
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+arg_0]
		mov	[esp+8+var_8], eax
		call	mw_mp_isodd
		leave
		test	eax, eax
		setz	al
		movzx	eax, al
		retn
mw_mp_iseven	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 392. mw_mp_cmw_mp_mag

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_cmw_mp_mag
mw_mp_cmw_mp_mag proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+arg_4]
		test	edx, edx
		jz	short loc_10017510
		test	eax, eax
		jz	short loc_10017510
		mov	[ebp+arg_4], eax
		mov	[ebp+arg_0], edx
		leave
		jmp	s_mw_mp_cmp
; ---------------------------------------------------------------------------

loc_10017510:				; CODE XREF: mw_mp_cmw_mp_mag+Ej
					; mw_mp_cmw_mp_mag+12j
		mov	[esp+18h+var_10], 73Ah
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aAVoid0BVoid0 ; "a != ((void *)0) && b	!= ((void *)0)"
		call	_assert
mw_mp_cmw_mp_mag endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 389. mw_mp_cmp

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_cmp
mw_mp_cmp	proc near		; CODE XREF: s_mw_mp_reduce+E1p
					; mw_mp_xgcd+3A4p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	ebx, [ebp+arg_0]
		mov	edx, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_10017580
		test	edx, edx
		jz	short loc_10017580
		movzx	eax, byte ptr [ebx]
		cmp	al, [edx]
		jnz	short loc_10017570
		mov	[esp+18h+var_14], edx
		mov	[esp+18h+var_18], ebx
		call	s_mw_mp_cmp
		test	eax, eax
		jz	short loc_10017563
		cmp	byte ptr [ebx],	0
		jz	short loc_10017563
		neg	eax

loc_10017563:				; CODE XREF: mw_mp_cmp+2Aj
					; mw_mp_cmp+2Fj
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10017570:				; CODE XREF: mw_mp_cmp+1Aj
		cmp	al, 1
		sbb	eax, eax
		add	esp, 14h
		pop	ebx
		and	eax, 2
		pop	ebp
		sub	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_10017580:				; CODE XREF: mw_mp_cmp+Fj
					; mw_mp_cmp+13j
		mov	[esp+18h+var_10], 719h
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aAVoid0BVoid0 ; "a != ((void *)0) && b	!= ((void *)0)"
		call	_assert
mw_mp_cmp	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 390. mw_mp_cmw_mp_d

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_cmw_mp_d
mw_mp_cmw_mp_d	proc near		; CODE XREF: mw_mp_sqrt+3Ap
					; mw_mp_sqrt+6Bp ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	edx, [ebp+arg_0]
		movzx	eax, word ptr [ebp+arg_4]
		test	edx, edx
		jz	short loc_100175CC
		cmp	byte ptr [edx],	1
		jz	short locret_100175C5
		movzx	eax, ax
		mov	[ebp+arg_4], eax
		mov	[ebp+arg_0], edx
		leave
		jmp	s_mw_mp_cmw_mp_d
; ---------------------------------------------------------------------------

locret_100175C5:			; CODE XREF: mw_mp_cmw_mp_d+14j
		leave
		mov	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_100175CC:				; CODE XREF: mw_mp_cmw_mp_d+Fj
		mov	[esp+18h+var_10], 70Ah
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aAVoid0 ; "a != ((void	*)0)"
		call	_assert
mw_mp_cmw_mp_d	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 381. mw_mp_2expt

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_2expt
mw_mp_2expt	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	edx, [ebp+arg_0]
		movzx	eax, word ptr [ebp+arg_4]
		test	edx, edx
		jz	short loc_10017610
		movzx	eax, ax
		mov	[ebp+arg_4], eax
		mov	[ebp+arg_0], edx
		leave
		jmp	s_mw_mp_2expt
; ---------------------------------------------------------------------------

loc_10017610:				; CODE XREF: mw_mp_2expt+Fj
		mov	[esp+18h+var_10], 53Fh
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aAVoid0 ; "a != ((void	*)0)"
		call	_assert
mw_mp_2expt	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 428. mw_mp_set_int

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_set_int
mw_mp_set_int	proc near		; CODE XREF: mwMpi_setDHBase+18p
					; sub_10003CA0+32p ...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		mov	eax, [ebp+arg_4]
		mov	esi, [ebp+arg_4]
		mov	edi, [ebp+arg_0]
		sar	eax, 1Fh
		xor	esi, eax
		sub	esi, eax
		test	edi, edi
		jz	short loc_100176B7
		mov	[esp+18h+var_18], edi
		call	mw_mp_zero
		mov	ecx, [ebp+arg_4]
		xor	eax, eax
		test	ecx, ecx
		jnz	short loc_10017666

loc_1001765E:				; CODE XREF: mw_mp_set_int+52j
					; mw_mp_set_int+6Bj ...
		add	esp, 0Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10017666:				; CODE XREF: mw_mp_set_int+2Cj
		mov	ebx, 18h
		nop
		lea	esi, [esi+0]

loc_10017670:				; CODE XREF: mw_mp_set_int+73j
		mov	[esp+18h+var_14], 8
		mov	[esp+18h+var_18], edi
		call	s_mw_mp_mul_2d
		test	eax, eax
		jnz	short loc_1001765E
		mov	ecx, ebx
		mov	eax, esi
		shr	eax, cl
		movzx	eax, al
		mov	[esp+18h+var_14], eax
		mov	[esp+18h+var_18], edi
		call	s_mw_mp_add_d
		test	eax, eax
		jnz	short loc_1001765E
		sub	ebx, 8
		cmp	ebx, 0FFFFFFF8h
		jnz	short loc_10017670
		mov	edx, [ebp+arg_4]
		test	edx, edx
		jns	short loc_1001765E
		mov	byte ptr [edi],	1
		add	esp, 0Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100176B7:				; CODE XREF: mw_mp_set_int+1Bj
		mov	[esp+18h+var_10], 1F2h
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aMpVoid0 ; "mp	!= ((void *)0)"
		call	_assert
mw_mp_set_int	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 388. mw_mp_clear_array

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_clear_array
mw_mp_clear_array proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		mov	edx, [ebp+arg_0]
		mov	edi, [ebp+arg_4]
		test	edx, edx
		jz	short loc_1001772A
		test	edi, edi
		jle	short loc_1001772A
		mov	eax, edi
		sub	eax, 1
		js	short loc_10017722
		mov	eax, edi
		xor	esi, esi
		shl	eax, 4
		lea	ebx, [edx+eax-10h]
		lea	esi, [esi+0]

loc_10017710:				; CODE XREF: mw_mp_clear_array+40j
		add	esi, 1
		mov	[esp+18h+var_18], ebx
		sub	ebx, 10h
		call	mw_mp_clear
		cmp	esi, edi
		jnz	short loc_10017710

loc_10017722:				; CODE XREF: mw_mp_clear_array+1Cj
		add	esp, 0Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1001772A:				; CODE XREF: mw_mp_clear_array+11j
					; mw_mp_clear_array+15j
		mov	[esp+18h+var_10], 1BEh
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aMpVoid0Count0	; "mp != ((void	*)0) &&	count >	0"
		call	_assert
mw_mp_clear_array endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 400. mw_mp_exch

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_exch
mw_mp_exch	proc near		; CODE XREF: s_mw_mp_div_d+C4p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+arg_4]
		test	edx, edx
		jz	short loc_10017770
		test	eax, eax
		jz	short loc_10017770
		mov	[ebp+arg_4], eax
		mov	[ebp+arg_0], edx
		leave
		jmp	s_mw_mp_exch
; ---------------------------------------------------------------------------

loc_10017770:				; CODE XREF: mw_mp_exch+Ej
					; mw_mp_exch+12j
		mov	[esp+18h+var_10], 190h
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aMp1NullMp2Null ; "mp1	!= NULL	&& mp2 != NULL"
		call	_assert
mw_mp_exch	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 394. mw_mp_copy

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_copy
mw_mp_copy	proc near		; CODE XREF: mw_mp_div_2d+2Cp
					; mw_mp_div_2d+69p ...

Dst		= dword	ptr -18h
Val		= dword	ptr -14h
Size		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_C], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_4]
		mov	[ebp+var_4], edi
		test	ebx, ebx
		jz	loc_10017864
		test	esi, esi
		jz	loc_10017864
		xor	eax, eax
		cmp	ebx, esi
		jz	short loc_1001780A
		mov	edx, [esi+4]
		mov	eax, [ebx+8]
		cmp	edx, eax
		jb	short loc_10017817
		sub	edx, eax
		add	eax, eax
		add	eax, [esi+0Ch]
		add	edx, edx
		mov	[esp+18h+Size],	edx ; Size
		mov	[esp+18h+Val], 0 ; Val
		mov	[esp+18h+Dst], eax ; Dst
		call	memset
		mov	eax, [ebx+8]
		mov	ecx, [esi+0Ch]
		mov	edx, [ebx+0Ch]
		add	eax, eax
		mov	[esp+18h+Size],	eax ; Size
		mov	[esp+18h+Val], edx ; Src
		mov	[esp+18h+Dst], ecx ; Dst
		call	memcpy
		mov	eax, [ebx+8]

loc_10017800:				; CODE XREF: mw_mp_copy+D2j
		mov	[esi+8], eax
		movzx	eax, byte ptr [ebx]
		mov	[esi], al
		xor	eax, eax

loc_1001780A:				; CODE XREF: mw_mp_copy+29j
					; mw_mp_copy+A0j
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10017817:				; CODE XREF: mw_mp_copy+33j
		mov	[esp+18h+Val], 2 ; SizeOfElements
		mov	[esp+18h+Dst], eax ; NumOfElements
		call	calloc
		mov	edi, eax
		mov	eax, 0FFFFFFFEh
		test	edi, edi
		jz	short loc_1001780A
		mov	eax, [ebx+8]
		mov	edx, [ebx+0Ch]
		mov	[esp+18h+Dst], edi ; Dst
		add	eax, eax
		mov	[esp+18h+Size],	eax ; Size
		mov	[esp+18h+Val], edx ; Src
		call	memcpy
		mov	eax, [esi+0Ch]
		test	eax, eax
		jz	short loc_10017859
		mov	[esp+18h+Dst], eax ; Memory
		call	free

loc_10017859:				; CODE XREF: mw_mp_copy+BFj
		mov	eax, [ebx+8]
		mov	[esi+0Ch], edi
		mov	[esi+4], eax
		jmp	short loc_10017800
; ---------------------------------------------------------------------------

loc_10017864:				; CODE XREF: mw_mp_copy+17j
					; mw_mp_copy+1Fj
		mov	[esp+18h+Size],	154h
		mov	[esp+18h+Val], offset aMpi_c ; "mpi.c"
		mov	[esp+18h+Dst], offset aFromVoid0ToVoi ;	"from != ((void	*)0) &&	to != ((void *)0"...
		call	_assert
mw_mp_copy	endp

; Exported entry 398. mw_mp_div_2d

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_div_2d
mw_mp_div_2d	proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_E		= word ptr -0Eh
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_0]
		movzx	eax, [ebp+arg_4]
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_8]
		mov	[ebp+var_C], ebx
		test	edi, edi
		mov	[ebp+var_E], ax
		jz	short loc_10017909
		test	esi, esi
		jz	short loc_100178D6
		mov	[esp+28h+var_24], esi
		mov	[esp+28h+var_28], edi
		call	mw_mp_copy
		test	eax, eax
		mov	ebx, eax
		jz	short loc_100178C6

loc_100178B7:				; CODE XREF: mw_mp_div_2d+5Dj
					; mw_mp_div_2d+72j ...
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100178C6:				; CODE XREF: mw_mp_div_2d+35j
		movzx	eax, [ebp+var_E]
		mov	[esp+28h+var_28], esi
		mov	[esp+28h+var_24], eax
		call	s_mw_mp_div_2d

loc_100178D6:				; CODE XREF: mw_mp_div_2d+23j
		mov	esi, [ebp+arg_C]
		xor	ebx, ebx
		test	esi, esi
		jz	short loc_100178B7
		mov	eax, [ebp+arg_C]
		mov	[esp+28h+var_28], edi
		mov	[esp+28h+var_24], eax
		call	mw_mp_copy
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_100178B7
		movzx	eax, [ebp+var_E]
		mov	[esp+28h+var_24], eax
		mov	eax, [ebp+arg_C]
		mov	[esp+28h+var_28], eax
		call	s_mw_mp_mod_2d
		jmp	short loc_100178B7
; ---------------------------------------------------------------------------

loc_10017909:				; CODE XREF: mw_mp_div_2d+1Fj
		mov	[esp+28h+var_20], 4D5h
		mov	[esp+28h+var_24], offset aMpi_c	; "mpi.c"
		mov	[esp+28h+var_28], offset aAVoid0 ; "a != ((void	*)0)"
		call	_assert
mw_mp_div_2d	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 419. mw_mp_mul_2d

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_mul_2d
mw_mp_mul_2d	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_8]
		mov	[ebp+var_4], esi
		movzx	esi, word ptr [ebp+arg_4]
		test	eax, eax
		jz	short loc_10017987
		test	ebx, ebx
		jz	short loc_10017987
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+var_18], eax
		call	mw_mp_copy
		test	eax, eax
		jnz	short loc_10017963
		test	si, si
		jnz	short loc_10017970

loc_10017963:				; CODE XREF: mw_mp_mul_2d+2Cj
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10017970:				; CODE XREF: mw_mp_mul_2d+31j
		movzx	eax, si
		mov	esi, [ebp+var_4]
		mov	[ebp+arg_0], ebx
		mov	ebx, [ebp+var_8]
		mov	[ebp+arg_4], eax
		mov	esp, ebp
		pop	ebp
		jmp	s_mw_mp_mul_2d
; ---------------------------------------------------------------------------

loc_10017987:				; CODE XREF: mw_mp_mul_2d+18j
					; mw_mp_mul_2d+1Cj
		mov	[esp+18h+var_10], 44Bh
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aAVoid0CVoid0 ; "a != ((void *)0) && c	!= ((void *)0)"
		call	_assert
mw_mp_mul_2d	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 422. mw_mp_neg

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_neg
mw_mp_neg	proc near		; CODE XREF: mw_mp_sub_d+AFp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_4]
		mov	[ebp+var_8], ebx
		test	eax, eax
		jz	short loc_10017A22
		test	esi, esi
		jz	short loc_10017A22
		mov	[esp+18h+var_14], esi
		mov	[esp+18h+var_18], eax
		call	mw_mp_copy
		test	eax, eax
		mov	ebx, eax
		jz	short loc_100179E8
		mov	eax, ebx
		mov	esi, [ebp+var_4]
		mov	ebx, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100179E8:				; CODE XREF: mw_mp_neg+2Aj
		mov	[esp+18h+var_14], 0
		mov	[esp+18h+var_18], esi
		call	s_mw_mp_cmw_mp_d
		test	eax, eax
		jnz	short loc_10017A10
		mov	byte ptr [esi],	0
		mov	eax, ebx
		mov	esi, [ebp+var_4]
		mov	ebx, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10017A10:				; CODE XREF: mw_mp_neg+4Aj
		cmp	byte ptr [esi],	1
		mov	eax, ebx
		setnz	byte ptr [esi]
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10017A22:				; CODE XREF: mw_mp_neg+14j
					; mw_mp_neg+18j
		mov	[esp+18h+var_10], 34Dh
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aAVoid0BVoid0 ; "a != ((void *)0) && b	!= ((void *)0)"
		call	_assert
mw_mp_neg	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 382. mw_mp_abs

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_abs
mw_mp_abs	proc near		; CODE XREF: mw_mp_xgcd+15Ep
					; mw_mp_xgcd+189p

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+arg_0]
		mov	ebx, [ebp+arg_4]
		test	eax, eax
		jz	short loc_10017A70
		test	ebx, ebx
		jz	short loc_10017A70
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+var_18], eax
		call	mw_mp_copy
		test	eax, eax
		jnz	short loc_10017A68
		mov	byte ptr [ebx],	0

loc_10017A68:				; CODE XREF: mw_mp_abs+23j
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10017A70:				; CODE XREF: mw_mp_abs+Fj
					; mw_mp_abs+13j
		mov	[esp+18h+var_10], 334h
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aAVoid0BVoid0 ; "a != ((void *)0) && b	!= ((void *)0)"
		call	_assert
mw_mp_abs	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 397. mw_mp_div_2

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_div_2
mw_mp_div_2	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_4]
		mov	[ebp+var_8], ebx
		test	eax, eax
		jz	short loc_10017AD0
		test	esi, esi
		jz	short loc_10017AD0
		mov	[esp+18h+var_14], esi
		mov	[esp+18h+var_18], eax
		call	mw_mp_copy
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_10017AC4
		mov	[esp+18h+var_18], esi
		call	s_mw_mp_div_2

loc_10017AC4:				; CODE XREF: mw_mp_div_2+2Aj
		mov	eax, ebx
		mov	esi, [ebp+var_4]
		mov	ebx, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10017AD0:				; CODE XREF: mw_mp_div_2+14j
					; mw_mp_div_2+18j
		mov	[esp+18h+var_10], 2E7h
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aAVoid0CVoid0 ; "a != ((void *)0) && c	!= ((void *)0)"
		call	_assert
mw_mp_div_2	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 418. mw_mp_mul_2

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_mul_2
mw_mp_mul_2	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+arg_0]
		mov	ebx, [ebp+arg_4]
		test	eax, eax
		jz	short loc_10017B30
		test	ebx, ebx
		jz	short loc_10017B30
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+var_18], eax
		call	mw_mp_copy
		test	eax, eax
		jz	short loc_10017B20
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10017B20:				; CODE XREF: mw_mp_mul_2+23j
		mov	[ebp+arg_0], ebx
		add	esp, 14h
		pop	ebx
		pop	ebp
		jmp	s_mw_mp_mul_2
; ---------------------------------------------------------------------------
		align 10h

loc_10017B30:				; CODE XREF: mw_mp_mul_2+Fj
					; mw_mp_mul_2+13j
		mov	[esp+18h+var_10], 281h
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aAVoid0CVoid0 ; "a != ((void *)0) && c	!= ((void *)0)"
		call	_assert
mw_mp_mul_2	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 420. mw_mp_mul_d

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_mul_d
mw_mp_mul_d	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_8]
		mov	[ebp+var_4], esi
		movzx	esi, word ptr [ebp+arg_4]
		test	eax, eax
		jz	short loc_10017BC0
		test	ebx, ebx
		jz	short loc_10017BC0
		test	si, si
		jz	short loc_10017B90
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+var_18], eax
		call	mw_mp_copy
		test	eax, eax
		jz	short loc_10017BA4
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10017B90:				; CODE XREF: mw_mp_mul_d+21j
		mov	[esp+18h+var_18], ebx
		call	mw_mp_zero
		mov	ebx, [ebp+var_8]
		xor	eax, eax
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10017BA4:				; CODE XREF: mw_mp_mul_d+31j
		movzx	eax, si
		mov	esi, [ebp+var_4]
		mov	[ebp+arg_0], ebx
		mov	ebx, [ebp+var_8]
		mov	[ebp+arg_4], eax
		mov	esp, ebp
		pop	ebp
		jmp	s_mw_mp_mul_d
; ---------------------------------------------------------------------------
		align 10h

loc_10017BC0:				; CODE XREF: mw_mp_mul_d+18j
					; mw_mp_mul_d+1Cj
		mov	[esp+18h+var_10], 269h
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aAVoid0BVoid0 ; "a != ((void *)0) && b	!= ((void *)0)"
		call	_assert
mw_mp_mul_d	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 436. mw_mp_sub_d

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_sub_d
mw_mp_sub_d	proc near		; CODE XREF: mw_mp_sqrt+19Fp

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_E		= word ptr -0Eh
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_0]
		movzx	edx, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		mov	ebx, [ebp+arg_8]
		mov	[ebp+var_8], esi
		test	eax, eax
		mov	[ebp+var_4], edi
		mov	[ebp+var_E], dx
		jz	loc_10017CB0
		test	ebx, ebx
		jz	loc_10017CB0
		mov	[esp+28h+var_24], ebx
		mov	[esp+28h+var_28], eax
		call	mw_mp_copy
		test	eax, eax
		mov	edi, eax
		jnz	short loc_10017C60
		cmp	byte ptr [ebx],	1
		jz	short loc_10017C70
		movzx	esi, [ebp+var_E]
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], esi
		call	s_mw_mp_cmw_mp_d
		test	eax, eax
		js	short loc_10017C88
		mov	[esp+28h+var_24], esi
		mov	[esp+28h+var_28], ebx
		call	s_mw_mp_sub_d
		test	eax, eax
		jnz	short loc_10017C84

loc_10017C48:				; CODE XREF: mw_mp_sub_d+A2j
					; mw_mp_sub_d+C8j
		mov	[esp+28h+var_24], 0
		mov	[esp+28h+var_28], ebx
		call	s_mw_mp_cmw_mp_d
		test	eax, eax
		jnz	short loc_10017C60
		mov	byte ptr [ebx],	0
		nop

loc_10017C60:				; CODE XREF: mw_mp_sub_d+3Dj
					; mw_mp_sub_d+7Aj ...
		mov	eax, edi
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10017C70:				; CODE XREF: mw_mp_sub_d+42j
		movzx	eax, [ebp+var_E]
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	s_mw_mp_add_d
		test	eax, eax
		jz	short loc_10017C48

loc_10017C84:				; CODE XREF: mw_mp_sub_d+66j
		mov	edi, eax
		jmp	short loc_10017C60
; ---------------------------------------------------------------------------

loc_10017C88:				; CODE XREF: mw_mp_sub_d+56j
		mov	[esp+28h+var_24], ebx
		mov	[esp+28h+var_28], ebx
		call	mw_mp_neg
		mov	eax, [ebx+0Ch]
		movzx	edx, word ptr [eax]
		sub	[ebp+var_E], dx
		movzx	edx, [ebp+var_E]
		mov	[eax], dx
		mov	byte ptr [ebx],	1
		jmp	short loc_10017C48
; ---------------------------------------------------------------------------
		align 10h

loc_10017CB0:				; CODE XREF: mw_mp_sub_d+1Fj
					; mw_mp_sub_d+27j
		mov	[esp+28h+var_20], 23Fh
		mov	[esp+28h+var_24], offset aMpi_c	; "mpi.c"
		mov	[esp+28h+var_28], offset aAVoid0BVoid0 ; "a != ((void *)0) && b	!= ((void *)0)"
		call	_assert
mw_mp_sub_d	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 384. mw_mp_add_d

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_add_d
mw_mp_add_d	proc near		; CODE XREF: mw_mp_read_unsigned_bin+4Ep

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_C], ebx
		mov	ebx, [ebp+arg_8]
		mov	[ebp+var_8], esi
		movzx	esi, word ptr [ebp+arg_4]
		mov	[ebp+var_4], edi
		test	eax, eax
		jz	loc_10017D80
		test	ebx, ebx
		jz	loc_10017D80
		mov	[esp+28h+var_24], ebx
		mov	[esp+28h+var_28], eax
		call	mw_mp_copy
		test	eax, eax
		mov	edi, eax
		jnz	short loc_10017D70
		cmp	byte ptr [ebx],	0
		jz	short loc_10017D40
		movzx	eax, si
		mov	[ebp+var_10], eax
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_28], ebx
		call	s_mw_mp_cmw_mp_d
		test	eax, eax
		js	short loc_10017D60
		mov	eax, [ebp+var_10]
		mov	[ebp+arg_0], ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	[ebp+arg_4], eax
		mov	esp, ebp
		pop	ebp
		jmp	s_mw_mp_sub_d
; ---------------------------------------------------------------------------

loc_10017D40:				; CODE XREF: mw_mp_add_d+3Ej
		movzx	eax, si
		mov	edi, [ebp+var_4]
		mov	[ebp+arg_0], ebx
		mov	esi, [ebp+var_8]
		mov	[ebp+arg_4], eax
		mov	ebx, [ebp+var_C]
		mov	esp, ebp
		pop	ebp
		jmp	s_mw_mp_add_d
; ---------------------------------------------------------------------------
		align 10h

loc_10017D60:				; CODE XREF: mw_mp_add_d+54j
		mov	eax, [ebx+0Ch]
		mov	byte ptr [ebx],	0
		sub	si, [eax]
		mov	[eax], si
		lea	esi, [esi+0]

loc_10017D70:				; CODE XREF: mw_mp_add_d+39j
		mov	eax, edi
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10017D80:				; CODE XREF: mw_mp_add_d+1Bj
					; mw_mp_add_d+23j
		mov	[esp+28h+var_20], 21Dh
		mov	[esp+28h+var_24], offset aMpi_c	; "mpi.c"
		mov	[esp+28h+var_28], offset aAVoid0BVoid0 ; "a != ((void *)0) && b	!= ((void *)0)"
		call	_assert
mw_mp_add_d	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 426. mw_mp_read_unsigned_bin

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_read_unsigned_bin
mw_mp_read_unsigned_bin	proc near	; CODE XREF: sub_10003790+16p
					; mwMpi_setDHPrime+20p	...

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		mov	esi, [ebp+arg_0]
		mov	edi, [ebp+arg_8]
		test	esi, esi
		jz	short loc_10017E06
		mov	eax, [ebp+arg_4]
		test	eax, eax
		jz	short loc_10017E06
		test	edi, edi
		jle	short loc_10017E06
		mov	[esp+18h+var_18], esi
		xor	ebx, ebx
		call	mw_mp_zero

loc_10017DC8:				; CODE XREF: mw_mp_read_unsigned_bin+5Cj
		mov	[esp+18h+var_14], 8
		mov	[esp+18h+var_18], esi
		call	s_mw_mp_mul_2d
		test	eax, eax
		jnz	short loc_10017DFE
		mov	edx, [ebp+arg_4]
		mov	[esp+18h+var_10], esi
		movzx	eax, byte ptr [ebx+edx]
		mov	[esp+18h+var_18], esi
		mov	[esp+18h+var_14], eax
		call	mw_mp_add_d
		test	eax, eax
		jnz	short loc_10017DFE
		add	ebx, 1
		cmp	ebx, edi
		jnz	short loc_10017DC8

loc_10017DFE:				; CODE XREF: mw_mp_read_unsigned_bin+3Aj
					; mw_mp_read_unsigned_bin+55j
		add	esp, 0Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10017E06:				; CODE XREF: mw_mp_read_unsigned_bin+11j
					; mw_mp_read_unsigned_bin+18j ...
		mov	[esp+18h+var_10], 91Eh
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aMpVoid0StrVo_1 ; "mp != ((void *)0) && str !=	((void *)0)"...
		call	_assert
mw_mp_read_unsigned_bin	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 425. mw_mp_read_signed_bin

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_read_signed_bin
mw_mp_read_signed_bin proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		mov	eax, [ebp+arg_8]
		mov	ebx, [ebp+arg_4]
		test	esi, esi
		jz	short loc_10017E80
		test	ebx, ebx
		jz	short loc_10017E80
		test	eax, eax
		jle	short loc_10017E80
		sub	eax, 1
		mov	[esp+18h+var_10], eax
		lea	eax, [ebx+1]
		mov	[esp+18h+var_14], eax
		mov	[esp+18h+var_18], esi
		call	mw_mp_read_unsigned_bin
		test	eax, eax
		jnz	short loc_10017E71
		cmp	byte ptr [ebx],	0
		setnz	byte ptr [esi]

loc_10017E71:				; CODE XREF: mw_mp_read_signed_bin+39j
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10017E80:				; CODE XREF: mw_mp_read_signed_bin+17j
					; mw_mp_read_signed_bin+1Bj ...
		mov	[esp+18h+var_10], 8E6h
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aMpVoid0StrVo_1 ; "mp != ((void *)0) && str !=	((void *)0)"...
		call	_assert
mw_mp_read_signed_bin endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 409. mw_mp_init_copy

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_init_copy
mw_mp_init_copy	proc near		; CODE XREF: mw_mp_sub+189p
					; mw_mp_sub+1F2p ...

NumOfElements	= dword	ptr -18h
SizeOfElements	= dword	ptr -14h
Size		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_4]
		test	esi, esi
		jz	short loc_10017F18
		test	ebx, ebx
		jz	short loc_10017F18
		xor	eax, eax
		cmp	esi, ebx
		jnz	short loc_10017ECA

loc_10017EC0:				; CODE XREF: mw_mp_init_copy+49j
					; mw_mp_init_copy+76j
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10017ECA:				; CODE XREF: mw_mp_init_copy+1Ej
		mov	[esp+18h+SizeOfElements], 2 ; SizeOfElements
		mov	eax, [ebx+8]
		mov	[esp+18h+NumOfElements], eax ; NumOfElements
		call	calloc
		mov	ecx, eax
		test	ecx, ecx
		mov	[esi+0Ch], eax
		mov	eax, 0FFFFFFFEh
		jz	short loc_10017EC0
		mov	eax, [ebx+8]
		mov	edx, [ebx+0Ch]
		mov	[esp+18h+NumOfElements], ecx ; Dst
		add	eax, eax
		mov	[esp+18h+Size],	eax ; Size
		mov	[esp+18h+SizeOfElements], edx ;	Src
		call	memcpy
		mov	eax, [ebx+8]
		mov	[esi+8], eax
		mov	eax, [ebx+8]
		mov	[esi+4], eax
		movzx	eax, byte ptr [ebx]
		mov	[esi], al
		xor	eax, eax
		jmp	short loc_10017EC0
; ---------------------------------------------------------------------------

loc_10017F18:				; CODE XREF: mw_mp_init_copy+14j
					; mw_mp_init_copy+18j
		mov	[esp+18h+Size],	135h
		mov	[esp+18h+SizeOfElements], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+NumOfElements], offset	aMpVoid0FromVoi	; "mp != ((void	*)0) &&	from !=	((void *)0"...
		call	_assert
mw_mp_init_copy	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 435. mw_mp_sub

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_sub
mw_mp_sub	proc near		; CODE XREF: mw_mp_submod+33p
					; s_mw_mp_reduce+ADp ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= byte ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_8]
		mov	[ebp+var_C], ebx
		test	esi, esi
		jz	short loc_10017FD2
		mov	eax, [ebp+arg_4]
		test	eax, eax
		jz	short loc_10017FD2
		test	edi, edi
		jz	short loc_10017FD2
		mov	edx, [ebp+arg_4]
		movzx	eax, byte ptr [esi]
		cmp	al, [edx]
		jz	loc_10017FF0
		cmp	edi, esi
		jz	loc_10018042
		cmp	edi, [ebp+arg_4]
		jz	short loc_10017F94
		mov	eax, [ebp+arg_4]
		mov	[esp+28h+var_24], edi
		mov	[esp+28h+var_28], eax
		call	mw_mp_copy
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_10017FB3

loc_10017F94:				; CODE XREF: mw_mp_sub+3Dj
		mov	[esp+28h+var_24], esi
		mov	[esp+28h+var_28], edi
		call	s_mw_mp_add
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_10017FB3
		movzx	eax, byte ptr [esi]
		mov	[edi], al

loc_10017FAB:				; CODE XREF: mw_mp_sub+F7j
					; mw_mp_sub+112j ...
		cmp	dword ptr [edi+8], 1
		jz	short loc_10017FC2

loc_10017FB1:				; CODE XREF: mw_mp_sub+89j
		xor	ebx, ebx

loc_10017FB3:				; CODE XREF: mw_mp_sub+52j
					; mw_mp_sub+64j ...
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10017FC2:				; CODE XREF: mw_mp_sub+6Fj
		mov	eax, [edi+0Ch]
		cmp	word ptr [eax],	0
		jnz	short loc_10017FB1
		xor	ebx, ebx
		mov	byte ptr [edi],	0
		jmp	short loc_10017FB3
; ---------------------------------------------------------------------------

loc_10017FD2:				; CODE XREF: mw_mp_sub+17j
					; mw_mp_sub+1Ej ...
		mov	[esp+28h+var_20], 3CEh
		mov	[esp+28h+var_24], offset aMpi_c	; "mpi.c"
		mov	[esp+28h+var_28], offset aAVoid0BVoid0CV ; "a != ((void	*)0) &&	b != ((void *)0) &&"...
		call	_assert
; ---------------------------------------------------------------------------
		align 10h

loc_10017FF0:				; CODE XREF: mw_mp_sub+2Cj
		mov	edx, [ebp+arg_4]
		mov	[esp+28h+var_28], esi
		mov	[esp+28h+var_24], edx
		call	s_mw_mp_cmp
		cmp	eax, 0
		jle	short loc_1001805D
		cmp	edi, [ebp+arg_4]
		jz	loc_100180BF
		cmp	edi, esi
		nop
		jz	short loc_10018024
		mov	[esp+28h+var_24], edi
		mov	[esp+28h+var_28], esi
		call	mw_mp_copy
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_10017FB3

loc_10018024:				; CODE XREF: mw_mp_sub+D0j
		mov	eax, [ebp+arg_4]
		mov	[esp+28h+var_28], edi
		mov	[esp+28h+var_24], eax
		call	s_mw_mp_sub
		test	eax, eax
		mov	ebx, eax
		jz	loc_10017FAB
		jmp	loc_10017FB3
; ---------------------------------------------------------------------------

loc_10018042:				; CODE XREF: mw_mp_sub+34j
		mov	[esp+28h+var_24], edx
		mov	[esp+28h+var_28], edi
		call	s_mw_mp_add
		test	eax, eax
		mov	ebx, eax
		jz	loc_10017FAB
		jmp	loc_10017FB3
; ---------------------------------------------------------------------------

loc_1001805D:				; CODE XREF: mw_mp_sub+C2j
		lea	esi, [esi+0]
		jz	loc_10018103
		cmp	edi, esi
		nop
		lea	esi, [esi+0]
		jz	loc_10018125
		cmp	edi, [ebp+arg_4]
		lea	esi, [esi+0]
		jz	short loc_1001809B
		mov	eax, [ebp+arg_4]
		mov	[esp+28h+var_24], edi
		mov	[esp+28h+var_28], eax
		call	mw_mp_copy
		test	eax, eax
		mov	ebx, eax
		jnz	loc_10017FB3

loc_1001809B:				; CODE XREF: mw_mp_sub+140j
		mov	[esp+28h+var_24], esi
		mov	[esp+28h+var_28], edi
		call	s_mw_mp_sub
		test	eax, eax
		mov	ebx, eax
		jnz	loc_10017FB3

loc_100180B1:				; CODE XREF: mw_mp_sub+227j
		mov	edx, [ebp+arg_4]
		cmp	byte ptr [edx],	0
		setz	byte ptr [edi]
		jmp	loc_10017FAB
; ---------------------------------------------------------------------------

loc_100180BF:				; CODE XREF: mw_mp_sub+C7j
		mov	[esp+28h+var_24], esi
		lea	esi, [ebp+var_1C]
		mov	[esp+28h+var_28], esi
		call	mw_mp_init_copy
		test	eax, eax
		mov	ebx, eax
		jnz	loc_10017FB3
		mov	[esp+28h+var_24], edi
		mov	[esp+28h+var_28], esi
		call	s_mw_mp_sub
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_10018115
		mov	[esp+28h+var_24], edi
		mov	[esp+28h+var_28], esi
		call	s_mw_mp_exch
		mov	[esp+28h+var_28], esi
		call	mw_mp_clear
		jmp	loc_10017FAB
; ---------------------------------------------------------------------------

loc_10018103:				; CODE XREF: mw_mp_sub+120j
		mov	[esp+28h+var_28], edi
		xor	ebx, ebx
		call	mw_mp_zero
		lea	esi, [esi+0]
		jmp	loc_10017FB3
; ---------------------------------------------------------------------------

loc_10018115:				; CODE XREF: mw_mp_sub+1A8j
					; mw_mp_sub+211j
		mov	[esp+28h+var_28], esi
		call	mw_mp_clear
		lea	esi, [esi+0]
		jmp	loc_10017FB3
; ---------------------------------------------------------------------------

loc_10018125:				; CODE XREF: mw_mp_sub+130j
		mov	edx, [ebp+arg_4]
		lea	esi, [ebp+var_1C]
		mov	[esp+28h+var_28], esi
		mov	[esp+28h+var_24], edx
		call	mw_mp_init_copy
		test	eax, eax
		mov	ebx, eax
		jnz	loc_10017FB3
		mov	[esp+28h+var_24], edi
		mov	[esp+28h+var_28], esi
		call	s_mw_mp_sub
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_10018115
		mov	[esp+28h+var_24], edi
		mov	[esp+28h+var_28], esi
		call	s_mw_mp_exch
		mov	[esp+28h+var_28], esi
		call	mw_mp_clear
		jmp	loc_100180B1
mw_mp_sub	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 383. mw_mp_add

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_add
mw_mp_add	proc near		; CODE XREF: mw_mp_mod+96j
					; mw_mp_addmod+33p ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= byte ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		test	esi, esi
		jz	loc_10018263
		test	edi, edi
		jz	loc_10018263
		mov	eax, [ebp+arg_8]
		test	eax, eax
		jz	loc_10018263
		movzx	eax, byte ptr [esi]
		cmp	al, [edi]
		jz	short loc_10018210
		mov	[esp+28h+var_24], edi
		mov	[esp+28h+var_28], esi
		call	s_mw_mp_cmp
		cmp	eax, 0
		jle	loc_1001827F
		cmp	[ebp+arg_8], edi
		jz	loc_100182D5
		cmp	[ebp+arg_8], esi
		jz	short loc_100181DF
		mov	edx, [ebp+arg_8]
		mov	[esp+28h+var_28], esi
		mov	[esp+28h+var_24], edx
		call	mw_mp_copy
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_10018200

loc_100181DF:				; CODE XREF: mw_mp_add+58j
		mov	eax, [ebp+arg_8]
		mov	[esp+28h+var_24], edi
		mov	[esp+28h+var_28], eax
		call	s_mw_mp_sub
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_10018200

loc_100181F4:				; CODE XREF: mw_mp_add+14Fj
					; mw_mp_add+1AAj ...
		mov	eax, [ebp+arg_8]
		cmp	dword ptr [eax+8], 1
		jz	short loc_10018251

loc_100181FD:				; CODE XREF: mw_mp_add+DFj
					; mw_mp_add+EAj
		xor	ebx, ebx
		nop

loc_10018200:				; CODE XREF: mw_mp_add+6Dj
					; mw_mp_add+82j ...
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10018210:				; CODE XREF: mw_mp_add+35j
		cmp	[ebp+arg_8], edi
		jz	loc_100182CA
		cmp	[ebp+arg_8], esi
		jz	short loc_10018233
		mov	edx, [ebp+arg_8]
		mov	[esp+28h+var_28], esi
		mov	[esp+28h+var_24], edx
		call	mw_mp_copy
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_10018200

loc_10018233:				; CODE XREF: mw_mp_add+ACj
		mov	[esp+28h+var_24], edi

loc_10018237:				; CODE XREF: mw_mp_add+160j
		mov	eax, [ebp+arg_8]
		mov	[esp+28h+var_28], eax
		call	s_mw_mp_add
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_10018200
		mov	eax, [ebp+arg_8]
		cmp	dword ptr [eax+8], 1
		jnz	short loc_100181FD

loc_10018251:				; CODE XREF: mw_mp_add+8Bj
		mov	edx, eax
		mov	eax, [eax+0Ch]
		cmp	word ptr [eax],	0
		jnz	short loc_100181FD
		xor	ebx, ebx
		mov	byte ptr [edx],	0
		jmp	short loc_10018200
; ---------------------------------------------------------------------------

loc_10018263:				; CODE XREF: mw_mp_add+17j
					; mw_mp_add+1Fj ...
		mov	[esp+28h+var_20], 36Ah
		mov	[esp+28h+var_24], offset aMpi_c	; "mpi.c"
		mov	[esp+28h+var_28], offset aAVoid0BVoid0CV ; "a != ((void	*)0) &&	b != ((void *)0) &&"...
		call	_assert
; ---------------------------------------------------------------------------

loc_1001827F:				; CODE XREF: mw_mp_add+46j
		jz	loc_1001831F
		cmp	[ebp+arg_8], esi
		jz	loc_1001833E
		cmp	[ebp+arg_8], edi
		jz	short loc_100182AC
		mov	eax, [ebp+arg_8]
		mov	[esp+28h+var_28], edi
		mov	[esp+28h+var_24], eax
		call	mw_mp_copy
		test	eax, eax
		mov	ebx, eax
		jnz	loc_10018200

loc_100182AC:				; CODE XREF: mw_mp_add+121j
		mov	edx, [ebp+arg_8]
		mov	[esp+28h+var_24], esi
		mov	[esp+28h+var_28], edx
		call	s_mw_mp_sub
		test	eax, eax
		mov	ebx, eax
		jz	loc_100181F4
		jmp	loc_10018200
; ---------------------------------------------------------------------------

loc_100182CA:				; CODE XREF: mw_mp_add+A3j
		mov	[esp+28h+var_24], esi
		xchg	ax, ax
		jmp	loc_10018237
; ---------------------------------------------------------------------------

loc_100182D5:				; CODE XREF: mw_mp_add+4Fj
		mov	[esp+28h+var_24], esi
		lea	esi, [ebp+var_1C]
		mov	[esp+28h+var_28], esi
		call	mw_mp_init_copy
		test	eax, eax
		mov	ebx, eax
		jnz	loc_10018200
		mov	edx, [ebp+arg_8]
		mov	[esp+28h+var_28], esi
		mov	[esp+28h+var_24], edx
		call	s_mw_mp_sub
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_10018331
		mov	eax, [ebp+arg_8]
		mov	[esp+28h+var_28], esi
		mov	[esp+28h+var_24], eax
		call	s_mw_mp_exch
		mov	[esp+28h+var_28], esi
		call	mw_mp_clear
		jmp	loc_100181F4
; ---------------------------------------------------------------------------

loc_1001831F:				; CODE XREF: mw_mp_add:loc_1001827Fj
		mov	edx, [ebp+arg_8]
		xor	ebx, ebx
		mov	[esp+28h+var_28], edx
		call	mw_mp_zero
		jmp	loc_10018200
; ---------------------------------------------------------------------------

loc_10018331:				; CODE XREF: mw_mp_add+191j
					; mw_mp_add+1FAj
		mov	[esp+28h+var_28], esi
		call	mw_mp_clear
		jmp	loc_10018200
; ---------------------------------------------------------------------------

loc_1001833E:				; CODE XREF: mw_mp_add+118j
		lea	esi, [ebp+var_1C]
		mov	[esp+28h+var_24], edi
		mov	[esp+28h+var_28], esi
		call	mw_mp_init_copy
		test	eax, eax
		mov	ebx, eax
		jnz	loc_10018200
		mov	eax, [ebp+arg_8]
		mov	[esp+28h+var_28], esi
		mov	[esp+28h+var_24], eax
		call	s_mw_mp_sub
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_10018331
		mov	edx, [ebp+arg_8]
		mov	[esp+28h+var_28], esi
		mov	[esp+28h+var_24], edx
		call	s_mw_mp_exch
		mov	[esp+28h+var_28], esi
		call	mw_mp_clear
		jmp	loc_100181F4
mw_mp_add	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 410. mw_mp_init_size

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl mw_mp_init_size(int, size_t)
		public mw_mp_init_size
mw_mp_init_size	proc near		; CODE XREF: s_mw_mp_div+81p
					; s_mw_mp_div+9Cp ...

NumOfElements	= dword	ptr -18h
SizeOfElements	= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_100183E1
		test	esi, esi
		jz	short loc_100183E1
		mov	[esp+18h+SizeOfElements], 2 ; SizeOfElements
		mov	[esp+18h+NumOfElements], esi ; NumOfElements
		call	calloc
		mov	edx, 0FFFFFFFEh
		test	eax, eax
		mov	[ebx+0Ch], eax
		jz	short loc_100183D5
		mov	byte ptr [ebx],	0
		xor	edx, edx
		mov	dword ptr [ebx+8], 1
		mov	[ebx+4], esi

loc_100183D5:				; CODE XREF: mw_mp_init_size+34j
		mov	ebx, [ebp+var_8]
		mov	eax, edx
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100183E1:				; CODE XREF: mw_mp_init_size+14j
					; mw_mp_init_size+18j
		mov	[esp+18h+var_10], 11Ah
		mov	[esp+18h+SizeOfElements], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+NumOfElements], offset	aMpVoid0Prec0 ;	"mp != ((void *)0) && prec > 0"
		call	_assert
mw_mp_init_size	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 451. s_mw_mp_div

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_div
s_mw_mp_div	proc near		; CODE XREF: mw_mp_div+138p

var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_46		= word ptr -46h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_2C		= dword	ptr -2Ch
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 58h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		mov	ebx, 0FFFFFFFDh
		mov	[ebp+var_4], edi
		mov	[esp+58h+var_58], esi
		call	mw_mp_cmw_mp_z
		test	eax, eax
		jnz	short loc_10018432

loc_10018423:				; CODE XREF: s_mw_mp_div+6Fj
					; s_mw_mp_div+8Aj ...
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10018432:				; CODE XREF: s_mw_mp_div+21j
		mov	[esp+58h+var_58], esi
		call	s_mw_mp_ispow2
		test	eax, eax
		mov	ebx, eax
		js	short loc_10018471
		mov	eax, [ebp+arg_0]
		movzx	ebx, bx
		mov	[esp+58h+var_54], esi
		mov	[esp+58h+var_58], eax
		call	mw_mp_copy
		mov	edx, [ebp+arg_0]
		mov	[esp+58h+var_54], ebx
		mov	[esp+58h+var_58], edx
		call	s_mw_mp_div_2d
		mov	[esp+58h+var_54], ebx
		xor	ebx, ebx
		mov	[esp+58h+var_58], esi
		call	s_mw_mp_mod_2d
		jmp	short loc_10018423
; ---------------------------------------------------------------------------

loc_10018471:				; CODE XREF: s_mw_mp_div+3Ej
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebx+8]
		mov	[esp+58h+var_54], eax ;	size_t
		lea	eax, [ebp+var_1C]
		mov	[esp+58h+var_58], eax ;	int
		call	mw_mp_init_size
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_10018423
		mov	edx, [ebp+arg_0]
		lea	ebx, [ebp+var_3C]
		mov	eax, [edx+8]
		mov	[esp+58h+var_58], ebx ;	int
		mov	[esp+58h+var_54], eax ;	size_t
		call	mw_mp_init_size
		test	eax, eax
		mov	ebx, eax
		jz	short loc_100184B7

loc_100184A7:				; CODE XREF: s_mw_mp_div+DDj
		lea	edx, [ebp+var_1C]
		mov	[esp+58h+var_58], edx
		call	mw_mp_clear
		jmp	loc_10018423
; ---------------------------------------------------------------------------

loc_100184B7:				; CODE XREF: s_mw_mp_div+A5j
		mov	edx, [ebp+arg_0]
		lea	ebx, [ebp+var_2C]
		mov	eax, [edx+8]
		mov	[esp+58h+var_58], ebx ;	int
		mov	[esp+58h+var_54], eax ;	size_t
		call	mw_mp_init_size
		test	eax, eax
		mov	ebx, eax
		jz	short loc_100184DF

loc_100184D2:				; CODE XREF: s_mw_mp_div+2BCj
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_58], eax
		call	mw_mp_clear
		jmp	short loc_100184A7
; ---------------------------------------------------------------------------

loc_100184DF:				; CODE XREF: s_mw_mp_div+D0j
		mov	eax, [ebp+arg_0]
		mov	[esp+58h+var_54], esi
		mov	[esp+58h+var_58], eax
		call	s_mw_mp_norm
		mov	edx, [ebp+arg_0]
		mov	ebx, [edx+8]
		mov	[ebp+var_46], ax
		sub	ebx, 1
		mov	[ebp+var_44], ebx
		js	loc_10018661

loc_10018504:				; CODE XREF: s_mw_mp_div+25Bj
		mov	edi, [ebp+var_44]
		add	edi, edi
		jmp	short loc_10018573
; ---------------------------------------------------------------------------
		align 10h

loc_10018510:				; CODE XREF: s_mw_mp_div+184j
		mov	eax, [ebp+var_44]
		test	eax, eax
		js	short loc_10018586
		lea	eax, [ebp+var_2C]
		mov	[esp+58h+var_54], 1
		mov	[esp+58h+var_58], eax
		call	s_mw_mp_lshd
		test	eax, eax
		mov	ebx, eax
		jnz	loc_100186B1
		lea	edx, [ebp+var_1C]
		mov	[esp+58h+var_54], 1
		mov	[esp+58h+var_58], edx
		call	s_mw_mp_lshd
		test	eax, eax
		mov	ebx, eax
		jnz	loc_100186B1
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebx+0Ch]
		movzx	edx, word ptr [eax+edi]
		sub	edi, 2
		mov	eax, [ebp+var_20]
		mov	[eax], dx
		lea	eax, [ebp+var_2C]
		mov	[esp+58h+var_58], eax
		call	s_mw_mp_clamp
		sub	[ebp+var_44], 1

loc_10018573:				; CODE XREF: s_mw_mp_div+109j
		lea	edx, [ebp+var_2C]
		mov	[esp+58h+var_54], esi
		mov	[esp+58h+var_58], edx
		call	s_mw_mp_cmp
		test	eax, eax
		js	short loc_10018510

loc_10018586:				; CODE XREF: s_mw_mp_div+115j
		lea	ebx, [ebp+var_2C]
		mov	[esp+58h+var_54], esi
		mov	[esp+58h+var_58], ebx
		call	s_mw_mp_cmp
		test	eax, eax
		js	loc_10018661
		mov	ebx, [ebp+var_24]
		mov	eax, [ebp+var_20]
		mov	edx, [esi+8]
		lea	edi, [ebx+ebx]
		movzx	ecx, word ptr [eax+edi-2]
		mov	[ebp+var_40], eax
		mov	eax, [esi+0Ch]
		movzx	edx, word ptr [eax+edx*2-2]
		cmp	ecx, edx
		ja	short loc_100185CF
		cmp	ebx, 1
		jbe	short loc_100185CF
		mov	ebx, [ebp+var_40]
		shl	ecx, 10h
		movzx	eax, word ptr [ebx+edi-4]
		or	ecx, eax

loc_100185CF:				; CODE XREF: s_mw_mp_div+1BBj
					; s_mw_mp_div+1C0j
		mov	eax, ecx
		mov	ebx, edx
		xor	edx, edx
		mov	edi, 0FFFFh
		div	ebx
		mov	[esp+58h+var_58], esi
		cmp	eax, 0FFFFh
		cmovbe	edi, eax
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_54], eax
		call	mw_mp_copy
		movzx	eax, di
		lea	edx, [ebp+var_3C]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edx
		call	s_mw_mp_mul_d
		test	eax, eax
		mov	ebx, eax
		jz	short loc_10018622
		jmp	loc_100186B1
; ---------------------------------------------------------------------------

loc_10018610:				; CODE XREF: s_mw_mp_div+236j
		lea	ebx, [ebp+var_3C]
		sub	edi, 1
		mov	[esp+58h+var_54], esi
		mov	[esp+58h+var_58], ebx
		call	s_mw_mp_sub

loc_10018622:				; CODE XREF: s_mw_mp_div+209j
		lea	eax, [ebp+var_2C]
		lea	edx, [ebp+var_3C]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edx
		call	s_mw_mp_cmp
		test	eax, eax
		jg	short loc_10018610
		lea	ebx, [ebp+var_3C]
		lea	eax, [ebp+var_2C]
		mov	[esp+58h+var_54], ebx
		mov	[esp+58h+var_58], eax
		call	s_mw_mp_sub
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_100186B1
		mov	eax, [ebp+var_10]
		mov	[eax], di
		mov	eax, [ebp+var_44]
		test	eax, eax
		jns	loc_10018504

loc_10018661:				; CODE XREF: s_mw_mp_div+FEj
					; s_mw_mp_div+197j
		cmp	[ebp+var_46], 0
		jz	short loc_1001867B
		movzx	eax, [ebp+var_46]
		lea	edx, [ebp+var_2C]
		mov	[esp+58h+var_58], edx
		mov	[esp+58h+var_54], eax
		call	s_mw_mp_div_2d

loc_1001867B:				; CODE XREF: s_mw_mp_div+266j
		lea	ebx, [ebp+var_1C]
		mov	[esp+58h+var_58], ebx
		call	s_mw_mp_clamp
		lea	eax, [ebp+var_2C]
		mov	[esp+58h+var_58], eax
		call	s_mw_mp_clamp
		mov	edx, [ebp+arg_0]
		mov	[esp+58h+var_58], ebx
		xor	ebx, ebx
		mov	[esp+58h+var_54], edx
		call	s_mw_mp_exch
		lea	eax, [ebp+var_2C]
		mov	[esp+58h+var_54], esi
		mov	[esp+58h+var_58], eax
		call	s_mw_mp_exch

loc_100186B1:				; CODE XREF: s_mw_mp_div+12Ej
					; s_mw_mp_div+14Bj ...
		lea	edx, [ebp+var_2C]
		mov	[esp+58h+var_58], edx
		call	mw_mp_clear
		jmp	loc_100184D2
s_mw_mp_div	endp

; ---------------------------------------------------------------------------
		jmp	short mw_mp_div
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 396. mw_mp_div

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_div
mw_mp_div	proc near		; CODE XREF: .text:100186C1j
					; mw_mp_mod+70p ...

var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_48		= byte ptr -48h
var_38		= byte ptr -38h
var_28		= byte ptr -28h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 58h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_C], ebx
		mov	ebx, [ebp+arg_4]
		mov	[ebp+var_4], edi
		test	esi, esi
		jz	loc_100188A0
		test	ebx, ebx
		jz	loc_100188A0
		mov	[esp+58h+var_58], ebx
		mov	edi, 0FFFFFFFDh
		call	mw_mp_cmw_mp_z
		test	eax, eax
		jnz	short loc_10018715

loc_10018706:				; CODE XREF: mw_mp_div+A0j
					; mw_mp_div+B5j ...
		mov	eax, edi
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10018715:				; CODE XREF: mw_mp_div+34j
		mov	[esp+58h+var_54], ebx
		mov	[esp+58h+var_58], esi
		call	s_mw_mp_cmp
		cmp	eax, 0
		jl	loc_100187BB
		jnz	short loc_10018772
		mov	edi, [ebp+arg_8]
		test	edi, edi
		jz	short loc_10018758
		movzx	esi, byte ptr [esi]
		mov	eax, [ebp+arg_8]
		movzx	ebx, byte ptr [ebx]
		mov	[esp+58h+var_54], 1
		mov	[esp+58h+var_58], eax
		call	mw_mp_set
		mov	eax, esi
		cmp	al, bl
		jz	short loc_10018758
		mov	eax, [ebp+arg_8]
		mov	byte ptr [eax],	1

loc_10018758:				; CODE XREF: mw_mp_div+61j
					; mw_mp_div+80j
		mov	ecx, [ebp+arg_C]
		test	ecx, ecx
		jz	loc_100187F4
		mov	eax, [ebp+arg_C]
		xor	edi, edi
		mov	[esp+58h+var_58], eax
		call	mw_mp_zero
		jmp	short loc_10018706
; ---------------------------------------------------------------------------

loc_10018772:				; CODE XREF: mw_mp_div+5Aj
		lea	eax, [ebp+var_28]
		mov	[esp+58h+var_54], esi
		mov	[esp+58h+var_58], eax
		call	mw_mp_init_copy
		test	eax, eax
		mov	edi, eax
		jnz	loc_10018706
		lea	eax, [ebp+var_38]
		mov	[esp+58h+var_54], ebx
		mov	[esp+58h+var_58], eax
		call	mw_mp_init_copy
		test	eax, eax
		mov	edi, eax
		jz	short loc_100187FB

loc_100187A0:				; CODE XREF: mw_mp_div+141j
					; mw_mp_div+1B0j ...
		lea	eax, [ebp+var_38]
		mov	[esp+58h+var_58], eax
		call	mw_mp_clear
		lea	eax, [ebp+var_28]
		mov	[esp+58h+var_58], eax
		call	mw_mp_clear
		jmp	loc_10018706
; ---------------------------------------------------------------------------

loc_100187BB:				; CODE XREF: mw_mp_div+54j
		mov	eax, [ebp+arg_C]
		test	eax, eax
		jz	short loc_100187DB
		mov	eax, [ebp+arg_C]
		mov	[esp+58h+var_58], esi
		mov	[esp+58h+var_54], eax
		call	mw_mp_copy
		test	eax, eax
		mov	edi, eax
		jnz	loc_10018706

loc_100187DB:				; CODE XREF: mw_mp_div+F0j
		mov	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_100187F4
		mov	eax, [ebp+arg_8]
		xor	edi, edi
		mov	[esp+58h+var_58], eax
		call	mw_mp_zero
		jmp	loc_10018706
; ---------------------------------------------------------------------------

loc_100187F4:				; CODE XREF: mw_mp_div+8Dj
					; mw_mp_div+110j
		xor	edi, edi
		jmp	loc_10018706
; ---------------------------------------------------------------------------

loc_100187FB:				; CODE XREF: mw_mp_div+CEj
		lea	eax, [ebp+var_38]
		mov	[esp+58h+var_54], eax
		lea	eax, [ebp+var_28]
		mov	[esp+58h+var_58], eax
		call	s_mw_mp_div
		test	eax, eax
		mov	edi, eax
		jnz	short loc_100187A0
		movzx	eax, byte ptr [esi]
		mov	[ebp+var_48], al
		mov	[ebp+var_38], al
		cmp	al, [ebx]
		lea	eax, [ebp+var_28]
		mov	[esp+58h+var_54], 0
		setnz	bl
		xor	esi, esi
		mov	[ebp+var_28], bl
		mov	[esp+58h+var_58], eax
		call	s_mw_mp_cmw_mp_d
		mov	[esp+58h+var_54], 0
		test	eax, eax
		cmovz	ebx, esi
		lea	eax, [ebp+var_38]
		mov	[ebp+var_28], bl
		mov	[esp+58h+var_58], eax
		call	s_mw_mp_cmw_mp_d
		mov	edx, [ebp+arg_8]
		test	eax, eax
		movzx	eax, [ebp+var_48]
		cmovnz	esi, eax
		test	edx, edx
		mov	eax, esi
		mov	[ebp+var_38], al
		jz	short loc_1001887B
		mov	eax, [ebp+arg_8]
		mov	[esp+58h+var_54], eax
		lea	eax, [ebp+var_28]
		mov	[esp+58h+var_58], eax
		call	s_mw_mp_exch

loc_1001887B:				; CODE XREF: mw_mp_div+197j
		mov	eax, [ebp+arg_C]
		test	eax, eax
		jz	loc_100187A0
		mov	eax, [ebp+arg_C]
		mov	[esp+58h+var_54], eax
		lea	eax, [ebp+var_38]
		mov	[esp+58h+var_58], eax
		call	s_mw_mp_exch
		jmp	loc_100187A0
; ---------------------------------------------------------------------------
		align 10h

loc_100188A0:				; CODE XREF: mw_mp_div+17j
					; mw_mp_div+1Fj
		mov	[esp+58h+var_50], 483h
		mov	[esp+58h+var_54], offset aMpi_c	; "mpi.c"
		mov	[esp+58h+var_58], offset aAVoid0BVoid0 ; "a != ((void *)0) && b	!= ((void *)0)"
		call	_assert
mw_mp_div	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 415. mw_mp_mod

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_mod
mw_mp_mod	proc near		; CODE XREF: mw_mp_submod+74j
					; mw_mp_addmod+74j ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_C], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_8]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_100188E4
		test	edi, edi
		jz	short loc_100188E4
		test	esi, esi
		jnz	short loc_10018900

loc_100188E4:				; CODE XREF: mw_mp_mod+1Aj
					; mw_mp_mod+1Ej
		mov	[esp+28h+var_20], 554h
		mov	[esp+28h+var_24], offset aMpi_c	; "mpi.c"
		mov	[esp+28h+var_28], offset aAVoid0MVoid0CV ; "a != ((void	*)0) &&	m != ((void *)0) &&"...
		call	_assert
; ---------------------------------------------------------------------------

loc_10018900:				; CODE XREF: mw_mp_mod+22j
		mov	[ebp+var_10], 0FFFFFFFDh
		cmp	byte ptr [edi],	1
		jz	short loc_10018970
		mov	[esp+28h+var_24], edi
		mov	[esp+28h+var_28], ebx
		call	s_mw_mp_cmp
		cmp	eax, 0
		jle	short loc_10018980
		mov	[esp+28h+var_1C], esi
		mov	[esp+28h+var_20], 0
		mov	[esp+28h+var_24], edi
		mov	[esp+28h+var_28], ebx
		call	mw_mp_div
		test	eax, eax
		mov	[ebp+var_10], eax
		jnz	short loc_10018970
		cmp	byte ptr [esi],	1
		jnz	short loc_10018970

loc_10018941:				; CODE XREF: mw_mp_mod+E1j
		mov	[ebp+arg_8], esi
		mov	ebx, [ebp+var_C]
		mov	[ebp+arg_4], edi
		mov	edi, [ebp+var_4]
		mov	[ebp+arg_0], esi
		mov	esi, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		jmp	mw_mp_add
; ---------------------------------------------------------------------------

loc_1001895B:				; CODE XREF: mw_mp_mod:loc_10018980j
		mov	[esp+28h+var_28], esi
		call	mw_mp_zero
		mov	[ebp+var_10], 0
		lea	esi, [esi+0]

loc_10018970:				; CODE XREF: mw_mp_mod+4Aj
					; mw_mp_mod+7Aj ...
		mov	eax, [ebp+var_10]
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10018980:				; CODE XREF: mw_mp_mod+5Bj
		jz	short loc_1001895B
		mov	[esp+28h+var_24], esi
		mov	[esp+28h+var_28], ebx
		call	mw_mp_copy
		test	eax, eax
		mov	[ebp+var_10], eax
		jnz	short loc_10018970
		mov	[esp+28h+var_28], ebx
		call	mw_mp_cmw_mp_z
		test	eax, eax
		jns	short loc_10018970
		jmp	short loc_10018941
mw_mp_mod	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 437. mw_mp_submod

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_submod
mw_mp_submod	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	edx, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_4], esi
		mov	ebx, [ebp+arg_C]
		mov	esi, [ebp+arg_8]
		test	edx, edx
		jz	short loc_100189F6
		test	eax, eax
		jz	short loc_100189F6
		test	esi, esi
		jz	short loc_100189F6
		test	ebx, ebx
		jz	short loc_100189F6
		mov	[esp+18h+var_10], ebx
		mov	[esp+18h+var_14], eax
		mov	[esp+18h+var_18], edx
		call	mw_mp_sub
		test	eax, eax
		jz	short loc_10018A12
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100189F6:				; CODE XREF: mw_mp_submod+1Aj
					; mw_mp_submod+1Ej ...
		mov	[esp+18h+var_10], 61Dh
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aAVoid0BVoid0MV ; "a != ((void	*)0) &&	b != ((void *)0) &&"...
		call	_assert
; ---------------------------------------------------------------------------

loc_10018A12:				; CODE XREF: mw_mp_submod+3Aj
		mov	[ebp+arg_8], ebx
		mov	[ebp+arg_4], esi
		mov	esi, [ebp+var_4]
		mov	[ebp+arg_0], ebx
		mov	ebx, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		jmp	mw_mp_mod
mw_mp_submod	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 385. mw_mp_addmod

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_addmod
mw_mp_addmod	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	edx, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_4], esi
		mov	ebx, [ebp+arg_C]
		mov	esi, [ebp+arg_8]
		test	edx, edx
		jz	short loc_10018A76
		test	eax, eax
		jz	short loc_10018A76
		test	esi, esi
		jz	short loc_10018A76
		test	ebx, ebx
		jz	short loc_10018A76
		mov	[esp+18h+var_10], ebx
		mov	[esp+18h+var_14], eax
		mov	[esp+18h+var_18], edx
		call	mw_mp_add
		test	eax, eax
		jz	short loc_10018A92
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10018A76:				; CODE XREF: mw_mp_addmod+1Aj
					; mw_mp_addmod+1Ej ...
		mov	[esp+18h+var_10], 604h
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aAVoid0BVoid0MV ; "a != ((void	*)0) &&	b != ((void *)0) &&"...
		call	_assert
; ---------------------------------------------------------------------------

loc_10018A92:				; CODE XREF: mw_mp_addmod+3Aj
		mov	[ebp+arg_8], ebx
		mov	[ebp+arg_4], esi
		mov	esi, [ebp+var_4]
		mov	[ebp+arg_0], ebx
		mov	ebx, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		jmp	mw_mp_mod
mw_mp_addmod	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 470. s_mw_mp_sqr

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_sqr
s_mw_mp_sqr	proc near		; CODE XREF: mw_mp_sqr+33p
					; mw_mp_exptmod_d+D6p ...

var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 4Ch
		mov	eax, [ebp+arg_0]
		lea	edx, [ebp+var_1C]
		mov	eax, [eax+8]
		mov	[esp+58h+var_58], edx ;	int
		mov	ebx, eax
		add	ebx, ebx
		mov	[ebp+var_30], eax
		mov	[esp+58h+var_54], ebx ;	size_t
		call	mw_mp_init_size
		test	eax, eax
		mov	[ebp+var_3C], eax
		jnz	loc_10018C29
		mov	[ebp+var_14], ebx
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebp+var_30]
		mov	ecx, [ebp+var_10]
		mov	ebx, [ebx+0Ch]
		test	eax, eax
		mov	[ebp+var_40], ecx
		mov	[ebp+var_44], ebx
		jz	loc_10018C01
		add	ebx, 2
		add	ecx, 2
		mov	[ebp+var_28], ebx
		mov	[ebp+var_20], 1
		mov	[ebp+var_24], 0
		mov	[ebp+var_48], ecx

loc_10018B17:				; CODE XREF: s_mw_mp_sqr+14Cj
		mov	eax, [ebp+var_20]
		mov	edx, [ebp+var_28]
		sub	eax, 1
		mov	[ebp+var_38], eax
		movzx	eax, word ptr [edx-2]
		test	ax, ax
		jz	loc_10018BE3
		mov	ecx, [ebp+var_40]
		movzx	eax, ax
		mov	ebx, [ebp+var_24]
		imul	eax, eax
		movzx	edx, word ptr [ecx+ebx]
		add	edx, eax
		mov	eax, [ebp+var_20]
		mov	esi, edx
		shr	esi, 10h
		cmp	[ebp+var_30], eax
		mov	[ecx+eax*4-4], dx
		mov	[ebp+var_34], eax
		jbe	short loc_10018BAD
		mov	ecx, [ebp+var_44]
		mov	edi, [ebp+var_48]
		add	edi, [ebp+var_24]
		lea	ebx, [ecx+eax*2]

loc_10018B63:				; CODE XREF: s_mw_mp_sqr+FBj
		mov	ecx, [ebp+var_28]
		movzx	edx, word ptr [ebx]
		movzx	eax, word ptr [ecx-2]
		imul	edx, eax
		mov	eax, edx
		add	edx, edx
		shr	eax, 1Fh
		mov	[ebp+var_2C], eax
		movzx	eax, word ptr [edi]
		lea	eax, [esi+eax]
		lea	ecx, [eax+edx]
		not	eax
		cmp	eax, edx
		setb	al
		add	ebx, 2
		movzx	esi, al
		or	esi, [ebp+var_2C]
		add	[ebp+var_34], 1
		mov	edx, [ebp+var_34]
		mov	[edi], cx
		shl	esi, 10h
		add	edi, 2
		shr	ecx, 10h
		or	esi, ecx
		cmp	[ebp+var_30], edx
		ja	short loc_10018B63

loc_10018BAD:				; CODE XREF: s_mw_mp_sqr+A5j
		mov	ecx, [ebp+var_34]
		add	ecx, [ebp+var_38]
		mov	ebx, [ebp+var_40]
		lea	edx, [ecx+ecx]
		movzx	eax, word ptr [ebx+edx]
		add	eax, esi
		mov	[ebx+edx], ax
		shr	eax, 10h
		test	eax, eax
		jz	short loc_10018BE3
		lea	edx, [ebx+ecx*2+2]
		xchg	ax, ax

loc_10018BD0:				; CODE XREF: s_mw_mp_sqr+131j
		movzx	eax, word ptr [edx]
		add	eax, 1
		mov	[edx], ax
		shr	eax, 10h
		add	edx, 2
		test	eax, eax
		jnz	short loc_10018BD0

loc_10018BE3:				; CODE XREF: s_mw_mp_sqr+7Aj
					; s_mw_mp_sqr+118j
		mov	eax, [ebp+var_20]
		mov	edx, [ebp+var_20]
		add	[ebp+var_28], 2
		add	[ebp+var_24], 4
		add	eax, 1
		cmp	[ebp+var_30], edx
		jbe	short loc_10018C01
		mov	[ebp+var_20], eax
		jmp	loc_10018B17
; ---------------------------------------------------------------------------

loc_10018C01:				; CODE XREF: s_mw_mp_sqr+47j
					; s_mw_mp_sqr+147j
		lea	ecx, [ebp+var_1C]
		mov	[esp+58h+var_58], ecx
		call	s_mw_mp_clamp
		mov	ebx, [ebp+arg_0]
		lea	eax, [ebp+var_1C]
		mov	[esp+58h+var_58], eax
		mov	[esp+58h+var_54], ebx
		call	s_mw_mp_exch
		lea	edx, [ebp+var_1C]
		mov	[esp+58h+var_58], edx
		call	mw_mp_clear

loc_10018C29:				; CODE XREF: s_mw_mp_sqr+2Aj
		mov	eax, [ebp+var_3C]
		add	esp, 4Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
s_mw_mp_sqr	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 431. mw_mp_sqr

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_sqr
mw_mp_sqr	proc near		; CODE XREF: mw_mp_sqrmod+28p
					; mw_mp_sqrt+CAp

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+arg_0]
		mov	ebx, [ebp+arg_4]
		test	eax, eax
		jz	short loc_10018C85
		test	ebx, ebx
		jz	short loc_10018C85
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+var_18], eax
		call	mw_mp_copy
		test	eax, eax
		jz	short loc_10018C70

loc_10018C65:				; CODE XREF: mw_mp_sqr+3Aj
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10018C70:				; CODE XREF: mw_mp_sqr+23j
		mov	[esp+18h+var_18], ebx
		call	s_mw_mp_sqr
		test	eax, eax
		jnz	short loc_10018C65
		mov	byte ptr [ebx],	0
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10018C85:				; CODE XREF: mw_mp_sqr+Fj
					; mw_mp_sqr+13j
		mov	[esp+18h+var_10], 460h
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aAVoid0BVoid0 ; "a != ((void *)0) && b	!= ((void *)0)"
		call	_assert
mw_mp_sqr	endp

; ---------------------------------------------------------------------------
		jmp	short mw_mp_sqrmod
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 432. mw_mp_sqrmod

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_sqrmod
mw_mp_sqrmod	proc near		; CODE XREF: .text:10018CA1j

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		mov	ebx, [ebp+arg_8]
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_4]
		test	eax, eax
		jz	short loc_10018D07
		test	esi, esi
		jz	short loc_10018D07
		test	ebx, ebx
		jz	short loc_10018D07
		mov	[esp+18h+var_14], ebx
		mov	[esp+18h+var_18], eax
		call	mw_mp_sqr
		test	eax, eax
		jz	short loc_10018CF0
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10018CF0:				; CODE XREF: mw_mp_sqrmod+2Fj
		mov	[ebp+arg_8], ebx
		mov	[ebp+arg_4], esi
		mov	esi, [ebp+var_4]
		mov	[ebp+arg_0], ebx
		mov	ebx, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		jmp	mw_mp_mod
; ---------------------------------------------------------------------------

loc_10018D07:				; CODE XREF: mw_mp_sqrmod+17j
					; mw_mp_sqrmod+1Bj ...
		mov	[esp+18h+var_10], 64Ah
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aAVoid0MVoid0CV ; "a != ((void	*)0) &&	m != ((void *)0) &&"...
		call	_assert
mw_mp_sqrmod	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 461. s_mw_mp_mul

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_mul
s_mw_mp_mul	proc near		; CODE XREF: s_mw_mp_reduce+64p
					; s_mw_mp_reduce+8Ep ...

var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 3Ch
		mov	esi, [ebp+arg_4]
		mov	eax, [ebp+arg_0]
		lea	ecx, [ebp+var_1C]
		mov	edx, [esi+8]
		mov	eax, [eax+8]
		mov	[esp+48h+var_48], ecx ;	int
		mov	ebx, edx
		add	ebx, eax
		mov	[ebp+var_2C], eax
		mov	[ebp+var_28], edx
		mov	[esp+48h+var_44], ebx ;	size_t
		call	mw_mp_init_size
		test	eax, eax
		mov	[ebp+var_34], eax
		jnz	loc_10018E34
		mov	esi, [esi+0Ch]
		mov	eax, [ebp+var_10]
		mov	[ebp+var_14], ebx
		mov	[ebp+var_24], esi
		mov	esi, [ebp+var_28]
		mov	[ebp+var_20], eax
		test	esi, esi
		jz	loc_10018E0C
		mov	[ebp+var_30], 0
		lea	esi, [esi+0]

loc_10018D90:				; CODE XREF: s_mw_mp_mul+DAj
		mov	ecx, [ebp+var_24]
		movzx	edx, word ptr [ecx]
		test	dx, dx
		jz	short loc_10018DFA
		mov	eax, [ebp+arg_0]
		xor	ecx, ecx
		mov	ebx, [ebp+var_2C]
		mov	esi, [eax+0Ch]
		xor	eax, eax
		test	ebx, ebx
		jz	short loc_10018DF0
		mov	ecx, [ebp+var_30]
		xor	edi, edi
		mov	eax, [ebp+var_20]
		lea	ebx, [eax+ecx*2]
		xor	ecx, ecx
		jmp	short loc_10018DC6
; ---------------------------------------------------------------------------
		align 10h

loc_10018DC0:				; CODE XREF: s_mw_mp_mul+BBj
		mov	eax, [ebp+var_24]
		movzx	edx, word ptr [eax]

loc_10018DC6:				; CODE XREF: s_mw_mp_mul+89j
		movzx	eax, word ptr [ebx]
		movzx	edx, dx
		add	edi, 1
		lea	eax, [ecx+eax]
		movzx	ecx, word ptr [esi]
		add	esi, 2
		imul	edx, ecx
		add	eax, edx
		mov	ecx, eax
		mov	[ebx], ax
		shr	ecx, 10h
		add	ebx, 2
		cmp	edi, [ebp+var_2C]
		jnz	short loc_10018DC0
		mov	eax, [ebp+var_2C]

loc_10018DF0:				; CODE XREF: s_mw_mp_mul+7Aj
		mov	edx, [ebp+var_20]
		add	eax, [ebp+var_30]
		mov	[edx+eax*2], cx

loc_10018DFA:				; CODE XREF: s_mw_mp_mul+69j
		add	[ebp+var_30], 1
		mov	ecx, [ebp+var_28]
		cmp	[ebp+var_30], ecx
		jz	short loc_10018E0C
		add	[ebp+var_24], 2
		jmp	short loc_10018D90
; ---------------------------------------------------------------------------

loc_10018E0C:				; CODE XREF: s_mw_mp_mul+4Dj
					; s_mw_mp_mul+D4j
		lea	eax, [ebp+var_1C]
		mov	[esp+48h+var_48], eax
		call	s_mw_mp_clamp
		mov	edx, [ebp+arg_0]
		lea	ecx, [ebp+var_1C]
		mov	[esp+48h+var_48], ecx
		mov	[esp+48h+var_44], edx
		call	s_mw_mp_exch
		lea	eax, [ebp+var_1C]
		mov	[esp+48h+var_48], eax
		call	mw_mp_clear

loc_10018E34:				; CODE XREF: s_mw_mp_mul+33j
		mov	eax, [ebp+var_34]
		add	esp, 3Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
s_mw_mp_mul	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 468. s_mw_mp_reduce

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_reduce
s_mw_mp_reduce	proc near		; CODE XREF: mw_mp_exptmod+17Bp
					; mw_mp_exptmod+1A7p ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= byte ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		mov	[ebp+var_4], edi
		lea	edi, [ebp+var_1C]
		mov	[ebp+var_8], esi
		mov	esi, [eax+8]
		mov	eax, [ebp+arg_0]
		mov	[esp+28h+var_28], edi
		mov	[esp+28h+var_24], eax
		call	mw_mp_init_copy
		test	eax, eax
		mov	ebx, eax
		jz	short loc_10018E80

loc_10018E6D:				; CODE XREF: s_mw_mp_reduce+C0j
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10018E80:				; CODE XREF: s_mw_mp_reduce+2Bj
		lea	eax, [esi-1]
		add	esi, 1
		mov	[esp+28h+var_24], eax
		mov	ebx, esi
		mov	[esp+28h+var_28], edi
		shl	ebx, 4
		call	s_mw_mp_rshd
		mov	eax, [ebp+arg_8]
		movzx	ebx, bx
		mov	[esp+28h+var_28], edi
		mov	[esp+28h+var_24], eax
		call	s_mw_mp_mul
		mov	[esp+28h+var_24], esi
		mov	[esp+28h+var_28], edi
		call	s_mw_mp_rshd
		mov	eax, [ebp+arg_0]
		mov	[esp+28h+var_24], ebx
		mov	[esp+28h+var_28], eax
		call	s_mw_mp_mod_2d
		mov	eax, [ebp+arg_4]
		mov	[esp+28h+var_28], edi
		mov	[esp+28h+var_24], eax
		call	s_mw_mp_mul
		mov	[esp+28h+var_24], ebx
		mov	[esp+28h+var_28], edi
		call	s_mw_mp_mod_2d
		mov	eax, [ebp+arg_0]
		mov	[esp+28h+var_24], edi
		mov	[esp+28h+var_20], eax
		mov	[esp+28h+var_28], eax
		call	mw_mp_sub
		test	eax, eax
		mov	ebx, eax
		jz	short loc_10018F05

loc_10018EF8:				; CODE XREF: s_mw_mp_reduce+E8j
					; s_mw_mp_reduce+102j ...
		mov	[esp+28h+var_28], edi
		call	mw_mp_clear
		jmp	loc_10018E6D
; ---------------------------------------------------------------------------

loc_10018F05:				; CODE XREF: s_mw_mp_reduce+B6j
		mov	eax, [ebp+arg_0]
		mov	[esp+28h+var_28], eax
		call	mw_mp_cmw_mp_z
		test	eax, eax
		js	short loc_10018F44

loc_10018F14:				; CODE XREF: s_mw_mp_reduce+100j
					; s_mw_mp_reduce+13Dj
		mov	eax, [ebp+arg_4]
		mov	[esp+28h+var_24], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+28h+var_28], eax
		call	mw_mp_cmp
		test	eax, eax
		js	short loc_10018EF8
		mov	eax, [ebp+arg_4]
		mov	[esp+28h+var_24], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+28h+var_28], eax
		call	s_mw_mp_sub
		test	eax, eax
		mov	ebx, eax
		jz	short loc_10018F14
		jmp	short loc_10018EF8
; ---------------------------------------------------------------------------

loc_10018F44:				; CODE XREF: s_mw_mp_reduce+D2j
		mov	[esp+28h+var_24], 1
		mov	[esp+28h+var_28], edi
		call	mw_mp_set
		mov	[esp+28h+var_24], esi
		mov	[esp+28h+var_28], edi
		call	s_mw_mp_lshd
		test	eax, eax
		jz	short loc_10018F68
		mov	ebx, eax
		jmp	short loc_10018EF8
; ---------------------------------------------------------------------------

loc_10018F68:				; CODE XREF: s_mw_mp_reduce+122j
		mov	eax, [ebp+arg_0]
		mov	[esp+28h+var_24], edi
		mov	[esp+28h+var_20], eax
		mov	[esp+28h+var_28], eax
		call	mw_mp_add
		test	eax, eax
		jz	short loc_10018F14
		mov	ebx, eax
		jmp	loc_10018EF8
s_mw_mp_reduce	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 417. mw_mp_mul

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_mul
mw_mp_mul	proc near		; CODE XREF: mw_mp_mulmod+33p
					; mw_mp_xgcd+4A3p ...

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_D		= byte ptr -0Dh
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_C], ebx
		mov	ebx, [ebp+arg_4]
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_8]
		mov	[ebp+var_4], edi
		test	eax, eax
		jz	short loc_10019001
		test	ebx, ebx
		jz	short loc_10019001
		test	esi, esi
		jz	short loc_10019001
		movzx	edx, byte ptr [eax]
		cmp	esi, ebx
		mov	[ebp+var_D], dl
		movzx	edi, byte ptr [ebx]
		jz	short loc_10019020
		mov	[esp+28h+var_24], esi
		mov	[esp+28h+var_28], eax
		call	mw_mp_copy
		test	eax, eax
		jz	short loc_10018FE0

loc_10018FD1:				; CODE XREF: mw_mp_mul+5Ej
					; mw_mp_mul+6Fj ...
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10018FE0:				; CODE XREF: mw_mp_mul+3Fj
		mov	[esp+28h+var_24], ebx
		mov	[esp+28h+var_28], esi
		call	s_mw_mp_mul
		test	eax, eax
		jnz	short loc_10018FD1

loc_10018FF0:				; CODE XREF: mw_mp_mul+9Ej
		mov	eax, edi
		cmp	[ebp+var_D], al
		setnz	bl
		jnz	short loc_10019032

loc_10018FFA:				; CODE XREF: mw_mp_mul+B4j
		xor	eax, eax
		mov	byte ptr [esi],	0
		jmp	short loc_10018FD1
; ---------------------------------------------------------------------------

loc_10019001:				; CODE XREF: mw_mp_mul+1Aj
					; mw_mp_mul+1Ej ...
		mov	[esp+28h+var_20], 424h
		mov	[esp+28h+var_24], offset aMpi_c	; "mpi.c"
		mov	[esp+28h+var_28], offset aAVoid0BVoid0CV ; "a != ((void	*)0) &&	b != ((void *)0) &&"...
		call	_assert
; ---------------------------------------------------------------------------
		align 10h

loc_10019020:				; CODE XREF: mw_mp_mul+2Fj
		mov	[esp+28h+var_24], eax
		mov	[esp+28h+var_28], esi
		call	s_mw_mp_mul
		test	eax, eax
		jz	short loc_10018FF0
		jmp	short loc_10018FD1
; ---------------------------------------------------------------------------

loc_10019032:				; CODE XREF: mw_mp_mul+68j
		mov	[esp+28h+var_24], 0
		mov	[esp+28h+var_28], esi
		call	s_mw_mp_cmw_mp_d
		test	eax, eax
		jz	short loc_10018FFA
		xor	eax, eax
		mov	[esi], bl
		jmp	short loc_10018FD1
mw_mp_mul	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 421. mw_mp_mulmod

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_mulmod
mw_mp_mulmod	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	edx, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_4], esi
		mov	ebx, [ebp+arg_C]
		mov	esi, [ebp+arg_8]
		test	edx, edx
		jz	short loc_10019096
		test	eax, eax
		jz	short loc_10019096
		test	esi, esi
		jz	short loc_10019096
		test	ebx, ebx
		jz	short loc_10019096
		mov	[esp+18h+var_10], ebx
		mov	[esp+18h+var_14], eax
		mov	[esp+18h+var_18], edx
		call	mw_mp_mul
		test	eax, eax
		jz	short loc_100190B2
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10019096:				; CODE XREF: mw_mp_mulmod+1Aj
					; mw_mp_mulmod+1Ej ...
		mov	[esp+18h+var_10], 636h
		mov	[esp+18h+var_14], offset aMpi_c	; "mpi.c"
		mov	[esp+18h+var_18], offset aAVoid0BVoid0MV ; "a != ((void	*)0) &&	b != ((void *)0) &&"...
		call	_assert
; ---------------------------------------------------------------------------

loc_100190B2:				; CODE XREF: mw_mp_mulmod+3Aj
		mov	[ebp+arg_8], ebx
		mov	[ebp+arg_4], esi
		mov	esi, [ebp+var_4]
		mov	[ebp+arg_0], ebx
		mov	ebx, [ebp+var_8]
		mov	esp, ebp
		pop	ebp
		jmp	mw_mp_mod
mw_mp_mulmod	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 454. s_mw_mp_div_d

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public s_mw_mp_div_d
s_mw_mp_div_d	proc near		; CODE XREF: mw_mp_toradix+93p
					; mw_mp_div_d+CCp ...

var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 2Ch
		mov	eax, [ebp+arg_0]
		movzx	esi, [ebp+arg_4]
		mov	[ebp+var_24], 0FFFFFFFDh
		mov	eax, [eax+0Ch]
		test	si, si
		mov	[ebp+var_20], eax
		jnz	short loc_10019100

loc_100190F2:				; CODE XREF: s_mw_mp_div_d+4Aj
		mov	eax, [ebp+var_24]
		add	esp, 2Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_10019100:				; CODE XREF: s_mw_mp_div_d+20j
		mov	edx, [ebp+arg_0]
		lea	edi, [ebp+var_1C]
		mov	eax, [edx+8]
		mov	[esp+38h+var_38], edi ;	int
		mov	[esp+38h+var_34], eax ;	size_t
		call	mw_mp_init_size
		test	eax, eax
		mov	[ebp+var_24], eax
		jnz	short loc_100190F2
		mov	edx, [ebp+arg_0]
		xor	edi, edi
		mov	eax, [edx+8]
		mov	edx, [ebp+var_10]
		mov	ebx, eax
		sub	ebx, 1
		mov	[ebp+var_14], eax
		js	short loc_1001916F
		mov	edi, [ebp+var_20]
		add	eax, eax
		movzx	esi, si
		add	edx, eax
		mov	[ebp+var_28], edx
		lea	ecx, [eax+edi]
		xor	edi, edi

loc_10019143:				; CODE XREF: s_mw_mp_div_d+9Dj
		movzx	eax, word ptr [ecx-2]
		shl	edi, 10h
		or	edi, eax
		xor	eax, eax
		cmp	edi, esi
		jb	short loc_1001915A
		mov	eax, edi
		xor	edx, edx
		div	esi
		mov	edi, edx

loc_1001915A:				; CODE XREF: s_mw_mp_div_d+80j
		mov	edx, [ebp+var_28]
		sub	ecx, 2
		mov	[edx-2], ax
		sub	edx, 2
		sub	ebx, 1
		mov	[ebp+var_28], edx
		jns	short loc_10019143

loc_1001916F:				; CODE XREF: s_mw_mp_div_d+5Fj
		mov	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_1001917C
		mov	eax, [ebp+arg_8]
		mov	[eax], di

loc_1001917C:				; CODE XREF: s_mw_mp_div_d+A4j
		lea	edx, [ebp+var_1C]
		mov	[esp+38h+var_38], edx
		call	s_mw_mp_clamp
		mov	edi, [ebp+arg_0]
		lea	eax, [ebp+var_1C]
		mov	[esp+38h+var_38], eax
		mov	[esp+38h+var_34], edi
		call	mw_mp_exch
		lea	edx, [ebp+var_1C]
		mov	[esp+38h+var_38], edx
		call	mw_mp_clear
		mov	eax, [ebp+var_24]
		add	esp, 2Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
s_mw_mp_div_d	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 440. mw_mp_toradix

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_toradix
mw_mp_toradix	proc near

var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_34		= dword	ptr -34h
var_2D		= byte ptr -2Dh
var_20		= byte ptr -20h
var_E		= word ptr -0Eh
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 3Ch
		mov	ebx, [ebp+arg_0]
		test	ebx, ebx
		jz	loc_10019317
		mov	eax, [ebp+arg_4]
		test	eax, eax
		jz	loc_10019317
		mov	eax, [ebp+arg_8]
		sub	eax, 2
		cmp	eax, 3Eh
		ja	loc_100192FB
		mov	[esp+48h+var_48], ebx
		call	mw_mp_cmw_mp_z
		test	eax, eax
		jnz	short loc_10019206
		mov	eax, [ebp+arg_4]
		mov	byte ptr [eax],	30h
		mov	byte ptr [eax+1], 0
		mov	[ebp+var_34], 0

loc_100191FB:				; CODE XREF: mw_mp_toradix+6Ej
					; mw_mp_toradix+13Aj
		mov	eax, [ebp+var_34]
		add	esp, 3Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10019206:				; CODE XREF: mw_mp_toradix+38j
		lea	edx, [ebp+var_20]
		movzx	esi, word ptr [ebp+arg_8]
		mov	[esp+48h+var_44], ebx
		mov	[esp+48h+var_48], edx
		call	mw_mp_init_copy
		test	eax, eax
		mov	[ebp+var_34], eax
		jnz	short loc_100191FB
		movzx	eax, [ebp+var_20]
		xor	edi, edi
		movzx	esi, si
		mov	[ebp+var_20], 0
		mov	[ebp+var_2D], al
		jmp	short loc_10019276
; ---------------------------------------------------------------------------

loc_10019232:				; CODE XREF: mw_mp_toradix+D3j
		lea	edx, [ebp+var_E]
		lea	eax, [ebp+var_20]
		mov	[esp+48h+var_40], edx
		mov	[esp+48h+var_44], esi
		mov	[esp+48h+var_48], eax
		call	s_mw_mp_div_d
		test	eax, eax
		mov	ebx, eax
		jnz	loc_100192DC
		mov	[esp+48h+var_40], 0
		mov	eax, [ebp+arg_8]
		mov	[esp+48h+var_44], eax
		movzx	eax, [ebp+var_E]
		mov	[esp+48h+var_48], eax
		call	s_mw_mp_todigit
		mov	edx, [ebp+arg_4]
		mov	[edi+edx], al
		add	edi, 1

loc_10019276:				; CODE XREF: mw_mp_toradix+80j
		lea	eax, [ebp+var_20]
		mov	[esp+48h+var_48], eax
		call	mw_mp_cmw_mp_z
		test	eax, eax
		jnz	short loc_10019232
		cmp	[ebp+var_2D], 1
		jz	short loc_100192EF

loc_1001928B:				; CODE XREF: mw_mp_toradix+149j
		mov	eax, [ebp+arg_4]
		lea	esi, [edi-1]
		test	esi, esi
		mov	byte ptr [edi+eax], 0
		jle	short loc_100192C6
		lea	ecx, [edi+eax]
		mov	ebx, 1

loc_100192A1:				; CODE XREF: mw_mp_toradix+114j
		mov	edx, [ebp+arg_4]
		sub	esi, 1
		mov	edi, [ebp+arg_4]
		movzx	eax, byte ptr [ebx+edx-1]
		movzx	edx, byte ptr [ecx-1]
		mov	[ebx+edi-1], dl
		mov	[ecx-1], al
		mov	eax, ebx
		sub	ecx, 1
		add	ebx, 1
		cmp	esi, eax
		jg	short loc_100192A1

loc_100192C6:				; CODE XREF: mw_mp_toradix+E7j
		lea	eax, [ebp+var_20]
		mov	[esp+48h+var_48], eax
		call	mw_mp_clear
		mov	eax, [ebp+var_34]
		add	esp, 3Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100192DC:				; CODE XREF: mw_mp_toradix+9Cj
		lea	edx, [ebp+var_20]
		mov	[esp+48h+var_48], edx
		call	mw_mp_clear
		mov	[ebp+var_34], ebx
		jmp	loc_100191FB
; ---------------------------------------------------------------------------

loc_100192EF:				; CODE XREF: mw_mp_toradix+D9j
		mov	edx, [ebp+arg_4]
		mov	byte ptr [edi+edx], 2Dh
		add	edi, 1
		jmp	short loc_1001928B
; ---------------------------------------------------------------------------

loc_100192FB:				; CODE XREF: mw_mp_toradix+28j
		mov	[esp+48h+var_40], 9FFh
		mov	[esp+48h+var_44], offset aMpi_c	; "mpi.c"
		mov	[esp+48h+var_48], offset aRadix1Radix64	; "radix > 1 &&	radix <= 64"
		call	_assert
; ---------------------------------------------------------------------------

loc_10019317:				; CODE XREF: mw_mp_toradix+Ej
					; mw_mp_toradix+19j
		mov	[esp+48h+var_40], 9FEh
		mov	[esp+48h+var_44], offset aMpi_c	; "mpi.c"
		mov	[esp+48h+var_48], offset aMpVoid0StrVo_0 ; "mp != ((void *)0) && str !=	((void *)0)"
		call	_assert
mw_mp_toradix	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 399. mw_mp_div_d

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_div_d
mw_mp_div_d	proc near		; CODE XREF: mw_mp_mod_d+4Ap

var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_20		= byte ptr -20h
var_E		= word ptr -0Eh
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_C], ebx
		movzx	eax, [ebp+arg_4]
		mov	[ebp+var_4], edi
		test	esi, esi
		jz	loc_100194A0
		test	ax, ax
		mov	ebx, 0FFFFFFFDh
		jnz	short loc_10019377

loc_10019368:				; CODE XREF: mw_mp_div_d+8Dj
					; mw_mp_div_d+99j ...
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10019377:				; CODE XREF: mw_mp_div_d+26j
		movzx	edi, ax
		mov	[esp+38h+var_38], edi
		call	s_mw_mp_ispow2d
		test	eax, eax
		mov	ebx, eax
		js	short loc_100193DB
		mov	edx, [esi+0Ch]
		mov	eax, 1
		mov	ecx, ebx
		shl	eax, cl
		sub	eax, 1
		and	ax, [edx]
		mov	[ebp+var_E], ax
		mov	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_100193C6
		mov	eax, [ebp+arg_8]
		mov	[esp+38h+var_38], esi
		mov	[esp+38h+var_34], eax
		call	mw_mp_copy
		mov	edx, [ebp+arg_8]
		movzx	eax, bx
		mov	[esp+38h+var_34], eax
		mov	[esp+38h+var_38], edx
		call	s_mw_mp_div_2d

loc_100193C6:				; CODE XREF: mw_mp_div_d+63j
		mov	eax, [ebp+arg_C]
		xor	ebx, ebx
		test	eax, eax
		jz	short loc_10019368
		movzx	eax, [ebp+var_E]
		mov	ecx, [ebp+arg_C]
		mov	[ecx], ax
		jmp	short loc_10019368
; ---------------------------------------------------------------------------

loc_100193DB:				; CODE XREF: mw_mp_div_d+46j
		mov	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_1001944A
		mov	eax, [ebp+arg_8]
		mov	[esp+38h+var_38], esi
		mov	[esp+38h+var_34], eax
		call	mw_mp_copy
		test	eax, eax
		mov	ebx, eax
		jnz	loc_10019368
		mov	edx, [ebp+arg_8]
		lea	eax, [ebp+var_E]
		mov	[esp+38h+var_30], eax
		mov	[esp+38h+var_34], edi
		mov	[esp+38h+var_38], edx
		call	s_mw_mp_div_d
		mov	ecx, [ebp+arg_8]
		mov	[esp+38h+var_34], 0
		mov	[esp+38h+var_38], ecx
		mov	ebx, eax
		call	s_mw_mp_cmw_mp_d
		test	eax, eax
		jnz	short loc_10019430
		mov	eax, [ebp+arg_8]
		mov	byte ptr [eax],	0

loc_10019430:				; CODE XREF: mw_mp_div_d+E8j
					; mw_mp_div_d+15Ej
		mov	eax, [ebp+arg_C]
		test	eax, eax
		jz	loc_10019368
		movzx	eax, [ebp+var_E]
		mov	edx, [ebp+arg_C]
		mov	[edx], ax
		jmp	loc_10019368
; ---------------------------------------------------------------------------

loc_1001944A:				; CODE XREF: mw_mp_div_d+A0j
		mov	[esp+38h+var_34], esi
		lea	esi, [ebp+var_20]
		mov	[esp+38h+var_38], esi
		call	mw_mp_init_copy
		test	eax, eax
		mov	ebx, eax
		jnz	loc_10019368
		lea	eax, [ebp+var_E]
		mov	[esp+38h+var_30], eax
		mov	[esp+38h+var_34], edi
		mov	[esp+38h+var_38], esi
		call	s_mw_mp_div_d
		mov	[esp+38h+var_34], 0
		mov	[esp+38h+var_38], esi
		mov	ebx, eax
		call	s_mw_mp_cmw_mp_d
		xor	edx, edx
		mov	[esp+38h+var_38], esi
		test	eax, eax
		movzx	eax, [ebp+var_20]
		cmovnz	edx, eax
		mov	[ebp+var_20], dl
		call	mw_mp_clear
		jmp	short loc_10019430
; ---------------------------------------------------------------------------

loc_100194A0:				; CODE XREF: mw_mp_div_d+18j
		mov	[esp+38h+var_30], 29Ch
		mov	[esp+38h+var_34], offset aMpi_c	; "mpi.c"
		mov	[esp+38h+var_38], offset aAVoid0 ; "a != ((void	*)0)"
		call	_assert
mw_mp_div_d	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 416. mw_mp_mod_d

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_mod_d
mw_mp_mod_d	proc near

var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_E		= word ptr -0Eh
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_0]
		mov	[ebp+var_C], ebx
		movzx	ebx, [ebp+arg_4]
		mov	[ebp+var_8], esi
		test	edi, edi
		jz	short loc_10019552
		mov	ecx, [ebp+arg_8]
		test	ecx, ecx
		jz	short loc_10019552
		movzx	esi, bx
		mov	[esp+38h+var_34], esi
		mov	[esp+38h+var_38], edi
		call	s_mw_mp_cmw_mp_d
		test	eax, eax
		jle	short loc_10019535
		lea	eax, [ebp+var_E]
		mov	[esp+38h+var_2C], eax
		mov	[esp+38h+var_30], 0
		mov	[esp+38h+var_34], esi
		mov	[esp+38h+var_38], edi
		call	mw_mp_div_d
		test	eax, eax
		jnz	short loc_10019528

loc_10019513:				; CODE XREF: mw_mp_mod_d+84j
					; mw_mp_mod_d+90j
		mov	edx, [ebp+arg_8]
		xor	eax, eax
		test	edx, edx
		jz	short loc_10019528
		movzx	eax, [ebp+var_E]
		mov	edx, [ebp+arg_8]
		mov	[edx], ax
		xor	eax, eax

loc_10019528:				; CODE XREF: mw_mp_mod_d+51j
					; mw_mp_mod_d+5Aj
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10019535:				; CODE XREF: mw_mp_mod_d+32j
		cmp	byte ptr [edi],	1
		jz	short loc_10019546
		mov	eax, [edi+0Ch]
		movzx	eax, word ptr [eax]
		mov	[ebp+var_E], ax
		jmp	short loc_10019513
; ---------------------------------------------------------------------------

loc_10019546:				; CODE XREF: mw_mp_mod_d+78j
		mov	eax, [edi+0Ch]
		sub	bx, [eax]
		mov	[ebp+var_E], bx
		jmp	short loc_10019513
; ---------------------------------------------------------------------------

loc_10019552:				; CODE XREF: mw_mp_mod_d+18j
					; mw_mp_mod_d+1Fj
		mov	[esp+38h+var_30], 590h
		mov	[esp+38h+var_34], offset aMpi_c	; "mpi.c"
		mov	[esp+38h+var_38], offset aAVoid0CVoid0 ; "a != ((void *)0) && c	!= ((void *)0)"
		call	_assert
mw_mp_mod_d	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 433. mw_mp_sqrt

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_sqrt
mw_mp_sqrt	proc near

var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_2C		= dword	ptr -2Ch
var_1C		= byte ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 48h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		test	esi, esi
		jz	loc_100196E1
		test	edi, edi
		jz	loc_100196E1
		cmp	byte ptr [esi],	1
		mov	ebx, 0FFFFFFFDh
		jz	short loc_100195C1
		mov	[esp+48h+var_44], 0
		mov	[esp+48h+var_48], esi
		call	mw_mp_cmw_mp_d
		test	eax, eax
		jnz	short loc_100195D0

loc_100195B3:				; CODE XREF: mw_mp_sqrt+72j
		mov	[esp+48h+var_44], edi
		mov	[esp+48h+var_48], esi
		call	mw_mp_copy
		mov	ebx, eax

loc_100195C1:				; CODE XREF: mw_mp_sqrt+2Dj
					; mw_mp_sqrt+8Aj ...
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_100195D0:				; CODE XREF: mw_mp_sqrt+41j
		mov	[esp+48h+var_44], 1
		mov	[esp+48h+var_48], esi
		call	mw_mp_cmw_mp_d
		test	eax, eax
		jz	short loc_100195B3
		mov	eax, [esi+8]
		mov	[esp+48h+var_44], eax ;	size_t
		lea	eax, [ebp+var_2C]
		mov	[esp+48h+var_48], eax ;	int
		call	mw_mp_init_size
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_100195C1
		lea	eax, [ebp+var_1C]
		mov	[esp+48h+var_44], esi
		mov	[esp+48h+var_48], eax
		call	mw_mp_init_copy
		test	eax, eax
		mov	ebx, eax
		jz	short loc_1001961E

loc_10019611:				; CODE XREF: mw_mp_sqrt+16Cj
		lea	eax, [ebp+var_2C]
		mov	[esp+48h+var_48], eax
		call	mw_mp_clear
		jmp	short loc_100195C1
; ---------------------------------------------------------------------------

loc_1001961E:				; CODE XREF: mw_mp_sqrt+9Fj
					; mw_mp_sqrt+15Bj
		lea	eax, [ebp+var_2C]
		mov	[esp+48h+var_44], eax
		lea	eax, [ebp+var_1C]
		mov	[esp+48h+var_48], eax
		call	mw_mp_copy
		lea	eax, [ebp+var_2C]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], eax
		call	mw_mp_sqr
		test	eax, eax
		mov	ebx, eax
		jnz	loc_100196D1
		lea	eax, [ebp+var_2C]
		mov	[esp+48h+var_40], eax
		mov	[esp+48h+var_44], esi
		mov	[esp+48h+var_48], eax
		call	mw_mp_sub
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_100196D1
		lea	eax, [ebp+var_1C]
		mov	[esp+48h+var_48], eax
		call	s_mw_mp_mul_2
		lea	eax, [ebp+var_2C]
		mov	[esp+48h+var_40], eax
		lea	eax, [ebp+var_1C]
		mov	[esp+48h+var_44], eax
		lea	eax, [ebp+var_2C]
		mov	[esp+48h+var_3C], 0
		mov	[esp+48h+var_48], eax
		call	mw_mp_div
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_100196D1
		lea	eax, [ebp+var_1C]
		mov	[esp+48h+var_48], eax
		call	s_mw_mp_div_2
		lea	eax, [ebp+var_2C]
		mov	[esp+48h+var_48], eax
		call	mw_mp_cmw_mp_z
		test	eax, eax
		jz	short loc_100196FD
		lea	eax, [ebp+var_1C]
		mov	[esp+48h+var_40], eax
		lea	eax, [ebp+var_2C]
		mov	[esp+48h+var_44], eax
		lea	eax, [ebp+var_1C]
		mov	[esp+48h+var_48], eax
		call	mw_mp_sub
		test	eax, eax
		mov	ebx, eax
		jz	loc_1001961E

loc_100196D1:				; CODE XREF: mw_mp_sqrt+D3j
					; mw_mp_sqrt+F0j ...
		lea	eax, [ebp+var_1C]
		mov	[esp+48h+var_48], eax
		call	mw_mp_clear
		jmp	loc_10019611
; ---------------------------------------------------------------------------

loc_100196E1:				; CODE XREF: mw_mp_sqrt+17j
					; mw_mp_sqrt+1Fj
		mov	[esp+48h+var_40], 5BAh
		mov	[esp+48h+var_44], offset aMpi_c	; "mpi.c"
		mov	[esp+48h+var_48], offset aAVoid0BVoid0 ; "a != ((void *)0) && b	!= ((void *)0)"
		call	_assert
; ---------------------------------------------------------------------------

loc_100196FD:				; CODE XREF: mw_mp_sqrt+13Cj
		lea	eax, [ebp+var_1C]
		mov	[esp+48h+var_40], eax
		mov	[esp+48h+var_44], 1
		mov	[esp+48h+var_48], eax
		call	mw_mp_sub_d
		lea	eax, [ebp+var_1C]
		mov	[esp+48h+var_44], edi
		mov	[esp+48h+var_48], eax
		call	s_mw_mp_exch
		jmp	short loc_100196D1
mw_mp_sqrt	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 407. mw_mp_init

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_init
mw_mp_init	proc near		; CODE XREF: mwMpi_new+18p
					; sub_10003860+Cp ...

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, dword_1001B060
		mov	[esp+8+var_4], eax ; size_t
		mov	eax, [ebp+arg_0]
		mov	[esp+8+var_8], eax ; int
		call	mw_mp_init_size
		leave
		retn
mw_mp_init	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 443. mw_mp_xgcd

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_xgcd
mw_mp_xgcd	proc near		; CODE XREF: mw_mp_invmod+BFp

var_D8		= dword	ptr -0D8h
var_D4		= dword	ptr -0D4h
var_D0		= dword	ptr -0D0h
var_C0		= dword	ptr -0C0h
var_BC		= dword	ptr -0BCh
var_B8		= dword	ptr -0B8h
var_B4		= dword	ptr -0B4h
var_B0		= dword	ptr -0B0h
var_AC		= dword	ptr -0ACh
var_A8		= dword	ptr -0A8h
var_A4		= dword	ptr -0A4h
var_A0		= dword	ptr -0A0h
var_9C		= byte ptr -9Ch
var_8C		= byte ptr -8Ch
var_7C		= byte ptr -7Ch
var_6C		= byte ptr -6Ch
var_5C		= byte ptr -5Ch
var_4C		= byte ptr -4Ch
var_3C		= byte ptr -3Ch
var_2C		= byte ptr -2Ch
var_1C		= byte ptr -1Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	edi
		mov	edi, 0FFFFFFFDh
		push	esi
		push	ebx
		sub	esp, 0CCh
		mov	ebx, [ebp+arg_4]
		mov	[esp+0D8h+var_D8], ebx
		call	mw_mp_cmw_mp_z
		test	eax, eax
		jnz	short loc_1001977D

loc_10019770:				; CODE XREF: mw_mp_xgcd+3Cj
					; mw_mp_xgcd+75j
		add	esp, 0CCh
		mov	eax, edi
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1001977D:				; CODE XREF: mw_mp_xgcd+1Ej
		lea	eax, [ebp+var_4C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_init
		test	eax, eax
		mov	edi, eax
		jnz	short loc_10019770
		lea	eax, [ebp+var_4C]
		xor	esi, esi
		mov	[ebp+var_C0], eax
		lea	eax, [ebp+var_5C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_init
		test	eax, eax
		mov	edi, eax
		jz	short loc_100197C7

loc_100197AA:				; CODE XREF: mw_mp_xgcd+93j
					; mw_mp_xgcd+B1j ...
		lea	ebx, [ebp+esi*4+var_C0]

loc_100197B1:				; CODE XREF: mw_mp_xgcd+73j
		mov	eax, [ebx]
		sub	esi, 1
		sub	ebx, 4
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_clear
		test	esi, esi
		jns	short loc_100197B1
		jmp	short loc_10019770
; ---------------------------------------------------------------------------

loc_100197C7:				; CODE XREF: mw_mp_xgcd+58j
		lea	eax, [ebp+var_5C]
		mov	si, 1
		mov	[ebp+var_BC], eax
		lea	eax, [ebp+var_1C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_init
		test	eax, eax
		mov	edi, eax
		jnz	short loc_100197AA
		lea	eax, [ebp+var_1C]
		mov	si, 2
		mov	[ebp+var_B8], eax
		lea	eax, [ebp+var_6C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_init
		test	eax, eax
		mov	edi, eax
		jnz	short loc_100197AA
		lea	eax, [ebp+var_6C]
		mov	si, 3
		mov	[ebp+var_B4], eax
		lea	eax, [ebp+var_7C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_init
		test	eax, eax
		mov	edi, eax
		jnz	short loc_100197AA
		lea	eax, [ebp+var_7C]
		mov	si, 4
		mov	[ebp+var_B0], eax
		lea	eax, [ebp+var_8C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_init
		test	eax, eax
		mov	edi, eax
		jnz	loc_100197AA
		lea	eax, [ebp+var_8C]
		mov	si, 5
		mov	[ebp+var_AC], eax
		lea	eax, [ebp+var_9C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_init
		test	eax, eax
		mov	edi, eax
		jnz	loc_100197AA
		lea	eax, [ebp+var_9C]
		mov	si, 6
		mov	[ebp+var_A8], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+0D8h+var_D4], eax
		lea	eax, [ebp+var_2C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_init_copy
		test	eax, eax
		mov	edi, eax
		jnz	loc_100197AA
		lea	eax, [ebp+var_2C]
		mov	si, 7
		mov	[ebp+var_A4], eax
		mov	[esp+0D8h+var_D4], eax
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_abs
		mov	[esp+0D8h+var_D4], ebx
		lea	ebx, [ebp+var_3C]
		mov	[esp+0D8h+var_D8], ebx
		call	mw_mp_init_copy
		test	eax, eax
		mov	edi, eax
		jnz	loc_100197AA
		mov	[ebp+var_A0], ebx
		mov	[esp+0D8h+var_D4], ebx
		mov	[esp+0D8h+var_D8], ebx
		call	mw_mp_abs
		lea	eax, [ebp+var_1C]
		mov	[esp+0D8h+var_D4], 1
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_set

loc_100198F1:				; CODE XREF: mw_mp_xgcd+1DEj
		lea	eax, [ebp+var_2C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_iseven
		test	eax, eax
		jz	short loc_1001993A
		mov	[esp+0D8h+var_D8], ebx
		call	mw_mp_iseven
		test	eax, eax
		jz	short loc_1001993A
		lea	eax, [ebp+var_2C]
		mov	[esp+0D8h+var_D8], eax
		call	s_mw_mp_div_2
		mov	[esp+0D8h+var_D8], ebx
		call	s_mw_mp_div_2
		lea	eax, [ebp+var_1C]
		mov	[esp+0D8h+var_D8], eax
		call	s_mw_mp_mul_2
		test	eax, eax
		mov	edi, eax
		jz	short loc_100198F1

loc_10019930:				; CODE XREF: mw_mp_xgcd+28Bj
					; mw_mp_xgcd+2B9j ...
		mov	esi, 8
		jmp	loc_100197AA
; ---------------------------------------------------------------------------

loc_1001993A:				; CODE XREF: mw_mp_xgcd+1AEj
					; mw_mp_xgcd+1BAj
		lea	eax, [ebp+var_4C]
		mov	[esp+0D8h+var_D4], eax
		lea	eax, [ebp+var_2C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_copy
		lea	eax, [ebp+var_5C]
		mov	[esp+0D8h+var_D4], eax
		mov	[esp+0D8h+var_D8], ebx
		call	mw_mp_copy
		lea	eax, [ebp+var_6C]
		mov	[esp+0D8h+var_D8], eax
		mov	[esp+0D8h+var_D4], 1
		call	mw_mp_set
		lea	eax, [ebp+var_9C]
		mov	[esp+0D8h+var_D4], 1
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_set

loc_10019984:				; CODE XREF: mw_mp_xgcd+2CAj
					; mw_mp_xgcd+42Dj ...
		lea	eax, [ebp+var_4C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_iseven
		test	eax, eax
		jz	loc_10019A3B
		lea	eax, [ebp+var_4C]
		mov	[esp+0D8h+var_D8], eax
		call	s_mw_mp_div_2
		lea	eax, [ebp+var_6C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_iseven
		test	eax, eax
		jz	short loc_100199C4
		lea	eax, [ebp+var_7C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_iseven
		test	eax, eax
		jnz	loc_10019C67

loc_100199C4:				; CODE XREF: mw_mp_xgcd+25Fj
		lea	eax, [ebp+var_6C]
		mov	[esp+0D8h+var_D0], eax
		mov	[esp+0D8h+var_D4], ebx
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_add
		test	eax, eax
		mov	edi, eax
		jnz	loc_10019930
		lea	eax, [ebp+var_6C]
		mov	[esp+0D8h+var_D8], eax
		call	s_mw_mp_div_2
		lea	eax, [ebp+var_7C]
		mov	[esp+0D8h+var_D0], eax
		lea	eax, [ebp+var_2C]
		mov	[esp+0D8h+var_D4], eax
		lea	eax, [ebp+var_7C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_sub
		test	eax, eax
		mov	edi, eax
		jnz	loc_10019930
		lea	eax, [ebp+var_7C]
		mov	[esp+0D8h+var_D8], eax
		call	s_mw_mp_div_2
		jmp	loc_10019984
; ---------------------------------------------------------------------------

loc_10019A1F:				; CODE XREF: mw_mp_xgcd+32Bj
		lea	eax, [ebp+var_8C]
		mov	[esp+0D8h+var_D8], eax
		call	s_mw_mp_div_2
		lea	eax, [ebp+var_9C]
		mov	[esp+0D8h+var_D8], eax
		call	s_mw_mp_div_2

loc_10019A3B:				; CODE XREF: mw_mp_xgcd+241j
					; mw_mp_xgcd+392j
		lea	eax, [ebp+var_5C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_iseven
		test	eax, eax
		jz	loc_10019AE7
		lea	eax, [ebp+var_5C]
		mov	[esp+0D8h+var_D8], eax
		call	s_mw_mp_div_2
		lea	eax, [ebp+var_8C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_iseven
		test	eax, eax
		jz	short loc_10019A7D
		lea	eax, [ebp+var_9C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_iseven
		test	eax, eax
		jnz	short loc_10019A1F

loc_10019A7D:				; CODE XREF: mw_mp_xgcd+319j
		lea	eax, [ebp+var_8C]
		mov	[esp+0D8h+var_D0], eax
		mov	[esp+0D8h+var_D4], ebx
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_add
		test	eax, eax
		mov	edi, eax
		jnz	loc_10019930
		lea	eax, [ebp+var_8C]
		mov	[esp+0D8h+var_D8], eax
		call	s_mw_mp_div_2
		lea	eax, [ebp+var_9C]
		mov	[esp+0D8h+var_D0], eax
		lea	eax, [ebp+var_2C]
		mov	[esp+0D8h+var_D4], eax
		lea	eax, [ebp+var_9C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_sub
		test	eax, eax
		mov	edi, eax
		jnz	loc_10019930
		lea	eax, [ebp+var_9C]
		mov	[esp+0D8h+var_D8], eax
		call	s_mw_mp_div_2
		jmp	loc_10019A3B
; ---------------------------------------------------------------------------

loc_10019AE7:				; CODE XREF: mw_mp_xgcd+2F8j
		lea	eax, [ebp+var_5C]
		mov	[esp+0D8h+var_D4], eax
		lea	eax, [ebp+var_4C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_cmp
		test	eax, eax
		js	loc_10019BFF
		lea	eax, [ebp+var_4C]
		mov	[esp+0D8h+var_D0], eax
		lea	eax, [ebp+var_5C]
		mov	[esp+0D8h+var_D4], eax
		lea	eax, [ebp+var_4C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_sub
		test	eax, eax
		mov	edi, eax
		jnz	loc_10019930
		lea	eax, [ebp+var_6C]
		mov	[esp+0D8h+var_D0], eax
		lea	eax, [ebp+var_8C]
		mov	[esp+0D8h+var_D4], eax
		lea	eax, [ebp+var_6C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_sub
		test	eax, eax
		mov	edi, eax
		jnz	loc_10019930
		lea	eax, [ebp+var_7C]
		mov	[esp+0D8h+var_D0], eax
		lea	eax, [ebp+var_9C]
		mov	[esp+0D8h+var_D4], eax
		lea	eax, [ebp+var_7C]

loc_10019B5E:				; CODE XREF: mw_mp_xgcd+512j
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_sub
		test	eax, eax
		mov	edi, eax
		jnz	loc_10019930
		lea	eax, [ebp+var_4C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_cmw_mp_z
		test	eax, eax
		jnz	loc_10019984
		mov	eax, [ebp+arg_C]
		test	eax, eax
		jz	short loc_10019BA9
		mov	eax, [ebp+arg_C]
		mov	[esp+0D8h+var_D4], eax
		lea	eax, [ebp+var_8C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_copy
		test	eax, eax
		mov	edi, eax
		jnz	loc_10019930

loc_10019BA9:				; CODE XREF: mw_mp_xgcd+438j
		mov	esi, [ebp+arg_10]
		test	esi, esi
		jz	short loc_10019BCF
		mov	eax, [ebp+arg_10]
		mov	[esp+0D8h+var_D4], eax
		lea	eax, [ebp+var_9C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_copy
		test	eax, eax
		mov	edi, eax
		jnz	loc_10019930

loc_10019BCF:				; CODE XREF: mw_mp_xgcd+45Ej
		mov	ebx, [ebp+arg_8]
		test	ebx, ebx
		jz	loc_10019930
		mov	eax, [ebp+arg_8]
		mov	esi, 8
		mov	[esp+0D8h+var_D0], eax
		lea	eax, [ebp+var_5C]
		mov	[esp+0D8h+var_D4], eax
		lea	eax, [ebp+var_1C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_mul
		mov	edi, eax
		jmp	loc_100197AA
; ---------------------------------------------------------------------------

loc_10019BFF:				; CODE XREF: mw_mp_xgcd+3ABj
		lea	eax, [ebp+var_5C]
		mov	[esp+0D8h+var_D0], eax
		lea	eax, [ebp+var_4C]
		mov	[esp+0D8h+var_D4], eax
		lea	eax, [ebp+var_5C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_sub
		test	eax, eax
		mov	edi, eax
		jnz	loc_10019930
		lea	eax, [ebp+var_8C]
		mov	[esp+0D8h+var_D0], eax
		lea	eax, [ebp+var_6C]
		mov	[esp+0D8h+var_D4], eax
		lea	eax, [ebp+var_8C]
		mov	[esp+0D8h+var_D8], eax
		call	mw_mp_sub
		test	eax, eax
		mov	edi, eax
		jnz	loc_10019930
		lea	eax, [ebp+var_9C]
		mov	[esp+0D8h+var_D0], eax
		lea	eax, [ebp+var_7C]
		mov	[esp+0D8h+var_D4], eax
		lea	eax, [ebp+var_9C]
		jmp	loc_10019B5E
; ---------------------------------------------------------------------------

loc_10019C67:				; CODE XREF: mw_mp_xgcd+26Ej
		lea	eax, [ebp+var_6C]
		mov	[esp+0D8h+var_D8], eax
		call	s_mw_mp_div_2
		lea	eax, [ebp+var_7C]
		mov	[esp+0D8h+var_D8], eax
		call	s_mw_mp_div_2
		jmp	loc_10019984
mw_mp_xgcd	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 411. mw_mp_invmod

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_invmod
mw_mp_invmod	proc near

var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_2D		= byte ptr -2Dh
var_2C		= byte ptr -2Ch
var_1C		= byte ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 48h
		mov	[ebp+var_C], ebx
		mov	ebx, [ebp+arg_0]
		mov	[ebp+var_8], esi
		mov	[ebp+var_4], edi
		test	ebx, ebx
		jz	short loc_10019CB4
		mov	eax, [ebp+arg_4]
		test	eax, eax
		jz	short loc_10019CB4
		mov	eax, [ebp+arg_8]
		test	eax, eax
		jnz	short loc_10019CD0

loc_10019CB4:				; CODE XREF: mw_mp_invmod+14j
					; mw_mp_invmod+1Bj
		mov	[esp+48h+var_40], 894h
		mov	[esp+48h+var_44], offset aMpi_c	; "mpi.c"
		mov	[esp+48h+var_48], offset aAMC ;	"a && m	&& c"
		call	_assert
; ---------------------------------------------------------------------------

loc_10019CD0:				; CODE XREF: mw_mp_invmod+22j
		mov	[esp+48h+var_48], ebx
		call	mw_mp_cmw_mp_z
		test	eax, eax
		jnz	short loc_10019CF0

loc_10019CDC:				; CODE XREF: mw_mp_invmod+6Dj
		mov	esi, 0FFFFFFFDh

loc_10019CE1:				; CODE XREF: mw_mp_invmod+84j
					; mw_mp_invmod+A0j
		mov	eax, esi
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10019CF0:				; CODE XREF: mw_mp_invmod+4Aj
		mov	eax, [ebp+arg_4]
		mov	[esp+48h+var_48], eax
		call	mw_mp_cmw_mp_z
		test	eax, eax
		jz	short loc_10019CDC
		movzx	edx, byte ptr [ebx]
		lea	edi, [ebp+var_1C]
		mov	[esp+48h+var_48], edi
		mov	[ebp+var_2D], dl
		call	mw_mp_init
		test	eax, eax
		mov	esi, eax
		jnz	short loc_10019CE1
		lea	eax, [ebp+var_2C]
		mov	[esp+48h+var_48], eax
		call	mw_mp_init
		test	eax, eax
		mov	esi, eax
		jz	short loc_10019D32

loc_10019D27:				; CODE XREF: mw_mp_invmod+D5j
		mov	[esp+48h+var_48], edi
		call	mw_mp_clear
		nop
		jmp	short loc_10019CE1
; ---------------------------------------------------------------------------

loc_10019D32:				; CODE XREF: mw_mp_invmod+95j
		mov	eax, [ebp+arg_4]
		lea	edx, [ebp+var_2C]
		mov	[esp+48h+var_38], 0
		mov	[esp+48h+var_3C], edx
		mov	[esp+48h+var_40], edi
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], ebx
		call	mw_mp_xgcd
		test	eax, eax
		mov	esi, eax
		jz	short loc_10019D67

loc_10019D5A:				; CODE XREF: mw_mp_invmod+EEj
					; mw_mp_invmod+114j
		lea	eax, [ebp+var_2C]
		mov	[esp+48h+var_48], eax
		call	mw_mp_clear
		jmp	short loc_10019D27
; ---------------------------------------------------------------------------

loc_10019D67:				; CODE XREF: mw_mp_invmod+C8j
		mov	[esp+48h+var_44], 1
		mov	esi, 0FFFFFFFBh
		mov	[esp+48h+var_48], edi
		call	mw_mp_cmw_mp_d
		test	eax, eax
		jnz	short loc_10019D5A
		mov	edx, [ebp+arg_8]
		mov	eax, [ebp+arg_4]
		mov	[esp+48h+var_40], edx
		lea	edx, [ebp+var_2C]
		mov	[esp+48h+var_48], edx
		mov	[esp+48h+var_44], eax
		call	mw_mp_mod
		mov	edx, [ebp+arg_8]
		mov	esi, eax
		movzx	eax, [ebp+var_2D]
		mov	[edx], al
		jmp	short loc_10019D5A
mw_mp_invmod	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 405. mw_mp_gcd

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_gcd
mw_mp_gcd	proc near		; CODE XREF: mw_mp_lcm+B3p

var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_40		= dword	ptr -40h
var_3C		= byte ptr -3Ch
var_2C		= byte ptr -2Ch
var_1C		= byte ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 58h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		test	esi, esi
		jz	loc_10019E55
		test	edi, edi
		jz	loc_10019E55
		mov	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_10019E55
		mov	[esp+58h+var_58], esi
		call	mw_mp_cmw_mp_z
		test	eax, eax
		jz	loc_10019FE0
		mov	[esp+58h+var_58], edi
		call	mw_mp_cmw_mp_z
		test	eax, eax
		jnz	short loc_10019E22
		mov	eax, [ebp+arg_8]
		mov	[esp+58h+var_58], esi
		mov	[esp+58h+var_54], eax
		call	mw_mp_copy
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_10019E13

loc_10019E0D:				; CODE XREF: mw_mp_gcd+259j
		mov	eax, [ebp+arg_8]
		mov	byte ptr [eax],	0

loc_10019E13:				; CODE XREF: mw_mp_gcd+5Bj
					; mw_mp_gcd+81j ...
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_10019E22:				; CODE XREF: mw_mp_gcd+46j
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_58], eax
		call	mw_mp_init
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_10019E13
		mov	[esp+58h+var_54], esi
		lea	esi, [ebp+var_1C]
		mov	[esp+58h+var_58], esi
		call	mw_mp_init_copy
		test	eax, eax
		mov	ebx, eax
		jz	short loc_10019E71

loc_10019E48:				; CODE XREF: mw_mp_gcd+1F9j
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_58], eax
		call	mw_mp_clear
		jmp	short loc_10019E13
; ---------------------------------------------------------------------------

loc_10019E55:				; CODE XREF: mw_mp_gcd+17j
					; mw_mp_gcd+1Fj ...
		mov	[esp+58h+var_50], 788h
		mov	[esp+58h+var_54], offset aMpi_c	; "mpi.c"
		mov	[esp+58h+var_58], offset aAVoid0BVoid0CV ; "a != ((void	*)0) &&	b != ((void *)0) &&"...
		call	_assert
; ---------------------------------------------------------------------------

loc_10019E71:				; CODE XREF: mw_mp_gcd+96j
		mov	[esp+58h+var_54], edi
		lea	edi, [ebp+var_2C]
		mov	[esp+58h+var_58], edi
		call	mw_mp_init_copy
		test	eax, eax
		mov	ebx, eax
		jnz	loc_10019FA1
		mov	[ebp+var_1C], 0
		mov	[ebp+var_2C], 0
		mov	[ebp+var_40], 0
		jmp	short loc_10019EC0
; ---------------------------------------------------------------------------
		align 10h

loc_10019EA0:				; CODE XREF: mw_mp_gcd+11Aj
		mov	[esp+58h+var_58], edi
		call	mw_mp_iseven
		test	eax, eax
		jz	short loc_10019ECC
		mov	[esp+58h+var_58], esi
		call	s_mw_mp_div_2
		mov	[esp+58h+var_58], edi
		call	s_mw_mp_div_2
		add	[ebp+var_40], 1

loc_10019EC0:				; CODE XREF: mw_mp_gcd+E9j
		mov	[esp+58h+var_58], esi
		call	mw_mp_iseven
		test	eax, eax
		jnz	short loc_10019EA0

loc_10019ECC:				; CODE XREF: mw_mp_gcd+FAj
		mov	[esp+58h+var_58], esi
		call	mw_mp_isodd
		test	eax, eax
		jz	loc_1001A014
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edi
		call	mw_mp_copy
		test	eax, eax
		mov	ebx, eax
		jnz	loc_10019F99
		cmp	[ebp+var_2C], 0
		setz	[ebp+var_3C]
		lea	esi, [esi+0]

loc_10019F00:				; CODE XREF: mw_mp_gcd+1C2j
					; mw_mp_gcd+209j ...
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_58], eax
		call	mw_mp_iseven
		test	eax, eax
		jnz	loc_10019FAE
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_58], eax
		call	mw_mp_cmw_mp_z
		sub	eax, 1
		jz	loc_10019FBE
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_54], edi
		mov	[esp+58h+var_58], eax
		call	mw_mp_copy
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_10019F99
		cmp	[ebp+var_3C], 0
		setz	[ebp+var_2C]

loc_10019F44:				; CODE XREF: mw_mp_gcd+221j
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_50], eax
		mov	[esp+58h+var_54], edi
		mov	[esp+58h+var_58], esi
		call	mw_mp_sub
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_10019F99
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_54], 0
		mov	[esp+58h+var_58], eax
		call	s_mw_mp_cmw_mp_d
		test	eax, eax
		jnz	short loc_10019F00
		movzx	eax, word ptr [ebp+var_40]
		mov	[esp+58h+var_58], edi
		mov	[esp+58h+var_54], eax
		call	s_mw_mp_2expt
		mov	eax, [ebp+arg_8]
		mov	[esp+58h+var_54], edi
		mov	[esp+58h+var_58], esi
		mov	[esp+58h+var_50], eax
		call	mw_mp_mul
		mov	ebx, eax

loc_10019F99:				; CODE XREF: mw_mp_gcd+13Fj
					; mw_mp_gcd+18Aj ...
		mov	[esp+58h+var_58], edi
		call	mw_mp_clear

loc_10019FA1:				; CODE XREF: mw_mp_gcd+D4j
		mov	[esp+58h+var_58], esi
		call	mw_mp_clear
		jmp	loc_10019E48
; ---------------------------------------------------------------------------

loc_10019FAE:				; CODE XREF: mw_mp_gcd+15Dj
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_58], eax
		call	s_mw_mp_div_2
		jmp	loc_10019F00
; ---------------------------------------------------------------------------

loc_10019FBE:				; CODE XREF: mw_mp_gcd+171j
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_54], esi
		mov	[esp+58h+var_58], eax
		call	mw_mp_copy
		test	eax, eax
		mov	ebx, eax
		jz	loc_10019F44
		jmp	short loc_10019F99
; ---------------------------------------------------------------------------
		align 10h

loc_10019FE0:				; CODE XREF: mw_mp_gcd+36j
		mov	[esp+58h+var_58], edi
		mov	ebx, 0FFFFFFFDh
		call	mw_mp_cmw_mp_z
		test	eax, eax
		nop
		jz	loc_10019E13
		mov	eax, [ebp+arg_8]
		mov	[esp+58h+var_58], edi
		mov	[esp+58h+var_54], eax
		call	mw_mp_copy
		test	eax, eax
		mov	ebx, eax
		jz	loc_10019E0D
		jmp	loc_10019E13
; ---------------------------------------------------------------------------

loc_1001A014:				; CODE XREF: mw_mp_gcd+126j
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], esi
		call	mw_mp_copy
		test	eax, eax
		mov	ebx, eax
		jnz	loc_10019F99
		jmp	loc_10019F00
mw_mp_gcd	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 414. mw_mp_lcm

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_lcm
mw_mp_lcm	proc near

var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_2C		= byte ptr -2Ch
var_1C		= byte ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 48h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_C], ebx
		mov	[ebp+var_4], edi
		test	esi, esi
		jz	short loc_1001A0A0
		mov	eax, [ebp+arg_4]
		test	eax, eax
		jz	short loc_1001A0A0
		mov	eax, [ebp+arg_8]
		test	eax, eax
		jz	short loc_1001A0A0
		lea	edi, [ebp+var_1C]
		mov	[esp+48h+var_48], edi
		call	mw_mp_init
		test	eax, eax
		mov	ebx, eax
		jz	short loc_1001A084

loc_1001A075:				; CODE XREF: mw_mp_lcm+5Dj
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1001A084:				; CODE XREF: mw_mp_lcm+33j
		lea	eax, [ebp+var_2C]
		mov	[esp+48h+var_48], eax
		call	mw_mp_init
		test	eax, eax
		mov	ebx, eax
		jz	short loc_1001A0BC

loc_1001A095:				; CODE XREF: mw_mp_lcm+A3j
		mov	[esp+48h+var_48], edi
		call	mw_mp_clear
		jmp	short loc_1001A075
; ---------------------------------------------------------------------------
		align 10h

loc_1001A0A0:				; CODE XREF: mw_mp_lcm+14j
					; mw_mp_lcm+1Bj ...
		mov	[esp+48h+var_40], 7F1h
		mov	[esp+48h+var_44], offset aMpi_c	; "mpi.c"
		mov	[esp+48h+var_48], offset aAVoid0BVoid0CV ; "a != ((void	*)0) &&	b != ((void *)0) &&"...
		call	_assert
; ---------------------------------------------------------------------------

loc_1001A0BC:				; CODE XREF: mw_mp_lcm+53j
		lea	eax, [ebp+var_2C]
		mov	[esp+48h+var_40], eax
		mov	eax, [ebp+arg_4]
		mov	[esp+48h+var_48], esi
		mov	[esp+48h+var_44], eax
		call	mw_mp_mul
		test	eax, eax
		mov	ebx, eax
		jz	short loc_1001A0E5

loc_1001A0D8:				; CODE XREF: mw_mp_lcm+BCj
					; mw_mp_lcm+DEj
		lea	eax, [ebp+var_2C]
		mov	[esp+48h+var_48], eax
		call	mw_mp_clear
		jmp	short loc_1001A095
; ---------------------------------------------------------------------------

loc_1001A0E5:				; CODE XREF: mw_mp_lcm+96j
		mov	eax, [ebp+arg_4]
		mov	[esp+48h+var_40], edi
		mov	[esp+48h+var_48], esi
		mov	[esp+48h+var_44], eax
		call	mw_mp_gcd
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_1001A0D8
		mov	eax, [ebp+arg_8]
		mov	[esp+48h+var_3C], 0
		mov	[esp+48h+var_44], edi
		mov	[esp+48h+var_40], eax
		lea	eax, [ebp+var_2C]
		mov	[esp+48h+var_48], eax
		call	mw_mp_div
		mov	ebx, eax
		jmp	short loc_1001A0D8
mw_mp_lcm	endp

; Exported entry 391. mw_mp_cmw_mp_int

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_cmw_mp_int
mw_mp_cmw_mp_int proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_18		= byte ptr -18h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+var_4], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_8], ebx
		test	esi, esi
		jz	short loc_1001A16F
		lea	ebx, [ebp+var_18]
		mov	[esp+28h+var_28], ebx
		call	mw_mp_init
		mov	eax, [ebp+arg_4]
		mov	[esp+28h+var_28], ebx
		mov	[esp+28h+var_24], eax
		call	mw_mp_set_int
		mov	[esp+28h+var_24], ebx
		mov	[esp+28h+var_28], esi
		call	mw_mp_cmp
		mov	[esp+28h+var_28], ebx
		mov	esi, eax
		call	mw_mp_clear
		mov	eax, esi
		mov	ebx, [ebp+var_8]
		mov	esi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1001A16F:				; CODE XREF: mw_mp_cmw_mp_int+11j
		mov	[esp+28h+var_20], 74Fh
		mov	[esp+28h+var_24], offset aMpi_c	; "mpi.c"
		mov	[esp+28h+var_28], offset aAVoid0 ; "a != ((void	*)0)"
		call	_assert
mw_mp_cmw_mp_int endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 404. mw_mp_exptmod_d

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_exptmod_d
mw_mp_exptmod_d	proc near

var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= byte ptr -2Ch
var_1C		= byte ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	ecx, [ebp+arg_0]
		mov	[ebp+var_8], esi
		movzx	esi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		mov	[ebp+var_4], edi
		test	ecx, ecx
		jz	loc_1001A2B3
		mov	edx, [ebp+arg_C]
		test	edx, edx
		jz	loc_1001A2B3
		lea	edi, [ebp+var_1C]
		mov	[esp+38h+var_38], edi
		call	mw_mp_init
		test	eax, eax
		mov	ebx, eax
		jz	short loc_1001A1E0

loc_1001A1CA:				; CODE XREF: mw_mp_exptmod_d+70j
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_1001A1E0:				; CODE XREF: mw_mp_exptmod_d+38j
		mov	eax, [ebp+arg_0]
		mov	[esp+38h+var_34], eax
		lea	eax, [ebp+var_2C]
		mov	[esp+38h+var_38], eax
		call	mw_mp_init_copy
		test	eax, eax
		mov	ebx, eax
		jz	short loc_1001A202

loc_1001A1F8:				; CODE XREF: mw_mp_exptmod_d+10Bj
		mov	[esp+38h+var_38], edi
		call	mw_mp_clear
		jmp	short loc_1001A1CA
; ---------------------------------------------------------------------------

loc_1001A202:				; CODE XREF: mw_mp_exptmod_d+66j
		mov	[esp+38h+var_34], 1
		mov	[esp+38h+var_38], edi
		call	mw_mp_set
		test	si, si
		jnz	short loc_1001A225
		jmp	loc_1001A2A0
; ---------------------------------------------------------------------------
		align 10h

loc_1001A220:				; CODE XREF: mw_mp_exptmod_d+FEj
		shr	si, 1
		jz	short loc_1001A2A0

loc_1001A225:				; CODE XREF: mw_mp_exptmod_d+85j
		test	si, 1
		lea	esi, [esi+0]
		jz	short loc_1001A260
		lea	eax, [ebp+var_2C]
		mov	[esp+38h+var_34], eax
		mov	[esp+38h+var_38], edi
		call	s_mw_mp_mul
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_1001A290
		mov	eax, [ebp+arg_8]
		mov	[esp+38h+var_30], edi
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	mw_mp_mod
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_1001A290

loc_1001A260:				; CODE XREF: mw_mp_exptmod_d+A0j
		lea	eax, [ebp+var_2C]
		mov	[esp+38h+var_38], eax
		call	s_mw_mp_sqr
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_1001A290
		lea	eax, [ebp+var_2C]
		mov	[esp+38h+var_30], eax
		mov	eax, [ebp+arg_8]
		mov	[esp+38h+var_34], eax
		lea	eax, [ebp+var_2C]
		mov	[esp+38h+var_38], eax
		call	mw_mp_mod
		test	eax, eax
		mov	ebx, eax
		jz	short loc_1001A220

loc_1001A290:				; CODE XREF: mw_mp_exptmod_d+B5j
					; mw_mp_exptmod_d+CEj ...
		lea	eax, [ebp+var_2C]
		mov	[esp+38h+var_38], eax
		call	mw_mp_clear
		jmp	loc_1001A1F8
; ---------------------------------------------------------------------------

loc_1001A2A0:				; CODE XREF: mw_mp_exptmod_d+87j
					; mw_mp_exptmod_d+93j
		mov	eax, [ebp+arg_C]
		xor	ebx, ebx
		mov	[esp+38h+var_38], edi
		mov	[esp+38h+var_34], eax
		call	s_mw_mp_exch
		jmp	short loc_1001A290
; ---------------------------------------------------------------------------

loc_1001A2B3:				; CODE XREF: mw_mp_exptmod_d+18j
					; mw_mp_exptmod_d+23j
		mov	[esp+38h+var_30], 6C1h
		mov	[esp+38h+var_34], offset aMpi_c	; "mpi.c"
		mov	[esp+38h+var_38], offset aAVoid0CVoid0 ; "a != ((void *)0) && c	!= ((void *)0)"
		call	_assert
mw_mp_exptmod_d	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 403. mw_mp_exptmod

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_exptmod
mw_mp_exptmod	proc near		; CODE XREF: sub_10003890+32p
					; sub_10003CA0+ACp

var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_4C		= dword	ptr -4Ch
var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= byte ptr -3Ch
var_2C		= byte ptr -2Ch
var_1C		= byte ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 58h
		mov	[ebp+var_C], ebx
		mov	ebx, [ebp+arg_0]
		mov	eax, [ebp+arg_4]
		mov	[ebp+var_8], esi
		mov	[ebp+var_4], edi
		test	ebx, ebx
		mov	esi, [eax+0Ch]
		mov	edi, [eax+8]
		jz	short loc_1001A2F6
		mov	edx, [ebp+arg_C]
		test	edx, edx
		jnz	short loc_1001A312

loc_1001A2F6:				; CODE XREF: mw_mp_exptmod+1Dj
		mov	[esp+58h+var_50], 66Dh
		mov	[esp+58h+var_54], offset aMpi_c	; "mpi.c"
		mov	[esp+58h+var_58], offset aAVoid0BVoid0CV ; "a != ((void	*)0) &&	b != ((void *)0) &&"...
		call	_assert
; ---------------------------------------------------------------------------

loc_1001A312:				; CODE XREF: mw_mp_exptmod+24j
		mov	[esp+58h+var_58], eax
		call	mw_mp_cmw_mp_z
		test	eax, eax
		jns	short loc_1001A335

loc_1001A31E:				; CODE XREF: mw_mp_exptmod+72j
		mov	[ebp+var_48], 0FFFFFFFDh

loc_1001A325:				; CODE XREF: mw_mp_exptmod+84j
					; mw_mp_exptmod+A7j
		mov	eax, [ebp+var_48]
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1001A335:				; CODE XREF: mw_mp_exptmod+4Cj
		mov	eax, [ebp+arg_8]
		mov	[esp+58h+var_58], eax
		call	mw_mp_cmw_mp_z
		test	eax, eax
		jle	short loc_1001A31E
		lea	edx, [ebp+var_1C]
		mov	[esp+58h+var_58], edx
		call	mw_mp_init
		test	eax, eax
		mov	[ebp+var_48], eax
		jnz	short loc_1001A325
		lea	eax, [ebp+var_2C]
		mov	[esp+58h+var_54], ebx
		mov	[esp+58h+var_58], eax
		call	mw_mp_init_copy
		test	eax, eax
		mov	[ebp+var_48], eax
		jz	short loc_1001A379

loc_1001A36C:				; CODE XREF: mw_mp_exptmod+D1j
		lea	eax, [ebp+var_1C]
		mov	[esp+58h+var_58], eax
		call	mw_mp_clear
		jmp	short loc_1001A325
; ---------------------------------------------------------------------------

loc_1001A379:				; CODE XREF: mw_mp_exptmod+9Aj
		mov	eax, [ebp+arg_8]
		lea	edx, [ebp+var_2C]
		mov	[esp+58h+var_50], edx
		mov	[esp+58h+var_58], edx
		mov	[esp+58h+var_54], eax
		call	mw_mp_mod
		test	eax, eax
		mov	[ebp+var_48], eax
		jz	short loc_1001A3A3

loc_1001A396:				; CODE XREF: mw_mp_exptmod+E3j
					; mw_mp_exptmod+282j
		lea	edx, [ebp+var_2C]
		mov	[esp+58h+var_58], edx
		call	mw_mp_clear
		jmp	short loc_1001A36C
; ---------------------------------------------------------------------------

loc_1001A3A3:				; CODE XREF: mw_mp_exptmod+C4j
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_58], eax
		call	mw_mp_init
		test	eax, eax
		mov	[ebp+var_48], eax
		jnz	short loc_1001A396
		lea	edx, [ebp+var_1C]
		mov	[esp+58h+var_58], edx
		mov	[esp+58h+var_54], 1
		call	mw_mp_set
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_54], 1
		mov	[esp+58h+var_58], eax
		call	s_mw_mp_add_d
		mov	edx, [ebp+arg_8]
		mov	eax, [edx+8]
		add	eax, eax
		mov	[esp+58h+var_54], eax
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_58], eax
		call	s_mw_mp_lshd
		mov	eax, [ebp+arg_8]
		lea	edx, [ebp+var_3C]
		mov	[esp+58h+var_4C], 0
		mov	[esp+58h+var_50], edx
		mov	[esp+58h+var_58], edx
		mov	[esp+58h+var_54], eax
		call	mw_mp_div
		test	eax, eax
		mov	[ebp+var_48], eax
		jnz	loc_1001A547
		cmp	edi, 1
		jz	loc_1001A4C0
		mov	[ebp+var_40], 1

loc_1001A42B:				; CODE XREF: mw_mp_exptmod+1EAj
		movzx	ebx, word ptr [esi]
		mov	[ebp+var_44], 0
		jmp	short loc_1001A48D
; ---------------------------------------------------------------------------

loc_1001A437:				; CODE XREF: mw_mp_exptmod+1D6j
		mov	edx, [ebp+arg_8]
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_50], eax
		lea	eax, [ebp+var_1C]
		mov	[esp+58h+var_58], eax
		mov	[esp+58h+var_54], edx
		call	s_mw_mp_reduce
		test	eax, eax
		jnz	short loc_1001A4A8

loc_1001A454:				; CODE XREF: mw_mp_exptmod+1C0j
		lea	edx, [ebp+var_2C]
		mov	[esp+58h+var_58], edx
		call	s_mw_mp_sqr
		test	eax, eax
		jnz	short loc_1001A4A8
		mov	edx, [ebp+arg_8]
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_50], eax
		lea	eax, [ebp+var_2C]
		mov	[esp+58h+var_58], eax
		mov	[esp+58h+var_54], edx
		call	s_mw_mp_reduce
		test	eax, eax
		jnz	short loc_1001A4A8
		add	[ebp+var_44], 1
		cmp	[ebp+var_44], 10h
		jz	short loc_1001A4B0
		shr	bx, 1

loc_1001A48D:				; CODE XREF: mw_mp_exptmod+165j
		test	bl, 1
		jz	short loc_1001A454
		lea	eax, [ebp+var_2C]
		lea	edx, [ebp+var_1C]
		mov	[esp+58h+var_54], eax
		mov	[esp+58h+var_58], edx
		call	s_mw_mp_mul
		test	eax, eax
		jz	short loc_1001A437

loc_1001A4A8:				; CODE XREF: mw_mp_exptmod+182j
					; mw_mp_exptmod+191j ...
		mov	[ebp+var_48], eax
		jmp	loc_1001A547
; ---------------------------------------------------------------------------

loc_1001A4B0:				; CODE XREF: mw_mp_exptmod+1B8j
		add	[ebp+var_40], 1
		add	esi, 2
		cmp	[ebp+var_40], edi
		jnz	loc_1001A42B

loc_1001A4C0:				; CODE XREF: mw_mp_exptmod+14Ej
		movzx	ebx, word ptr [esi]
		test	bx, bx
		jz	short loc_1001A535

loc_1001A4C8:				; CODE XREF: mw_mp_exptmod+263j
		test	bl, 1
		jz	short loc_1001A500
		lea	edx, [ebp+var_2C]
		lea	eax, [ebp+var_1C]
		mov	[esp+58h+var_54], edx
		mov	[esp+58h+var_58], eax
		call	s_mw_mp_mul
		test	eax, eax
		jnz	short loc_1001A4A8
		mov	eax, [ebp+arg_8]
		lea	edx, [ebp+var_3C]
		mov	[esp+58h+var_50], edx
		lea	edx, [ebp+var_1C]
		mov	[esp+58h+var_58], edx
		mov	[esp+58h+var_54], eax
		call	s_mw_mp_reduce
		test	eax, eax
		jnz	short loc_1001A4A8

loc_1001A500:				; CODE XREF: mw_mp_exptmod+1FBj
		lea	eax, [ebp+var_2C]
		mov	[esp+58h+var_58], eax
		call	s_mw_mp_sqr
		test	eax, eax
		jnz	short loc_1001A4A8
		mov	eax, [ebp+arg_8]
		lea	edx, [ebp+var_3C]
		mov	[esp+58h+var_50], edx
		lea	edx, [ebp+var_2C]
		mov	[esp+58h+var_58], edx
		mov	[esp+58h+var_54], eax
		call	s_mw_mp_reduce
		test	eax, eax
		jnz	loc_1001A4A8
		shr	bx, 1
		jnz	short loc_1001A4C8

loc_1001A535:				; CODE XREF: mw_mp_exptmod+1F6j
		mov	eax, [ebp+arg_C]
		lea	edx, [ebp+var_1C]
		mov	[esp+58h+var_58], edx
		mov	[esp+58h+var_54], eax
		call	s_mw_mp_exch

loc_1001A547:				; CODE XREF: mw_mp_exptmod+145j
					; mw_mp_exptmod+1DBj
		lea	eax, [ebp+var_3C]
		mov	[esp+58h+var_58], eax
		call	mw_mp_clear
		jmp	loc_1001A396
mw_mp_exptmod	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 401. mw_mp_expt

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_expt
mw_mp_expt	proc near

var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_30		= dword	ptr -30h
var_2C		= byte ptr -2Ch
var_1C		= byte ptr -1Ch
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 48h
		mov	[ebp+var_8], esi
		mov	esi, [ebp+arg_0]
		mov	[ebp+var_C], ebx
		mov	[ebp+var_4], edi
		test	esi, esi
		jz	short loc_1001A584
		mov	ebx, [ebp+arg_4]
		test	ebx, ebx
		jz	short loc_1001A584
		mov	ecx, [ebp+arg_8]
		test	ecx, ecx
		jnz	short loc_1001A5A0

loc_1001A584:				; CODE XREF: mw_mp_expt+14j
					; mw_mp_expt+1Bj
		mov	[esp+48h+var_40], 4FBh
		mov	[esp+48h+var_44], offset aMpi_c	; "mpi.c"
		mov	[esp+48h+var_48], offset aAVoid0BVoid0CV ; "a != ((void	*)0) &&	b != ((void *)0) &&"...
		call	_assert
; ---------------------------------------------------------------------------

loc_1001A5A0:				; CODE XREF: mw_mp_expt+22j
		mov	eax, [ebp+arg_4]
		mov	esi, 0FFFFFFFDh
		mov	[esp+48h+var_48], eax
		call	mw_mp_cmw_mp_z
		test	eax, eax
		js	short loc_1001A5C5
		lea	edx, [ebp+var_1C]
		mov	[esp+48h+var_48], edx
		call	mw_mp_init
		test	eax, eax
		mov	esi, eax
		jz	short loc_1001A5D4

loc_1001A5C5:				; CODE XREF: mw_mp_expt+52j
					; mw_mp_expt+171j
		mov	eax, esi
		mov	ebx, [ebp+var_C]
		mov	esi, [ebp+var_8]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1001A5D4:				; CODE XREF: mw_mp_expt+63j
		lea	ecx, [ebp+var_1C]
		mov	[esp+48h+var_48], ecx
		mov	[esp+48h+var_44], 1
		call	mw_mp_set
		mov	eax, [ebp+arg_0]
		lea	edx, [ebp+var_2C]
		mov	[esp+48h+var_48], edx
		mov	[esp+48h+var_44], eax
		call	mw_mp_init_copy
		test	eax, eax
		mov	esi, eax
		jnz	loc_1001A6C6
		mov	ecx, [ebp+arg_4]
		xor	edx, edx
		cmp	dword ptr [ecx+8], 1
		jz	short loc_1001A672
		mov	[ebp+var_30], 0

loc_1001A615:				; CODE XREF: mw_mp_expt+10Ej
		mov	ecx, [ebp+arg_4]
		xor	edi, edi
		mov	eax, [ecx+0Ch]
		movzx	ebx, word ptr [eax+edx*2]
		jmp	short loc_1001A626
; ---------------------------------------------------------------------------

loc_1001A623:				; CODE XREF: mw_mp_expt+FAj
		shr	bx, 1

loc_1001A626:				; CODE XREF: mw_mp_expt+C1j
		test	bl, 1
		jz	short loc_1001A643
		lea	eax, [ebp+var_2C]
		lea	edx, [ebp+var_1C]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], edx
		call	s_mw_mp_mul
		test	eax, eax
		mov	esi, eax
		jnz	short loc_1001A6BB

loc_1001A643:				; CODE XREF: mw_mp_expt+C9j
		lea	ecx, [ebp+var_2C]
		mov	[esp+48h+var_48], ecx
		call	s_mw_mp_sqr
		test	eax, eax
		mov	esi, eax
		jnz	short loc_1001A6BB
		add	edi, 1
		cmp	edi, 10h
		jnz	short loc_1001A623
		mov	ecx, [ebp+arg_4]
		add	[ebp+var_30], 1
		mov	edx, [ebp+var_30]
		mov	eax, [ecx+8]
		sub	eax, 1
		cmp	eax, edx
		ja	short loc_1001A615
		add	edx, edx

loc_1001A672:				; CODE XREF: mw_mp_expt+ACj
		mov	ecx, [ebp+arg_4]
		mov	eax, [ecx+0Ch]
		movzx	ebx, word ptr [eax+edx]
		test	bx, bx
		jnz	short loc_1001A688
		jmp	short loc_1001A6D6
; ---------------------------------------------------------------------------

loc_1001A683:				; CODE XREF: mw_mp_expt+159j
		shr	bx, 1
		jz	short loc_1001A6D6

loc_1001A688:				; CODE XREF: mw_mp_expt+11Fj
		test	bl, 1
		nop
		lea	esi, [esi+0]
		jz	short loc_1001A6AA
		lea	eax, [ebp+var_2C]
		lea	edx, [ebp+var_1C]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], edx
		call	s_mw_mp_mul
		test	eax, eax
		mov	esi, eax
		jnz	short loc_1001A6BB

loc_1001A6AA:				; CODE XREF: mw_mp_expt+130j
		lea	ecx, [ebp+var_2C]
		mov	[esp+48h+var_48], ecx
		call	s_mw_mp_sqr
		test	eax, eax
		mov	esi, eax
		jz	short loc_1001A683

loc_1001A6BB:				; CODE XREF: mw_mp_expt+E1j
					; mw_mp_expt+F2j ...
		lea	edx, [ebp+var_2C]
		mov	[esp+48h+var_48], edx
		call	mw_mp_clear

loc_1001A6C6:				; CODE XREF: mw_mp_expt+9Dj
		lea	ecx, [ebp+var_1C]
		mov	[esp+48h+var_48], ecx
		call	mw_mp_clear
		jmp	loc_1001A5C5
; ---------------------------------------------------------------------------

loc_1001A6D6:				; CODE XREF: mw_mp_expt+121j
					; mw_mp_expt+126j
		mov	eax, [ebp+arg_4]
		mov	[esp+48h+var_48], eax
		call	mw_mp_iseven
		test	eax, eax
		jz	short loc_1001A6EE
		mov	edx, [ebp+arg_0]
		movzx	eax, byte ptr [edx]
		mov	[ebp+var_1C], al

loc_1001A6EE:				; CODE XREF: mw_mp_expt+183j
		mov	ecx, [ebp+arg_8]
		lea	eax, [ebp+var_1C]
		mov	[esp+48h+var_48], eax
		mov	[esp+48h+var_44], ecx
		call	mw_mp_copy
		mov	esi, eax
		jmp	short loc_1001A6BB
mw_mp_expt	endp

; ---------------------------------------------------------------------------
		align 10h
; Exported entry 402. mw_mp_expt_d

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_expt_d
mw_mp_expt_d	proc near

var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_2D		= byte ptr -2Dh
var_2C		= byte ptr -2Ch
var_1C		= byte ptr -1Ch
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= word ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 48h
		mov	[ebp+var_4], edi
		mov	edi, [ebp+arg_0]
		mov	[ebp+var_8], esi
		movzx	esi, [ebp+arg_4]
		mov	[ebp+var_C], ebx
		test	edi, edi
		jz	loc_1001A805
		mov	eax, [ebp+arg_8]
		test	eax, eax
		jz	loc_1001A805
		lea	eax, [ebp+var_1C]
		mov	[esp+48h+var_48], eax
		call	mw_mp_init
		test	eax, eax
		mov	ebx, eax
		jz	short loc_1001A760

loc_1001A74A:				; CODE XREF: mw_mp_expt_d+CBj
		mov	eax, ebx
		mov	esi, [ebp+var_8]
		mov	ebx, [ebp+var_C]
		mov	edi, [ebp+var_4]
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------
		align 10h

loc_1001A760:				; CODE XREF: mw_mp_expt_d+38j
		lea	edx, [ebp+var_2C]
		mov	[esp+48h+var_44], edi
		mov	[esp+48h+var_48], edx
		call	mw_mp_init_copy
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_1001A7D0
		mov	eax, [ebp+var_10]
		mov	[ebp+var_2D], 0
		mov	word ptr [eax],	1
		movzx	eax, si
		test	al, 1
		jnz	short loc_1001A7E0

loc_1001A788:				; CODE XREF: mw_mp_expt_d+D6j
		test	si, si
		jnz	short loc_1001A798
		jmp	short loc_1001A7E8
; ---------------------------------------------------------------------------
		align 10h

loc_1001A790:				; CODE XREF: mw_mp_expt_d+B3j
		shr	si, 1
		jz	short loc_1001A7E8
		movzx	eax, si

loc_1001A798:				; CODE XREF: mw_mp_expt_d+7Bj
		test	al, 1
		jz	short loc_1001A7B4
		lea	eax, [ebp+var_2C]
		lea	edx, [ebp+var_1C]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], edx
		call	s_mw_mp_mul
		test	eax, eax
		mov	ebx, eax
		jnz	short loc_1001A7C5

loc_1001A7B4:				; CODE XREF: mw_mp_expt_d+8Aj
		lea	eax, [ebp+var_2C]
		mov	[esp+48h+var_48], eax
		call	s_mw_mp_sqr
		test	eax, eax
		mov	ebx, eax
		jz	short loc_1001A790

loc_1001A7C5:				; CODE XREF: mw_mp_expt_d+A2j
					; mw_mp_expt_d+F3j
		lea	eax, [ebp+var_2C]
		mov	[esp+48h+var_48], eax
		call	mw_mp_clear

loc_1001A7D0:				; CODE XREF: mw_mp_expt_d+63j
		lea	edx, [ebp+var_1C]
		mov	[esp+48h+var_48], edx
		call	mw_mp_clear
		jmp	loc_1001A74A
; ---------------------------------------------------------------------------

loc_1001A7E0:				; CODE XREF: mw_mp_expt_d+76j
		movzx	edx, byte ptr [edi]
		mov	[ebp+var_2D], dl
		jmp	short loc_1001A788
; ---------------------------------------------------------------------------

loc_1001A7E8:				; CODE XREF: mw_mp_expt_d+7Dj
					; mw_mp_expt_d+83j
		movzx	edx, [ebp+var_2D]
		xor	ebx, ebx
		mov	eax, [ebp+arg_8]
		mov	[ebp+var_1C], dl
		lea	edx, [ebp+var_1C]
		mov	[esp+48h+var_44], eax
		mov	[esp+48h+var_48], edx
		call	s_mw_mp_exch
		jmp	short loc_1001A7C5
; ---------------------------------------------------------------------------

loc_1001A805:				; CODE XREF: mw_mp_expt_d+18j
					; mw_mp_expt_d+23j
		mov	[esp+48h+var_40], 2FCh
		mov	[esp+48h+var_44], offset aMpi_c	; "mpi.c"
		mov	[esp+48h+var_48], offset aAVoid0CVoid0 ; "a != ((void *)0) && c	!= ((void *)0)"
		call	_assert
mw_mp_expt_d	endp

; ---------------------------------------------------------------------------
		jmp	short mw_mp_init_array
; ---------------------------------------------------------------------------
		align 10h
; Exported entry 408. mw_mp_init_array

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public mw_mp_init_array
mw_mp_init_array proc near		; CODE XREF: .text:1001A821j

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_10		= dword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		mov	eax, [ebp+arg_0]
		mov	esi, [ebp+arg_4]
		test	eax, eax
		jz	short loc_1001A89D
		xor	edi, edi
		test	esi, esi
		mov	ebx, [ebp+arg_0]
		jg	short loc_1001A85A
		jmp	short loc_1001A89D
; ---------------------------------------------------------------------------
		align 10h

loc_1001A850:				; CODE XREF: mw_mp_init_array+37j
		add	edi, 1
		add	ebx, 10h
		cmp	edi, esi
		jz	short loc_1001A892

loc_1001A85A:				; CODE XREF: mw_mp_init_array+1Aj
		mov	[esp+28h+var_28], ebx
		call	mw_mp_init
		test	eax, eax
		mov	[ebp+var_10], eax
		jz	short loc_1001A850
		mov	eax, edi
		sub	eax, 1
		js	short loc_1001A892
		mov	edx, [ebp+arg_0]
		mov	eax, edi
		xor	esi, esi
		shl	eax, 4
		lea	ebx, [edx+eax-10h]
		xchg	ax, ax

loc_1001A880:				; CODE XREF: mw_mp_init_array+60j
		add	esi, 1
		mov	[esp+28h+var_28], ebx
		sub	ebx, 10h
		call	mw_mp_clear
		cmp	esi, edi
		jnz	short loc_1001A880

loc_1001A892:				; CODE XREF: mw_mp_init_array+28j
					; mw_mp_init_array+3Ej
		mov	eax, [ebp+var_10]
		add	esp, 1Ch
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1001A89D:				; CODE XREF: mw_mp_init_array+11j
					; mw_mp_init_array+1Cj
		mov	[esp+28h+var_20], 0FBh
		mov	[esp+28h+var_24], offset aMpi_c	; "mpi.c"
		mov	[esp+28h+var_28], offset aMpVoid0Count_0 ; "mp !=((void	*)0) &&	count >	0"
		call	_assert
mw_mp_init_array endp

; ---------------------------------------------------------------------------
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION g_hash_table_new]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION g_hash_table_insert]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION g_strdup]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION g_list_free]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION g_slist_append]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION g_slist_free]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION g_hash_table_lookup]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION g_free]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION g_malloc0]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION g_hash_table_new_full]
		align 10h

loc_1001A910:				; DATA XREF: mwChannelSet_new+2Bo
					; mwChannel_newIncoming+4Bo ...
		jmp	ds:g_direct_hash
; ---------------------------------------------------------------------------
		align 4

loc_1001A918:				; DATA XREF: mwChannelSet_new+23o
					; mwChannel_newIncoming+43o ...
		jmp	ds:g_direct_equal
; ---------------------------------------------------------------------------
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION g_hash_table_remove]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION g_list_append]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION g_hash_table_foreach]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION g_return_if_fail_warning]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION g_hash_table_steal]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION g_log]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION g_hash_table_destroy]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION g_malloc]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION g_memdup]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION g_str_hash]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION g_list_prepend]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION g_list_length]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION g_list_delete_link]
		align 4

loc_1001A988:				; DATA XREF: mwSession_new+88o
					; mwServiceDirectory_new+B0o
		jmp	ds:g_str_equal
; ---------------------------------------------------------------------------
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION g_hash_table_foreach_steal]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION g_list_remove_all]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION g_hash_table_size]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION g_list_remove]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION g_strdup_printf]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION g_list_copy]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION g_list_concat]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION g_string_new]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION g_string_free]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION g_string_append]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION g_string_append_len]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION g_strndup]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION g_string_append_printf]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION g_strdup_vprintf]
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1001AA00	proc near		; CODE XREF: DllEntryPoint+17p
					; DllEntryPoint+79p
		push	ebp
		mov	eax, 1
		mov	ebp, esp
		pop	ebp
		retn	0Ch
sub_1001AA00	endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

sub_1001AA10	proc near		; CODE XREF: DllEntryPoint+64p
		push	ebp
		mov	ecx, offset dword_10020E58
		mov	ebp, esp
		cmp	ecx, offset dword_10020E58
		jnb	short loc_1001AA38

loc_1001AA20:				; CODE XREF: sub_1001AA10+26j
		mov	edx, [ecx+4]
		mov	eax, [ecx]
		add	edx, 10000000h
		add	ecx, 8
		add	[edx], eax
		cmp	ecx, offset dword_10020E58
		jb	short loc_1001AA20

loc_1001AA38:				; CODE XREF: sub_1001AA10+Ej
		pop	ebp
		retn
sub_1001AA10	endp

; ---------------------------------------------------------------------------
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION malloc]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION _errno]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION free]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION fflush]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION __dllonexit]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION time]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION srand]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION rand]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION strcmp]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION strlen]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION memcpy]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION sprintf]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION clock]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION sscanf]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION strstr]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION strrchr]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION _isctype]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION _assert]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION calloc]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION memset]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION toupper]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION tolower]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION log]
		align 4
; [00000006 BYTES: COLLAPSED FUNCTION GetModuleHandleA]
		align 10h
; [00000006 BYTES: COLLAPSED FUNCTION GetProcAddress]
		align 4
dword_1001AB08	dd 0FFFFFFFFh		; DATA XREF: sub_10001200:loc_10001216r
					; sub_10001200+34o ...
		align 10h
		dd 0FFFFFFFFh
dword_1001AB14	dd 3Bh dup(0)		; DATA XREF: .data:off_1001B004o
		dd 100h	dup(?)
_text		ends

; Section 2. (virtual address 0001B000)
; Virtual size			: 00000068 (	104.)
; Section size in file		: 00000200 (	512.)
; Offset to raw	data for section: 0001A000
; Flags	C0600040: Data Readable	Writable
; Alignment	: 32 bytes
; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment '32byte' can not be represented in assembly
_data		segment	para public 'DATA' use32
		assume cs:_data
		;org 1001B000h
dword_1001B000	dd 0			; DATA XREF: sub_10001200+5r
					; sub_10001200+1Cw
off_1001B004	dd offset dword_1001AB14 ; DATA	XREF: sub_100011D0+6r
					; sub_100011D0+13r ...
		align 20h
dword_1001B020	dd 0CEAF84CFh, 52FADD86h, 106D137Fh, 0EE287535h, 0EFAFA0FBh
					; DATA XREF: mwMpi_setDHPrime+15o
					; sub_10003860+1Co
		dd 17298F80h, 9E6A3B4Eh, 71010097h, 6C108F7Ch, 0A661C141h
		dd 7B0591CEh, 0CB62DA34h, 0C1FD7BB8h, 911B5CB3h, 2472EA0Fh
		dd 9F6B569Dh
; size_t dword_1001B060
dword_1001B060	dd 20h			; DATA XREF: mw_mp_get_prec+1r
					; mw_mp_set_prec+11w ...
dword_1001B064	dd 0			; DATA XREF: sub_10001170+6r
					; sub_10001170+40o
		align 1000h
_data		ends

; Section 3. (virtual address 0001C000)
; Virtual size			: 00004E58 (  20056.)
; Section size in file		: 00005000 (  20480.)
; Offset to raw	data for section: 0001A200
; Flags	40600040: Data Readable
; Alignment	: 32 bytes
; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 1001C000h
; CHAR ModuleName[]
ModuleName	db 'libgcj_s.dll',0     ; DATA XREF: sub_10001170+12o
; CHAR ProcName[]
ProcName	db '_Jv_RegisterClasses',0 ; DATA XREF: sub_10001170+2Co
		align 20h
aError		db 'error',0            ; DATA XREF: sub_10001280+25o
aUnknown	db 'UNKNOWN',0          ; DATA XREF: sub_10001280+6o
aNew		db 'new',0              ; DATA XREF: sub_10001280:loc_10001294o
aInitializing	db 'initializing',0     ; DATA XREF: sub_10001280+2Eo
aWaiting	db 'waiting',0          ; DATA XREF: sub_10001280+37o
aOpen		db 'open',0             ; DATA XREF: sub_10001280+40o
aClosing	db 'closing',0          ; DATA XREF: sub_10001280+49o
off_1001C074	dd offset loc_10001294	; DATA XREF: sub_10001280+Dr
		dd offset loc_100012AD	; jump table for switch	statement
		dd offset loc_100012B6
		dd offset loc_100012BF
		dd offset loc_100012C8
		dd offset loc_100012A4
aChanNull	db 'chan != NULL',0     ; DATA XREF: mwChannel_getState:loc_100012F2o
					; mwChannel_getCipherInstance:loc_10001332o ...
aMeanwhile	db 'meanwhile',0        ; DATA XREF: mwChannel_getState+22o
					; mwChannel_getCipherInstance+22o ...
aChanStateMwcha	db 'chan->state == mwChannel_INIT',0
					; DATA XREF: mwChannel_setOptions:loc_10001459o
					; mwChannel_setProtoVer:loc_10001539o ...
		align 4
aChannel0x08xSt	db 'channel 0x%08x state: %s (0x%08x)',0 ; DATA XREF: sub_10001700+36o
aChannel0x08x_0	db 'channel 0x%08x state: %s',0 ; DATA XREF: sub_10001700+6Eo
aChanSupportedN	db 'chan->supported != NULL',0
					; DATA XREF: mwChannel_selectCipherInstance:loc_100018E1o
aNull		db '(null)',0           ; DATA XREF: mwChannel_selectCipherInstance+71o
					; mwChannel_addSupportedCipherInstance+22o
		align 10h
aChannel0x08xSe	db 'channel 0x%08x selected cipher %s',0
					; DATA XREF: mwChannel_selectCipherInstance+8Bo
		align 4
aChannel0x08x_1	db 'channel 0x%08x selected no cipher',0
					; DATA XREF: mwChannel_selectCipherInstance+E1o
		align 4
aChannel0x08xAd	db 'channel 0x%08x added cipher %s',0
					; DATA XREF: mwChannel_addSupportedCipherInstance+44o
aSessionNull	db 'session != NULL',0  ; DATA XREF: mwChannel_populateSupportedCipherInstances:loc_10001B0Ao
					; mwChannel_destroy:loc_1000225Co ...
aMsgNull	db 'msg != NULL',0      ; DATA XREF: mwChannel_recvDestroy:loc_10001C14o
					; mwChannel_recvAccept:loc_100024F8o ...
aChanIdMsgHead_	db 'chan->id == msg->head.channel',0
					; DATA XREF: mwChannel_recvDestroy:loc_10001C32o
					; mwChannel_recvAccept:loc_10002519o
aCsNull		db 'cs != NULL',0       ; DATA XREF: mwChannel_recvDestroy:loc_10001C50o
					; mwChannel_find:loc_10001CB3o	...
aCsMapNull	db 'cs->map != NULL',0  ; DATA XREF: mwChannel_recvDestroy:loc_10001C6Eo
					; mwChannel_find:loc_10001CD3o	...
aChanStatsNull	db 'chan->stats != NULL',0 ; DATA XREF: mwChannel_getStatistic:loc_10001D7Ao
aQueue_incoming	db 'queue_incoming, channel 0x%08x',0 ; DATA XREF: mwChannel_recv+70o
		align 10h
aChannel0x08xNo	db 'channel 0x%08x not an outgoing channel',0
					; DATA XREF: mwChannel_recvAccept+196o
		align 4
aChannel0x08x_2	db 'channel 0x%08x state not WAIT: %s',0
					; DATA XREF: mwChannel_recvAccept+55o
aNoService0x08x	db 'no service: 0x%08x',0 ; DATA XREF: mwChannel_recvAccept+1D6o
		align 10h
aChannelAccepte	db 'channel accepted with encrypt policy 0x%04x',0
					; DATA XREF: mwChannel_recvAccept+DAo
aNotAnOfferedCi	db 'not an offered cipher: 0x%04x',0 ; DATA XREF: mwChannel_recvAccept+216o
aChanIdMsgChann	db 'chan->id == msg->channel',0
					; DATA XREF: mwChannel_recvCreate:loc_100027A3o
		align 4
aChannel0x08x_3	db 'channel 0x%08x not an incoming channel',0
					; DATA XREF: mwChannel_recvCreate+56o
		align 4
aChannelOffered	db 'channel offered with encrypt policy 0x%04x',0
					; DATA XREF: mwChannel_recvCreate+ABo
		align 4
aChannelOffer_0	db 'channel offered cipher id 0x%04x',0
					; DATA XREF: mwChannel_recvCreate+18Co
		align 4
aNoSuchCipherFo	db 'no such cipher found in session',0
					; DATA XREF: mwChannel_recvCreate+1C2o
aQueue_outgoing	db 'queue_outgoing, channel 0x%08x',0
					; DATA XREF: mwChannel_sendEncrypted+58o
aMwchannel_isin	db 'mwChannel_isIncoming(chan)',0
					; DATA XREF: mwChannel_accept:loc_10002A8Co
aChanStateMwc_0	db 'chan->state == mwChannel_WAIT',0
					; DATA XREF: mwChannel_accept:loc_10002AB2o
aMwchannel_isou	db 'mwChannel_isOutgoing(chan)',0
					; DATA XREF: mwChannel_create:loc_10002C22o
aSrvcNull	db 'srvc != NULL',0     ; DATA XREF: mwChannel_setService:loc_10002D9Co
aCsSessionNull	db 'cs->session != NULL',0 ; DATA XREF: mwChannel_newIncoming:loc_10002EB1o
aMwchannel_sele	db 'mwChannel_selectCipherInstance',0
					; DATA XREF: mwChannel_selectCipherInstance+10Bo
					; mwChannel_selectCipherInstance+129o
		align 10h
aMwchannel_ge_4	db 'mwChannel_getSupportedCipherInstances',0
					; DATA XREF: mwChannel_getSupportedCipherInstances+3Bo
		align 20h
aMwchannel_adds	db 'mwChannel_addSupportedCipherInstance',0
					; DATA XREF: mwChannel_addSupportedCipherInstance+7Bo
		align 20h
aMwchannel_popu	db 'mwChannel_populateSupportedCipherInstances',0
					; DATA XREF: mwChannel_populateSupportedCipherInstances+54o
					; mwChannel_populateSupportedCipherInstances+72o
aMwchannel_recv	db 'mwChannel_recvDestroy',0 ; DATA XREF: mwChannel_recvDestroy+89o
					; mwChannel_recvDestroy+ACo ...
aState		db 'state',0            ; DATA XREF: sub_10001700+A0o
aMwchannel_re_0	db 'mwChannel_recvAccept',0 ; DATA XREF: mwChannel_recvAccept+22Fo
					; mwChannel_recvAccept+250o ...
aMwchannel_re_1	db 'mwChannel_recvCreate',0 ; DATA XREF: mwChannel_recvCreate+208o
					; mwChannel_recvCreate+229o ...
aChannel_free	db 'channel_free',0     ; DATA XREF: sub_10001FC0+D8o
aMwchannel_find	db 'mwChannel_find',0   ; DATA XREF: mwChannel_find+2Bo
					; mwChannel_find+4Bo
aMwchannel_send	db 'mwChannel_sendEncrypted',0 ; DATA XREF: mwChannel_sendEncrypted+E9o
aMwchannel_dest	db 'mwChannel_destroy',0 ; DATA XREF: mwChannel_destroy+B6o
					; mwChannel_destroy+D9o ...
aMwchannel_acce	db 'mwChannel_accept',0 ; DATA XREF: mwChannel_accept+173o
					; mwChannel_accept+199o ...
aMwchannel_crea	db 'mwChannel_create',0 ; DATA XREF: mwChannel_create+12Fo
					; mwChannel_create+152o ...
aMwchannel_ge_6	db 'mwChannel_getStatistic',0 ; DATA XREF: mwChannel_getStatistic+22o
					; mwChannel_getStatistic+42o
aMwchannel_gets	db 'mwChannel_getState',0 ; DATA XREF: mwChannel_getState+1Ao
aMwchannel_getc	db 'mwChannel_getCipherInstance',0
					; DATA XREF: mwChannel_getCipherInstance+1Ao
aMwchannel_geta	db 'mwChannel_getAddtlAccept',0 ; DATA XREF: mwChannel_getAddtlAccept+1Ao
aMwchannel_ge_0	db 'mwChannel_getAddtlCreate',0 ; DATA XREF: mwChannel_getAddtlCreate+1Ao
aMwchannel_getu	db 'mwChannel_getUser',0 ; DATA XREF: mwChannel_getUser+1Ao
aMwchannel_seto	db 'mwChannel_setOptions',0 ; DATA XREF: mwChannel_setOptions+23o
					; mwChannel_setOptions+41o
aMwchannel_geto	db 'mwChannel_getOptions',0 ; DATA XREF: mwChannel_getOptions+1Ao
aMwchannel_gete	db 'mwChannel_getEncryptPolicy',0
					; DATA XREF: mwChannel_getEncryptPolicy+1Bo
aMwchannel_setp	db 'mwChannel_setProtoVer',0 ; DATA XREF: mwChannel_setProtoVer+23o
					; mwChannel_setProtoVer+41o
aMwchannel_getp	db 'mwChannel_getProtoVer',0 ; DATA XREF: mwChannel_getProtoVer+1Ao
aMwchannel_se_0	db 'mwChannel_setProtoType',0 ; DATA XREF: mwChannel_setProtoType+23o
					; mwChannel_setProtoType+41o
aMwchannel_ge_1	db 'mwChannel_getProtoType',0 ; DATA XREF: mwChannel_getProtoType+1Ao
aMwchannel_remo	db 'mwChannel_removeServiceData',0
					; DATA XREF: mwChannel_removeServiceData+21o
aMwchannel_sets	db 'mwChannel_setServiceData',0 ; DATA XREF: mwChannel_setServiceData+29o
aMwchannel_ge_7	db 'mwChannel_getServiceData',0 ; DATA XREF: mwChannel_getServiceData+21o
aMwchannel_se_1	db 'mwChannel_setService',0 ; DATA XREF: mwChannel_setService+36o
					; mwChannel_setService+54o ...
aMwchannel_ge_5	db 'mwChannel_getService',0 ; DATA XREF: mwChannel_getService+28o
aMwchannel_ge_2	db 'mwChannel_getServiceId',0 ; DATA XREF: mwChannel_getServiceId+1Ao
aMwchannel_ge_3	db 'mwChannel_getSession',0 ; DATA XREF: mwChannel_getSession+19o
aMwchannel_geti	db 'mwChannel_getId',0  ; DATA XREF: mwChannel_getId+1Ao
aMwchannel_newo	db 'mwChannel_newOutgoing',0 ; DATA XREF: mwChannel_newOutgoing+5Fo
					; mwChannel_newOutgoing+7Fo
aMwchannel_newi	db 'mwChannel_newIncoming',0 ; DATA XREF: mwChannel_newIncoming+BBo
					; mwChannel_newIncoming+DBo
		align 20h
aRc240Cipher	db 'RC2/40 Cipher',0    ; DATA XREF: sub_10002FB0+1o
aRc240BitEffect	db 'RC2, 40-bit effective key',0 ; DATA XREF: sub_10002FC0+1o
aRc2128Cipher	db 'RC2/128 Cipher',0   ; DATA XREF: sub_10002FD0+1o
aRc2DhSharedSec	db 'RC2, DH shared secret key',0 ; DATA XREF: sub_10002FE0+1o
aDataNull	db 'data != NULL',0     ; DATA XREF: mwCipherInstance_decrypt:loc_100030BAo
					; mwCipherInstance_encrypt:loc_1000313Ao
aMeanwhile_0	db 'meanwhile',0        ; DATA XREF: mwCipherInstance_decrypt+43o
					; mwCipherInstance_decrypt+6Ao	...
aCipherNull	db 'cipher != NULL',0   ; DATA XREF: mwCipherInstance_decrypt:loc_10003093o
					; mwCipherInstance_encrypt:loc_10003113o ...
aCiNull		db 'ci != NULL',0       ; DATA XREF: mwCipherInstance_accept:loc_1000317Co
					; mwCipherInstance_accepted:loc_100031EBo ...
aChanNull_0	db 'chan != NULL',0     ; DATA XREF: mwCipher_newInstance:loc_100033C4o
aCipherNew_inst	db 'cipher->new_instance != NULL',0
					; DATA XREF: mwCipher_newInstance:loc_100033E2o
aCipherGet_desc	db 'cipher->get_desc != NULL',0 ; DATA XREF: mwCipher_getDesc:loc_10003437o
aCipherGet_name	db 'cipher->get_name != NULL',0 ; DATA XREF: mwCipher_getName:loc_10003497o
aKeylen0	db 'keylen > 0',0       ; DATA XREF: mwKeyExpand:loc_10003621o
aKeyNull	db 'key != NULL',0      ; DATA XREF: mwKeyExpand:loc_10003642o
					; mwKeyRandom:loc_10003C7Ao
aINull		db 'i != NULL',0        ; DATA XREF: mwMpi_import:loc_100037C7o
					; mwMpi_setDHPrime:loc_10003837o ...
aONull		db 'o != NULL',0        ; DATA XREF: mwMpi_import:loc_100037E5o
					; mwMpi_export:loc_10003EF8o
aShared_keyNull	db 'shared_key != NULL',0 ; DATA XREF: mwMpi_calculateDHShared:loc_100038FBo
aRemote_keyNull	db 'remote_key != NULL',0 ; DATA XREF: mwMpi_calculateDHShared:loc_10003916o
aPrivate_keyNul	db 'private_key != NULL',0
					; DATA XREF: mwMpi_calculateDHShared:loc_10003931o
					; mwMpi_randDHKeypair:loc_10003D8Ao
aPublic_keyNull	db 'public_key != NULL',0 ; DATA XREF: mwMpi_randDHKeypair:loc_10003DA8o
		align 4
aAttemptingDecr	db 'attempting decryption of mis-sized data, %u bytes',0
					; DATA XREF: mwDecryptExpanded+258o
aMwcipherinstan	db 'mwCipherInstance_decrypt',0 ; DATA XREF: mwCipherInstance_decrypt+3Bo
					; mwCipherInstance_decrypt+62o
aMwcipherinst_0	db 'mwCipherInstance_encrypt',0 ; DATA XREF: mwCipherInstance_encrypt+3Bo
					; mwCipherInstance_encrypt+62o
aMwcipherinst_1	db 'mwCipherInstance_accept',0 ; DATA XREF: mwCipherInstance_accept+24o
					; mwCipherInstance_accept+44o
aMwcipherinst_2	db 'mwCipherInstance_accepted',0 ; DATA XREF: mwCipherInstance_accepted+33o
					; mwCipherInstance_accepted+55o
aMwcipherinst_3	db 'mwCipherInstance_offer',0 ; DATA XREF: mwCipherInstance_offer+24o
					; mwCipherInstance_offer+44o
aMwcipherinst_4	db 'mwCipherInstance_offered',0 ; DATA XREF: mwCipherInstance_offered+33o
					; mwCipherInstance_offered+55o
aMwcipherinst_5	db 'mwCipherInstance_getChannel',0
					; DATA XREF: mwCipherInstance_getChannel+1Ao
aMwcipherinst_6	db 'mwCipherInstance_getCipher',0
					; DATA XREF: mwCipherInstance_getCipher+19o
aMwcipher_newin	db 'mwCipher_newInstance',0 ; DATA XREF: mwCipher_newInstance+2Co
					; mwCipher_newInstance+4Co ...
aMwcipher_getde	db 'mwCipher_getDesc',0 ; DATA XREF: mwCipher_getDesc+1Fo
					; mwCipher_getDesc+3Fo
aMwcipher_getna	db 'mwCipher_getName',0 ; DATA XREF: mwCipher_getName+1Fo
					; mwCipher_getName+3Fo
aMwcipher_getty	db 'mwCipher_getType',0 ; DATA XREF: mwCipher_getType+1Bo
aMwcipher_getse	db 'mwCipher_getSession',0 ; DATA XREF: mwCipher_getSession+19o
		align 10h
byte_1001CA60	db 0D9h			; DATA XREF: mwKeyExpand+71r
					; mwKeyExpand+8Er
		db 78h,	0F9h, 0C4h
		dd 0EDB5DD19h, 79FDE928h, 9DD8A04Ah, 83377EC6h,	8E53762Bh
		dd 88644C62h, 0A2FB8B44h, 0F5599A17h, 134FB387h, 8D6D4561h
		dd 327D8109h, 0EB408FBDh, 0B7BB786h, 222195F0h,	824E6B5Ch
		dd 9365D654h, 1CB260CEh, 14C05673h, 0DCF18CA7h,	1FCA7512h
		dd 0D1E4BE3Bh, 30D43D42h, 26B63CA3h, 0DA0EBF6Fh, 57076946h
		dd 9B1DF227h, 34394BCh,	0F6C711F8h, 0E73EEF90h,	2FD5C306h
		dd 0D71E66C8h, 0DEEAE808h, 0F7EE5280h, 0AC72AA84h, 2A6A4D35h
		dd 71D21A96h, 7449155Ah, 5ED09F4Bh, 0ECA41804h,	6E41E0C2h
		dd 0CCCB510Fh, 50AF9124h, 3970F4A1h, 853A7C99h,	7AB4B823h
		dd 5B3602FCh, 31975525h, 98FA5D2Dh, 0AE928AE3h,	1029DF05h
		dd 0C9BA6C67h, 0CFE600D3h, 2CA89EE1h, 3F011663h, 0A989E258h
		dd 1B34380Dh, 0B0FF33ABh, 5F0C48BBh, 2ECDB1B9h,	47DBF3C5h
		dd 779CA5E5h, 6820A60Ah, 0ADC17FFEh
aMwkeyexpand	db 'mwKeyExpand',0      ; DATA XREF: mwKeyExpand:loc_10003628o
aMwkeyrandom	db 'mwKeyRandom',0      ; DATA XREF: mwKeyRandom+52o
aMwmpi_export	db 'mwMpi_export',0     ; DATA XREF: mwMpi_export+22o
					; mwMpi_export+40o
aMwmpi_import	db 'mwMpi_import',0     ; DATA XREF: mwMpi_import+1Fo
					; mwMpi_import+3Do
aMwmpi_calculat	db 'mwMpi_calculateDHShared',0 ; DATA XREF: mwMpi_calculateDHShared+22o
					; mwMpi_calculateDHShared+3Do ...
aMwmpi_randdhke	db 'mwMpi_randDHKeypair',0 ; DATA XREF: mwMpi_randDHKeypair+22o
					; mwMpi_randDHKeypair+40o
aMwmpi_setdhbas	db 'mwMpi_setDHBase',0  ; DATA XREF: mwMpi_setDHBase+27o
aMwmpi_setdhpri	db 'mwMpi_setDHPrime',0 ; DATA XREF: mwMpi_setDHPrime+2Fo
		align 10h
aInfoNull	db 'info != NULL',0     ; DATA XREF: mwPrivacyInfo_clear:loc_100049C7o
					; mwPrivacyInfo_get:loc_10005BCAo ...
aMeanwhile_1	db 'meanwhile',0        ; DATA XREF: mwPrivacyInfo_clear+77o
					; gboolean_get+5Fo ...
aBNull		db 'b != NULL',0        ; DATA XREF: gboolean_get:loc_10004A3Fo
					; guint32_get:loc_10004B00o ...
		align 4
aCheck_bufferBG	db 'check_buffer(b, gboolean_buflen())',0
					; DATA XREF: gboolean_get:loc_10004A5Do
		align 4
aCheck_buffer_0	db 'check_buffer(b, guint32_buflen())',0
					; DATA XREF: guint32_get:loc_10004B21o
		align 4
aCheck_buffer_1	db 'check_buffer(b, guint16_buflen())',0
					; DATA XREF: guint16_get:loc_10004BD2o
aToNull		db 'to != NULL',0       ; DATA XREF: mwPutBuffer_finalize:loc_10004D4Ao
					; mwAwareIdBlock_clone:loc_10004DD6o ...
aFromNull	db 'from != NULL',0     ; DATA XREF: mwPutBuffer_finalize:loc_10004D68o
					; mwAwareIdBlock_clone:loc_10004DF4o ...
aANull		db 'a != NULL',0        ; DATA XREF: mwAwareIdBlock_equal:loc_100051D4o
					; mwIdBlock_equal:loc_10005273o
aONull_0	db 'o != NULL',0        ; DATA XREF: mwOpaque_get:loc_1000553Co
aCheck_buffer_2	db 'check_buffer(b, (gsize) tmp)',0 ; DATA XREF: mwOpaque_get:loc_1000555Do
aEiNull		db 'ei != NULL',0       ; DATA XREF: mwEncryptItem_get:loc_100055F1o
					; mwEncryptItem_put:loc_100060C6o
aValNull	db 'val != NULL',0      ; DATA XREF: mwString_get:loc_10005737o
aCheck_buffer_3	db 'check_buffer(b, (gsize) len)',0 ; DATA XREF: mwString_get:loc_10005758o
aIdbNull	db 'idb != NULL',0      ; DATA XREF: mwAwareIdBlock_get:loc_10005800o
					; mwAwareSnapshot_get:loc_10005A1Do ...
aIdNull		db 'id != NULL',0       ; DATA XREF: mwIdBlock_get:loc_10005891o
					; mwIdBlock_put:loc_10006335o
aStatNull	db 'stat != NULL',0     ; DATA XREF: mwUserStatus_get:loc_10005930o
					; mwUserStatus_put:loc_100063D5o
aUserNull	db 'user != NULL',0     ; DATA XREF: mwUserItem_get:loc_10005AD5o
					; mwUserItem_put:loc_10006482o
aLoginNull	db 'login != NULL',0    ; DATA XREF: mwLoginInfo_get:loc_10005CD1o
					; mwLoginInfo_put:loc_10006636o
aDataNull_0	db 'data != NULL',0     ; DATA XREF: mwGetBuffer_read:loc_10005D8Fo
					; mwPutBuffer_write:loc_10006169o
aODataNull	db 'o->data != NULL',0  ; DATA XREF: mwOpaque_put:loc_10005FD1o
aMwawaresnapsho	db 'mwAwareSnapshot_clone',0 ; DATA XREF: mwAwareSnapshot_clone+77o
					; mwAwareSnapshot_clone+95o
aMwawaresnaps_0	db 'mwAwareSnapshot_get',0 ; DATA XREF: mwAwareSnapshot_get+B7o
					; mwAwareSnapshot_get+D5o
aMwawareidblo_0	db 'mwAwareIdBlock_equal',0 ; DATA XREF: mwAwareIdBlock_equal+5Co
					; mwAwareIdBlock_equal+7Co
aMwawareidblock	db 'mwAwareIdBlock_clone',0 ; DATA XREF: mwAwareIdBlock_clone+4Eo
					; mwAwareIdBlock_clone+6Co
aMwawareidblo_1	db 'mwAwareIdBlock_get',0 ; DATA XREF: mwAwareIdBlock_get+6Ao
					; mwAwareIdBlock_get+88o
aMwawareidblo_2	db 'mwAwareIdBlock_put',0 ; DATA XREF: mwAwareIdBlock_put+57o
					; mwAwareIdBlock_put+7Do
aMwencryptitem_	db 'mwEncryptItem_get',0 ; DATA XREF: mwEncryptItem_get+5Bo
					; mwEncryptItem_get+79o
aMwencryptite_0	db 'mwEncryptItem_put',0 ; DATA XREF: mwEncryptItem_put+48o
					; mwEncryptItem_put+6Eo
aMwidblock_equa	db 'mwIdBlock_equal',0  ; DATA XREF: mwIdBlock_equal+5Bo
					; mwIdBlock_equal+7Bo
aMwidblock_clon	db 'mwIdBlock_clone',0  ; DATA XREF: mwIdBlock_clone+46o
					; mwIdBlock_clone+64o
aMwidblock_get	db 'mwIdBlock_get',0    ; DATA XREF: mwIdBlock_get+5Bo
					; mwIdBlock_get+79o
aMwidblock_put	db 'mwIdBlock_put',0    ; DATA XREF: mwIdBlock_put+47o
					; mwIdBlock_put+6Do
aMwuserstatus_c	db 'mwUserStatus_clone',0 ; DATA XREF: mwUserStatus_clone+3Do
					; mwUserStatus_clone+5Bo
aMwuserstatus_g	db 'mwUserStatus_get',0 ; DATA XREF: mwUserStatus_get+6Ao
					; mwUserStatus_get+88o
aMwuserstatus_p	db 'mwUserStatus_put',0 ; DATA XREF: mwUserStatus_put+57o
					; mwUserStatus_put+7Do
aMwprivacyinfo_	db 'mwPrivacyInfo_clear',0 ; DATA XREF: mwPrivacyInfo_clear+6Fo
aMwprivacyinf_0	db 'mwPrivacyInfo_clone',0 ; DATA XREF: mwPrivacyInfo_clone+7Co
					; mwPrivacyInfo_clone+9Ao
aMwprivacyinf_1	db 'mwPrivacyInfo_get',0 ; DATA XREF: mwPrivacyInfo_get+B1o
					; mwPrivacyInfo_get+D2o
aMwprivacyinf_2	db 'mwPrivacyInfo_put',0 ; DATA XREF: mwPrivacyInfo_put+89o
					; mwPrivacyInfo_put+A7o
aMwuseritem_clo	db 'mwUserItem_clone',0 ; DATA XREF: mwUserItem_clone+5Do
					; mwUserItem_clone+7Bo
aMwuseritem_get	db 'mwUserItem_get',0   ; DATA XREF: mwUserItem_get+7Fo
					; mwUserItem_get+9Do
aMwuseritem_put	db 'mwUserItem_put',0   ; DATA XREF: mwUserItem_put+6Co
					; mwUserItem_put+8Ao
aMwlogininfo_cl	db 'mwLoginInfo_clone',0 ; DATA XREF: mwLoginInfo_clone+93o
					; mwLoginInfo_clone+B1o
aMwlogininfo_ge	db 'mwLoginInfo_get',0  ; DATA XREF: mwLoginInfo_get+C8o
					; mwLoginInfo_get+E9o
aMwlogininfo_pu	db 'mwLoginInfo_put',0  ; DATA XREF: mwLoginInfo_put+C0o
					; mwLoginInfo_put+DEo
aMwopaque_clone	db 'mwOpaque_clone',0   ; DATA XREF: mwOpaque_clone+50o
aMwopaque_get	db 'mwOpaque_get',0     ; DATA XREF: mwOpaque_get+96o
					; mwOpaque_get+B4o ...
aMwopaque_put	db 'mwOpaque_put',0     ; DATA XREF: mwOpaque_put+8Bo
					; mwOpaque_put+A9o
aMwstring_get	db 'mwString_get',0     ; DATA XREF: mwString_get+AEo
					; mwString_get+CFo ...
aMwstring_put	db 'mwString_put',0     ; DATA XREF: mwString_put+93o
aGboolean_get	db 'gboolean_get',0     ; DATA XREF: gboolean_get+57o
					; gboolean_get+75o
aGboolean_put	db 'gboolean_put',0     ; DATA XREF: gboolean_put+3Bo
aGuint32_get	db 'guint32_get',0      ; DATA XREF: guint32_get+88o
					; guint32_get+A9o
aGuint32_put	db 'guint32_put',0      ; DATA XREF: guint32_put+5Do
aGuint16_get	db 'guint16_get',0      ; DATA XREF: guint16_get+6Co
					; guint16_get+8Ao
aGuint16_put	db 'guint16_put',0      ; DATA XREF: guint16_put+4Fo
aMwgetbuffer_er	db 'mwGetBuffer_error',0 ; DATA XREF: mwGetBuffer_error+1Ao
aMwgetbuffer_re	db 'mwGetBuffer_remaining',0 ; DATA XREF: mwGetBuffer_remaining+1Ao
aMwgetbuffer__0	db 'mwGetBuffer_reset',0 ; DATA XREF: mwGetBuffer_reset+29o
aMwgetbuffer_ad	db 'mwGetBuffer_advance',0 ; DATA XREF: mwGetBuffer_advance+3Eo
aMwgetbuffer__1	db 'mwGetBuffer_read',0 ; DATA XREF: mwGetBuffer_read+79o
					; mwGetBuffer_read+99o
aMwputbuffer_fi	db 'mwPutBuffer_finalize',0 ; DATA XREF: mwPutBuffer_finalize+32o
					; mwPutBuffer_finalize+50o
aMwputbuffer_wr	db 'mwPutBuffer_write',0 ; DATA XREF: mwPutBuffer_write:loc_1000614Ao
		align 4
aRequestedTypeI	db 'Requested type is already registered',0 ; DATA XREF: mwError+52o
		align 10h
aRequestedTyp_0	db 'Requested type is not registered',0 ; DATA XREF: mwError+5Eo
aSuccess	db 'Success',0          ; DATA XREF: mwError:loc_100068AAo
aGeneralFailure	db 'General failure',0  ; DATA XREF: mwError+1C6o
aRequestDelayed	db 'Request delayed',0  ; DATA XREF: mwError+1AEo
aRequestIsInval	db 'Request is invalid',0 ; DATA XREF: mwError+11Co
aNotAuthorized	db 'Not authorized',0   ; DATA XREF: mwError+14Do
aUserIsNotOnlin	db 'User is not online',0 ; DATA XREF: mwError+132o
					; mwError+1E5o
		align 10h
aRequestedChann	db 'Requested channel is not supported',0 ; DATA XREF: mwError+288o
		align 4
aRequestedCha_0	db 'Requested channel already exists',0 ; DATA XREF: mwError+29Eo
		align 4
aRequestedServi	db 'Requested service is not supported',0 ; DATA XREF: mwError+85o
		align 4
aRequestedProto	db 'Requested protocol is not supported',0
					; DATA XREF: mwError:loc_10006896o
aVersionIsNotSu	db 'Version is not supported',0 ; DATA XREF: mwError+15Co
		align 4
aUserIsInvalidO	db 'User is invalid or not trusted',0 ; DATA XREF: mwError+16Co
aAlreadyInitial	db 'Already initialized',0 ; DATA XREF: mwError+97o
		align 10h
aEncryptionMeth	db 'Encryption method not supported',0 ; DATA XREF: mwError+C3o
aNoCommonEncryp	db 'No common encryption method',0 ; DATA XREF: mwError+ABo
aVersionMismatc	db 'Version mismatch',0 ; DATA XREF: mwError+263o
aMessageIsTooLa	db 'Message is too large',0 ; DATA XREF: mwError+279o
aConnectionBrok	db 'Connection broken',0 ; DATA XREF: mwError+216o
aConnectionAbor	db 'Connection aborted',0 ; DATA XREF: mwError+D5o
aConnectionRefu	db 'Connection refused',0 ; DATA XREF: mwError:loc_100068B4o
aConnectionRese	db 'Connection reset',0 ; DATA XREF: mwError+E7o
aConnectionTime	db 'Connection timed out',0 ; DATA XREF: mwError+FBo
aConnectionClos	db 'Connection closed',0 ; DATA XREF: mwError+10Do
aIncorrectUsern	db 'Incorrect Username/Password',0 ; DATA XREF: mwError+1o
		align 10h
aLoginVerificat	db 'Login verification down or unavailable',0 ; DATA XREF: mwError+22Co
		align 4
aTheGuestNameIs	db 'The guest name is currently being used',0 ; DATA XREF: mwError+206o
		align 10h
aLoginToTwoDiff	db 'Login to two different servers concurrently',0 ; DATA XREF: mwError+1Co
					; mwError+1F7o
aServerMisconfi	db 'Server misconfiguration',0 ; DATA XREF: mwError+1D5o
aUserIsInDoNotD	db 'User is in Do Not Disturb mode',0 ; DATA XREF: mwError+2Eo
aAlreadyLoggedI	db 'Already logged in elsewhere',0 ; DATA XREF: mwError:loc_100068A0o
		align 10h
aCannotRegister	db 'Cannot register a reserved type',0 ; DATA XREF: mwError+40o
; char Format[]
Format		db '0x%08x',0           ; DATA XREF: mwError+186o
		align 4
aBNull_0	db 'b != NULL',0        ; DATA XREF: mwMessage_put:loc_100071C9o
					; mwMessage_get:loc_10007D7Fo
aMeanwhile_2	db 'meanwhile',0        ; DATA XREF: mwMessage_put+639o
					; mwMessage_put+65Ao ...
aMsgNull_0	db 'msg != NULL',0      ; DATA XREF: mwMessage_put:loc_100071EAo
aUnknownMessage	db 'unknown message type 0x%02x',0Ah,0 ; DATA XREF: mwMessage_new+53o
		align 4
aProblemParsi_0	db 'problem parsing message head from buffer',0
					; DATA XREF: mwMessage_get+91Eo
		align 4
aUnknownMessa_0	db 'unknown message type 0x%02x, no parse handler',0
					; DATA XREF: mwMessage_get+99o
		align 4
aProblemParsing	db 'problem parsing message type 0x%02x, not enough data',0
					; DATA XREF: mwMessage_get+554o
aMwmessage_put	db 'mwMessage_put',0    ; DATA XREF: mwMessage_put+631o
					; mwMessage_put+652o
aMwmessage_get	db 'mwMessage_get',0    ; DATA XREF: mwMessage_get+949o
		align 4
aSrvcNull_0	db 'srvc != NULL',0     ; DATA XREF: mwService_removeClientData:loc_10007E21o
					; mwService_getClientData:loc_10007E52o ...
aMeanwhile_3	db 'meanwhile',0        ; DATA XREF: mwService_removeClientData+41o
					; mwService_getClientData+22o ...
aSessNull	db 'sess != NULL',0     ; DATA XREF: mwService_init:loc_10007F41o
aType0x00	db 'type != 0x00',0     ; DATA XREF: mwService_init:loc_10007F5Co
aSNull		db 's != NULL',0        ; DATA XREF: mwService_getSession:loc_10007F92o
					; mwService_getDesc:loc_10007FDAo ...
aSGet_descNull	db 's->get_desc != NULL',0 ; DATA XREF: mwService_getDesc:loc_10007FFAo
aSGet_nameNull	db 's->get_name != NULL',0 ; DATA XREF: mwService_getName:loc_1000805Ao
aNull_0		db '(null)',0           ; DATA XREF: mwService_stopped+2Fo
					; mwService_stop+40o ...
aStoppedService	db 'stopped service %s',0 ; DATA XREF: mwService_stopped+46o
aStoppingServic	db 'stopping service %s',0 ; DATA XREF: mwService_stop+57o
aErrorInService	db 'error in service %s',0 ; DATA XREF: mwService_error+57o
aStartedService	db 'started service %s',0 ; DATA XREF: mwService_started+34o
aStartingServic	db 'starting service %s',0 ; DATA XREF: mwService_start+46o
aChanNull_1	db 'chan != NULL',0     ; DATA XREF: mwService_recv:loc_10008503o
					; mwService_recvDestroy:loc_100085C5o ...
aDataNull_1	db 'data != NULL',0     ; DATA XREF: mwService_recv:loc_1000850Co
		align 10h
aSSessionMwchan	db 's->session == mwChannel_getSession(chan)',0
					; DATA XREF: mwService_recv:loc_10008515o
					; mwService_recvDestroy:loc_100085D7o ...
aMsgNull_1	db 'msg != NULL',0      ; DATA XREF: mwService_recvDestroy:loc_100085CEo
					; mwService_recvAccept:loc_1000869Eo ...
		align 4
aMwchannel_ge_8	db 'mwChannel_getId(chan) == msg->head.channel',0
					; DATA XREF: mwService_recvDestroy:loc_100085E0o
					; mwService_recvAccept:loc_100086B0o
		align 4
aMwchannel_ge_9	db 'mwChannel_getId(chan) == msg->channel',0
					; DATA XREF: mwService_recvCreate:loc_100087A3o
aMwservice_remo	db 'mwService_removeClientData',0
					; DATA XREF: mwService_removeClientData+39o
aMwservice_getc	db 'mwService_getClientData',0 ; DATA XREF: mwService_getClientData+1Ao
aMwservice_setc	db 'mwService_setClientData',0 ; DATA XREF: mwService_setClientData+1Fo
aMwservice_free	db 'mwService_free',0   ; DATA XREF: mwService_free+46o
aMwservice_stop	db 'mwService_stopped',0 ; DATA XREF: mwService_stopped+70o
aMwservice_st_0	db 'mwService_stop',0   ; DATA XREF: mwService_stop+99o
aMwservice_erro	db 'mwService_error',0  ; DATA XREF: mwService_error+99o
aMwservice_star	db 'mwService_started',0 ; DATA XREF: mwService_started+5Eo
aMwservice_st_1	db 'mwService_start',0  ; DATA XREF: mwService_start+88o
aMwservice_gets	db 'mwService_getState',0 ; DATA XREF: mwService_getState+1Ao
aMwservice_init	db 'mwService_init',0   ; DATA XREF: mwService_init+2Do
					; mwService_init+48o ...
aMwservice_ge_0	db 'mwService_getSession',0 ; DATA XREF: mwService_getSession+1Ao
aMwservice_getd	db 'mwService_getDesc',0 ; DATA XREF: mwService_getDesc+22o
					; mwService_getDesc+42o
aMwservice_getn	db 'mwService_getName',0 ; DATA XREF: mwService_getName+22o
					; mwService_getName+42o
aMwservice_gett	db 'mwService_getType',0 ; DATA XREF: mwService_getType+19o
aMwservice_recv	db 'mwService_recv',0   ; DATA XREF: mwService_recv:loc_100084E4o
aMwservice_re_0	db 'mwService_recvDestroy',0
					; DATA XREF: mwService_recvDestroy:loc_100085A6o
aMwservice_re_1	db 'mwService_recvAccept',0 ; DATA XREF: mwService_recvAccept:loc_10008676o
aMwservice_re_2	db 'mwService_recvCreate',0 ; DATA XREF: mwService_recvCreate:loc_10008769o
		align 4
aStopped	db 'stopped',0          ; DATA XREF: sub_100087B0+57o
aUnknown_0	db 'UNKNOWN',0          ; DATA XREF: sub_100087B0+9o
aStarting	db 'starting',0         ; DATA XREF: sub_100087B0+1Fo
aHandshakeSent	db 'handshake sent',0   ; DATA XREF: sub_100087B0+26o
aHandshakeAckno	db 'handshake acknowledged',0 ; DATA XREF: sub_100087B0+2Do
aLoginSent	db 'login sent',0       ; DATA XREF: sub_100087B0+34o
aLoginRedirecte	db 'login redirected',0 ; DATA XREF: sub_100087B0+3Bo
aForcingLogin	db 'forcing login',0    ; DATA XREF: sub_100087B0+18o
aLoginAcknowled	db 'login acknowledged',0 ; DATA XREF: sub_100087B0+42o
aStarted	db 'started',0          ; DATA XREF: sub_100087B0+49o
aStopping	db 'stopping',0         ; DATA XREF: sub_100087B0+50o
		align 4
off_1001D7E4	dd offset loc_100087CE	; DATA XREF: sub_100087B0:loc_100087C0r
		dd offset loc_100087D5	; jump table for switch	statement
		dd offset loc_100087DC
		dd offset loc_100087E3
		dd offset loc_100087EA
		dd offset loc_100087F1
		dd offset loc_100087F8
		dd offset loc_100087FF
		dd offset loc_10008806
		dd offset loc_100087B8
		dd offset loc_100087C7
aSessionNull_0	db 'session != NULL',0  ; DATA XREF: mwSession_getChannels:loc_10008822o
					; mwSession_removeClientData:loc_10008AD9o ...
aMeanwhile_4	db 'meanwhile',0        ; DATA XREF: mwSession_getChannels+22o
					; mwSession_getStateInfo+22o ...
aSNull_0	db 's != NULL',0        ; DATA XREF: mwSession_getStateInfo:loc_10008862o
					; mwSession_getState:loc_100088A2o ...
aSHandlerNull	db 's->handler != NULL',0 ; DATA XREF: sub_100089D0:loc_10008A1Fo
					; sub_100091A0:loc_100092CBo ...
aSHandlerIo_wri	db 's->handler->io_write != NULL',0 ; DATA XREF: sub_100089D0:loc_10008A42o
aSAttributesNul	db 's->attributes != NULL',0
					; DATA XREF: mwSession_removeProperty:loc_10008BC5o
					; mwSession_getProperty:loc_10008E8Eo ...
aKeyNull_0	db 'key != NULL',0      ; DATA XREF: mwSession_removeProperty:loc_10008BE3o
					; mwSession_getProperty:loc_10008EACo ...
aSCiphersNull	db 's->ciphers != NULL',0 ; DATA XREF: mwSession_removeCipher:loc_10008C84o
					; mwSession_getCipher:loc_10008CF7o ...
aSServicesNull	db 's->services != NULL',0
					; DATA XREF: mwSession_removeService:loc_10008D90o
					; mwSession_getService:loc_10008DF3o ...
aCNull		db 'c != NULL',0        ; DATA XREF: mwSession_addCipher:loc_10009158o
aNull_1		db '(null)',0           ; DATA XREF: mwSession_addCipher+4Fo
					; mwSession_addCipher+98o ...
		align 10h
aCipherSIsAlrea	db 'cipher %s is already added, apparently',0
					; DATA XREF: mwSession_addCipher+66o
aAddingCipherS	db 'adding cipher %s',0 ; DATA XREF: mwSession_addCipher+AFo
aSessionStateS0	db 'session state: %s (0x%08x)',0 ; DATA XREF: sub_100091A0+A5o
aSessionStateSS	db 'session state: %s (%s)',0 ; DATA XREF: sub_100091A0+E1o
aSessionStateS	db 'session state: %s',0 ; DATA XREF: sub_100091A0+4Bo
aSrvc0x00	db 'srvc != 0x00',0     ; DATA XREF: mwSession_senseService:loc_100094A4o
aMwsession_isst	db 'mwSession_isStarted(s)',0
					; DATA XREF: mwSession_senseService:loc_100094C2o
					; mwSession_sendAnnounce:loc_100097CDo
aSrvNull	db 'srv != NULL',0      ; DATA XREF: mwSession_addService:loc_10009598o
aStatNull_0	db 'stat != NULL',0     ; DATA XREF: mwSession_setUserStatus:loc_10009662o
aPrivacyNull	db 'privacy != NULL',0  ; DATA XREF: mwSession_setPrivacyInfo:loc_10009712o
		align 4
aMwsession_is_0	db 'mwSession_isState(s, mwSession_LOGIN_REDIR)',0
					; DATA XREF: mwSession_forceLogin:loc_1000986Ao
aAttemptedToSto	db 'attempted to stop session that is already stopped/stopping',0
					; DATA XREF: mwSession_stop:loc_100099D0o
aSHandlerIo_clo	db 's->handler->io_close != NULL',0
					; DATA XREF: mwSession_stop:loc_10009A3Fo
aBufNull	db 'buf != NULL',0      ; DATA XREF: sub_10009A60:loc_1000A1B5o
aParsingOfMessa	db 'parsing of message failed',0 ; DATA XREF: sub_10009A60:loc_10009B71o
aMsgNull_2	db 'msg != NULL',0      ; DATA XREF: sub_10009A60:loc_1000A1D6o
aServer_version	db 'server.version.major',0 ; DATA XREF: sub_10009A60+1C8o
aServer_versi_0	db 'server.version.minor',0 ; DATA XREF: sub_10009A60+1E8o
aClient_id	db 'client.id',0        ; DATA XREF: sub_10009A60+205o
					; mwSession_start+F4o ...
aSession_auth_u	db 'session.auth.user',0 ; DATA XREF: sub_10009A60+217o
aSession_auth_p	db 'session.auth.password',0 ; DATA XREF: sub_10009A60+235o
		align 10h
aMwsession_is_2	db 'mwSession_isState(s, mwSession_LOGIN)',0
					; DATA XREF: sub_10009A60:loc_1000A1F7o
aChanNull_2	db 'chan != NULL',0     ; DATA XREF: sub_10009A60:loc_1000A218o
aSet_privacy_li	db 'SET_PRIVACY_LIST',0 ; DATA XREF: sub_10009A60+5AAo
aUnknownMessa_1	db 'unknown message type 0x%04x, no handler',0
					; DATA XREF: sub_10009A60+167o
aMwsession_is_1	db 'mwSession_isState(s, mwSession_HANDSHAKE) || mwSession_isState(s,'
					; DATA XREF: sub_10009A60+60Eo
		db ' mwSession_LOGIN_CONT)',0
aMwsession_is_3	db 'mwSession_isStopped(s)',0 ; DATA XREF: mwSession_start:loc_1000A629o
		align 4
aAttemptedToSta	db 'attempted to start session that is already started/starting',0
					; DATA XREF: mwSession_start:loc_1000A4F4o
aClient_version	db 'client.version.major',0 ; DATA XREF: mwSession_start+D6o
					; mwSession_new+A1o
aClient_versi_0	db 'client.version.minor',0 ; DATA XREF: mwSession_start+E4o
					; mwSession_new+BCo
aClient_ip	db 'client.ip',0        ; DATA XREF: mwSession_start+104o
aClient_host	db 'client.host',0      ; DATA XREF: mwSession_start+1BAo
aSessionIsNotSt	db 'session is not stopped (state: %s), proceeding with free',0
					; DATA XREF: mwSession_free+27o
aHandlerNull	db 'handler != NULL',0  ; DATA XREF: mwSession_new:loc_1000A860o
aHandlerIo_writ	db 'handler->io_write != NULL',0 ; DATA XREF: mwSession_new:loc_1000A880o
aHandlerIo_clos	db 'handler->io_close != NULL',0 ; DATA XREF: mwSession_new:loc_1000A8A0o
aMwsession_remo	db 'mwSession_removeClientData',0
					; DATA XREF: mwSession_removeClientData+21o
aMwsession_ge_1	db 'mwSession_getClientData',0 ; DATA XREF: mwSession_getClientData+21o
aMwsession_setc	db 'mwSession_setClientData',0 ; DATA XREF: mwSession_setClientData+29o
aMwsession_re_0	db 'mwSession_removeProperty',0 ; DATA XREF: mwSession_removeProperty+2Fo
					; mwSession_removeProperty+4Do	...
aMwsession_ge_4	db 'mwSession_getProperty',0 ; DATA XREF: mwSession_getProperty+26o
					; mwSession_getProperty+46o ...
aMwsession_setp	db 'mwSession_setProperty',0
					; DATA XREF: mwSession_setProperty:loc_10008F4Eo
aMwsession_ge_5	db 'mwSession_getCiphers',0 ; DATA XREF: mwSession_getCiphers+25o
					; mwSession_getCiphers+45o
aMwsession_re_1	db 'mwSession_removeCipher',0 ; DATA XREF: mwSession_removeCipher+5Eo
					; mwSession_removeCipher+7Eo
aMwsession_ge_2	db 'mwSession_getCipher',0 ; DATA XREF: mwSession_getCipher+2Fo
					; mwSession_getCipher+4Fo
aMwsession_addc	db 'mwSession_addCipher',0 ; DATA XREF: mwSession_addCipher+FDo
					; mwSession_addCipher+120o ...
aMwsession_sens	db 'mwSession_senseService',0 ; DATA XREF: mwSession_senseService+63o
					; mwSession_senseService+8Co ...
aMwsession_ge_6	db 'mwSession_getServices',0 ; DATA XREF: mwSession_getServices+25o
					; mwSession_getServices+45o
aMwsession_re_2	db 'mwSession_removeService',0 ; DATA XREF: mwSession_removeService+5Ao
					; mwSession_removeService+7Ao
aMwsession_ge_3	db 'mwSession_getService',0 ; DATA XREF: mwSession_getService+2Bo
					; mwSession_getService+4Bo
aMwsession_adds	db 'mwSession_addService',0 ; DATA XREF: mwSession_addService+A0o
					; mwSession_addService+C0o ...
aMwsession_getc	db 'mwSession_getChannels',0 ; DATA XREF: mwSession_getChannels+1Ao
aMwsession_gets	db 'mwSession_getStateInfo',0 ; DATA XREF: mwSession_getStateInfo+1Ao
aMwsession_ge_0	db 'mwSession_getState',0 ; DATA XREF: mwSession_getState+1Ao
aMwsession_getu	db 'mwSession_getUserStatus',0 ; DATA XREF: mwSession_getUserStatus+1Ao
aMwsession_setu	db 'mwSession_setUserStatus',0 ; DATA XREF: mwSession_setUserStatus+6Co
					; mwSession_setUserStatus+8Fo
aMwsession_getp	db 'mwSession_getPrivacyInfo',0 ; DATA XREF: mwSession_getPrivacyInfo+1Ao
aMwsession_se_1	db 'mwSession_setPrivacyInfo',0 ; DATA XREF: mwSession_setPrivacyInfo+6Co
					; mwSession_setPrivacyInfo+8Fo
aMwsession_getl	db 'mwSession_getLoginInfo',0 ; DATA XREF: mwSession_getLoginInfo+1Ao
aMwsession_geth	db 'mwSession_getHandler',0 ; DATA XREF: mwSession_getHandler+19o
aMwsession_se_2	db 'mwSession_sendAnnounce',0 ; DATA XREF: mwSession_sendAnnounce+77o
					; mwSession_sendAnnounce+9Ao
aMwsession_forc	db 'mwSession_forceLogin',0 ; DATA XREF: mwSession_forceLogin+64o
					; mwSession_forceLogin+87o
aState_0	db 'state',0            ; DATA XREF: sub_100091A0+112o
					; sub_100091A0+133o
aMwsession_send	db 'mwSession_sendKeepalive',0 ; DATA XREF: mwSession_sendKeepalive+28o
aIo_write	db 'io_write',0         ; DATA XREF: sub_100089D0+34o
					; sub_100089D0+57o ...
aMwsession_se_0	db 'mwSession_send',0   ; DATA XREF: mwSession_send+B9o
aMwsession_recv	db 'mwSession_recv',0   ; DATA XREF: mwSession_recv+253o
aSession_proces	db 'session_process',0  ; DATA XREF: sub_10009A60+71Bo
					; sub_10009A60+75Do ...
aHandshake_ack_	db 'HANDSHAKE_ACK_recv',0 ; DATA XREF: sub_10009A60+616o
aLogin_ack_recv	db 'LOGIN_ACK_recv',0   ; DATA XREF: sub_10009A60+79Fo
aChannel_accept	db 'CHANNEL_ACCEPT_recv',0 ; DATA XREF: sub_10009A60+7C0o
aSession_buf_fr	db 'session_buf_free',0 ; DATA XREF: sub_10009890+3Bo
aMwsession_stop	db 'mwSession_stop',0   ; DATA XREF: mwSession_stop+118o
aIo_close	db 'io_close',0         ; DATA XREF: mwSession_stop+136o
					; mwSession_stop+157o
aMwsession_star	db 'mwSession_start',0  ; DATA XREF: mwSession_start+160o
					; mwSession_start+181o
aMwsession_free	db 'mwSession_free',0   ; DATA XREF: mwSession_free+C8o
aMwsession_new	db 'mwSession_new',0    ; DATA XREF: mwSession_new+FAo
					; mwSession_new+11Ao ...
		align 20h
aPresenceAwaren	db 'Presence Awareness',0 ; DATA XREF: sub_1000A8C0+1o
		align 4
aBuddyListServi	db 'Buddy list service with support for server-side groups',0
					; DATA XREF: sub_1000A8D0+1o
aListNull	db 'list != NULL',0     ; DATA XREF: mwAwareList_getHandler:loc_1000A912o
					; sub_1000A9C0:loc_1000A9E3o ...
aMeanwhile_5	db 'meanwhile',0        ; DATA XREF: mwAwareList_getHandler+22o
					; mwAwareAttribute_asOpaque+22o ...
aAttribNull	db 'attrib != NULL',0   ; DATA XREF: mwAwareAttribute_asOpaque:loc_1000A952o
					; mwAwareAttribute_getKey:loc_1000A991o
aListEntriesNul	db 'list->entries != NULL',0 ; DATA XREF: sub_1000A9C0:loc_1000AA03o
aSrchNull	db 'srch != NULL',0     ; DATA XREF: sub_1000A9C0:loc_1000AA23o
					; sub_1000AA50:loc_1000AAB3o
aSrvcNull_1	db 'srvc != NULL',0     ; DATA XREF: sub_1000AA50:loc_1000AA73o
					; mwServiceAware_getText:loc_1000AB06o	...
aSrvcEntriesNul	db 'srvc->entries != NULL',0 ; DATA XREF: sub_1000AA50:loc_1000AA93o
aUserNull_0	db 'user != NULL',0     ; DATA XREF: mwServiceAware_getText:loc_1000AB26o
					; mwServiceAware_getAttribute:loc_1000ABB0o ...
aKey0x00	db 'key != 0x00',0      ; DATA XREF: mwServiceAware_getAttribute:loc_1000ABCEo
aAwareNull	db 'aware != NULL',0    ; DATA XREF: mwServiceAware_getAttribute:loc_1000ABECo
					; sub_1000C470:loc_1000C550o
aStatNull_1	db 'stat != NULL',0     ; DATA XREF: mwServiceAware_setStatus:loc_1000AD1Eo
aChanNull_3	db 'chan != NULL',0     ; DATA XREF: sub_1000AEB0:loc_1000AF11o
					; sub_1000AFE0:loc_1000B0E4o
aBringOutYourDe	db 'bring out your dead *clang*',0 ; DATA XREF: sub_1000AFE0+1Do
aRemoving0x08x	db ' removing 0x%08x',0 ; DATA XREF: sub_1000B1B0+23o
aNull_2		db '(null)',0           ; DATA XREF: sub_1000B220+23o
					; mwAwareList_removeAware+73o
aRemovingSS	db ' removing %s, %s',0 ; DATA XREF: sub_1000B220+2Bo
aBuddySSNotInLi	db 'buddy %s, %s not in list',0 ; DATA XREF: mwAwareList_removeAware+7Bo
aHandlerNull_0	db 'handler != NULL',0  ; DATA XREF: mwAwareList_new:loc_1000B481o
					; mwServiceAware_new:loc_1000C38Fo
aIdUserNull	db 'id->user != NULL',0 ; DATA XREF: mwAwareList_addAware:loc_1000B6D4o
aStrlenIdUser0	db 'strlen(id->user) > 0',0 ; DATA XREF: mwAwareList_addAware:loc_1000B6F5o
aGrpNull	db 'grp != NULL',0      ; DATA XREF: sub_1000B7C0:loc_1000B828o
aListAttribsNul	db 'list->attribs != NULL',0
					; DATA XREF: mwAwareList_getWatchedAttributes:loc_1000B8C2o
aSrvcChannelNul	db 'srvc->channel != NULL',0 ; DATA XREF: sub_1000B8F0:loc_1000B9D3o
					; sub_1000C8B0:loc_1000C93Do
aListServiceNul	db 'list->service != NULL',0
					; DATA XREF: mwAwareList_watchAttributeArray:loc_1000BA6Do
					; mwAwareList_unwatchAttributeArray:loc_1000BC2Do ...
aCollectingDead	db 'collecting dead attributes',0 ; DATA XREF: sub_1000BA90+17o
aWatchNull	db 'watch != NULL',0    ; DATA XREF: mwAwareList_unwatchAttributes:loc_1000BCD8o
aSessionNull_1	db 'session != NULL',0  ; DATA XREF: mwServiceAware_new:loc_1000C36Fo
aSrvc_awareChan	db 'srvc_aware->channel == chan',0 ; DATA XREF: sub_1000C570:loc_1000C82Bo
		align 10h
aSrvcSessionMwc	db 'srvc->session == mwChannel_getSession(chan)',0
					; DATA XREF: sub_1000C570:loc_1000C84Co
aDataNull_2	db 'data != NULL',0     ; DATA XREF: sub_1000C570:loc_1000C86Do
		align 4
aUnknownMessa_2	db 'unknown message in aware service: 0x%04x',0
					; DATA XREF: sub_1000C570+F7o
aSrvcChannelCha	db 'srvc->channel == chan',0 ; DATA XREF: sub_1000C8B0:loc_1000C963o
aMwserviceaware	db 'mwServiceAware_getText',0 ; DATA XREF: mwServiceAware_getText+2Eo
					; mwServiceAware_getText+4Eo
aAware_find	db 'aware_find',0       ; DATA XREF: sub_1000AA50+2Bo
					; sub_1000AA50+4Bo ...
aMwserviceawa_0	db 'mwServiceAware_getAttribute',0
					; DATA XREF: mwServiceAware_getAttribute+44o
					; mwServiceAware_getAttribute+68o ...
aMwserviceawa_1	db 'mwServiceAware_setStatus',0 ; DATA XREF: mwServiceAware_setStatus+7Ao
					; mwServiceAware_setStatus+98o	...
aMwawarelist_re	db 'mwAwareList_removeClientData',0
					; DATA XREF: mwAwareList_removeClientData+21o
aMwawarelist__0	db 'mwAwareList_getClientData',0 ; DATA XREF: mwAwareList_getClientData+21o
aMwawarelist_se	db 'mwAwareList_setClientData',0 ; DATA XREF: mwAwareList_setClientData+29o
aMwawarelist__1	db 'mwAwareList_removeAllAware',0
					; DATA XREF: mwAwareList_removeAllAware+57o
					; mwAwareList_removeAllAware+82o
aSend_rem	db 'send_rem',0         ; DATA XREF: sub_1000AFE0+10Eo
aMwawarelist__2	db 'mwAwareList_removeAware',0 ; DATA XREF: mwAwareList_removeAware+C2o
					; mwAwareList_removeAware+EBo
aList_aware_fin	db 'list_aware_find',0  ; DATA XREF: sub_1000A9C0+2Bo
					; sub_1000A9C0+4Bo ...
aMwawarelist_ad	db 'mwAwareList_addAware',0 ; DATA XREF: mwAwareList_addAware+1FFo
					; mwAwareList_addAware+225o
aList_add	db 'list_add',0         ; DATA XREF: mwAwareList_addAware+15Co
					; mwAwareList_addAware+17Do
aSend_add	db 'send_add',0         ; DATA XREF: sub_1000AEB0+6Bo
		align 20h
aMwawarelist__3	db 'mwAwareList_getWatchedAttributes',0
					; DATA XREF: mwAwareList_getWatchedAttributes+5Ao
					; mwAwareList_getWatchedAttributes+7Ao
		align 20h
aMwawarelist_un	db 'mwAwareList_unwatchAllAttributes',0
					; DATA XREF: mwAwareList_unwatchAllAttributes+53o
aSend_attrib_li	db 'send_attrib_list',0 ; DATA XREF: sub_1000B8F0+CDo
					; sub_1000B8F0+EDo
aMwawarelist__5	db 'mwAwareList_unwatchAttributes',0
					; DATA XREF: mwAwareList_unwatchAttributes+C1o
					; mwAwareList_unwatchAttributes+E4o
aWatch_remove	db 'watch_remove',0     ; DATA XREF: mwAwareList_unwatchAttributes+90o
		align 10h
aMwawarelist__4	db 'mwAwareList_unwatchAttributeArray',0
					; DATA XREF: mwAwareList_unwatchAttributeArray+4Bo
					; mwAwareList_unwatchAttributeArray+75o
aMwawarelist__6	db 'mwAwareList_watchAttributes',0
					; DATA XREF: mwAwareList_watchAttributes+4Co
					; mwAwareList_watchAttributes+6Fo
		align 10h
aMwawarelist_wa	db 'mwAwareList_watchAttributeArray',0
					; DATA XREF: mwAwareList_watchAttributeArray+4Bo
					; mwAwareList_watchAttributeArray+75o
aMwawarelist_ge	db 'mwAwareList_getHandler',0 ; DATA XREF: mwAwareList_getHandler+1Ao
aMwawarelist_fr	db 'mwAwareList_free',0 ; DATA XREF: mwAwareList_free+78o
					; mwAwareList_free+9Bo
aMwawarelist_ne	db 'mwAwareList_new',0  ; DATA XREF: mwAwareList_new+5Bo
					; mwAwareList_new+7Bo
aMwawareattribu	db 'mwAwareAttribute_asOpaque',0 ; DATA XREF: mwAwareAttribute_asOpaque+1Ao
aMwawareattri_0	db 'mwAwareAttribute_getKey',0 ; DATA XREF: mwAwareAttribute_getKey+19o
aMwserviceawa_2	db 'mwServiceAware_new',0 ; DATA XREF: mwServiceAware_new+E9o
					; mwServiceAware_new+109o
aClear		db 'clear',0            ; DATA XREF: sub_1000BEA0+53o
aRecv		db 'recv',0             ; DATA XREF: sub_1000C570+2C3o
					; sub_1000C570+2E4o ...
aGroup_member_r	db 'group_member_recv',0 ; DATA XREF: sub_1000B7C0+70o
aAttrib_recv	db 'attrib_recv',0      ; DATA XREF: sub_1000C470+E8o
aRecv_accept	db 'recv_accept',0      ; DATA XREF: sub_1000C8B0:loc_1000C944o
		align 10h
aBasicConferenc	db 'Basic Conferencing',0 ; DATA XREF: sub_1000C980+1o
		align 4
aMultiUserPlain	db 'Multi-user plain-text conferencing',0 ; DATA XREF: sub_1000C990+1o
aSrvcNull_2	db 'srvc != NULL',0     ; DATA XREF: mwServiceConference_getHandler:loc_1000C9B2o
					; sub_1000CAA0:loc_1000CACFo ...
aMeanwhile_6	db 'meanwhile',0        ; DATA XREF: mwServiceConference_getHandler+22o
					; mwConference_getTitle+22o ...
aConfNull	db 'conf != NULL',0     ; DATA XREF: mwConference_getTitle:loc_1000C9F2o
					; mwConference_getName:loc_1000CA32o ...
aChanNull_4	db 'chan != NULL',0     ; DATA XREF: sub_1000CAA0:loc_1000CAEFo
aConferenceNull	db 'conference != NULL',0
					; DATA XREF: mwConference_removeClientData:loc_1000CB69o
					; mwConference_getClientData:loc_1000CBA9o ...
aConfChannelNul	db 'conf->channel != NULL',0
					; DATA XREF: mwConference_sendTyping:loc_1000CCE7o
					; mwConference_sendText:loc_1000CDD4o ...
		align 4
aConfStateMwcon	db 'conf->state == mwConference_OPEN',0
					; DATA XREF: mwConference_sendTyping:loc_1000CD0Ao
aWhoNull	db 'who != NULL',0      ; DATA XREF: mwConference_invite:loc_1000CF02o
		align 4
aConfStateMwc_0	db 'conf->state == mwConference_INVITED',0
					; DATA XREF: mwConference_accept:loc_1000CFA1o
aError_0	db 'error',0            ; DATA XREF: sub_1000D170:loc_1000D1C7o
aUnknown_1	db 'UNKNOWN',0          ; DATA XREF: sub_1000D170+11o
aNew_0		db 'new',0              ; DATA XREF: sub_1000D170:loc_1000D1EEo
aPending	db 'pending',0          ; DATA XREF: sub_1000D170:loc_1000D1E7o
aInvited	db 'invited',0          ; DATA XREF: sub_1000D170:loc_1000D1E0o
aOpen_0		db 'open',0             ; DATA XREF: sub_1000D170:loc_1000D1D9o
aClosing_0	db 'closing',0          ; DATA XREF: sub_1000D170:loc_1000D1D2o
aNull_3		db '(null)',0           ; DATA XREF: sub_1000D170+1Do
aConferenceSSta	db 'conference %s state: %s',0 ; DATA XREF: sub_1000D170+26o
		align 4
off_1001E698	dd offset loc_1000D1EE	; DATA XREF: sub_1000D170:loc_1000D1C0r
		dd offset loc_1000D1E7	; jump table for switch	statement
		dd offset loc_1000D1E0
		dd offset loc_1000D1D9
		dd offset loc_1000D1D2
		dd offset loc_1000D1C7
aConfServiceNul	db 'conf->service != NULL',0 ; DATA XREF: mwConference_open:loc_1000D47Eo
		align 4
aConfStateMwc_1	db 'conf->state == mwConference_NEW',0
					; DATA XREF: mwConference_open:loc_1000D4A4o
aConfChannelN_0	db 'conf->channel == NULL',0 ; DATA XREF: mwConference_open:loc_1000D4CAo
aSessionNull_2	db 'session != NULL',0  ; DATA XREF: mwConference_open:loc_1000D4F0o
					; mwServiceConference_new:loc_1000D704o
aSession_auth_0	db 'session.auth.user',0 ; DATA XREF: mwConference_open:loc_1000D3BCo
					; sub_1000D580+50o
aS08x04x	db '%s(%08x,%04x)',0    ; DATA XREF: mwConference_open+178o
		align 10h
aGeneratedRando	db 'generated random conference name: ',27h,'%s',27h,0
					; DATA XREF: mwConference_open+18Eo
aConfMembersNul	db 'conf->members != NULL',0
					; DATA XREF: mwConference_getMembers:loc_1000D55Do
aHandlerNull_1	db 'handler != NULL',0  ; DATA XREF: mwServiceConference_new:loc_1000D724o
		align 10h
aErrorParsingWe	db 'error parsing welcome message for conference',0
					; DATA XREF: sub_1000D750:loc_1000DAB1o
		align 10h
aFailedParsingJ	db 'failed parsing JOIN message in conference',0
					; DATA XREF: sub_1000D750+292o
		align 4
aReceivedMessag	db 'received message type 0x%04x from unknown conference member %u',0
					; DATA XREF: sub_1000D750+4ABo
		align 4
aFailedToParseT	db 'failed to parse text message in conference',0
					; DATA XREF: sub_1000D750:loc_1000DC20o
		align 4
aUnknownDataMes	db 'unknown data message type (0x%08x, 0x%08x)',0
					; DATA XREF: sub_1000D750+42Eo
		align 4
aUnknownMessa_3	db 'unknown message type 0x%4x received in conference',0
					; DATA XREF: sub_1000D750+22Eo
		align 4
aFailureParsing	db 'failure parsing addtl for conference invite',0
					; DATA XREF: sub_1000DC50+A2o
		align 10h
aMwservicecon_0	db 'mwServiceConference_getConferences',0
					; DATA XREF: mwServiceConference_getConferences+21o
		align 4
aMwserviceconfe	db 'mwServiceConference_getHandler',0
					; DATA XREF: mwServiceConference_getHandler+1Ao
aMwconference_r	db 'mwConference_removeClientData',0
					; DATA XREF: mwConference_removeClientData+21o
aMwconference_2	db 'mwConference_getClientData',0
					; DATA XREF: mwConference_getClientData+21o
aMwconference_s	db 'mwConference_setClientData',0
					; DATA XREF: mwConference_setClientData+29o
aMwconference_3	db 'mwConference_sendTyping',0 ; DATA XREF: mwConference_sendTyping+C1o
					; mwConference_sendTyping+E4o ...
aMwconference_4	db 'mwConference_sendText',0 ; DATA XREF: mwConference_sendText+8Eo
					; mwConference_sendText+B1o
aMwconference_i	db 'mwConference_invite',0 ; DATA XREF: mwConference_invite+C9o
					; mwConference_invite+ECo ...
aMwconference_a	db 'mwConference_accept',0 ; DATA XREF: mwConference_accept+56o
					; mwConference_accept+79o
aMwconference_d	db 'mwConference_destroy',0 ; DATA XREF: mwConference_destroy+A4o
					; mwConference_destroy+C7o
aConf_free	db 'conf_free',0        ; DATA XREF: sub_1000CFD0+67o
aMwconference_o	db 'mwConference_open',0 ; DATA XREF: mwConference_open+1C5o
					; mwConference_open+1EBo ...
aConf_state	db 'conf_state',0       ; DATA XREF: sub_1000D170+8Do
aMwconference_5	db 'mwConference_getMembers',0 ; DATA XREF: mwConference_getMembers+25o
					; mwConference_getMembers+45o
aMwconference_g	db 'mwConference_getTitle',0 ; DATA XREF: mwConference_getTitle+1Ao
aMwconference_0	db 'mwConference_getName',0 ; DATA XREF: mwConference_getName+1Ao
aMwconference_1	db 'mwConference_getService',0 ; DATA XREF: mwConference_getService+1Ao
aMwconference_n	db 'mwConference_new',0 ; DATA XREF: mwConference_new+35o
aMwservicecon_1	db 'mwServiceConference_new',0 ; DATA XREF: mwServiceConference_new+9Eo
					; mwServiceConference_new+BEo
aRecv_0		db 'recv',0             ; DATA XREF: sub_1000D750+45Bo
aConf_find	db 'conf_find',0        ; DATA XREF: sub_1000CAA0+37o
					; sub_1000CAA0+57o
		align 10h
aAddressBookAnd	db 'Address Book and Directory',0 ; DATA XREF: sub_1000DDC0+1o
		align 4
aAddressBookDir	db 'Address book directory service for user and group lookups',0
					; DATA XREF: sub_1000DDD0+1o
aDirNull	db 'dir != NULL',0      ; DATA XREF: mwDirectory_getAddressBook:loc_1000DE92o
					; mwDirectory_getService:loc_1000DED8o	...
aMeanwhile_7	db 'meanwhile',0        ; DATA XREF: mwDirectory_getAddressBook+22o
					; mwDirectory_getService+28o ...
aDirBookNull	db 'dir->book != NULL',0 ; DATA XREF: mwDirectory_getService:loc_1000DEF8o
aBookNull	db 'book != NULL',0     ; DATA XREF: mwDirectory_new:loc_1000DF98o
					; mwAddressBook_getName:loc_1000DFF2o ...
aBookServiceNul	db 'book->service != NULL',0 ; DATA XREF: mwDirectory_new:loc_1000DFB8o
aSrvcNull_3	db 'srvc != NULL',0     ; DATA XREF: mwServiceDirectory_getHandler:loc_1000E032o
					; mwDirectory_destroy:loc_1000E15Ao ...
aChanNull_5	db 'chan != NULL',0     ; DATA XREF: mwDirectory_destroy:loc_1000E180o
					; mwServiceDirectory_refreshAddressBooks:loc_1000E248o	...
aMw_directory_i	db 'MW_DIRECTORY_IS_OPEN(dir)',0
					; DATA XREF: mwDirectory_previous:loc_1000E34Do
					; mwDirectory_next:loc_1000E49Do ...
aQueryNull	db 'query != NULL',0    ; DATA XREF: mwDirectory_search:loc_1000E639o
aQuery0		db '*query != ',27h,'\0',27h,0 ; DATA XREF: mwDirectory_search:loc_1000E65Co
aCbNull		db 'cb != NULL',0       ; DATA XREF: mwDirectory_open:loc_1000E7D6o
aMw_directory_0	db 'MW_DIRECTORY_IS_NEW(dir)',0 ; DATA XREF: mwDirectory_open:loc_1000E7F9o
aBookDirsNull	db 'book->dirs != NULL',0
					; DATA XREF: mwAddressBook_getDirectories:loc_1000E96Do
aSrvcBooksNull	db 'srvc->books != NULL',0
					; DATA XREF: mwServiceDirectory_getAddressBooks:loc_1000E9CDo
					; mwServiceDirectory_getDirectories:loc_1000EA6Co
aSessionNull_3	db 'session != NULL',0  ; DATA XREF: mwServiceDirectory_new:loc_1000EB66o
aHandlerNull_2	db 'handler != NULL',0  ; DATA XREF: mwServiceDirectory_new:loc_1000EB86o
aChanSrvcChanne	db 'chan == srvc->channel',0 ; DATA XREF: sub_1000EC50:loc_1000EE47o
aDataNull_3	db 'data != NULL',0     ; DATA XREF: sub_1000EC50:loc_1000EE68o
aReceivedStrang	db 'received strange address book list',0 ; DATA XREF: sub_1000EC50+D1o
		align 4
aMsgType0x04xIn	db 'msg type 0x%04x in directory service',0 ; DATA XREF: sub_1000EC50+4Fo
aSrvcChannelN_0	db 'srvc->channel != NULL',0 ; DATA XREF: sub_1000EEB0:loc_1000EF11o
aSrvcChannelC_0	db 'srvc->channel == chan',0 ; DATA XREF: sub_1000EEB0:loc_1000EF34o
aMwdirectory_de	db 'mwDirectory_destroy',0 ; DATA XREF: mwDirectory_destroy+E1o
aDir_close	db 'dir_close',0        ; DATA XREF: mwDirectory_destroy+107o
					; mwDirectory_destroy+12Do
aMwdirectory_se	db 'mwDirectory_search',0 ; DATA XREF: mwDirectory_search+F0o
					; mwDirectory_search+113o ...
aMwdirectory_pr	db 'mwDirectory_previous',0 ; DATA XREF: mwDirectory_previous+C7o
					; mwDirectory_previous+EAo ...
aMwdirectory__2	db 'mwDirectory_next',0 ; DATA XREF: mwDirectory_next+C7o
					; mwDirectory_next+EAo	...
aMwdirectory_op	db 'mwDirectory_open',0 ; DATA XREF: mwDirectory_open+F0o
					; mwDirectory_open+113o ...
aDir_open	db 'dir_open',0         ; DATA XREF: mwDirectory_open+159o
					; mwDirectory_open+17Fo
aMwdirectory_ge	db 'mwDirectory_getAddressBook',0
					; DATA XREF: mwDirectory_getAddressBook+1Ao
aMwdirectory__0	db 'mwDirectory_getService',0 ; DATA XREF: mwDirectory_getService+20o
					; mwDirectory_getService+40o
aMwdirectory_re	db 'mwDirectory_removeClientData',0
					; DATA XREF: mwDirectory_removeClientData+21o
aMwdirectory__3	db 'mwDirectory_getClientData',0 ; DATA XREF: mwDirectory_getClientData+21o
aMwdirectory__4	db 'mwDirectory_setClientData',0 ; DATA XREF: mwDirectory_setClientData+29o
aMwdirectory__1	db 'mwDirectory_getState',0 ; DATA XREF: mwDirectory_getState+1Ao
aMwdirectory_ne	db 'mwDirectory_new',0  ; DATA XREF: mwDirectory_new+40o
					; mwDirectory_new+60o
aMwaddressbook_	db 'mwAddressBook_getName',0 ; DATA XREF: mwAddressBook_getName+1Ao
aMwaddressboo_0	db 'mwAddressBook_getDirectories',0
					; DATA XREF: mwAddressBook_getDirectories+25o
					; mwAddressBook_getDirectories+45o
		align 20h
aMwservicedir_2	db 'mwServiceDirectory_getDirectories',0
					; DATA XREF: mwServiceDirectory_getDirectories+66o
					; mwServiceDirectory_getDirectories+86o
		align 20h
aMwservicedir_1	db 'mwServiceDirectory_getAddressBooks',0
					; DATA XREF: mwServiceDirectory_getAddressBooks+25o
					; mwServiceDirectory_getAddressBooks+45o
		align 20h
aMwservicedir_0	db 'mwServiceDirectory_refreshAddressBooks',0
					; DATA XREF: mwServiceDirectory_refreshAddressBooks+82o
					; mwServiceDirectory_refreshAddressBooks+A5o
aMwservicedirec	db 'mwServiceDirectory_getHandler',0
					; DATA XREF: mwServiceDirectory_getHandler+1Ao
aMwservicedir_3	db 'mwServiceDirectory_new',0 ; DATA XREF: mwServiceDirectory_new+E0o
					; mwServiceDirectory_new+100o
aRecv_1		db 'recv',0             ; DATA XREF: sub_1000EC50+1BDo
					; sub_1000EC50+1DEo ...
aRecv_accept_0	db 'recv_accept',0      ; DATA XREF: sub_1000EEB0:loc_1000EF18o
		align 20h
aFileTransfer	db 'File Transfer',0    ; DATA XREF: sub_1000F050+1o
		align 10h
aProvidesFileTr	db 'Provides file transfer capabilities through the community server',0
					; DATA XREF: sub_1000F060+1o
aFtNull		db 'ft != NULL',0       ; DATA XREF: mwFileTransfer_getRemaining:loc_1000F082o
					; mwFileTransfer_getFileSize:loc_1000F0C2o ...
aMeanwhile_8	db 'meanwhile',0        ; DATA XREF: mwFileTransfer_getRemaining+22o
					; mwFileTransfer_getFileSize+22o ...
aSrvcNull_4	db 'srvc != NULL',0     ; DATA XREF: mwServiceFileTransfer_getTransfers:loc_1000F242o
					; mwServiceFileTransfer_getHandler:loc_1000F282o ...
aChanNull_6	db 'chan != NULL',0     ; DATA XREF: mwFileTransfer_ack:loc_1000F3DAo
aMwchannel_is_0	db 'mwChannel_isIncoming(chan)',0
					; DATA XREF: mwFileTransfer_ack:loc_1000F3FDo
aMwfiletrans_11	db 'mwFileTransfer_isOpen(ft)',0
					; DATA XREF: mwFileTransfer_send:loc_1000F4C4o
					; sub_1000FF10:loc_10010040o
aFtChannelNull	db 'ft->channel != NULL',0 ; DATA XREF: mwFileTransfer_send:loc_1000F4E7o
					; mwFileTransfer_accept:loc_1000FB2Do
aMwchannel_is_1	db 'mwChannel_isOutgoing(chan)',0
					; DATA XREF: mwFileTransfer_send:loc_1000F50Do
aError_1	db 'error',0            ; DATA XREF: sub_1000F5D0:loc_1000F64Eo
aUnknown_2	db 'UNKNOWN',0          ; DATA XREF: sub_1000F5D0+23o
aNew_1		db 'new',0              ; DATA XREF: sub_1000F5D0:loc_1000F678o
aPending_0	db 'pending',0          ; DATA XREF: sub_1000F5D0:loc_1000F671o
aOpen_1		db 'open',0             ; DATA XREF: sub_1000F5D0:loc_1000F66Ao
aCancelledLocal	db 'cancelled locally',0 ; DATA XREF: sub_1000F5D0:loc_1000F663o
aCancelledRemot	db 'cancelled remotely',0 ; DATA XREF: sub_1000F5D0:loc_1000F65Co
aDone		db 'done',0             ; DATA XREF: sub_1000F5D0:loc_1000F655o
aNull_4		db '(null)',0           ; DATA XREF: sub_1000F5D0+2Do
aSettingFtSSSta	db 'setting ft (%s, %s) state: %s',0 ; DATA XREF: sub_1000F5D0+39o
		align 4
off_1001F054	dd offset loc_1000F678	; DATA XREF: sub_1000F5D0:loc_1000F647r
		dd offset loc_1000F671	; jump table for switch	statement
		dd offset loc_1000F66A
		dd offset loc_1000F663
		dd offset loc_1000F65C
		dd offset loc_1000F655
		dd offset loc_1000F64E
aHandlerNull_3	db 'handler != NULL',0  ; DATA XREF: mwFileTransfer_close:loc_1000F767o
					; mwServiceFileTransfer_new:loc_1000FD94o
aFtChannelNul_0	db 'ft->channel == NULL',0 ; DATA XREF: mwFileTransfer_offer:loc_1000F973o
					; mwFileTransfer_offer:loc_1000FA26o
aMwfiletrans_14	db 'mwFileTransfer_isNew(ft)',0
					; DATA XREF: mwFileTransfer_offer:loc_1000F996o
					; mwFileTransfer_offer:loc_1000FA05o
aFtServiceNull	db 'ft->service != NULL',0 ; DATA XREF: mwFileTransfer_offer:loc_1000F9B9o
					; mwFileTransfer_accept:loc_1000FBC2o
aSrvcHandlerNul	db 'srvc->handler != NULL',0 ; DATA XREF: mwFileTransfer_offer:loc_1000F9DFo
					; mwFileTransfer_accept:loc_1000FBE8o ...
aMwfiletrans_16	db 'mwFileTransfer_isPending(ft)',0
					; DATA XREF: mwFileTransfer_accept:loc_1000FB50o
aMwchannel_is_2	db 'mwChannel_isIncoming(ft->channel)',0
					; DATA XREF: mwFileTransfer_accept:loc_1000FB76o
		align 4
aMwchannel_isst	db 'mwChannel_isState(ft->channel, mwChannel_WAIT)',0
					; DATA XREF: mwFileTransfer_accept:loc_1000FB9Co
aWhoNull_0	db 'who != NULL',0      ; DATA XREF: mwFileTransfer_new:loc_1000FCBFo
aSessionNull_4	db 'session != NULL',0  ; DATA XREF: mwServiceFileTransfer_new:loc_1000FD74o
		align 4
aUnknownMessa_4	db 'unknown message in ft service: 0x%04x',0 ; DATA XREF: sub_1000FF10+49o
		align 4
aBadMalformedAd	db 'bad/malformed addtl in File Transfer service',0
					; DATA XREF: sub_10010050:loc_10010160o
		align 10h
aMwfiletransf_6	db 'mwFileTransfer_removeClientData',0
					; DATA XREF: mwFileTransfer_removeClientData+21o
aMwfiletransf_7	db 'mwFileTransfer_getClientData',0
					; DATA XREF: mwFileTransfer_getClientData+21o
aMwfiletransf_8	db 'mwFileTransfer_setClientData',0
					; DATA XREF: mwFileTransfer_setClientData+29o
aMwfiletransf_9	db 'mwFileTransfer_ack',0 ; DATA XREF: mwFileTransfer_ack+4Fo
					; mwFileTransfer_ack+72o ...
aMwfiletrans_10	db 'mwFileTransfer_send',0 ; DATA XREF: mwFileTransfer_send+89o
					; mwFileTransfer_send+ACo ...
aMwfiletrans_12	db 'mwFileTransfer_close',0 ; DATA XREF: mwFileTransfer_close+93o
					; mwFileTransfer_close+B1o ...
aFt_state	db 'ft_state',0         ; DATA XREF: sub_1000F5D0+BAo
aMwfiletrans_13	db 'mwFileTransfer_offer',0 ; DATA XREF: mwFileTransfer_offer+1C8o
					; mwFileTransfer_offer+1EBo ...
aFt_create_chan	db 'ft_create_chan',0   ; DATA XREF: mwFileTransfer_offer+27Do
					; mwFileTransfer_offer+29Eo
aMwfiletrans_15	db 'mwFileTransfer_accept',0 ; DATA XREF: mwFileTransfer_accept+C7o
					; mwFileTransfer_accept+EAo ...
aMwfiletransfer	db 'mwFileTransfer_getRemaining',0
					; DATA XREF: mwFileTransfer_getRemaining+1Ao
aMwfiletransf_0	db 'mwFileTransfer_getFileSize',0
					; DATA XREF: mwFileTransfer_getFileSize+1Ao
aMwfiletransf_1	db 'mwFileTransfer_getFileName',0
					; DATA XREF: mwFileTransfer_getFileName+1Ao
aMwfiletransf_2	db 'mwFileTransfer_getMessage',0 ; DATA XREF: mwFileTransfer_getMessage+1Ao
aMwfiletransf_3	db 'mwFileTransfer_getUser',0 ; DATA XREF: mwFileTransfer_getUser+1Ao
aMwfiletransf_4	db 'mwFileTransfer_getState',0 ; DATA XREF: mwFileTransfer_getState+1Ao
aMwfiletransf_5	db 'mwFileTransfer_getService',0 ; DATA XREF: mwFileTransfer_getService+19o
aMwfiletrans_17	db 'mwFileTransfer_new',0 ; DATA XREF: mwFileTransfer_new+99o
					; mwFileTransfer_new+B9o
		align 20h
aMwservicefilet	db 'mwServiceFileTransfer_getTransfers',0
					; DATA XREF: mwServiceFileTransfer_getTransfers+1Ao
		align 20h
aMwservicefil_0	db 'mwServiceFileTransfer_getHandler',0
					; DATA XREF: mwServiceFileTransfer_getHandler+1Ao
aMwservicefil_1	db 'mwServiceFileTransfer_new',0 ; DATA XREF: mwServiceFileTransfer_new+9Eo
					; mwServiceFileTransfer_new+BEo
aRecv_2		db 'recv',0             ; DATA XREF: sub_1000FF10+111o
aRecv_transfer	db 'recv_TRANSFER',0    ; DATA XREF: sub_1000FF10+137o
aRecv_channelde	db 'recv_channelDestroy',0 ; DATA XREF: sub_1000FE00:loc_1000FE61o
aRecv_channelac	db 'recv_channelAccept',0 ; DATA XREF: sub_1000FE90:loc_1000FEE7o
aRecv_channelcr	db 'recv_channelCreate',0 ; DATA XREF: sub_10010050+14Eo
		align 20h
aInstantMessagi	db 'Instant Messaging',0 ; DATA XREF: sub_100101C0+1o
		align 4
aImServiceWithS	db 'IM service with Standard and NotesBuddy features',0
					; DATA XREF: sub_100101D0+1o
aConvNull	db 'conv != NULL',0     ; DATA XREF: mwConversation_getTarget:loc_100101F2o
					; mwConversation_getClientType:loc_10010232o ...
aMeanwhile_9	db 'meanwhile',0        ; DATA XREF: mwConversation_getTarget+22o
					; mwConversation_getClientType+22o ...
aSrvcNull_5	db 'srvc != NULL',0     ; DATA XREF: mwServiceIm_getClientType:loc_10010352o
					; mwServiceIm_setClientType:loc_10010395o ...
aPending_1	db 'pending',0          ; DATA XREF: sub_100104D0+1Fo
aUnknown_3	db 'UNKNOWN',0          ; DATA XREF: sub_100104D0+83o
aClosed		db 'closed',0           ; DATA XREF: sub_100104D0+28o
aOpen_2		db 'open',0             ; DATA XREF: sub_100104D0+8Ao
aNull_5		db '(null)',0           ; DATA XREF: sub_100104D0+33o
aSettingConvers	db 'setting conversation (%s, %s) state: %s',0 ; DATA XREF: sub_100104D0+3Fo
aConvServiceNul	db 'conv->service != NULL',0 ; DATA XREF: sub_10010620:loc_10010677o
aHNull		db 'h != NULL',0        ; DATA XREF: sub_10010620:loc_10010695o
aConvChannelNul	db 'conv->channel != NULL',0
					; DATA XREF: mwConversation_getTargetInfo:loc_100108BDo
					; mwConversation_send:loc_10010CE2o
aChanNull_7	db 'chan != NULL',0     ; DATA XREF: sub_100108E0:loc_10010993o
aMwconversat_11	db 'mwConversation_isOpen(conv)',0
					; DATA XREF: mwConversation_send:loc_10010CBCo
		align 4
aUnsupportedImS	db 'unsupported IM Send Type, 0x%x',0 ; DATA XREF: mwConversation_send+40o
		align 4
off_1001F594	dd offset loc_10010C2A	; DATA XREF: mwConversation_send:loc_10010B95r
		dd offset loc_10010C03	; jump table for switch	statement
		dd offset loc_10010BE9
		dd offset loc_10010BB6
		dd offset loc_10010B9C
aSessionNull_5	db 'session != NULL',0  ; DATA XREF: mwServiceIm_new:loc_10010DAFo
aHndlNull	db 'hndl != NULL',0     ; DATA XREF: mwServiceIm_new:loc_10010DCFo
		align 4
aReceivedChanne	db 'received channel accept for non-existant conversation',0
					; DATA XREF: sub_10010E30:loc_10010E50o
aTypeMsg_messag	db 'type == msg_MESSAGE',0 ; DATA XREF: sub_10010E90:loc_100112F3o
		align 4
aFailedToPars_0	db 'failed to parse message for IM service',0
					; DATA XREF: sub_10010E90:loc_10010FA8o
aConvo_invite	db 'convo_invite',0     ; DATA XREF: sub_10010E90:loc_1001116Do
aHandlerNull_4	db 'handler != NULL',0  ; DATA XREF: sub_10010E90:loc_10011432o
aHandlerPlace_i	db 'handler->place_invite != NULL',0 ; DATA XREF: sub_10010E90:loc_10011411o
		align 4
aProblemWithPla	db 'problem with place invite over IM service',0
					; DATA XREF: sub_10010E90+3D9o
aConvMultiNul_0	db 'conv->multi == NULL',0 ; DATA XREF: sub_10010E90:loc_100113F0o
aConvMultiNull	db 'conv->multi != NULL',0 ; DATA XREF: sub_10010E90:loc_100113CFo
		align 4
aUnknownDataM_0	db 'unknown data message type in IM service: (0x%08x, 0x%08x)',0
					; DATA XREF: sub_10010E90+21Eo
		align 4
aUnknownMessa_5	db 'unknown message type 0x%08x for IM service',0
					; DATA XREF: sub_10010E90+55o
		align 4
aFailedToParseM	db 'failed to parse message type 0x%08x for IM service',0
					; DATA XREF: sub_10010E90+F3o
aCNull_0	db 'c != NULL',0        ; DATA XREF: sub_10011460:loc_1001157Fo
					; sub_100115E0:loc_1001167Eo
aMwconversat_12	db 'mwConversation_isPending(c)',0 ; DATA XREF: sub_10011460:loc_1001159Do
aCChannelNull	db 'c->channel == NULL',0 ; DATA XREF: sub_10011460:loc_100115BBo
aFallingBackOnA	db 'falling back on a plaintext conversation',0
					; DATA XREF: sub_100115E0:loc_10011648o
aMwconversat_14	db 'mwConversation_isClosed(conv)',0
					; DATA XREF: mwConversation_open:loc_10011704o
		align 4
aUnacceptableSe	db 'unacceptable service, proto, ver: 0x%08x, 0x%08x, 0x%08x',0
					; DATA XREF: sub_10011730+60o
		align 4
aBadMalformed_0	db 'bad/malformed addtl in IM service',0
					; DATA XREF: sub_10011730:loc_100118A7o
		align 4
aUnknownParams0	db 'unknown params: 0x%08x, 0x%08x',0 ; DATA XREF: sub_10011730+104o
		align 4
aRejectingPlace	db 'rejecting place-invite channel',0
					; DATA XREF: sub_10011730:loc_10011A9Ao
		align 4
aAcceptingPlace	db 'accepting place-invite channel',0 ; DATA XREF: sub_10011730+310o
		align 4
aRejectingImCha	db 'rejecting IM channel due to DND status',0
					; DATA XREF: sub_10011730:loc_10011A61o
		align 10h
aSendingImChann	db 'sending IM channel accept failed',0 ; DATA XREF: sub_10011730+2CDo
aToNull_0	db 'to != NULL',0       ; DATA XREF: mwServiceIm_getConversation:loc_10011BCBo
					; mwServiceIm_findConversation:loc_10011C2Ao
aMwconversati_6	db 'mwConversation_free',0 ; DATA XREF: mwConversation_free+47o
aMwconversati_4	db 'mwConversation_close',0 ; DATA XREF: mwConversation_close+69o
					; mwConversation_close+87o
aConvo_set_stat	db 'convo_set_state',0  ; DATA XREF: sub_100104D0+99o
		align 10h
aMwconversati_5	db 'mwConversation_removeClientData',0
					; DATA XREF: mwConversation_removeClientData+21o
aMwconversati_7	db 'mwConversation_getClientData',0
					; DATA XREF: mwConversation_getClientData+21o
aMwconversati_8	db 'mwConversation_setClientData',0
					; DATA XREF: mwConversation_setClientData+29o
aMwconversati_9	db 'mwConversation_getTargetInfo',0
					; DATA XREF: mwConversation_getTargetInfo+25o
					; mwConversation_getTargetInfo+45o
aMwconversation	db 'mwConversation_getTarget',0 ; DATA XREF: mwConversation_getTarget+1Ao
aMwconversati_0	db 'mwConversation_getClientType',0
					; DATA XREF: mwConversation_getClientType+1Ao
aMwconversati_1	db 'mwConversation_supports',0 ; DATA XREF: mwConversation_supports+3Ao
aMwconversati_2	db 'mwConversation_getService',0 ; DATA XREF: mwConversation_getService+19o
aMwconversati_3	db 'mwConversation_getState',0 ; DATA XREF: mwConversation_getState+1Ao
aMwconversat_10	db 'mwConversation_send',0 ; DATA XREF: mwConversation_send+173o
					; mwConversation_send+199o ...
aConvo_send_dat	db 'convo_send_data',0  ; DATA XREF: sub_100108E0+C0o
aMwserviceim_ge	db 'mwServiceIm_getClientType',0 ; DATA XREF: mwServiceIm_getClientType+1Ao
aMwserviceim_se	db 'mwServiceIm_setClientType',0 ; DATA XREF: mwServiceIm_setClientType+1Do
aMwserviceim_su	db 'mwServiceIm_supports',0 ; DATA XREF: mwServiceIm_supports+3Ao
aMwserviceim__0	db 'mwServiceIm_getHandler',0 ; DATA XREF: mwServiceIm_getHandler+1Ao
aMwserviceim_ne	db 'mwServiceIm_new',0  ; DATA XREF: mwServiceIm_new+A9o
					; mwServiceIm_new+C9o
aRecv_3		db 'recv',0             ; DATA XREF: sub_10010E90+46Bo
aConvo_recv	db 'convo_recv',0       ; DATA XREF: sub_10010460+3Co
					; sub_10010460+5Ao
aConvo_invite_0	db 'convo_invite',0     ; DATA XREF: sub_10010E90+589o
					; sub_10010E90+5AAo
aConvo_multi__0	db 'convo_multi_start',0 ; DATA XREF: sub_10010E90+568o
aConvo_multi_st	db 'convo_multi_stop',0 ; DATA XREF: sub_10010E90+547o
aRecv_channel_0	db 'recv_channelDestroy',0 ; DATA XREF: sub_100115E0+A8o
aConvo_create_c	db 'convo_create_chan',0 ; DATA XREF: sub_10011460+127o
					; sub_10011460+145o ...
aConvo_opened	db 'convo_opened',0     ; DATA XREF: sub_10010620+41o
					; sub_10010620+5Fo ...
aMwconversat_13	db 'mwConversation_open',0 ; DATA XREF: mwConversation_open+3Ao
					; mwConversation_open+5Co
aMwserviceim__1	db 'mwServiceIm_getConversation',0
					; DATA XREF: mwServiceIm_getConversation+85o
					; mwServiceIm_getConversation+A5o
aMwserviceim_fi	db 'mwServiceIm_findConversation',0
					; DATA XREF: mwServiceIm_findConversation+22o
					; mwServiceIm_findConversation+42o
		align 20h
aPlacesConferen	db 'Places Conferencing',0 ; DATA XREF: sub_10011CA0+1o
aBarebonesConfe	db 'Barebones conferencing via Places',0 ; DATA XREF: sub_10011CB0+1o
aPlaceNull	db 'place != NULL',0    ; DATA XREF: mwPlace_getService:loc_10011CD1o
					; mwPlace_removeClientData:loc_10011D99o ...
aMeanwhile_10	db 'meanwhile',0        ; DATA XREF: mwPlace_getService+21o
					; mwServicePlace_getPlaces+22o	...
aSrvcNull_6	db 'srvc != NULL',0     ; DATA XREF: mwServicePlace_getPlaces:loc_10011D12o
					; mwServicePlace_getHandler:loc_10011D52o ...
aPlaceMembersNu	db 'place->members != NULL',0 ; DATA XREF: mwPlace_getMembers:loc_10012177o
aNull_6		db '(null)',0           ; DATA XREF: mwPlace_getMembers+32o
					; sub_100121A0+23o ...
aCollectedMembe	db 'collected member %u: %s, %s',0 ; DATA XREF: mwPlace_getMembers+56o
aError_2	db 'error',0            ; DATA XREF: sub_100121A0:loc_100121FAo
aUnknown_4	db 'UNKNOWN',0          ; DATA XREF: sub_100121A0+16o
aNew_2		db 'new',0              ; DATA XREF: sub_100121A0:loc_10012225o
aPending_2	db 'pending',0          ; DATA XREF: sub_100121A0:loc_1001221Eo
aJoining	db 'joining',0          ; DATA XREF: sub_100121A0:loc_10012217o
aJoined		db 'joined',0           ; DATA XREF: sub_100121A0:loc_10012210o
aOpen_3		db 'open',0             ; DATA XREF: sub_100121A0:loc_10012209o
aClosing_1	db 'closing',0          ; DATA XREF: sub_100121A0:loc_10012202o
aPlaceSStateS	db 'place %s state: %s',0 ; DATA XREF: sub_100121A0+2Co
		align 10h
off_1001FC80	dd offset loc_10012225	; DATA XREF: sub_100121A0:loc_100121F3r
		dd offset loc_1001221E	; jump table for switch	statement
		dd offset loc_10012217
		dd offset loc_10012210
		dd offset loc_10012209
		dd offset loc_10012202
		dd offset loc_100121FA
aMeanwhile_11	db 'Meanwhile',0        ; DATA XREF: mwPlace_getTitle:loc_1001241Ao
aSSConference	db '%s',27h,'s Conference',0 ; DATA XREF: mwPlace_getTitle+47o
		align 4
aGeneratedConfe	db 'generated conference title: %s',0 ; DATA XREF: mwPlace_getTitle+53o
aS08x04x_0	db '%s(%08x,%04x)',0    ; DATA XREF: mwPlace_getName+9Co
		align 4
aGeneratedRan_0	db 'generated random conference name: ',27h,'%s',27h,0
					; DATA XREF: mwPlace_getName+B3o
aPNull		db 'p != NULL',0        ; DATA XREF: mwPlace_open:loc_10012686o
aPServiceNull	db 'p->service != NULL',0 ; DATA XREF: mwPlace_open:loc_100126A9o
aSessionNull_6	db 'session != NULL',0  ; DATA XREF: mwPlace_open:loc_100126CCo
					; mwServicePlace_new:loc_100128B4o
aCsNull_0	db 'cs != NULL',0       ; DATA XREF: mwPlace_open:loc_100126F2o
aHandlerNull_5	db 'handler != NULL',0  ; DATA XREF: mwServicePlace_new:loc_100128D4o
aPlaceStateMwpl	db 'place->state == mwPlace_OPEN',0 ; DATA XREF: sub_10012AC0:loc_100132D9o
aPmNull		db 'pm != NULL',0       ; DATA XREF: sub_10012AC0:loc_100132B8o
					; sub_10012AC0:loc_1001335Do ...
aMwgetbuffer__2	db '! mwGetBuffer_error(b)',0 ; DATA XREF: sub_10012AC0:loc_100132FAo
					; sub_10012AC0:loc_1001333Co
aServer_versi_1	db 'server.version.major',0 ; DATA XREF: sub_10012AC0+BAo
aServer_versi_2	db 'server.version.minor',0 ; DATA XREF: sub_10012AC0+CCo
aSecPlaceSectio	db 'sec == place->section',0 ; DATA XREF: sub_10012AC0:loc_1001331Bo
		align 4
aSection_peer_j	db 'SECTION_PEER_JOIN with section 0x00',0 ; DATA XREF: sub_10012AC0+533o
aSectionPlaceSe	db 'section == place->section',0 ; DATA XREF: sub_10012AC0:loc_1001339Fo
		align 4
aReceivedUnknow	db 'Received unknown message type 0x%x on place %s',0
					; DATA XREF: sub_10012AC0+43o
		align 4
aTroublingParsi	db 'Troubling parsing message type 0x0%x on place %s',0
					; DATA XREF: sub_10012AC0+438o
		align 4
off_1001FE7C	dd offset loc_10012DA6	; DATA XREF: sub_10012AC0:loc_10012B36r
		dd offset loc_10012AFB	; jump table for switch	statement
		dd offset loc_10012DD5
		dd offset loc_10012AFB
		dd offset loc_10012CEA
		dd offset loc_10012AFB
		dd offset loc_10012AFB
		dd offset loc_10012AFB
		dd offset loc_10012AFB
		dd offset loc_10012AFB
		dd offset loc_10012AFB
		dd offset loc_10012AFB
		dd offset loc_10012AFB
		dd offset loc_10012AFB
		dd offset loc_10012AFB
		dd offset loc_10012AFB
		dd offset loc_10012AFB
		dd offset loc_10012AFB
		dd offset loc_10012AFB
		dd offset loc_10012AFB
		dd offset loc_10012B3D
		dd offset loc_10012B26
aMwplace_remove	db 'mwPlace_removeClientData',0 ; DATA XREF: mwPlace_removeClientData+21o
aMwplace_getcli	db 'mwPlace_getClientData',0 ; DATA XREF: mwPlace_getClientData+21o
aMwplace_setcli	db 'mwPlace_setClientData',0 ; DATA XREF: mwPlace_setClientData+29o
aMwplace_getmem	db 'mwPlace_getMembers',0 ; DATA XREF: mwPlace_getMembers+91o
					; mwPlace_getMembers+B1o
aPlace_state	db 'place_state',0      ; DATA XREF: sub_100121A0+94o
aPlace_free	db 'place_free',0       ; DATA XREF: sub_10012280+69o
aMwplace_open	db 'mwPlace_open',0     ; DATA XREF: mwPlace_open+133o
					; mwPlace_open+156o ...
aMwplace_gettit	db 'mwPlace_getTitle',0 ; DATA XREF: mwPlace_getTitle+89o
aMwplace_getnam	db 'mwPlace_getName',0  ; DATA XREF: mwPlace_getName+F1o
aMwplace_getser	db 'mwPlace_getService',0 ; DATA XREF: mwPlace_getService+19o
aMwplace_new	db 'mwPlace_new',0      ; DATA XREF: mwPlace_new+8Eo
aMwserviceplace	db 'mwServicePlace_getPlaces',0 ; DATA XREF: mwServicePlace_getPlaces+1Ao
aMwservicepla_0	db 'mwServicePlace_getHandler',0 ; DATA XREF: mwServicePlace_getHandler+1Ao
aMwservicepla_1	db 'mwServicePlace_new',0 ; DATA XREF: mwServicePlace_new+9Eo
					; mwServicePlace_new+BEo
aRecv_4		db 'recv',0             ; DATA XREF: sub_10012AC0+63Fo
aRecv_message	db 'recv_MESSAGE',0     ; DATA XREF: sub_10012AC0+800o
					; sub_10012AC0+821o
aRecv_section	db 'recv_SECTION',0     ; DATA XREF: sub_10012AC0+842o
aRecv_section_l	db 'recv_SECTION_LIST',0 ; DATA XREF: sub_10012AC0+863o
aRecv_section_p	db 'recv_SECTION_PEER',0 ; DATA XREF: sub_10012AC0+884o
aRecv_section_2	db 'recv_SECTION_PEER_PART',0 ; DATA XREF: sub_10012AC0+8E7o
aRecv_section_0	db 'recv_SECTION_PEER_CLEAR_ATTR',0 ; DATA XREF: sub_10012AC0+8A5o
aRecv_section_1	db 'recv_SECTION_PEER_SET_ATTR',0 ; DATA XREF: sub_10012AC0+8C6o
aRecv_channel_1	db 'recv_channelDestroy',0 ; DATA XREF: sub_10012900:loc_10012976o
aRecv_channel_2	db 'recv_channelAccept',0 ; DATA XREF: sub_100129A0+E2o
					; sub_100129A0+100o
		align 10h
aIdentityResolu	db 'Identity Resolution',0 ; DATA XREF: sub_10013400+1o
aResolvesShortI	db 'Resolves short IDs to full IDs',0 ; DATA XREF: sub_10013410+1o
aSrvcNull_7	db 'srvc != NULL',0     ; DATA XREF: mwServiceResolve_cancelResolve:loc_10013443o
					; mwServiceResolve_resolve:loc_1001364Fo ...
aMeanwhile_12	db 'meanwhile',0        ; DATA XREF: mwServiceResolve_cancelResolve+33o
					; mwServiceResolve_cancelResolve+51o ...
aSrvcSearchesNu	db 'srvc->searches != NULL',0
					; DATA XREF: mwServiceResolve_cancelResolve:loc_10013461o
aSearchNull	db 'search != NULL',0   ; DATA XREF: sub_10013480:loc_100134AAo
aHandlerNull_6	db 'handler != NULL',0  ; DATA XREF: mwServiceResolve_resolve:loc_1001362Fo
aCount0		db 'count > 0',0        ; DATA XREF: mwServiceResolve_resolve:loc_1001360Fo
aSessionNull_7	db 'session != NULL',0  ; DATA XREF: mwServiceResolve_new:loc_100136E9o
					; sub_10013C90:loc_10013D13o
aChanNull_8	db 'chan != NULL',0     ; DATA XREF: sub_100138B0:loc_10013C20o
					; sub_10013C90:loc_10013D01o ...
aChanSrvcChan_0	db 'chan == srvc->channel',0 ; DATA XREF: sub_100138B0:loc_10013BFFo
					; sub_10013C90:loc_10013D0Ao ...
aDataNull_4	db 'data != NULL',0     ; DATA XREF: sub_100138B0:loc_10013C62o
		align 4
aUnknownMessa_6	db 'unknown message in resolve service: 0x%04x',0
					; DATA XREF: sub_100138B0+49o
aErrorParsing_0	db 'error parsing search result',0 ; DATA XREF: sub_100138B0:loc_10013B62o
aErrorParsingSe	db 'error parsing search results',0 ; DATA XREF: sub_100138B0+1F0o
aTriggeringHand	db 'triggering handler',0 ; DATA XREF: sub_100138B0:loc_10013B8Eo
aNoSearchFound0	db 'no search found: 0x%x',0 ; DATA XREF: sub_100138B0+32Ao
		align 4
aMwserviceresol	db 'mwServiceResolve_cancelResolve',0
					; DATA XREF: mwServiceResolve_cancelResolve+2Bo
					; mwServiceResolve_cancelResolve+49o
aMwserviceres_0	db 'mwServiceResolve_resolve',0 ; DATA XREF: mwServiceResolve_resolve+147o
					; mwServiceResolve_resolve+167o ...
aSearch_free	db 'search_free',0      ; DATA XREF: sub_10013480+32o
aMwserviceres_1	db 'mwServiceResolve_new',0 ; DATA XREF: mwServiceResolve_new+83o
aStop		db 'stop',0             ; DATA XREF: sub_10013760+5Bo
aStart		db 'start',0            ; DATA XREF: sub_100137E0+B6o
aRecv_5		db 'recv',0             ; DATA XREF: sub_100138B0+357o
					; sub_100138B0+378o ...
aRecv_destroy	db 'recv_destroy',0     ; DATA XREF: sub_10013C90:loc_10013CE8o
aRecv_accept_1	db 'recv_accept',0      ; DATA XREF: sub_10013D20+26o
					; sub_10013D20+41o ...
		align 10h
aUserStorage	db 'User Storage',0     ; DATA XREF: sub_10013D90+1o
		align 10h
aStoresUserData	db 'Stores user data and settings on the server',0
					; DATA XREF: sub_10013DA0+1o
aItemNull	db 'item != NULL',0     ; DATA XREF: mwStorageUnit_asOpaque:loc_100140F2o
					; mwStorageUnit_getKey:loc_10014131o ...
aMeanwhile_13	db 'meanwhile',0        ; DATA XREF: mwStorageUnit_asOpaque+22o
					; mwStorageUnit_getKey+21o ...
		align 4
aErrorObtaining	db 'error obtaining string value from opaque',0
					; DATA XREF: mwStorageUnit_asString:loc_100141B0o
aSrvcNull_8	db 'srvc != NULL',0     ; DATA XREF: sub_100143F0:loc_10014465o
					; sub_10014490:loc_1001450Eo ...
aChanNull_9	db 'chan != NULL',0     ; DATA XREF: sub_10014530:loc_100147ACo
					; sub_10014830:loc_100148A6o ...
aChanSrvc_storC	db 'chan == srvc_stor->channel',0 ; DATA XREF: sub_10014530:loc_1001478Bo
					; sub_100148C0:loc_1001493Bo
aDataNull_5	db 'data != NULL',0     ; DATA XREF: sub_10014530:loc_100147EEo
		align 10h
aCouldnTFindReq	db 'couldn',27h,'t find request 0x%x in storage service',0
					; DATA XREF: sub_10014530+15Eo
aReqActionType	db 'req->action == type',0 ; DATA XREF: sub_10014530:loc_1001480Fo
		align 4
aStorageReque_0	db 'storage request 0x%x, type: 0x%x',0 ; DATA XREF: sub_10014530+191o
aSaved		db 'saved',0            ; DATA XREF: sub_10014530+241o
aUnknown_5	db 'UNKNOWN',0          ; DATA XREF: sub_10014530:loc_10014603o
aLoad		db 'load',0             ; DATA XREF: sub_10014530:loc_10014781o
aLoaded		db 'loaded',0           ; DATA XREF: sub_10014530+B4o
aSave		db 'save',0             ; DATA XREF: sub_10014530+233o
aStorageRequest	db 'storage request %s: key = 0x%x, result = 0x%x, length = %u',0
					; DATA XREF: sub_10014530+EAo
aSessionNull_8	db 'session != NULL',0  ; DATA XREF: sub_10014830:loc_100148AFo
aMwstorageunit_	db 'mwStorageUnit_asOpaque',0 ; DATA XREF: mwStorageUnit_asOpaque+1Ao
aMwstorageuni_1	db 'mwStorageUnit_asString',0 ; DATA XREF: mwStorageUnit_asString+76o
aMwstorageuni_2	db 'mwStorageUnit_asInteger',0 ; DATA XREF: mwStorageUnit_asInteger+55o
aMwstorageuni_0	db 'mwStorageUnit_getKey',0 ; DATA XREF: mwStorageUnit_getKey+19o
aStop_0		db 'stop',0             ; DATA XREF: sub_100143F0+7Do
aStart_0	db 'start',0            ; DATA XREF: sub_10014490+86o
aRecv_6		db 'recv',0             ; DATA XREF: sub_10014530+263o
					; sub_10014530+284o ...
aRecv_channel_3	db 'recv_channelDestroy',0 ; DATA XREF: sub_10014830:loc_1001488Ao
aRecv_channel_4	db 'recv_channelAccept',0 ; DATA XREF: sub_100148C0:loc_10014921o
		align 4
aUNull		db 'u != NULL',0        ; DATA XREF: mwSametimeUser_getAlias:loc_100149A2o
					; mwSametimeUser_getShortName:loc_100149E2o ...
aMeanwhile_14	db 'meanwhile',0        ; DATA XREF: mwSametimeUser_getAlias+22o
					; mwSametimeUser_getShortName+22o ...
aGNull		db 'g != NULL',0        ; DATA XREF: mwSametimeGroup_getList:loc_10014B21o
					; mwSametimeGroup_isOpen:loc_10014B62o	...
aLNull		db 'l != NULL',0        ; DATA XREF: mwSametimeList_getMicro:loc_10014CA2o
					; mwSametimeList_setMicro:loc_10014CE5o ...
; char aVersionU_U_U[]
aVersionU_U_U	db 'Version=%u.%u.%u',0Ah,0 ; DATA XREF: sub_10014E40+E5o
		align 10h
aStrangeSametim	db 'strange sametime list version line:',0Ah ; DATA XREF: sub_10014E40+FEo
		db '%s',0
; char aGSSC[]
aGSSC		db 'G %s %s %c',0Ah,0   ; DATA XREF: sub_10014E40+254o
		align 4
aStrangeSamet_0	db 'strange sametime list group line:',0Ah ; DATA XREF: sub_10014E40+305o
		db '%s',0
; char aUSS[]
aUSS		db 'U %s %s',0          ; DATA XREF: sub_10014E40+153o
		align 4
aStrangeSamet_1	db 'strange sametime list user line:',0Ah ; DATA XREF: sub_10014E40+3C8o
		db '%s',0
; char SubStr[]
SubStr		db '::',0               ; DATA XREF: sub_10014E40:loc_100151DFo
		align 4
aUnknownSametim	db 'unknown sametime list data line:',0Ah ; DATA XREF: sub_10014E40+9Ao
		db '%s',0
aBNull_1	db 'b != NULL',0        ; DATA XREF: mwSametimeList_get:loc_10015294o
					; mwSametimeList_put:loc_100157BAo
aDataNull_6	db 'data != NULL',0     ; DATA XREF: mwSametimeList_load:loc_100152EFo
aListNull_0	db 'list != NULL',0     ; DATA XREF: mwSametimeGroup_new:loc_1001546Bo
aNameNull	db 'name != NULL',0     ; DATA XREF: mwSametimeGroup_new:loc_1001548Bo
					; mwSametimeList_findGroup:loc_10015C22o
aName0		db '*name != ',27h,'\0',27h,0 ; DATA XREF: mwSametimeGroup_new:loc_100154ABo
					; mwSametimeList_findGroup:loc_10015C02o
aVersionU_U_U_0	db 'Version=%u.%u.%u',0Dh,0Ah,0 ; DATA XREF: sub_100154D0+32o
aGSCSC		db 'G %s%c %s %c',0Dh,0Ah,0 ; DATA XREF: sub_100154D0+C6o
byte_100205E1	db 0			; DATA XREF: sub_100154D0+197o
					; sub_100154D0:loc_100156F4o
aUSCSS		db 'U %s%c:: %s,%s',0Dh,0Ah,0 ; DATA XREF: sub_100154D0+1AFo
aUGroupNull	db 'u->group != NULL',0 ; DATA XREF: mwSametimeUser_free:loc_100158A9o
aGListNull	db 'g->list != NULL',0  ; DATA XREF: mwSametimeGroup_free:loc_10015958o
aGroupNull	db 'group != NULL',0    ; DATA XREF: mwSametimeUser_new:loc_10015A33o
aIdNull_0	db 'id != NULL',0       ; DATA XREF: mwSametimeUser_new:loc_10015A53o
aUserNull_1	db 'user != NULL',0     ; DATA XREF: mwSametimeGroup_findUser:loc_10015AF4o
aMwsametimeli_5	db 'mwSametimeList_get',0 ; DATA XREF: mwSametimeList_get+4Eo
					; mwSametimeList_get+6Co
aMwsametimeli_6	db 'mwSametimeList_load',0 ; DATA XREF: mwSametimeList_load+39o
aMwsametimeli_7	db 'mwSametimeList_put',0 ; DATA XREF: mwSametimeList_put+69o
					; mwSametimeList_put+92o
aList_store	db 'list_store',0       ; DATA XREF: sub_100154D0+240o
aMwsametimeli_8	db 'mwSametimeList_store',0 ; DATA XREF: mwSametimeList_store+37o
aMwsametimeus_7	db 'mwSametimeUser_free',0 ; DATA XREF: mwSametimeUser_free+5Eo
					; mwSametimeUser_free+81o
aMwsametimeuser	db 'mwSametimeUser_getAlias',0 ; DATA XREF: mwSametimeUser_getAlias+1Ao
aMwsametimeus_5	db 'mwSametimeUser_setAlias',0 ; DATA XREF: mwSametimeUser_setAlias+35o
aMwsametimeus_0	db 'mwSametimeUser_getShortName',0
					; DATA XREF: mwSametimeUser_getShortName+1Ao
aMwsametimeus_6	db 'mwSametimeUser_setShortName',0
					; DATA XREF: mwSametimeUser_setShortName+35o
aMwsametimeus_1	db 'mwSametimeUser_getCommunity',0
					; DATA XREF: mwSametimeUser_getCommunity+1Ao
aMwsametimeus_2	db 'mwSametimeUser_getUser',0 ; DATA XREF: mwSametimeUser_getUser+1Ao
aMwsametimeus_3	db 'mwSametimeUser_getType',0 ; DATA XREF: mwSametimeUser_getType+1Ao
aMwsametimeus_4	db 'mwSametimeUser_getGroup',0 ; DATA XREF: mwSametimeUser_getGroup+19o
aMwsametimeus_8	db 'mwSametimeUser_new',0 ; DATA XREF: mwSametimeUser_new+6Do
					; mwSametimeUser_new+8Do
aMwsametimegr_7	db 'mwSametimeGroup_free',0 ; DATA XREF: mwSametimeGroup_free+6Do
					; mwSametimeGroup_free+90o
aMwsametimegr_8	db 'mwSametimeGroup_findUser',0 ; DATA XREF: mwSametimeGroup_findUser+5Eo
					; mwSametimeGroup_findUser+7Eo
aMwsametimegr_9	db 'mwSametimeGroup_getUsers',0 ; DATA XREF: mwSametimeGroup_getUsers+21o
aMwsametimegrou	db 'mwSametimeGroup_getList',0 ; DATA XREF: mwSametimeGroup_getList+19o
aMwsametimegr_0	db 'mwSametimeGroup_isOpen',0 ; DATA XREF: mwSametimeGroup_isOpen+1Ao
aMwsametimegr_1	db 'mwSametimeGroup_setOpen',0 ; DATA XREF: mwSametimeGroup_setOpen+1Do
aMwsametimegr_2	db 'mwSametimeGroup_getAlias',0 ; DATA XREF: mwSametimeGroup_getAlias+1Ao
aMwsametimegr_5	db 'mwSametimeGroup_setAlias',0 ; DATA XREF: mwSametimeGroup_setAlias+35o
aMwsametimegr_3	db 'mwSametimeGroup_getName',0 ; DATA XREF: mwSametimeGroup_getName+1Ao
aMwsametimegr_4	db 'mwSametimeGroup_getType',0 ; DATA XREF: mwSametimeGroup_getType+1Ao
aMwsametimegr_6	db 'mwSametimeGroup_new',0 ; DATA XREF: mwSametimeGroup_new+75o
					; mwSametimeGroup_new+95o ...
aMwsametimeli_9	db 'mwSametimeList_free',0 ; DATA XREF: mwSametimeList_free+36o
aMwsametimel_11	db 'mwSametimeList_findGroup',0 ; DATA XREF: mwSametimeList_findGroup+6Co
					; mwSametimeList_findGroup+8Co	...
aMwsametimel_10	db 'mwSametimeList_getGroups',0 ; DATA XREF: mwSametimeList_getGroups+21o
aMwsametimelist	db 'mwSametimeList_getMicro',0 ; DATA XREF: mwSametimeList_getMicro+1Ao
aMwsametimeli_0	db 'mwSametimeList_setMicro',0 ; DATA XREF: mwSametimeList_setMicro+1Do
aMwsametimeli_1	db 'mwSametimeList_getMinor',0 ; DATA XREF: mwSametimeList_getMinor+1Ao
aMwsametimeli_2	db 'mwSametimeList_setMinor',0 ; DATA XREF: mwSametimeList_setMinor+1Do
aMwsametimeli_3	db 'mwSametimeList_getMajor',0 ; DATA XREF: mwSametimeList_getMajor+19o
aMwsametimeli_4	db 'mwSametimeList_setMajor',0 ; DATA XREF: mwSametimeList_setMajor+1Co
		align 10h
aBufNullLen0	db 'buf != NULL || len == 0',0 ; DATA XREF: mw_debug_datav+1A6o
					; mw_debug_data+34o
aMeanwhile_15	db 'meanwhile',0        ; DATA XREF: mw_debug_datav+148o
					; mw_debug_datav+1B4o ...
aS		db '%s',0Ah,0           ; DATA XREF: mw_debug_datav+51o
		align 4
a02x02x02x02x02	db '%02x%02x %02x%02x %02x%02x %02x%02x %02x%02x %02x%02x %02x%02x %0'
					; DATA XREF: mw_debug_datav+F7o
		db '2x%02x ',0
asc_100209D1	db 0Ah,0		; DATA XREF: mw_debug_datav:loc_10015DE0o
		align 4
a02x02x02x02x_0	db '%02x%02x %02x%02x %02x%02x %02x%02x ',0 ; DATA XREF: mw_debug_datav+20Do
a02x02x02x02x	db '%02x%02x %02x%02x ',0 ; DATA XREF: mw_debug_datav+24Bo
a02x02x		db '%02x%02x ',0        ; DATA XREF: mw_debug_datav+126o
a02x		db '%02x',0             ; DATA XREF: mw_debug_datav+188o
aONull_1	db 'o != NULL',0        ; DATA XREF: mw_debug_opaquev:loc_10015FAEo
					; mw_debug_opaque:loc_10015FF8o
aMw_debug_opa_0	db 'mw_debug_opaque',0  ; DATA XREF: mw_debug_opaque+30o
aMw_debug_opaqu	db 'mw_debug_opaquev',0 ; DATA XREF: mw_debug_opaquev+35o
aMw_debug_data	db 'mw_debug_data',0    ; DATA XREF: mw_debug_data+3Co
aMw_debug_datav	db 'mw_debug_datav',0   ; DATA XREF: mw_debug_datav+1ADo
		align 4
aUnknownResultC	db 'unknown result code',0 ; DATA XREF: mw_mp_strerror+1o
					; .rdata:10020E38o
aMpi_c		db 'mpi.c',0            ; DATA XREF: mw_mp_value_radix_size+39o
					; mw_mp_read_radix+118o ...
		align 10h
aNum0Qty0Radix2	db 'num >= 0 && qty > 0 && radix >= 2 && radix <= 64',0
					; DATA XREF: mw_mp_value_radix_size+41o
		align 4
aMpVoid0StrVoid	db 'mp != ((void *)0) && str != ((void *)0) && radix >= 2 && radix <='
					; DATA XREF: mw_mp_read_radix+120o
		db ' 64',0
aMpVoid0	db 'mp != ((void *)0)',0 ; DATA XREF: mw_mp_count_bits+46o
					; mw_mp_radix_size+62o	...
		align 4
aMpVoid0StrVo_0	db 'mp != ((void *)0) && str != ((void *)0)',0
					; DATA XREF: mw_mp_to_unsigned_bin+B5o
					; mw_mp_to_signed_bin+38o ...
aAVoid0		db 'a != ((void *)0)',0 ; DATA XREF: mw_mp_isodd+28o
					; mw_mp_cmw_mp_d+3Co ...
		align 4
aAVoid0BVoid0	db 'a != ((void *)0) && b != ((void *)0)',0
					; DATA XREF: mw_mp_cmw_mp_mag+30o
					; mw_mp_cmp+60o ...
		align 10h
aMpVoid0Count0	db 'mp != ((void *)0) && count > 0',0 ; DATA XREF: mw_mp_clear_array+5Ao
aMp1NullMp2Null	db 'mp1 != NULL && mp2 != NULL',0 ; DATA XREF: mw_mp_exch+30o
		align 4
aFromVoid0ToVoi	db 'from != ((void *)0) && to != ((void *)0)',0 ; DATA XREF: mw_mp_copy+E4o
		align 4
aAVoid0CVoid0	db 'a != ((void *)0) && c != ((void *)0)',0 ; DATA XREF: mw_mp_mul_2d+67o
					; mw_mp_div_2+50o ...
		align 10h
aMpVoid0StrVo_1	db 'mp != ((void *)0) && str != ((void *)0) && len > 0',0
					; DATA XREF: mw_mp_read_unsigned_bin+76o
					; mw_mp_read_signed_bin+60o
		align 4
aMpVoid0FromVoi	db 'mp != ((void *)0) && from != ((void *)0)',0
					; DATA XREF: mw_mp_init_copy+88o
		align 10h
aAVoid0BVoid0CV	db 'a != ((void *)0) && b != ((void *)0) && c != ((void *)0)',0
					; DATA XREF: mw_mp_sub+A2o
					; mw_mp_add+103o ...
aMpVoid0Prec0	db 'mp != ((void *)0) && prec > 0',0 ; DATA XREF: mw_mp_init_size+61o
		align 4
aAVoid0MVoid0CV	db 'a != ((void *)0) && m != ((void *)0) && c != ((void *)0)',0
					; DATA XREF: mw_mp_mod+34o
					; mw_mp_sqrmod+67o
		align 4
aAVoid0BVoid0MV	db 'a != ((void *)0) && b != ((void *)0) && m != ((void *)0) && c != '
					; DATA XREF: mw_mp_submod+56o
					; mw_mp_addmod+56o ...
		db '((void *)0)',0
aRadix1Radix64	db 'radix > 1 && radix <= 64',0 ; DATA XREF: mw_mp_toradix+15Bo
aAMC		db 'a && m && c',0      ; DATA XREF: mw_mp_invmod+34o
aMpVoid0Count_0	db 'mp !=((void *)0) && count > 0',0 ; DATA XREF: mw_mp_init_array+7Do
a0123456789abcd	db '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/',0
					; DATA XREF: .rdata:off_10020DC8o
		align 4
off_10020DC8	dd offset a0123456789abcd ; DATA XREF: s_mw_mp_todigit+14r
					; "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabc"...
aBooleanTrue	db 'boolean true',0     ; DATA XREF: .rdata:off_10020E3Co
aBooleanFalse	db 'boolean false',0    ; DATA XREF: .rdata:10020E40o
aOutOfMemory	db 'out of memory',0    ; DATA XREF: .rdata:10020E44o
aArgumentOutOfR	db 'argument out of range',0 ; DATA XREF: .rdata:10020E48o
aInvalidInputPa	db 'invalid input parameter',0 ; DATA XREF: .rdata:10020E4Co
aResultIsUndefi	db 'result is undefined',0 ; DATA XREF: .rdata:10020E50o
		align 4
		dd offset aUnknownResultC ; "unknown result code"
off_10020E3C	dd offset aBooleanTrue	; DATA XREF: mw_mp_strerror+1Cr
					; "boolean true"
		dd offset aBooleanFalse	; "boolean false"
		dd offset aOutOfMemory	; "out of memory"
		dd offset aArgumentOutOfR ; "argument out of range"
		dd offset aInvalidInputPa ; "invalid input parameter"
		dd offset aResultIsUndefi ; "result is undefined"
flt_10020E54	dd 0.5			; DATA XREF: s_mw_mp_outlen+42r
dword_10020E58	dd 6Ah dup(0)		; DATA XREF: sub_1001AA10+1o
					; sub_1001AA10+8o ...
_rdata		ends

; Section 4. (virtual address 00021000)
; Virtual size			: 00000084 (	132.)
; Section size in file		: 00000000 (	  0.)
; Offset to raw	data for section: 00000000
; Flags	C0400080: Bss Readable Writable
; Alignment	: 8 bytes
; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_bss		segment	para public 'BSS' use32
		assume cs:_bss
		;org 10021000h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; void *Memory
Memory		dd ?			; DATA XREF: .text:1000100Eo
					; sub_10001020+Eo ...
		align 10h
dword_10021010	dd ?			; DATA XREF: .text:10001009o
					; sub_10001020+9o ...
		align 10h
; char Dest[10]
Dest		db 0Ah dup(?)		; DATA XREF: mwError+18Eo mwError+19Ao
byte_1002102A	db ?			; DATA XREF: mwError+19Fw
		align 10h
dword_10021030	dd ?			; DATA XREF: .text:10011C64w
					; .text:10011C8Bo
word_10021034	dw ?			; DATA XREF: .text:10011C6Dw
		align 4
dword_10021038	dd ?			; DATA XREF: .text:10011C76w
dword_1002103C	dd ?			; DATA XREF: .text:10011C7Ew
dword_10021040	dd ?			; DATA XREF: .text:10011C86w
dword_10021044	dd ?			; DATA XREF: .text:10011C57w
		align 1000h
_bss		ends

; Section 6. (virtual address 00026000)
; Virtual size			: 00000804 (   2052.)
; Section size in file		: 00000A00 (   2560.)
; Offset to raw	data for section: 00022A00
; Flags	C0300040: Data Readable	Writable
; Alignment	: 4 bytes
; ===========================================================================

; Segment type:	Externs
; _idata


;
; Imports from libglib-2.0-0.dll
;
		extrn g_ascii_table:dword ; DATA XREF: sub_10014E40+1Cr
		extrn g_direct_equal:dword ; DATA XREF:	.text:loc_1001A918r
		extrn g_direct_hash:dword ; DATA XREF: .text:loc_1001A910r
		extrn __imp_g_free:dword ; DATA	XREF: g_freer
		extrn __imp_g_hash_table_destroy:dword ; DATA XREF: g_hash_table_destroyr
		extrn __imp_g_hash_table_foreach:dword ; DATA XREF: g_hash_table_foreachr
		extrn __imp_g_hash_table_foreach_steal:dword
					; DATA XREF: g_hash_table_foreach_stealr
		extrn __imp_g_hash_table_insert:dword ;	DATA XREF: g_hash_table_insertr
		extrn __imp_g_hash_table_lookup:dword ;	DATA XREF: g_hash_table_lookupr
		extrn __imp_g_hash_table_new:dword ; DATA XREF:	g_hash_table_newr
		extrn __imp_g_hash_table_new_full:dword	; DATA XREF: g_hash_table_new_fullr
		extrn __imp_g_hash_table_remove:dword ;	DATA XREF: g_hash_table_remover
		extrn __imp_g_hash_table_size:dword ; DATA XREF: g_hash_table_sizer
		extrn __imp_g_hash_table_steal:dword ; DATA XREF: g_hash_table_stealr
		extrn __imp_g_list_append:dword	; DATA XREF: g_list_appendr
		extrn __imp_g_list_concat:dword	; DATA XREF: g_list_concatr
		extrn __imp_g_list_copy:dword ;	DATA XREF: g_list_copyr
		extrn __imp_g_list_delete_link:dword ; DATA XREF: g_list_delete_linkr
		extrn __imp_g_list_free:dword ;	DATA XREF: g_list_freer
		extrn __imp_g_list_length:dword	; DATA XREF: g_list_lengthr
		extrn __imp_g_list_prepend:dword ; DATA	XREF: g_list_prependr
		extrn __imp_g_list_remove:dword	; DATA XREF: g_list_remover
		extrn __imp_g_list_remove_all:dword ; DATA XREF: g_list_remove_allr
		extrn __imp_g_log:dword	; DATA XREF: g_logr
		extrn __imp_g_malloc:dword ; DATA XREF:	g_mallocr
		extrn __imp_g_malloc0:dword ; DATA XREF: g_malloc0r
		extrn __imp_g_memdup:dword ; DATA XREF:	g_memdupr
		extrn __imp_g_return_if_fail_warning:dword
					; DATA XREF: g_return_if_fail_warningr
		extrn __imp_g_slist_append:dword ; DATA	XREF: g_slist_appendr
		extrn __imp_g_slist_free:dword ; DATA XREF: g_slist_freer
		extrn g_str_equal:dword	; DATA XREF: .text:loc_1001A988r
		extrn __imp_g_str_hash:dword ; DATA XREF: g_str_hashr
		extrn __imp_g_strdup:dword ; DATA XREF:	g_strdupr
		extrn __imp_g_strdup_printf:dword ; DATA XREF: g_strdup_printfr
		extrn __imp_g_strdup_vprintf:dword ; DATA XREF:	g_strdup_vprintfr
		extrn __imp_g_string_append:dword ; DATA XREF: g_string_appendr
		extrn __imp_g_string_append_len:dword ;	DATA XREF: g_string_append_lenr
		extrn __imp_g_string_append_printf:dword
					; DATA XREF: g_string_append_printfr
		extrn __imp_g_string_free:dword	; DATA XREF: g_string_freer
		extrn __imp_g_string_new:dword ; DATA XREF: g_string_newr
		extrn __imp_g_strndup:dword ; DATA XREF: g_strndupr

;
; Imports from KERNEL32.dll
;
; HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName)
		extrn __imp_GetModuleHandleA:dword ; DATA XREF:	GetModuleHandleAr
; FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName)
		extrn __imp_GetProcAddress:dword ; DATA	XREF: GetProcAddressr

;
; Imports from msvcrt.dll
;
		extrn __imp___dllonexit:dword ;	DATA XREF: __dllonexitr
; int _mb_cur_max
		extrn __mb_cur_max:dword ; DATA	XREF: s_mw_mp_tovalue+26r
		extrn __imp__assert:dword ; DATA XREF: _assertr
; int *__cdecl _errno()
		extrn __imp__errno:dword ; DATA	XREF: _errnor
; int __cdecl _isctype(int C, int Type)
		extrn __imp__isctype:dword ; DATA XREF:	_isctyper
; const	unsigned __int16 *pctype
		extrn _pctype:dword	; DATA XREF: s_mw_mp_tovalue:loc_10016777r
					; s_mw_mp_tovalue+7Er
; void *__cdecl	calloc(size_t NumOfElements, size_t SizeOfElements)
		extrn __imp_calloc:dword ; DATA	XREF: callocr
; clock_t __cdecl clock()
		extrn __imp_clock:dword	; DATA XREF: clockr
; int __cdecl fflush(FILE *File)
		extrn __imp_fflush:dword ; DATA	XREF: fflushr
; void __cdecl free(void *Memory)
		extrn __imp_free:dword	; DATA XREF: freer
		extrn __imp_log:dword	; DATA XREF: logr
; void *__cdecl	malloc(size_t Size)
		extrn __imp_malloc:dword ; DATA	XREF: mallocr
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn __imp_memcpy:dword ; DATA	XREF: memcpyr
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn __imp_memset:dword ; DATA	XREF: memsetr
; int __cdecl rand()
		extrn __imp_rand:dword	; DATA XREF: randr
; int sprintf(char *Dest, const	char *Format, ...)
		extrn __imp_sprintf:dword ; DATA XREF: sprintfr
; void __cdecl srand(unsigned int Seed)
		extrn __imp_srand:dword	; DATA XREF: srandr
; int sscanf(const char	*Src, const char *Format, ...)
		extrn __imp_sscanf:dword ; DATA	XREF: sscanfr
; int __cdecl strcmp(const char	*Str1, const char *Str2)
		extrn __imp_strcmp:dword ; DATA	XREF: strcmpr
; size_t __cdecl strlen(const char *Str)
		extrn __imp_strlen:dword ; DATA	XREF: strlenr
; char *__cdecl	strrchr(const char *Str, int Ch)
		extrn __imp_strrchr:dword ; DATA XREF: strrchrr
; char *__cdecl	strstr(const char *Str,	const char *SubStr)
		extrn __imp_strstr:dword ; DATA	XREF: strstrr
; time_t __cdecl static	time(time_t *Time)
		extrn __imp_time:dword	; DATA XREF: timer
; int __cdecl tolower(int C)
		extrn __imp_tolower:dword ; DATA XREF: tolowerr
; int __cdecl toupper(int C)
		extrn __imp_toupper:dword ; DATA XREF: toupperr



		end DllEntryPoint
