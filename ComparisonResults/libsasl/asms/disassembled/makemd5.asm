;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	83D6E6DBB3B2DBD1395663E43BED04C4
; Input	CRC32 :	4E5BBF42

; File Name   :	C:\compspace\objfiles\libsasl\makemd5.o
; Format      :	COFF (X386MAGIC)

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	dword public 'CODE' use32
		assume cs:_text
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_my_strupr	proc near		; CODE XREF: _try_signed+B0p
					; _try_signed+1D7p ...

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_0]
		mov	[ebp+var_C], eax
		jmp	short loc_53
; ---------------------------------------------------------------------------

loc_E:					; CODE XREF: _my_strupr+5Bj
		mov	eax, dword ptr ds:__imp____ctype_ptr__
		mov	edx, [eax]
		mov	eax, [ebp+var_C]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		add	eax, 1
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		and	eax, 3
		cmp	eax, 2

loc_2F:					; DATA XREF: .eh_frame:00000FC0o
					; .eh_frame:00000FE0o
		jnz	short loc_4F
		mov	eax, [ebp+var_C]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		mov	[ebp+var_10], eax
		mov	eax, [ebp+var_10]
		mov	[esp], eax	; int
		call	_toupper
		mov	edx, eax
		mov	eax, [ebp+var_C]
		mov	[eax], dl

loc_4F:					; CODE XREF: _my_strupr:loc_2Fj
		add	[ebp+var_C], 1

loc_53:					; CODE XREF: _my_strupr+Cj
		mov	eax, [ebp+var_C]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_E
		leave
		retn
_my_strupr	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl try_signed(FILE *, int)
_try_signed	proc near		; CODE XREF: _main+F1p	_main+105p ...

var_154		= byte ptr -154h
var_D4		= byte ptr -0D4h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_4C		= word ptr -4Ch
var_49		= byte ptr -49h
var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_1E		= word ptr -1Eh
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_D		= byte ptr -0Dh
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 168h
		mov	[ebp+var_C], 0
		mov	[ebp+var_D], 1
		mov	[ebp+var_49], 0
		mov	[ebp+var_14], offset byte_BA8
		jmp	short loc_9D
; ---------------------------------------------------------------------------

loc_80:					; CODE XREF: _try_signed+42j
		movsx	eax, [ebp+var_D]
		add	eax, eax
		mov	[ebp+var_D], al
		add	[ebp+var_C], 1
		movzx	eax, [ebp+var_D]
		cmp	al, [ebp+var_49]
		jge	short loc_9D
		mov	[ebp+var_14], offset byte_BAA

loc_9D:					; CODE XREF: _try_signed+1Fj
					; _try_signed+35j
		cmp	[ebp+var_D], 0
		jnz	short loc_80
		mov	eax, [ebp+var_C]
		cmp	eax, [ebp+arg_4]
		jl	loc_188
		mov	eax, [ebp+arg_4]
		lea	edx, [eax+7]
		test	eax, eax
		cmovs	eax, edx
		sar	eax, 3
		mov	[esp+0Ch], eax
		mov	eax, [ebp+var_14]
		mov	[esp+8], eax
		mov	dword ptr [esp+4], offset aSintD ; "%sINT%d"
		lea	eax, [ebp+var_154]
		mov	[esp], eax	; char *
		call	_sprintf
		lea	eax, [ebp+var_154]
		mov	[esp+0Ch], eax
		mov	dword ptr [esp+8], offset aSignedChar ;	"signed	char"
		mov	dword ptr [esp+4], offset aTypedefSS ; "typedef	%s %s;"
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_sprintf
		lea	eax, [ebp+var_154]
		mov	[esp], eax
		call	_my_strupr
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_strlen
		shr	eax, 3
		mov	edx, 5
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+var_18], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+4], eax	; FILE *
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_fputs
		jmp	short loc_15B
; ---------------------------------------------------------------------------

loc_148:				; CODE XREF: _try_signed+107j
		mov	eax, [ebp+arg_0]
		mov	[esp+4], eax	; FILE *
		mov	dword ptr [esp], 9 ; int
		call	_fputc

loc_15B:				; CODE XREF: _try_signed+E7j
		mov	eax, [ebp+var_18]
		lea	edx, [eax-1]
		mov	[ebp+var_18], edx
		test	eax, eax
		jg	short loc_148
		mov	eax, [ebp+var_C]
		mov	[esp+8], eax
		mov	dword ptr [esp+4], offset a2dBits ; "/*	%2d bits */\n"
		mov	eax, [ebp+arg_0]
		mov	[esp], eax	; FILE *
		call	_fprintf
		nop
		jmp	locret_503
; ---------------------------------------------------------------------------

loc_188:				; CODE XREF: _try_signed+4Aj
		mov	[ebp+var_1C], 0
		mov	[ebp+var_1E], 1
		mov	[ebp+var_4C], 0

loc_19B:				; DATA XREF: .eh_frame:00001000o
		mov	[ebp+var_24], offset byte_BA8
		jmp	short loc_1C3
; ---------------------------------------------------------------------------

loc_1A4:				; CODE XREF: _try_signed+169j
		movsx	eax, [ebp+var_1E]
		add	eax, eax
		mov	[ebp+var_1E], ax
		add	[ebp+var_1C], 1
		movzx	eax, [ebp+var_1E]
		cmp	ax, [ebp+var_4C]
		jge	short loc_1C3
		mov	[ebp+var_24], offset byte_BAA

loc_1C3:				; CODE XREF: _try_signed+143j
					; _try_signed+15Bj
		cmp	[ebp+var_1E], 0
		jnz	short loc_1A4
		mov	eax, [ebp+var_1C]
		cmp	eax, [ebp+arg_4]
		jl	loc_2AF
		mov	eax, [ebp+arg_4]
		lea	edx, [eax+7]
		test	eax, eax
		cmovs	eax, edx
		sar	eax, 3
		mov	[esp+0Ch], eax
		mov	eax, [ebp+var_24]
		mov	[esp+8], eax
		mov	dword ptr [esp+4], offset aSintD ; "%sINT%d"
		lea	eax, [ebp+var_154]
		mov	[esp], eax	; char *
		call	_sprintf
		lea	eax, [ebp+var_154]
		mov	[esp+0Ch], eax
		mov	dword ptr [esp+8], offset aShort ; "short"
		mov	dword ptr [esp+4], offset aTypedefSS ; "typedef	%s %s;"
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_sprintf
		lea	eax, [ebp+var_154]
		mov	[esp], eax
		call	_my_strupr
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_strlen
		shr	eax, 3
		mov	edx, 5
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+var_28], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+4], eax	; FILE *
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_fputs
		jmp	short loc_282
; ---------------------------------------------------------------------------

loc_26F:				; CODE XREF: _try_signed+22Ej
		mov	eax, [ebp+arg_0]
		mov	[esp+4], eax	; FILE *
		mov	dword ptr [esp], 9 ; int
		call	_fputc

loc_282:				; CODE XREF: _try_signed+20Ej
		mov	eax, [ebp+var_28]
		lea	edx, [eax-1]
		mov	[ebp+var_28], edx
		test	eax, eax
		jg	short loc_26F
		mov	eax, [ebp+var_1C]
		mov	[esp+8], eax
		mov	dword ptr [esp+4], offset a2dBits ; "/*	%2d bits */\n"
		mov	eax, [ebp+arg_0]
		mov	[esp], eax	; FILE *
		call	_fprintf
		nop
		jmp	locret_503
; ---------------------------------------------------------------------------

loc_2AF:				; CODE XREF: _try_signed+171j
		mov	[ebp+var_2C], 0
		mov	[ebp+var_30], 1
		mov	[ebp+var_50], 0
		mov	[ebp+var_34], offset byte_BA8
		jmp	short loc_2E3
; ---------------------------------------------------------------------------

loc_2CD:				; CODE XREF: _try_signed+288j
		shl	[ebp+var_30], 1
		add	[ebp+var_2C], 1
		mov	eax, [ebp+var_30]
		cmp	eax, [ebp+var_50]
		jge	short loc_2E3
		mov	[ebp+var_34], offset byte_BAA

loc_2E3:				; CODE XREF: _try_signed+26Cj
					; _try_signed+27Bj
		cmp	[ebp+var_30], 0
		jnz	short loc_2CD
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+arg_4]
		jl	loc_3CE
		mov	eax, [ebp+arg_4]
		lea	edx, [eax+7]
		test	eax, eax
		cmovs	eax, edx
		sar	eax, 3
		mov	[esp+0Ch], eax
		mov	eax, [ebp+var_34]
		mov	[esp+8], eax
		mov	dword ptr [esp+4], offset aSintD ; "%sINT%d"
		lea	eax, [ebp+var_154]
		mov	[esp], eax	; char *
		call	_sprintf
		lea	eax, [ebp+var_154]
		mov	[esp+0Ch], eax
		mov	dword ptr [esp+8], offset aInt ; "int"
		mov	dword ptr [esp+4], offset aTypedefSS ; "typedef	%s %s;"
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_sprintf
		lea	eax, [ebp+var_154]
		mov	[esp], eax
		call	_my_strupr
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_strlen
		shr	eax, 3
		mov	edx, 5
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+var_38], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+4], eax	; FILE *
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_fputs
		jmp	short loc_3A1
; ---------------------------------------------------------------------------

loc_38E:				; CODE XREF: _try_signed+34Dj
		mov	eax, [ebp+arg_0]
		mov	[esp+4], eax	; FILE *
		mov	dword ptr [esp], 9 ; int
		call	_fputc

loc_3A1:				; CODE XREF: _try_signed+32Dj
		mov	eax, [ebp+var_38]
		lea	edx, [eax-1]
		mov	[ebp+var_38], edx
		test	eax, eax
		jg	short loc_38E
		mov	eax, [ebp+var_2C]
		mov	[esp+8], eax
		mov	dword ptr [esp+4], offset a2dBits ; "/*	%2d bits */\n"
		mov	eax, [ebp+arg_0]
		mov	[esp], eax	; FILE *
		call	_fprintf
		nop
		jmp	locret_503
; ---------------------------------------------------------------------------

loc_3CE:				; CODE XREF: _try_signed+290j
		mov	[ebp+var_3C], 0
		mov	[ebp+var_40], 1
		mov	[ebp+var_54], 0
		mov	[ebp+var_44], offset byte_BA8
		jmp	short loc_402
; ---------------------------------------------------------------------------

loc_3EC:				; CODE XREF: _try_signed+3A7j
		shl	[ebp+var_40], 1
		add	[ebp+var_3C], 1
		mov	eax, [ebp+var_40]
		cmp	eax, [ebp+var_54]
		jge	short loc_402
		mov	[ebp+var_44], offset byte_BAA

loc_402:				; CODE XREF: _try_signed+38Bj
					; _try_signed+39Aj
		cmp	[ebp+var_40], 0
		jnz	short loc_3EC
		mov	eax, [ebp+var_3C]
		cmp	eax, [ebp+arg_4]
		jl	loc_4E9
		mov	eax, [ebp+arg_4]
		lea	edx, [eax+7]
		test	eax, eax
		cmovs	eax, edx
		sar	eax, 3
		mov	[esp+0Ch], eax
		mov	eax, [ebp+var_44]
		mov	[esp+8], eax
		mov	dword ptr [esp+4], offset aSintD ; "%sINT%d"
		lea	eax, [ebp+var_154]
		mov	[esp], eax	; char *
		call	_sprintf
		lea	eax, [ebp+var_154]
		mov	[esp+0Ch], eax
		mov	dword ptr [esp+8], offset aLong	; "long"
		mov	dword ptr [esp+4], offset aTypedefSS ; "typedef	%s %s;"
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_sprintf
		lea	eax, [ebp+var_154]
		mov	[esp], eax
		call	_my_strupr
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_strlen
		shr	eax, 3
		mov	edx, 5
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+var_48], eax
		mov	eax, [ebp+arg_0]

loc_499:				; DATA XREF: .eh_frame:00000FA0o
		mov	[esp+4], eax	; FILE *
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *

loc_4A6:				; DATA XREF: .eh_frame:00000F80o
		call	_fputs
		jmp	short loc_4C0
; ---------------------------------------------------------------------------

loc_4AD:				; CODE XREF: _try_signed+46Cj
		mov	eax, [ebp+arg_0]
		mov	[esp+4], eax	; FILE *
		mov	dword ptr [esp], 9 ; int
		call	_fputc

loc_4C0:				; CODE XREF: _try_signed+44Cj
		mov	eax, [ebp+var_48]
		lea	edx, [eax-1]
		mov	[ebp+var_48], edx
		test	eax, eax
		jg	short loc_4AD
		mov	eax, [ebp+var_3C]
		mov	[esp+8], eax
		mov	dword ptr [esp+4], offset a2dBits ; "/*	%2d bits */\n"
		mov	eax, [ebp+arg_0]
		mov	[esp], eax	; FILE *
		call	_fprintf
		jmp	short locret_503
; ---------------------------------------------------------------------------

loc_4E9:				; CODE XREF: _try_signed+3AFj
		mov	eax, [ebp+arg_4]
		mov	[esp+8], eax
		mov	dword ptr [esp+4], offset aThereIsNoDBitT ; "/*	There is no %d bit type	*/\n"
		mov	eax, [ebp+arg_0]
		mov	[esp], eax	; FILE *
		call	_fprintf

locret_503:				; CODE XREF: _try_signed+124j
					; _try_signed+24Bj ...
		leave
		retn
_try_signed	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl try_unsigned(FILE	*, int)
_try_unsigned	proc near		; CODE XREF: _main+141p _main+155p ...

var_154		= byte ptr -154h
var_D4		= byte ptr -0D4h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_4C		= word ptr -4Ch
var_49		= byte ptr -49h
var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_1E		= word ptr -1Eh
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_D		= byte ptr -0Dh
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 168h
		mov	[ebp+var_C], 0
		mov	[ebp+var_D], 1
		mov	[ebp+var_49], 0
		mov	[ebp+var_14], offset byte_BA8
		jmp	short loc_53D
; ---------------------------------------------------------------------------

loc_526:				; CODE XREF: _try_unsigned+3Cj
		shl	[ebp+var_D], 1
		add	[ebp+var_C], 1
		movzx	eax, [ebp+var_D]
		cmp	al, [ebp+var_49]
		jnb	short loc_53D
		mov	[ebp+var_14], offset byte_BAA

loc_53D:				; CODE XREF: _try_unsigned+1Fj
					; _try_unsigned+2Fj
		cmp	[ebp+var_D], 0
		jnz	short loc_526
		mov	eax, [ebp+var_C]
		cmp	eax, [ebp+arg_4]
		jl	loc_628
		mov	eax, [ebp+arg_4]
		lea	edx, [eax+7]
		test	eax, eax
		cmovs	eax, edx
		sar	eax, 3
		mov	[esp+0Ch], eax
		mov	eax, [ebp+var_14]
		mov	[esp+8], eax
		mov	dword ptr [esp+4], offset aSintD ; "%sINT%d"
		lea	eax, [ebp+var_154]
		mov	[esp], eax	; char *
		call	_sprintf
		lea	eax, [ebp+var_154]
		mov	[esp+0Ch], eax
		mov	dword ptr [esp+8], offset aUnsignedChar	; "unsigned char"
		mov	dword ptr [esp+4], offset aTypedefSS ; "typedef	%s %s;"
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_sprintf
		lea	eax, [ebp+var_154]
		mov	[esp], eax
		call	_my_strupr
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_strlen
		shr	eax, 3
		mov	edx, 5
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+var_18], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+4], eax	; FILE *
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_fputs
		jmp	short loc_5FB
; ---------------------------------------------------------------------------

loc_5E8:				; CODE XREF: _try_unsigned+101j
		mov	eax, [ebp+arg_0]
		mov	[esp+4], eax	; FILE *
		mov	dword ptr [esp], 9 ; int
		call	_fputc

loc_5FB:				; CODE XREF: _try_unsigned+E1j
		mov	eax, [ebp+var_18]
		lea	edx, [eax-1]
		mov	[ebp+var_18], edx
		test	eax, eax
		jg	short loc_5E8
		mov	eax, [ebp+var_C]
		mov	[esp+8], eax
		mov	dword ptr [esp+4], offset a2dBits ; "/*	%2d bits */\n"
		mov	eax, [ebp+arg_0]
		mov	[esp], eax	; FILE *
		call	_fprintf
		nop
		jmp	locret_99D
; ---------------------------------------------------------------------------

loc_628:				; CODE XREF: _try_unsigned+44j
		mov	[ebp+var_1C], 0
		mov	[ebp+var_1E], 1
		mov	[ebp+var_4C], 0
		mov	[ebp+var_24], offset byte_BA8
		jmp	short loc_65D
; ---------------------------------------------------------------------------

loc_644:				; CODE XREF: _try_unsigned+15Dj
		shl	[ebp+var_1E], 1
		add	[ebp+var_1C], 1
		movzx	eax, [ebp+var_1E]
		cmp	ax, [ebp+var_4C]
		jnb	short loc_65D
		mov	[ebp+var_24], offset byte_BAA

loc_65D:				; CODE XREF: _try_unsigned+13Dj
					; _try_unsigned+14Fj
		cmp	[ebp+var_1E], 0
		jnz	short loc_644
		mov	eax, [ebp+var_1C]
		cmp	eax, [ebp+arg_4]
		jl	loc_749
		mov	eax, [ebp+arg_4]
		lea	edx, [eax+7]
		test	eax, eax
		cmovs	eax, edx
		sar	eax, 3
		mov	[esp+0Ch], eax
		mov	eax, [ebp+var_24]
		mov	[esp+8], eax
		mov	dword ptr [esp+4], offset aSintD ; "%sINT%d"
		lea	eax, [ebp+var_154]
		mov	[esp], eax	; char *
		call	_sprintf
		lea	eax, [ebp+var_154]
		mov	[esp+0Ch], eax
		mov	dword ptr [esp+8], offset aUnsignedShort ; "unsigned short"
		mov	dword ptr [esp+4], offset aTypedefSS ; "typedef	%s %s;"
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_sprintf
		lea	eax, [ebp+var_154]
		mov	[esp], eax
		call	_my_strupr
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_strlen
		shr	eax, 3
		mov	edx, 5
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+var_28], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+4], eax	; FILE *
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_fputs
		jmp	short loc_71C
; ---------------------------------------------------------------------------

loc_709:				; CODE XREF: _try_unsigned+222j
		mov	eax, [ebp+arg_0]
		mov	[esp+4], eax	; FILE *
		mov	dword ptr [esp], 9 ; int
		call	_fputc

loc_71C:				; CODE XREF: _try_unsigned+202j
		mov	eax, [ebp+var_28]
		lea	edx, [eax-1]
		mov	[ebp+var_28], edx
		test	eax, eax
		jg	short loc_709
		mov	eax, [ebp+var_1C]
		mov	[esp+8], eax
		mov	dword ptr [esp+4], offset a2dBits ; "/*	%2d bits */\n"
		mov	eax, [ebp+arg_0]
		mov	[esp], eax	; FILE *
		call	_fprintf
		nop
		jmp	locret_99D
; ---------------------------------------------------------------------------

loc_749:				; CODE XREF: _try_unsigned+165j
		mov	[ebp+var_2C], 0
		mov	[ebp+var_30], 1
		mov	[ebp+var_50], 0
		mov	[ebp+var_34], offset byte_BA8
		jmp	short loc_77D
; ---------------------------------------------------------------------------

loc_767:				; CODE XREF: _try_unsigned+27Cj
		shl	[ebp+var_30], 1
		add	[ebp+var_2C], 1
		mov	eax, [ebp+var_30]
		cmp	eax, [ebp+var_50]
		jnb	short loc_77D
		mov	[ebp+var_34], offset byte_BAA

loc_77D:				; CODE XREF: _try_unsigned+260j
					; _try_unsigned+26Fj
		cmp	[ebp+var_30], 0
		jnz	short loc_767
		mov	eax, [ebp+var_2C]
		cmp	eax, [ebp+arg_4]
		jl	loc_868
		mov	eax, [ebp+arg_4]
		lea	edx, [eax+7]
		test	eax, eax
		cmovs	eax, edx
		sar	eax, 3
		mov	[esp+0Ch], eax
		mov	eax, [ebp+var_34]
		mov	[esp+8], eax
		mov	dword ptr [esp+4], offset aSintD ; "%sINT%d"
		lea	eax, [ebp+var_154]
		mov	[esp], eax	; char *
		call	_sprintf
		lea	eax, [ebp+var_154]
		mov	[esp+0Ch], eax
		mov	dword ptr [esp+8], offset aUnsignedInt ; "unsigned int"
		mov	dword ptr [esp+4], offset aTypedefSS ; "typedef	%s %s;"
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_sprintf
		lea	eax, [ebp+var_154]
		mov	[esp], eax
		call	_my_strupr
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_strlen
		shr	eax, 3
		mov	edx, 5
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+var_38], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+4], eax	; FILE *
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_fputs
		jmp	short loc_83B
; ---------------------------------------------------------------------------

loc_828:				; CODE XREF: _try_unsigned+341j
		mov	eax, [ebp+arg_0]
		mov	[esp+4], eax	; FILE *
		mov	dword ptr [esp], 9 ; int
		call	_fputc

loc_83B:				; CODE XREF: _try_unsigned+321j
		mov	eax, [ebp+var_38]
		lea	edx, [eax-1]
		mov	[ebp+var_38], edx
		test	eax, eax
		jg	short loc_828
		mov	eax, [ebp+var_2C]
		mov	[esp+8], eax
		mov	dword ptr [esp+4], offset a2dBits ; "/*	%2d bits */\n"
		mov	eax, [ebp+arg_0]
		mov	[esp], eax	; FILE *
		call	_fprintf
		nop
		jmp	locret_99D
; ---------------------------------------------------------------------------

loc_868:				; CODE XREF: _try_unsigned+284j
		mov	[ebp+var_3C], 0
		mov	[ebp+var_40], 1
		mov	[ebp+var_54], 0
		mov	[ebp+var_44], offset byte_BA8
		jmp	short loc_89C
; ---------------------------------------------------------------------------

loc_886:				; CODE XREF: _try_unsigned+39Bj
		shl	[ebp+var_40], 1
		add	[ebp+var_3C], 1
		mov	eax, [ebp+var_40]
		cmp	eax, [ebp+var_54]
		jnb	short loc_89C
		mov	[ebp+var_44], offset byte_BAA

loc_89C:				; CODE XREF: _try_unsigned+37Fj
					; _try_unsigned+38Ej
		cmp	[ebp+var_40], 0
		jnz	short loc_886
		mov	eax, [ebp+var_3C]
		cmp	eax, [ebp+arg_4]
		jl	loc_983
		mov	eax, [ebp+arg_4]
		lea	edx, [eax+7]
		test	eax, eax
		cmovs	eax, edx
		sar	eax, 3
		mov	[esp+0Ch], eax
		mov	eax, [ebp+var_44]
		mov	[esp+8], eax
		mov	dword ptr [esp+4], offset aSintD ; "%sINT%d"
		lea	eax, [ebp+var_154]
		mov	[esp], eax	; char *
		call	_sprintf
		lea	eax, [ebp+var_154]
		mov	[esp+0Ch], eax
		mov	dword ptr [esp+8], offset aUnsignedLong	; "unsigned long"
		mov	dword ptr [esp+4], offset aTypedefSS ; "typedef	%s %s;"
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_sprintf
		lea	eax, [ebp+var_154]
		mov	[esp], eax
		call	_my_strupr
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_strlen
		shr	eax, 3
		mov	edx, 5
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+var_48], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+4], eax	; FILE *
		lea	eax, [ebp+var_D4]
		mov	[esp], eax	; char *
		call	_fputs
		jmp	short loc_95A
; ---------------------------------------------------------------------------

loc_947:				; CODE XREF: _try_unsigned+460j
		mov	eax, [ebp+arg_0]
		mov	[esp+4], eax	; FILE *
		mov	dword ptr [esp], 9 ; int
		call	_fputc

loc_95A:				; CODE XREF: _try_unsigned+440j
		mov	eax, [ebp+var_48]
		lea	edx, [eax-1]
		mov	[ebp+var_48], edx
		test	eax, eax
		jg	short loc_947
		mov	eax, [ebp+var_3C]
		mov	[esp+8], eax
		mov	dword ptr [esp+4], offset a2dBits ; "/*	%2d bits */\n"
		mov	eax, [ebp+arg_0]
		mov	[esp], eax	; FILE *
		call	_fprintf
		jmp	short locret_99D
; ---------------------------------------------------------------------------

loc_983:				; CODE XREF: _try_unsigned+3A3j
		mov	eax, [ebp+arg_4]
		mov	[esp+8], eax
		mov	dword ptr [esp+4], offset aThereIsNoDBitT ; "/*	There is no %d bit type	*/\n"
		mov	eax, [ebp+arg_0]
		mov	[esp], eax	; FILE *
		call	_fprintf

locret_99D:				; CODE XREF: _try_unsigned+11Ej
					; _try_unsigned+23Fj ...
		leave
		retn
_try_unsigned	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl print_pre(FILE *)
_print_pre	proc near		; CODE XREF: _main+DDp

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	[esp+0Ch], eax	; FILE *
		mov	dword ptr [esp+8], 1A9h	; size_t
		mov	dword ptr [esp+4], 1 ; size_t
		mov	dword ptr [esp], offset	aGlobal_hRsaref	; "/* GLOBAL.H - RSAREF	types and constant"...
		call	_fwrite
		mov	eax, 1
		leave
		retn
_print_pre	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl print_post(FILE *)
_print_post	proc near		; CODE XREF: _main+189p

arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	[esp+0Ch], eax	; FILE *
		mov	dword ptr [esp+8], 117h	; size_t
		mov	dword ptr [esp+4], 1 ; size_t
		mov	dword ptr [esp], offset	aProto_listIsDe	; "\n/*	PROTO_LIST is defined depending	on"...
		call	_fwrite
		mov	eax, 1
		leave
		retn
_print_post	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public _main
_main		proc near

argc		= dword	ptr  8
argv		= dword	ptr  0Ch
envp		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF0h
		sub	esp, 20h
		call	___main
		cmp	[ebp+argc], 1
		jg	short loc_A34
		mov	dword ptr [esp+14h], offset aBits_h ; "bits.h"
		mov	dword ptr [esp+10h], offset a__bits_h__	; "__BITS_H__"
		call	___getreent
		mov	eax, [eax+8]
		mov	[esp+1Ch], eax
		jmp	loc_AD5
; ---------------------------------------------------------------------------

loc_A34:				; CODE XREF: _main+12j
		mov	eax, [ebp+argv]
		mov	eax, [eax+4]
		mov	[esp+14h], eax
		mov	eax, [esp+14h]
		mov	[esp], eax	; char *
		call	_strlen
		add	eax, 5
		mov	[esp], eax	; size_t
		call	_malloc
		mov	[esp+10h], eax
		mov	eax, [esp+14h]
		mov	[esp+8], eax
		mov	dword ptr [esp+4], offset a__S__ ; "__%s__"
		mov	eax, [esp+10h]
		mov	[esp], eax	; char *
		call	_sprintf
		mov	eax, [esp+10h]
		mov	[esp+18h], eax
		jmp	short loc_AAE
; ---------------------------------------------------------------------------

loc_A7F:				; CODE XREF: _main+B8j
		mov	eax, dword ptr ds:__imp____ctype_ptr__
		mov	edx, [eax]
		mov	eax, [esp+18h]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		add	eax, 1
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		and	eax, 7
		test	eax, eax
		jnz	short loc_AA9
		mov	eax, [esp+18h]
		mov	byte ptr [eax],	5Fh ; '_'

loc_AA9:				; CODE XREF: _main+A1j
		add	dword ptr [esp+18h], 1

loc_AAE:				; CODE XREF: _main+7Ej
		mov	eax, [esp+18h]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_A7F
		mov	eax, [ebp+argv]
		add	eax, 4
		mov	eax, [eax]
		mov	dword ptr [esp+4], offset aW ; "w"
		mov	[esp], eax	; char *
		call	_fopen
		mov	[esp+1Ch], eax

loc_AD5:				; CODE XREF: _main+30j
		mov	eax, [esp+1Ch]
		mov	[esp], eax	; FILE *
		call	_print_pre
		mov	dword ptr [esp+4], 8 ; int
		mov	eax, [esp+1Ch]
		mov	[esp], eax	; FILE *
		call	_try_signed
		mov	dword ptr [esp+4], 10h ; int
		mov	eax, [esp+1Ch]
		mov	[esp], eax	; FILE *
		call	_try_signed
		mov	dword ptr [esp+4], 20h ; ' ' ; int
		mov	eax, [esp+1Ch]
		mov	[esp], eax	; FILE *
		call	_try_signed
		mov	dword ptr [esp+4], 40h ; '@' ; int
		mov	eax, [esp+1Ch]
		mov	[esp], eax	; FILE *
		call	_try_signed
		mov	dword ptr [esp+4], 8 ; int
		mov	eax, [esp+1Ch]
		mov	[esp], eax	; FILE *
		call	_try_unsigned
		mov	dword ptr [esp+4], 10h ; int
		mov	eax, [esp+1Ch]
		mov	[esp], eax	; FILE *
		call	_try_unsigned
		mov	dword ptr [esp+4], 20h ; ' ' ; int
		mov	eax, [esp+1Ch]
		mov	[esp], eax	; FILE *
		call	_try_unsigned
		mov	dword ptr [esp+4], 40h ; '@' ; int
		mov	eax, [esp+1Ch]
		mov	[esp], eax	; FILE *
		call	_try_unsigned
		mov	eax, [esp+1Ch]
		mov	[esp], eax	; FILE *
		call	_print_post
		mov	eax, [esp+1Ch]
		mov	[esp], eax	; FILE *
		call	_fclose
		mov	eax, 0
		leave

locret_B9F:				; DATA XREF: .eh_frame:00000F5Co
					; .eh_frame:00000F7Co ...
		retn
_main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BA8h
byte_BA8	db 55h,	0		; DATA XREF: _try_signed+18o
					; _try_signed:loc_19Bo	...
byte_BAA	db 0			; DATA XREF: _try_signed+37o
					; _try_signed+15Do ...
; char aSintD[]
aSintD		db '%sINT%d',0          ; DATA XREF: _try_signed+69o
					; _try_signed+190o ...
aSignedChar	db 'signed char',0      ; DATA XREF: _try_signed+89o
; char aTypedefSS[]
aTypedefSS	db 'typedef %s %s;',0   ; DATA XREF: _try_signed+91o
					; _try_signed+1B8o ...
; char a2dBits[]
a2dBits		db '/* %2d bits */',0Ah,0 ; DATA XREF: _try_signed+110o
					; _try_signed+237o ...
aShort		db 'short',0            ; DATA XREF: _try_signed+1B0o
aInt		db 'int',0              ; DATA XREF: _try_signed+2CFo
aLong		db 'long',0             ; DATA XREF: _try_signed+3EEo
		align 10h
; char aThereIsNoDBitT[]
aThereIsNoDBitT	db '/* There is no %d bit type */',0Ah,0 ; DATA XREF: _try_signed+491o
					; _try_unsigned+485o
aUnsignedChar	db 'unsigned char',0    ; DATA XREF: _try_unsigned+83o
aUnsignedShort	db 'unsigned short',0   ; DATA XREF: _try_unsigned+1A4o
aUnsignedInt	db 'unsigned int',0     ; DATA XREF: _try_unsigned+2C3o
aUnsignedLong	db 'unsigned long',0    ; DATA XREF: _try_unsigned+3E2o
		align 4
aGlobal_hRsaref	db '/* GLOBAL.H - RSAREF types and constants',0Ah
					; DATA XREF: _print_pre+1Do
		db ' */',0Ah
		db '#ifndef MD5GLOBAL_H',0Ah
		db '#define MD5GLOBAL_H',0Ah
		db 0Ah
		db '/* PROTOTYPES should be set to one if and only if the compiler su'
		db 'pports',0Ah
		db '  function argument prototyping.',0Ah
		db 'The following makes PROTOTYPES default to 0 if it has not already'
		db 0Ah
		db '  been defined with C compiler flags.',0Ah
		db ' */',0Ah
		db '#ifndef PROTOTYPES',0Ah
		db '#define PROTOTYPES 0',0Ah
		db '#endif',0Ah
		db 0Ah
		db '/* POINTER defines a generic pointer type */',0Ah
		db 'typedef unsigned char *POINTER;',0Ah
		db 0Ah,0
		align 4
aProto_listIsDe	db 0Ah			; DATA XREF: _print_post+1Do
		db '/* PROTO_LIST is defined depending on how PROTOTYPES is defined a'
		db 'bove.',0Ah
		db 'If using PROTOTYPES, then PROTO_LIST returns the list, otherwise '
		db 'it',0Ah
		db 'returns an empty list.',0Ah
		db '*/',0Ah
		db '#if PROTOTYPES',0Ah
		db '#define PROTO_LIST(list) list',0Ah
		db '#else',0Ah
		db '#define PROTO_LIST(list) ()',0Ah
		db '#endif',0Ah
		db 0Ah
		db '#endif /* MD5GLOBAL_H */',0Ah
		db 0Ah,0
aBits_h		db 'bits.h',0           ; DATA XREF: _main+14o
a__bits_h__	db '__BITS_H__',0       ; DATA XREF: _main+1Co
; char a__S__[]
a__S__		db '__%s__',0           ; DATA XREF: _main+62o
; char aW[]
aW		db 'w',0                ; DATA XREF: _main+C2o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata$zzz	segment	dword public 'DATA' use32
		assume cs:_rdata$zzz
		;org 0F28h
aGccGnu4_9_3	db 'GCC: (GNU) 4.9.3',0
		align 4
_rdata$zzz	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'DATA' use32
		assume cs:_eh_frame
		;org 0F3Ch
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset locret_B9F-1AFBh
		dd offset _try_signed
		dd 80E4100h, 0D420285h,	0C55B0205h, 4040Ch, 1Ch, 3Ch
		dd offset locret_B9F-1ABCh
		dd offset loc_4A6
		dd 80E4100h, 0D420285h,	4A20305h, 4040CC5h, 1Ch, 5Ch
		dd offset locret_B9F-1636h
		dd offset loc_499+1
		dd 80E4100h, 0D420285h,	4960305h, 4040CC5h, 1Ch, 7Ch
		dd offset locret_B9F-11BCh
		dd offset loc_2F+1
		dd 80E4100h, 0D420285h,	0CC56C05h, 404h, 1Ch, 9Ch
		dd offset locret_B9F-11ACh
		dd offset loc_2F+1
		dd 80E4100h, 0D420285h,	0CC56C05h, 404h, 1Ch, 0BCh
		dd offset locret_B9F-119Ch
		dd offset loc_19B+6
		dd 80E4100h, 0D420285h,	19D0305h, 4040CC5h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __imp____ctype_ptr__:near	; DATA XREF: _my_strupr:loc_Er
					; _main:loc_A7Fr
		extrn ___main:near	; CODE XREF: _main+9p
; int __cdecl toupper(int)
		extrn _toupper:near	; CODE XREF: _my_strupr+43p
; int sprintf(char *, const char *, ...)
		extrn _sprintf:near	; CODE XREF: _try_signed+7Ap
					; _try_signed+A2p ...
; size_t __cdecl strlen(const char *)
		extrn _strlen:near	; CODE XREF: _try_signed+BEp
					; _try_signed+1E5p ...
; int __cdecl fputs(const char *, FILE *)
		extrn _fputs:near	; CODE XREF: _try_signed+E2p
					; _try_signed+209p ...
; int __cdecl fputc(int, FILE *)
		extrn _fputc:near	; CODE XREF: _try_signed+F7p
					; _try_signed+21Ep ...
; int fprintf(FILE *, const char *, ...)
		extrn _fprintf:near	; CODE XREF: _try_signed+11Ep
					; _try_signed+245p ...
; size_t __cdecl fwrite(const void *, size_t, size_t, FILE *)
		extrn _fwrite:near	; CODE XREF: _print_pre+24p
					; _print_post+24p
		extrn ___getreent:near	; CODE XREF: _main+24p
; void *__cdecl	malloc(size_t)
		extrn _malloc:near	; CODE XREF: _main+51p
; FILE *__cdecl	fopen(const char *, const char *)
		extrn _fopen:near	; CODE XREF: _main+CDp
; int __cdecl fclose(FILE *)
		extrn _fclose:near	; CODE XREF: _main+195p


		end
