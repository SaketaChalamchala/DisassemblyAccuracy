;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	14656A196C7080557AF10902864D1C4A
; Input	CRC32 :	11B8AD56

; File Name   :	C:\compspace\Diff\openssl\obj\asn1_lib.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		public _ASN1_version
_ASN1_version	db 'ASN.1 part of OpenSSL 1.0.2h  3 May 2016',0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ASN1_STRING_clear_free
_ASN1_STRING_clear_free	proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	short loc_6C
		mov	eax, [esi+8]
		test	eax, eax
		jz	short loc_4D
		test	byte ptr [esi+0Ch], 10h
		jnz	short loc_4D
		push	dword ptr [esi]
		push	eax
		call	_OPENSSL_cleanse
		add	esp, 8

loc_4D:					; CODE XREF: _ASN1_STRING_clear_free+Ej
					; _ASN1_STRING_clear_free+14j
		mov	eax, [esi+8]
		test	eax, eax
		jz	short loc_63
		test	byte ptr [esi+0Ch], 10h
		jnz	short loc_63
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_63:					; CODE XREF: _ASN1_STRING_clear_free+26j
					; _ASN1_STRING_clear_free+2Cj
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_6C:					; CODE XREF: _ASN1_STRING_clear_free+7j
		pop	esi
		retn
_ASN1_STRING_clear_free	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 70h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ASN1_STRING_cmp
_ASN1_STRING_cmp proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		mov	ebx, [esp+4+arg_4]
		push	edi
		mov	edi, [esp+8+arg_0]
		mov	ecx, [edi]
		mov	eax, ecx
		sub	eax, [ebx]
		jnz	short loc_E7
		mov	edx, [edi+8]
		push	esi
		mov	esi, [ebx+8]
		sub	ecx, 4
		jb	short loc_A1
		xchg	ax, ax

loc_90:					; CODE XREF: _ASN1_STRING_cmp+2Fj
		mov	eax, [edx]
		cmp	eax, [esi]
		jnz	short loc_A6
		add	edx, 4
		add	esi, 4
		sub	ecx, 4
		jnb	short loc_90

loc_A1:					; CODE XREF: _ASN1_STRING_cmp+1Cj
		cmp	ecx, 0FFFFFFFCh
		jz	short loc_DA

loc_A6:					; CODE XREF: _ASN1_STRING_cmp+24j
		mov	al, [edx]
		cmp	al, [esi]
		jnz	short loc_D3
		cmp	ecx, 0FFFFFFFDh
		jz	short loc_DA
		mov	al, [edx+1]
		cmp	al, [esi+1]
		jnz	short loc_D3
		cmp	ecx, 0FFFFFFFEh
		jz	short loc_DA
		mov	al, [edx+2]
		cmp	al, [esi+2]
		jnz	short loc_D3
		cmp	ecx, 0FFFFFFFFh
		jz	short loc_DA
		mov	al, [edx+3]
		cmp	al, [esi+3]
		jz	short loc_DA

loc_D3:					; CODE XREF: _ASN1_STRING_cmp+3Aj
					; _ASN1_STRING_cmp+47j	...
		sbb	eax, eax
		or	eax, 1
		jmp	short loc_DC
; ---------------------------------------------------------------------------

loc_DA:					; CODE XREF: _ASN1_STRING_cmp+34j
					; _ASN1_STRING_cmp+3Fj	...
		xor	eax, eax

loc_DC:					; CODE XREF: _ASN1_STRING_cmp+68j
		pop	esi
		test	eax, eax
		jnz	short loc_E7
		mov	eax, [edi+4]
		sub	eax, [ebx+4]

loc_E7:					; CODE XREF: _ASN1_STRING_cmp+10j
					; _ASN1_STRING_cmp+6Fj
		pop	edi
		pop	ebx
		retn
_ASN1_STRING_cmp endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0ECh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ASN1_STRING_copy
_ASN1_STRING_copy proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_4]
		test	esi, esi
		jnz	short loc_F9
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_F9:					; CODE XREF: _ASN1_STRING_copy+7j
		mov	eax, [esi+4]
		push	edi
		mov	edi, [esp+8+arg_0]
		mov	[edi+4], eax
		push	dword ptr [esi]	; Size
		push	dword ptr [esi+8] ; Src
		push	edi		; int
		call	_ASN1_STRING_set
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_119
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_119:				; CODE XREF: _ASN1_STRING_copy+28j
		mov	eax, [esi+0Ch]
		mov	[edi+0Ch], eax
		mov	eax, 1
		pop	edi
		pop	esi
		retn
_ASN1_STRING_copy endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 128h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ASN1_STRING_data
_ASN1_STRING_data proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+8]
		retn
_ASN1_STRING_data endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 130h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ASN1_STRING_dup
_ASN1_STRING_dup proc near

arg_0		= dword	ptr  4

		push	edi
		mov	edi, [esp+4+arg_0]
		test	edi, edi
		jnz	short loc_13D
		xor	eax, eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_13D:				; CODE XREF: _ASN1_STRING_dup+7j
		push	esi
		call	_ASN1_STRING_new
		mov	esi, eax
		test	esi, esi
		jz	short loc_18B
		mov	eax, [edi+4]
		mov	[esi+4], eax
		push	dword ptr [edi]	; Size
		push	dword ptr [edi+8] ; Src
		push	esi		; int
		call	_ASN1_STRING_set
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_16C
		mov	eax, [edi+0Ch]
		mov	[esi+0Ch], eax
		mov	eax, esi
		pop	esi
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_16C:				; CODE XREF: _ASN1_STRING_dup+2Fj
		mov	eax, [esi+8]
		test	eax, eax
		jz	short loc_182
		test	byte ptr [esi+0Ch], 10h
		jnz	short loc_182
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_182:				; CODE XREF: _ASN1_STRING_dup+41j
					; _ASN1_STRING_dup+47j
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_18B:				; CODE XREF: _ASN1_STRING_dup+17j
		pop	esi
		xor	eax, eax
		pop	edi
		retn
_ASN1_STRING_dup endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 190h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ASN1_STRING_free
_ASN1_STRING_free proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	short loc_1B8
		mov	eax, [esi+8]
		test	eax, eax
		jz	short loc_1AF
		test	byte ptr [esi+0Ch], 10h
		jnz	short loc_1AF
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_1AF:				; CODE XREF: _ASN1_STRING_free+Ej
					; _ASN1_STRING_free+14j
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_1B8:				; CODE XREF: _ASN1_STRING_free+7j
		pop	esi
		retn
_ASN1_STRING_free endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1BCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ASN1_STRING_length
_ASN1_STRING_length proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax]
		retn
_ASN1_STRING_length endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1C4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ASN1_STRING_length_set
_ASN1_STRING_length_set	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax], ecx
		retn
_ASN1_STRING_length_set	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1D0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ASN1_STRING_new
_ASN1_STRING_new proc near		; CODE XREF: _ASN1_STRING_dup+Ep
		push	198h
		push	offset ??_C@_0BJ@BDGDICBL@?4?2crypto?2asn1?2asn1_lib?4c?$AA@ ; ".\\crypto\\asn1\\asn1_lib.c"
		push	10h
		call	_CRYPTO_malloc
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_206
		push	19Ah
		push	offset ??_C@_0BJ@BDGDICBL@?4?2crypto?2asn1?2asn1_lib?4c?$AA@ ; ".\\crypto\\asn1\\asn1_lib.c"
		push	41h ; 'A'
		push	82h ; '‚'
		push	0Dh
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_206:				; CODE XREF: _ASN1_STRING_new+16j
		mov	dword ptr [eax], 0
		mov	dword ptr [eax+4], 4
		mov	dword ptr [eax+8], 0
		mov	dword ptr [eax+0Ch], 0
		retn
_ASN1_STRING_new endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 224h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl ASN1_STRING_set(int, void	*Src, size_t Size)
		public _ASN1_STRING_set
_ASN1_STRING_set proc near		; CODE XREF: _ASN1_STRING_copy+1Ep
					; _ASN1_STRING_dup+25p

arg_0		= dword	ptr  4
Src		= dword	ptr  8
Size		= dword	ptr  0Ch

		push	ebx
		mov	ebx, [esp+4+Src]
		push	esi
		mov	esi, [esp+8+Size]
		test	esi, esi
		jns	short loc_24D
		test	ebx, ebx
		jnz	short loc_23B
		pop	esi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_23B:				; CODE XREF: _ASN1_STRING_set+10j
		mov	esi, ebx
		lea	ecx, [esi+1]
		nop	dword ptr [eax+00h]

loc_244:				; CODE XREF: _ASN1_STRING_set+25j
		mov	al, [esi]
		inc	esi
		test	al, al
		jnz	short loc_244
		sub	esi, ecx

loc_24D:				; CODE XREF: _ASN1_STRING_set+Cj
		push	ebp
		push	edi
		mov	edi, [esp+10h+arg_0]
		cmp	[edi], esi
		jl	short loc_25E
		mov	eax, [edi+8]
		test	eax, eax
		jnz	short loc_2BD

loc_25E:				; CODE XREF: _ASN1_STRING_set+31j
		mov	ebp, [edi+8]
		lea	eax, [esi+1]
		test	ebp, ebp
		jnz	short loc_27D
		push	174h
		push	offset ??_C@_0BJ@BDGDICBL@?4?2crypto?2asn1?2asn1_lib?4c?$AA@ ; ".\\crypto\\asn1\\asn1_lib.c"
		push	eax
		call	_CRYPTO_malloc
		add	esp, 0Ch
		jmp	short loc_291
; ---------------------------------------------------------------------------

loc_27D:				; CODE XREF: _ASN1_STRING_set+42j
		push	176h
		push	offset ??_C@_0BJ@BDGDICBL@?4?2crypto?2asn1?2asn1_lib?4c?$AA@ ; ".\\crypto\\asn1\\asn1_lib.c"
		push	eax
		push	ebp
		call	_CRYPTO_realloc
		add	esp, 10h

loc_291:				; CODE XREF: _ASN1_STRING_set+57j
		mov	[edi+8], eax
		test	eax, eax
		jnz	short loc_2BD
		push	179h
		push	offset ??_C@_0BJ@BDGDICBL@?4?2crypto?2asn1?2asn1_lib?4c?$AA@ ; ".\\crypto\\asn1\\asn1_lib.c"
		push	41h ; 'A'
		push	0BAh ; 'º'
		push	0Dh
		call	_ERR_put_error
		add	esp, 14h
		mov	[edi+8], ebp
		xor	eax, eax
		pop	edi
		pop	ebp
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_2BD:				; CODE XREF: _ASN1_STRING_set+38j
					; _ASN1_STRING_set+72j
		mov	[edi], esi
		test	ebx, ebx
		jz	short loc_2D5
		push	esi		; Size
		push	ebx		; Src
		push	eax		; Dst
		call	_memcpy
		mov	eax, [edi+8]
		add	esp, 0Ch
		mov	byte ptr [esi+eax], 0

loc_2D5:				; CODE XREF: _ASN1_STRING_set+9Dj
		pop	edi
		pop	ebp
		pop	esi
		mov	eax, 1
		pop	ebx
		retn
_ASN1_STRING_set endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ASN1_STRING_set0
_ASN1_STRING_set0 proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, [esi+8]
		test	eax, eax
		jz	short loc_2F5
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_2F5:				; CODE XREF: _ASN1_STRING_set0+Aj
		mov	eax, [esp+4+arg_4]
		mov	[esi+8], eax
		mov	eax, [esp+4+arg_8]
		mov	[esi], eax
		pop	esi
		retn
_ASN1_STRING_set0 endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 304h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ASN1_STRING_type
_ASN1_STRING_type proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+4]
		retn
_ASN1_STRING_type endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 30Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ASN1_STRING_type_new
_ASN1_STRING_type_new proc near

arg_0		= dword	ptr  4

		push	198h
		push	offset ??_C@_0BJ@BDGDICBL@?4?2crypto?2asn1?2asn1_lib?4c?$AA@ ; ".\\crypto\\asn1\\asn1_lib.c"
		push	10h
		call	_CRYPTO_malloc
		mov	ecx, eax
		add	esp, 0Ch
		test	ecx, ecx
		jnz	short loc_344
		push	19Ah
		push	offset ??_C@_0BJ@BDGDICBL@?4?2crypto?2asn1?2asn1_lib?4c?$AA@ ; ".\\crypto\\asn1\\asn1_lib.c"
		push	41h ; 'A'
		push	82h ; '‚'
		push	0Dh
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_344:				; CODE XREF: _ASN1_STRING_type_new+18j
		mov	eax, [esp+arg_0]
		mov	[ecx+4], eax
		mov	eax, ecx
		mov	dword ptr [ecx], 0
		mov	dword ptr [ecx+8], 0
		mov	dword ptr [ecx+0Ch], 0
		retn
_ASN1_STRING_type_new endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 364h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ASN1_check_infinite_end
_ASN1_check_infinite_end proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_4]
		test	eax, eax
		jle	short loc_387
		cmp	eax, 2
		jl	short loc_38D
		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		cmp	byte ptr [eax],	0
		jnz	short loc_38D
		cmp	byte ptr [eax+1], 0
		jnz	short loc_38D
		add	eax, 2
		mov	[ecx], eax

loc_387:				; CODE XREF: _ASN1_check_infinite_end+6j
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_38D:				; CODE XREF: _ASN1_check_infinite_end+Bj
					; _ASN1_check_infinite_end+16j	...
		xor	eax, eax
		retn
_ASN1_check_infinite_end endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 390h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ASN1_const_check_infinite_end
_ASN1_const_check_infinite_end proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_4]
		test	eax, eax
		jle	short loc_3B3
		cmp	eax, 2
		jl	short loc_3B9
		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		cmp	byte ptr [eax],	0
		jnz	short loc_3B9
		cmp	byte ptr [eax+1], 0
		jnz	short loc_3B9
		add	eax, 2
		mov	[ecx], eax

loc_3B3:				; CODE XREF: _ASN1_const_check_infinite_end+6j
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_3B9:				; CODE XREF: _ASN1_const_check_infinite_end+Bj
					; _ASN1_const_check_infinite_end+16j ...
		xor	eax, eax
		retn
_ASN1_const_check_infinite_end endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3BCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ASN1_get_object
_ASN1_get_object proc near		; CODE XREF: _asn1_GetSequence+1Dp

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	eax, 4
		call	__chkstk
		mov	ecx, [esp+4+arg_0]
		push	ebx
		push	ebp
		mov	ebp, [esp+0Ch+arg_10]
		mov	ecx, [ecx]
		push	esi
		push	edi
		test	ebp, ebp
		jz	$err$24
		movzx	edi, byte ptr [ecx]
		lea	esi, [ebp-1]
		mov	ebx, edi
		mov	eax, edi
		and	eax, 0C0h
		and	edi, 1Fh
		and	ebx, 20h
		mov	[esp+14h+var_4], eax
		inc	ecx
		cmp	edi, 1Fh
		jnz	short loc_444
		test	esi, esi
		jz	$err$24
		mov	al, [ecx]
		xor	edx, edx
		test	al, al
		jns	short loc_433
		nop

loc_40C:				; CODE XREF: _ASN1_get_object+75j
		movzx	eax, al
		inc	ecx
		and	eax, 7Fh
		shl	edx, 7
		or	edx, eax
		sub	esi, 1
		jz	$err$24
		cmp	edx, 0FFFFFFh
		jg	$err$24
		mov	al, [ecx]
		test	al, al
		js	short loc_40C

loc_433:				; CODE XREF: _ASN1_get_object+4Dj
		movzx	edi, byte ptr [ecx]
		inc	ecx
		and	edi, 7Fh
		shl	edx, 7
		or	edi, edx
		sub	esi, 1
		jmp	short loc_446
; ---------------------------------------------------------------------------

loc_444:				; CODE XREF: _ASN1_get_object+3Dj
		test	esi, esi

loc_446:				; CODE XREF: _ASN1_get_object+86j
		mov	[esp+14h+arg_10], ecx
		jz	short $err$24
		mov	eax, [esp+14h+arg_8]
		mov	ecx, [esp+14h+var_4]
		push	esi
		push	[esp+18h+arg_4]
		mov	[eax], edi
		mov	eax, [esp+1Ch+arg_C]
		mov	[eax], ecx
		lea	eax, [esp+1Ch+var_4]
		push	eax
		lea	eax, [esp+20h+arg_10]
		push	eax
		call	_asn1_get_length
		add	esp, 10h
		test	eax, eax
		jz	short $err$24
		mov	esi, [esp+14h+var_4]
		test	esi, esi
		jz	short loc_484
		test	bl, 20h
		jz	short $err$24

loc_484:				; CODE XREF: _ASN1_get_object+C1j
		mov	eax, [esp+14h+arg_0]
		mov	edi, [esp+14h+arg_10]
		mov	ecx, [esp+14h+arg_4]
		mov	eax, [eax]
		sub	eax, edi
		add	eax, ebp
		cmp	[ecx], eax
		jle	short loc_4BB
		push	93h ; '“'
		push	offset ??_C@_0BJ@BDGDICBL@?4?2crypto?2asn1?2asn1_lib?4c?$AA@ ; ".\\crypto\\asn1\\asn1_lib.c"
		push	9Bh ; '›'
		push	72h ; 'r'
		push	0Dh
		call	_ERR_put_error
		add	esp, 14h
		or	ebx, 80h

loc_4BB:				; CODE XREF: _ASN1_get_object+DCj
		mov	eax, [esp+14h+arg_0]
		or	esi, ebx
		mov	[eax], edi
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$err$24:				; CODE XREF: _ASN1_get_object+1Aj
					; _ASN1_get_object+41j	...
		push	9Dh ; ''
		push	offset ??_C@_0BJ@BDGDICBL@?4?2crypto?2asn1?2asn1_lib?4c?$AA@ ; ".\\crypto\\asn1\\asn1_lib.c"
		push	7Bh ; '{'
		push	72h ; 'r'
		push	0Dh
		call	_ERR_put_error
		add	esp, 14h
		mov	eax, 80h ; '€'
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
_ASN1_get_object endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4F0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ASN1_object_size
_ASN1_object_size proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_4]
		mov	edx, [esp+arg_8]
		lea	eax, [ecx+1]
		cmp	edx, 1Fh
		jl	short loc_508

loc_500:				; CODE XREF: _ASN1_object_size+16j
		sar	edx, 7
		inc	eax
		test	edx, edx
		jg	short loc_500

loc_508:				; CODE XREF: _ASN1_object_size+Ej
		cmp	[esp+arg_0], 2
		jnz	short loc_513
		add	eax, 3
		retn
; ---------------------------------------------------------------------------

loc_513:				; CODE XREF: _ASN1_object_size+1Dj
		inc	eax
		cmp	ecx, 7Fh ; ''
		jle	short locret_528
		nop	dword ptr [eax+00000000h]

loc_520:				; CODE XREF: _ASN1_object_size+36j
		sar	ecx, 8
		inc	eax
		test	ecx, ecx
		jg	short loc_520

locret_528:				; CODE XREF: _ASN1_object_size+27j
		retn
_ASN1_object_size endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 52Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ASN1_put_eoc
_ASN1_put_eoc	proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	word ptr [eax],	0
		add	eax, 2
		mov	[ecx], eax
		mov	eax, 2
		retn
_ASN1_put_eoc	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 544h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ASN1_put_object
_ASN1_put_object proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	eax, [esp+arg_10]
		mov	ecx, [esp+arg_C]
		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	esi
		push	edi
		mov	edi, [esp+0Ch+arg_4]
		mov	edx, edi
		mov	esi, [ebx]
		neg	edx
		sbb	edx, edx
		and	eax, 0C0h
		and	edx, 20h
		or	edx, eax
		cmp	ecx, 1Fh
		jge	short loc_578
		and	cl, 1Fh
		or	cl, dl
		mov	[esi], cl
		inc	esi
		jmp	short loc_5B9
; ---------------------------------------------------------------------------

loc_578:				; CODE XREF: _ASN1_put_object+28j
		or	dl, 1Fh
		xor	eax, eax
		mov	[esi], dl
		inc	esi
		mov	edx, ecx
		test	ecx, ecx
		jle	short loc_58E

loc_586:				; CODE XREF: _ASN1_put_object+48j
		sar	edx, 7
		inc	eax
		test	edx, edx
		jg	short loc_586

loc_58E:				; CODE XREF: _ASN1_put_object+40j
		push	ebp
		mov	ebp, eax
		test	eax, eax
		jle	short loc_5B6
		lea	edi, [eax-1]

loc_598:				; CODE XREF: _ASN1_put_object+6Cj
		dec	eax
		mov	dl, cl
		and	dl, 7Fh
		mov	[eax+esi], dl
		cmp	eax, edi
		jz	short loc_5AB
		or	dl, 80h
		mov	[eax+esi], dl

loc_5AB:				; CODE XREF: _ASN1_put_object+5Fj
		sar	ecx, 7
		test	eax, eax
		jg	short loc_598
		mov	edi, [esp+10h+arg_4]

loc_5B6:				; CODE XREF: _ASN1_put_object+4Fj
		add	esi, ebp
		pop	ebp

loc_5B9:				; CODE XREF: _ASN1_put_object+32j
		cmp	edi, 2
		jnz	short loc_5C8
		mov	byte ptr [esi],	80h ; '€'
		inc	esi
		pop	edi
		mov	[ebx], esi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_5C8:				; CODE XREF: _ASN1_put_object+78j
		mov	edx, [esp+0Ch+arg_8]
		cmp	edx, 7Fh ; ''
		jg	short loc_5DA
		mov	[esi], dl
		inc	esi
		pop	edi
		mov	[ebx], esi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_5DA:				; CODE XREF: _ASN1_put_object+8Bj
		xor	ecx, ecx
		mov	eax, edx
		test	edx, edx
		jle	short loc_5EC
		xchg	ax, ax

loc_5E4:				; CODE XREF: _ASN1_put_object+A6j
		sar	eax, 8
		inc	ecx
		test	eax, eax
		jg	short loc_5E4

loc_5EC:				; CODE XREF: _ASN1_put_object+9Cj
		mov	al, cl
		or	al, 80h
		mov	[esi], al
		inc	esi
		mov	eax, ecx
		test	ecx, ecx
		jle	short loc_604

loc_5F9:				; CODE XREF: _ASN1_put_object+BEj
		dec	ecx
		mov	[ecx+esi], dl
		sar	edx, 8
		test	ecx, ecx
		jg	short loc_5F9

loc_604:				; CODE XREF: _ASN1_put_object+B3j
		add	esi, eax
		pop	edi
		mov	[ebx], esi
		pop	esi
		pop	ebx
		retn
_ASN1_put_object endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 60Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__asn1_Finish	proc near		; CODE XREF: _asn1_Finishj
					; _asn1_const_Finishj

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		cmp	dword ptr [ecx+0Ch], 21h ; '!'
		jnz	short loc_63A
		cmp	dword ptr [ecx+4], 0
		jnz	short loc_63A
		mov	eax, [ecx+18h]
		test	eax, eax
		jle	short loc_63A
		cmp	eax, 2
		jl	short loc_65B
		mov	eax, [ecx]
		cmp	byte ptr [eax],	0
		jnz	short loc_65B
		cmp	byte ptr [eax+1], 0
		jnz	short loc_65B
		add	eax, 2
		mov	[ecx], eax

loc_63A:				; CODE XREF: __asn1_Finish+8j
					; __asn1_Finish+Ej ...
		mov	eax, [ecx+18h]
		test	eax, eax
		jz	short loc_649
		test	byte ptr [ecx+0Ch], 1
		jz	short loc_651
		test	eax, eax

loc_649:				; CODE XREF: __asn1_Finish+33j
		jns	short loc_665
		test	byte ptr [ecx+0Ch], 1
		jz	short loc_665

loc_651:				; CODE XREF: __asn1_Finish+39j
		mov	dword ptr [ecx+8], 3Eh ; '>'
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_65B:				; CODE XREF: __asn1_Finish+1Aj
					; __asn1_Finish+21j ...
		mov	dword ptr [ecx+8], 3Fh ; '?'
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_665:				; CODE XREF: __asn1_Finish:loc_649j
					; __asn1_Finish+43j
		mov	eax, 1
		retn
__asn1_Finish	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 66Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


__asn1_check_infinite_end proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_4]
		test	eax, eax
		jle	short loc_68F
		cmp	eax, 2
		jl	short loc_695
		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		cmp	byte ptr [eax],	0
		jnz	short loc_695
		cmp	byte ptr [eax+1], 0
		jnz	short loc_695
		add	eax, 2
		mov	[ecx], eax

loc_68F:				; CODE XREF: __asn1_check_infinite_end+6j
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_695:				; CODE XREF: __asn1_check_infinite_end+Bj
					; __asn1_check_infinite_end+16j ...
		xor	eax, eax
		retn
__asn1_check_infinite_end endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 698h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
; [00000005 BYTES: COLLAPSED FUNCTION _asn1_Finish]
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6A0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _asn1_GetSequence
_asn1_GetSequence proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		push	ebp
		push	esi
		mov	esi, [esp+0Ch+arg_0]
		push	edi
		mov	edi, [esp+10h+arg_4]
		mov	ebx, [esi]
		lea	eax, [esi+14h]
		lea	ebp, [esi+10h]
		push	dword ptr [edi]
		lea	ecx, [esi+18h]
		push	eax
		push	ebp
		push	ecx
		push	esi
		call	_ASN1_get_object
		add	esp, 14h
		mov	[esi+0Ch], eax
		test	al, al
		jns	short loc_6DA
		pop	edi
		mov	dword ptr [esi+8], 3Ch ; '<'
		xor	eax, eax
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_6DA:				; CODE XREF: _asn1_GetSequence+2Aj
		cmp	dword ptr [ebp+0], 10h
		jz	short loc_6EE
		pop	edi
		mov	dword ptr [esi+8], 3Dh ; '='
		xor	eax, eax
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_6EE:				; CODE XREF: _asn1_GetSequence+3Ej
		sub	ebx, [esi]
		add	[edi], ebx
		cmp	dword ptr [esi+1Ch], 0
		mov	ecx, [edi]
		jz	short loc_70C
		test	ecx, ecx
		jns	short loc_70C
		pop	edi
		mov	dword ptr [esi+8], 3Eh ; '>'
		xor	eax, eax
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_70C:				; CODE XREF: _asn1_GetSequence+58j
					; _asn1_GetSequence+5Cj
		cmp	dword ptr [esi+0Ch], 21h ; '!'
		jnz	short loc_71E
		mov	eax, [esi+24h]
		mov	eax, [eax]
		sub	eax, [esi]
		add	eax, ecx
		mov	[esi+18h], eax

loc_71E:				; CODE XREF: _asn1_GetSequence+70j
		pop	edi
		mov	dword ptr [esi+4], 0
		mov	eax, 1
		pop	esi
		pop	ebp
		pop	ebx
		retn
_asn1_GetSequence endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 730h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _asn1_add_error
_asn1_add_error	proc near

var_24		= byte ptr -24h
var_14		= byte ptr -14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 24h ; '$'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+24h+var_4], eax
		mov	eax, [esp+24h+arg_0]
		push	eax
		push	offset ??_C@_03FKNCMABI@?$CFlu?$AA@ ; `string'
		lea	eax, [esp+2Ch+var_14]
		push	0Dh
		push	eax
		call	_BIO_snprintf
		push	[esp+34h+arg_4]
		lea	eax, [esp+38h+var_24]
		push	offset ??_C@_02DPKJAMEF@?$CFd?$AA@ ; `string'
		push	0Dh
		push	eax
		call	_BIO_snprintf
		lea	eax, [esp+44h+var_24]
		push	eax
		push	offset ??_C@_08CPJNFLGB@?5offset?$DN?$AA@ ; " offset="
		lea	eax, [esp+4Ch+var_14]
		push	eax
		push	offset ??_C@_08CLFLHNDD@address?$DN?$AA@ ; "address="
		push	4
		call	_ERR_add_error_data
		mov	ecx, [esp+58h+var_4]
		add	esp, 34h
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 24h
		retn
_asn1_add_error	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7A0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _asn1_const_Finish
_asn1_const_Finish proc	near
		jmp	__asn1_Finish
_asn1_const_Finish endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7A8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_asn1_get_length proc near		; CODE XREF: _ASN1_get_object+AFp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	ebx
		mov	ebx, [esp+4+arg_0]
		xor	eax, eax
		push	edi
		mov	edi, [esp+8+arg_C]
		mov	edx, [ebx]
		cmp	edi, 1
		jge	short loc_7BE
		pop	edi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_7BE:				; CODE XREF: _asn1_get_length+11j
		cmp	byte ptr [edx],	80h ; '€'
		push	esi
		jnz	short loc_7E2
		mov	eax, [esp+0Ch+arg_4]
		mov	dword ptr [eax], 1
		xor	eax, eax
		inc	edx

loc_7D1:				; CODE XREF: _asn1_get_length+5Cj
					; _asn1_get_length+77j
		mov	ecx, [esp+0Ch+arg_8]
		pop	esi
		mov	[ebx], edx
		pop	edi
		mov	[ecx], eax
		mov	eax, 1
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_7E2:				; CODE XREF: _asn1_get_length+1Aj
		mov	ecx, [esp+0Ch+arg_4]
		mov	[ecx], eax
		mov	cl, [edx]
		inc	edx
		movzx	esi, cl
		and	esi, 7Fh
		and	cl, 80h
		jz	short loc_818
		cmp	esi, 4
		ja	short loc_821
		lea	ecx, [edi-1]
		cmp	ecx, esi
		jl	short loc_821
		test	esi, esi
		jz	short loc_7D1
		xchg	ax, ax

loc_808:				; CODE XREF: _asn1_get_length+6Cj
		movzx	ecx, byte ptr [edx]
		inc	edx
		shl	eax, 8
		or	eax, ecx
		sub	esi, 1
		jnz	short loc_808
		jmp	short loc_81A
; ---------------------------------------------------------------------------

loc_818:				; CODE XREF: _asn1_get_length+4Cj
		mov	eax, esi

loc_81A:				; CODE XREF: _asn1_get_length+6Ej
		cmp	eax, 7FFFFFFFh
		jbe	short loc_7D1

loc_821:				; CODE XREF: _asn1_get_length+51j
					; _asn1_get_length+58j
		pop	esi
		pop	edi
		xor	eax, eax
		pop	ebx
		retn
_asn1_get_length endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 828h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_asn1_put_length proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		push	esi
		push	edi
		mov	edi, [esp+8+arg_0]
		mov	esi, [edi]
		cmp	edx, 7Fh ; ''
		jg	short loc_841
		mov	[esi], dl
		inc	esi
		mov	[edi], esi
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_841:				; CODE XREF: _asn1_put_length+Fj
		xor	eax, eax
		mov	ecx, edx
		test	edx, edx
		jle	short loc_851

loc_849:				; CODE XREF: _asn1_put_length+27j
		sar	ecx, 8
		inc	eax
		test	ecx, ecx
		jg	short loc_849

loc_851:				; CODE XREF: _asn1_put_length+1Fj
		mov	cl, al
		or	cl, 80h
		mov	[esi], cl
		inc	esi
		mov	ecx, eax
		test	eax, eax
		jle	short loc_86A

loc_85F:				; CODE XREF: _asn1_put_length+40j
		dec	eax
		mov	[eax+esi], dl
		sar	edx, 8
		test	eax, eax
		jg	short loc_85F

loc_86A:				; CODE XREF: _asn1_put_length+35j
		add	esi, ecx
		mov	[edi], esi
		pop	edi
		pop	esi
		retn
_asn1_put_length endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 874h
; COMDAT (pick any)
		public ??_C@_0BJ@BDGDICBL@?4?2crypto?2asn1?2asn1_lib?4c?$AA@
; `string'
??_C@_0BJ@BDGDICBL@?4?2crypto?2asn1?2asn1_lib?4c?$AA@ db '.\crypto\asn1\asn1_lib.c',0
					; DATA XREF: _ASN1_STRING_new+5o
					; _ASN1_STRING_new+1Do	...
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 890h
; COMDAT (pick any)
		public ??_C@_03FKNCMABI@?$CFlu?$AA@
; `string'
??_C@_03FKNCMABI@?$CFlu?$AA@ dd	756C25h	; DATA XREF: _asn1_add_error+1Ao
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 894h
; COMDAT (pick any)
		public ??_C@_02DPKJAMEF@?$CFd?$AA@
; `string'
??_C@_02DPKJAMEF@?$CFd?$AA@ db 25h, 64h, 0 ; DATA XREF:	_asn1_add_error+33o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 898h
; COMDAT (pick any)
		public ??_C@_08CPJNFLGB@?5offset?$DN?$AA@
; `string'
??_C@_08CPJNFLGB@?5offset?$DN?$AA@ db ' offset=',0 ; DATA XREF: _asn1_add_error+45o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8A4h
; COMDAT (pick any)
		public ??_C@_08CLFLHNDD@address?$DN?$AA@
; `string'
??_C@_08CLFLHNDD@address?$DN?$AA@ db 'address=',0 ; DATA XREF: _asn1_add_error+4Fo
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _CRYPTO_malloc:near ; CODE XREF: _ASN1_STRING_new+Cp
					; _ASN1_STRING_set+4Fp	...
		extrn _CRYPTO_free:near	; CODE XREF: _ASN1_STRING_clear_free+2Fp
					; _ASN1_STRING_clear_free+38p ...
		extrn _CRYPTO_realloc:near ; CODE XREF:	_ASN1_STRING_set+65p
		extrn _OPENSSL_cleanse:near ; CODE XREF: _ASN1_STRING_clear_free+19p
		extrn _BIO_snprintf:near ; CODE	XREF: _asn1_add_error+26p
					; _asn1_add_error+3Bp
		extrn _ERR_put_error:near ; CODE XREF: _ASN1_STRING_new+2Bp
					; _ASN1_STRING_set+87p	...
		extrn _ERR_add_error_data:near ; CODE XREF: _asn1_add_error+56p
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _asn1_add_error+64p
		extrn __chkstk:near	; CODE XREF: _ASN1_get_object+5p
					; _asn1_add_error+5p
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _ASN1_STRING_set+A2p
		extrn ___security_cookie:near ;	DATA XREF: _asn1_add_error+Ar


		end
