;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	145B11F354B0693CBEF5C25614532950
; Input	CRC32 :	0F70F2A5

; File Name   :	C:\compspace\Diff\openssl\obj\uplink.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data		segment	para public 'DATA' use32
		assume cs:_data
		public _OPENSSL_UplinkTable
_OPENSSL_UplinkTable dd	16h		; DATA XREF: _lazy1+2o	_lazy2+2o ...
off_4		dd offset _lazy1	; DATA XREF: _lazy1+Fr
off_8		dd offset _lazy2	; DATA XREF: _lazy2+Fr
off_C		dd offset _lazy3	; DATA XREF: _lazy3+Fr
off_10		dd offset _lazy4	; DATA XREF: _lazy4+Fr
off_14		dd offset _lazy5	; DATA XREF: _lazy5+Fr
off_18		dd offset _lazy6	; DATA XREF: _lazy6+Fr
off_1C		dd offset _lazy7	; DATA XREF: _lazy7+Fr
off_20		dd offset _lazy8	; DATA XREF: _lazy8+Fr
off_24		dd offset _lazy9	; DATA XREF: _lazy9+Fr
off_28		dd offset _lazy10	; DATA XREF: _lazy10+Fr
off_2C		dd offset _lazy11	; DATA XREF: _lazy11+Fr
off_30		dd offset _lazy12	; DATA XREF: _lazy12+Fr
off_34		dd offset _lazy13	; DATA XREF: _lazy13+Fr
off_38		dd offset _lazy14	; DATA XREF: _lazy14+Fr
off_3C		dd offset _lazy15	; DATA XREF: _lazy15+Fr
off_40		dd offset _lazy16	; DATA XREF: _lazy16+Fr
off_44		dd offset _lazy17	; DATA XREF: _lazy17+Fr
off_48		dd offset _lazy18	; DATA XREF: _lazy18+Fr
off_4C		dd offset _lazy19	; DATA XREF: _lazy19+Fr
off_50		dd offset _lazy20	; DATA XREF: _lazy20+Fr
off_54		dd offset _lazy21	; DATA XREF: _lazy21+Fr
off_58		dd offset _lazy22	; DATA XREF: _lazy22+Fr
off_5C		dd offset _lazy23	; DATA XREF: _lazy23+Fr
off_60		dd offset _lazy24	; DATA XREF: _lazy24+Fr
off_64		dd offset _lazy25	; DATA XREF: _lazy25+Fr
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_bss		segment	para public 'BSS' use32
		assume cs:_bss
		;org 68h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; LPCSTR `OPENSSL_Uplink'::`2'::apphandle
?apphandle@?1??OPENSSL_Uplink@@9@9 dd ?	; DATA XREF: _OPENSSL_Uplink+36r
					; _OPENSSL_Uplink+80w ...
; `OPENSSL_Uplink'::`2'::applinktable
?applinktable@?1??OPENSSL_Uplink@@9@9 dd ? ; DATA XREF:	_OPENSSL_Uplink+B3r
					; _OPENSSL_Uplink:loc_474w ...
; char msg[]
_msg		xmmword	?		; DATA XREF: _OPENSSL_Uplink+18o
					; _OPENSSL_Uplink+3Ew ...
dword_80	dd ?			; DATA XREF: _OPENSSL_Uplink+45w
					; _OPENSSL_Uplink+91w ...
word_84		dw ?			; DATA XREF: _OPENSSL_Uplink+52w
byte_86		db ?			; DATA XREF: _OPENSSL_Uplink+5Fw
		align 4
		dd 1Ah dup(?)
_bss		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy1		proc near		; CODE XREF: _lazy1+Fj
					; DATA XREF: .data:off_4o
		push	1
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_4
_lazy1		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 108h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy2		proc near		; CODE XREF: _lazy2+Fj
					; DATA XREF: .data:off_8o
		push	2
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_8
_lazy2		endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 120h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy3		proc near		; CODE XREF: _lazy3+Fj
					; DATA XREF: .data:off_Co
		push	3
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_C
_lazy3		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 138h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy4		proc near		; CODE XREF: _lazy4+Fj
					; DATA XREF: .data:off_10o
		push	4
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_10
_lazy4		endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 150h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy5		proc near		; CODE XREF: _lazy5+Fj
					; DATA XREF: .data:off_14o
		push	5
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_14
_lazy5		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 168h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy6		proc near		; CODE XREF: _lazy6+Fj
					; DATA XREF: .data:off_18o
		push	6
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_18
_lazy6		endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 180h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy7		proc near		; CODE XREF: _lazy7+Fj
					; DATA XREF: .data:off_1Co
		push	7
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_1C
_lazy7		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 198h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy8		proc near		; CODE XREF: _lazy8+Fj
					; DATA XREF: .data:off_20o
		push	8
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_20
_lazy8		endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1B0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy9		proc near		; CODE XREF: _lazy9+Fj
					; DATA XREF: .data:off_24o
		push	9
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_24
_lazy9		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1C8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy10		proc near		; CODE XREF: _lazy10+Fj
					; DATA XREF: .data:off_28o
		push	0Ah
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_28
_lazy10		endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1E0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy11		proc near		; CODE XREF: _lazy11+Fj
					; DATA XREF: .data:off_2Co
		push	0Bh
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_2C
_lazy11		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1F8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy12		proc near		; CODE XREF: _lazy12+Fj
					; DATA XREF: .data:off_30o
		push	0Ch
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_30
_lazy12		endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 210h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy13		proc near		; CODE XREF: _lazy13+Fj
					; DATA XREF: .data:off_34o
		push	0Dh
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_34
_lazy13		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 228h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy14		proc near		; CODE XREF: _lazy14+Fj
					; DATA XREF: .data:off_38o
		push	0Eh
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_38
_lazy14		endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 240h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy15		proc near		; CODE XREF: _lazy15+Fj
					; DATA XREF: .data:off_3Co
		push	0Fh
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_3C
_lazy15		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 258h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy16		proc near		; CODE XREF: _lazy16+Fj
					; DATA XREF: .data:off_40o
		push	10h
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_40
_lazy16		endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 270h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy17		proc near		; CODE XREF: _lazy17+Fj
					; DATA XREF: .data:off_44o
		push	11h
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_44
_lazy17		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 288h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy18		proc near		; CODE XREF: _lazy18+Fj
					; DATA XREF: .data:off_48o
		push	12h
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_48
_lazy18		endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2A0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy19		proc near		; CODE XREF: _lazy19+Fj
					; DATA XREF: .data:off_4Co
		push	13h
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_4C
_lazy19		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2B8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy20		proc near		; CODE XREF: _lazy20+Fj
					; DATA XREF: .data:off_50o
		push	14h
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_50
_lazy20		endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2D0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy21		proc near		; CODE XREF: _lazy21+Fj
					; DATA XREF: .data:off_54o
		push	15h
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_54
_lazy21		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy22		proc near		; CODE XREF: _lazy22+Fj
					; DATA XREF: .data:off_58o
		push	16h
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_58
_lazy22		endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 300h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy23		proc near		; CODE XREF: _lazy23+Fj
					; DATA XREF: .data:off_5Co
		push	17h
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_5C
_lazy23		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 318h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy24		proc near		; CODE XREF: _lazy24+Fj
					; DATA XREF: .data:off_60o
		push	18h
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_60
_lazy24		endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 330h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_lazy25		proc near		; CODE XREF: _lazy25+Fj
					; DATA XREF: .data:off_64o
		push	19h
		push	offset _OPENSSL_UplinkTable
		call	_OPENSSL_Uplink
		add	esp, 8
		jmp	off_64
_lazy25		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 348h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _OPENSSL_Uplink
_OPENSSL_Uplink	proc near		; CODE XREF: _lazy1+7p	_lazy2+7p ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		push	ebp
		mov	ebp, [esp+8+arg_0]
		push	esi
		mov	esi, [esp+0Ch+arg_4]
		push	edi
		push	esi
		push	ebp
		push	offset ??_C@_0BK@OLLBCFDA@OPENSSL_Uplink?$CI?$CFp?0?$CF02X?$CJ?3?5?$AA@	; "OPENSSL_Uplink(%p,%02X): "
		push	80h ; '€'       ; Count
		push	offset _msg	; Dest
		mov	edi, offset _unimplemented
		call	__snprintf
		movups	xmm0, ds:??_C@_0BH@NCBMGNFI@unimplemented?5function?$AA@ ; `string'
		mov	ecx, ds:dword_588
		mov	ebx, eax
		mov	eax, ds:?apphandle@?1??OPENSSL_Uplink@@9@9 ; `OPENSSL_Uplink'::`2'::apphandle
		add	esp, 14h
		movups	ds:_msg[ebx], xmm0
		mov	ds:dword_80[ebx], ecx
		mov	cx, ds:word_58C
		mov	ds:word_84[ebx], cx
		mov	cl, ds:byte_58E
		mov	ds:byte_86[ebx], cl
		test	eax, eax
		jnz	short loc_3ED
		push	eax		; lpModuleName
		call	dword ptr ds:__imp__GetModuleHandleA@4 ; GetModuleHandleA(x)
		test	eax, eax
		jnz	short loc_3E8
		movups	xmm0, ds:??_C@_0BE@IDFBNOIA@no?5host?5application?$AA@ ; `string'
		mov	eax, ds:dword_5A0
		mov	ds:?apphandle@?1??OPENSSL_Uplink@@9@9, 0FFFFFFFFh ; `OPENSSL_Uplink'::`2'::apphandle
		movups	ds:_msg[ebx], xmm0
		mov	ds:dword_80[ebx], eax
		mov	[ebp+esi*4+0], edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_3E8:				; CODE XREF: _OPENSSL_Uplink+72j
		mov	ds:?apphandle@?1??OPENSSL_Uplink@@9@9, eax ; `OPENSSL_Uplink'::`2'::apphandle

loc_3ED:				; CODE XREF: _OPENSSL_Uplink+67j
		mov	eax, ds:?apphandle@?1??OPENSSL_Uplink@@9@9 ; `OPENSSL_Uplink'::`2'::apphandle
		cmp	eax, 0FFFFFFFFh
		jz	loc_48C
		cmp	ds:?applinktable@?1??OPENSSL_Uplink@@9@9, 0 ; `OPENSSL_Uplink'::`2'::applinktable
		jnz	short loc_47B
		push	offset ??_C@_0BA@OADNPGJF@OPENSSL_Applink?$AA@ ; "OPENSSL_Applink"
		push	eax		; hModule
		call	dword ptr ds:__imp__GetProcAddress@8 ; GetProcAddress(x,x)
		test	eax, eax
		jnz	short loc_44D
		movups	xmm0, ds:??_C@_0BD@BGGIKGMH@no?5OPENSSL_Applink?$AA@ ; `string'
		mov	ax, ds:word_5C4
		mov	ds:?apphandle@?1??OPENSSL_Uplink@@9@9, 0FFFFFFFFh ; `OPENSSL_Uplink'::`2'::apphandle
		movups	ds:_msg[ebx], xmm0
		mov	word ptr ds:dword_80[ebx], ax
		mov	al, ds:byte_5C6
		mov	byte ptr ds:(dword_80+2)[ebx], al
		mov	[ebp+esi*4+0], edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_44D:				; CODE XREF: _OPENSSL_Uplink+CAj
		call	eax
		test	eax, eax
		jnz	short loc_474
		movups	xmm0, ds:??_C@_0BA@OHMIFFKM@no?5ApplinkTable?$AA@ ; `string'
		mov	ds:?apphandle@?1??OPENSSL_Uplink@@9@9, 0FFFFFFFFh ; `OPENSSL_Uplink'::`2'::apphandle
		movups	ds:_msg[ebx], xmm0
		mov	[ebp+esi*4+0], edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_474:				; CODE XREF: _OPENSSL_Uplink+109j
		mov	ds:?applinktable@?1??OPENSSL_Uplink@@9@9, eax ;	`OPENSSL_Uplink'::`2'::applinktable
		jmp	short loc_480
; ---------------------------------------------------------------------------

loc_47B:				; CODE XREF: _OPENSSL_Uplink+BAj
		mov	eax, ds:?applinktable@?1??OPENSSL_Uplink@@9@9 ;	`OPENSSL_Uplink'::`2'::applinktable

loc_480:				; CODE XREF: _OPENSSL_Uplink+131j
		cmp	esi, [eax]
		jg	short loc_48C
		mov	eax, [eax+esi*4]
		test	eax, eax
		cmovnz	edi, eax

loc_48C:				; CODE XREF: _OPENSSL_Uplink+ADj
					; _OPENSSL_Uplink+13Aj
		mov	[ebp+esi*4+0], edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_OPENSSL_Uplink	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 498h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public ___local_stdio_printf_options
___local_stdio_printf_options proc near	; CODE XREF: __snprintf+13p
					; __vsnprintf+12p ...
		mov	eax, offset ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
		retn
___local_stdio_printf_options endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4A0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int _snprintf(char *Dest, size_t Count, const	char *Format, ...)
		public __snprintf
__snprintf	proc near		; CODE XREF: _OPENSSL_Uplink+22p

Dest		= dword	ptr  4
Count		= dword	ptr  8
Format		= dword	ptr  0Ch
arg_C		= byte ptr  10h

		lea	eax, [esp+arg_C]
		push	eax
		push	0
		push	[esp+8+Format]
		push	[esp+0Ch+Count]
		push	[esp+10h+Dest]
		call	___local_stdio_printf_options
		mov	ecx, [eax]
		push	dword ptr [eax+4]
		or	ecx, 1
		push	ecx
		call	dword ptr ds:__imp____stdio_common_vsprintf
		or	ecx, 0FFFFFFFFh
		add	esp, 1Ch
		test	eax, eax
		cmovs	eax, ecx
		retn
__snprintf	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4D4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl _vsnprintf(char *Dest, size_t Count, const char *Format, va_list Args)
		public __vsnprintf
__vsnprintf	proc near

Dest		= dword	ptr  4
Count		= dword	ptr  8
Format		= dword	ptr  0Ch
Args		= dword	ptr  10h

		push	[esp+Args]
		push	0
		push	[esp+8+Format]
		push	[esp+0Ch+Count]
		push	[esp+10h+Dest]
		call	___local_stdio_printf_options
		mov	ecx, [eax]
		push	dword ptr [eax+4]
		or	ecx, 1
		push	ecx
		call	dword ptr ds:__imp____stdio_common_vsprintf
		or	ecx, 0FFFFFFFFh
		add	esp, 1Ch
		test	eax, eax
		cmovs	eax, ecx
		retn
__vsnprintf	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 508h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl _vsnprintf_l(char	*DstBuf, size_t	MaxCount, const	char *Format, _locale_t	Locale,	va_list	ArgList)
		public __vsnprintf_l
__vsnprintf_l	proc near

DstBuf		= dword	ptr  4
MaxCount	= dword	ptr  8
Format		= dword	ptr  0Ch
Locale		= dword	ptr  10h
ArgList		= dword	ptr  14h

		push	[esp+ArgList]
		push	[esp+4+Locale]
		push	[esp+8+Format]
		push	[esp+0Ch+MaxCount]
		push	[esp+10h+DstBuf]
		call	___local_stdio_printf_options
		mov	ecx, [eax]
		push	dword ptr [eax+4]
		or	ecx, 1
		push	ecx
		call	dword ptr ds:__imp____stdio_common_vsprintf
		or	ecx, 0FFFFFFFFh
		add	esp, 1Ch
		test	eax, eax
		cmovs	eax, ecx
		retn
__vsnprintf_l	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 53Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

_unimplemented	proc near		; DATA XREF: _OPENSSL_Uplink+1Do
		push	offset _msg
		push	offset ??_C@_03OFAPEBGM@?$CFs?6?$AA@ ; `string'
		call	_OPENSSL_showfatal
		add	esp, 8
		push	1		; uExitCode
		call	dword ptr ds:__imp__ExitProcess@4 ; ExitProcess(x)
_unimplemented	endp

; ---------------------------------------------------------------------------
$LN4		db 0CCh			; $LN3
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 558h
; COMDAT (pick any)
		public ??_C@_03OFAPEBGM@?$CFs?6?$AA@
; `string'
??_C@_03OFAPEBGM@?$CFs?6?$AA@ dd 0A7325h ; DATA	XREF: _unimplemented+5o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 55Ch
; COMDAT (pick any)
		public ??_C@_0BK@OLLBCFDA@OPENSSL_Uplink?$CI?$CFp?0?$CF02X?$CJ?3?5?$AA@
; char `string'[]
??_C@_0BK@OLLBCFDA@OPENSSL_Uplink?$CI?$CFp?0?$CF02X?$CJ?3?5?$AA@ db 'OPENSSL_Uplink(%p,%02X): ',0
					; DATA XREF: _OPENSSL_Uplink+Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 578h
; COMDAT (pick any)
		public ??_C@_0BH@NCBMGNFI@unimplemented?5function?$AA@
; `string'
??_C@_0BH@NCBMGNFI@unimplemented?5function?$AA@	xmmword	7566206465746E656D656C706D696E75h
					; DATA XREF: _OPENSSL_Uplink+27r
dword_588	dd 6974636Eh		; DATA XREF: _OPENSSL_Uplink+2Er
word_58C	dw 6E6Fh		; DATA XREF: _OPENSSL_Uplink+4Br
byte_58E	db 0			; DATA XREF: _OPENSSL_Uplink+59r
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 590h
; COMDAT (pick any)
		public ??_C@_0BE@IDFBNOIA@no?5host?5application?$AA@
; `string'
??_C@_0BE@IDFBNOIA@no?5host?5application?$AA@ xmmword 746163696C7070612074736F68206F6Eh
					; DATA XREF: _OPENSSL_Uplink+74r
dword_5A0	dd 6E6F69h		; DATA XREF: _OPENSSL_Uplink+7Br
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5A4h
; COMDAT (pick any)
		public ??_C@_0BA@OADNPGJF@OPENSSL_Applink?$AA@
; CHAR `string'[]
??_C@_0BA@OADNPGJF@OPENSSL_Applink?$AA@	db 'OPENSSL_Applink',0
					; DATA XREF: _OPENSSL_Uplink+BCo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5B4h
; COMDAT (pick any)
		public ??_C@_0BD@BGGIKGMH@no?5OPENSSL_Applink?$AA@
; `string'
??_C@_0BD@BGGIKGMH@no?5OPENSSL_Applink?$AA@ xmmword 696C7070415F4C53534E45504F206F6Eh
					; DATA XREF: _OPENSSL_Uplink+CCr
word_5C4	dw 6B6Eh		; DATA XREF: _OPENSSL_Uplink+D3r
byte_5C6	db 0			; DATA XREF: _OPENSSL_Uplink+F1r
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5C8h
; COMDAT (pick any)
		public ??_C@_0BA@OHMIFFKM@no?5ApplinkTable?$AA@
; `string'
??_C@_0BA@OHMIFFKM@no?5ApplinkTable?$AA@ xmmword 656C6261546B6E696C707041206F6Eh
					; DATA XREF: _OPENSSL_Uplink+10Br
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; void __stdcall __noreturn ExitProcess(UINT uExitCode)
		extrn __imp__ExitProcess@4:near	; CODE XREF: _unimplemented+14p
					; DATA XREF: _unimplemented+14r
; HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName)
		extrn __imp__GetModuleHandleA@4:near ; CODE XREF: _OPENSSL_Uplink+6Ap
					; DATA XREF: _OPENSSL_Uplink+6Ar
; FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName)
		extrn __imp__GetProcAddress@8:near ; CODE XREF:	_OPENSSL_Uplink+C2p
					; DATA XREF: _OPENSSL_Uplink+C2r
		extrn __imp____stdio_common_vsprintf:near ; CODE XREF: __snprintf+21p
					; __vsnprintf+20p ...
		extrn _OPENSSL_showfatal:near ;	CODE XREF: _unimplemented+Ap
; `__local_stdio_printf_options'::`2'::_OptionsStorage
		extrn ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:near
					; DATA XREF: ___local_stdio_printf_optionso


		end
