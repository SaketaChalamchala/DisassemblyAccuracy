;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	BAE89BDDAA7E2CC47F4436F5EC56DEBD
; Input	CRC32 :	D5D8DB61

; File Name   :	C:\compspace\Diff\openssl\obj\ssl_lib.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data		segment	para public 'DATA' use32
		assume cs:_data
		public _ssl3_undef_enc_method
_ssl3_undef_enc_method dd offset _ssl_undefined_function
		dd offset _ssl_undefined_function
		dd offset _ssl_undefined_function
		dd offset _ssl_undefined_function
		dd offset _ssl_undefined_function
		dd offset _ssl_undefined_function
		dd 0
		dd offset _ssl_undefined_function
		dd 4 dup(0)
		dd offset _ssl_undefined_function
		dd offset _ssl_undefined_function
		dd 4 dup(0)
		public _SSL_version_str
_SSL_version_str dd offset ??_C@_0BL@EECJKKOB@OpenSSL?51?40?42h?5?53?5May?52016?$AA@ ; "OpenSSL	1.0.2h	3 May 2016"
; `ssl_cipher_list_to_bytes'::`6'::scsv
?scsv@?5??ssl_cipher_list_to_bytes@@9@9	dd 2 dup(0)
					; DATA XREF: _ssl_cipher_list_to_bytes+C1o
		dd 30000FFh, 9 dup(0)
; `ssl_cipher_list_to_bytes'::`7'::scsv
?scsv@?6??ssl_cipher_list_to_bytes@@9@9	dd 2 dup(0)
					; DATA XREF: _ssl_cipher_list_to_bytes+DBo
		dd 3005600h, 9 dup(0)
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACh
; COMDAT (pick any)
		public ??_C@_0BL@EECJKKOB@OpenSSL?51?40?42h?5?53?5May?52016?$AA@
; `string'
??_C@_0BL@EECJKKOB@OpenSSL?51?40?42h?5?53?5May?52016?$AA@ db 'OpenSSL 1.0.2h  3 May 2016',0
					; DATA XREF: .data:_SSL_version_stro
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_undefined_function
_ssl_undefined_function	proc near	; DATA XREF: .data:_ssl3_undef_enc_methodo
					; .data:00000004o ...
		push	0B05h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	42h ; 'B'
		push	0C5h ; 'Å'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
_ssl_undefined_function	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _OBJ_bsearch_ssl_cipher_id
_OBJ_bsearch_ssl_cipher_id proc	near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	offset _ssl_cipher_id_cmp_BSEARCH_CMP_FN
		push	30h ; '0'
		push	[esp+8+arg_8]
		push	[esp+0Ch+arg_4]
		push	[esp+10h+arg_0]
		call	_OBJ_bsearch_
		add	esp, 14h
		retn
_OBJ_bsearch_ssl_cipher_id endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 104h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_callback_ctrl
_SSL_CTX_callback_ctrl proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	edx, [esp+arg_4]
		mov	eax, [esp+arg_0]
		cmp	edx, 0Fh
		jz	short loc_120
		mov	ecx, [eax]
		mov	[esp+arg_4], edx
		mov	[esp+arg_0], eax
		mov	eax, [ecx+70h]
		jmp	eax
; ---------------------------------------------------------------------------

loc_120:				; CODE XREF: _SSL_CTX_callback_ctrl+Bj
		mov	ecx, [esp+arg_8]
		mov	[eax+0B8h], ecx
		mov	eax, 1
		retn
_SSL_CTX_callback_ctrl endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 130h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_check_private_key
_SSL_CTX_check_private_key proc	near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short loc_17D
		mov	eax, [eax+0B0h]
		test	eax, eax
		jz	short loc_17D
		mov	eax, [eax]
		mov	ecx, [eax]
		test	ecx, ecx
		jz	short loc_17D
		mov	eax, [eax+4]
		test	eax, eax
		jnz	short loc_172
		push	3C3h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0BEh ; '¾'
		push	0A8h ; '¨'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_172:				; CODE XREF: _SSL_CTX_check_private_key+1Fj
		push	eax
		push	ecx
		call	_X509_check_private_key
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_17D:				; CODE XREF: _SSL_CTX_check_private_key+6j
					; _SSL_CTX_check_private_key+10j ...
		push	3BEh
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0B1h ; '±'
		push	0A8h ; '¨'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
_SSL_CTX_check_private_key endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1A0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_ctrl
_SSL_CTX_ctrl	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	edx, [esp+arg_0]
		test	edx, edx
		jnz	short loc_1E0
		mov	eax, [esp+arg_4]
		cmp	eax, 5Ch ; '\'
		jz	short loc_1CF
		cmp	eax, 62h ; 'b'
		jz	short loc_1BE
		cmp	eax, 66h ; 'f'
		jz	short loc_1BE
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1BE:				; CODE XREF: _SSL_CTX_ctrl+14j
					; _SSL_CTX_ctrl+19j
		push	0
		push	[esp+4+arg_C]
		push	0
		call	_tls1_set_sigalgs_list
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_1CF:				; CODE XREF: _SSL_CTX_ctrl+Fj
		push	[esp+arg_C]
		push	0
		push	0
		call	_tls1_set_curves_list
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_1E0:				; CODE XREF: _SSL_CTX_ctrl+6j
		push	esi
		mov	esi, [esp+4+arg_4]
		lea	eax, [esi-10h]	; switch 85 cases
		cmp	eax, 54h ; 'T'
		ja	$LN40		; jumptable 000001F8 default case
		movzx	ecx, ds:$LN42[eax]
		jmp	ds:$LN45[ecx*4]	; switch jump
; ---------------------------------------------------------------------------

$LN10_0:				; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [edx+0B4h]	; jumptable 000001F8 case 40
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN11_0:				; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [edx+0B4h]	; jumptable 000001F8 case 41
		mov	ecx, [esp+4+arg_8]
		mov	[edx+0B4h], ecx
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN12_0:				; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [esp+4+arg_C] ; jumptable 000001F8	case 16
		mov	[edx+0BCh], eax
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN13_0:				; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [edx+0ACh]	; jumptable 000001F8 case 50
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN14:					; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [edx+0ACh]	; jumptable 000001F8 case 51
		mov	ecx, [esp+4+arg_8]
		mov	[edx+0ACh], ecx
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN15:					; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [edx+14h]	; jumptable 000001F8 case 42
		mov	ecx, [esp+4+arg_8]
		mov	[edx+14h], ecx
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN16_0:				; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [edx+14h]	; jumptable 000001F8 case 43
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN17:					; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [edx+20h]	; jumptable 000001F8 case 44
		mov	ecx, [esp+4+arg_8]
		mov	[edx+20h], ecx
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN18_0:				; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [edx+20h]	; jumptable 000001F8 case 45
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN19:					; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		push	dword ptr [edx+10h] ; jumptable	000001F8 case 20
		call	_lh_num_items
		add	esp, 4
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN20_0:				; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [edx+34h]	; jumptable 000001F8 case 21
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN21_0:				; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [edx+3Ch]	; jumptable 000001F8 case 22
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN22:					; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [edx+38h]	; jumptable 000001F8 case 23
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN23_0:				; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [edx+40h]	; jumptable 000001F8 case 24
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN24:					; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [edx+48h]	; jumptable 000001F8 case 25
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN25:					; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [edx+44h]	; jumptable 000001F8 case 26
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN26:					; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [edx+58h]	; jumptable 000001F8 case 27
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN27_0:				; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [edx+5Ch]	; jumptable 000001F8 case 28
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN28:					; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [edx+4Ch]	; jumptable 000001F8 case 29
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN29:					; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [edx+50h]	; jumptable 000001F8 case 30
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN30_0:				; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [edx+54h]	; jumptable 000001F8 case 31
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN31:					; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [edx+0A4h]	; jumptable 000001F8 case 32
		or	eax, [esp+4+arg_8]
		mov	[edx+0A4h], eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN32:					; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [esp+4+arg_8] ; jumptable 000001F8	case 77
		not	eax
		and	eax, [edx+0A4h]
		mov	[edx+0A4h], eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN33:					; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [edx+0A8h]	; jumptable 000001F8 case 33
		or	eax, [esp+4+arg_8]
		mov	[edx+0A8h], eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN34:					; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	eax, [esp+4+arg_8] ; jumptable 000001F8	case 78
		not	eax
		and	eax, [edx+0A8h]
		mov	[edx+0A8h], eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN35:					; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	ecx, [esp+4+arg_8] ; jumptable 000001F8	case 52
		lea	eax, [ecx-200h]
		cmp	eax, 3E00h
		ja	short loc_314
		mov	[edx+0F8h], ecx
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_314:				; CODE XREF: _SSL_CTX_ctrl+165j
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN38:					; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	ecx, [edx+0B0h]	; jumptable 000001F8 case 99
		pop	esi
		mov	eax, [ecx+38h]
		or	eax, [esp+arg_8]
		mov	[ecx+38h], eax
		retn
; ---------------------------------------------------------------------------

$LN39:					; CODE XREF: _SSL_CTX_ctrl+58j
					; DATA XREF: .text$mn:$LN45o
		mov	ecx, [edx+0B0h]	; jumptable 000001F8 case 100
		mov	eax, [esp+4+arg_8]
		not	eax
		pop	esi
		and	eax, [ecx+38h]
		mov	[ecx+38h], eax
		retn
; ---------------------------------------------------------------------------

$LN40:					; CODE XREF: _SSL_CTX_ctrl+4Bj
					; _SSL_CTX_ctrl+58j
					; DATA XREF: ...
		push	[esp+4+arg_C]	; jumptable 000001F8 default case
		mov	eax, [edx]
		push	[esp+8+arg_8]
		push	esi
		mov	eax, [eax+44h]
		push	edx
		call	eax
		add	esp, 10h
		pop	esi
		retn
_SSL_CTX_ctrl	endp

; ---------------------------------------------------------------------------
$LN45		dd offset $LN12_0, offset $LN19, offset	$LN20_0, offset	$LN21_0
					; DATA XREF: _SSL_CTX_ctrl+58r
		dd offset $LN22, offset	$LN23_0, offset	$LN24, offset $LN25 ; jump table for switch statement
		dd offset $LN26, offset	$LN27_0, offset	$LN28, offset $LN29
		dd offset $LN30_0, offset $LN31, offset	$LN33, offset $LN10_0
		dd offset $LN11_0, offset $LN15, offset	$LN16_0, offset	$LN17
		dd offset $LN18_0, offset $LN13_0, offset $LN14, offset	$LN35
		dd offset $LN32, offset	$LN34, offset $LN38, offset $LN39
		dd offset $LN40
$LN42		db	0,   1Ch,   1Ch,   1Ch ; DATA XREF: _SSL_CTX_ctrl+51r
		db	1,     2,     3,     4 ; indirect table	for switch statement
		db	5,     6,     7,     8
		db	9,   0Ah,   0Bh,   0Ch
		db    0Dh,   0Eh,   1Ch,   1Ch
		db    1Ch,   1Ch,   1Ch,   1Ch
		db    0Fh,   10h,   11h,   12h
		db    13h,   14h,   1Ch,   1Ch
		db    1Ch,   1Ch,   15h,   16h
		db    17h,   1Ch,   1Ch,   1Ch
		db    1Ch,   1Ch,   1Ch,   1Ch
		db    1Ch,   1Ch,   1Ch,   1Ch
		db    1Ch,   1Ch,   1Ch,   1Ch
		db    1Ch,   1Ch,   1Ch,   1Ch
		db    1Ch,   1Ch,   1Ch,   1Ch
		db    1Ch,   18h,   19h,   1Ch
		db    1Ch,   1Ch,   1Ch,   1Ch
		db    1Ch,   1Ch,   1Ch,   1Ch
		db    1Ch,   1Ch,   1Ch,   1Ch
		db    1Ch,   1Ch,   1Ch,   1Ch
		db    1Ch,   1Ch,   1Ch,   1Ah
		db    1Bh
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 420h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_free
_SSL_CTX_free	proc near		; CODE XREF: _SSL_CTX_new+76p
					; _SSL_free+166p ...

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	loc_5BC
		push	83Ch
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0Ch
		lea	eax, [esi+60h]
		push	0FFFFFFFFh
		push	eax
		call	_CRYPTO_add_lock
		add	esp, 14h
		test	eax, eax
		jg	loc_5BC
		mov	eax, [esi+0F0h]
		test	eax, eax
		jz	short loc_462
		push	eax
		call	_X509_VERIFY_PARAM_free
		add	esp, 4

loc_462:				; CODE XREF: _SSL_CTX_free+37j
		cmp	dword ptr [esi+10h], 0
		jz	short loc_473
		push	0
		push	esi
		call	_SSL_CTX_flush_sessions
		add	esp, 8

loc_473:				; CODE XREF: _SSL_CTX_free+46j
		lea	eax, [esi+80h]
		push	eax
		push	esi
		push	2
		call	_CRYPTO_free_ex_data
		mov	eax, [esi+10h]
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_495
		push	eax
		call	_lh_free
		add	esp, 4

loc_495:				; CODE XREF: _SSL_CTX_free+6Aj
		mov	eax, [esi+0Ch]
		test	eax, eax
		jz	short loc_4A5
		push	eax
		call	_X509_STORE_free
		add	esp, 4

loc_4A5:				; CODE XREF: _SSL_CTX_free+7Aj
		mov	eax, [esi+4]
		test	eax, eax
		jz	short loc_4B5
		push	eax
		call	_sk_free
		add	esp, 4

loc_4B5:				; CODE XREF: _SSL_CTX_free+8Aj
		mov	eax, [esi+8]
		test	eax, eax
		jz	short loc_4C5
		push	eax
		call	_sk_free
		add	esp, 4

loc_4C5:				; CODE XREF: _SSL_CTX_free+9Aj
		mov	eax, [esi+0B0h]
		test	eax, eax
		jz	short loc_4D8
		push	eax
		call	_ssl_cert_free
		add	esp, 4

loc_4D8:				; CODE XREF: _SSL_CTX_free+ADj
		mov	eax, [esi+0A0h]
		test	eax, eax
		jz	short loc_4F0
		push	offset _X509_NAME_free
		push	eax
		call	_sk_pop_free
		add	esp, 8

loc_4F0:				; CODE XREF: _SSL_CTX_free+C0j
		mov	eax, [esi+94h]
		test	eax, eax
		jz	short loc_508
		push	offset _X509_free
		push	eax
		call	_sk_pop_free
		add	esp, 8

loc_508:				; CODE XREF: _SSL_CTX_free+D8j
		mov	eax, [esi+1B4h]
		mov	dword ptr [esi+98h], 0
		test	eax, eax
		jz	short loc_525
		push	eax
		call	_sk_free
		add	esp, 4

loc_525:				; CODE XREF: _SSL_CTX_free+FAj
		mov	eax, [esi+14Ch]
		test	eax, eax
		jz	short loc_538
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_538:				; CODE XREF: _SSL_CTX_free+10Dj
		push	esi
		call	_SSL_CTX_SRP_CTX_free
		mov	eax, [esi+0FCh]
		add	esp, 4
		test	eax, eax
		jz	short loc_554
		push	eax
		call	_ENGINE_finish
		add	esp, 4

loc_554:				; CODE XREF: _SSL_CTX_free+129j
		mov	eax, [esi+15Ch]
		test	eax, eax
		jz	short loc_567
		push	eax
		call	_ssl_buf_freelist_free
		add	esp, 4

loc_567:				; CODE XREF: _SSL_CTX_free+13Cj
		mov	eax, [esi+160h]
		test	eax, eax
		jz	short loc_57A
		push	eax
		call	_ssl_buf_freelist_free
		add	esp, 4

loc_57A:				; CODE XREF: _SSL_CTX_free+14Fj
		mov	eax, [esi+1CCh]
		test	eax, eax
		jz	short loc_58D
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_58D:				; CODE XREF: _SSL_CTX_free+162j
		mov	eax, [esi+1D4h]
		test	eax, eax
		jz	short loc_5A0
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_5A0:				; CODE XREF: _SSL_CTX_free+175j
		mov	eax, [esi+1C0h]
		test	eax, eax
		jz	short loc_5B3
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_5B3:				; CODE XREF: _SSL_CTX_free+188j
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_5BC:				; CODE XREF: _SSL_CTX_free+7j
					; _SSL_CTX_free+29j
		pop	esi
		retn
_SSL_CTX_free	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5C0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_get0_certificate
_SSL_CTX_get0_certificate proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+0B0h]
		test	eax, eax
		jz	short loc_5D3
		mov	eax, [eax]
		mov	eax, [eax]
		retn
; ---------------------------------------------------------------------------

loc_5D3:				; CODE XREF: _SSL_CTX_get0_certificate+Cj
		xor	eax, eax
		retn
_SSL_CTX_get0_certificate endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5D8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_get0_param
_SSL_CTX_get0_param proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+0F0h]
		retn
_SSL_CTX_get0_param endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5E4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_get0_privatekey
_SSL_CTX_get0_privatekey proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+0B0h]
		test	eax, eax
		jz	short loc_5F8
		mov	eax, [eax]
		mov	eax, [eax+4]
		retn
; ---------------------------------------------------------------------------

loc_5F8:				; CODE XREF: _SSL_CTX_get0_privatekey+Cj
		xor	eax, eax
		retn
_SSL_CTX_get0_privatekey endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5FCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_get_cert_store
_SSL_CTX_get_cert_store	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+0Ch]
		retn
_SSL_CTX_get_cert_store	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 604h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_get_ex_data
_SSL_CTX_get_ex_data proc near

arg_0		= dword	ptr  4

		sub	[esp+arg_0], 0FFFFFF80h
		jmp	_CRYPTO_get_ex_data
_SSL_CTX_get_ex_data endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 610h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_get_ex_new_index
_SSL_CTX_get_ex_new_index proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		push	[esp+arg_10]
		push	[esp+4+arg_C]
		push	[esp+8+arg_8]
		push	[esp+0Ch+arg_4]
		push	[esp+10h+arg_0]
		push	2
		call	_CRYPTO_get_ex_new_index
		add	esp, 18h
		retn
_SSL_CTX_get_ex_new_index endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 630h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_get_quiet_shutdown
_SSL_CTX_get_quiet_shutdown proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+0F4h]
		retn
_SSL_CTX_get_quiet_shutdown endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 63Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_get_ssl_method
_SSL_CTX_get_ssl_method	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax]
		retn
_SSL_CTX_get_ssl_method	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 644h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_get_verify_callback
_SSL_CTX_get_verify_callback proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+0E8h]
		retn
_SSL_CTX_get_verify_callback endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 650h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_get_verify_depth
_SSL_CTX_get_verify_depth proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		push	dword ptr [eax+0F0h]
		call	_X509_VERIFY_PARAM_get_depth
		add	esp, 4
		retn
_SSL_CTX_get_verify_depth endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 664h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_get_verify_mode
_SSL_CTX_get_verify_mode proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+0C0h]
		retn
_SSL_CTX_get_verify_mode endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 670h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_load_verify_locations
_SSL_CTX_load_verify_locations proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	[esp+arg_8]
		mov	eax, [esp+4+arg_0]
		push	[esp+4+arg_4]
		push	dword ptr [eax+0Ch]
		call	_X509_STORE_load_locations
		add	esp, 0Ch
		retn
_SSL_CTX_load_verify_locations endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 688h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_new
_SSL_CTX_new	proc near

arg_0		= dword	ptr  4

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	edi
		xor	edi, edi
		test	ebx, ebx
		jnz	short loc_6B7
		push	759h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0C4h ; 'Ä'
		push	0A9h ; '©'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_6B7:				; CODE XREF: _SSL_CTX_new+Aj
		call	_SSL_get_ex_data_X509_STORE_CTX_idx
		test	eax, eax
		jns	short loc_70B
		push	764h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	10Dh
		push	0A9h ; '©'
		push	14h
		call	_ERR_put_error
		add	esp, 14h

$err$24:				; CODE XREF: _SSL_CTX_new+9Ej
					; _SSL_CTX_new+185j ...
		push	81Bh
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	41h ; 'A'

loc_6EA:				; CODE XREF: _SSL_CTX_new+25Aj
					; _SSL_CTX_new+285j ...
		push	0A9h ; '©'
		push	14h
		call	_ERR_put_error
		add	esp, 14h

$err2$25:
		test	edi, edi
		jz	short loc_706
		push	edi
		call	_SSL_CTX_free
		add	esp, 4

loc_706:				; CODE XREF: _SSL_CTX_new+73j
		pop	edi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_70B:				; CODE XREF: _SSL_CTX_new+36j
		push	767h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	1D8h
		call	_CRYPTO_malloc
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jz	short $err$24
		push	1D8h		; Size
		push	0		; Val
		push	edi		; Dst
		call	_memset
		mov	[edi], ebx
		mov	dword ptr [edi+0Ch], 0
		mov	dword ptr [edi+20h], 2
		mov	dword ptr [edi+14h], 5000h
		mov	dword ptr [edi+18h], 0
		mov	dword ptr [edi+1Ch], 0
		mov	eax, [ebx+60h]
		call	eax
		push	2Ch ; ','       ; Size
		mov	[edi+24h], eax
		lea	eax, [edi+34h]
		push	0		; Val
		push	eax		; Dst
		mov	dword ptr [edi+28h], 0
		mov	dword ptr [edi+2Ch], 0
		mov	dword ptr [edi+30h], 0
		mov	dword ptr [edi+0ECh], 0
		call	_memset
		add	esp, 18h
		mov	dword ptr [edi+60h], 1
		mov	dword ptr [edi+0F4h], 0
		mov	dword ptr [edi+9Ch], 0
		mov	dword ptr [edi+64h], 0
		mov	dword ptr [edi+68h], 0
		mov	dword ptr [edi+0ACh], 19000h
		mov	dword ptr [edi+0B4h], 0
		mov	dword ptr [edi+0B8h], 0
		mov	dword ptr [edi+0BCh], 0
		mov	dword ptr [edi+0C0h], 0
		mov	dword ptr [edi+0C4h], 0
		mov	dword ptr [edi+0E8h], 0
		call	_ssl_cert_new
		mov	[edi+0B0h], eax
		test	eax, eax
		jz	$err$24
		push	offset _ssl_session_LHASH_COMP
		push	offset _ssl_session_LHASH_HASH
		mov	dword ptr [edi+6Ch], 0
		mov	dword ptr [edi+70h], 0
		mov	dword ptr [edi+74h], 0
		mov	dword ptr [edi+78h], 0
		mov	dword ptr [edi+7Ch], 0
		call	_lh_new
		add	esp, 8
		mov	[edi+10h], eax
		test	eax, eax
		jz	$err$24
		call	_X509_STORE_new
		mov	[edi+0Ch], eax
		test	eax, eax
		jz	$err$24
		cmp	dword ptr [ebx], 2
		mov	ecx, offset ??_C@_0CG@ENOBHNBE@ALL?3?$CBEXPORT?3?$CBLOW?3?$CBaNULL?3?$CBeNULL?3?$CB@ ; "ALL:!EXPORT:!LOW:!aNULL:!eNULL:!SSLv2"
		push	esi
		push	dword ptr [edi+0B0h]
		mov	eax, offset ??_C@_05NHFKDGAI@SSLv2?$AA@	; "SSLv2"
		lea	esi, [edi+4]
		cmovnz	eax, ecx
		push	eax
		lea	eax, [edi+8]
		push	eax
		push	esi
		push	dword ptr [edi]
		call	_ssl_create_cipher_list
		mov	eax, [esi]
		add	esp, 14h
		pop	esi
		test	eax, eax
		jz	loc_AE9
		push	eax
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jle	loc_AE9
		call	_X509_VERIFY_PARAM_new
		mov	[edi+0F0h], eax
		test	eax, eax
		jz	$err$24
		push	offset ??_C@_08OKFBGHCE@ssl2?9md5?$AA@ ; "ssl2-md5"
		call	_EVP_get_digestbyname
		add	esp, 4
		mov	[edi+88h], eax
		test	eax, eax
		jnz	short loc_8E7
		push	7B7h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0F1h ; 'ñ'
		jmp	loc_6EA
; ---------------------------------------------------------------------------

loc_8E7:				; CODE XREF: _SSL_CTX_new+249j
		push	offset ??_C@_08CBANLEIB@ssl3?9md5?$AA@ ; "ssl3-md5"
		call	_EVP_get_digestbyname
		add	esp, 4
		mov	[edi+8Ch], eax
		test	eax, eax
		jnz	short loc_912
		push	7BBh
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0F2h ; 'ò'
		jmp	loc_6EA
; ---------------------------------------------------------------------------

loc_912:				; CODE XREF: _SSL_CTX_new+274j
		push	offset ??_C@_09KCHAKJIH@ssl3?9sha1?$AA@	; "ssl3-sha1"
		call	_EVP_get_digestbyname
		add	esp, 4
		mov	[edi+90h], eax
		test	eax, eax
		jnz	short loc_93D
		push	7BFh
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0F3h ; 'ó'
		jmp	loc_6EA
; ---------------------------------------------------------------------------

loc_93D:				; CODE XREF: _SSL_CTX_new+29Fj
		call	_sk_new_null
		mov	[edi+0A0h], eax
		test	eax, eax
		jz	$err$24
		lea	eax, [edi+80h]
		push	eax
		push	edi
		push	2
		call	_CRYPTO_new_ex_data
		mov	dword ptr [edi+94h], 0
		add	esp, 0Ch
		mov	eax, [ebx+64h]
		test	byte ptr [eax+38h], 8
		jnz	short loc_980
		call	_SSL_COMP_get_compression_methods
		mov	[edi+98h], eax

loc_980:				; CODE XREF: _SSL_CTX_new+2EBj
		lea	eax, [edi+108h]
		mov	dword ptr [edi+0F8h], 4000h
		push	10h
		push	eax
		mov	dword ptr [edi+100h], 0
		mov	dword ptr [edi+104h], 0
		call	_RAND_pseudo_bytes
		add	esp, 8
		test	eax, eax
		jle	short loc_9DD
		lea	eax, [edi+118h]
		push	10h
		push	eax
		call	_RAND_bytes
		add	esp, 8
		test	eax, eax
		jle	short loc_9DD
		lea	eax, [edi+128h]
		push	10h
		push	eax
		call	_RAND_bytes
		add	esp, 8
		test	eax, eax
		jg	short loc_9E7

loc_9DD:				; CODE XREF: _SSL_CTX_new+329j
					; _SSL_CTX_new+33Ej
		or	dword ptr [edi+0A4h], 4000h

loc_9E7:				; CODE XREF: _SSL_CTX_new+353j
		push	edi
		mov	dword ptr [edi+13Ch], 0
		mov	dword ptr [edi+140h], 0
		mov	dword ptr [edi+1A4h], 0
		mov	dword ptr [edi+1ACh], 0
		mov	dword ptr [edi+14Ch], 0
		mov	dword ptr [edi+150h], 0
		mov	dword ptr [edi+154h], 0
		call	_SSL_CTX_SRP_CTX_init
		push	7EAh
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0Ch
		mov	dword ptr [edi+158h], 20h ; ' '
		call	_CRYPTO_malloc
		add	esp, 10h
		mov	[edi+160h], eax
		test	eax, eax
		jz	$err$24
		mov	dword ptr [eax], 0
		mov	eax, [edi+160h]
		push	7F0h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0Ch
		mov	dword ptr [eax+4], 0
		mov	eax, [edi+160h]
		mov	dword ptr [eax+8], 0
		call	_CRYPTO_malloc
		add	esp, 0Ch
		mov	[edi+15Ch], eax
		test	eax, eax
		jnz	short loc_AB0
		push	dword ptr [edi+160h]
		call	_CRYPTO_free
		add	esp, 4
		jmp	$err$24
; ---------------------------------------------------------------------------

loc_AB0:				; CODE XREF: _SSL_CTX_new+413j
		mov	dword ptr [eax], 0
		mov	eax, [edi+15Ch]
		mov	dword ptr [eax+4], 0
		mov	eax, [edi+15Ch]
		mov	dword ptr [eax+8], 0
		mov	eax, edi
		or	dword ptr [edi+0A4h], 1000004h
		mov	dword ptr [edi+0FCh], 0
		pop	edi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_AE9:				; CODE XREF: _SSL_CTX_new+20Aj
					; _SSL_CTX_new+21Bj
		push	7AEh
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0A1h ; '¡'
		jmp	loc_6EA
_SSL_CTX_new	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B00h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_sessions
_SSL_CTX_sessions proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+10h]
		retn
_SSL_CTX_sessions endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B08h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set1_param
_SSL_CTX_set1_param proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		push	[esp+arg_4]
		push	dword ptr [eax+0F0h]
		call	_X509_VERIFY_PARAM_set1
		add	esp, 8
		retn
_SSL_CTX_set1_param endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B20h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl SSL_CTX_set_alpn_protos(int, void	*Src, size_t Size)
		public _SSL_CTX_set_alpn_protos
_SSL_CTX_set_alpn_protos proc near

arg_0		= dword	ptr  4
Src		= dword	ptr  8
Size		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		mov	eax, [esi+1C0h]
		test	eax, eax
		jz	short loc_B39
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_B39:				; CODE XREF: _SSL_CTX_set_alpn_protos+Ej
		mov	edi, [esp+8+Size]
		push	6E0h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	edi
		call	_CRYPTO_malloc
		add	esp, 0Ch
		mov	[esi+1C0h], eax
		test	eax, eax
		jnz	short loc_B62
		pop	edi
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_B62:				; CODE XREF: _SSL_CTX_set_alpn_protos+38j
		push	edi		; Size
		push	[esp+0Ch+Src]	; Src
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	[esi+1C4h], edi
		xor	eax, eax
		pop	edi
		pop	esi
		retn
_SSL_CTX_set_alpn_protos endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B7Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_alpn_select_cb
_SSL_CTX_set_alpn_select_cb proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		mov	eax, [esp+arg_4]
		mov	[ecx+1B8h], eax
		mov	eax, [esp+arg_8]
		mov	[ecx+1BCh], eax
		retn
_SSL_CTX_set_alpn_select_cb endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B98h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_cert_cb
_SSL_CTX_set_cert_cb proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	[esp+arg_8]
		mov	eax, [esp+4+arg_0]
		push	[esp+4+arg_4]
		push	dword ptr [eax+0B0h]
		call	_ssl_cert_set_cert_cb
		add	esp, 0Ch
		retn
_SSL_CTX_set_cert_cb endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0BB4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_cert_store
_SSL_CTX_set_cert_store	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, [esi+0Ch]
		test	eax, eax
		jz	short loc_BC9
		push	eax
		call	_X509_STORE_free
		add	esp, 4

loc_BC9:				; CODE XREF: _SSL_CTX_set_cert_store+Aj
		mov	eax, [esp+4+arg_4]
		mov	[esi+0Ch], eax
		pop	esi
		retn
_SSL_CTX_set_cert_store	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0BD4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_cert_verify_callback
_SSL_CTX_set_cert_verify_callback proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		mov	eax, [esp+arg_4]
		mov	[ecx+64h], eax
		mov	eax, [esp+arg_8]
		mov	[ecx+68h], eax
		retn
_SSL_CTX_set_cert_verify_callback endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0BE8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_cipher_list
_SSL_CTX_set_cipher_list proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		push	dword ptr [ecx+0B0h]
		lea	eax, [ecx+8]
		push	[esp+4+arg_4]
		push	eax
		lea	eax, [ecx+4]
		push	eax
		push	dword ptr [ecx]
		call	_ssl_create_cipher_list
		add	esp, 14h
		test	eax, eax
		jz	short loc_C37
		push	eax
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jnz	short loc_C3A
		push	567h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0B9h ; '¹'
		push	10Dh
		push	14h
		call	_ERR_put_error
		add	esp, 14h

loc_C37:				; CODE XREF: _SSL_CTX_set_cipher_list+22j
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_C3A:				; CODE XREF: _SSL_CTX_set_cipher_list+2Fj
		mov	eax, 1
		retn
_SSL_CTX_set_cipher_list endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C40h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_default_passwd_cb
_SSL_CTX_set_default_passwd_cb proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+6Ch], ecx
		retn
_SSL_CTX_set_default_passwd_cb endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C4Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_default_passwd_cb_userdata
_SSL_CTX_set_default_passwd_cb_userdata	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+70h], ecx
		retn
_SSL_CTX_set_default_passwd_cb_userdata	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C58h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_default_verify_paths
_SSL_CTX_set_default_verify_paths proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		push	dword ptr [eax+0Ch]
		call	_X509_STORE_set_default_paths
		add	esp, 4
		retn
_SSL_CTX_set_default_verify_paths endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C68h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_ex_data
_SSL_CTX_set_ex_data proc near

arg_0		= dword	ptr  4

		sub	[esp+arg_0], 0FFFFFF80h
		jmp	_CRYPTO_set_ex_data
_SSL_CTX_set_ex_data endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C74h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_generate_session_id
_SSL_CTX_set_generate_session_id proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	1D3h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0Ch
		push	9
		call	_CRYPTO_lock
		mov	eax, [esp+10h+arg_0]
		mov	ecx, [esp+10h+arg_4]
		push	1D5h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0Ch
		push	0Ah
		mov	[eax+0ECh], ecx
		call	_CRYPTO_lock
		add	esp, 20h
		mov	eax, 1
		retn
_SSL_CTX_set_generate_session_id endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0CB4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_msg_callback
_SSL_CTX_set_msg_callback proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+0B8h], ecx
		retn
_SSL_CTX_set_msg_callback endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0CC4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_next_proto_select_cb
_SSL_CTX_set_next_proto_select_cb proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		mov	eax, [esp+arg_4]
		mov	[ecx+1ACh], eax
		mov	eax, [esp+arg_8]
		mov	[ecx+1B0h], eax
		retn
_SSL_CTX_set_next_proto_select_cb endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0CE0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_next_protos_advertised_cb
_SSL_CTX_set_next_protos_advertised_cb proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		mov	eax, [esp+arg_4]
		mov	[ecx+1A4h], eax
		mov	eax, [esp+arg_8]
		mov	[ecx+1A8h], eax
		retn
_SSL_CTX_set_next_protos_advertised_cb endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0CFCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_psk_client_callback
_SSL_CTX_set_psk_client_callback proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+150h], ecx
		retn
_SSL_CTX_set_psk_client_callback endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D0Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_psk_server_callback
_SSL_CTX_set_psk_server_callback proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+154h], ecx
		retn
_SSL_CTX_set_psk_server_callback endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D1Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_purpose
_SSL_CTX_set_purpose proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		push	[esp+arg_4]
		push	dword ptr [eax+0F0h]
		call	_X509_VERIFY_PARAM_set_purpose
		add	esp, 8
		retn
_SSL_CTX_set_purpose endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D34h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_quiet_shutdown
_SSL_CTX_set_quiet_shutdown proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+0F4h], ecx
		retn
_SSL_CTX_set_quiet_shutdown endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D44h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl SSL_CTX_set_session_id_context(int, void *Src, size_t Size)
		public _SSL_CTX_set_session_id_context
_SSL_CTX_set_session_id_context	proc near

arg_0		= dword	ptr  4
Src		= dword	ptr  8
Size		= dword	ptr  0Ch

		mov	ecx, [esp+Size]
		cmp	ecx, 20h ; ' '
		jbe	short loc_D6E
		push	1BAh
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	111h
		push	0DBh ; 'Û'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_D6E:				; CODE XREF: _SSL_CTX_set_session_id_context+7j
		mov	eax, [esp+arg_0]
		push	ecx		; Size
		push	[esp+4+Src]	; Src
		mov	[eax+0C4h], ecx
		add	eax, 0C8h ; 'È'
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, 1
		retn
_SSL_CTX_set_session_id_context	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D94h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_ssl_version
_SSL_CTX_set_ssl_version proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		mov	eax, offset ??_C@_05NHFKDGAI@SSLv2?$AA@	; "SSLv2"
		mov	edx, [esp+arg_4]
		push	esi
		mov	esi, offset ??_C@_0CG@ENOBHNBE@ALL?3?$CBEXPORT?3?$CBLOW?3?$CBaNULL?3?$CBeNULL?3?$CB@ ; "ALL:!EXPORT:!LOW:!aNULL:!eNULL:!SSLv2"
		push	dword ptr [ecx+0B0h]
		mov	[ecx], edx
		cmp	dword ptr [edx], 2
		cmovnz	eax, esi
		push	eax
		lea	eax, [ecx+8]
		push	eax
		lea	eax, [ecx+4]
		push	eax
		push	edx
		call	_ssl_create_cipher_list
		add	esp, 14h
		pop	esi
		test	eax, eax
		jz	short loc_DDF
		push	eax
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jle	short loc_DDF
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_DDF:				; CODE XREF: _SSL_CTX_set_ssl_version+36j
					; _SSL_CTX_set_ssl_version+43j
		push	120h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0E6h ; 'æ'
		push	0AAh ; 'ª'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
_SSL_CTX_set_ssl_version endp ;	sp-analysis failed

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E00h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_tmp_dh_callback
_SSL_CTX_set_tmp_dh_callback proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		push	[esp+arg_4]
		push	6
		mov	ecx, [eax]
		push	eax
		mov	eax, [ecx+70h]
		call	eax
		add	esp, 0Ch
		retn
_SSL_CTX_set_tmp_dh_callback endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E18h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_tmp_ecdh_callback
_SSL_CTX_set_tmp_ecdh_callback proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		push	[esp+arg_4]
		push	7
		mov	ecx, [eax]
		push	eax
		mov	eax, [ecx+70h]
		call	eax
		add	esp, 0Ch
		retn
_SSL_CTX_set_tmp_ecdh_callback endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E30h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_tmp_rsa_callback
_SSL_CTX_set_tmp_rsa_callback proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		push	[esp+arg_4]
		push	5
		mov	ecx, [eax]
		push	eax
		mov	eax, [ecx+70h]
		call	eax
		add	esp, 0Ch
		retn
_SSL_CTX_set_tmp_rsa_callback endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E48h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_trust
_SSL_CTX_set_trust proc	near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		push	[esp+arg_4]
		push	dword ptr [eax+0F0h]
		call	_X509_VERIFY_PARAM_set_trust
		add	esp, 8
		retn
_SSL_CTX_set_trust endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E60h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_verify
_SSL_CTX_set_verify proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		mov	eax, [esp+arg_4]
		mov	[ecx+0C0h], eax
		mov	eax, [esp+arg_8]
		mov	[ecx+0E8h], eax
		retn
_SSL_CTX_set_verify endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E7Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_set_verify_depth
_SSL_CTX_set_verify_depth proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		push	[esp+arg_4]
		push	dword ptr [eax+0F0h]
		call	_X509_VERIFY_PARAM_set_depth
		add	esp, 8
		retn
_SSL_CTX_set_verify_depth endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E94h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_CTX_use_psk_identity_hint
_SSL_CTX_use_psk_identity_hint proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_4]
		test	esi, esi
		jz	short loc_ED7
		mov	ecx, esi
		lea	edx, [ecx+1]
		xchg	ax, ax

loc_EA4:				; CODE XREF: _SSL_CTX_use_psk_identity_hint+15j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_EA4
		sub	ecx, edx
		cmp	ecx, 80h ; ''
		jbe	short loc_ED7
		push	0D51h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	92h ; ''
		push	110h
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_ED7:				; CODE XREF: _SSL_CTX_use_psk_identity_hint+7j
					; _SSL_CTX_use_psk_identity_hint+1Fj
		push	edi
		mov	edi, [esp+8+arg_0]
		mov	eax, [edi+14Ch]
		test	eax, eax
		jz	short loc_EEF
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_EEF:				; CODE XREF: _SSL_CTX_use_psk_identity_hint+50j
		test	esi, esi
		jz	short loc_F09
		push	esi
		call	_BUF_strdup
		add	esp, 4
		mov	[edi+14Ch], eax
		test	eax, eax
		jnz	short loc_F13
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_F09:				; CODE XREF: _SSL_CTX_use_psk_identity_hint+5Dj
		mov	dword ptr [edi+14Ch], 0

loc_F13:				; CODE XREF: _SSL_CTX_use_psk_identity_hint+70j
		pop	edi
		mov	eax, 1
		pop	esi
		retn
_SSL_CTX_use_psk_identity_hint endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F1Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_accept
_SSL_accept	proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		cmp	dword ptr [esi+20h], 0
		jnz	short loc_F30
		push	esi
		call	_SSL_set_accept_state
		add	esp, 4

loc_F30:				; CODE XREF: _SSL_accept+9j
		mov	eax, [esi+8]
		push	esi
		mov	eax, [eax+10h]
		call	eax
		add	esp, 4
		pop	esi
		retn
_SSL_accept	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F40h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_cache_hit
_SSL_cache_hit	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+6Ch]
		retn
_SSL_cache_hit	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F48h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_callback_ctrl
_SSL_callback_ctrl proc	near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	edx, [esp+arg_4]
		mov	eax, [esp+arg_0]
		cmp	edx, 0Fh
		jz	short loc_F65
		mov	ecx, [eax+8]
		mov	[esp+arg_4], edx
		mov	[esp+arg_0], eax
		mov	eax, [ecx+6Ch]
		jmp	eax
; ---------------------------------------------------------------------------

loc_F65:				; CODE XREF: _SSL_callback_ctrl+Bj
		mov	ecx, [esp+arg_8]
		mov	[eax+64h], ecx
		mov	eax, 1
		retn
_SSL_callback_ctrl endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F74h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_certs_clear
_SSL_certs_clear proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		push	dword ptr [eax+98h]
		call	_ssl_cert_clear_certs
		pop	ecx
		retn
_SSL_certs_clear endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F88h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_check_private_key
_SSL_check_private_key proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jnz	short loc_FAE
		push	3CEh
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	43h ; 'C'
		push	0A3h ; '£'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_FAE:				; CODE XREF: _SSL_check_private_key+6j
		mov	eax, [eax+98h]
		test	eax, eax
		jnz	short loc_FD9
		push	3D2h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0B1h ; '±'
		push	0A3h ; '£'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_FD9:				; CODE XREF: _SSL_check_private_key+2Ej
		mov	eax, [eax]
		mov	ecx, [eax]
		test	ecx, ecx
		jnz	short loc_1002
		push	3D6h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0B1h ; '±'
		push	0A3h ; '£'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1002:				; CODE XREF: _SSL_check_private_key+57j
		mov	eax, [eax+4]
		test	eax, eax
		jnz	short loc_102A
		push	3DAh
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0BEh ; '¾'
		push	0A3h ; '£'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_102A:				; CODE XREF: _SSL_check_private_key+7Fj
		push	eax
		push	ecx
		call	_X509_check_private_key
		add	esp, 8
		retn
_SSL_check_private_key endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1038h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_clear
_SSL_clear	proc near		; CODE XREF: _SSL_new+34Cp

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		cmp	dword ptr [esi+8], 0
		jnz	short loc_1065
		push	0C2h ; 'Â'
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0BCh ; '¼'
		push	0A4h ; '¤'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1065:				; CODE XREF: _SSL_clear+9j
		push	esi
		call	_ssl_clear_bad_session
		add	esp, 4
		test	eax, eax
		jz	short loc_108A
		push	dword ptr [esi+0C0h]
		call	_SSL_SESSION_free
		add	esp, 4
		mov	dword ptr [esi+0C0h], 0

loc_108A:				; CODE XREF: _SSL_clear+38j
		cmp	dword ptr [esi+190h], 0
		mov	dword ptr [esi+0D4h], 0
		mov	dword ptr [esi+6Ch], 0
		mov	dword ptr [esi+30h], 0
		jz	short loc_10CA
		push	0DCh ; 'Ü'
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	44h ; 'D'
		push	0A4h ; '¤'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_10CA:				; CODE XREF: _SSL_clear+71j
		cmp	dword ptr [esi+24h], 0
		mov	eax, 1000h
		mov	ecx, 2000h
		mov	dword ptr [esi+4], 0
		cmovnz	eax, ecx
		or	eax, 4000h
		mov	[esi+34h], eax
		mov	eax, [esi+8]
		mov	eax, [eax]
		mov	[esi], eax
		mov	[esi+110h], eax
		mov	eax, [esi+3Ch]
		mov	dword ptr [esi+18h], 1
		mov	dword ptr [esi+38h], 0F0h ; 'ð'
		test	eax, eax
		jz	short loc_111C
		push	eax
		call	_BUF_MEM_free
		add	esp, 4
		mov	dword ptr [esi+3Ch], 0

loc_111C:				; CODE XREF: _SSL_clear+D2j
		push	esi
		call	_ssl_clear_cipher_ctx
		mov	eax, [esi+84h]
		add	esp, 4
		test	eax, eax
		jz	short loc_1138
		push	eax
		call	_EVP_MD_CTX_destroy
		add	esp, 4

loc_1138:				; CODE XREF: _SSL_clear+F5j
		mov	dword ptr [esi+84h], 0
		mov	eax, [esi+90h]
		test	eax, eax
		jz	short loc_1155
		push	eax
		call	_EVP_MD_CTX_destroy
		add	esp, 4

loc_1155:				; CODE XREF: _SSL_clear+112j
		mov	dword ptr [esi+90h], 0
		mov	eax, [esi+98h]
		mov	dword ptr [esi+10Ch], 0
		test	eax, eax
		jz	short loc_11B6
		mov	eax, [eax+170h]
		test	eax, eax
		jz	short loc_1196
		push	eax
		call	_CRYPTO_free
		mov	eax, [esi+98h]
		add	esp, 4
		mov	dword ptr [eax+170h], 0

loc_1196:				; CODE XREF: _SSL_clear+143j
		mov	eax, [esi+98h]
		mov	dword ptr [eax+174h], 0
		mov	eax, [esi+98h]
		mov	dword ptr [eax+178h], 0

loc_11B6:				; CODE XREF: _SSL_clear+139j
		cmp	dword ptr [esi+1Ch], 0
		jnz	short loc_11F2
		cmp	dword ptr [esi+0C0h], 0
		jnz	short loc_11F2
		mov	eax, [esi+0E4h]
		mov	ecx, [esi+8]
		cmp	ecx, [eax]
		jz	short loc_11F2
		mov	eax, [ecx+0Ch]
		push	esi
		call	eax
		mov	eax, [esi+0E4h]
		push	esi
		mov	eax, [eax]
		mov	[esi+8], eax
		mov	eax, [eax+4]
		call	eax
		add	esp, 8
		test	eax, eax
		jnz	short loc_11FE
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_11F2:				; CODE XREF: _SSL_clear+182j
					; _SSL_clear+18Bj ...
		mov	eax, [esi+8]
		push	esi
		mov	eax, [eax+8]
		call	eax
		add	esp, 4

loc_11FE:				; CODE XREF: _SSL_clear+1B6j
		mov	eax, 1
		pop	esi
		retn
_SSL_clear	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1208h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_connect
_SSL_connect	proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		cmp	dword ptr [esi+20h], 0
		jnz	short loc_121C
		push	esi
		call	_SSL_set_connect_state
		add	esp, 4

loc_121C:				; CODE XREF: _SSL_connect+9j
		mov	eax, [esi+8]
		push	esi
		mov	eax, [eax+14h]
		call	eax
		add	esp, 4
		pop	esi
		retn
_SSL_connect	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 122Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_copy_session_id
_SSL_copy_session_id proc near		; CODE XREF: _SSL_dup+3Ap

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		push	edi
		mov	edi, [esp+8+arg_4]
		push	edi
		call	_SSL_get_session
		mov	esi, [esp+0Ch+arg_0]
		push	eax
		push	esi
		call	_SSL_set_session
		mov	eax, [esi+8]
		add	esp, 0Ch
		cmp	eax, [edi+8]
		jz	short loc_1263
		mov	eax, [eax+0Ch]
		push	esi
		call	eax
		mov	eax, [edi+8]
		mov	[esi+8], eax
		push	esi
		mov	eax, [eax+4]
		call	eax
		add	esp, 8

loc_1263:				; CODE XREF: _SSL_copy_session_id+20j
		mov	eax, [edi+98h]
		push	ebx
		mov	ebx, [esi+98h]
		test	eax, eax
		jz	short loc_129E
		push	3AFh
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0Dh
		add	eax, 16Ch
		push	1
		push	eax
		call	_CRYPTO_add_lock
		mov	eax, [edi+98h]
		add	esp, 14h
		mov	[esi+98h], eax
		jmp	short loc_12A8
; ---------------------------------------------------------------------------

loc_129E:				; CODE XREF: _SSL_copy_session_id+46j
		mov	dword ptr [esi+98h], 0

loc_12A8:				; CODE XREF: _SSL_copy_session_id+70j
		test	ebx, ebx
		jz	short loc_12B5
		push	ebx
		call	_ssl_cert_free
		add	esp, 4

loc_12B5:				; CODE XREF: _SSL_copy_session_id+7Ej
		mov	eax, [edi+9Ch]
		pop	ebx
		cmp	eax, 20h ; ' '
		jbe	short loc_12E2
		push	1C8h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	111h
		push	0DAh ; 'Ú'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_12E2:				; CODE XREF: _SSL_copy_session_id+93j
		push	eax		; Size
		mov	[esi+9Ch], eax
		lea	eax, [edi+0A0h]
		push	eax		; Src
		lea	eax, [esi+0A0h]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		pop	edi
		pop	esi
		retn
_SSL_copy_session_id endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1304h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_ctrl
_SSL_ctrl	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	edx, [esp+arg_4]
		lea	eax, [edx-10h]	; switch 95 cases
		cmp	eax, 5Eh ; '^'
		ja	$LN23		; jumptable 0000131B default case
		movzx	eax, ds:$LN27[eax]
		jmp	ds:$LN30[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN4:					; CODE XREF: _SSL_ctrl+17j
					; DATA XREF: .text$mn:$LN30o
		mov	eax, [esp+arg_0] ; jumptable 0000131B case 40
		mov	eax, [eax+60h]
		retn
; ---------------------------------------------------------------------------

$LN5:					; CODE XREF: _SSL_ctrl+17j
					; DATA XREF: .text$mn:$LN30o
		mov	edx, [esp+arg_0] ; jumptable 0000131B case 41
		mov	ecx, [esp+arg_8]
		mov	eax, [edx+60h]
		mov	[edx+60h], ecx
		retn
; ---------------------------------------------------------------------------

$LN6:					; CODE XREF: _SSL_ctrl+17j
					; DATA XREF: .text$mn:$LN30o
		mov	eax, [esp+arg_0] ; jumptable 0000131B case 16
		mov	ecx, [esp+arg_C]
		mov	[eax+68h], ecx
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

$LN7:					; CODE XREF: _SSL_ctrl+17j
					; DATA XREF: .text$mn:$LN30o
		mov	ecx, [esp+arg_0] ; jumptable 0000131B case 32
		mov	eax, [ecx+100h]
		or	eax, [esp+arg_8]
		mov	[ecx+100h], eax
		retn
; ---------------------------------------------------------------------------

$LN8:					; CODE XREF: _SSL_ctrl+17j
					; DATA XREF: .text$mn:$LN30o
		mov	ecx, [esp+arg_0] ; jumptable 0000131B case 77
		mov	eax, [esp+arg_8]
		not	eax
		and	eax, [ecx+100h]
		mov	[ecx+100h], eax
		retn
; ---------------------------------------------------------------------------

$LN9:					; CODE XREF: _SSL_ctrl+17j
					; DATA XREF: .text$mn:$LN30o
		mov	ecx, [esp+arg_0] ; jumptable 0000131B case 33
		mov	eax, [ecx+104h]
		or	eax, [esp+arg_8]
		mov	[ecx+104h], eax
		retn
; ---------------------------------------------------------------------------

$LN10:					; CODE XREF: _SSL_ctrl+17j
					; DATA XREF: .text$mn:$LN30o
		mov	ecx, [esp+arg_0] ; jumptable 0000131B case 78
		mov	eax, [esp+arg_8]
		not	eax
		and	eax, [ecx+104h]
		mov	[ecx+104h], eax
		retn
; ---------------------------------------------------------------------------

$LN11:					; CODE XREF: _SSL_ctrl+17j
					; DATA XREF: .text$mn:$LN30o
		mov	eax, [esp+arg_0] ; jumptable 0000131B case 50
		mov	eax, [eax+108h]
		retn
; ---------------------------------------------------------------------------

$LN12:					; CODE XREF: _SSL_ctrl+17j
					; DATA XREF: .text$mn:$LN30o
		mov	edx, [esp+arg_0] ; jumptable 0000131B case 51
		mov	ecx, [esp+arg_8]
		mov	eax, [edx+108h]
		mov	[edx+108h], ecx
		retn
; ---------------------------------------------------------------------------

$LN13:					; CODE XREF: _SSL_ctrl+17j
					; DATA XREF: .text$mn:$LN30o
		mov	ecx, [esp+arg_8] ; jumptable 0000131B case 52
		lea	eax, [ecx-200h]
		cmp	eax, 3E00h
		ja	short loc_13E3
		mov	eax, [esp+arg_0]
		mov	[eax+114h], ecx
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_13E3:				; CODE XREF: _SSL_ctrl+CDj
					; _SSL_ctrl+EBj ...
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

$LN16:					; CODE XREF: _SSL_ctrl+17j
					; DATA XREF: .text$mn:$LN30o
		mov	eax, [esp+arg_0] ; jumptable 0000131B case 76
		mov	eax, [eax+58h]
		test	eax, eax
		jz	short loc_13E3
		mov	eax, [eax+418h]
		retn
; ---------------------------------------------------------------------------

$LN18:					; CODE XREF: _SSL_ctrl+17j
					; DATA XREF: .text$mn:$LN30o
		mov	eax, [esp+arg_0] ; jumptable 0000131B case 99
		mov	ecx, [eax+98h]
		mov	eax, [ecx+38h]
		or	eax, [esp+arg_8]
		mov	[ecx+38h], eax
		retn
; ---------------------------------------------------------------------------

$LN20:					; CODE XREF: _SSL_ctrl+17j
					; DATA XREF: .text$mn:$LN30o
		mov	eax, [esp+arg_0] ; jumptable 0000131B case 100
		mov	ecx, [eax+98h]
		mov	eax, [esp+arg_8]
		not	eax
		and	eax, [ecx+38h]
		mov	[ecx+38h], eax
		retn
; ---------------------------------------------------------------------------

$LN21:					; CODE XREF: _SSL_ctrl+17j
					; DATA XREF: .text$mn:$LN30o
		mov	ecx, [esp+arg_C] ; jumptable 0000131B case 110
		test	ecx, ecx
		jz	short loc_144F
		mov	edx, [esp+arg_0]
		mov	eax, [edx+98h]
		mov	eax, [eax+154h]
		test	eax, eax
		jz	short loc_13E3
		mov	[ecx], eax
		mov	eax, [edx+98h]
		mov	eax, [eax+158h]
		retn
; ---------------------------------------------------------------------------

loc_144F:				; CODE XREF: _SSL_ctrl+126j
		mov	eax, [esp+arg_0]
		push	0
		push	0
		mov	eax, [eax+8]
		mov	eax, [eax+4Ch]
		call	eax
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

$LN23:					; CODE XREF: _SSL_ctrl+Aj
					; _SSL_ctrl+17j
					; DATA XREF: ...
		mov	eax, [esp+arg_0] ; jumptable 0000131B default case
		mov	[esp+arg_0], eax
		mov	[esp+arg_4], edx
		mov	ecx, [eax+8]
		mov	eax, [ecx+40h]
		jmp	eax
_SSL_ctrl	endp

; ---------------------------------------------------------------------------
		align 4
$LN30		dd offset $LN6,	offset $LN7, offset $LN9, offset $LN4
					; DATA XREF: _SSL_ctrl+17r
		dd offset $LN5,	offset $LN11, offset $LN12, offset $LN13 ; jump	table for switch statement
		dd offset $LN16, offset	$LN8, offset $LN10, offset $LN18
		dd offset $LN20, offset	$LN21, offset $LN23
$LN27		db	0,   0Eh,   0Eh,   0Eh ; DATA XREF: _SSL_ctrl+10r
		db    0Eh,   0Eh,   0Eh,   0Eh ; indirect table	for switch statement
		db    0Eh,   0Eh,   0Eh,   0Eh
		db    0Eh,   0Eh,   0Eh,   0Eh
		db	1,     2,   0Eh,   0Eh
		db    0Eh,   0Eh,   0Eh,   0Eh
		db	3,     4,   0Eh,   0Eh
		db    0Eh,   0Eh,   0Eh,   0Eh
		db    0Eh,   0Eh,     5,     6
		db	7,   0Eh,   0Eh,   0Eh
		db    0Eh,   0Eh,   0Eh,   0Eh
		db    0Eh,   0Eh,   0Eh,   0Eh
		db    0Eh,   0Eh,   0Eh,   0Eh
		db    0Eh,   0Eh,   0Eh,   0Eh
		db    0Eh,   0Eh,   0Eh,   0Eh
		db	8,     9,   0Ah,   0Eh
		db    0Eh,   0Eh,   0Eh,   0Eh
		db    0Eh,   0Eh,   0Eh,   0Eh
		db    0Eh,   0Eh,   0Eh,   0Eh
		db    0Eh,   0Eh,   0Eh,   0Eh
		db    0Eh,   0Eh,   0Eh,   0Bh
		db    0Ch,   0Eh,   0Eh,   0Eh
		db    0Eh,   0Eh,   0Eh,   0Eh
		db    0Eh,   0Eh,   0Dh
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1514h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_do_handshake
_SSL_do_handshake proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		mov	edi, 1
		cmp	dword ptr [esi+20h], 0
		jnz	short loc_1549
		push	0ADBh
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	90h ; ''
		push	0B4h ; '´'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1549:				; CODE XREF: _SSL_do_handshake+Fj
		mov	eax, [esi+8]
		push	esi
		mov	eax, [eax+2Ch]
		call	eax
		add	esp, 4
		test	dword ptr [esi+34h], 7000h
		jz	short loc_1569
		mov	eax, [esi+20h]
		push	esi
		call	eax
		add	esp, 4
		mov	edi, eax

loc_1569:				; CODE XREF: _SSL_do_handshake+48j
		mov	eax, edi
		pop	edi
		pop	esi
		retn
_SSL_do_handshake endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1570h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_dup
_SSL_dup	proc near

arg_0		= dword	ptr  4

		push	esi
		push	edi
		mov	edi, [esp+8+arg_0]
		push	dword ptr [edi+0E4h]
		call	_SSL_new
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jnz	short loc_158D
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_158D:				; CODE XREF: _SSL_dup+18j
		mov	eax, [edi]
		mov	[esi], eax
		mov	eax, [edi+4]
		mov	[esi+4], eax
		mov	eax, [edi+8]
		push	ebx
		mov	[esi+8], eax
		cmp	dword ptr [edi+0C0h], 0
		push	ebp
		jz	short loc_15B4
		push	edi
		push	esi
		call	_SSL_copy_session_id
		add	esp, 8
		jmp	short loc_1617
; ---------------------------------------------------------------------------

loc_15B4:				; CODE XREF: _SSL_dup+36j
		mov	eax, [eax+0Ch]
		push	esi
		call	eax
		mov	eax, [edi+8]
		mov	[esi+8], eax
		push	esi
		mov	eax, [eax+4]
		call	eax
		add	esp, 8
		cmp	dword ptr [edi+98h], 0
		jz	short loc_1601
		mov	eax, [esi+98h]
		test	eax, eax
		jz	short loc_15E5
		push	eax
		call	_ssl_cert_free
		add	esp, 4

loc_15E5:				; CODE XREF: _SSL_dup+6Aj
		push	dword ptr [edi+98h]
		call	_ssl_cert_dup
		add	esp, 4
		mov	[esi+98h], eax
		test	eax, eax
		jz	$err$107

loc_1601:				; CODE XREF: _SSL_dup+60j
		push	dword ptr [edi+9Ch] ; Size
		lea	eax, [edi+0A0h]
		push	eax		; Src
		push	esi		; int
		call	_SSL_set_session_id_context
		add	esp, 0Ch

loc_1617:				; CODE XREF: _SSL_dup+42j
		mov	eax, [edi+100h]
		mov	[esi+100h], eax
		mov	eax, [edi+104h]
		mov	[esi+104h], eax
		mov	eax, [edi+108h]
		mov	[esi+108h], eax
		mov	eax, [edi+60h]
		mov	[esi+60h], eax
		mov	eax, [edi+64h]
		mov	[esi+64h], eax
		mov	eax, [edi+68h]
		mov	[esi+68h], eax
		mov	ecx, [edi+0CCh]
		mov	eax, [edi+0C8h]
		mov	[esi+0C8h], eax
		test	ecx, ecx
		jz	short loc_1669
		mov	[esi+0CCh], ecx

loc_1669:				; CODE XREF: _SSL_dup+F1j
		push	dword ptr [edi+70h]
		call	_X509_VERIFY_PARAM_get_depth
		push	eax
		push	dword ptr [esi+70h]
		call	_X509_VERIFY_PARAM_set_depth
		mov	eax, [edi+0C4h]
		mov	[esi+0C4h], eax
		mov	eax, [edi+0D0h]
		mov	[esi+0D0h], eax
		mov	eax, [edi+0E8h]
		mov	[esi+0E8h], eax
		lea	eax, [edi+0F0h]
		push	eax
		lea	eax, [esi+0F0h]
		push	eax
		push	1
		call	_CRYPTO_dup_ex_data
		add	esp, 18h
		test	eax, eax
		jz	$err$107
		mov	ecx, [edi+0Ch]
		test	ecx, ecx
		jz	short loc_16DE
		lea	eax, [esi+0Ch]
		push	eax
		push	0
		push	0Ch
		push	ecx
		call	_BIO_ctrl
		add	esp, 10h
		test	eax, eax
		jz	$err$107

loc_16DE:				; CODE XREF: _SSL_dup+153j
		mov	ecx, [edi+10h]
		test	ecx, ecx
		jz	short loc_170B
		cmp	ecx, [edi+0Ch]
		jz	short loc_1705
		lea	eax, [esi+10h]
		push	eax
		push	0
		push	0Ch
		push	ecx
		call	_BIO_ctrl
		add	esp, 10h
		test	eax, eax
		jz	$err$107
		jmp	short loc_170B
; ---------------------------------------------------------------------------

loc_1705:				; CODE XREF: _SSL_dup+178j
		mov	eax, [esi+0Ch]
		mov	[esi+10h], eax

loc_170B:				; CODE XREF: _SSL_dup+173j
					; _SSL_dup+193j
		mov	eax, [edi+18h]
		mov	[esi+18h], eax
		mov	eax, [edi+1Ch]
		mov	[esi+1Ch], eax
		mov	eax, [edi+20h]
		mov	[esi+20h], eax
		mov	eax, [edi+24h]
		mov	[esi+24h], eax
		mov	eax, [edi+190h]
		mov	[esi+190h], eax
		mov	eax, [edi+28h]
		mov	[esi+28h], eax
		mov	eax, [edi+2Ch]
		mov	[esi+2Ch], eax
		mov	eax, [edi+30h]
		mov	[esi+30h], eax
		mov	eax, [edi+34h]
		mov	[esi+34h], eax
		mov	eax, [edi+38h]
		mov	[esi+38h], eax
		mov	dword ptr [esi+44h], 0
		mov	eax, [edi+6Ch]
		mov	[esi+6Ch], eax
		push	dword ptr [edi+70h]
		push	dword ptr [esi+70h]
		call	_X509_VERIFY_PARAM_inherit
		mov	eax, [edi+74h]
		add	esp, 8
		test	eax, eax
		jz	short loc_1783
		push	eax
		call	_sk_dup
		add	esp, 4
		mov	[esi+74h], eax
		test	eax, eax
		jz	$err$107

loc_1783:				; CODE XREF: _SSL_dup+1FDj
		mov	eax, [edi+78h]
		test	eax, eax
		jz	short loc_179A
		push	eax
		call	_sk_dup
		add	esp, 4
		mov	[esi+78h], eax
		test	eax, eax
		jz	short $err$107

loc_179A:				; CODE XREF: _SSL_dup+218j
		mov	eax, [edi+0F8h]
		test	eax, eax
		jz	short loc_180F
		push	eax
		call	_sk_dup
		mov	ebx, eax
		add	esp, 4
		test	ebx, ebx
		jz	short $err$107
		push	ebx
		mov	[esi+0F8h], ebx
		xor	edi, edi
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jle	short loc_180F

loc_17C8:				; CODE XREF: _SSL_dup+282j
		push	edi
		push	ebx
		call	_sk_value
		mov	ebp, eax
		push	ebp
		call	_X509_NAME_dup
		push	eax
		push	edi
		push	ebx
		call	_sk_set
		add	esp, 18h
		test	eax, eax
		jz	short loc_17FB
		push	ebx
		inc	edi
		call	_sk_num
		add	esp, 4
		cmp	edi, eax
		jl	short loc_17C8
		pop	ebp
		pop	ebx
		pop	edi
		mov	eax, esi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_17FB:				; CODE XREF: _SSL_dup+274j
		push	ebp
		call	_X509_NAME_free
		add	esp, 4

$err$107:				; CODE XREF: _SSL_dup+8Bj
					; _SSL_dup+148j ...
		push	esi
		call	_SSL_free
		add	esp, 4
		xor	esi, esi

loc_180F:				; CODE XREF: _SSL_dup+232j
					; _SSL_dup+256j
		pop	ebp
		pop	ebx
		pop	edi
		mov	eax, esi
		pop	esi
		retn
_SSL_dup	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1818h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_export_keying_material
_SSL_export_keying_material proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		cmp	dword ptr [ecx], 301h
		jge	short loc_1828
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_1828:				; CODE XREF: _SSL_export_keying_material+Aj
		mov	eax, [ecx+8]
		mov	[esp+arg_0], ecx
		mov	eax, [eax+64h]
		mov	eax, [eax+34h]
		jmp	eax
_SSL_export_keying_material endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1838h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_free
_SSL_free	proc near		; CODE XREF: _SSL_dup+295p
					; _SSL_new+CCp

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	loc_1A9F
		push	239h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	10h
		lea	eax, [esi+0FCh]
		push	0FFFFFFFFh
		push	eax
		call	_CRYPTO_add_lock
		add	esp, 14h
		test	eax, eax
		jg	loc_1A9F
		mov	eax, [esi+70h]
		test	eax, eax
		jz	short loc_187A
		push	eax
		call	_X509_VERIFY_PARAM_free
		add	esp, 4

loc_187A:				; CODE XREF: _SSL_free+37j
		lea	eax, [esi+0F0h]
		push	eax
		push	esi
		push	1
		call	_CRYPTO_free_ex_data
		mov	eax, [esi+14h]
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_18B8
		mov	ecx, [esi+10h]
		cmp	eax, ecx
		jnz	short loc_18A6
		push	ecx
		call	_BIO_pop
		add	esp, 4
		mov	[esi+10h], eax

loc_18A6:				; CODE XREF: _SSL_free+60j
		push	dword ptr [esi+14h]
		call	_BIO_free
		add	esp, 4
		mov	dword ptr [esi+14h], 0

loc_18B8:				; CODE XREF: _SSL_free+59j
		mov	eax, [esi+0Ch]
		test	eax, eax
		jz	short loc_18C8
		push	eax
		call	_BIO_free_all
		add	esp, 4

loc_18C8:				; CODE XREF: _SSL_free+85j
		mov	eax, [esi+10h]
		test	eax, eax
		jz	short loc_18DD
		cmp	eax, [esi+0Ch]
		jz	short loc_18DD
		push	eax
		call	_BIO_free_all
		add	esp, 4

loc_18DD:				; CODE XREF: _SSL_free+95j
					; _SSL_free+9Aj
		mov	eax, [esi+3Ch]
		test	eax, eax
		jz	short loc_18ED
		push	eax
		call	_BUF_MEM_free
		add	esp, 4

loc_18ED:				; CODE XREF: _SSL_free+AAj
		mov	eax, [esi+74h]
		test	eax, eax
		jz	short loc_18FD
		push	eax
		call	_sk_free
		add	esp, 4

loc_18FD:				; CODE XREF: _SSL_free+BAj
		mov	eax, [esi+78h]
		test	eax, eax
		jz	short loc_190D
		push	eax
		call	_sk_free
		add	esp, 4

loc_190D:				; CODE XREF: _SSL_free+CAj
		cmp	dword ptr [esi+0C0h], 0
		jz	short loc_192A
		push	esi
		call	_ssl_clear_bad_session
		push	dword ptr [esi+0C0h]
		call	_SSL_SESSION_free
		add	esp, 8

loc_192A:				; CODE XREF: _SSL_free+DCj
		push	esi
		call	_ssl_clear_cipher_ctx
		mov	eax, [esi+84h]
		add	esp, 4
		test	eax, eax
		jz	short loc_1946
		push	eax
		call	_EVP_MD_CTX_destroy
		add	esp, 4

loc_1946:				; CODE XREF: _SSL_free+103j
		mov	dword ptr [esi+84h], 0
		mov	eax, [esi+90h]
		test	eax, eax
		jz	short loc_1963
		push	eax
		call	_EVP_MD_CTX_destroy
		add	esp, 4

loc_1963:				; CODE XREF: _SSL_free+120j
		mov	dword ptr [esi+90h], 0
		mov	eax, [esi+98h]
		test	eax, eax
		jz	short loc_1980
		push	eax
		call	_ssl_cert_free
		add	esp, 4

loc_1980:				; CODE XREF: _SSL_free+13Dj
		mov	eax, [esi+120h]
		test	eax, eax
		jz	short loc_1993
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_1993:				; CODE XREF: _SSL_free+150j
		mov	eax, [esi+170h]
		test	eax, eax
		jz	short loc_19A6
		push	eax
		call	_SSL_CTX_free
		add	esp, 4

loc_19A6:				; CODE XREF: _SSL_free+163j
		mov	eax, [esi+148h]
		test	eax, eax
		jz	short loc_19B9
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_19B9:				; CODE XREF: _SSL_free+176j
		mov	eax, [esi+150h]
		test	eax, eax
		jz	short loc_19CC
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_19CC:				; CODE XREF: _SSL_free+189j
		mov	eax, [esi+154h]
		test	eax, eax
		jz	short loc_19DF
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_19DF:				; CODE XREF: _SSL_free+19Cj
		mov	eax, [esi+134h]
		test	eax, eax
		jz	short loc_19F7
		push	offset _X509_EXTENSION_free
		push	eax
		call	_sk_pop_free
		add	esp, 8

loc_19F7:				; CODE XREF: _SSL_free+1AFj
		mov	eax, [esi+130h]
		test	eax, eax
		jz	short loc_1A0F
		push	offset _OCSP_RESPID_free
		push	eax
		call	_sk_pop_free
		add	esp, 8

loc_1A0F:				; CODE XREF: _SSL_free+1C7j
		mov	eax, [esi+138h]
		test	eax, eax
		jz	short loc_1A22
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_1A22:				; CODE XREF: _SSL_free+1DFj
		mov	eax, [esi+1D4h]
		test	eax, eax
		jz	short loc_1A35
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_1A35:				; CODE XREF: _SSL_free+1F2j
		mov	eax, [esi+0F8h]
		test	eax, eax
		jz	short loc_1A4D
		push	offset _X509_NAME_free
		push	eax
		call	_sk_pop_free
		add	esp, 8

loc_1A4D:				; CODE XREF: _SSL_free+205j
		mov	eax, [esi+8]
		test	eax, eax
		jz	short loc_1A5D
		mov	eax, [eax+0Ch]
		push	esi
		call	eax
		add	esp, 4

loc_1A5D:				; CODE XREF: _SSL_free+21Aj
		mov	eax, [esi+0E4h]
		test	eax, eax
		jz	short loc_1A70
		push	eax
		call	_SSL_CTX_free
		add	esp, 4

loc_1A70:				; CODE XREF: _SSL_free+22Dj
		mov	eax, [esi+174h]
		test	eax, eax
		jz	short loc_1A83
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_1A83:				; CODE XREF: _SSL_free+240j
		mov	eax, [esi+17Ch]
		test	eax, eax
		jz	short loc_1A96
		push	eax
		call	_sk_free
		add	esp, 4

loc_1A96:				; CODE XREF: _SSL_free+253j
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_1A9F:				; CODE XREF: _SSL_free+7j
					; _SSL_free+2Cj
		pop	esi
		retn
_SSL_free	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1AA4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get0_alpn_selected
_SSL_get0_alpn_selected	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_4]
		mov	edx, [esp+arg_0]
		mov	dword ptr [ecx], 0
		mov	eax, [edx+58h]
		test	eax, eax
		jz	short loc_1AD5
		mov	eax, [eax+424h]
		mov	[ecx], eax
		test	eax, eax
		jz	short loc_1AD5
		mov	eax, [edx+58h]
		mov	ecx, [eax+428h]
		mov	eax, [esp+arg_8]
		mov	[eax], ecx
		retn
; ---------------------------------------------------------------------------

loc_1AD5:				; CODE XREF: _SSL_get0_alpn_selected+13j
					; _SSL_get0_alpn_selected+1Fj
		mov	eax, [esp+arg_8]
		mov	dword ptr [eax], 0
		retn
_SSL_get0_alpn_selected	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1AE0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get0_next_proto_negotiated
_SSL_get0_next_proto_negotiated	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	edx, [esp+arg_0]
		mov	eax, [esp+arg_4]
		mov	ecx, [edx+174h]
		mov	[eax], ecx
		mov	eax, [esp+arg_8]
		test	ecx, ecx
		jnz	short loc_1AFB
		mov	[eax], ecx
		retn
; ---------------------------------------------------------------------------

loc_1AFB:				; CODE XREF: _SSL_get0_next_proto_negotiated+16j
		movzx	ecx, byte ptr [edx+178h]
		mov	[eax], ecx
		retn
_SSL_get0_next_proto_negotiated	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1B08h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get0_param
_SSL_get0_param	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+70h]
		retn
_SSL_get0_param	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1B10h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_SSL_CTX
_SSL_get_SSL_CTX proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+0E4h]
		retn
_SSL_get_SSL_CTX endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1B1Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_certificate
_SSL_get_certificate proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+98h]
		test	eax, eax
		jz	short loc_1B2F
		mov	eax, [eax]
		mov	eax, [eax]
		retn
; ---------------------------------------------------------------------------

loc_1B2F:				; CODE XREF: _SSL_get_certificate+Cj
		xor	eax, eax
		retn
_SSL_get_certificate endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1B34h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_cipher_list
_SSL_get_cipher_list proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		test	eax, eax
		jnz	short loc_1B3D
		retn
; ---------------------------------------------------------------------------

loc_1B3D:				; CODE XREF: _SSL_get_cipher_list+6j
		push	esi
		mov	esi, [eax+74h]
		test	esi, esi
		jnz	short loc_1B56
		mov	esi, [eax+0E4h]
		test	esi, esi
		jz	short loc_1B7A
		mov	esi, [esi+4]
		test	esi, esi
		jz	short loc_1B7A

loc_1B56:				; CODE XREF: _SSL_get_cipher_list+Fj
		push	esi
		call	_sk_num
		mov	ecx, [esp+8+arg_4]
		add	esp, 4
		cmp	eax, ecx
		jle	short loc_1B7A
		push	ecx
		push	esi
		call	_sk_value
		add	esp, 8
		test	eax, eax
		jz	short loc_1B7A
		mov	eax, [eax+4]
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1B7A:				; CODE XREF: _SSL_get_cipher_list+19j
					; _SSL_get_cipher_list+20j ...
		xor	eax, eax
		pop	esi
		retn
_SSL_get_cipher_list endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1B80h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_ciphers
_SSL_get_ciphers proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jz	short loc_1BA0
		mov	eax, [ecx+74h]
		test	eax, eax
		jnz	short locret_1BA2
		mov	eax, [ecx+0E4h]
		test	eax, eax
		jz	short loc_1BA0
		mov	eax, [eax+4]
		test	eax, eax
		jnz	short locret_1BA2

loc_1BA0:				; CODE XREF: _SSL_get_ciphers+6j
					; _SSL_get_ciphers+17j
		xor	eax, eax

locret_1BA2:				; CODE XREF: _SSL_get_ciphers+Dj
					; _SSL_get_ciphers+1Ej
		retn
_SSL_get_ciphers endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1BA4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_current_cipher
_SSL_get_current_cipher	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+0C0h]
		test	eax, eax
		jz	short loc_1BBC
		mov	eax, [eax+0B4h]
		test	eax, eax
		jnz	short locret_1BBE

loc_1BBC:				; CODE XREF: _SSL_get_current_cipher+Cj
		xor	eax, eax

locret_1BBE:				; CODE XREF: _SSL_get_current_cipher+16j
		retn
_SSL_get_current_cipher	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1BC0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_current_compression
_SSL_get_current_compression proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+94h]
		test	eax, eax
		jz	short loc_1BD1
		mov	eax, [eax]
		retn
; ---------------------------------------------------------------------------

loc_1BD1:				; CODE XREF: _SSL_get_current_compression+Cj
		xor	eax, eax
		retn
_SSL_get_current_compression endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1BD4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_current_expansion
_SSL_get_current_expansion proc	near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+88h]
		test	eax, eax
		jz	short loc_1BE5
		mov	eax, [eax]
		retn
; ---------------------------------------------------------------------------

loc_1BE5:				; CODE XREF: _SSL_get_current_expansion+Cj
		xor	eax, eax
		retn
_SSL_get_current_expansion endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1BE8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_default_timeout
_SSL_get_default_timeout proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+8]
		mov	eax, [eax+60h]
		jmp	eax
_SSL_get_default_timeout endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1BF4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_error
_SSL_get_error	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	edi
		mov	edi, [esp+4+arg_4]
		test	edi, edi
		jle	short loc_1C01
		xor	eax, eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_1C01:				; CODE XREF: _SSL_get_error+7j
		call	_ERR_peek_error
		mov	ecx, eax
		test	ecx, ecx
		jz	short loc_1C26
		xor	eax, eax
		and	ecx, 0FF000000h
		cmp	ecx, 2000000h
		pop	edi
		setz	al
		lea	eax, ds:1[eax*4]
		retn
; ---------------------------------------------------------------------------

loc_1C26:				; CODE XREF: _SSL_get_error+16j
		push	ebx
		push	esi
		mov	esi, [esp+0Ch+arg_0]
		test	edi, edi
		jns	loc_1CEE
		cmp	dword ptr [esi+18h], 3
		jnz	short loc_1C6A
		mov	ebx, [esi+0Ch]
		push	1
		push	ebx
		call	_BIO_test_flags
		add	esp, 8
		test	eax, eax
		jnz	short loc_1C9A
		push	2
		push	ebx
		call	_BIO_test_flags
		add	esp, 8
		test	eax, eax
		jnz	short loc_1C82
		push	4
		push	ebx
		call	_BIO_test_flags
		add	esp, 8
		test	eax, eax
		jnz	short loc_1CB2

loc_1C6A:				; CODE XREF: _SSL_get_error+44j
		cmp	dword ptr [esi+18h], 2
		jnz	short loc_1CDD
		mov	ebx, [esi+10h]
		push	2
		push	ebx
		call	_BIO_test_flags
		add	esp, 8
		test	eax, eax
		jz	short loc_1C8B

loc_1C82:				; CODE XREF: _SSL_get_error+65j
		pop	esi
		pop	ebx
		mov	eax, 3
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_1C8B:				; CODE XREF: _SSL_get_error+8Cj
		push	1
		push	ebx
		call	_BIO_test_flags
		add	esp, 8
		test	eax, eax
		jz	short loc_1CA3

loc_1C9A:				; CODE XREF: _SSL_get_error+56j
		pop	esi
		pop	ebx
		mov	eax, 2
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_1CA3:				; CODE XREF: _SSL_get_error+A4j
		push	4
		push	ebx
		call	_BIO_test_flags
		add	esp, 8
		test	eax, eax
		jz	short loc_1CDD

loc_1CB2:				; CODE XREF: _SSL_get_error+74j
		push	ebx
		call	_BIO_get_retry_reason
		mov	ecx, eax
		add	esp, 4
		cmp	ecx, 2
		jnz	short loc_1CC9
		pop	esi
		pop	ebx
		lea	eax, [ecx+5]
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_1CC9:				; CODE XREF: _SSL_get_error+CCj
		pop	esi
		cmp	ecx, 3
		mov	eax, 5
		mov	edx, 8
		pop	ebx
		cmovz	eax, edx
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_1CDD:				; CODE XREF: _SSL_get_error+7Aj
					; _SSL_get_error+BCj
		cmp	dword ptr [esi+18h], 4
		jnz	short loc_1CEC
		pop	esi
		pop	ebx
		mov	eax, 4
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_1CEC:				; CODE XREF: _SSL_get_error+EDj
		test	edi, edi

loc_1CEE:				; CODE XREF: _SSL_get_error+3Aj
		jnz	short loc_1D15
		cmp	dword ptr [esi], 2
		jnz	short loc_1CFE
		pop	esi
		pop	ebx
		mov	eax, 6
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_1CFE:				; CODE XREF: _SSL_get_error+FFj
		test	byte ptr [esi+30h], 2
		jz	short loc_1D15
		mov	eax, [esi+58h]
		cmp	dword ptr [eax+184h], 0
		mov	eax, 6
		jz	short loc_1D1A

loc_1D15:				; CODE XREF: _SSL_get_error:loc_1CEEj
					; _SSL_get_error+10Ej
		mov	eax, 5

loc_1D1A:				; CODE XREF: _SSL_get_error+11Fj
		pop	esi
		pop	ebx
		pop	edi
		retn
_SSL_get_error	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1D20h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_ex_data
_SSL_get_ex_data proc near

arg_0		= dword	ptr  4

		add	[esp+arg_0], 0F0h ; 'ð'
		jmp	_CRYPTO_get_ex_data
_SSL_get_ex_data endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1D30h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_ex_new_index
_SSL_get_ex_new_index proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		push	[esp+arg_10]
		push	[esp+4+arg_C]
		push	[esp+8+arg_8]
		push	[esp+0Ch+arg_4]
		push	[esp+10h+arg_0]
		push	1
		call	_CRYPTO_get_ex_new_index
		add	esp, 18h
		retn
_SSL_get_ex_new_index endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1D50h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_fd
_SSL_get_fd	proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 4
		call	__chkstk
		mov	eax, [esp+4+arg_0]
		push	100h
		mov	[esp+8+var_4], 0FFFFFFFFh
		push	dword ptr [eax+0Ch]
		call	_BIO_find_type
		add	esp, 8
		test	eax, eax
		jz	short loc_1D8B
		lea	ecx, [esp+4+var_4]
		push	ecx
		push	0
		push	69h ; 'i'
		push	eax
		call	_BIO_ctrl
		add	esp, 10h

loc_1D8B:				; CODE XREF: _SSL_get_fd+28j
		mov	eax, [esp+4+var_4]
		pop	ecx
		retn
_SSL_get_fd	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1D90h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl SSL_get_finished(int, void *Dst, int)
		public _SSL_get_finished
_SSL_get_finished proc near

arg_0		= dword	ptr  4
Dst		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, [esp+arg_0]
		mov	ecx, [eax+58h]
		test	ecx, ecx
		jz	short loc_1DC3
		mov	eax, [esp+arg_8]
		push	esi
		mov	esi, [ecx+2B4h]
		cmp	eax, esi
		cmova	eax, esi
		push	eax		; Size
		lea	eax, [ecx+234h]
		push	eax		; Src
		push	[esp+0Ch+Dst]	; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, esi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1DC3:				; CODE XREF: _SSL_get_finished+9j
		xor	eax, eax
		retn
_SSL_get_finished endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1DC8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_info_callback
_SSL_get_info_callback proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+0D0h]
		retn
_SSL_get_info_callback endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1DD4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_peer_cert_chain
_SSL_get_peer_cert_chain proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short loc_1DF3
		mov	eax, [eax+0C0h]
		test	eax, eax
		jz	short loc_1DF3
		mov	eax, [eax+98h]
		test	eax, eax
		jz	short loc_1DF3
		mov	eax, [eax]
		retn
; ---------------------------------------------------------------------------

loc_1DF3:				; CODE XREF: _SSL_get_peer_cert_chain+6j
					; _SSL_get_peer_cert_chain+10j	...
		xor	eax, eax
		retn
_SSL_get_peer_cert_chain endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1DF8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_peer_certificate
_SSL_get_peer_certificate proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		push	esi
		test	eax, eax
		jz	short loc_1E33
		mov	esi, [eax+0C0h]
		test	esi, esi
		jz	short loc_1E33
		mov	esi, [esi+9Ch]
		test	esi, esi
		jz	short loc_1E33
		push	382h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	3
		lea	ecx, [esi+10h]
		push	1
		push	ecx
		call	_CRYPTO_add_lock
		add	esp, 14h
		mov	eax, esi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1E33:				; CODE XREF: _SSL_get_peer_certificate+7j
					; _SSL_get_peer_certificate+11j ...
		xor	eax, eax
		pop	esi
		retn
_SSL_get_peer_certificate endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1E38h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl SSL_get_peer_finished(int, void *Dst, int)
		public _SSL_get_peer_finished
_SSL_get_peer_finished proc near

arg_0		= dword	ptr  4
Dst		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, [esp+arg_0]
		mov	ecx, [eax+58h]
		test	ecx, ecx
		jz	short loc_1E6B
		mov	eax, [esp+arg_8]
		push	esi
		mov	esi, [ecx+338h]
		cmp	eax, esi
		cmova	eax, esi
		push	eax		; Size
		lea	eax, [ecx+2B8h]
		push	eax		; Src
		push	[esp+0Ch+Dst]	; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, esi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1E6B:				; CODE XREF: _SSL_get_peer_finished+9j
		xor	eax, eax
		retn
_SSL_get_peer_finished endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1E70h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_privatekey
_SSL_get_privatekey proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+98h]
		test	eax, eax
		jz	short loc_1E84
		mov	eax, [eax]
		mov	eax, [eax+4]
		retn
; ---------------------------------------------------------------------------

loc_1E84:				; CODE XREF: _SSL_get_privatekey+Cj
		xor	eax, eax
		retn
_SSL_get_privatekey endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1E88h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_psk_identity
_SSL_get_psk_identity proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short loc_1EA1
		mov	eax, [eax+0C0h]
		test	eax, eax
		jz	short loc_1EA1
		mov	eax, [eax+90h]
		retn
; ---------------------------------------------------------------------------

loc_1EA1:				; CODE XREF: _SSL_get_psk_identity+6j
					; _SSL_get_psk_identity+10j
		xor	eax, eax
		retn
_SSL_get_psk_identity endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1EA4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_psk_identity_hint
_SSL_get_psk_identity_hint proc	near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short loc_1EBD
		mov	eax, [eax+0C0h]
		test	eax, eax
		jz	short loc_1EBD
		mov	eax, [eax+8Ch]
		retn
; ---------------------------------------------------------------------------

loc_1EBD:				; CODE XREF: _SSL_get_psk_identity_hint+6j
					; _SSL_get_psk_identity_hint+10j
		xor	eax, eax
		retn
_SSL_get_psk_identity_hint endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1EC0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_quiet_shutdown
_SSL_get_quiet_shutdown	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+2Ch]
		retn
_SSL_get_quiet_shutdown	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1EC8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_rbio
_SSL_get_rbio	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+0Ch]
		retn
_SSL_get_rbio	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1ED0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_read_ahead
_SSL_get_read_ahead proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+60h]
		retn
_SSL_get_read_ahead endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1ED8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_rfd
_SSL_get_rfd	proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 4
		call	__chkstk
		mov	eax, [esp+4+arg_0]
		push	100h
		mov	[esp+8+var_4], 0FFFFFFFFh
		push	dword ptr [eax+0Ch]
		call	_BIO_find_type
		add	esp, 8
		test	eax, eax
		jz	short loc_1F13
		lea	ecx, [esp+4+var_4]
		push	ecx
		push	0
		push	69h ; 'i'
		push	eax
		call	_BIO_ctrl
		add	esp, 10h

loc_1F13:				; CODE XREF: _SSL_get_rfd+28j
		mov	eax, [esp+4+var_4]
		pop	ecx
		retn
_SSL_get_rfd	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1F18h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_servername
_SSL_get_servername proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		cmp	[esp+arg_4], 0
		jz	short loc_1F22
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1F22:				; CODE XREF: _SSL_get_servername+5j
		mov	eax, [esp+arg_0]
		mov	ecx, [eax+0C0h]
		test	ecx, ecx
		jz	short loc_1F40
		cmp	dword ptr [eax+120h], 0
		jnz	short loc_1F40
		mov	eax, [ecx+0D0h]
		retn
; ---------------------------------------------------------------------------

loc_1F40:				; CODE XREF: _SSL_get_servername+16j
					; _SSL_get_servername+1Fj
		mov	eax, [eax+120h]
		retn
_SSL_get_servername endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1F48h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_servername_type
_SSL_get_servername_type proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	ecx, [eax+0C0h]
		test	ecx, ecx
		jz	short loc_1F6D
		mov	eax, [eax+120h]
		test	eax, eax
		jnz	short loc_1F6A
		mov	eax, [ecx+0D0h]
		test	eax, eax
		jz	short loc_1F6D

loc_1F6A:				; CODE XREF: _SSL_get_servername_type+16j
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1F6D:				; CODE XREF: _SSL_get_servername_type+Cj
					; _SSL_get_servername_type+20j
		or	eax, 0FFFFFFFFh
		retn
_SSL_get_servername_type endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1F74h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_shared_ciphers
_SSL_get_shared_ciphers	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, [esp+arg_0]
		push	ebp
		push	esi
		mov	eax, [eax+0C0h]
		test	eax, eax
		jz	loc_2043
		mov	esi, [eax+0BCh]
		mov	[esp+8+arg_0], esi
		test	esi, esi
		jz	loc_2043
		mov	ebp, [esp+8+arg_8]
		cmp	ebp, 2
		jl	loc_2043
		push	edi
		mov	edi, [esp+0Ch+arg_4]
		push	esi
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jnz	short loc_1FBD
		pop	edi
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1FBD:				; CODE XREF: _SSL_get_shared_ciphers+43j
		push	ebx
		push	esi
		xor	ebx, ebx
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jle	short loc_2025
		nop	dword ptr [eax+00000000h]

loc_1FD4:				; CODE XREF: _SSL_get_shared_ciphers+AFj
		push	ebx
		push	esi
		call	_sk_value
		add	esp, 8
		mov	esi, [eax+4]
		mov	edx, esi
		lea	ecx, [edx+1]

loc_1FE6:				; CODE XREF: _SSL_get_shared_ciphers+77j
		mov	al, [edx]
		inc	edx
		test	al, al
		jnz	short loc_1FE6
		sub	edx, ecx
		lea	eax, [edx+1]
		cmp	eax, ebp
		jg	short loc_2032
		mov	eax, edi

loc_1FF8:				; CODE XREF: _SSL_get_shared_ciphers+90j
		mov	cl, [esi]
		lea	esi, [esi+1]
		mov	[eax], cl
		lea	eax, [eax+1]
		test	cl, cl
		jnz	short loc_1FF8
		mov	esi, [esp+10h+arg_0]
		add	edi, edx
		or	eax, 0FFFFFFFFh
		inc	ebx
		sub	eax, edx
		push	esi
		mov	byte ptr [edi],	3Ah ; ':'
		add	ebp, eax
		inc	edi
		call	_sk_num
		add	esp, 4
		cmp	ebx, eax
		jl	short loc_1FD4

loc_2025:				; CODE XREF: _SSL_get_shared_ciphers+57j
		mov	eax, [esp+10h+arg_4]
		pop	ebx
		mov	byte ptr [edi-1], 0
		pop	edi
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_2032:				; CODE XREF: _SSL_get_shared_ciphers+80j
		mov	eax, [esp+10h+arg_4]
		cmp	edi, eax
		jz	short loc_203B
		dec	edi

loc_203B:				; CODE XREF: _SSL_get_shared_ciphers+C4j
		pop	ebx
		mov	byte ptr [edi],	0
		pop	edi
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_2043:				; CODE XREF: _SSL_get_shared_ciphers+Ej
					; _SSL_get_shared_ciphers+20j ...
		pop	esi
		xor	eax, eax
		pop	ebp
		retn
_SSL_get_shared_ciphers	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2048h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_shutdown
_SSL_get_shutdown proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+30h]
		retn
_SSL_get_shutdown endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2050h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_ssl_method
_SSL_get_ssl_method proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+8]
		retn
_SSL_get_ssl_method endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2058h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_verify_callback
_SSL_get_verify_callback proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+0CCh]
		retn
_SSL_get_verify_callback endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2064h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_verify_depth
_SSL_get_verify_depth proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		push	dword ptr [eax+70h]
		call	_X509_VERIFY_PARAM_get_depth
		add	esp, 4
		retn
_SSL_get_verify_depth endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2074h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_verify_mode
_SSL_get_verify_mode proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+0C8h]
		retn
_SSL_get_verify_mode endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2080h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_verify_result
_SSL_get_verify_result proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+0ECh]
		retn
_SSL_get_verify_result endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 208Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_version
_SSL_get_version proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	ecx, [eax]
		cmp	ecx, 303h
		jnz	short loc_20A0
		mov	eax, offset ??_C@_07KDKGANMO@TLSv1?42?$AA@ ; "TLSv1.2"
		retn
; ---------------------------------------------------------------------------

loc_20A0:				; CODE XREF: _SSL_get_version+Cj
		cmp	ecx, 302h
		jnz	short loc_20AE
		mov	eax, offset ??_C@_07IIILFOAN@TLSv1?41?$AA@ ; "TLSv1.1"
		retn
; ---------------------------------------------------------------------------

loc_20AE:				; CODE XREF: _SSL_get_version+1Aj
		cmp	ecx, 301h
		jnz	short loc_20BC
		mov	eax, offset ??_C@_05LLIBCOJ@TLSv1?$AA@ ; "TLSv1"
		retn
; ---------------------------------------------------------------------------

loc_20BC:				; CODE XREF: _SSL_get_version+28j
		cmp	ecx, 300h
		jnz	short loc_20CA
		mov	eax, offset ??_C@_05MOEBAHEJ@SSLv3?$AA@	; "SSLv3"
		retn
; ---------------------------------------------------------------------------

loc_20CA:				; CODE XREF: _SSL_get_version+36j
		cmp	ecx, 2
		jnz	short loc_20D5
		mov	eax, offset ??_C@_05NHFKDGAI@SSLv2?$AA@	; "SSLv2"
		retn
; ---------------------------------------------------------------------------

loc_20D5:				; CODE XREF: _SSL_get_version+41j
		cmp	ecx, 100h
		jnz	short loc_20E3
		mov	eax, offset ??_C@_08PILLCKKM@DTLSv0?49?$AA@ ; "DTLSv0.9"
		retn
; ---------------------------------------------------------------------------

loc_20E3:				; CODE XREF: _SSL_get_version+4Fj
		cmp	ecx, 0FEFFh
		jnz	short loc_20F1
		mov	eax, offset ??_C@_06JHFCDNFO@DTLSv1?$AA@ ; "DTLSv1"
		retn
; ---------------------------------------------------------------------------

loc_20F1:				; CODE XREF: _SSL_get_version+5Dj
		cmp	ecx, 0FEFDh
		mov	eax, offset ??_C@_08KDPDJEAC@DTLSv1?42?$AA@ ; "DTLSv1.2"
		mov	edx, offset ??_C@_07CIFAGBMG@unknown?$AA@ ; "unknown"
		cmovnz	eax, edx
		retn
_SSL_get_version endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2108h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_wbio
_SSL_get_wbio	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+10h]
		retn
_SSL_get_wbio	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2110h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_get_wfd
_SSL_get_wfd	proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 4
		call	__chkstk
		mov	eax, [esp+4+arg_0]
		push	100h
		mov	[esp+8+var_4], 0FFFFFFFFh
		push	dword ptr [eax+10h]
		call	_BIO_find_type
		add	esp, 8
		test	eax, eax
		jz	short loc_214B
		lea	ecx, [esp+4+var_4]
		push	ecx
		push	0
		push	69h ; 'i'
		push	eax
		call	_BIO_ctrl
		add	esp, 10h

loc_214B:				; CODE XREF: _SSL_get_wfd+28j
		mov	eax, [esp+4+var_4]
		pop	ecx
		retn
_SSL_get_wfd	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2150h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl SSL_has_matching_session_id(int, void *Src, size_t Size)
		public _SSL_has_matching_session_id
_SSL_has_matching_session_id proc near

var_F8		= dword	ptr -0F8h
var_B4		= dword	ptr -0B4h
Dst		= byte ptr -0B0h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
Src		= dword	ptr  8
Size		= dword	ptr  0Ch

		mov	eax, 0F8h ; 'ø'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+0F8h+var_4], eax
		mov	ecx, [esp+0F8h+Src]
		push	esi
		mov	esi, [esp+0FCh+Size]
		push	edi
		mov	edi, [esp+100h+arg_0]
		cmp	esi, 20h ; ' '
		jbe	short loc_219D
		pop	edi
		xor	eax, eax
		pop	esi
		mov	ecx, [esp+0F8h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 0F8h
		retn
; ---------------------------------------------------------------------------

loc_219D:				; CODE XREF: _SSL_has_matching_session_id+32j
		mov	eax, [edi]
		push	esi		; Size
		mov	[esp+104h+var_F8], eax
		lea	eax, [esp+104h+Dst]
		push	ecx		; Src
		push	eax		; Dst
		mov	[esp+10Ch+var_B4], esi
		call	_memcpy
		add	esp, 0Ch
		cmp	[esp+100h+var_F8], 2
		jnz	short loc_21E3
		cmp	esi, 10h
		jnb	short loc_21E3
		mov	eax, 10h
		sub	eax, esi
		push	eax		; Size
		lea	eax, [esp+104h+Dst]
		add	eax, esi
		push	0		; Val
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		mov	[esp+100h+var_B4], 10h

loc_21E3:				; CODE XREF: _SSL_has_matching_session_id+6Bj
					; _SSL_has_matching_session_id+70j
		push	1FFh
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0Ch
		push	5
		call	_CRYPTO_lock
		lea	eax, [esp+110h+var_F8]
		push	eax
		mov	eax, [edi+0E4h]
		push	dword ptr [eax+10h]
		call	_lh_retrieve
		push	201h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0Ch
		push	6
		mov	esi, eax
		call	_CRYPTO_lock
		mov	ecx, [esp+128h+var_4]
		add	esp, 28h
		xor	eax, eax
		test	esi, esi
		setnz	al
		pop	edi
		pop	esi
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 0F8h
		retn
_SSL_has_matching_session_id endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2240h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_is_server
_SSL_is_server	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+24h]
		retn
_SSL_is_server	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2248h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_new
_SSL_new	proc near		; CODE XREF: _SSL_dup+Cp

arg_0		= dword	ptr  4

		push	ebx
		mov	ebx, [esp+4+arg_0]
		test	ebx, ebx
		jnz	short loc_2273
		push	12Bh
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0C3h ; 'Ã'
		push	0BAh ; 'º'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_2273:				; CODE XREF: _SSL_new+7j
		cmp	dword ptr [ebx], 0
		jnz	short loc_229A
		push	12Fh
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0E4h ; 'ä'
		push	0BAh ; 'º'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_229A:				; CODE XREF: _SSL_new+2Ej
		push	edi
		push	133h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	1DCh
		call	_CRYPTO_malloc
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jz	short loc_231C
		push	1DCh		; Size
		push	0		; Val
		push	edi		; Dst
		call	_memset
		mov	ecx, [ebx+0A4h]
		add	esp, 0Ch
		mov	[edi+100h], ecx
		mov	eax, [ebx+0A8h]
		mov	[edi+104h], eax
		mov	eax, [ebx+0ACh]
		mov	[edi+108h], eax
		mov	dword ptr [edi+0FCh], 1
		mov	eax, [ebx+0B0h]
		test	eax, eax
		jz	short loc_233C
		push	eax
		call	_ssl_cert_dup
		add	esp, 4
		mov	[edi+98h], eax
		test	eax, eax
		jnz	short loc_2346

$err$23:				; CODE XREF: _SSL_new+18Bj
					; _SSL_new+269j ...
		push	edi
		call	_SSL_free
		add	esp, 4

loc_231C:				; CODE XREF: _SSL_new+6Ej
		push	1B1h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	41h ; 'A'
		push	0BAh ; 'º'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_233C:				; CODE XREF: _SSL_new+B6j
		mov	dword ptr [edi+98h], 0

loc_2346:				; CODE XREF: _SSL_new+C9j
		mov	eax, [ebx+0B4h]
		mov	[edi+60h], eax
		mov	eax, [ebx+0B8h]
		mov	[edi+64h], eax
		mov	eax, [ebx+0BCh]
		mov	[edi+68h], eax
		mov	eax, [ebx+0C0h]
		mov	[edi+0C8h], eax
		mov	eax, [ebx+0C4h]
		mov	[edi+9Ch], eax
		cmp	eax, 20h ; ' '
		jbe	short loc_2395
		push	offset ??_C@_0CH@MEMCPFFG@s?9?$DOsid_ctx_length?5?$DM?$DN?5sizeof?5s?9?$DOs@ ; "s->sid_ctx_length <= sizeof s->sid_ctx"
		push	15Ah
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_2395:				; CODE XREF: _SSL_new+134j
		movups	xmm0, xmmword ptr [ebx+0C8h]
		movups	xmmword	ptr [edi+0A0h],	xmm0
		movups	xmm0, xmmword ptr [ebx+0D8h]
		movups	xmmword	ptr [edi+0B0h],	xmm0
		mov	eax, [ebx+0E8h]
		mov	[edi+0CCh], eax
		mov	eax, [ebx+0ECh]
		mov	[edi+0C4h], eax
		call	_X509_VERIFY_PARAM_new
		mov	[edi+70h], eax
		test	eax, eax
		jz	$err$23
		push	esi
		push	dword ptr [ebx+0F0h]
		push	eax
		call	_X509_VERIFY_PARAM_inherit
		mov	eax, [ebx+0F4h]
		lea	esi, [ebx+60h]
		push	16Ah
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0Ch
		mov	[edi+2Ch], eax
		mov	eax, [ebx+0F8h]
		push	1
		push	esi
		mov	[edi+114h], eax
		call	_CRYPTO_add_lock
		push	176h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0Ch
		push	1
		push	esi
		mov	[edi+0E4h], ebx
		mov	dword ptr [edi+118h], 0
		mov	dword ptr [edi+11Ch], 0
		mov	dword ptr [edi+140h], 0
		mov	dword ptr [edi+128h], 0FFFFFFFFh
		mov	dword ptr [edi+12Ch], 0
		mov	dword ptr [edi+130h], 0
		mov	dword ptr [edi+134h], 0
		mov	dword ptr [edi+138h], 0
		mov	dword ptr [edi+13Ch], 0FFFFFFFFh
		call	_CRYPTO_add_lock
		add	esp, 30h
		mov	[edi+170h], ebx
		mov	eax, [ebx+1CCh]
		pop	esi
		test	eax, eax
		jz	short loc_24C3
		push	dword ptr [ebx+1C8h]
		push	eax
		call	_BUF_memdup
		add	esp, 8
		mov	[edi+148h], eax
		test	eax, eax
		jz	$err$23
		mov	eax, [ebx+1C8h]
		mov	[edi+144h], eax

loc_24C3:				; CODE XREF: _SSL_new+250j
		mov	eax, [ebx+1D4h]
		test	eax, eax
		jz	short loc_24F6
		push	dword ptr [ebx+1D0h]
		push	eax
		call	_BUF_memdup
		add	esp, 8
		mov	[edi+150h], eax
		test	eax, eax
		jz	$err$23
		mov	eax, [ebx+1D0h]
		mov	[edi+14Ch], eax

loc_24F6:				; CODE XREF: _SSL_new+283j
		mov	eax, [edi+0E4h]
		mov	dword ptr [edi+174h], 0
		cmp	dword ptr [eax+1C0h], 0
		jz	short loc_2562
		push	192h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	dword ptr [eax+1C4h]
		call	_CRYPTO_malloc
		add	esp, 0Ch
		mov	[edi+1D4h], eax
		test	eax, eax
		jz	$err$23
		mov	ecx, [edi+0E4h]
		push	dword ptr [ecx+1C4h] ; Size
		push	dword ptr [ecx+1C0h] ; Src
		push	eax		; Dst
		call	_memcpy
		mov	eax, [edi+0E4h]
		add	esp, 0Ch
		mov	eax, [eax+1C4h]
		mov	[edi+1D8h], eax

loc_2562:				; CODE XREF: _SSL_new+2C5j
		mov	dword ptr [edi+0ECh], 0
		mov	eax, [ebx]
		mov	[edi+8], eax
		push	edi
		mov	eax, [eax+4]
		call	eax
		add	esp, 4
		test	eax, eax
		jz	$err$23
		mov	eax, [ebx]
		xor	ecx, ecx
		push	edi
		cmp	dword ptr [eax+10h], offset _ssl_undefined_function
		setnz	cl
		mov	[edi+24h], ecx
		call	_SSL_clear
		lea	eax, [edi+0F0h]
		push	eax
		push	edi
		push	1
		call	_CRYPTO_new_ex_data
		mov	eax, [ebx+150h]
		add	esp, 10h
		mov	[edi+0DCh], eax
		mov	eax, [ebx+154h]
		mov	[edi+0E0h], eax
		mov	eax, edi
		pop	edi
		pop	ebx
		retn
_SSL_new	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 25C8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_peek
_SSL_peek	proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		cmp	dword ptr [ecx+20h], 0
		jnz	short loc_25F4
		push	409h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	114h
		push	10Eh
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_25F4:				; CODE XREF: _SSL_peek+8j
		test	byte ptr [ecx+30h], 2
		jz	short loc_25FD
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_25FD:				; CODE XREF: _SSL_peek+30j
		mov	eax, [ecx+8]
		mov	[esp+arg_0], ecx
		mov	eax, [eax+1Ch]
		jmp	eax
_SSL_peek	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 260Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_pending
_SSL_pending	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	ecx, [eax+8]
		mov	[esp+arg_0], eax
		mov	eax, [ecx+50h]
		jmp	eax
_SSL_pending	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 261Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_read
_SSL_read	proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		cmp	dword ptr [ecx+20h], 0
		jnz	short loc_2648
		push	3FBh
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	114h
		push	0DFh ; 'ß'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_2648:				; CODE XREF: _SSL_read+8j
		test	byte ptr [ecx+30h], 2
		jz	short loc_2658
		mov	dword ptr [ecx+18h], 1
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_2658:				; CODE XREF: _SSL_read+30j
		mov	eax, [ecx+8]
		mov	[esp+arg_0], ecx
		mov	eax, [eax+18h]
		jmp	eax
_SSL_read	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2664h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_renegotiate
_SSL_renegotiate proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		cmp	dword ptr [ecx+190h], 0
		jnz	short loc_267B
		mov	dword ptr [ecx+190h], 1

loc_267B:				; CODE XREF: _SSL_renegotiate+Bj
		mov	dword ptr [ecx+28h], 1
		mov	eax, [ecx+8]
		mov	[esp+arg_0], ecx
		mov	eax, [eax+28h]
		jmp	eax
_SSL_renegotiate endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2690h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_renegotiate_abbreviated
_SSL_renegotiate_abbreviated proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		cmp	dword ptr [ecx+190h], 0
		jnz	short loc_26A7
		mov	dword ptr [ecx+190h], 1

loc_26A7:				; CODE XREF: _SSL_renegotiate_abbreviated+Bj
		mov	dword ptr [ecx+28h], 0
		mov	eax, [ecx+8]
		mov	[esp+arg_0], ecx
		mov	eax, [eax+28h]
		jmp	eax
_SSL_renegotiate_abbreviated endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 26BCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_renegotiate_pending
_SSL_renegotiate_pending proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		xor	eax, eax
		cmp	[ecx+190h], eax
		setnz	al
		retn
_SSL_renegotiate_pending endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 26CCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_select_next_proto
_SSL_select_next_proto proc near

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	eax, 8
		call	__chkstk
		push	ebx
		push	ebp
		mov	ebp, [esp+10h+arg_10]
		xor	ecx, ecx
		push	esi
		push	edi
		mov	[esp+18h+var_4], ecx
		cmp	[esp+18h+arg_C], ecx
		jbe	loc_278C

loc_26EE:				; CODE XREF: _SSL_select_next_proto+BAj
		mov	eax, [esp+18h+arg_14]
		xor	edi, edi
		test	eax, eax
		jz	short loc_2773
		add	ecx, [esp+18h+arg_8]
		mov	[esp+18h+var_8], ecx
		mov	bh, [ecx]

loc_2702:				; CODE XREF: _SSL_select_next_proto+A1j
		mov	bl, [edi+ebp]
		cmp	bh, bl
		jnz	short loc_2763
		lea	eax, [ebp+1]
		movzx	esi, bh
		add	eax, edi
		lea	edx, [ecx+1]
		sub	esi, 4
		jb	short loc_272D
		nop	dword ptr [eax]

loc_271C:				; CODE XREF: _SSL_select_next_proto+5Fj
		mov	ecx, [edx]
		cmp	ecx, [eax]
		jnz	short loc_2732
		add	edx, 4
		add	eax, 4
		sub	esi, 4
		jnb	short loc_271C

loc_272D:				; CODE XREF: _SSL_select_next_proto+4Bj
		cmp	esi, 0FFFFFFFCh
		jz	short loc_27AB

loc_2732:				; CODE XREF: _SSL_select_next_proto+54j
		mov	cl, [edx]
		cmp	cl, [eax]
		jnz	short loc_275F
		cmp	esi, 0FFFFFFFDh
		jz	short loc_27AB
		mov	cl, [edx+1]
		cmp	cl, [eax+1]
		jnz	short loc_275F
		cmp	esi, 0FFFFFFFEh
		jz	short loc_27AB
		mov	cl, [edx+2]
		cmp	cl, [eax+2]
		jnz	short loc_275F
		cmp	esi, 0FFFFFFFFh
		jz	short loc_27AB
		mov	cl, [edx+3]
		cmp	cl, [eax+3]
		jz	short loc_27AB

loc_275F:				; CODE XREF: _SSL_select_next_proto+6Aj
					; _SSL_select_next_proto+77j ...
		mov	ecx, [esp+18h+var_8]

loc_2763:				; CODE XREF: _SSL_select_next_proto+3Bj
		inc	edi
		movzx	eax, bl
		add	edi, eax
		cmp	edi, [esp+18h+arg_14]
		jb	short loc_2702
		mov	ecx, [esp+18h+var_4]

loc_2773:				; CODE XREF: _SSL_select_next_proto+2Aj
		mov	eax, [esp+18h+arg_8]
		movzx	eax, byte ptr [ecx+eax]
		inc	ecx
		add	ecx, eax
		mov	[esp+18h+var_4], ecx
		cmp	ecx, [esp+18h+arg_C]
		jb	loc_26EE

loc_278C:				; CODE XREF: _SSL_select_next_proto+1Cj
		mov	eax, 2

$found$31:				; CODE XREF: _SSL_select_next_proto+ECj
		mov	ecx, [esp+18h+arg_0]
		lea	edx, [ebp+1]
		pop	edi
		pop	esi
		mov	[ecx], edx
		mov	ecx, [esp+10h+arg_4]
		mov	dl, [ebp+0]
		pop	ebp
		pop	ebx
		mov	[ecx], dl
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_27AB:				; CODE XREF: _SSL_select_next_proto+64j
					; _SSL_select_next_proto+6Fj ...
		mov	ebp, [esp+18h+var_4]
		mov	eax, 1
		add	ebp, [esp+18h+arg_8]
		jmp	short $found$31
_SSL_select_next_proto endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 27BCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set1_param
_SSL_set1_param	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		push	[esp+arg_4]
		push	dword ptr [eax+70h]
		call	_X509_VERIFY_PARAM_set1
		add	esp, 8
		retn
_SSL_set1_param	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 27D0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_SSL_CTX
_SSL_set_SSL_CTX proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		mov	ebx, [esp+4+arg_4]
		push	esi
		mov	esi, [esp+8+arg_0]
		push	edi
		mov	eax, [esi+0E4h]
		mov	edi, [esi+98h]
		cmp	eax, ebx
		jz	loc_29B1
		test	ebx, ebx
		jnz	short loc_27F9
		mov	ebx, [esi+170h]

loc_27F9:				; CODE XREF: _SSL_set_SSL_CTX+21j
		push	dword ptr [ebx+0B0h]
		call	_ssl_cert_dup
		add	esp, 4
		mov	[esi+98h], eax
		test	edi, edi
		jz	loc_28BA
		cmp	dword ptr [esi+24h], 0
		jz	short loc_2871
		mov	ecx, [edi+124h]
		mov	[eax+124h], ecx
		mov	ecx, [esi+98h]
		mov	eax, [edi+128h]
		mov	[ecx+128h], eax
		mov	eax, [edi+154h]
		mov	dword ptr [edi+124h], 0
		mov	ecx, [esi+98h]
		mov	[ecx+154h], eax
		mov	ecx, [esi+98h]
		mov	eax, [edi+158h]
		mov	[ecx+158h], eax
		mov	dword ptr [edi+154h], 0

loc_2871:				; CODE XREF: _SSL_set_SSL_CTX+49j
		mov	ecx, [esi+98h]
		mov	eax, [edi+170h]
		push	edi
		mov	[ecx+170h], eax
		mov	ecx, [esi+98h]
		mov	eax, [edi+174h]
		mov	[ecx+174h], eax
		mov	eax, [edi+178h]
		mov	dword ptr [edi+170h], 0
		mov	ecx, [esi+98h]
		mov	[ecx+178h], eax
		call	_ssl_cert_free
		add	esp, 4

loc_28BA:				; CODE XREF: _SSL_set_SSL_CTX+3Fj
		cmp	dword ptr [esi+9Ch], 20h ; ' '
		jbe	short loc_28DA
		push	offset ??_C@_0CM@NMJLCBPB@ssl?9?$DOsid_ctx_length?5?$DM?$DN?5sizeof?$CIss@ ; "ssl->sid_ctx_length <= sizeof(ssl->sid_"...
		push	0C7Fh
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_28DA:				; CODE XREF: _SSL_set_SSL_CTX+F1j
		mov	edi, [esi+0E4h]
		test	edi, edi
		jz	loc_297C
		mov	ecx, [esi+9Ch]
		cmp	ecx, [edi+0C4h]
		jnz	loc_297C
		add	edi, 0C8h ; 'È'
		lea	edx, [esi+0A0h]
		push	ebp
		sub	ecx, 4
		jb	short loc_2921
		nop	dword ptr [eax+00h]

loc_2910:				; CODE XREF: _SSL_set_SSL_CTX+14Fj
		mov	eax, [edx]
		cmp	eax, [edi]
		jnz	short loc_2926
		add	edx, 4
		add	edi, 4
		sub	ecx, 4
		jnb	short loc_2910

loc_2921:				; CODE XREF: _SSL_set_SSL_CTX+13Aj
		cmp	ecx, 0FFFFFFFCh
		jz	short loc_2953

loc_2926:				; CODE XREF: _SSL_set_SSL_CTX+144j
		mov	al, [edx]
		cmp	al, [edi]
		jnz	short loc_297B
		cmp	ecx, 0FFFFFFFDh
		jz	short loc_2953
		mov	al, [edx+1]
		cmp	al, [edi+1]
		jnz	short loc_297B
		cmp	ecx, 0FFFFFFFEh
		jz	short loc_2953
		mov	al, [edx+2]
		cmp	al, [edi+2]
		jnz	short loc_297B
		cmp	ecx, 0FFFFFFFFh
		jz	short loc_2953
		mov	al, [edx+3]
		cmp	al, [edi+3]
		jnz	short loc_297B

loc_2953:				; CODE XREF: _SSL_set_SSL_CTX+154j
					; _SSL_set_SSL_CTX+15Fj ...
		mov	eax, [ebx+0C4h]
		mov	[esi+9Ch], eax
		movups	xmm0, xmmword ptr [ebx+0C8h]
		movups	xmmword	ptr [esi+0A0h],	xmm0
		movups	xmm0, xmmword ptr [ebx+0D8h]
		movups	xmmword	ptr [esi+0B0h],	xmm0

loc_297B:				; CODE XREF: _SSL_set_SSL_CTX+15Aj
					; _SSL_set_SSL_CTX+167j ...
		pop	ebp

loc_297C:				; CODE XREF: _SSL_set_SSL_CTX+112j
					; _SSL_set_SSL_CTX+124j
		push	0C8Eh
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0Ch
		lea	eax, [ebx+60h]
		push	1
		push	eax
		call	_CRYPTO_add_lock
		mov	eax, [esi+0E4h]
		add	esp, 14h
		test	eax, eax
		jz	short loc_29A9
		push	eax
		call	_SSL_CTX_free
		add	esp, 4

loc_29A9:				; CODE XREF: _SSL_set_SSL_CTX+1CEj
		mov	[esi+0E4h], ebx
		mov	eax, ebx

loc_29B1:				; CODE XREF: _SSL_set_SSL_CTX+19j
		pop	edi
		pop	esi
		pop	ebx
		retn
_SSL_set_SSL_CTX endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 29B8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_accept_state
_SSL_set_accept_state proc near		; CODE XREF: _SSL_accept+Cp

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		push	esi
		mov	eax, [esi+8]
		mov	dword ptr [esi+24h], 1
		mov	dword ptr [esi+30h], 0
		mov	dword ptr [esi+34h], 6000h
		mov	eax, [eax+10h]
		mov	[esi+20h], eax
		call	_ssl_clear_cipher_ctx
		mov	eax, [esi+84h]
		add	esp, 4
		test	eax, eax
		jz	short loc_29F7
		push	eax
		call	_EVP_MD_CTX_destroy
		add	esp, 4

loc_29F7:				; CODE XREF: _SSL_set_accept_state+34j
		mov	dword ptr [esi+84h], 0
		mov	eax, [esi+90h]
		test	eax, eax
		jz	short loc_2A14
		push	eax
		call	_EVP_MD_CTX_destroy
		add	esp, 4

loc_2A14:				; CODE XREF: _SSL_set_accept_state+51j
		mov	dword ptr [esi+90h], 0
		pop	esi
		retn
_SSL_set_accept_state endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2A20h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl SSL_set_alpn_protos(int, void *Src, size_t Size)
		public _SSL_set_alpn_protos
_SSL_set_alpn_protos proc near

arg_0		= dword	ptr  4
Src		= dword	ptr  8
Size		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		mov	eax, [esi+1D4h]
		test	eax, eax
		jz	short loc_2A39
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_2A39:				; CODE XREF: _SSL_set_alpn_protos+Ej
		mov	edi, [esp+8+Size]
		push	6F4h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	edi
		call	_CRYPTO_malloc
		add	esp, 0Ch
		mov	[esi+1D4h], eax
		test	eax, eax
		jnz	short loc_2A62
		pop	edi
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_2A62:				; CODE XREF: _SSL_set_alpn_protos+38j
		push	edi		; Size
		push	[esp+0Ch+Src]	; Src
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	[esi+1D8h], edi
		xor	eax, eax
		pop	edi
		pop	esi
		retn
_SSL_set_alpn_protos endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2A7Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_bio
_SSL_set_bio	proc near		; CODE XREF: _SSL_set_fd+48p
					; _SSL_set_rfd+3Ap ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		mov	ecx, [esi+14h]
		test	ecx, ecx
		jz	short loc_2A9D
		mov	eax, [esi+10h]
		cmp	eax, ecx
		jnz	short loc_2A9D
		mov	eax, [eax+24h]
		mov	[esi+10h], eax
		mov	dword ptr [ecx+24h], 0

loc_2A9D:				; CODE XREF: _SSL_set_bio+Bj
					; _SSL_set_bio+12j
		mov	eax, [esi+0Ch]
		mov	edi, [esp+8+arg_4]
		test	eax, eax
		jz	short loc_2AB5
		cmp	eax, edi
		jz	short loc_2AB5
		push	eax
		call	_BIO_free_all
		add	esp, 4

loc_2AB5:				; CODE XREF: _SSL_set_bio+2Aj
					; _SSL_set_bio+2Ej
		mov	eax, [esi+10h]
		test	eax, eax
		jz	short loc_2ADD
		push	ebx
		mov	ebx, [esp+0Ch+arg_8]
		cmp	eax, ebx
		jz	short loc_2AD3
		cmp	[esi+0Ch], eax
		jz	short loc_2AD3
		push	eax
		call	_BIO_free_all
		add	esp, 4

loc_2AD3:				; CODE XREF: _SSL_set_bio+47j
					; _SSL_set_bio+4Cj
		mov	[esi+10h], ebx
		pop	ebx
		mov	[esi+0Ch], edi
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_2ADD:				; CODE XREF: _SSL_set_bio+3Ej
		mov	eax, [esp+8+arg_8]
		mov	[esi+0Ch], edi
		pop	edi
		mov	[esi+10h], eax
		pop	esi
		retn
_SSL_set_bio	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2AECh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_cert_cb
_SSL_set_cert_cb proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	[esp+arg_8]
		mov	eax, [esp+4+arg_0]
		push	[esp+4+arg_4]
		push	dword ptr [eax+98h]
		call	_ssl_cert_set_cert_cb
		add	esp, 0Ch
		retn
_SSL_set_cert_cb endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2B08h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_cipher_list
_SSL_set_cipher_list proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		push	dword ptr [ecx+98h]
		lea	eax, [ecx+78h]
		push	[esp+4+arg_4]
		push	eax
		lea	eax, [ecx+74h]
		push	eax
		mov	eax, [ecx+0E4h]
		push	dword ptr [eax]
		call	_ssl_create_cipher_list
		add	esp, 14h
		test	eax, eax
		jz	short loc_2B5D
		push	eax
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jnz	short loc_2B60
		push	578h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0B9h ; '¹'
		push	10Fh
		push	14h
		call	_ERR_put_error
		add	esp, 14h

loc_2B5D:				; CODE XREF: _SSL_set_cipher_list+28j
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_2B60:				; CODE XREF: _SSL_set_cipher_list+35j
		mov	eax, 1
		retn
_SSL_set_cipher_list endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2B68h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_connect_state
_SSL_set_connect_state proc near	; CODE XREF: _SSL_connect+Cp

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		push	esi
		mov	eax, [esi+8]
		mov	dword ptr [esi+24h], 0
		mov	dword ptr [esi+30h], 0
		mov	dword ptr [esi+34h], 5000h
		mov	eax, [eax+14h]
		mov	[esi+20h], eax
		call	_ssl_clear_cipher_ctx
		mov	eax, [esi+84h]
		add	esp, 4
		test	eax, eax
		jz	short loc_2BA7
		push	eax
		call	_EVP_MD_CTX_destroy
		add	esp, 4

loc_2BA7:				; CODE XREF: _SSL_set_connect_state+34j
		mov	dword ptr [esi+84h], 0
		mov	eax, [esi+90h]
		test	eax, eax
		jz	short loc_2BC4
		push	eax
		call	_EVP_MD_CTX_destroy
		add	esp, 4

loc_2BC4:				; CODE XREF: _SSL_set_connect_state+51j
		mov	dword ptr [esi+90h], 0
		pop	esi
		retn
_SSL_set_connect_state endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2BD0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_debug
_SSL_set_debug	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+0E8h], ecx
		retn
_SSL_set_debug	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2BE0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_ex_data
_SSL_set_ex_data proc near

arg_0		= dword	ptr  4

		add	[esp+arg_0], 0F0h ; 'ð'
		jmp	_CRYPTO_set_ex_data
_SSL_set_ex_data endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2BF0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_fd
_SSL_set_fd	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		call	_BIO_s_socket
		push	eax
		call	_BIO_new
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jnz	short loc_2C24
		push	2E4h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	7
		push	0C0h ; 'À'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_2C24:				; CODE XREF: _SSL_set_fd+13j
		push	[esp+4+arg_4]
		push	0
		push	68h ; 'h'
		push	esi
		call	_BIO_int_ctrl
		push	esi
		push	esi
		push	[esp+1Ch+arg_0]
		call	_SSL_set_bio
		add	esp, 1Ch
		mov	eax, 1

$err$5:
		pop	esi
		retn
_SSL_set_fd	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2C48h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_generate_session_id
_SSL_set_generate_session_id proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	1DBh
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	10h
		push	9
		call	_CRYPTO_lock
		mov	eax, [esp+10h+arg_0]
		mov	ecx, [esp+10h+arg_4]
		push	1DDh
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	10h
		push	0Ah
		mov	[eax+0C4h], ecx
		call	_CRYPTO_lock
		add	esp, 20h
		mov	eax, 1
		retn
_SSL_set_generate_session_id endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2C88h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_info_callback
_SSL_set_info_callback proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+0D0h], ecx
		retn
_SSL_set_info_callback endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2C98h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_msg_callback
_SSL_set_msg_callback proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+64h], ecx
		retn
_SSL_set_msg_callback endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2CA4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_psk_client_callback
_SSL_set_psk_client_callback proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+0DCh], ecx
		retn
_SSL_set_psk_client_callback endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2CB4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_psk_server_callback
_SSL_set_psk_server_callback proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+0E0h], ecx
		retn
_SSL_set_psk_server_callback endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2CC4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_purpose
_SSL_set_purpose proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		push	[esp+arg_4]
		push	dword ptr [eax+70h]
		call	_X509_VERIFY_PARAM_set_purpose
		add	esp, 8
		retn
_SSL_set_purpose endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2CD8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_quiet_shutdown
_SSL_set_quiet_shutdown	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+2Ch], ecx
		retn
_SSL_set_quiet_shutdown	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2CE4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_read_ahead
_SSL_set_read_ahead proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+60h], ecx
		retn
_SSL_set_read_ahead endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2CF0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_rfd
_SSL_set_rfd	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		mov	eax, [esi+10h]
		test	eax, eax
		jz	short loc_2D3A
		push	eax
		call	_BIO_method_type
		add	esp, 4
		cmp	eax, 505h
		jnz	short loc_2D3A
		push	0
		push	0
		push	69h ; 'i'
		push	dword ptr [esi+10h]
		call	_BIO_ctrl
		add	esp, 10h
		cmp	eax, [esp+8+arg_4]
		jnz	short loc_2D3A
		mov	eax, [esi+10h]
		push	eax
		push	eax
		push	esi
		call	_SSL_set_bio
		add	esp, 0Ch
		mov	eax, 1
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_2D3A:				; CODE XREF: _SSL_set_rfd+Bj
					; _SSL_set_rfd+1Bj ...
		call	_BIO_s_socket
		push	eax
		call	_BIO_new
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jnz	short loc_2D6E
		push	30Eh
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	7
		push	0C2h ; 'Â'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_2D6E:				; CODE XREF: _SSL_set_rfd+5Cj
		push	[esp+8+arg_4]
		push	0
		push	68h ; 'h'
		push	edi
		call	_BIO_int_ctrl
		push	dword ptr [esi+10h]
		push	edi
		push	esi
		call	_SSL_set_bio
		add	esp, 1Ch
		mov	eax, 1

$err$14:
		pop	edi
		pop	esi
		retn
_SSL_set_rfd	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2D94h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl SSL_set_session_id_context(int, void *Src, size_t	Size)
		public _SSL_set_session_id_context
_SSL_set_session_id_context proc near	; CODE XREF: _SSL_dup+9Fp

arg_0		= dword	ptr  4
Src		= dword	ptr  8
Size		= dword	ptr  0Ch

		mov	ecx, [esp+Size]
		cmp	ecx, 20h ; ' '
		jbe	short loc_2DBE
		push	1C8h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	111h
		push	0DAh ; 'Ú'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_2DBE:				; CODE XREF: _SSL_set_session_id_context+7j
		mov	eax, [esp+arg_0]
		push	ecx		; Size
		push	[esp+4+Src]	; Src
		mov	[eax+9Ch], ecx
		add	eax, 0A0h ; ' '
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, 1
		retn
_SSL_set_session_id_context endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2DE4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_shutdown
_SSL_set_shutdown proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+30h], ecx
		retn
_SSL_set_shutdown endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2DF0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_ssl_method
_SSL_set_ssl_method proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		push	esi
		mov	esi, [esp+8+arg_0]
		or	ebx, 0FFFFFFFFh
		push	edi
		mov	edi, [esp+0Ch+arg_4]
		mov	ecx, [esi+8]
		lea	edx, [ebx+2]
		cmp	ecx, edi
		jz	short loc_2E51
		mov	eax, [esi+20h]
		test	eax, eax
		jz	short loc_2E17
		xor	ebx, ebx
		cmp	eax, [ecx+14h]
		setz	bl

loc_2E17:				; CODE XREF: _SSL_set_ssl_method+1Dj
		mov	eax, [ecx]
		cmp	eax, [edi]
		jnz	short loc_2E22
		mov	[esi+8], edi
		jmp	short loc_2E36
; ---------------------------------------------------------------------------

loc_2E22:				; CODE XREF: _SSL_set_ssl_method+2Bj
		mov	eax, [ecx+0Ch]
		push	esi
		call	eax
		mov	[esi+8], edi
		mov	eax, [edi+4]
		push	esi
		call	eax
		add	esp, 8
		mov	edx, eax

loc_2E36:				; CODE XREF: _SSL_set_ssl_method+30j
		cmp	ebx, 1
		jnz	short loc_2E47
		mov	ecx, [edi+14h]
		mov	eax, edx
		pop	edi
		mov	[esi+20h], ecx
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_2E47:				; CODE XREF: _SSL_set_ssl_method+49j
		test	ebx, ebx
		jnz	short loc_2E51
		mov	eax, [edi+10h]
		mov	[esi+20h], eax

loc_2E51:				; CODE XREF: _SSL_set_ssl_method+16j
					; _SSL_set_ssl_method+59j
		pop	edi
		pop	esi
		mov	eax, edx
		pop	ebx
		retn
_SSL_set_ssl_method endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E58h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_state
_SSL_set_state	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+34h], ecx
		retn
_SSL_set_state	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E64h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_tmp_dh_callback
_SSL_set_tmp_dh_callback proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		push	[esp+arg_4]
		push	6
		mov	ecx, [eax+8]
		push	eax
		mov	eax, [ecx+6Ch]
		call	eax
		add	esp, 0Ch
		retn
_SSL_set_tmp_dh_callback endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E7Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_tmp_ecdh_callback
_SSL_set_tmp_ecdh_callback proc	near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		push	[esp+arg_4]
		push	7
		mov	ecx, [eax+8]
		push	eax
		mov	eax, [ecx+6Ch]
		call	eax
		add	esp, 0Ch
		retn
_SSL_set_tmp_ecdh_callback endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E94h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_tmp_rsa_callback
_SSL_set_tmp_rsa_callback proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		push	[esp+arg_4]
		push	5
		mov	ecx, [eax+8]
		push	eax
		mov	eax, [ecx+6Ch]
		call	eax
		add	esp, 0Ch
		retn
_SSL_set_tmp_rsa_callback endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2EACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_trust
_SSL_set_trust	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		push	[esp+arg_4]
		push	dword ptr [eax+70h]
		call	_X509_VERIFY_PARAM_set_trust
		add	esp, 8
		retn
_SSL_set_trust	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2EC0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_verify
_SSL_set_verify	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		mov	eax, [esp+arg_4]
		mov	[ecx+0C8h], eax
		mov	eax, [esp+arg_8]
		test	eax, eax
		jz	short locret_2EDC
		mov	[ecx+0CCh], eax

locret_2EDC:				; CODE XREF: _SSL_set_verify+14j
		retn
_SSL_set_verify	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2EE0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_verify_depth
_SSL_set_verify_depth proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		push	[esp+arg_4]
		push	dword ptr [eax+70h]
		call	_X509_VERIFY_PARAM_set_depth
		add	esp, 8
		retn
_SSL_set_verify_depth endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2EF4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_verify_result
_SSL_set_verify_result proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+0ECh], ecx
		retn
_SSL_set_verify_result endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2F04h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_set_wfd
_SSL_set_wfd	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		mov	eax, [esi+0Ch]
		test	eax, eax
		jz	short loc_2F4E
		push	eax
		call	_BIO_method_type
		add	esp, 4
		cmp	eax, 505h
		jnz	short loc_2F4E
		push	0
		push	0
		push	69h ; 'i'
		push	dword ptr [esi+0Ch]
		call	_BIO_ctrl
		add	esp, 10h
		cmp	eax, [esp+8+arg_4]
		jnz	short loc_2F4E
		mov	eax, [esi+0Ch]
		push	eax
		push	eax
		push	esi
		call	_SSL_set_bio
		add	esp, 0Ch
		mov	eax, 1
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_2F4E:				; CODE XREF: _SSL_set_wfd+Bj
					; _SSL_set_wfd+1Bj ...
		call	_BIO_s_socket
		push	eax
		call	_BIO_new
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jnz	short loc_2F82
		push	2F8h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	7
		push	0C4h ; 'Ä'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_2F82:				; CODE XREF: _SSL_set_wfd+5Cj
		push	[esp+8+arg_4]
		push	0
		push	68h ; 'h'
		push	edi
		call	_BIO_int_ctrl
		push	edi
		push	dword ptr [esi+0Ch]
		push	esi
		call	_SSL_set_bio
		add	esp, 1Ch
		mov	eax, 1

$err$14_0:
		pop	edi
		pop	esi
		retn
_SSL_set_wfd	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2FA8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_shutdown
_SSL_shutdown	proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		cmp	dword ptr [ecx+20h], 0
		jnz	short loc_2FD4
		push	42Ch
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	114h
		push	0E0h ; 'à'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_2FD4:				; CODE XREF: _SSL_shutdown+8j
		test	dword ptr [ecx+34h], 3000h
		jnz	short loc_2FE9
		mov	eax, [ecx+8]
		mov	[esp+arg_0], ecx
		mov	eax, [eax+24h]
		jmp	eax
; ---------------------------------------------------------------------------

loc_2FE9:				; CODE XREF: _SSL_shutdown+33j
		push	433h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	197h
		push	0E0h ; 'à'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		retn
_SSL_shutdown	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 300Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_state
_SSL_state	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+34h]
		retn
_SSL_state	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3014h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_use_psk_identity_hint
_SSL_use_psk_identity_hint proc	near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jnz	short loc_3021
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_3021:				; CODE XREF: _SSL_use_psk_identity_hint+7j
		mov	edx, [esi+0C0h]
		test	edx, edx
		jnz	short loc_3030
		lea	eax, [edx+1]
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_3030:				; CODE XREF: _SSL_use_psk_identity_hint+15j
		push	edi
		mov	edi, [esp+8+arg_4]
		test	edi, edi
		jz	short loc_3079
		mov	ecx, edi
		push	ebx
		lea	ebx, [ecx+1]
		nop	dword ptr [eax+eax+00h]

loc_3044:				; CODE XREF: _SSL_use_psk_identity_hint+35j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_3044
		sub	ecx, ebx
		pop	ebx
		cmp	ecx, 80h ; ''
		jbe	short loc_3079
		push	0D68h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	92h ; ''
		push	111h
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_3079:				; CODE XREF: _SSL_use_psk_identity_hint+23j
					; _SSL_use_psk_identity_hint+40j
		mov	eax, [edx+8Ch]
		test	eax, eax
		jz	short loc_308C
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_308C:				; CODE XREF: _SSL_use_psk_identity_hint+6Dj
		test	edi, edi
		jz	short loc_30B9
		push	edi
		call	_BUF_strdup
		mov	ecx, [esi+0C0h]
		add	esp, 4
		mov	[ecx+8Ch], eax
		mov	eax, [esi+0C0h]
		cmp	dword ptr [eax+8Ch], 0
		jnz	short loc_30C9
		pop	edi
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_30B9:				; CODE XREF: _SSL_use_psk_identity_hint+7Aj
		mov	eax, [esi+0C0h]
		mov	dword ptr [eax+8Ch], 0

loc_30C9:				; CODE XREF: _SSL_use_psk_identity_hint+9Ej
		pop	edi
		mov	eax, 1
		pop	esi
		retn
_SSL_use_psk_identity_hint endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 30D4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_version
_SSL_version	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax]
		retn
_SSL_version	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 30DCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_want
_SSL_want	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+18h]
		retn
_SSL_want	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 30E4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SSL_write
_SSL_write	proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		cmp	dword ptr [ecx+20h], 0
		jnz	short loc_3110
		push	416h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	114h
		push	0D0h ; 'Ð'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_3110:				; CODE XREF: _SSL_write+8j
		test	byte ptr [ecx+30h], 1
		jz	short loc_313F
		push	41Ch
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0CFh ; 'Ï'
		push	0D0h ; 'Ð'
		push	14h
		mov	dword ptr [ecx+18h], 1
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_313F:				; CODE XREF: _SSL_write+30j
		mov	eax, [ecx+8]
		mov	[esp+arg_0], ecx
		mov	eax, [eax+20h]
		jmp	eax
_SSL_write	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 314Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_bad_method
_ssl_bad_method	proc near
		push	0B19h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	42h ; 'B'
		push	0A0h ; ' '
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
_ssl_bad_method	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 316Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssl_buf_freelist_free proc near	; CODE XREF: _SSL_CTX_free+13Fp
					; _SSL_CTX_free+152p

arg_0		= dword	ptr  4

		push	edi
		mov	edi, [esp+4+arg_0]
		mov	eax, [edi+8]
		test	eax, eax
		jz	short loc_318E
		push	esi
		nop	dword ptr [eax]

loc_317C:				; CODE XREF: _ssl_buf_freelist_free+1Fj
		mov	esi, [eax]
		push	eax
		call	_CRYPTO_free
		add	esp, 4
		mov	eax, esi
		test	esi, esi
		jnz	short loc_317C
		pop	esi

loc_318E:				; CODE XREF: _ssl_buf_freelist_free+Aj
		push	edi
		call	_CRYPTO_free
		add	esp, 4
		pop	edi
		retn
_ssl_buf_freelist_free endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 319Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_bytes_to_cipher_list
_ssl_bytes_to_cipher_list proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	esi
		push	edi
		mov	eax, [ebx+58h]
		test	eax, eax
		jz	short loc_31B4
		mov	dword ptr [eax+418h], 0

loc_31B4:				; CODE XREF: _ssl_bytes_to_cipher_list+Cj
		mov	eax, [ebx+8]
		push	0
		push	0
		mov	eax, [eax+4Ch]
		call	eax
		mov	edi, eax
		add	esp, 8
		test	edi, edi
		jz	loc_33DA
		mov	esi, [esp+0Ch+arg_8]
		mov	eax, esi
		cdq
		idiv	edi
		test	edx, edx
		jnz	loc_33DA
		push	ebp
		mov	ebp, [esp+10h+arg_C]
		test	ebp, ebp
		jz	short loc_3243
		mov	ebp, [ebp+0]
		test	ebp, ebp
		jz	short loc_3243
		push	ebp
		call	_sk_zero
		add	esp, 4

loc_31F7:				; CODE XREF: _ssl_bytes_to_cipher_list+B0j
		mov	eax, [ebx+98h]
		mov	eax, [eax+154h]
		test	eax, eax
		jz	short loc_3210
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_3210:				; CODE XREF: _ssl_bytes_to_cipher_list+69j
		push	esi
		mov	esi, [esp+14h+arg_4]
		push	esi
		call	_BUF_memdup
		mov	ecx, [ebx+98h]
		add	esp, 8
		mov	[ecx+154h], eax
		mov	eax, [ebx+98h]
		cmp	dword ptr [eax+154h], 0
		jnz	short loc_3270
		push	603h
		jmp	loc_33A3
; ---------------------------------------------------------------------------

loc_3243:				; CODE XREF: _ssl_bytes_to_cipher_list+49j
					; _ssl_bytes_to_cipher_list+50j
		call	_sk_new_null
		mov	ebp, eax
		test	ebp, ebp
		jnz	short loc_31F7
		push	5F7h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	41h ; 'A'
		push	0A1h ; '¡'
		push	14h
		call	_ERR_put_error
		add	esp, 14h

loc_3269:				; CODE XREF: _ssl_bytes_to_cipher_list+228j
		pop	ebp
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_3270:				; CODE XREF: _ssl_bytes_to_cipher_list+9Bj
		mov	ecx, [esp+10h+arg_8]
		mov	[eax+158h], ecx
		mov	[esp+10h+arg_0], 0
		test	ecx, ecx
		jle	loc_3330
		xchg	ax, ax

loc_328C:				; CODE XREF: _ssl_bytes_to_cipher_list+18Ej
		mov	eax, [ebx+58h]
		test	eax, eax
		jz	short loc_32C6
		cmp	edi, 3
		jnz	short loc_329D
		cmp	byte ptr [esi],	0
		jnz	short loc_32F8

loc_329D:				; CODE XREF: _ssl_bytes_to_cipher_list+FAj
		cmp	byte ptr [edi+esi-2], 0
		jnz	short loc_32C6
		cmp	byte ptr [edi+esi-1], 0FFh
		jnz	short loc_32C6
		cmp	dword ptr [ebx+190h], 0
		jnz	loc_3341
		mov	dword ptr [eax+418h], 1
		add	esi, edi
		jmp	short loc_331E
; ---------------------------------------------------------------------------

loc_32C6:				; CODE XREF: _ssl_bytes_to_cipher_list+F5j
					; _ssl_bytes_to_cipher_list+106j ...
		cmp	edi, 3
		jnz	short loc_32D0
		cmp	byte ptr [esi],	0
		jnz	short loc_32F8

loc_32D0:				; CODE XREF: _ssl_bytes_to_cipher_list+12Dj
		cmp	byte ptr [edi+esi-2], 56h ; 'V'
		jnz	short loc_32F8
		cmp	byte ptr [edi+esi-1], 0
		jnz	short loc_32F8
		mov	eax, [ebx+8]
		push	0
		push	0
		push	77h ; 'w'
		mov	eax, [eax+40h]
		push	ebx
		call	eax
		add	esp, 10h
		test	eax, eax
		jz	short loc_336B
		add	esi, edi
		jmp	short loc_331A
; ---------------------------------------------------------------------------

loc_32F8:				; CODE XREF: _ssl_bytes_to_cipher_list+FFj
					; _ssl_bytes_to_cipher_list+132j ...
		push	esi
		push	ebx
		call	_ssl_get_cipher_by_char
		add	esp, 8
		add	esi, edi
		test	eax, eax
		jz	short loc_331A
		push	eax
		push	ebp
		call	_sk_push
		add	esp, 8
		test	eax, eax
		jz	loc_339E

loc_331A:				; CODE XREF: _ssl_bytes_to_cipher_list+15Aj
					; _ssl_bytes_to_cipher_list+16Aj
		mov	ecx, [esp+10h+arg_8]

loc_331E:				; CODE XREF: _ssl_bytes_to_cipher_list+128j
		mov	eax, [esp+10h+arg_0]
		add	eax, edi
		mov	[esp+10h+arg_0], eax
		cmp	eax, ecx
		jl	loc_328C

loc_3330:				; CODE XREF: _ssl_bytes_to_cipher_list+E8j
		mov	eax, [esp+10h+arg_C]
		test	eax, eax
		jz	short loc_333A
		mov	[eax], ebp

loc_333A:				; CODE XREF: _ssl_bytes_to_cipher_list+19Aj
		mov	eax, ebp
		pop	ebp
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_3341:				; CODE XREF: _ssl_bytes_to_cipher_list+116j
		push	610h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	159h
		push	0A1h ; '¡'
		push	14h
		call	_ERR_put_error
		push	28h ; '('
		push	2
		push	ebx
		call	_ssl3_send_alert
		add	esp, 20h
		jmp	short $err$67
; ---------------------------------------------------------------------------

loc_336B:				; CODE XREF: _ssl_bytes_to_cipher_list+156j
		push	627h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	175h
		push	0A1h ; '¡'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		cmp	dword ptr [ebx+58h], 0
		jz	short $err$67
		push	56h ; 'V'
		push	2
		push	ebx
		call	_ssl3_send_alert
		add	esp, 0Ch
		jmp	short $err$67
; ---------------------------------------------------------------------------

loc_339E:				; CODE XREF: _ssl_bytes_to_cipher_list+178j
		push	635h

loc_33A3:				; CODE XREF: _ssl_bytes_to_cipher_list+A2j
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	41h ; 'A'
		push	0A1h ; '¡'
		push	14h
		call	_ERR_put_error
		add	esp, 14h

$err$67:				; CODE XREF: _ssl_bytes_to_cipher_list+1CDj
					; _ssl_bytes_to_cipher_list+1F1j ...
		mov	eax, [esp+10h+arg_C]
		test	eax, eax
		jz	short loc_33CA
		cmp	dword ptr [eax], 0
		jnz	loc_3269

loc_33CA:				; CODE XREF: _ssl_bytes_to_cipher_list+223j
		push	ebp
		call	_sk_free
		add	esp, 4
		xor	eax, eax
		pop	ebp
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_33DA:				; CODE XREF: _ssl_bytes_to_cipher_list+2Bj
					; _ssl_bytes_to_cipher_list+3Cj
		push	5F1h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	97h ; ''
		push	0A1h ; '¡'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		retn
_ssl_bytes_to_cipher_list endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3400h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_check_srvr_ecc_cert_and_alg
_ssl_check_srvr_ecc_cert_and_alg proc near

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 0Ch
		call	__chkstk
		push	ebx
		push	ebp
		mov	ebp, [esp+14h+arg_4]
		mov	[esp+14h+var_8], 0
		mov	[esp+14h+var_C], 0
		push	edi
		mov	eax, [ebp+58h]
		mov	edi, [esp+18h+arg_0]
		mov	eax, [eax+344h]
		test	byte ptr [eax+20h], 2
		mov	ebx, [eax+0Ch]
		mov	ecx, [eax+10h]
		mov	[esp+18h+arg_4], ebx
		mov	[esp+18h+var_4], ecx
		jz	short loc_3474
		push	edi
		call	_X509_get_pubkey
		mov	ebx, eax
		add	esp, 4
		test	ebx, ebx
		jz	loc_34DA
		push	esi
		push	ebx
		call	_EVP_PKEY_bits
		push	ebx
		mov	esi, eax
		call	_EVP_PKEY_free
		add	esp, 8
		cmp	esi, 0A3h ; '£'
		pop	esi
		jg	short loc_34DA
		mov	ebx, [esp+18h+arg_4]

loc_3474:				; CODE XREF: _ssl_check_srvr_ecc_cert_and_alg+40j
		push	0
		push	0FFFFFFFFh
		push	edi
		call	_X509_check_purpose
		mov	eax, [edi+4]
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_34A7
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_34A7
		push	eax
		call	_OBJ_obj2nid
		lea	ecx, [esp+1Ch+var_C]
		push	ecx
		lea	ecx, [esp+20h+var_8]
		push	ecx
		push	eax
		call	_OBJ_find_sigid_algs
		add	esp, 10h

loc_34A7:				; CODE XREF: _ssl_check_srvr_ecc_cert_and_alg+86j
					; _ssl_check_srvr_ecc_cert_and_alg+8Cj
		test	bl, 60h
		jz	loc_355A
		test	byte ptr [edi+28h], 2
		jz	short loc_34E3
		test	byte ptr [edi+2Ch], 8
		jnz	short loc_34E3
		push	9B9h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	13Dh

loc_34CB:				; CODE XREF: _ssl_check_srvr_ecc_cert_and_alg+11Cj
					; _ssl_check_srvr_ecc_cert_and_alg+155j ...
		push	117h
		push	14h
		call	_ERR_put_error
		add	esp, 14h

loc_34DA:				; CODE XREF: _ssl_check_srvr_ecc_cert_and_alg+4Fj
					; _ssl_check_srvr_ecc_cert_and_alg+6Ej
		pop	edi
		pop	ebp
		xor	eax, eax
		pop	ebx
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_34E3:				; CODE XREF: _ssl_check_srvr_ecc_cert_and_alg+B4j
					; _ssl_check_srvr_ecc_cert_and_alg+BAj
		mov	ecx, [esp+18h+var_C]
		test	bl, 40h
		jz	short loc_351E
		mov	edx, [ebp+0]
		mov	eax, edx
		and	eax, 0FFFFFF00h
		cmp	eax, 300h
		jnz	short loc_3505
		cmp	edx, 303h
		jge	short loc_351E

loc_3505:				; CODE XREF: _ssl_check_srvr_ecc_cert_and_alg+FBj
		cmp	ecx, 198h
		jz	short loc_351E
		push	9C0h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	143h
		jmp	short loc_34CB
; ---------------------------------------------------------------------------

loc_351E:				; CODE XREF: _ssl_check_srvr_ecc_cert_and_alg+EAj
					; _ssl_check_srvr_ecc_cert_and_alg+103j ...
		test	bl, 20h
		jz	short loc_355A
		mov	edx, [ebp+0]
		mov	eax, edx
		and	eax, 0FFFFFF00h
		cmp	eax, 300h
		jnz	short loc_353C
		cmp	edx, 303h
		jge	short loc_355A

loc_353C:				; CODE XREF: _ssl_check_srvr_ecc_cert_and_alg+132j
		cmp	ecx, 6
		jz	short loc_355A
		cmp	ecx, 13h
		jz	short loc_355A
		push	9C9h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	142h
		jmp	loc_34CB
; ---------------------------------------------------------------------------

loc_355A:				; CODE XREF: _ssl_check_srvr_ecc_cert_and_alg+AAj
					; _ssl_check_srvr_ecc_cert_and_alg+121j ...
		test	byte ptr [esp+18h+var_4], 40h
		jz	short loc_3581
		test	byte ptr [edi+28h], 2
		jz	short loc_3581
		test	byte ptr [edi+2Ch], 80h
		jnz	short loc_3581
		push	9D2h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	13Eh
		jmp	loc_34CB
; ---------------------------------------------------------------------------

loc_3581:				; CODE XREF: _ssl_check_srvr_ecc_cert_and_alg+15Fj
					; _ssl_check_srvr_ecc_cert_and_alg+165j ...
		pop	edi
		pop	ebp
		mov	eax, 1
		pop	ebx
		add	esp, 0Ch
		retn
_ssl_check_srvr_ecc_cert_and_alg endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3590h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_cipher_id_cmp
_ssl_cipher_id_cmp proc	near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [eax+8]
		mov	eax, [esp+arg_4]
		sub	ecx, [eax+8]
		jnz	short loc_35A3
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_35A3:				; CODE XREF: _ssl_cipher_id_cmp+Ej
		xor	eax, eax
		test	ecx, ecx
		setnle	al
		lea	eax, ds:0FFFFFFFFh[eax*2]
		retn
_ssl_cipher_id_cmp endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 35B4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssl_cipher_id_cmp_BSEARCH_CMP_FN proc near ; DATA XREF: _OBJ_bsearch_ssl_cipher_ido

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [eax+8]
		mov	eax, [esp+arg_4]
		sub	ecx, [eax+8]
		jnz	short loc_35C7
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_35C7:				; CODE XREF: _ssl_cipher_id_cmp_BSEARCH_CMP_FN+Ej
		xor	eax, eax
		test	ecx, ecx
		setnle	al
		lea	eax, ds:0FFFFFFFFh[eax*2]
		retn
_ssl_cipher_id_cmp_BSEARCH_CMP_FN endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 35D8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_cipher_list_to_bytes
_ssl_cipher_list_to_bytes proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, 4
		call	__chkstk
		push	ebx
		push	ebp
		push	edi
		mov	edi, [esp+10h+arg_0]
		xor	eax, eax
		push	edi
		cmp	[edi+190h], eax
		mov	ebx, [edi+98h]
		setz	al
		mov	[esp+14h+var_4], eax
		call	_ssl_set_client_disabled
		mov	ebp, [esp+14h+arg_4]
		add	esp, 4
		test	ebp, ebp
		jnz	short loc_3616
		pop	edi
		pop	ebp
		xor	eax, eax
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_3616:				; CODE XREF: _ssl_cipher_list_to_bytes+35j
		cmp	[esp+10h+arg_C], 0
		push	esi
		mov	esi, [esp+14h+arg_8]
		mov	[esp+14h+arg_4], esi
		jnz	short loc_3630
		mov	eax, [edi+8]
		mov	eax, [eax+4Ch]
		mov	[esp+14h+arg_C], eax

loc_3630:				; CODE XREF: _ssl_cipher_list_to_bytes+4Cj
		push	ebp
		xor	edi, edi
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jle	loc_36C9
		nop	dword ptr [eax+eax+00h]

loc_3648:				; CODE XREF: _ssl_cipher_list_to_bytes+ABj
		push	edi
		push	ebp
		call	_sk_value
		mov	ecx, eax
		add	esp, 8
		mov	eax, [ecx+1Ch]
		test	[ebx+18h], eax
		jnz	short loc_3677
		mov	eax, [ecx+0Ch]
		test	[ebx+8], eax
		jnz	short loc_3677
		mov	eax, [ecx+10h]
		test	[ebx+0Ch], eax
		jnz	short loc_3677
		push	esi
		push	ecx
		call	[esp+1Ch+arg_C]
		add	esp, 8
		add	esi, eax

loc_3677:				; CODE XREF: _ssl_cipher_list_to_bytes+82j
					; _ssl_cipher_list_to_bytes+8Aj ...
		push	ebp
		inc	edi
		call	_sk_num
		add	esp, 4
		cmp	edi, eax
		jl	short loc_3648
		mov	edi, [esp+14h+arg_4]
		cmp	esi, edi
		jz	short loc_36CB
		cmp	[esp+14h+var_4], 0
		mov	ebx, [esp+14h+arg_C]
		jz	short loc_36A5
		push	esi
		push	offset ?scsv@?5??ssl_cipher_list_to_bytes@@9@9 ; `ssl_cipher_list_to_bytes'::`6'::scsv
		call	ebx
		add	esp, 8
		add	esi, eax

loc_36A5:				; CODE XREF: _ssl_cipher_list_to_bytes+BEj
		mov	eax, [esp+14h+arg_0]
		test	byte ptr [eax+104h], 80h
		jz	short loc_36CB
		push	esi
		push	offset ?scsv@?6??ssl_cipher_list_to_bytes@@9@9 ; `ssl_cipher_list_to_bytes'::`7'::scsv
		call	ebx
		add	esp, 8
		add	esi, eax
		sub	esi, edi
		mov	eax, esi
		pop	esi
		pop	edi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_36C9:				; CODE XREF: _ssl_cipher_list_to_bytes+65j
		mov	edi, esi

loc_36CB:				; CODE XREF: _ssl_cipher_list_to_bytes+B3j
					; _ssl_cipher_list_to_bytes+D8j
		sub	esi, edi
		mov	eax, esi
		pop	esi
		pop	edi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
_ssl_cipher_list_to_bytes endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 36D8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_cipher_ptr_id_cmp
_ssl_cipher_ptr_id_cmp proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [eax]
		mov	eax, [esp+arg_4]
		mov	ecx, [ecx+8]
		mov	eax, [eax]
		sub	ecx, [eax+8]
		jnz	short loc_36EF
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_36EF:				; CODE XREF: _ssl_cipher_ptr_id_cmp+12j
		xor	eax, eax
		test	ecx, ecx
		setnle	al
		lea	eax, ds:0FFFFFFFFh[eax*2]
		retn
_ssl_cipher_ptr_id_cmp endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3700h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_clear_cipher_ctx
_ssl_clear_cipher_ctx proc near		; CODE XREF: _SSL_clear+E5p
					; _SSL_free+F3p ...

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, [esi+80h]
		test	eax, eax
		jz	short loc_372D
		push	eax
		call	_EVP_CIPHER_CTX_cleanup
		push	dword ptr [esi+80h]
		call	_CRYPTO_free
		add	esp, 8
		mov	dword ptr [esi+80h], 0

loc_372D:				; CODE XREF: _ssl_clear_cipher_ctx+Dj
		mov	eax, [esi+8Ch]
		test	eax, eax
		jz	short loc_3755
		push	eax
		call	_EVP_CIPHER_CTX_cleanup
		push	dword ptr [esi+8Ch]
		call	_CRYPTO_free
		add	esp, 8
		mov	dword ptr [esi+8Ch], 0

loc_3755:				; CODE XREF: _ssl_clear_cipher_ctx+35j
		mov	eax, [esi+88h]
		test	eax, eax
		jz	short loc_3772
		push	eax
		call	_COMP_CTX_free
		add	esp, 4
		mov	dword ptr [esi+88h], 0

loc_3772:				; CODE XREF: _ssl_clear_cipher_ctx+5Dj
		mov	eax, [esi+94h]
		test	eax, eax
		jz	short loc_378F
		push	eax
		call	_COMP_CTX_free
		add	esp, 4
		mov	dword ptr [esi+94h], 0

loc_378F:				; CODE XREF: _ssl_clear_cipher_ctx+7Aj
		pop	esi
		retn
_ssl_clear_cipher_ctx endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3794h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_clear_hash_ctx
_ssl_clear_hash_ctx proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, [esi]
		test	eax, eax
		jz	short loc_37A8
		push	eax
		call	_EVP_MD_CTX_destroy
		add	esp, 4

loc_37A8:				; CODE XREF: _ssl_clear_hash_ctx+9j
		mov	dword ptr [esi], 0
		pop	esi
		retn
_ssl_clear_hash_ctx endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 37B0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_free_wbio_buffer
_ssl_free_wbio_buffer proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, [esi+14h]
		test	eax, eax
		jz	short loc_37E1
		mov	ecx, [esi+10h]
		cmp	eax, ecx
		jnz	short loc_37CF
		push	ecx
		call	_BIO_pop
		add	esp, 4
		mov	[esi+10h], eax

loc_37CF:				; CODE XREF: _ssl_free_wbio_buffer+11j
		push	dword ptr [esi+14h]
		call	_BIO_free
		add	esp, 4
		mov	dword ptr [esi+14h], 0

loc_37E1:				; CODE XREF: _ssl_free_wbio_buffer+Aj
		pop	esi
		retn
_ssl_free_wbio_buffer endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 37E4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_get_ciphers_by_id
_ssl_get_ciphers_by_id proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jz	short loc_3804
		mov	eax, [ecx+78h]
		test	eax, eax
		jnz	short locret_3806
		mov	eax, [ecx+0E4h]
		test	eax, eax
		jz	short loc_3804
		mov	eax, [eax+8]
		test	eax, eax
		jnz	short locret_3806

loc_3804:				; CODE XREF: _ssl_get_ciphers_by_id+6j
					; _ssl_get_ciphers_by_id+17j
		xor	eax, eax

locret_3806:				; CODE XREF: _ssl_get_ciphers_by_id+Dj
					; _ssl_get_ciphers_by_id+1Ej
		retn
_ssl_get_ciphers_by_id endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3808h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssl_get_server_cert_index proc	near	; CODE XREF: _ssl_get_server_send_pkey+25p

arg_0		= dword	ptr  4

		push	esi
		push	edi
		mov	edi, [esp+8+arg_0]
		mov	eax, [edi+58h]
		push	dword ptr [eax+344h]
		call	_ssl_cipher_get_cert_index
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jnz	short loc_3836
		mov	ecx, [edi+98h]
		cmp	[ecx+3Ch], eax
		jnz	short loc_3858
		pop	edi
		lea	eax, [esi+1]
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_3836:				; CODE XREF: _ssl_get_server_cert_index+1Bj
		cmp	esi, 0FFFFFFFFh
		jnz	short loc_3858
		push	9E3h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	44h ; 'D'
		push	142h
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		mov	eax, esi

loc_3858:				; CODE XREF: _ssl_get_server_cert_index+26j
					; _ssl_get_server_cert_index+31j
		pop	edi
		pop	esi
		retn
_ssl_get_server_cert_index endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 385Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_get_server_cert_serverinfo
_ssl_get_server_cert_serverinfo	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		push	esi
		mov	esi, [esp+8+arg_0]
		push	edi
		mov	edi, [esp+0Ch+arg_8]
		mov	dword ptr [edi], 0
		mov	eax, [esi+58h]
		mov	ebx, [esi+98h]
		push	dword ptr [eax+344h]
		call	_ssl_cipher_get_cert_index
		mov	edx, eax
		add	esp, 4
		test	edx, edx
		jnz	short loc_38C2
		mov	ecx, [esi+98h]
		cmp	[ecx+3Ch], eax
		jnz	short loc_389A
		mov	edx, 1

loc_389A:				; CODE XREF: _ssl_get_server_cert_serverinfo+37j
					; _ssl_get_server_cert_serverinfo+69j
		lea	eax, ds:0[edx*8]
		sub	eax, edx
		mov	edx, [ebx+eax*4+4Ch]
		lea	ecx, [ebx+eax*4]
		test	edx, edx
		jz	short loc_38E2
		mov	eax, [esp+0Ch+arg_4]
		mov	[eax], edx
		mov	eax, [ecx+50h]
		mov	[edi], eax
		mov	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_38C2:				; CODE XREF: _ssl_get_server_cert_serverinfo+2Cj
		cmp	edx, 0FFFFFFFFh
		jnz	short loc_389A
		push	9E3h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	44h ; 'D'
		push	142h
		push	14h
		call	_ERR_put_error
		add	esp, 14h

loc_38E2:				; CODE XREF: _ssl_get_server_cert_serverinfo+50j
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebx
		retn
_ssl_get_server_cert_serverinfo	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 38E8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_get_server_send_pkey
_ssl_get_server_send_pkey proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		mov	eax, [esi+58h]
		mov	edi, [esi+98h]
		test	eax, eax
		jz	short loc_392D
		mov	eax, [eax+344h]
		test	eax, eax
		jz	short loc_392D
		push	eax
		push	edi
		call	_ssl_set_cert_masks
		push	esi
		call	_ssl_get_server_cert_index
		mov	ecx, eax
		add	esp, 0Ch
		test	ecx, ecx
		js	short loc_392D
		lea	eax, ds:0[ecx*8]
		sub	eax, ecx
		add	eax, 0Fh
		lea	eax, [edi+eax*4]
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_392D:				; CODE XREF: _ssl_get_server_send_pkey+11j
					; _ssl_get_server_send_pkey+1Bj ...
		pop	edi
		xor	eax, eax
		pop	esi
		retn
_ssl_get_server_send_pkey endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3934h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_get_sign_pkey
_ssl_get_sign_pkey proc	near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, [esp+arg_4]
		push	esi
		mov	ecx, [eax+10h]
		mov	eax, [esp+4+arg_0]
		mov	esi, [eax+98h]
		test	cl, 2
		jz	short loc_3958
		cmp	dword ptr [esi+78h], 0
		jz	short loc_3958
		mov	edx, 2
		jmp	short loc_3987
; ---------------------------------------------------------------------------

loc_3958:				; CODE XREF: _ssl_get_sign_pkey+15j
					; _ssl_get_sign_pkey+1Bj
		test	cl, 1
		jz	short loc_3974
		cmp	dword ptr [esi+5Ch], 0
		jz	short loc_396A
		mov	edx, 1
		jmp	short loc_3987
; ---------------------------------------------------------------------------

loc_396A:				; CODE XREF: _ssl_get_sign_pkey+2Dj
		cmp	dword ptr [esi+40h], 0
		jz	short loc_39AD
		xor	edx, edx
		jmp	short loc_3987
; ---------------------------------------------------------------------------

loc_3974:				; CODE XREF: _ssl_get_sign_pkey+27j
		test	cl, 40h
		jz	short loc_39AD
		cmp	dword ptr [esi+0CCh], 0
		jz	short loc_39AD
		mov	edx, 5

loc_3987:				; CODE XREF: _ssl_get_sign_pkey+22j
					; _ssl_get_sign_pkey+34j ...
		mov	eax, [esp+4+arg_8]
		test	eax, eax
		jz	short loc_399E
		lea	ecx, ds:0[edx*8]
		sub	ecx, edx
		mov	ecx, [esi+ecx*4+44h]
		mov	[eax], ecx

loc_399E:				; CODE XREF: _ssl_get_sign_pkey+59j
		lea	eax, ds:0[edx*8]
		sub	eax, edx
		mov	eax, [esi+eax*4+40h]
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_39AD:				; CODE XREF: _ssl_get_sign_pkey+3Aj
					; _ssl_get_sign_pkey+43j ...
		push	0A24h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	44h ; 'D'
		push	0B7h ; '·'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
_ssl_get_sign_pkey endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 39CCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_init_wbio_buffer
_ssl_init_wbio_buffer proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		push	edi
		mov	edi, [esp+8+arg_0]
		mov	esi, [edi+14h]
		test	esi, esi
		jnz	short loc_39F2
		call	_BIO_f_buffer
		push	eax
		call	_BIO_new
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jz	short loc_3A3F
		mov	[edi+14h], esi
		jmp	short loc_3A05
; ---------------------------------------------------------------------------

loc_39F2:				; CODE XREF: _ssl_init_wbio_buffer+Bj
		mov	eax, [edi+10h]
		cmp	esi, eax
		jnz	short loc_3A05
		push	eax
		call	_BIO_pop
		add	esp, 4
		mov	[edi+10h], eax

loc_3A05:				; CODE XREF: _ssl_init_wbio_buffer+24j
					; _ssl_init_wbio_buffer+2Bj
		push	0
		push	0
		push	1
		push	esi
		call	_BIO_ctrl
		push	0
		push	1
		push	75h ; 'u'
		push	esi
		call	_BIO_int_ctrl
		add	esp, 20h
		test	eax, eax
		jnz	short loc_3A44
		push	0C18h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	7
		push	0B8h ; '¸'
		push	14h
		call	_ERR_put_error
		add	esp, 14h

loc_3A3F:				; CODE XREF: _ssl_init_wbio_buffer+1Fj
		pop	edi
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_3A44:				; CODE XREF: _ssl_init_wbio_buffer+56j
		cmp	[esp+8+arg_4], 0
		jz	short loc_3A67
		mov	eax, [edi+10h]
		cmp	eax, esi
		jz	short loc_3A78
		push	eax
		push	esi
		call	_BIO_push
		add	esp, 8
		mov	[edi+10h], eax
		mov	eax, 1
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_3A67:				; CODE XREF: _ssl_init_wbio_buffer+7Dj
		cmp	[edi+10h], esi
		jnz	short loc_3A78
		push	esi
		call	_BIO_pop
		add	esp, 4
		mov	[edi+10h], eax

loc_3A78:				; CODE XREF: _ssl_init_wbio_buffer+84j
					; _ssl_init_wbio_buffer+9Ej
		pop	edi
		mov	eax, 1
		pop	esi
		retn
_ssl_init_wbio_buffer endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3A80h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_ok
_ssl_ok		proc near
		mov	eax, 1
		retn
_ssl_ok		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3A88h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_replace_hash
_ssl_replace_hash proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, [esi]
		test	eax, eax
		jz	short loc_3A9C
		push	eax
		call	_EVP_MD_CTX_destroy
		add	esp, 4

loc_3A9C:				; CODE XREF: _ssl_replace_hash+9j
		mov	dword ptr [esi], 0
		call	_EVP_MD_CTX_create
		mov	[esi], eax
		test	eax, eax
		jz	short loc_3AC9
		mov	ecx, [esp+4+arg_4]
		test	ecx, ecx
		jz	short loc_3AC5
		push	0
		push	ecx
		push	eax
		call	_EVP_DigestInit_ex
		add	esp, 0Ch
		test	eax, eax
		jle	short loc_3AC9

loc_3AC5:				; CODE XREF: _ssl_replace_hash+2Bj
		mov	eax, [esi]
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_3AC9:				; CODE XREF: _ssl_replace_hash+23j
					; _ssl_replace_hash+3Bj
		push	dword ptr [esi]
		call	_EVP_MD_CTX_destroy
		add	esp, 4
		mov	dword ptr [esi], 0
		xor	eax, eax
		pop	esi
		retn
_ssl_replace_hash endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3AE0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssl_session_LHASH_COMP	proc near	; DATA XREF: _SSL_CTX_new+18Bo
		jmp	_ssl_session_cmp
_ssl_session_LHASH_COMP	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3AE8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssl_session_LHASH_HASH	proc near	; DATA XREF: _SSL_CTX_new+190o

arg_0		= dword	ptr  4

		mov	edx, [esp+arg_0]
		movzx	eax, byte ptr [edx+4Bh]
		movzx	ecx, byte ptr [edx+4Ah]
		shl	eax, 8
		or	eax, ecx
		movzx	ecx, byte ptr [edx+49h]
		shl	eax, 8
		or	eax, ecx
		movzx	ecx, byte ptr [edx+48h]
		shl	eax, 8
		or	eax, ecx
		retn
_ssl_session_LHASH_HASH	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3B0Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssl_session_cmp proc near		; CODE XREF: _ssl_session_LHASH_COMPj

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_0]
		push	esi
		mov	esi, [esp+4+arg_4]
		mov	eax, [edx]
		cmp	eax, [esi]
		jz	short loc_3B22

loc_3B1B:				; CODE XREF: _ssl_session_cmp+1Cj
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_3B22:				; CODE XREF: _ssl_session_cmp+Dj
		mov	ecx, [edx+44h]
		cmp	ecx, [esi+44h]
		jnz	short loc_3B1B
		add	esi, 48h ; 'H'
		add	edx, 48h ; 'H'
		sub	ecx, 4
		jb	short loc_3B4D
		nop	dword ptr [eax+00000000h]

loc_3B3C:				; CODE XREF: _ssl_session_cmp+3Fj
		mov	eax, [edx]
		cmp	eax, [esi]
		jnz	short loc_3B52
		add	edx, 4
		add	esi, 4
		sub	ecx, 4
		jnb	short loc_3B3C

loc_3B4D:				; CODE XREF: _ssl_session_cmp+27j
		cmp	ecx, 0FFFFFFFCh
		jz	short loc_3B86

loc_3B52:				; CODE XREF: _ssl_session_cmp+34j
		mov	al, [edx]
		cmp	al, [esi]
		jnz	short loc_3B7F
		cmp	ecx, 0FFFFFFFDh
		jz	short loc_3B86
		mov	al, [edx+1]
		cmp	al, [esi+1]
		jnz	short loc_3B7F
		cmp	ecx, 0FFFFFFFEh
		jz	short loc_3B86
		mov	al, [edx+2]
		cmp	al, [esi+2]
		jnz	short loc_3B7F
		cmp	ecx, 0FFFFFFFFh
		jz	short loc_3B86
		mov	al, [edx+3]
		cmp	al, [esi+3]
		jz	short loc_3B86

loc_3B7F:				; CODE XREF: _ssl_session_cmp+4Aj
					; _ssl_session_cmp+57j	...
		sbb	eax, eax
		or	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_3B86:				; CODE XREF: _ssl_session_cmp+44j
					; _ssl_session_cmp+4Fj	...
		xor	eax, eax
		pop	esi
		retn
_ssl_session_cmp endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3B8Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssl_session_hash proc near

arg_0		= dword	ptr  4

		mov	edx, [esp+arg_0]
		movzx	eax, byte ptr [edx+4Bh]
		movzx	ecx, byte ptr [edx+4Ah]
		shl	eax, 8
		or	eax, ecx
		movzx	ecx, byte ptr [edx+49h]
		shl	eax, 8
		or	eax, ecx
		movzx	ecx, byte ptr [edx+48h]
		shl	eax, 8
		or	eax, ecx
		retn
_ssl_session_hash endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3BB0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_set_cert_masks
_ssl_set_cert_masks proc near		; CODE XREF: _ssl_get_server_send_pkey+1Fp

var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 3Ch ; '<'
		call	__chkstk
		push	esi
		mov	esi, [esp+40h+arg_0]
		mov	[esp+40h+var_20], 0
		mov	[esp+40h+var_4], 0
		test	esi, esi
		jz	loc_3F9F
		mov	eax, [esp+40h+arg_4]
		push	ebx
		push	ebp
		push	edi
		test	byte ptr [eax+20h], 8
		mov	edi, 400h
		mov	eax, 200h
		cmovnz	edi, eax
		mov	eax, [esi+1Ch]
		test	eax, eax
		jnz	short loc_3BFF
		cmp	[esi+20h], eax
		jnz	short loc_3BFF
		xor	ecx, ecx
		jmp	short loc_3C04
; ---------------------------------------------------------------------------

loc_3BFF:				; CODE XREF: _ssl_set_cert_masks+44j
					; _ssl_set_cert_masks+49j
		mov	ecx, 1

loc_3C04:				; CODE XREF: _ssl_set_cert_masks+4Dj
		cmp	dword ptr [esi+20h], 0
		mov	[esp+4Ch+var_3C], ecx
		jnz	short loc_3C2C
		test	ecx, ecx
		jz	short loc_3C22
		push	eax
		call	_RSA_size
		shl	eax, 3
		add	esp, 4
		cmp	eax, edi
		jle	short loc_3C2C

loc_3C22:				; CODE XREF: _ssl_set_cert_masks+60j
		mov	[esp+4Ch+var_34], 0
		jmp	short loc_3C34
; ---------------------------------------------------------------------------

loc_3C2C:				; CODE XREF: _ssl_set_cert_masks+5Cj
					; _ssl_set_cert_masks+70j
		mov	[esp+4Ch+var_34], 1

loc_3C34:				; CODE XREF: _ssl_set_cert_masks+7Aj
		mov	eax, [esi+24h]
		test	eax, eax
		jnz	short loc_3C44
		cmp	[esi+28h], eax
		jnz	short loc_3C44
		xor	ecx, ecx
		jmp	short loc_3C49
; ---------------------------------------------------------------------------

loc_3C44:				; CODE XREF: _ssl_set_cert_masks+89j
					; _ssl_set_cert_masks+8Ej
		mov	ecx, 1

loc_3C49:				; CODE XREF: _ssl_set_cert_masks+92j
		cmp	dword ptr [esi+28h], 0
		mov	[esp+4Ch+var_2C], ecx
		jnz	short loc_3C71
		test	ecx, ecx
		jz	short loc_3C67
		push	eax
		call	_DH_size
		shl	eax, 3
		add	esp, 4
		cmp	eax, edi
		jle	short loc_3C71

loc_3C67:				; CODE XREF: _ssl_set_cert_masks+A5j
		mov	[esp+4Ch+var_30], 0
		jmp	short loc_3C79
; ---------------------------------------------------------------------------

loc_3C71:				; CODE XREF: _ssl_set_cert_masks+A1j
					; _ssl_set_cert_masks+B5j
		mov	[esp+4Ch+var_30], 1

loc_3C79:				; CODE XREF: _ssl_set_cert_masks+BFj
		cmp	dword ptr [esi+2Ch], 0
		jnz	short loc_3C93
		cmp	dword ptr [esi+30h], 0
		jnz	short loc_3C93
		cmp	dword ptr [esi+34h], 0
		mov	[esp+4Ch+var_1C], 0
		jz	short loc_3C9B

loc_3C93:				; CODE XREF: _ssl_set_cert_masks+CDj
					; _ssl_set_cert_masks+D3j
		mov	[esp+4Ch+var_1C], 1

loc_3C9B:				; CODE XREF: _ssl_set_cert_masks+E1j
		mov	eax, [esi+54h]
		and	eax, 1
		mov	[esp+4Ch+var_18], eax
		jz	short loc_3CC1
		push	dword ptr [esi+40h]
		call	_EVP_PKEY_size
		shl	eax, 3
		add	esp, 4
		mov	[esp+4Ch+var_38], 1
		cmp	eax, edi
		jle	short loc_3CC9

loc_3CC1:				; CODE XREF: _ssl_set_cert_masks+F5j
		mov	[esp+4Ch+var_38], 0

loc_3CC9:				; CODE XREF: _ssl_set_cert_masks+10Fj
		mov	eax, [esi+70h]
		and	eax, 2
		mov	[esp+4Ch+arg_0], eax
		mov	eax, [esi+8Ch]
		and	eax, 2
		mov	[esp+4Ch+var_C], eax
		mov	eax, [esi+0A8h]
		and	eax, 1
		mov	[esp+4Ch+var_14], eax
		jz	short loc_3D0C
		push	dword ptr [esi+94h]
		call	_EVP_PKEY_size
		shl	eax, 3
		add	esp, 4
		mov	[esp+4Ch+var_28], 1
		cmp	eax, edi
		jle	short loc_3D14

loc_3D0C:				; CODE XREF: _ssl_set_cert_masks+13Dj
		mov	[esp+4Ch+var_28], 0

loc_3D14:				; CODE XREF: _ssl_set_cert_masks+15Aj
		mov	eax, [esi+0C4h]
		and	eax, 1
		mov	[esp+4Ch+var_10], eax
		jz	short loc_3D40
		push	dword ptr [esi+0B0h]
		call	_EVP_PKEY_size
		shl	eax, 3
		add	esp, 4
		mov	[esp+4Ch+var_24], 1
		cmp	eax, edi
		jle	short loc_3D48

loc_3D40:				; CODE XREF: _ssl_set_cert_masks+171j
		mov	[esp+4Ch+var_24], 0

loc_3D48:				; CODE XREF: _ssl_set_cert_masks+18Ej
		mov	eax, [esi+0E0h]
		xor	ebx, ebx
		and	eax, 1
		xor	edi, edi
		mov	[esp+4Ch+var_8], eax
		xor	ebp, ebp
		xor	eax, eax
		cmp	[esi+100h], eax
		jz	short loc_3D74
		cmp	[esi+104h], eax
		jz	short loc_3D74
		mov	ebx, 200h
		mov	edi, ebx

loc_3D74:				; CODE XREF: _ssl_set_cert_masks+1B3j
					; _ssl_set_cert_masks+1BBj
		cmp	[esi+0E4h], eax
		jz	short loc_3D90
		cmp	[esi+0E8h], eax
		jz	short loc_3D90
		or	ebx, 200h
		or	edi, 100h

loc_3D90:				; CODE XREF: _ssl_set_cert_masks+1CAj
					; _ssl_set_cert_masks+1D2j
		mov	ecx, [esp+4Ch+var_18]
		mov	edx, [esp+4Ch+arg_0]
		test	ecx, ecx
		jnz	short loc_3DA6
		cmp	[esp+4Ch+var_3C], eax
		jz	short loc_3DA9
		test	edx, edx
		jz	short loc_3DA9

loc_3DA6:				; CODE XREF: _ssl_set_cert_masks+1EAj
		or	ebx, 1

loc_3DA9:				; CODE XREF: _ssl_set_cert_masks+1F0j
					; _ssl_set_cert_masks+1F4j
		cmp	[esp+4Ch+var_38], eax
		jnz	short loc_3DBD
		cmp	[esp+4Ch+var_34], eax
		jz	short loc_3DC2
		test	edx, edx
		jnz	short loc_3DBD
		test	ecx, ecx
		jz	short loc_3DC2

loc_3DBD:				; CODE XREF: _ssl_set_cert_masks+1FDj
					; _ssl_set_cert_masks+207j
		mov	ebp, 1

loc_3DC2:				; CODE XREF: _ssl_set_cert_masks+203j
					; _ssl_set_cert_masks+20Bj
		cmp	[esp+4Ch+var_30], eax
		jz	short loc_3DCB
		or	ebp, 8

loc_3DCB:				; CODE XREF: _ssl_set_cert_masks+216j
		cmp	[esp+4Ch+var_2C], eax
		jz	short loc_3DD4
		or	ebx, 8

loc_3DD4:				; CODE XREF: _ssl_set_cert_masks+21Fj
		cmp	[esp+4Ch+var_14], eax
		jz	short loc_3DDD
		or	ebx, 2

loc_3DDD:				; CODE XREF: _ssl_set_cert_masks+228j
		cmp	[esp+4Ch+var_28], eax
		jz	short loc_3DE6
		or	ebp, 2

loc_3DE6:				; CODE XREF: _ssl_set_cert_masks+231j
		cmp	[esp+4Ch+var_10], eax
		jz	short loc_3DEF
		or	ebx, 4

loc_3DEF:				; CODE XREF: _ssl_set_cert_masks+23Aj
		cmp	[esp+4Ch+var_24], eax
		jz	short loc_3DF8
		or	ebp, 4

loc_3DF8:				; CODE XREF: _ssl_set_cert_masks+243j
		test	bl, 6
		jz	short loc_3E00
		or	edi, 8

loc_3E00:				; CODE XREF: _ssl_set_cert_masks+24Bj
		test	ecx, ecx
		jnz	short loc_3E08
		test	edx, edx
		jz	short loc_3E10

loc_3E08:				; CODE XREF: _ssl_set_cert_masks+252j
		or	edi, 1
		mov	eax, 1

loc_3E10:				; CODE XREF: _ssl_set_cert_masks+256j
		cmp	[esp+4Ch+var_C], 0
		jz	short loc_3E1D
		or	edi, 2
		or	eax, 2

loc_3E1D:				; CODE XREF: _ssl_set_cert_masks+265j
		or	eax, 4
		or	edi, 4
		cmp	[esp+4Ch+var_8], 0
		mov	[esp+4Ch+arg_0], eax
		jz	loc_3F5F
		mov	eax, [esi+0C8h]
		push	0
		push	0FFFFFFFFh
		push	eax
		mov	[esp+58h+var_24], eax
		call	_X509_check_purpose
		mov	eax, [esp+58h+var_24]
		add	esp, 0Ch
		mov	edx, [eax+28h]
		and	edx, 2
		jz	short loc_3E61
		mov	ecx, [eax+2Ch]
		and	ecx, 8
		mov	[esp+4Ch+var_28], ecx
		jmp	short loc_3E69
; ---------------------------------------------------------------------------

loc_3E61:				; CODE XREF: _ssl_set_cert_masks+2A3j
		mov	[esp+4Ch+var_28], 1

loc_3E69:				; CODE XREF: _ssl_set_cert_masks+2AFj
		test	edx, edx
		jz	short loc_3E78
		mov	ecx, [eax+2Ch]
		and	ecx, 80h
		jmp	short loc_3E7D
; ---------------------------------------------------------------------------

loc_3E78:				; CODE XREF: _ssl_set_cert_masks+2BBj
		mov	ecx, 1

loc_3E7D:				; CODE XREF: _ssl_set_cert_masks+2C6j
		test	byte ptr [esi+0E0h], 2
		mov	edx, 0
		push	eax
		cmovz	ecx, edx
		mov	[esp+50h+var_C], ecx
		call	_X509_get_pubkey
		add	esp, 4
		mov	[esp+4Ch+var_8], eax
		test	eax, eax
		jz	short loc_3EB4
		push	eax
		call	_EVP_PKEY_bits
		mov	[esp+50h+var_3C], eax
		add	esp, 4
		mov	eax, [esp+4Ch+var_8]
		jmp	short loc_3EBC
; ---------------------------------------------------------------------------

loc_3EB4:				; CODE XREF: _ssl_set_cert_masks+2EFj
		mov	[esp+4Ch+var_3C], 0

loc_3EBC:				; CODE XREF: _ssl_set_cert_masks+302j
		push	eax
		call	_EVP_PKEY_free
		mov	eax, [esp+50h+var_24]
		add	esp, 4
		mov	eax, [eax+4]
		test	eax, eax
		jz	short loc_3EEF
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_3EEF
		push	eax
		call	_OBJ_obj2nid
		lea	ecx, [esp+50h+var_20]
		push	ecx
		lea	ecx, [esp+54h+var_4]
		push	ecx
		push	eax
		call	_OBJ_find_sigid_algs
		add	esp, 10h

loc_3EEF:				; CODE XREF: _ssl_set_cert_masks+31Ej
					; _ssl_set_cert_masks+324j
		cmp	[esp+4Ch+var_28], 0
		jz	short loc_3F4E
		mov	ecx, [esp+4Ch+var_20]
		cmp	ecx, 6
		jz	short loc_3F04
		cmp	ecx, 13h
		jnz	short loc_3F26

loc_3F04:				; CODE XREF: _ssl_set_cert_masks+34Dj
		mov	edx, [esp+4Ch+var_3C]
		or	ebx, 20h
		mov	eax, [esp+4Ch+arg_0]
		or	edi, 10h
		cmp	edx, 0A3h ; '£'
		jg	short loc_3F2E
		or	ebp, 20h
		or	eax, 10h
		mov	[esp+4Ch+arg_0], eax
		jmp	short loc_3F2E
; ---------------------------------------------------------------------------

loc_3F26:				; CODE XREF: _ssl_set_cert_masks+352j
		mov	eax, [esp+4Ch+arg_0]
		mov	edx, [esp+4Ch+var_3C]

loc_3F2E:				; CODE XREF: _ssl_set_cert_masks+368j
					; _ssl_set_cert_masks+374j
		cmp	ecx, 198h
		jnz	short loc_3F4E
		or	ebx, 40h
		or	edi, 10h
		cmp	edx, 0A3h ; '£'
		jg	short loc_3F4E
		or	ebp, 40h
		or	eax, 10h
		mov	[esp+4Ch+arg_0], eax

loc_3F4E:				; CODE XREF: _ssl_set_cert_masks+344j
					; _ssl_set_cert_masks+384j ...
		cmp	[esp+4Ch+var_C], 0
		mov	eax, [esp+4Ch+arg_0]
		jz	short loc_3F5F
		or	edi, 40h
		or	eax, 40h

loc_3F5F:				; CODE XREF: _ssl_set_cert_masks+27Cj
					; _ssl_set_cert_masks+3A7j
		cmp	[esp+4Ch+var_1C], 0
		jz	short loc_3F72
		or	ebx, 80h
		or	ebp, 80h

loc_3F72:				; CODE XREF: _ssl_set_cert_masks+3B4j
		or	edi, 80h
		mov	dword ptr [esi+4], 1
		or	ebp, 100h
		mov	[esi+0Ch], edi
		or	ebx, 100h
		mov	[esi+10h], ebp
		pop	edi
		or	eax, 80h
		mov	[esi+8], ebx
		pop	ebp
		mov	[esi+14h], eax
		pop	ebx

loc_3F9F:				; CODE XREF: _ssl_set_cert_masks+21j
		pop	esi
		add	esp, 3Ch
		retn
_ssl_set_cert_masks endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3FA4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_undefined_const_function
_ssl_undefined_const_function proc near
		push	0B13h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	42h ; 'B'
		push	0F3h ; 'ó'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
_ssl_undefined_const_function endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3FC4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_undefined_void_function
_ssl_undefined_void_function proc near
		push	0B0Ch
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	42h ; 'B'
		push	0F4h ; 'ô'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
_ssl_undefined_void_function endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3FE4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_update_cache
_ssl_update_cache proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 8
		call	__chkstk
		push	esi
		mov	esi, [esp+0Ch+arg_0]
		mov	eax, [esi+0C0h]
		cmp	dword ptr [eax+44h], 0
		jz	loc_40C5
		mov	edx, [esi+170h]
		push	ebx
		mov	ebx, [esp+10h+arg_4]
		push	edi
		mov	ecx, [edx+20h]
		mov	edi, ecx
		mov	[esp+14h+arg_0], ecx
		and	edi, ebx
		jz	short loc_408A
		cmp	dword ptr [esi+6Ch], 0
		jnz	short loc_408A
		test	ecx, 200h
		jnz	short loc_4038
		push	eax
		push	edx
		call	_SSL_CTX_add_session
		add	esp, 8
		test	eax, eax
		jz	short loc_408A

loc_4038:				; CODE XREF: _ssl_update_cache+44j
		mov	eax, [esi+170h]
		cmp	dword ptr [eax+28h], 0
		jz	short loc_408A
		mov	eax, [esi+0C0h]
		push	0A52h
		push	offset ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ ; ".\\ssl\\ssl_lib.c"
		push	0Eh
		add	eax, 0A4h ; '¤'
		push	1
		push	eax
		call	_CRYPTO_add_lock
		mov	eax, [esi+170h]
		push	dword ptr [esi+0C0h]
		push	esi
		mov	eax, [eax+28h]
		call	eax
		add	esp, 1Ch
		test	eax, eax
		jnz	short loc_408A
		push	dword ptr [esi+0C0h]
		call	_SSL_SESSION_free
		add	esp, 4

loc_408A:				; CODE XREF: _ssl_update_cache+36j
					; _ssl_update_cache+3Cj ...
		test	byte ptr [esp+14h+arg_0], 80h
		jnz	short loc_40C3
		cmp	edi, ebx
		jnz	short loc_40C3
		mov	eax, [esi+170h]
		test	bl, 1
		jz	short loc_40A5
		mov	eax, [eax+3Ch]
		jmp	short loc_40A8
; ---------------------------------------------------------------------------

loc_40A5:				; CODE XREF: _ssl_update_cache+BAj
		mov	eax, [eax+48h]

loc_40A8:				; CODE XREF: _ssl_update_cache+BFj
		cmp	al, 0FFh
		jnz	short loc_40C3
		push	0		; Time
		call	dword ptr ds:__imp___time64
		push	eax
		push	dword ptr [esi+170h]
		call	_SSL_CTX_flush_sessions
		add	esp, 0Ch

loc_40C3:				; CODE XREF: _ssl_update_cache+ABj
					; _ssl_update_cache+AFj ...
		pop	edi
		pop	ebx

loc_40C5:				; CODE XREF: _ssl_update_cache+19j
		pop	esi
		add	esp, 8
		retn
_ssl_update_cache endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 40CCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; time_t __cdecl static	time(time_t *Time)
_time		proc near
		jmp	dword ptr ds:__imp___time64
_time		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40D4h
; COMDAT (pick any)
		public ??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@
; `string'
??_C@_0BA@KBOIMHCO@?4?2ssl?2ssl_lib?4c?$AA@ db '.\ssl\ssl_lib.c',0
					; DATA XREF: _ssl_undefined_function+5o
					; _SSL_CTX_check_private_key+26o ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40E4h
; COMDAT (pick any)
		public ??_C@_05NHFKDGAI@SSLv2?$AA@
; `string'
??_C@_05NHFKDGAI@SSLv2?$AA@ db 'SSLv2',0 ; DATA XREF: _SSL_CTX_new+1EAo
					; _SSL_CTX_set_ssl_version+4o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40ECh
; COMDAT (pick any)
		public ??_C@_0CG@ENOBHNBE@ALL?3?$CBEXPORT?3?$CBLOW?3?$CBaNULL?3?$CBeNULL?3?$CB@
; `string'
??_C@_0CG@ENOBHNBE@ALL?3?$CBEXPORT?3?$CBLOW?3?$CBaNULL?3?$CBeNULL?3?$CB@ db 'ALL:!EXPORT:!LOW:!aNULL:!eNULL:!SSLv2',0
					; DATA XREF: _SSL_CTX_new+1DEo
					; _SSL_CTX_set_ssl_version+Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4114h
; COMDAT (pick any)
		public ??_C@_0CH@MEMCPFFG@s?9?$DOsid_ctx_length?5?$DM?$DN?5sizeof?5s?9?$DOs@
; `string'
??_C@_0CH@MEMCPFFG@s?9?$DOsid_ctx_length?5?$DM?$DN?5sizeof?5s?9?$DOs@ db 's->sid_ctx_length <= sizeof s->sid_ctx',0
					; DATA XREF: _SSL_new+136o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 413Ch
; COMDAT (pick any)
		public ??_C@_08OKFBGHCE@ssl2?9md5?$AA@
; `string'
??_C@_08OKFBGHCE@ssl2?9md5?$AA@	db 'ssl2-md5',0 ; DATA XREF: _SSL_CTX_new+234o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4148h
; COMDAT (pick any)
		public ??_C@_08CBANLEIB@ssl3?9md5?$AA@
; `string'
??_C@_08CBANLEIB@ssl3?9md5?$AA@	db 'ssl3-md5',0 ; DATA XREF: _SSL_CTX_new:loc_8E7o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4154h
; COMDAT (pick any)
		public ??_C@_09KCHAKJIH@ssl3?9sha1?$AA@
; `string'
??_C@_09KCHAKJIH@ssl3?9sha1?$AA@ db 'ssl3-sha1',0 ; DATA XREF: _SSL_CTX_new:loc_912o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4160h
; COMDAT (pick any)
		public ??_C@_07KDKGANMO@TLSv1?42?$AA@
; `string'
??_C@_07KDKGANMO@TLSv1?42?$AA@ db 'TLSv1.2',0 ; DATA XREF: _SSL_get_version+Eo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4168h
; COMDAT (pick any)
		public ??_C@_07IIILFOAN@TLSv1?41?$AA@
; `string'
??_C@_07IIILFOAN@TLSv1?41?$AA@ db 'TLSv1.1',0 ; DATA XREF: _SSL_get_version+1Co
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4170h
; COMDAT (pick any)
		public ??_C@_05LLIBCOJ@TLSv1?$AA@
; `string'
??_C@_05LLIBCOJ@TLSv1?$AA@ db 'TLSv1',0 ; DATA XREF: _SSL_get_version+2Ao
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4178h
; COMDAT (pick any)
		public ??_C@_05MOEBAHEJ@SSLv3?$AA@
; `string'
??_C@_05MOEBAHEJ@SSLv3?$AA@ db 'SSLv3',0 ; DATA XREF: _SSL_get_version+38o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4180h
; COMDAT (pick any)
		public ??_C@_08PILLCKKM@DTLSv0?49?$AA@
; `string'
??_C@_08PILLCKKM@DTLSv0?49?$AA@	db 'DTLSv0.9',0 ; DATA XREF: _SSL_get_version+51o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 418Ch
; COMDAT (pick any)
		public ??_C@_06JHFCDNFO@DTLSv1?$AA@
; `string'
??_C@_06JHFCDNFO@DTLSv1?$AA@ db	'DTLSv1',0 ; DATA XREF: _SSL_get_version+5Fo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4194h
; COMDAT (pick any)
		public ??_C@_08KDPDJEAC@DTLSv1?42?$AA@
; `string'
??_C@_08KDPDJEAC@DTLSv1?42?$AA@	db 'DTLSv1.2',0 ; DATA XREF: _SSL_get_version+6Bo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 41A0h
; COMDAT (pick any)
		public ??_C@_07CIFAGBMG@unknown?$AA@
; `string'
??_C@_07CIFAGBMG@unknown?$AA@ db 'unknown',0 ; DATA XREF: _SSL_get_version+70o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 41A8h
; COMDAT (pick any)
		public ??_C@_0CM@NMJLCBPB@ssl?9?$DOsid_ctx_length?5?$DM?$DN?5sizeof?$CIss@
; `string'
??_C@_0CM@NMJLCBPB@ssl?9?$DOsid_ctx_length?5?$DM?$DN?5sizeof?$CIss@ db 'ssl->sid_ctx_length <= sizeof(ssl->sid_ctx)',0
					; DATA XREF: _SSL_set_SSL_CTX+F3o
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; __time64_t __cdecl __time64(__time64_t *Time)
		extrn __imp___time64:near ; CODE XREF: _ssl_update_cache+CAp
					; DATA XREF: _ssl_update_cache+CAr ...
		extrn _BUF_MEM_free:near ; CODE	XREF: _SSL_clear+D5p
					; _SSL_free+ADp
		extrn _BUF_strdup:near	; CODE XREF: _SSL_CTX_use_psk_identity_hint+60p
					; _SSL_use_psk_identity_hint+7Dp
		extrn _BUF_memdup:near	; CODE XREF: _SSL_new+259p
					; _SSL_new+28Cp ...
		extrn _sk_num:near	; CODE XREF: _SSL_CTX_new+211p
					; _SSL_CTX_set_cipher_list+25p	...
		extrn _sk_value:near	; CODE XREF: _SSL_dup+25Ap
					; _SSL_get_cipher_list+35p ...
		extrn _sk_set:near	; CODE XREF: _SSL_dup+26Ap
		extrn _sk_new_null:near	; CODE XREF: _SSL_CTX_new:loc_93Dp
					; _ssl_bytes_to_cipher_list:loc_3243p
		extrn _sk_free:near	; CODE XREF: _SSL_CTX_free+8Dp
					; _SSL_CTX_free+9Dp ...
		extrn _sk_pop_free:near	; CODE XREF: _SSL_CTX_free+C8p
					; _SSL_CTX_free+E0p ...
		extrn _sk_push:near	; CODE XREF: _ssl_bytes_to_cipher_list+16Ep
		extrn _sk_zero:near	; CODE XREF: _ssl_bytes_to_cipher_list+53p
		extrn _sk_dup:near	; CODE XREF: _SSL_dup+200p
					; _SSL_dup+21Bp ...
		extrn _CRYPTO_get_ex_new_index:near
					; CODE XREF: _SSL_CTX_get_ex_new_index+16p
					; _SSL_get_ex_new_index+16p
		extrn _CRYPTO_new_ex_data:near ; CODE XREF: _SSL_CTX_new+2D2p
					; _SSL_new+35Bp
		extrn _CRYPTO_dup_ex_data:near ; CODE XREF: _SSL_dup+13Ep
		extrn _CRYPTO_free_ex_data:near	; CODE XREF: _SSL_CTX_free+5Dp
					; _SSL_free+4Cp
		extrn _CRYPTO_set_ex_data:near ; CODE XREF: _SSL_CTX_set_ex_data+5j
					; _SSL_set_ex_data+8j
		extrn _CRYPTO_get_ex_data:near ; CODE XREF: _SSL_CTX_get_ex_data+5j
					; _SSL_get_ex_data+8j
		extrn _CRYPTO_lock:near	; CODE XREF: _SSL_CTX_set_generate_session_id+Ep
					; _SSL_CTX_set_generate_session_id+2Fp	...
		extrn _CRYPTO_add_lock:near ; CODE XREF: _SSL_CTX_free+1Fp
					; _SSL_copy_session_id+5Cp ...
		extrn _CRYPTO_malloc:near ; CODE XREF: _SSL_CTX_new+92p
					; _SSL_CTX_new+3C1p ...
		extrn _CRYPTO_free:near	; CODE XREF: _SSL_CTX_free+110p
					; _SSL_CTX_free+165p ...
		extrn _OpenSSLDie:near	; CODE XREF: _SSL_new+145p
					; _SSL_set_SSL_CTX+102p
		extrn _COMP_CTX_free:near ; CODE XREF: _ssl_clear_cipher_ctx+60p
					; _ssl_clear_cipher_ctx+7Dp
		extrn _BIO_test_flags:near ; CODE XREF:	_SSL_get_error+4Cp
					; _SSL_get_error+5Bp ...
		extrn _BIO_method_type:near ; CODE XREF: _SSL_set_rfd+Ep
					; _SSL_set_wfd+Ep
		extrn _BIO_new:near	; CODE XREF: _SSL_set_fd+7p
					; _SSL_set_rfd+50p ...
		extrn _BIO_free:near	; CODE XREF: _SSL_free+71p
					; _ssl_free_wbio_buffer+22p
		extrn _BIO_ctrl:near	; CODE XREF: _SSL_dup+15Ep
					; _SSL_dup+183p ...
		extrn _BIO_int_ctrl:near ; CODE	XREF: _SSL_set_fd+3Dp
					; _SSL_set_rfd+87p ...
		extrn _BIO_push:near	; CODE XREF: _ssl_init_wbio_buffer+88p
		extrn _BIO_pop:near	; CODE XREF: _SSL_free+63p
					; _ssl_free_wbio_buffer+14p ...
		extrn _BIO_free_all:near ; CODE	XREF: _SSL_free+88p
					; _SSL_free+9Dp ...
		extrn _BIO_find_type:near ; CODE XREF: _SSL_get_fd+1Ep
					; _SSL_get_rfd+1Ep ...
		extrn _BIO_get_retry_reason:near ; CODE	XREF: _SSL_get_error+BFp
		extrn _BIO_s_socket:near ; CODE	XREF: _SSL_set_fd+1p
					; _SSL_set_rfd:loc_2D3Ap ...
		extrn _BIO_f_buffer:near ; CODE	XREF: _ssl_init_wbio_buffer+Dp
		extrn _RSA_size:near	; CODE XREF: _ssl_set_cert_masks+63p
		extrn _DH_size:near	; CODE XREF: _ssl_set_cert_masks+A8p
		extrn _lh_new:near	; CODE XREF: _SSL_CTX_new+1B8p
		extrn _lh_free:near	; CODE XREF: _SSL_CTX_free+6Dp
		extrn _lh_retrieve:near	; CODE XREF: _SSL_has_matching_session_id+B4p
		extrn _lh_num_items:near ; CODE	XREF: _SSL_CTX_ctrl+C9p
		extrn _ERR_put_error:near ; CODE XREF: _ssl_undefined_function+13p
					; _SSL_CTX_check_private_key+37p ...
		extrn _ERR_peek_error:near ; CODE XREF:	_SSL_get_error:loc_1C01p
		extrn _OBJ_obj2nid:near	; CODE XREF: _ssl_check_srvr_ecc_cert_and_alg+8Fp
					; _ssl_set_cert_masks+327p
		extrn _OBJ_bsearch_:near ; CODE	XREF: _OBJ_bsearch_ssl_cipher_id+13p
		extrn _OBJ_find_sigid_algs:near
					; CODE XREF: _ssl_check_srvr_ecc_cert_and_alg+9Fp
					; _ssl_set_cert_masks+337p
		extrn _EVP_MD_CTX_create:near ;	CODE XREF: _ssl_replace_hash+1Ap
		extrn _EVP_MD_CTX_destroy:near ; CODE XREF: _SSL_clear+F8p
					; _SSL_clear+115p ...
		extrn _EVP_DigestInit_ex:near ;	CODE XREF: _ssl_replace_hash+31p
		extrn _EVP_CIPHER_CTX_cleanup:near ; CODE XREF:	_ssl_clear_cipher_ctx+10p
					; _ssl_clear_cipher_ctx+38p
		extrn _EVP_get_digestbyname:near ; CODE	XREF: _SSL_CTX_new+239p
					; _SSL_CTX_new+264p ...
		extrn _EVP_PKEY_bits:near ; CODE XREF: _ssl_check_srvr_ecc_cert_and_alg+57p
					; _ssl_set_cert_masks+2F2p
		extrn _EVP_PKEY_size:near ; CODE XREF: _ssl_set_cert_masks+FAp
					; _ssl_set_cert_masks+145p ...
		extrn _EVP_PKEY_free:near ; CODE XREF: _ssl_check_srvr_ecc_cert_and_alg+5Fp
					; _ssl_set_cert_masks+30Dp
		extrn _X509_STORE_new:near ; CODE XREF:	_SSL_CTX_new+1CBp
		extrn _X509_STORE_free:near ; CODE XREF: _SSL_CTX_free+7Dp
					; _SSL_CTX_set_cert_store+Dp
		extrn _X509_STORE_load_locations:near
					; CODE XREF: _SSL_CTX_load_verify_locations+Fp
		extrn _X509_STORE_set_default_paths:near
					; CODE XREF: _SSL_CTX_set_default_verify_paths+7p
		extrn _X509_VERIFY_PARAM_new:near ; CODE XREF: _SSL_CTX_new+221p
					; _SSL_new+181p
		extrn _X509_VERIFY_PARAM_free:near ; CODE XREF:	_SSL_CTX_free+3Ap
					; _SSL_free+3Ap
		extrn _X509_VERIFY_PARAM_inherit:near ;	CODE XREF: _SSL_dup+1F0p
					; _SSL_new+199p
		extrn _X509_VERIFY_PARAM_set1:near ; CODE XREF:	_SSL_CTX_set1_param+Ep
					; _SSL_set1_param+Bp
		extrn _X509_VERIFY_PARAM_set_purpose:near
					; CODE XREF: _SSL_CTX_set_purpose+Ep
					; _SSL_set_purpose+Bp
		extrn _X509_VERIFY_PARAM_set_trust:near	; CODE XREF: _SSL_CTX_set_trust+Ep
					; _SSL_set_trust+Bp
		extrn _X509_VERIFY_PARAM_set_depth:near
					; CODE XREF: _SSL_CTX_set_verify_depth+Ep
					; _SSL_dup+105p ...
		extrn _X509_VERIFY_PARAM_get_depth:near
					; CODE XREF: _SSL_CTX_get_verify_depth+Ap
					; _SSL_dup+FCp	...
		extrn _X509_NAME_dup:near ; CODE XREF: _SSL_dup+262p
		extrn _X509_EXTENSION_free:near	; DATA XREF: _SSL_free+1B1o
		extrn _X509_NAME_free:near ; CODE XREF:	_SSL_dup+28Cp
					; DATA XREF: _SSL_CTX_free+C2o	...
		extrn _X509_free:near	; DATA XREF: _SSL_CTX_free+DAo
		extrn _X509_get_pubkey:near
					; CODE XREF: _ssl_check_srvr_ecc_cert_and_alg+43p
					; _ssl_set_cert_masks+2E1p
		extrn _X509_check_private_key:near
					; CODE XREF: _SSL_CTX_check_private_key+44p
					; _SSL_check_private_key+A4p
		extrn _SSL_CTX_SRP_CTX_init:near ; CODE	XREF: _SSL_CTX_new+3A6p
		extrn _SSL_CTX_SRP_CTX_free:near ; CODE	XREF: _SSL_CTX_free+119p
		extrn _SSL_CTX_flush_sessions:near ; CODE XREF:	_SSL_CTX_free+4Bp
					; _ssl_update_cache+D7p
		extrn _SSL_SESSION_free:near ; CODE XREF: _SSL_clear+40p
					; _SSL_free+EAp ...
		extrn _SSL_set_session:near ; CODE XREF: _SSL_copy_session_id+12p
		extrn _SSL_CTX_add_session:near	; CODE XREF: _ssl_update_cache+48p
		extrn _SSL_get_session:near ; CODE XREF: _SSL_copy_session_id+7p
		extrn _SSL_get_ex_data_X509_STORE_CTX_idx:near
					; CODE XREF: _SSL_CTX_new:loc_6B7p
		extrn _SSL_COMP_get_compression_methods:near ; CODE XREF: _SSL_CTX_new+2EDp
		extrn _ssl_clear_bad_session:near ; CODE XREF: _SSL_clear+2Ep
					; _SSL_free+DFp
		extrn _ssl_cert_new:near ; CODE	XREF: _SSL_CTX_new+178p
		extrn _ssl_cert_dup:near ; CODE	XREF: _SSL_dup+7Bp
					; _SSL_new+B9p	...
		extrn _ssl_cert_clear_certs:near ; CODE	XREF: _SSL_certs_clear+Ap
		extrn _ssl_cert_free:near ; CODE XREF: _SSL_CTX_free+B0p
					; _SSL_copy_session_id+81p ...
		extrn _ssl_create_cipher_list:near ; CODE XREF:	_SSL_CTX_new+1FDp
					; _SSL_CTX_set_cipher_list+18p	...
		extrn _ssl_cipher_get_cert_index:near
					; CODE XREF: _ssl_get_server_cert_index+Fp
					; _ssl_get_server_cert_serverinfo+20p
		extrn _ssl_get_cipher_by_char:near
					; CODE XREF: _ssl_bytes_to_cipher_list+15Ep
		extrn _ssl_cert_set_cert_cb:near ; CODE	XREF: _SSL_CTX_set_cert_cb+12p
					; _SSL_set_cert_cb+12p
		extrn _ssl3_send_alert:near ; CODE XREF: _ssl_bytes_to_cipher_list+1C5p
					; _ssl_bytes_to_cipher_list+1F8p
		extrn _tls1_set_curves_list:near ; CODE	XREF: _SSL_CTX_ctrl+37p
		extrn _tls1_set_sigalgs_list:near ; CODE XREF: _SSL_CTX_ctrl+26p
		extrn _ssl_set_client_disabled:near
					; CODE XREF: _ssl_cipher_list_to_bytes+27p
		extrn _X509_check_purpose:near
					; CODE XREF: _ssl_check_srvr_ecc_cert_and_alg+79p
					; _ssl_set_cert_masks+291p
		extrn _RAND_bytes:near	; CODE XREF: _SSL_CTX_new+334p
					; _SSL_CTX_new+349p
		extrn _RAND_pseudo_bytes:near ;	CODE XREF: _SSL_CTX_new+31Fp
		extrn _OCSP_RESPID_free:near ; DATA XREF: _SSL_free+1C9o
		extrn _ENGINE_finish:near ; CODE XREF: _SSL_CTX_free+12Cp
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: _SSL_has_matching_session_id+41p
					; _SSL_has_matching_session_id+E3p
		extrn __chkstk:near	; CODE XREF: _SSL_get_fd+5p
					; _SSL_get_rfd+5p ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _SSL_CTX_set_alpn_protos+48p
					; _SSL_CTX_set_session_id_context+3Fp ...
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _SSL_CTX_new+A8p
					; _SSL_CTX_new+101p ...
		extrn ___security_cookie:near ;	DATA XREF: _SSL_has_matching_session_id+Ar


		end
