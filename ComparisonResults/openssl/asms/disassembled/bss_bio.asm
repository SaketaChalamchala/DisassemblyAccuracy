;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	5DD30216A66798639903CDF5D5778E40
; Input	CRC32 :	F9D8DBEB

; File Name   :	C:\compspace\Diff\openssl\obj\bss_bio.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_bio_new	proc near		; DATA XREF: .data:00000584o

arg_0		= dword	ptr  4

		push	93h ; 'ì'
		push	offset ??_C@_0BH@BEKGBHJN@?4?2crypto?2bio?2bss_bio?4c?$AA@ ; ".\\crypto\\bio\\bss_bio.c"
		push	1Ch
		call	_CRYPTO_malloc
		mov	ecx, eax
		add	esp, 0Ch
		test	ecx, ecx
		jnz	short loc_1B
		retn
; ---------------------------------------------------------------------------

loc_1B:					; CODE XREF: _bio_new+18j
		mov	eax, [esp+arg_0]
		mov	dword ptr [ecx], 0
		mov	dword ptr [ecx+10h], 4400h
		mov	dword ptr [ecx+14h], 0
		mov	[eax+20h], ecx
		mov	eax, 1
		retn
_bio_new	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_bio_free	proc near		; DATA XREF: .data:00000588o

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jnz	short loc_45
		retn
; ---------------------------------------------------------------------------

loc_45:					; CODE XREF: _bio_free+6j
		push	esi
		mov	esi, [eax+20h]
		cmp	dword ptr [esi], 0
		jz	short loc_57
		push	eax
		call	_bio_destroy_pair
		add	esp, 4

loc_57:					; CODE XREF: _bio_free+10j
		mov	eax, [esi+14h]
		test	eax, eax
		jz	short loc_67
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_67:					; CODE XREF: _bio_free+20j
		push	esi
		call	_CRYPTO_free
		add	esp, 4
		mov	eax, 1
		pop	esi
		retn
_bio_free	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 78h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl bio_read(int, void *Dst, int)
_bio_read	proc near		; CODE XREF: _bio_nread0+38p
					; DATA XREF: .data:00000574o

arg_0		= dword	ptr  4
Dst		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	edi
		mov	edi, [esp+4+arg_0]
		push	0Fh
		push	edi
		call	_BIO_clear_flags
		add	esp, 8
		cmp	dword ptr [edi+0Ch], 0
		jnz	short loc_92
		xor	eax, eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_92:					; CODE XREF: _bio_read+14j
		mov	eax, [edi+20h]
		push	ebx
		push	ebp
		mov	ebp, [esp+0Ch+Dst]
		push	esi
		mov	esi, [eax]
		mov	esi, [esi+20h]
		mov	dword ptr [esi+18h], 0
		test	ebp, ebp
		jz	loc_140
		mov	ebx, [esp+10h+arg_8]
		test	ebx, ebx
		jz	loc_140
		mov	eax, [esi+8]
		test	eax, eax
		jnz	short loc_E6
		cmp	[esi+4], eax
		jnz	short loc_140
		push	9
		push	edi
		call	_BIO_set_flags
		mov	eax, [esi+10h]
		add	esp, 8
		cmp	ebx, eax
		cmovbe	eax, ebx
		mov	[esi+18h], eax
		or	eax, 0FFFFFFFFh
		pop	esi
		pop	ebp
		pop	ebx
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_E6:					; CODE XREF: _bio_read+49j
		cmp	eax, ebx
		cmovb	ebx, eax
		mov	[esp+10h+arg_8], ebx

loc_EF:					; CODE XREF: _bio_read+BDj
		mov	eax, [esi+0Ch]
		mov	edi, [esi+10h]
		sub	edi, eax
		lea	ecx, [eax+ebx]
		mov	eax, [esi+14h]
		cmp	ecx, [esi+10h]
		cmovbe	edi, ebx
		add	eax, [esi+0Ch]
		push	edi		; Size
		push	eax		; Src
		push	ebp		; Dst
		call	_memcpy
		add	esp, 0Ch
		sub	[esi+8], edi
		jz	short loc_12C
		add	[esi+0Ch], edi
		mov	eax, [esi+0Ch]
		cmp	eax, [esi+10h]
		jnz	short loc_128
		mov	dword ptr [esi+0Ch], 0

loc_128:				; CODE XREF: _bio_read+A7j
		add	ebp, edi
		jmp	short loc_133
; ---------------------------------------------------------------------------

loc_12C:				; CODE XREF: _bio_read+9Cj
		mov	dword ptr [esi+0Ch], 0

loc_133:				; CODE XREF: _bio_read+B2j
		sub	ebx, edi
		jnz	short loc_EF
		mov	eax, [esp+10h+arg_8]
		pop	esi
		pop	ebp
		pop	ebx
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_140:				; CODE XREF: _bio_read+32j
					; _bio_read+3Ej ...
		pop	esi
		pop	ebp
		pop	ebx
		xor	eax, eax
		pop	edi
		retn
_bio_read	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 148h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl bio_write(int, void *Src,	int)
_bio_write	proc near		; CODE XREF: _bio_puts+1Fp
					; DATA XREF: .data:00000570o

arg_0		= dword	ptr  4
Src		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebp
		push	esi
		mov	esi, [esp+8+arg_0]
		push	0Fh
		push	esi
		call	_BIO_clear_flags
		add	esp, 8
		cmp	dword ptr [esi+0Ch], 0
		jz	loc_215
		mov	ebp, [esp+8+Src]
		test	ebp, ebp
		jz	loc_215
		mov	eax, [esp+8+arg_8]
		test	eax, eax
		jz	loc_215
		push	edi
		mov	edi, [esi+20h]
		cmp	dword ptr [edi+4], 0
		mov	dword ptr [edi+18h], 0
		jz	short loc_1AB
		push	168h
		push	offset ??_C@_0BH@BEKGBHJN@?4?2crypto?2bio?2bss_bio?4c?$AA@ ; ".\\crypto\\bio\\bss_bio.c"
		push	7Ch ; '|'
		push	71h ; 'q'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		pop	edi
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1AB:				; CODE XREF: _bio_write+42j
		mov	edx, [edi+8]
		mov	ecx, [edi+10h]
		cmp	edx, ecx
		jnz	short loc_1C7
		push	0Ah
		push	esi
		call	_BIO_set_flags
		add	esp, 8
		or	eax, 0FFFFFFFFh
		pop	edi
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1C7:				; CODE XREF: _bio_write+6Bj
		sub	ecx, edx
		cmp	eax, ecx
		push	ebx
		cmova	eax, ecx
		mov	[esp+10h+arg_8], eax
		mov	ebx, eax
		nop	dword ptr [eax]

loc_1D8:				; CODE XREF: _bio_write+C2j
		mov	eax, [edi+0Ch]
		add	eax, [edi+8]
		mov	edx, [edi+10h]
		cmp	eax, edx
		jb	short loc_1E7
		sub	eax, edx

loc_1E7:				; CODE XREF: _bio_write+9Bj
		lea	ecx, [eax+ebx]
		mov	esi, edx
		sub	esi, eax
		cmp	ecx, edx
		mov	ecx, [edi+14h]
		cmovbe	esi, ebx
		add	ecx, eax
		push	esi		; Size
		push	ebp		; Src
		push	ecx		; Dst
		call	_memcpy
		add	[edi+8], esi
		add	esp, 0Ch
		add	ebp, esi
		sub	ebx, esi
		jnz	short loc_1D8
		mov	eax, [esp+10h+arg_8]
		pop	ebx
		pop	edi
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_215:				; CODE XREF: _bio_write+15j
					; _bio_write+21j ...
		pop	esi
		xor	eax, eax
		pop	ebp
		retn
_bio_write	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 21Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl bio_ctrl(int Dst,	int, int, int)
_bio_ctrl	proc near		; DATA XREF: .data:00000580o

Dst		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, [esp+arg_4]
		push	ebx
		mov	ebx, [esp+4+Dst]
		dec	eax
		push	esi
		push	edi
		mov	edi, [ebx+20h]
		cmp	eax, 92h ; 'í'  ; switch 147 cases
		ja	short $LN42	; jumptable 00000239 default case
		movzx	eax, ds:$LN52[eax]
		jmp	ds:$LN56[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN4:					; CODE XREF: _bio_ctrl+1Dj
					; DATA XREF: .text$mn:$LN56o
		cmp	dword ptr [edi], 0 ; jumptable 00000239	case 135
		jz	short loc_265
		push	1F5h
		push	offset ??_C@_0BH@BEKGBHJN@?4?2crypto?2bio?2bss_bio?4c?$AA@ ; ".\\crypto\\bio\\bss_bio.c"
		push	7Bh ; '{'
		push	67h ; 'g'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 14h

$LN42:					; CODE XREF: _bio_ctrl+14j
					; _bio_ctrl+1Dj ...
		xor	esi, esi	; jumptable 00000239 default case

loc_25F:				; CODE XREF: _bio_ctrl+17Cj
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_265:				; CODE XREF: _bio_ctrl+27j
		mov	esi, [esp+0Ch+arg_8]
		test	esi, esi
		jnz	short loc_28B
		push	1F8h
		push	offset ??_C@_0BH@BEKGBHJN@?4?2crypto?2bio?2bss_bio?4c?$AA@ ; ".\\crypto\\bio\\bss_bio.c"
		push	7Dh ; '}'
		push	67h ; 'g'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 14h
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_28B:				; CODE XREF: _bio_ctrl+4Fj
		cmp	[edi+10h], esi
		jz	short $LN9	; jumptable 00000239 case 10
		mov	eax, [edi+14h]
		test	eax, eax
		jz	short loc_2A7
		push	eax
		call	_CRYPTO_free
		add	esp, 4
		mov	dword ptr [edi+14h], 0

loc_2A7:				; CODE XREF: _bio_ctrl+79j
		mov	[edi+10h], esi

$LN9:					; CODE XREF: _bio_ctrl+1Dj
					; _bio_ctrl+72j ...
		mov	esi, 1		; jumptable 00000239 case 10
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN11:					; CODE XREF: _bio_ctrl+1Dj
					; DATA XREF: .text$mn:$LN56o
		mov	esi, [edi+10h]	; jumptable 00000239 case 136
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN12:					; CODE XREF: _bio_ctrl+1Dj
					; DATA XREF: .text$mn:$LN56o
		push	[esp+0Ch+arg_C]	; jumptable 00000239 case 137
		push	ebx
		call	_bio_make_pair
		add	esp, 8
		mov	esi, eax
		neg	esi
		sbb	esi, esi
		neg	esi
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN15:					; CODE XREF: _bio_ctrl+1Dj
					; DATA XREF: .text$mn:$LN56o
		push	ebx		; jumptable 00000239 case 138
		call	_bio_destroy_pair
		add	esp, 4
		mov	esi, 1
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN16:					; CODE XREF: _bio_ctrl+1Dj
					; DATA XREF: .text$mn:$LN56o
		cmp	dword ptr [edi], 0 ; jumptable 00000239	case 139
		jz	$LN42		; jumptable 00000239 default case
		cmp	dword ptr [edi+4], 0
		jnz	$LN42		; jumptable 00000239 default case
		mov	esi, [edi+10h]
		sub	esi, [edi+8]
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN20:					; CODE XREF: _bio_ctrl+1Dj
					; DATA XREF: .text$mn:$LN56o
		mov	esi, [edi+18h]	; jumptable 00000239 case 140
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN21:					; CODE XREF: _bio_ctrl+1Dj
					; DATA XREF: .text$mn:$LN56o
		mov	esi, 1		; jumptable 00000239 case 146
		mov	dword ptr [edi+18h], 0
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN22:					; CODE XREF: _bio_ctrl+1Dj
					; DATA XREF: .text$mn:$LN56o
		mov	esi, 1		; jumptable 00000239 case 141
		mov	dword ptr [edi+4], 1
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN23:					; CODE XREF: _bio_ctrl+1Dj
					; DATA XREF: .text$mn:$LN56o
		push	[esp+0Ch+arg_C]	; jumptable 00000239 case 142
		push	ebx		; Dst
		call	_bio_nread0
		add	esp, 8
		mov	esi, eax
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN24:					; CODE XREF: _bio_ctrl+1Dj
					; DATA XREF: .text$mn:$LN56o
		push	[esp+0Ch+arg_8]	; jumptable 00000239 case 143
		push	[esp+10h+arg_C]	; int
		push	ebx		; Dst
		call	_bio_nread
		add	esp, 0Ch
		mov	esi, eax
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN25:					; CODE XREF: _bio_ctrl+1Dj
					; DATA XREF: .text$mn:$LN56o
		push	[esp+0Ch+arg_C]	; jumptable 00000239 case 144
		push	ebx
		call	_bio_nwrite0
		add	esp, 8
		mov	esi, eax
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN26:					; CODE XREF: _bio_ctrl+1Dj
					; DATA XREF: .text$mn:$LN56o
		mov	esi, [esp+0Ch+arg_8] ; jumptable 00000239 case 145
		mov	eax, 7FFFFFFFh
		push	[esp+0Ch+arg_C]
		cmp	esi, eax
		push	ebx
		cmova	esi, eax
		call	_bio_nwrite0
		add	esp, 8
		cmp	esi, eax
		cmovg	esi, eax
		test	esi, esi
		jle	loc_25F
		mov	eax, [ebx+20h]
		pop	edi
		add	[eax+8], esi
		mov	eax, esi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN27:					; CODE XREF: _bio_ctrl+1Dj
					; DATA XREF: .text$mn:$LN56o
		cmp	dword ptr [edi+14h], 0 ; jumptable 00000239 case 0
		jz	$LN42		; jumptable 00000239 default case
		xor	esi, esi
		mov	dword ptr [edi+8], 0
		mov	dword ptr [edi+0Ch], 0
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN29:					; CODE XREF: _bio_ctrl+1Dj
					; DATA XREF: .text$mn:$LN56o
		mov	esi, [ebx+10h]	; jumptable 00000239 case 7
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN30:					; CODE XREF: _bio_ctrl+1Dj
					; DATA XREF: .text$mn:$LN56o
		mov	eax, [esp+0Ch+arg_8] ; jumptable 00000239 case 8
		mov	esi, 1
		mov	[ebx+10h], eax
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN31:					; CODE XREF: _bio_ctrl+1Dj
					; DATA XREF: .text$mn:$LN56o
		mov	eax, [edi]	; jumptable 00000239 case 9
		test	eax, eax
		jz	$LN42		; jumptable 00000239 default case
		mov	eax, [eax+20h]
		pop	edi
		mov	esi, [eax+8]
		mov	eax, esi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN34:					; CODE XREF: _bio_ctrl+1Dj
					; DATA XREF: .text$mn:$LN56o
		cmp	dword ptr [edi+14h], 0 ; jumptable 00000239 case 12
		jz	$LN42		; jumptable 00000239 default case
		mov	esi, [edi+8]
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN37:					; CODE XREF: _bio_ctrl+1Dj
					; DATA XREF: .text$mn:$LN56o
		mov	eax, [esp+0Ch+arg_C] ; jumptable 00000239 case 11

loc_412:				; DATA XREF: .data:_methods_biopo
		mov	esi, 1
		mov	ecx, [eax+20h]
		mov	eax, [edi+10h]
		pop	edi
		mov	[ecx+10h], eax
		mov	eax, esi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN39:					; CODE XREF: _bio_ctrl+1Dj
					; DATA XREF: .text$mn:$LN56o
		mov	eax, [esp+0Ch+arg_C] ; jumptable 00000239 case 1
		test	eax, eax
		jz	$LN9		; jumptable 00000239 case 10
		mov	eax, [eax+20h]
		cmp	dword ptr [eax+8], 0
		jnz	$LN42		; jumptable 00000239 default case
		cmp	dword ptr [eax+4], 0
		jz	$LN42		; jumptable 00000239 default case
		mov	esi, 1
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebx
		retn
_bio_ctrl	endp

; ---------------------------------------------------------------------------
$LN56		dd offset $LN27, offset	$LN39, offset $LN29, offset $LN30
					; DATA XREF: _bio_ctrl+1Dr
		dd offset $LN31, offset	$LN9, offset $LN37, offset $LN34 ; jump	table for switch statement
		dd offset $LN4,	offset $LN11, offset $LN12, offset $LN15
		dd offset $LN16, offset	$LN20, offset $LN22, offset $LN23
		dd offset $LN24, offset	$LN25, offset $LN26, offset $LN21
		dd offset $LN42
$LN52		db	0,     1,   14h,   14h ; DATA XREF: _bio_ctrl+16r
		db    14h,   14h,   14h,     2 ; indirect table	for switch statement
		db	3,     4,     5,     6
		db	7,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,   14h
		db    14h,   14h,   14h,     8
		db	9,   0Ah,   0Bh,   0Ch
		db    0Dh,   0Eh,   0Fh,   10h
		db    11h,   12h,   13h
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 53Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl bio_puts(int, void *Src)
_bio_puts	proc near		; DATA XREF: .data:00000578o

arg_0		= dword	ptr  4
Src		= dword	ptr  8

		mov	edx, [esp+Src]
		mov	eax, edx
		push	esi
		lea	esi, [eax+1]
		nop	word ptr [eax+eax+00h]

loc_54C:				; CODE XREF: _bio_puts+15j
		mov	cl, [eax]
		inc	eax
		test	cl, cl
		jnz	short loc_54C
		sub	eax, esi
		push	eax		; int
		push	edx		; Src
		push	[esp+0Ch+arg_0]	; int
		call	_bio_write
		add	esp, 0Ch
		pop	esi
		retn
_bio_puts	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 568h
_methods_biop	dd offset loc_412+1	; DATA XREF: _BIO_new_bio_pair+3o
					; _BIO_new_bio_pair+1Eo ...
		dd offset ??_C@_08EKOIICMC@BIO?5pair?$AA@ ; "BIO pair"
		dd offset _bio_write
		dd offset _bio_read
		dd offset _bio_puts
		align 10h
		dd offset _bio_ctrl
		dd offset _bio_new
		dd offset _bio_free
		align 10h
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 590h
; COMDAT (pick any)
		public ??_C@_08EKOIICMC@BIO?5pair?$AA@
; `string'
??_C@_08EKOIICMC@BIO?5pair?$AA@	db 'BIO pair',0 ; DATA XREF: .data:0000056Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 59Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_ctrl_get_read_request
_BIO_ctrl_get_read_request proc	near

arg_0		= dword	ptr  4

		push	0
		push	0
		push	8Dh ; 'ç'
		push	[esp+0Ch+arg_0]
		call	_BIO_ctrl
		add	esp, 10h
		retn
_BIO_ctrl_get_read_request endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5B4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_ctrl_get_write_guarantee
_BIO_ctrl_get_write_guarantee proc near

arg_0		= dword	ptr  4

		push	0
		push	0
		push	8Ch ; 'å'
		push	[esp+0Ch+arg_0]
		call	_BIO_ctrl
		add	esp, 10h
		retn
_BIO_ctrl_get_write_guarantee endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5CCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_ctrl_reset_read_request
_BIO_ctrl_reset_read_request proc near

arg_0		= dword	ptr  4

		push	0
		push	0
		push	93h ; 'ì'
		push	[esp+0Ch+arg_0]
		call	_BIO_ctrl
		add	esp, 10h
		neg	eax
		sbb	eax, eax
		neg	eax
		retn
_BIO_ctrl_reset_read_request endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5E8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_new_bio_pair
_BIO_new_bio_pair proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	ebx
		push	esi
		push	edi
		push	offset _methods_biop
		xor	esi, esi
		xor	ebx, ebx
		call	_BIO_new
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jz	loc_698
		push	offset _methods_biop
		call	_BIO_new
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jz	short loc_67E
		mov	eax, [esp+0Ch+arg_4]
		test	eax, eax
		jz	short loc_635
		push	ebx
		push	eax
		push	88h ; 'à'
		push	edi
		call	_BIO_ctrl
		add	esp, 10h
		test	eax, eax
		jz	short loc_67E

loc_635:				; CODE XREF: _BIO_new_bio_pair+37j
		mov	eax, [esp+0Ch+arg_C]
		test	eax, eax
		jz	short loc_652
		push	0
		push	eax
		push	88h ; 'à'
		push	esi
		call	_BIO_ctrl
		add	esp, 10h
		test	eax, eax
		jz	short loc_67E

loc_652:				; CODE XREF: _BIO_new_bio_pair+53j
		push	esi
		push	0
		push	8Ah ; 'ä'
		push	edi
		call	_BIO_ctrl
		add	esp, 10h
		test	eax, eax
		jz	short loc_67E
		mov	ecx, [esp+0Ch+arg_0]
		mov	ebx, 1
		mov	eax, ebx
		mov	[ecx], edi
		mov	ecx, [esp+0Ch+arg_8]
		pop	edi
		mov	[ecx], esi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_67E:				; CODE XREF: _BIO_new_bio_pair+2Fj
					; _BIO_new_bio_pair+4Bj ...
		push	edi
		call	_BIO_free
		add	esp, 4
		xor	edi, edi
		test	esi, esi
		jz	short loc_698
		push	esi
		call	_BIO_free
		add	esp, 4
		xor	esi, esi

loc_698:				; CODE XREF: _BIO_new_bio_pair+18j
					; _BIO_new_bio_pair+A3j
		mov	ecx, [esp+0Ch+arg_0]
		mov	eax, ebx
		mov	[ecx], edi
		mov	ecx, [esp+0Ch+arg_8]
		pop	edi
		mov	[ecx], esi
		pop	esi
		pop	ebx
		retn
_BIO_new_bio_pair endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6ACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_nread
_BIO_nread	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_0]
		cmp	dword ptr [esi+0Ch], 0
		jnz	short loc_6D6
		push	34Fh
		push	offset ??_C@_0BH@BEKGBHJN@?4?2crypto?2bio?2bss_bio?4c?$AA@ ; ".\\crypto\\bio\\bss_bio.c"
		push	78h ; 'x'
		push	7Bh ; '{'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 14h
		mov	eax, 0FFFFFFFEh
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_6D6:				; CODE XREF: _BIO_nread+9j
		push	[esp+4+arg_4]
		push	[esp+8+arg_8]
		push	90h ; 'ê'
		push	esi
		call	_BIO_ctrl
		add	esp, 10h
		test	eax, eax
		jle	short loc_6F3
		add	[esi+30h], eax

loc_6F3:				; CODE XREF: _BIO_nread+42j
		pop	esi
		retn
_BIO_nread	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6F8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_nread0
_BIO_nread0	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		cmp	dword ptr [eax+0Ch], 0
		jnz	short loc_720
		push	33Fh
		push	offset ??_C@_0BH@BEKGBHJN@?4?2crypto?2bio?2bss_bio?4c?$AA@ ; ".\\crypto\\bio\\bss_bio.c"
		push	78h ; 'x'
		push	7Ch ; '|'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 14h
		mov	eax, 0FFFFFFFEh
		retn
; ---------------------------------------------------------------------------

loc_720:				; CODE XREF: _BIO_nread0+8j
		push	[esp+arg_4]
		push	0
		push	8Fh ; 'è'
		push	eax
		call	_BIO_ctrl
		mov	ecx, 7FFFFFFFh
		add	esp, 10h
		cmp	eax, ecx
		cmovg	eax, ecx
		retn
_BIO_nread0	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 740h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_nwrite
_BIO_nwrite	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_0]
		cmp	dword ptr [esi+0Ch], 0
		jnz	short loc_76A
		push	36Eh
		push	offset ??_C@_0BH@BEKGBHJN@?4?2crypto?2bio?2bss_bio?4c?$AA@ ; ".\\crypto\\bio\\bss_bio.c"
		push	78h ; 'x'
		push	7Dh ; '}'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 14h
		mov	eax, 0FFFFFFFEh
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_76A:				; CODE XREF: _BIO_nwrite+9j
		push	[esp+4+arg_4]
		push	[esp+8+arg_8]
		push	92h ; 'í'
		push	esi
		call	_BIO_ctrl
		add	esp, 10h
		test	eax, eax
		jle	short loc_787
		add	[esi+34h], eax

loc_787:				; CODE XREF: _BIO_nwrite+42j
		pop	esi
		retn
_BIO_nwrite	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 78Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_nwrite0
_BIO_nwrite0	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		cmp	dword ptr [eax+0Ch], 0
		jnz	short loc_7B4
		push	35Eh
		push	offset ??_C@_0BH@BEKGBHJN@?4?2crypto?2bio?2bss_bio?4c?$AA@ ; ".\\crypto\\bio\\bss_bio.c"
		push	78h ; 'x'
		push	7Ah ; 'z'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 14h
		mov	eax, 0FFFFFFFEh
		retn
; ---------------------------------------------------------------------------

loc_7B4:				; CODE XREF: _BIO_nwrite0+8j
		push	[esp+arg_4]
		push	0
		push	91h ; 'ë'
		push	eax
		call	_BIO_ctrl
		mov	ecx, 7FFFFFFFh
		add	esp, 10h
		cmp	eax, ecx
		cmovg	eax, ecx
		retn
_BIO_nwrite0	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7D4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_s_bio
_BIO_s_bio	proc near
		mov	eax, offset _methods_biop
		retn
_BIO_s_bio	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7DCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_bio_destroy_pair proc near		; CODE XREF: _bio_free+13p
					; _bio_ctrl+BEp

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	ecx, [esi+20h]
		test	ecx, ecx
		jz	short loc_827
		mov	edx, [ecx]
		test	edx, edx
		jz	short loc_827
		mov	eax, [edx+20h]
		mov	dword ptr [eax], 0
		mov	dword ptr [edx+0Ch], 0
		mov	dword ptr [eax+8], 0
		mov	dword ptr [eax+0Ch], 0
		mov	dword ptr [ecx], 0
		mov	dword ptr [esi+0Ch], 0
		mov	dword ptr [ecx+8], 0
		mov	dword ptr [ecx+0Ch], 0

loc_827:				; CODE XREF: _bio_destroy_pair+Aj
					; _bio_destroy_pair+10j
		pop	esi
		retn
_bio_destroy_pair endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 82Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_bio_make_pair	proc near		; CODE XREF: _bio_ctrl+A7p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	ebp
		mov	ebp, [esp+8+arg_4]
		push	esi
		push	edi
		mov	edi, [ebx+20h]
		mov	esi, [ebp+20h]
		cmp	dword ptr [edi], 0
		jnz	loc_926
		cmp	dword ptr [esi], 0
		jnz	loc_926
		cmp	dword ptr [edi+14h], 0
		jnz	short loc_89F
		push	2BAh
		push	offset ??_C@_0BH@BEKGBHJN@?4?2crypto?2bio?2bss_bio?4c?$AA@ ; ".\\crypto\\bio\\bss_bio.c"
		push	dword ptr [edi+10h]
		call	_CRYPTO_malloc
		add	esp, 0Ch
		mov	[edi+14h], eax
		test	eax, eax
		jnz	short loc_891
		push	2BCh
		push	offset ??_C@_0BH@BEKGBHJN@?4?2crypto?2bio?2bss_bio?4c?$AA@ ; ".\\crypto\\bio\\bss_bio.c"
		push	41h ; 'A'
		push	79h ; 'y'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_891:				; CODE XREF: _bio_make_pair+44j
		mov	dword ptr [edi+8], 0
		mov	dword ptr [edi+0Ch], 0

loc_89F:				; CODE XREF: _bio_make_pair+28j
		cmp	dword ptr [esi+14h], 0
		jnz	short loc_8EE
		push	2C4h
		push	offset ??_C@_0BH@BEKGBHJN@?4?2crypto?2bio?2bss_bio?4c?$AA@ ; ".\\crypto\\bio\\bss_bio.c"
		push	dword ptr [esi+10h]
		call	_CRYPTO_malloc
		add	esp, 0Ch
		mov	[esi+14h], eax
		test	eax, eax
		jnz	short loc_8E0
		push	2C6h
		push	offset ??_C@_0BH@BEKGBHJN@?4?2crypto?2bio?2bss_bio?4c?$AA@ ; ".\\crypto\\bio\\bss_bio.c"
		push	41h ; 'A'
		push	79h ; 'y'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_8E0:				; CODE XREF: _bio_make_pair+93j
		mov	dword ptr [esi+8], 0
		mov	dword ptr [esi+0Ch], 0

loc_8EE:				; CODE XREF: _bio_make_pair+77j
		mov	[edi], ebp
		mov	eax, 1
		mov	dword ptr [edi+4], 0
		mov	dword ptr [edi+18h], 0
		mov	[esi], ebx
		pop	edi
		mov	dword ptr [esi+4], 0
		mov	dword ptr [esi+18h], 0
		mov	dword ptr [ebx+0Ch], 1
		pop	esi
		mov	dword ptr [ebp+0Ch], 1
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_926:				; CODE XREF: _bio_make_pair+15j
					; _bio_make_pair+1Ej
		push	2B5h
		push	offset ??_C@_0BH@BEKGBHJN@?4?2crypto?2bio?2bss_bio?4c?$AA@ ; ".\\crypto\\bio\\bss_bio.c"
		push	7Bh ; '{'
		push	79h ; 'y'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_bio_make_pair	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 948h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl bio_nread(int Dst, int, int)
_bio_nread	proc near		; CODE XREF: _bio_ctrl+139p

Dst		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_8]
		mov	eax, 7FFFFFFFh
		push	edi
		push	[esp+8+arg_4]	; int
		mov	edi, [esp+0Ch+Dst]
		cmp	esi, eax
		push	edi		; Dst
		cmova	esi, eax
		call	_bio_nread0
		add	esp, 8
		cmp	esi, eax
		cmovg	esi, eax
		test	esi, esi
		jle	short loc_991
		mov	eax, [edi+20h]
		mov	eax, [eax]
		mov	ecx, [eax+20h]
		sub	[ecx+8], esi
		jz	short loc_98A
		add	[ecx+0Ch], esi
		mov	eax, [ecx+0Ch]
		cmp	eax, [ecx+10h]
		jnz	short loc_991

loc_98A:				; CODE XREF: _bio_nread+35j
		mov	dword ptr [ecx+0Ch], 0

loc_991:				; CODE XREF: _bio_nread+28j
					; _bio_nread+40j
		pop	edi
		mov	eax, esi
		pop	esi
		retn
_bio_nread	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 998h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl bio_nread0(int Dst, int)
_bio_nread0	proc near		; CODE XREF: _bio_ctrl+122p
					; _bio_nread+19p

Dst		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+Dst]
		push	0Fh
		push	esi
		call	_BIO_clear_flags
		add	esp, 8
		cmp	dword ptr [esi+0Ch], 0
		jnz	short loc_9B2
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_9B2:				; CODE XREF: _bio_nread0+14j
		mov	eax, [esi+20h]
		mov	eax, [eax]
		mov	ecx, [eax+20h]
		mov	edx, [ecx+8]
		mov	dword ptr [ecx+18h], 0
		test	edx, edx
		jnz	short loc_9DA
		push	1		; int
		lea	eax, [esp+8+Dst]
		push	eax		; Dst
		push	esi		; int
		call	_bio_read
		add	esp, 0Ch
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_9DA:				; CODE XREF: _bio_nread0+2Ej
		mov	esi, [ecx+0Ch]
		lea	eax, [esi+edx]
		cmp	[ecx+10h], eax
		jnb	short loc_9EA
		mov	edx, [ecx+10h]
		sub	edx, esi

loc_9EA:				; CODE XREF: _bio_nread0+4Bj
		mov	eax, [esp+4+arg_4]
		test	eax, eax
		jz	short loc_9F9
		mov	ecx, [ecx+14h]
		add	ecx, esi
		mov	[eax], ecx

loc_9F9:				; CODE XREF: _bio_nread0+58j
		mov	eax, edx
		pop	esi
		retn
_bio_nread0	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A00h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_bio_nwrite	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_8]
		mov	eax, 7FFFFFFFh
		push	edi
		push	[esp+8+arg_4]
		mov	edi, [esp+0Ch+arg_0]
		cmp	esi, eax
		push	edi
		cmova	esi, eax
		call	_bio_nwrite0
		add	esp, 8
		cmp	esi, eax
		cmovg	esi, eax
		test	esi, esi
		jle	short loc_A30
		mov	eax, [edi+20h]
		add	[eax+8], esi

loc_A30:				; CODE XREF: _bio_nwrite+28j
		pop	edi
		mov	eax, esi
		pop	esi
		retn
_bio_nwrite	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A38h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_bio_nwrite0	proc near		; CODE XREF: _bio_ctrl+14Cp
					; _bio_ctrl+16Dp ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		push	0Fh
		push	esi
		call	_BIO_clear_flags
		add	esp, 8
		cmp	dword ptr [esi+0Ch], 0
		jnz	short loc_A52
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_A52:				; CODE XREF: _bio_nwrite0+14j
		mov	ecx, [esi+20h]
		cmp	dword ptr [ecx+4], 0
		mov	dword ptr [ecx+18h], 0
		jz	short loc_A7F
		push	1B4h
		push	offset ??_C@_0BH@BEKGBHJN@?4?2crypto?2bio?2bss_bio?4c?$AA@ ; ".\\crypto\\bio\\bss_bio.c"
		push	7Ch ; '|'
		push	7Ah ; 'z'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_A7F:				; CODE XREF: _bio_nwrite0+28j
		mov	eax, [ecx+8]
		push	edi
		mov	edi, [ecx+10h]
		cmp	eax, edi
		jnz	short loc_A9B
		push	0Ah
		push	esi
		call	_BIO_set_flags
		add	esp, 8
		or	eax, 0FFFFFFFFh
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_A9B:				; CODE XREF: _bio_nwrite0+50j
		mov	edx, [ecx+0Ch]
		mov	esi, edi
		add	edx, eax
		sub	esi, eax
		cmp	edx, edi
		jb	short loc_AAA
		sub	edx, edi

loc_AAA:				; CODE XREF: _bio_nwrite0+6Ej
		lea	eax, [edx+esi]
		cmp	eax, edi
		jbe	short loc_AB5
		mov	esi, edi
		sub	esi, edx

loc_AB5:				; CODE XREF: _bio_nwrite0+77j
		mov	eax, [esp+8+arg_4]
		test	eax, eax
		jz	short loc_AC4
		mov	ecx, [ecx+14h]
		add	ecx, edx
		mov	[eax], ecx

loc_AC4:				; CODE XREF: _bio_nwrite0+83j
		pop	edi
		mov	eax, esi
		pop	esi
		retn
_bio_nwrite0	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ACCh
; COMDAT (pick any)
		public ??_C@_0BH@BEKGBHJN@?4?2crypto?2bio?2bss_bio?4c?$AA@
; `string'
??_C@_0BH@BEKGBHJN@?4?2crypto?2bio?2bss_bio?4c?$AA@ db '.\crypto\bio\bss_bio.c',0
					; DATA XREF: _bio_new+5o
					; _bio_write+49o ...
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _CRYPTO_malloc:near ; CODE XREF: _bio_new+Cp
					; _bio_make_pair+37p ...
		extrn _CRYPTO_free:near	; CODE XREF: _bio_free+23p
					; _bio_free+2Cp ...
		extrn _BIO_set_flags:near ; CODE XREF: _bio_read+53p
					; _bio_write+70p ...
		extrn _BIO_clear_flags:near ; CODE XREF: _bio_read+8p
					; _bio_write+9p ...
		extrn _BIO_new:near	; CODE XREF: _BIO_new_bio_pair+Cp
					; _BIO_new_bio_pair+23p
		extrn _BIO_free:near	; CODE XREF: _BIO_new_bio_pair+97p
					; _BIO_new_bio_pair+A6p
		extrn _BIO_ctrl:near	; CODE XREF: _BIO_ctrl_get_read_request+Dp
					; _BIO_ctrl_get_write_guarantee+Dp ...
		extrn _ERR_put_error:near ; CODE XREF: _bio_write+54p
					; _bio_ctrl+39p ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _bio_read+91p
					; _bio_write+B3p


		end
