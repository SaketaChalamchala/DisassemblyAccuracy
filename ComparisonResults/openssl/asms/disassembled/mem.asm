;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	BC83AA8F64A4ED55910E71FF36CF8A9C
; Input	CRC32 :	40EDEA91

; File Name   :	C:\compspace\Diff\openssl\obj\mem.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
_allow_customize dd 1			; DATA XREF: _CRYPTO_malloc+12w
					; _CRYPTO_malloc_locked+12w ...
_allow_customize_debug dd 1		; DATA XREF: _CRYPTO_malloc+32w
					; _CRYPTO_malloc_locked+32w ...
_malloc_func	dd offset _malloc	; DATA XREF: _default_malloc_ex+4r
					; _CRYPTO_get_mem_functions+14r ...
_malloc_ex_func	dd offset _default_malloc_ex ; DATA XREF: _CRYPTO_get_mem_ex_functions+8r
					; _CRYPTO_get_mem_functions+Ar	...
_realloc_func	dd offset _realloc	; DATA XREF: _default_realloc_ex+8r
					; _CRYPTO_get_mem_functions+31r ...
_realloc_ex_func dd offset _default_realloc_ex ; DATA XREF: _CRYPTO_get_mem_ex_functions+21r
					; _CRYPTO_get_mem_functions+27r ...
_free_func	dd offset _free		; DATA XREF: _CRYPTO_free+18r
					; _CRYPTO_get_mem_ex_functions+3Ar ...
_malloc_locked_func dd offset _malloc	; DATA XREF: _default_malloc_locked_ex+4r
					; _CRYPTO_get_locked_mem_functions+14r	...
_malloc_locked_ex_func dd offset _default_malloc_locked_ex
					; DATA XREF: _CRYPTO_get_locked_mem_ex_functions+8r
					; _CRYPTO_get_locked_mem_functions+Ar ...
_free_locked_func dd offset _free	; CODE XREF: _default_malloc_ex+4p
					; _default_realloc_ex+8p ...
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 28h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl default_malloc_ex(size_t Size)
_default_malloc_ex proc	near		; CODE XREF: _CRYPTO_malloc+44p
					; _CRYPTO_realloc_clean+63p
					; DATA XREF: ...

Size		= dword	ptr  4

		push	[esp+Size]	; Size
		call	_malloc_func
		add	esp, 4
		retn
_default_malloc_ex endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 38h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl default_realloc_ex(void *Memory, size_t NewSize)
_default_realloc_ex proc near		; CODE XREF: _CRYPTO_realloc+51p
					; DATA XREF: .data:_realloc_ex_funco ...

Memory		= dword	ptr  4
NewSize		= dword	ptr  8

		push	[esp+NewSize]	; NewSize
		push	[esp+4+Memory]	; Memory
		call	_realloc_func
		add	esp, 8
		retn
_default_realloc_ex endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl default_malloc_locked_ex(size_t Size)
_default_malloc_locked_ex proc near	; CODE XREF: _CRYPTO_malloc_locked+44p
					; DATA XREF: .data:_malloc_locked_ex_funco ...

Size		= dword	ptr  4

		push	[esp+Size]	; Size
		call	_malloc_locked_func
		add	esp, 4
		retn
_default_malloc_locked_ex endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 5Ch
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
_malloc_debug_func dd ?			; DATA XREF: _CRYPTO_get_mem_debug_functions+8r
					; _CRYPTO_malloc:loc_22Dr ...
_realloc_debug_func dd ?		; DATA XREF: _CRYPTO_get_mem_debug_functions+17r
					; _CRYPTO_realloc:loc_325r ...
_free_debug_func dd ?			; DATA XREF: _CRYPTO_freer
					; _CRYPTO_free+1Er ...
_set_debug_options_func	dd ?		; DATA XREF: _CRYPTO_get_mem_debug_functions+35r
					; _CRYPTO_set_mem_debug_functions+30w ...
_get_debug_options_func	dd ?		; DATA XREF: _CRYPTO_get_mem_debug_functions+44r
					; _CRYPTO_get_mem_debug_optionsr ...
_bss		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 70h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl CRYPTO_free(void *Memory)
		public _CRYPTO_free
_CRYPTO_free	proc near

Memory		= dword	ptr  4

		mov	eax, ds:_free_debug_func
		test	eax, eax
		jz	short loc_84
		push	0
		push	[esp+4+Memory]
		call	eax ; _free_debug_func
		add	esp, 8

loc_84:					; CODE XREF: _CRYPTO_free+7j
		push	[esp+Memory]	; Memory
		call	_free_func
		mov	eax, ds:_free_debug_func
		add	esp, 4
		test	eax, eax
		jz	short locret_A3
		push	1
		push	0
		call	eax ; _free_debug_func
		add	esp, 8

locret_A3:				; CODE XREF: _CRYPTO_free+28j
		retn
_CRYPTO_free	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_free_locked
_CRYPTO_free_locked proc near

arg_0		= dword	ptr  4

		mov	eax, ds:_free_debug_func
		test	eax, eax
		jz	short loc_B8
		push	0
		push	[esp+4+arg_0]
		call	eax ; _free_debug_func
		add	esp, 8

loc_B8:					; CODE XREF: _CRYPTO_free_locked+7j
		push	[esp+arg_0]
		call	_free_locked_func
		mov	eax, ds:_free_debug_func
		add	esp, 4
		test	eax, eax
		jz	short locret_D7
		push	1
		push	0
		call	eax ; _free_debug_func
		add	esp, 8

locret_D7:				; CODE XREF: _CRYPTO_free_locked+28j
		retn
_CRYPTO_free_locked endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_get_locked_mem_ex_functions
_CRYPTO_get_locked_mem_ex_functions proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_0]
		test	edx, edx
		jz	short loc_F1
		mov	eax, _malloc_locked_ex_func
		xor	ecx, ecx
		cmp	eax, offset _default_malloc_locked_ex
		cmovnz	ecx, eax
		mov	[edx], ecx

loc_F1:					; CODE XREF: _CRYPTO_get_locked_mem_ex_functions+6j
		mov	ecx, [esp+arg_4]
		test	ecx, ecx
		jz	short locret_100
		mov	eax, _free_locked_func
		mov	[ecx], eax

locret_100:				; CODE XREF: _CRYPTO_get_locked_mem_ex_functions+1Fj
		retn
_CRYPTO_get_locked_mem_ex_functions endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 104h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_get_locked_mem_functions
_CRYPTO_get_locked_mem_functions proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jz	short loc_121
		xor	eax, eax
		cmp	_malloc_locked_ex_func,	offset _default_malloc_locked_ex
		cmovz	eax, _malloc_locked_func
		mov	[ecx], eax

loc_121:				; CODE XREF: _CRYPTO_get_locked_mem_functions+6j
		mov	ecx, [esp+arg_4]
		test	ecx, ecx
		jz	short locret_130
		mov	eax, _free_locked_func
		mov	[ecx], eax

locret_130:				; CODE XREF: _CRYPTO_get_locked_mem_functions+23j
		retn
_CRYPTO_get_locked_mem_functions endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 134h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_get_mem_debug_functions
_CRYPTO_get_mem_debug_functions	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jz	short loc_143
		mov	eax, ds:_malloc_debug_func
		mov	[ecx], eax

loc_143:				; CODE XREF: _CRYPTO_get_mem_debug_functions+6j
		mov	ecx, [esp+arg_4]
		test	ecx, ecx
		jz	short loc_152
		mov	eax, ds:_realloc_debug_func
		mov	[ecx], eax

loc_152:				; CODE XREF: _CRYPTO_get_mem_debug_functions+15j
		mov	ecx, [esp+arg_8]
		test	ecx, ecx
		jz	short loc_161
		mov	eax, ds:_free_debug_func
		mov	[ecx], eax

loc_161:				; CODE XREF: _CRYPTO_get_mem_debug_functions+24j
		mov	ecx, [esp+arg_C]
		test	ecx, ecx
		jz	short loc_170
		mov	eax, ds:_set_debug_options_func
		mov	[ecx], eax

loc_170:				; CODE XREF: _CRYPTO_get_mem_debug_functions+33j
		mov	ecx, [esp+arg_10]
		test	ecx, ecx
		jz	short locret_17F
		mov	eax, ds:_get_debug_options_func
		mov	[ecx], eax

locret_17F:				; CODE XREF: _CRYPTO_get_mem_debug_functions+42j
		retn
_CRYPTO_get_mem_debug_functions	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 180h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_get_mem_debug_options
_CRYPTO_get_mem_debug_options proc near
		mov	eax, ds:_get_debug_options_func
		test	eax, eax
		jz	short loc_18B
		jmp	eax
; ---------------------------------------------------------------------------

loc_18B:				; CODE XREF: _CRYPTO_get_mem_debug_options+7j
		xor	eax, eax
		retn
_CRYPTO_get_mem_debug_options endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 190h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_get_mem_ex_functions
_CRYPTO_get_mem_ex_functions proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	edx, [esp+arg_0]
		test	edx, edx
		jz	short loc_1A9
		mov	eax, _malloc_ex_func
		xor	ecx, ecx
		cmp	eax, offset _default_malloc_ex
		cmovnz	ecx, eax
		mov	[edx], ecx

loc_1A9:				; CODE XREF: _CRYPTO_get_mem_ex_functions+6j
		mov	edx, [esp+arg_4]
		test	edx, edx
		jz	short loc_1C2
		mov	eax, _realloc_ex_func
		xor	ecx, ecx
		cmp	eax, offset _default_realloc_ex
		cmovnz	ecx, eax
		mov	[edx], ecx

loc_1C2:				; CODE XREF: _CRYPTO_get_mem_ex_functions+1Fj
		mov	ecx, [esp+arg_8]
		test	ecx, ecx
		jz	short locret_1D1
		mov	eax, _free_func
		mov	[ecx], eax

locret_1D1:				; CODE XREF: _CRYPTO_get_mem_ex_functions+38j
		retn
_CRYPTO_get_mem_ex_functions endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1D4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_get_mem_functions
_CRYPTO_get_mem_functions proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jz	short loc_1F1
		xor	eax, eax
		cmp	_malloc_ex_func, offset	_default_malloc_ex
		cmovz	eax, _malloc_func
		mov	[ecx], eax

loc_1F1:				; CODE XREF: _CRYPTO_get_mem_functions+6j
		mov	ecx, [esp+arg_4]
		test	ecx, ecx
		jz	short loc_20E
		xor	eax, eax
		cmp	_realloc_ex_func, offset _default_realloc_ex
		cmovz	eax, _realloc_func
		mov	[ecx], eax

loc_20E:				; CODE XREF: _CRYPTO_get_mem_functions+23j
		mov	ecx, [esp+arg_8]
		test	ecx, ecx
		jz	short locret_21D
		mov	eax, _free_func
		mov	[ecx], eax

locret_21D:				; CODE XREF: _CRYPTO_get_mem_functions+40j
		retn
_CRYPTO_get_mem_functions endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 220h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl CRYPTO_malloc(size_t Size, int, int)
		public _CRYPTO_malloc
_CRYPTO_malloc	proc near		; CODE XREF: _CRYPTO_realloc+15p
					; _CRYPTO_realloc_clean+15p ...

Size		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+Size]
		test	esi, esi
		jg	short loc_22D
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_22D:				; CODE XREF: _CRYPTO_malloc+7j
		mov	eax, ds:_malloc_debug_func
		mov	_allow_customize, 0
		push	ebx
		mov	ebx, [esp+8+arg_4]
		push	ebp
		push	edi
		mov	edi, [esp+10h+arg_8]
		test	eax, eax
		jz	short loc_261
		push	0
		push	edi
		push	ebx
		push	esi
		push	0
		mov	_allow_customize_debug,	0
		call	eax ; _malloc_debug_func
		add	esp, 14h

loc_261:				; CODE XREF: _CRYPTO_malloc+29j
		push	edi
		push	ebx
		push	esi		; Size
		call	_malloc_ex_func
		mov	ebp, eax
		add	esp, 0Ch
		mov	eax, ds:_malloc_debug_func
		test	eax, eax
		jz	short loc_283
		push	1
		push	edi
		push	ebx
		push	esi
		push	ebp
		call	eax ; _malloc_debug_func
		add	esp, 14h

loc_283:				; CODE XREF: _CRYPTO_malloc+56j
		pop	edi
		mov	eax, ebp
		pop	ebp
		pop	ebx
		pop	esi
		retn
_CRYPTO_malloc	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 28Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl CRYPTO_malloc_locked(size_t Size,	int, int)
		public _CRYPTO_malloc_locked
_CRYPTO_malloc_locked proc near

Size		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+Size]
		test	esi, esi
		jg	short loc_299
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_299:				; CODE XREF: _CRYPTO_malloc_locked+7j
		mov	eax, ds:_malloc_debug_func
		mov	_allow_customize, 0
		push	ebx
		mov	ebx, [esp+8+arg_4]
		push	ebp
		push	edi
		mov	edi, [esp+10h+arg_8]
		test	eax, eax
		jz	short loc_2CD
		push	0
		push	edi
		push	ebx
		push	esi
		push	0
		mov	_allow_customize_debug,	0
		call	eax ; _malloc_debug_func
		add	esp, 14h

loc_2CD:				; CODE XREF: _CRYPTO_malloc_locked+29j
		push	edi
		push	ebx
		push	esi		; Size
		call	_malloc_locked_ex_func
		mov	ebp, eax
		add	esp, 0Ch
		mov	eax, ds:_malloc_debug_func
		test	eax, eax
		jz	short loc_2EF
		push	1
		push	edi
		push	ebx
		push	esi
		push	ebp
		call	eax ; _malloc_debug_func
		add	esp, 14h

loc_2EF:				; CODE XREF: _CRYPTO_malloc_locked+56j
		pop	edi
		mov	eax, ebp
		pop	ebp
		pop	ebx
		pop	esi
		retn
_CRYPTO_malloc_locked endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2F8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl CRYPTO_realloc(void *Memory, size_t NewSize, int,	int)
		public _CRYPTO_realloc
_CRYPTO_realloc	proc near

Memory		= dword	ptr  4
NewSize		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	esi
		mov	esi, [esp+4+Memory]
		test	esi, esi
		jnz	short loc_317
		push	[esp+4+arg_C]	; int
		push	[esp+8+arg_8]	; int
		push	[esp+0Ch+NewSize] ; Size
		call	_CRYPTO_malloc
		add	esp, 0Ch
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_317:				; CODE XREF: _CRYPTO_realloc+7j
		push	edi
		mov	edi, [esp+8+NewSize]
		test	edi, edi
		jg	short loc_325
		pop	edi
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_325:				; CODE XREF: _CRYPTO_realloc+26j
		mov	eax, ds:_realloc_debug_func
		push	ebx
		mov	ebx, [esp+0Ch+arg_C]
		push	ebp
		mov	ebp, [esp+10h+arg_8]
		test	eax, eax
		jz	short loc_345
		push	0
		push	ebx
		push	ebp
		push	edi
		push	0
		push	esi
		call	eax ; _realloc_debug_func
		add	esp, 18h

loc_345:				; CODE XREF: _CRYPTO_realloc+3Ej
		push	ebx
		push	ebp
		push	edi		; NewSize
		push	esi		; Memory
		call	_realloc_ex_func
		mov	ecx, ds:_realloc_debug_func
		add	esp, 10h
		mov	[esp+10h+Memory], eax
		test	ecx, ecx
		jz	short loc_370
		push	1
		push	ebx
		push	ebp
		push	edi
		push	eax
		push	esi
		call	ecx ; _realloc_debug_func
		mov	eax, [esp+28h+Memory]
		add	esp, 18h

loc_370:				; CODE XREF: _CRYPTO_realloc+66j
		pop	ebp
		pop	ebx
		pop	edi
		pop	esi
		retn
_CRYPTO_realloc	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 378h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl CRYPTO_realloc_clean(void	*Src, size_t Size, size_t, int,	int)
		public _CRYPTO_realloc_clean
_CRYPTO_realloc_clean proc near

Src		= dword	ptr  4
Size		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		push	esi
		mov	esi, [esp+4+Src]
		test	esi, esi
		jnz	short loc_397
		push	[esp+4+arg_10]	; int
		push	[esp+8+arg_C]	; int
		push	[esp+0Ch+arg_8]	; Size
		call	_CRYPTO_malloc
		add	esp, 0Ch
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_397:				; CODE XREF: _CRYPTO_realloc_clean+7j
		push	edi
		mov	edi, [esp+8+arg_8]
		test	edi, edi
		jg	short loc_3A5
		pop	edi
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_3A5:				; CODE XREF: _CRYPTO_realloc_clean+26j
		push	ebp
		mov	ebp, [esp+0Ch+Size]
		cmp	edi, ebp
		jge	short loc_3B4
		pop	ebp
		pop	edi
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_3B4:				; CODE XREF: _CRYPTO_realloc_clean+34j
		mov	ecx, ds:_realloc_debug_func
		mov	eax, [esp+0Ch+arg_C]
		push	ebx
		mov	ebx, [esp+10h+arg_10]
		test	ecx, ecx
		jz	short loc_3D8
		push	0
		push	ebx
		push	eax
		push	edi
		push	0
		push	esi
		call	ecx ; _realloc_debug_func
		mov	eax, [esp+28h+arg_C]
		add	esp, 18h

loc_3D8:				; CODE XREF: _CRYPTO_realloc_clean+4Dj
		push	ebx
		push	eax
		push	edi		; Size
		call	_malloc_ex_func
		mov	ebx, eax
		add	esp, 0Ch
		test	ebx, ebx
		jz	short loc_403
		push	ebp		; Size
		push	esi		; Src
		push	ebx		; Dst
		call	_memcpy
		push	ebp
		push	esi
		call	_OPENSSL_cleanse
		push	esi		; Memory
		call	_free_func
		add	esp, 18h

loc_403:				; CODE XREF: _CRYPTO_realloc_clean+70j
		mov	eax, ds:_realloc_debug_func
		test	eax, eax
		jz	short loc_41E
		push	1
		push	[esp+14h+arg_10]
		push	[esp+18h+arg_C]
		push	edi
		push	ebx
		push	esi
		call	eax ; _realloc_debug_func
		add	esp, 18h

loc_41E:				; CODE XREF: _CRYPTO_realloc_clean+92j
		mov	eax, ebx
		pop	ebx
		pop	ebp
		pop	edi
		pop	esi
		retn
_CRYPTO_realloc_clean endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 428h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl CRYPTO_remalloc(void *Memory, size_t Size)
		public _CRYPTO_remalloc
_CRYPTO_remalloc proc near

Memory		= dword	ptr  4
Size		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+Memory]
		test	esi, esi
		jz	short loc_45E
		mov	eax, ds:_free_debug_func
		test	eax, eax
		jz	short loc_442
		push	0
		push	esi
		call	eax ; _free_debug_func
		add	esp, 8

loc_442:				; CODE XREF: _CRYPTO_remalloc+10j
		push	esi		; Memory
		call	_free_func
		mov	eax, ds:_free_debug_func
		add	esp, 4
		test	eax, eax
		jz	short loc_45E
		push	1
		push	0
		call	eax ; _free_debug_func
		add	esp, 8

loc_45E:				; CODE XREF: _CRYPTO_remalloc+7j
					; _CRYPTO_remalloc+2Bj
		push	1C3h		; int
		push	offset ??_C@_0P@FIAMPLLC@?4?2crypto?2mem?4c?$AA@ ; ".\\crypto\\mem.c"
		push	[esp+0Ch+Size]	; Size
		call	_CRYPTO_malloc
		add	esp, 0Ch
		pop	esi
		retn
_CRYPTO_remalloc endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 478h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_set_locked_mem_ex_functions
_CRYPTO_set_locked_mem_ex_functions proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		cmp	_allow_customize, 0
		jz	short loc_4AC
		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short loc_4AC
		mov	ecx, [esp+arg_4]
		test	ecx, ecx
		jz	short loc_4AC
		mov	_malloc_locked_ex_func,	eax
		mov	eax, 1
		mov	_malloc_locked_func, 0
		mov	_free_func, ecx
		retn
; ---------------------------------------------------------------------------

loc_4AC:				; CODE XREF: _CRYPTO_set_locked_mem_ex_functions+7j
					; _CRYPTO_set_locked_mem_ex_functions+Fj ...
		xor	eax, eax
		retn
_CRYPTO_set_locked_mem_ex_functions endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4B0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_set_locked_mem_functions
_CRYPTO_set_locked_mem_functions proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		cmp	_allow_customize, 0
		jz	short loc_4E4
		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short loc_4E4
		mov	ecx, [esp+arg_4]
		test	ecx, ecx
		jz	short loc_4E4
		mov	_malloc_locked_func, eax
		mov	eax, 1
		mov	_malloc_locked_ex_func,	offset _default_malloc_locked_ex
		mov	_free_locked_func, ecx
		retn
; ---------------------------------------------------------------------------

loc_4E4:				; CODE XREF: _CRYPTO_set_locked_mem_functions+7j
					; _CRYPTO_set_locked_mem_functions+Fj ...
		xor	eax, eax
		retn
_CRYPTO_set_locked_mem_functions endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4E8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_set_mem_debug_functions
_CRYPTO_set_mem_debug_functions	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		cmp	_allow_customize_debug,	0
		jnz	short loc_4F4
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_4F4:				; CODE XREF: _CRYPTO_set_mem_debug_functions+7j
		call	_OPENSSL_init
		mov	eax, [esp+arg_0]
		mov	ds:_malloc_debug_func, eax
		mov	eax, [esp+arg_4]
		mov	ds:_realloc_debug_func,	eax
		mov	eax, [esp+arg_8]
		mov	ds:_free_debug_func, eax
		mov	eax, [esp+arg_C]
		mov	ds:_set_debug_options_func, eax
		mov	eax, [esp+arg_10]
		mov	ds:_get_debug_options_func, eax
		mov	eax, 1
		retn
_CRYPTO_set_mem_debug_functions	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 52Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_set_mem_debug_options
_CRYPTO_set_mem_debug_options proc near
		mov	eax, ds:_set_debug_options_func
		test	eax, eax
		jz	short locret_537
		jmp	eax
; ---------------------------------------------------------------------------

locret_537:				; CODE XREF: _CRYPTO_set_mem_debug_options+7j
		retn
_CRYPTO_set_mem_debug_options endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 538h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_set_mem_ex_functions
_CRYPTO_set_mem_ex_functions proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		cmp	_allow_customize, 0
		jz	short loc_599
		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short loc_599
		mov	edx, [esp+arg_4]
		test	edx, edx
		jz	short loc_599
		mov	ecx, [esp+arg_8]
		test	ecx, ecx
		jz	short loc_599
		mov	_malloc_ex_func, eax
		mov	_malloc_locked_ex_func,	eax
		mov	eax, 1
		mov	_malloc_func, 0
		mov	_realloc_func, 0
		mov	_realloc_ex_func, edx
		mov	_free_func, ecx
		mov	_malloc_locked_func, 0
		mov	_free_locked_func, ecx
		retn
; ---------------------------------------------------------------------------

loc_599:				; CODE XREF: _CRYPTO_set_mem_ex_functions+7j
					; _CRYPTO_set_mem_ex_functions+Fj ...
		xor	eax, eax
		retn
_CRYPTO_set_mem_ex_functions endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 59Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_set_mem_functions
_CRYPTO_set_mem_functions proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		call	_OPENSSL_init
		cmp	_allow_customize, 0
		jz	short loc_602
		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short loc_602
		mov	edx, [esp+arg_4]
		test	edx, edx
		jz	short loc_602
		mov	ecx, [esp+arg_8]
		test	ecx, ecx
		jz	short loc_602
		mov	_malloc_func, eax
		mov	_malloc_locked_func, eax
		mov	eax, 1
		mov	_malloc_ex_func, offset	_default_malloc_ex
		mov	_realloc_func, edx
		mov	_realloc_ex_func, offset _default_realloc_ex
		mov	_free_func, ecx
		mov	_malloc_locked_ex_func,	offset _default_malloc_locked_ex
		mov	_free_locked_func, ecx
		retn
; ---------------------------------------------------------------------------

loc_602:				; CODE XREF: _CRYPTO_set_mem_functions+Cj
					; _CRYPTO_set_mem_functions+14j ...
		xor	eax, eax
		retn
_CRYPTO_set_mem_functions endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 608h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_strdup
_CRYPTO_strdup	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	ecx, esi
		lea	edx, [ecx+1]
		nop	word ptr [eax+eax+00h]

loc_618:				; CODE XREF: _CRYPTO_strdup+15j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_618
		push	[esp+4+arg_8]	; int
		sub	ecx, edx
		push	[esp+8+arg_4]	; int
		lea	eax, [ecx+1]
		push	eax		; Size
		call	_CRYPTO_malloc
		mov	edx, eax
		add	esp, 0Ch
		test	edx, edx
		jnz	short loc_63D
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_63D:				; CODE XREF: _CRYPTO_strdup+31j
		mov	ecx, edx
		sub	ecx, esi
		nop	dword ptr [eax+00000000h]

loc_648:				; CODE XREF: _CRYPTO_strdup+4Bj
		mov	al, [esi]
		lea	esi, [esi+1]
		mov	[ecx+esi-1], al
		test	al, al
		jnz	short loc_648
		mov	eax, edx
		pop	esi
		retn
_CRYPTO_strdup	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 65Ch
; COMDAT (pick any)
		public ??_C@_0P@FIAMPLLC@?4?2crypto?2mem?4c?$AA@
; `string'
??_C@_0P@FIAMPLLC@?4?2crypto?2mem?4c?$AA@ db '.\crypto\mem.c',0
					; DATA XREF: _CRYPTO_remalloc+3Bo
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; void *__cdecl	malloc(size_t Size)
		extrn _malloc:near	; CODE XREF: _default_malloc_ex+4p
					; _default_malloc_locked_ex+4p
					; DATA XREF: ...
; void __cdecl free(void *Memory)
		extrn _free:near	; CODE XREF: _CRYPTO_free+18p
					; _CRYPTO_realloc_clean+82p ...
; void *__cdecl	realloc(void *Memory, size_t NewSize)
		extrn _realloc:near	; CODE XREF: _default_realloc_ex+8p
					; DATA XREF: .data:_realloc_funco
		extrn _OPENSSL_cleanse:near ; CODE XREF: _CRYPTO_realloc_clean+7Cp
		extrn _OPENSSL_init:near
					; CODE XREF: _CRYPTO_set_mem_debug_functions:loc_4F4p
					; _CRYPTO_set_mem_functionsp
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _CRYPTO_realloc_clean+75p


		end
