;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	996C742CABD73569D3DCEC61AA9DF04A
; Input	CRC32 :	0AC17F57

; File Name   :	C:\compspace\Diff\openssl\obj\stack.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		public _STACK_version
_STACK_version	db 'Stack part of OpenSSL 1.0.2h  3 May 2016',0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_internal_find	proc near		; CODE XREF: _sk_find+Ap
					; _sk_find_ex+Ap

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	short loc_58
		mov	eax, [esi+10h]
		test	eax, eax
		jnz	short loc_5D
		mov	edx, [esi]
		test	edx, edx
		jle	short loc_58
		mov	ecx, [esi+4]
		mov	esi, [esp+4+arg_4]
		nop	dword ptr [eax]

loc_4C:					; CODE XREF: _internal_find+2Aj
		cmp	[ecx], esi
		jz	short loc_A7
		inc	eax
		add	ecx, 4
		cmp	eax, edx
		jl	short loc_4C

loc_58:					; CODE XREF: _internal_find+7j
					; _internal_find+14j ...
		or	eax, 0FFFFFFFFh
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_5D:					; CODE XREF: _internal_find+Ej
		cmp	dword ptr [esi+8], 0
		jnz	short loc_7B
		push	eax		; PtFuncCompare
		push	4		; SizeOfElements
		push	dword ptr [esi]	; NumOfElements
		push	dword ptr [esi+4] ; Base
		call	dword ptr ds:__imp__qsort
		add	esp, 10h
		mov	dword ptr [esi+8], 1

loc_7B:					; CODE XREF: _internal_find+35j
		cmp	[esp+4+arg_4], 0
		jz	short loc_58
		push	[esp+4+arg_8]
		lea	eax, [esp+8+arg_4]
		push	dword ptr [esi+10h]
		push	4
		push	dword ptr [esi]
		push	dword ptr [esi+4]
		push	eax
		call	_OBJ_bsearch_ex_
		add	esp, 18h
		test	eax, eax
		jz	short loc_58
		sub	eax, [esi+4]
		sar	eax, 2

loc_A7:					; CODE XREF: _internal_find+22j
		pop	esi
		retn
_internal_find	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0ACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _sk_deep_copy
_sk_deep_copy	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	edi
		push	7Ch ; '|'
		push	offset ??_C@_0BH@GBDCJGGB@?4?2crypto?2stack?2stack?4c?$AA@ ; ".\\crypto\\stack\\stack.c"
		push	14h
		call	_CRYPTO_malloc
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jnz	short loc_C6
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_C6:					; CODE XREF: _sk_deep_copy+16j
		push	ebx
		mov	ebx, [esp+8+arg_0]
		mov	ecx, 4
		push	82h ; '‚'
		push	offset ??_C@_0BH@GBDCJGGB@?4?2crypto?2stack?2stack?4c?$AA@ ; ".\\crypto\\stack\\stack.c"
		mov	eax, [ebx+10h]
		mov	[edi+10h], eax
		mov	eax, [ebx+8]
		mov	[edi+8], eax
		mov	eax, [ebx]
		mov	[edi], eax
		cmp	[ebx], ecx
		cmovg	ecx, [ebx]
		mov	[edi+0Ch], ecx
		lea	eax, ds:0[ecx*4]
		push	eax
		call	_CRYPTO_malloc
		add	esp, 0Ch
		mov	[edi+4], eax
		test	eax, eax
		jnz	short loc_117
		push	edi
		call	_CRYPTO_free
		add	esp, 4
		xor	eax, eax
		pop	ebx
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_117:				; CODE XREF: _sk_deep_copy+5Bj
		xor	ecx, ecx
		cmp	[edi+0Ch], ecx
		jle	short loc_12E

loc_11E:				; CODE XREF: _sk_deep_copy+80j
		mov	eax, [edi+4]
		mov	dword ptr [eax+ecx*4], 0
		inc	ecx
		cmp	ecx, [edi+0Ch]
		jl	short loc_11E

loc_12E:				; CODE XREF: _sk_deep_copy+70j
		push	ebp
		push	esi
		xor	esi, esi
		cmp	[edi], esi
		jle	short loc_15B
		mov	ebp, [esp+10h+arg_4]
		xchg	ax, ax

loc_13C:				; CODE XREF: _sk_deep_copy+ADj
		mov	eax, [ebx+4]
		mov	eax, [eax+esi*4]
		test	eax, eax
		jz	short loc_156
		push	eax
		call	ebp
		mov	ecx, [edi+4]
		add	esp, 4
		mov	[ecx+esi*4], eax
		test	eax, eax
		jz	short loc_162

loc_156:				; CODE XREF: _sk_deep_copy+98j
		inc	esi
		cmp	esi, [edi]
		jl	short loc_13C

loc_15B:				; CODE XREF: _sk_deep_copy+88j
		pop	esi
		pop	ebp
		pop	ebx
		mov	eax, edi
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_162:				; CODE XREF: _sk_deep_copy+A8j
		sub	esi, 1
		js	short loc_181
		mov	ebx, [esp+10h+arg_8]
		nop

loc_16C:				; CODE XREF: _sk_deep_copy+D3j
		mov	eax, [edi+4]
		mov	eax, [eax+esi*4]
		test	eax, eax
		jz	short loc_17C
		push	eax
		call	ebx
		add	esp, 4

loc_17C:				; CODE XREF: _sk_deep_copy+C8j
		sub	esi, 1
		jns	short loc_16C

loc_181:				; CODE XREF: _sk_deep_copy+B9j
		mov	eax, [edi+4]
		test	eax, eax
		jz	short loc_191
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_191:				; CODE XREF: _sk_deep_copy+DAj
		push	edi
		call	_CRYPTO_free
		add	esp, 4
		xor	eax, eax
		pop	esi
		pop	ebp
		pop	ebx
		pop	edi
		retn
_sk_deep_copy	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1A4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _sk_delete
_sk_delete	proc near		; CODE XREF: _sk_pop+14p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		test	esi, esi
		jz	short loc_1DF
		mov	ecx, [esp+8+arg_4]
		test	ecx, ecx
		js	short loc_1DF
		mov	edi, [esi]
		cmp	ecx, edi
		jge	short loc_1DF
		mov	eax, [esi+4]
		dec	edi
		push	ebx
		mov	ebx, [eax+ecx*4]
		cmp	ecx, edi
		jge	short loc_1D7

loc_1C8:				; CODE XREF: _sk_delete+31j
		mov	eax, [esi+4]
		mov	edx, [eax+ecx*4+4]
		mov	[eax+ecx*4], edx
		inc	ecx
		cmp	ecx, edi
		jl	short loc_1C8

loc_1D7:				; CODE XREF: _sk_delete+22j
		dec	dword ptr [esi]
		mov	eax, ebx
		pop	ebx
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1DF:				; CODE XREF: _sk_delete+8j
					; _sk_delete+10j ...
		pop	edi
		xor	eax, eax
		pop	esi
		retn
_sk_delete	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1E4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _sk_delete_ptr
_sk_delete_ptr	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		push	esi
		mov	esi, [esp+8+arg_0]
		xor	eax, eax
		push	edi
		mov	edx, [esi]
		test	edx, edx
		jle	short loc_208
		mov	ebx, [esi+4]
		mov	ecx, ebx
		mov	edi, [esp+0Ch+arg_4]

loc_1FC:				; CODE XREF: _sk_delete_ptr+22j
		cmp	[ecx], edi
		jz	short loc_20E
		inc	eax
		add	ecx, 4
		cmp	eax, edx
		jl	short loc_1FC

loc_208:				; CODE XREF: _sk_delete_ptr+Dj
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_20E:				; CODE XREF: _sk_delete_ptr+1Aj
		test	eax, eax
		js	short loc_23C
		cmp	eax, edx
		jge	short loc_23C
		mov	ebx, [ebx+eax*4]
		lea	edi, [edx-1]
		cmp	eax, edi
		jge	short loc_234
		nop	dword ptr [eax+00h]

loc_224:				; CODE XREF: _sk_delete_ptr+4Ej
		mov	ecx, [esi+4]
		lea	edx, [ecx+eax*4]
		inc	eax
		mov	ecx, [edx+4]
		mov	[edx], ecx
		cmp	eax, edi
		jl	short loc_224

loc_234:				; CODE XREF: _sk_delete_ptr+3Aj
		dec	dword ptr [esi]
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_23C:				; CODE XREF: _sk_delete_ptr+2Cj
					; _sk_delete_ptr+30j
		pop	edi
		xor	ebx, ebx
		pop	esi
		mov	eax, ebx
		pop	ebx
		retn
_sk_delete_ptr	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 244h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _sk_dup
_sk_dup		proc near

arg_0		= dword	ptr  4

		push	esi
		push	edi
		mov	edi, [esp+8+arg_0]
		push	dword ptr [edi+10h]
		call	_sk_new
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jz	short loc_293
		mov	ecx, [edi+0Ch]
		push	65h ; 'e'
		push	offset ??_C@_0BH@GBDCJGGB@?4?2crypto?2stack?2stack?4c?$AA@ ; ".\\crypto\\stack\\stack.c"
		shl	ecx, 2
		push	ecx
		push	dword ptr [esi+4]
		call	_CRYPTO_realloc
		mov	ecx, eax
		add	esp, 10h
		test	ecx, ecx
		jnz	short loc_298

$err$11:
		mov	eax, [esi+4]
		test	eax, eax
		jz	short loc_28A
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_28A:				; CODE XREF: _sk_dup+3Bj
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_293:				; CODE XREF: _sk_dup+15j
		pop	edi
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_298:				; CODE XREF: _sk_dup+34j
		mov	[esi+4], ecx
		mov	eax, [edi]
		mov	[esi], eax
		mov	eax, [edi]
		shl	eax, 2
		push	eax		; Size
		push	dword ptr [edi+4] ; Src
		push	ecx		; Dst
		call	_memcpy
		mov	eax, [edi+8]
		add	esp, 0Ch
		mov	[esi+8], eax
		mov	eax, [edi+0Ch]
		mov	[esi+0Ch], eax
		mov	eax, [edi+10h]
		mov	[esi+10h], eax
		mov	eax, esi
		pop	edi
		pop	esi
		retn
_sk_dup		endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2C8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _sk_find
_sk_find	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	2
		push	[esp+4+arg_4]
		push	[esp+8+arg_0]
		call	_internal_find
		add	esp, 0Ch
		retn
_sk_find	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2DCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _sk_find_ex
_sk_find_ex	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	1
		push	[esp+4+arg_4]
		push	[esp+8+arg_0]
		call	_internal_find
		add	esp, 0Ch
		retn
_sk_find_ex	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2F0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _sk_free
_sk_free	proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	short loc_312
		mov	eax, [esi+4]
		test	eax, eax
		jz	short loc_309
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_309:				; CODE XREF: _sk_free+Ej
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_312:				; CODE XREF: _sk_free+7j
		pop	esi
		retn
_sk_free	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 314h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _sk_insert
_sk_insert	proc near		; CODE XREF: _sk_push+Bp
					; _sk_unshift+Ap

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jnz	short loc_321

loc_31D:				; CODE XREF: _sk_insert+36j
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_321:				; CODE XREF: _sk_insert+7j
		mov	eax, [esi]
		mov	ecx, [esi+0Ch]
		inc	eax
		cmp	ecx, eax
		jg	short loc_357
		push	0BBh ; '»'
		push	offset ??_C@_0BH@GBDCJGGB@?4?2crypto?2stack?2stack?4c?$AA@ ; ".\\crypto\\stack\\stack.c"
		lea	eax, ds:0[ecx*8]
		push	eax
		push	dword ptr [esi+4]
		call	_CRYPTO_realloc
		add	esp, 10h
		test	eax, eax
		jz	short loc_31D
		mov	[esi+4], eax
		mov	eax, [esi+0Ch]
		add	eax, eax
		mov	[esi+0Ch], eax

loc_357:				; CODE XREF: _sk_insert+15j
		mov	edx, [esi]
		push	edi
		mov	edi, [esp+8+arg_8]
		cmp	edi, edx
		jge	short loc_3A0
		test	edi, edi
		js	short loc_3A0
		push	ebx
		mov	ebx, [esi+4]
		lea	eax, [ebx+4]
		cmp	edx, edi
		jl	short loc_387
		lea	ecx, [eax+edx*4]
		sub	ebx, eax
		sub	edx, edi
		inc	edx

loc_379:				; CODE XREF: _sk_insert+71j
		mov	eax, [ebx+ecx]
		lea	ecx, [ecx-4]
		mov	[ecx+4], eax
		sub	edx, 1
		jnz	short loc_379

loc_387:				; CODE XREF: _sk_insert+5Bj
		mov	ecx, [esi+4]
		mov	eax, [esp+0Ch+arg_4]
		pop	ebx
		mov	[ecx+edi*4], eax
		inc	dword ptr [esi]
		mov	eax, [esi]
		pop	edi
		mov	dword ptr [esi+8], 0
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_3A0:				; CODE XREF: _sk_insert+4Cj
					; _sk_insert+50j
		mov	ecx, [esi+4]
		mov	eax, [esp+8+arg_4]
		pop	edi
		mov	[ecx+edx*4], eax
		inc	dword ptr [esi]
		mov	eax, [esi]
		mov	dword ptr [esi+8], 0
		pop	esi
		retn
_sk_insert	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3B8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _sk_is_sorted
_sk_is_sorted	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jnz	short loc_3C6
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_3C6:				; CODE XREF: _sk_is_sorted+6j
		mov	eax, [eax+8]
		retn
_sk_is_sorted	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3CCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _sk_new
_sk_new		proc near		; CODE XREF: _sk_dup+9p
					; _sk_new_null+2p

arg_0		= dword	ptr  4

		push	esi
		push	0A2h ; '¢'
		push	offset ??_C@_0BH@GBDCJGGB@?4?2crypto?2stack?2stack?4c?$AA@ ; ".\\crypto\\stack\\stack.c"
		push	14h
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jz	short loc_40B
		push	0A4h ; '¤'
		push	offset ??_C@_0BH@GBDCJGGB@?4?2crypto?2stack?2stack?4c?$AA@ ; ".\\crypto\\stack\\stack.c"
		push	10h
		call	_CRYPTO_malloc
		add	esp, 0Ch
		mov	[esi+4], eax
		test	eax, eax
		jnz	short loc_40F

$err$18:
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_40B:				; CODE XREF: _sk_new+19j
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_40F:				; CODE XREF: _sk_new+34j
		mov	dword ptr [eax], 0
		mov	eax, [esi+4]
		mov	dword ptr [eax+4], 0
		mov	eax, [esi+4]
		mov	dword ptr [eax+8], 0
		mov	eax, [esi+4]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [esp+4+arg_0]
		mov	[esi+10h], eax
		mov	eax, esi
		mov	dword ptr [esi+0Ch], 4
		mov	dword ptr [esi], 0
		mov	dword ptr [esi+8], 0
		pop	esi
		retn
_sk_new		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 454h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _sk_new_null
_sk_new_null	proc near
		push	0
		call	_sk_new
		add	esp, 4
		retn
_sk_new_null	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 460h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _sk_num
_sk_num		proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jnz	short loc_46C
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_46C:				; CODE XREF: _sk_num+6j
		mov	eax, [eax]
		retn
_sk_num		endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 470h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _sk_pop
_sk_pop		proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jnz	short loc_47B

loc_478:				; CODE XREF: _sk_pop+Fj
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_47B:				; CODE XREF: _sk_pop+6j
		mov	eax, [ecx]
		test	eax, eax
		jle	short loc_478
		dec	eax
		push	eax
		push	ecx
		call	_sk_delete
		add	esp, 8
		retn
_sk_pop		endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 490h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _sk_pop_free
_sk_pop_free	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	edi
		mov	edi, [esp+4+arg_0]
		test	edi, edi
		jz	short loc_4D5
		push	esi
		xor	esi, esi
		cmp	[edi], esi
		jle	short loc_4BB
		push	ebx
		mov	ebx, [esp+0Ch+arg_4]

loc_4A5:				; CODE XREF: _sk_pop_free+28j
		mov	eax, [edi+4]
		mov	eax, [eax+esi*4]
		test	eax, eax
		jz	short loc_4B5
		push	eax
		call	ebx
		add	esp, 4

loc_4B5:				; CODE XREF: _sk_pop_free+1Dj
		inc	esi
		cmp	esi, [edi]
		jl	short loc_4A5
		pop	ebx

loc_4BB:				; CODE XREF: _sk_pop_free+Ej
		mov	eax, [edi+4]
		pop	esi
		test	eax, eax
		jz	short loc_4CC
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_4CC:				; CODE XREF: _sk_pop_free+31j
		push	edi
		call	_CRYPTO_free
		add	esp, 4

loc_4D5:				; CODE XREF: _sk_pop_free+7j
		pop	edi
		retn
_sk_pop_free	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4D8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _sk_push
_sk_push	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		push	dword ptr [eax]
		push	[esp+4+arg_4]
		push	eax
		call	_sk_insert
		add	esp, 0Ch
		retn
_sk_push	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4ECh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _sk_set
_sk_set		proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jz	short loc_50B
		mov	edx, [esp+arg_4]
		test	edx, edx
		js	short loc_50B
		cmp	edx, [ecx]
		jge	short loc_50B
		mov	ecx, [ecx+4]
		mov	eax, [esp+arg_8]
		mov	[ecx+edx*4], eax
		retn
; ---------------------------------------------------------------------------

loc_50B:				; CODE XREF: _sk_set+6j _sk_set+Ej ...
		xor	eax, eax
		retn
_sk_set		endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 510h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _sk_set_cmp_func
_sk_set_cmp_func proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		mov	edx, [esp+arg_4]
		mov	eax, [ecx+10h]
		mov	[ecx+10h], edx
		cmp	eax, edx
		jz	short locret_529
		mov	dword ptr [ecx+8], 0

locret_529:				; CODE XREF: _sk_set_cmp_func+10j
		retn
_sk_set_cmp_func endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 52Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _sk_shift
_sk_shift	proc near

arg_0		= dword	ptr  4

		mov	edx, [esp+arg_0]
		test	edx, edx
		jnz	short loc_537

loc_534:				; CODE XREF: _sk_shift+Fj
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_537:				; CODE XREF: _sk_shift+6j
		mov	ecx, [edx]
		test	ecx, ecx
		jle	short loc_534
		mov	eax, [edx+4]
		push	ebx
		push	edi
		lea	edi, [ecx-1]
		mov	ebx, [eax]
		test	edi, edi
		jz	short loc_563
		push	esi
		xor	esi, esi
		test	edi, edi
		jle	short loc_562

loc_552:				; CODE XREF: _sk_shift+34j
		mov	eax, [edx+4]
		lea	ecx, [eax+esi*4]
		inc	esi
		mov	eax, [ecx+4]
		mov	[ecx], eax
		cmp	esi, edi
		jl	short loc_552

loc_562:				; CODE XREF: _sk_shift+24j
		pop	esi

loc_563:				; CODE XREF: _sk_shift+1Dj
		dec	dword ptr [edx]
		mov	eax, ebx
		pop	edi
		pop	ebx
		retn
_sk_shift	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 56Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _sk_sort
_sk_sort	proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	short loc_59A
		cmp	dword ptr [esi+8], 0
		jnz	short loc_59A
		mov	eax, [esi+10h]
		test	eax, eax
		jz	short loc_59A
		push	eax		; PtFuncCompare
		push	4		; SizeOfElements
		push	dword ptr [esi]	; NumOfElements
		push	dword ptr [esi+4] ; Base
		call	dword ptr ds:__imp__qsort
		add	esp, 10h
		mov	dword ptr [esi+8], 1

loc_59A:				; CODE XREF: _sk_sort+7j _sk_sort+Dj ...
		pop	esi
		retn
_sk_sort	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 59Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _sk_unshift
_sk_unshift	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	0
		push	[esp+4+arg_4]
		push	[esp+8+arg_0]
		call	_sk_insert
		add	esp, 0Ch
		retn
_sk_unshift	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5B0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _sk_value
_sk_value	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short loc_5CB
		mov	ecx, [esp+arg_4]
		test	ecx, ecx
		js	short loc_5CB
		cmp	ecx, [eax]
		jge	short loc_5CB
		mov	eax, [eax+4]
		mov	eax, [eax+ecx*4]
		retn
; ---------------------------------------------------------------------------

loc_5CB:				; CODE XREF: _sk_value+6j _sk_value+Ej ...
		xor	eax, eax
		retn
_sk_value	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5D0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _sk_zero
_sk_zero	proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	short loc_5F6
		mov	eax, [esi]
		test	eax, eax
		jle	short loc_5F6
		shl	eax, 2
		push	eax		; Size
		push	0		; Val
		push	dword ptr [esi+4] ; Dst
		call	_memset
		add	esp, 0Ch
		mov	dword ptr [esi], 0

loc_5F6:				; CODE XREF: _sk_zero+7j _sk_zero+Dj
		pop	esi
		retn
_sk_zero	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5F8h
; COMDAT (pick any)
		public ??_C@_0BH@GBDCJGGB@?4?2crypto?2stack?2stack?4c?$AA@
; `string'
??_C@_0BH@GBDCJGGB@?4?2crypto?2stack?2stack?4c?$AA@ db '.\crypto\stack\stack.c',0
					; DATA XREF: _sk_deep_copy+3o
					; _sk_deep_copy+29o ...
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; void __cdecl _qsort(void *Base, size_t NumOfElements,	size_t SizeOfElements, int (__cdecl *PtFuncCompare)(const void *, const	void *))
		extrn __imp__qsort:near	; CODE XREF: _internal_find+3Fp
					; _sk_sort+1Ep
					; DATA XREF: ...
		extrn _CRYPTO_malloc:near ; CODE XREF: _sk_deep_copy+Ap
					; _sk_deep_copy+4Ep ...
		extrn _CRYPTO_free:near	; CODE XREF: _sk_deep_copy+5Ep
					; _sk_deep_copy+DDp ...
		extrn _CRYPTO_realloc:near ; CODE XREF:	_sk_dup+28p
					; _sk_insert+2Cp
		extrn _OBJ_bsearch_ex_:near ; CODE XREF: _internal_find+69p
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _sk_dup+65p
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _sk_zero+18p


		end
