;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	3E4F27BB6755599B84233BF5374495C6
; Input	CRC32 :	B9EED7B0

; File Name   :	C:\compspace\Diff\openssl\obj\ecs_lib.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		public _ECDSA_version
_ECDSA_version	db 'ECDSA part of OpenSSL 1.0.2h  3 May 2016',0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 2Ch
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
_default_ECDSA_method dd ?		; DATA XREF: _ECDSA_DATA_new_method:loc_61r
					; _ECDSA_DATA_new_method+45w ...
_bss		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 30h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ECDSA_DATA_new_method proc near	; CODE XREF: _ecdsa_check+25p
					; _ecdsa_data_dup+12j ...

arg_0		= dword	ptr  4

		push	esi
		push	77h ; 'w'
		push	offset ??_C@_0BJ@FFOJENDB@?4?2crypto?2ecdsa?2ecs_lib?4c?$AA@ ; ".\\crypto\\ecdsa\\ecs_lib.c"
		push	18h
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jnz	short loc_61
		push	79h ; 'y'
		push	offset ??_C@_0BJ@FFOJENDB@?4?2crypto?2ecdsa?2ecs_lib?4c?$AA@ ; ".\\crypto\\ecdsa\\ecs_lib.c"
		push	41h ; 'A'
		push	64h ; 'd'
		push	2Ah ; '*'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_61:					; CODE XREF: _ECDSA_DATA_new_method+16j
		mov	eax, ds:_default_ECDSA_method
		mov	dword ptr [esi], 0
		test	eax, eax
		jnz	short loc_7A
		call	_ECDSA_OpenSSL
		mov	ds:_default_ECDSA_method, eax

loc_7A:					; CODE XREF: _ECDSA_DATA_new_method+3Ej
		mov	[esi+0Ch], eax
		mov	eax, [esp+4+arg_0]
		mov	[esi+4], eax
		test	eax, eax
		jnz	short loc_90
		call	_ENGINE_get_default_ECDSA
		mov	[esi+4], eax

loc_90:					; CODE XREF: _ECDSA_DATA_new_method+56j
		mov	eax, [esi+4]
		test	eax, eax
		jz	short loc_D1
		push	eax
		call	_ENGINE_get_ECDSA
		add	esp, 4
		mov	[esi+0Ch], eax
		test	eax, eax
		jnz	short loc_D1
		push	87h ; '‡'
		push	offset ??_C@_0BJ@FFOJENDB@?4?2crypto?2ecdsa?2ecs_lib?4c?$AA@ ; ".\\crypto\\ecdsa\\ecs_lib.c"
		push	26h ; '&'
		push	64h ; 'd'
		push	2Ah ; '*'
		call	_ERR_put_error
		push	dword ptr [esi+4]
		call	_ENGINE_finish
		push	esi
		call	_CRYPTO_free
		add	esp, 1Ch
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_D1:					; CODE XREF: _ECDSA_DATA_new_method+65j
					; _ECDSA_DATA_new_method+75j
		mov	eax, [esi+0Ch]
		mov	eax, [eax+10h]
		mov	[esi+8], eax
		lea	eax, [esi+10h]
		push	eax
		push	esi
		push	0Ch
		call	_CRYPTO_new_ex_data
		add	esp, 0Ch
		mov	eax, esi
		pop	esi
		retn
_ECDSA_DATA_new_method endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ECDSA_METHOD_free
_ECDSA_METHOD_free proc	near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	byte ptr [eax+10h], 2
		jz	short locret_103
		mov	[esp+arg_0], eax
		jmp	_CRYPTO_free
; ---------------------------------------------------------------------------

locret_103:				; CODE XREF: _ECDSA_METHOD_free+8j
		retn
_ECDSA_METHOD_free endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 104h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ECDSA_METHOD_get_app_data
_ECDSA_METHOD_get_app_data proc	near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+14h]
		retn
_ECDSA_METHOD_get_app_data endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 10Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ECDSA_METHOD_new
_ECDSA_METHOD_new proc near

arg_0		= dword	ptr  4

		push	11Bh
		push	offset ??_C@_0BJ@FFOJENDB@?4?2crypto?2ecdsa?2ecs_lib?4c?$AA@ ; ".\\crypto\\ecdsa\\ecs_lib.c"
		push	18h
		call	_CRYPTO_malloc
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_13F
		push	11Dh
		push	offset ??_C@_0BJ@FFOJENDB@?4?2crypto?2ecdsa?2ecs_lib?4c?$AA@ ; ".\\crypto\\ecdsa\\ecs_lib.c"
		push	41h ; 'A'
		push	69h ; 'i'
		push	2Ah ; '*'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_13F:				; CODE XREF: _ECDSA_METHOD_new+16j
		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jz	short loc_15C
		movups	xmm0, xmmword ptr [ecx]
		movups	xmmword	ptr [eax], xmm0
		movq	xmm0, qword ptr	[ecx+10h]
		movq	qword ptr [eax+10h], xmm0
		or	dword ptr [eax+10h], 2
		retn
; ---------------------------------------------------------------------------

loc_15C:				; CODE XREF: _ECDSA_METHOD_new+39j
		mov	dword ptr [eax+10h], 0
		or	dword ptr [eax+10h], 2
		mov	dword ptr [eax+8], 0
		mov	dword ptr [eax+4], 0
		mov	dword ptr [eax+0Ch], 0
		mov	dword ptr [eax], 0
		retn
_ECDSA_METHOD_new endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 184h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ECDSA_METHOD_set_app_data
_ECDSA_METHOD_set_app_data proc	near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+14h], ecx
		retn
_ECDSA_METHOD_set_app_data endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 190h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ECDSA_METHOD_set_flags
_ECDSA_METHOD_set_flags	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		or	ecx, 2
		mov	[eax+10h], ecx
		retn
_ECDSA_METHOD_set_flags	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1A0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ECDSA_METHOD_set_name
_ECDSA_METHOD_set_name proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax], ecx
		retn
_ECDSA_METHOD_set_name endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1ACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ECDSA_METHOD_set_sign
_ECDSA_METHOD_set_sign proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+4], ecx
		retn
_ECDSA_METHOD_set_sign endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1B8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ECDSA_METHOD_set_sign_setup
_ECDSA_METHOD_set_sign_setup proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+8], ecx
		retn
_ECDSA_METHOD_set_sign_setup endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1C4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ECDSA_METHOD_set_verify
_ECDSA_METHOD_set_verify proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+0Ch], ecx
		retn
_ECDSA_METHOD_set_verify endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1D0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ECDSA_get_default_method
_ECDSA_get_default_method proc near
		mov	eax, ds:_default_ECDSA_method
		test	eax, eax
		jnz	short locret_1E3
		call	_ECDSA_OpenSSL
		mov	ds:_default_ECDSA_method, eax

locret_1E3:				; CODE XREF: _ECDSA_get_default_method+7j
		retn
_ECDSA_get_default_method endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1E4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ECDSA_get_ex_data
_ECDSA_get_ex_data proc	near

arg_0		= dword	ptr  4

		push	[esp+arg_0]
		call	_ecdsa_check
		add	esp, 4
		test	eax, eax
		jnz	short loc_1F5
		retn
; ---------------------------------------------------------------------------

loc_1F5:				; CODE XREF: _ECDSA_get_ex_data+Ej
		add	eax, 10h
		mov	[esp+arg_0], eax
		jmp	_CRYPTO_get_ex_data
_ECDSA_get_ex_data endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 204h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ECDSA_get_ex_new_index
_ECDSA_get_ex_new_index	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		push	[esp+arg_10]
		push	[esp+4+arg_C]
		push	[esp+8+arg_8]
		push	[esp+0Ch+arg_4]
		push	[esp+10h+arg_0]
		push	0Ch
		call	_CRYPTO_get_ex_new_index
		add	esp, 18h
		retn
_ECDSA_get_ex_new_index	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 224h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ECDSA_set_default_method
_ECDSA_set_default_method proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	ds:_default_ECDSA_method, eax
		retn
_ECDSA_set_default_method endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 230h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ECDSA_set_ex_data
_ECDSA_set_ex_data proc	near

arg_0		= dword	ptr  4

		push	[esp+arg_0]
		call	_ecdsa_check
		add	esp, 4
		test	eax, eax
		jnz	short loc_241
		retn
; ---------------------------------------------------------------------------

loc_241:				; CODE XREF: _ECDSA_set_ex_data+Ej
		add	eax, 10h
		mov	[esp+arg_0], eax
		jmp	_CRYPTO_set_ex_data
_ECDSA_set_ex_data endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 250h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ECDSA_set_method
_ECDSA_set_method proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		push	[esp+4+arg_0]
		call	_ecdsa_check
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jnz	short loc_265
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_265:				; CODE XREF: _ECDSA_set_method+11j
		mov	eax, [esi+4]
		test	eax, eax
		jz	short loc_27C
		push	eax
		call	_ENGINE_finish
		add	esp, 4
		mov	dword ptr [esi+4], 0

loc_27C:				; CODE XREF: _ECDSA_set_method+1Aj
		mov	eax, [esp+4+arg_4]
		mov	[esi+0Ch], eax
		mov	eax, 1
		pop	esi
		retn
_ECDSA_set_method endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 28Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ECDSA_size
_ECDSA_size	proc near

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  4

		mov	eax, 10h
		call	__chkstk
		mov	eax, [esp+10h+arg_0]
		test	eax, eax
		jnz	short loc_2A2
		add	esp, 10h
		retn
; ---------------------------------------------------------------------------

loc_2A2:				; CODE XREF: _ECDSA_size+10j
		push	esi
		push	eax
		call	_EC_KEY_get0_group
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jnz	short loc_2B7
		pop	esi
		add	esp, 10h
		retn
; ---------------------------------------------------------------------------

loc_2B7:				; CODE XREF: _ECDSA_size+24j
		push	edi
		call	_BN_new
		mov	edi, eax
		test	edi, edi
		jz	short loc_2DC
		push	0
		push	edi
		push	esi
		call	_EC_GROUP_get_order
		add	esp, 0Ch
		push	edi
		test	eax, eax
		jnz	short loc_2E4
		call	_BN_clear_free
		add	esp, 4

loc_2DC:				; CODE XREF: _ECDSA_size+35j
		pop	edi
		xor	eax, eax
		pop	esi
		add	esp, 10h
		retn
; ---------------------------------------------------------------------------

loc_2E4:				; CODE XREF: _ECDSA_size+46j
		call	_BN_num_bits
		add	eax, 7
		mov	[esp+1Ch+var_C], 2
		cdq
		and	edx, 7
		mov	byte ptr [esp+1Ch+arg_0], 0FFh
		add	eax, edx
		sar	eax, 3
		mov	[esp+1Ch+var_10], eax
		lea	eax, [esp+1Ch+arg_0]
		mov	[esp+1Ch+var_8], eax
		lea	eax, [esp+1Ch+var_10]
		push	0
		push	eax
		call	_i2d_ASN1_INTEGER
		add	eax, eax
		push	10h
		push	eax
		push	1
		call	_ASN1_object_size
		push	edi
		mov	esi, eax
		call	_BN_clear_free
		add	esp, 1Ch
		mov	eax, esi
		pop	edi
		pop	esi
		add	esp, 10h
		retn
_ECDSA_size	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 33Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ecdsa_check
_ecdsa_check	proc near		; CODE XREF: _ECDSA_get_ex_data+4p
					; _ECDSA_set_ex_data+4p ...

arg_0		= dword	ptr  4

		push	esi
		push	edi
		mov	edi, [esp+8+arg_0]
		push	offset _ecdsa_data_free
		push	offset _ecdsa_data_free
		push	offset _ecdsa_data_dup
		push	edi
		call	_EC_KEY_get_key_method_data
		mov	esi, eax
		add	esp, 10h
		test	esi, esi
		jnz	short loc_39C
		push	eax
		call	_ECDSA_DATA_new_method
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jnz	short loc_372
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_372:				; CODE XREF: _ecdsa_check+31j
		push	offset _ecdsa_data_free
		push	offset _ecdsa_data_free
		push	offset _ecdsa_data_dup
		push	esi
		push	edi
		call	_EC_KEY_insert_key_method_data
		mov	edi, eax
		add	esp, 14h
		test	edi, edi
		jz	short loc_39C
		push	esi
		call	_ecdsa_data_free
		add	esp, 4
		mov	esi, edi

loc_39C:				; CODE XREF: _ecdsa_check+22j
					; _ecdsa_check+53j
		pop	edi
		mov	eax, esi
		pop	esi
		retn
_ecdsa_check	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3A4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ecdsa_data_dup	proc near		; DATA XREF: _ecdsa_check+10o
					; _ecdsa_check+40o

arg_0		= dword	ptr  4

		cmp	[esp+arg_0], 0
		jnz	short loc_3AE
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_3AE:				; CODE XREF: _ecdsa_data_dup+5j
		mov	[esp+arg_0], 0
		jmp	_ECDSA_DATA_new_method
_ecdsa_data_dup	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3BCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ecdsa_data_free proc near		; CODE XREF: _ecdsa_check+56p
					; DATA XREF: _ecdsa_check+6o ...

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, [esi+4]
		test	eax, eax
		jz	short loc_3D1
		push	eax
		call	_ENGINE_finish
		add	esp, 4

loc_3D1:				; CODE XREF: _ecdsa_data_free+Aj
		lea	eax, [esi+10h]
		push	eax
		push	esi
		push	0Ch
		call	_CRYPTO_free_ex_data
		push	18h
		push	esi
		call	_OPENSSL_cleanse
		push	esi
		call	_CRYPTO_free
		add	esp, 18h
		pop	esi
		retn
_ecdsa_data_free endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3F0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ecdsa_data_new	proc near
		push	0
		call	_ECDSA_DATA_new_method
		add	esp, 4
		retn
_ecdsa_data_new	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3FCh
; COMDAT (pick any)
		public ??_C@_0BJ@FFOJENDB@?4?2crypto?2ecdsa?2ecs_lib?4c?$AA@
; `string'
??_C@_0BJ@FFOJENDB@?4?2crypto?2ecdsa?2ecs_lib?4c?$AA@ db '.\crypto\ecdsa\ecs_lib.c',0
					; DATA XREF: _ECDSA_DATA_new_method+3o
					; _ECDSA_DATA_new_method+1Ao ...
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _CRYPTO_get_ex_new_index:near ; CODE XREF: _ECDSA_get_ex_new_index+16p
		extrn _CRYPTO_new_ex_data:near ; CODE XREF: _ECDSA_DATA_new_method+B1p
		extrn _CRYPTO_free_ex_data:near	; CODE XREF: _ecdsa_data_free+1Cp
		extrn _CRYPTO_set_ex_data:near ; CODE XREF: _ECDSA_set_ex_data+18j
		extrn _CRYPTO_get_ex_data:near ; CODE XREF: _ECDSA_get_ex_data+18j
		extrn _CRYPTO_malloc:near ; CODE XREF: _ECDSA_DATA_new_method+Ap
					; _ECDSA_METHOD_new+Cp
		extrn _CRYPTO_free:near	; CODE XREF: _ECDSA_DATA_new_method+95p
					; _ECDSA_METHOD_free+Ej ...
		extrn _OPENSSL_cleanse:near ; CODE XREF: _ecdsa_data_free+24p
		extrn _BN_num_bits:near	; CODE XREF: _ECDSA_size:loc_2E4p
		extrn _BN_new:near	; CODE XREF: _ECDSA_size+2Cp
		extrn _BN_clear_free:near ; CODE XREF: _ECDSA_size+48p
					; _ECDSA_size+9Dp
		extrn _i2d_ASN1_INTEGER:near ; CODE XREF: _ECDSA_size+89p
		extrn _ASN1_object_size:near ; CODE XREF: _ECDSA_size+95p
		extrn _EC_GROUP_get_order:near ; CODE XREF: _ECDSA_size+3Bp
		extrn _EC_KEY_get0_group:near ;	CODE XREF: _ECDSA_size+18p
		extrn _EC_KEY_get_key_method_data:near ; CODE XREF: _ecdsa_check+16p
		extrn _EC_KEY_insert_key_method_data:near ; CODE XREF: _ecdsa_check+47p
		extrn _ECDSA_OpenSSL:near ; CODE XREF: _ECDSA_DATA_new_method+40p
					; _ECDSA_get_default_method+9p
		extrn _ERR_put_error:near ; CODE XREF: _ECDSA_DATA_new_method+25p
					; _ECDSA_DATA_new_method+87p ...
		extrn _ENGINE_get_ECDSA:near ; CODE XREF: _ECDSA_DATA_new_method+68p
		extrn _ENGINE_finish:near ; CODE XREF: _ECDSA_DATA_new_method+8Fp
					; _ECDSA_set_method+1Dp ...
		extrn _ENGINE_get_default_ECDSA:near ; CODE XREF: _ECDSA_DATA_new_method+58p
		extrn __chkstk:near	; CODE XREF: _ECDSA_size+5p


		end
