;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	5339E379A7874486FE0BC9B6E90011A4
; Input	CRC32 :	14662D03

; File Name   :	C:\compspace\Diff\openssl\obj\err.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data		segment	para public 'DATA' use32
		assume cs:_data
_ERR_str_libraries dd 1000000h		; DATA XREF: _ERR_load_ERR_strings:loc_2DD7r
					; _ERR_load_ERR_strings+4Fo
		dd offset ??_C@_0BA@JLJAKIKL@unknown?5library?$AA@ ; "unknown library"
		dd 2000000h
		dd offset ??_C@_0P@KJHLNCML@system?5library?$AA@ ; "system library"
		dd 3000000h
		dd offset ??_C@_0BA@BALAMMCD@bignum?5routines?$AA@ ; "bignum routines"
		dd 4000000h
		dd offset ??_C@_0N@FLFIDGHD@rsa?5routines?$AA@ ; "rsa routines"
dword_20	dd 5000000h		; DATA XREF: .data:000001C0o
					; .data:000001C8o ...
off_24		dd offset ??_C@_0BI@BELEOFAM@Diffie?9Hellman?5routines?$AA@
					; DATA XREF: .data:000001E0o
					; .data:000001E8o ...
					; "Diffie-Hellman routines"
		dd 6000000h
off_2C		dd offset ??_C@_0BK@KCBHLAIJ@digital?5envelope?5routines?$AA@
					; DATA XREF: .data:00000200o
					; "digital envelope routines"
		dd 7000000h
		dd offset ??_C@_0BH@GHBGFOKA@memory?5buffer?5routines?$AA@ ; "memory buffer routines"
dword_38	dd 8000000h		; DATA XREF: .data:00000208o
					; .data:00000210o
off_3C		dd offset ??_C@_0BL@GAJLDLEG@object?5identifier?5routines?$AA@
					; DATA XREF: .data:00000218o
					; .data:00000220o ...
					; "object identifier routines"
dword_40	dd 9000000h		; DATA XREF: .data:00000238o
					; .data:00000240o ...
off_44		dd offset ??_C@_0N@PPOIEGDJ@PEM?5routines?$AA@ ; DATA XREF: .data:00000258o
					; .data:00000260o
					; "PEM routines"
		dd 0A000000h
		dd offset ??_C@_0N@EPLKEPHE@dsa?5routines?$AA@ ; "dsa routines"
		dd 0B000000h
		dd offset ??_C@_0BK@MLDIFNOG@x509?5certificate?5routines?$AA@ ;	"x509 certificate routines"
		dd 0D000000h
		dd offset ??_C@_0BH@OKMDKJBH@asn1?5encoding?5routines?$AA@ ; "asn1 encoding routines"
		dd 0E000000h
		dd offset ??_C@_0BM@FNIFPKKP@configuration?5file?5routines?$AA@	; "configuration file routines"
		dd 0F000000h
		dd offset ??_C@_0BK@GOIAPJCF@common?5libcrypto?5routines?$AA@ ;	"common	libcrypto routines"
		dd 10000000h
		dd offset ??_C@_0BI@NNCFPCDI@elliptic?5curve?5routines?$AA@ ; "elliptic	curve routines"
		dd 14000000h
		dd offset ??_C@_0N@GAIJLNCL@SSL?5routines?$AA@ ; "SSL routines"
dword_80	dd 20000000h		; DATA XREF: .data:_int_err_library_numbero
		dd offset ??_C@_0N@HGNFKBOI@BIO?5routines?$AA@ ; "BIO routines"
		dd 21000000h
		dd offset ??_C@_0P@FBDCKDAN@PKCS7?5routines?$AA@ ; "PKCS7 routines"
		dd 22000000h
		dd offset ??_C@_0BB@LKDEPKLM@X509?5V3?5routines?$AA@ ; "X509 V3	routines"
		dd 23000000h
		dd offset ??_C@_0BA@KPFPMFD@PKCS12?5routines?$AA@ ; "PKCS12 routines"
		dd 24000000h
		dd offset ??_C@_0BI@GMPKPCPG@random?5number?5generator?$AA@ ; "random number generator"
		dd 25000000h
		dd offset ??_C@_0BF@BDHLAIEM@DSO?5support?5routines?$AA@ ; "DSO	support	routines"
		dd 2F000000h
		dd offset ??_C@_0BE@IMHDPIMO@time?5stamp?5routines?$AA@	; "time	stamp routines"
		dd 26000000h
		dd offset ??_C@_0BA@MMHCJFKD@engine?5routines?$AA@ ; "engine routines"
		dd 27000000h
		dd offset ??_C@_0O@LJIADBLP@OCSP?5routines?$AA@	; "OCSP	routines"
		dd 2D000000h
		dd offset ??_C@_0O@MDPFBMCI@FIPS?5routines?$AA@	; "FIPS	routines"
		dd 2E000000h
		dd offset ??_C@_0N@MKJBFBO@CMS?5routines?$AA@ ;	"CMS routines"
		dd 30000000h
		dd offset ??_C@_0O@PBJMEGGG@HMAC?5routines?$AA@	; "HMAC	routines"
		dd 2 dup(0)
_ERR_str_functs	dd offset dword_1000	; DATA XREF: _ERR_load_ERR_strings:loc_2E26r
					; _ERR_load_ERR_strings+9Do
		dd offset ??_C@_05FFKPLNPJ@fopen?$AA@ ;	"fopen"
		dd offset ?strerror_tab@?1??build_SYS_str_reasons@@9@9+0E98h
		dd offset ??_C@_07KAIBNCHO@connect?$AA@	; "connect"
		dd offset loc_3000
		dd offset ??_C@_0O@NKLJGHIL@getservbyname?$AA@ ; "getservbyname"
		dd 4000h
		dd offset ??_C@_06HBELJPBO@socket?$AA@ ; "socket"
		dd 5000h
		dd offset ??_C@_0M@PBPOCKDG@ioctlsocket?$AA@ ; "ioctlsocket"
		dd 6000h
		dd offset ??_C@_04NPNJNMMP@bind?$AA@ ; "bind"
		dd 7000h
		dd offset ??_C@_06OODDLKLE@listen?$AA@ ; "listen"
		dd 8000h
		dd offset ??_C@_06MPKMECK@accept?$AA@ ;	"accept"
		dd 9000h
		dd offset ??_C@_0L@LNCNEFCG@WSAstartup?$AA@ ; "WSAstartup"
		dd 0A000h
		dd offset ??_C@_07OPAOJOOA@opendir?$AA@	; "opendir"
		dd 0B000h
		dd offset ??_C@_05FHPOAJDB@fread?$AA@ ;	"fread"
		dd 2 dup(0)
_ERR_str_reasons dd 2			; DATA XREF: _ERR_load_ERR_strings:loc_2DFCr
					; _ERR_load_ERR_strings+73o
		dd offset ??_C@_0L@NFMIFFDK@system?5lib?$AA@ ; "system lib"
		dd 3
		dd offset ??_C@_06CEKJLBPI@BN?5lib?$AA@	; "BN lib"
		dd 4
		dd offset ??_C@_07PLBLGAPL@RSA?5lib?$AA@ ; "RSA	lib"
		dd 5
		dd offset ??_C@_06JBCAGHNP@DH?5lib?$AA@	; "DH lib"
		dd 6
		dd offset ??_C@_07BHNHKGFA@EVP?5lib?$AA@ ; "EVP	lib"
		dd 7
		dd offset ??_C@_07PJHFFEFC@BUF?5lib?$AA@ ; "BUF	lib"
		dd 8
		dd offset ??_C@_07LHMLCDLI@OBJ?5lib?$AA@ ; "OBJ	lib"
		dd 9
		dd offset ??_C@_07MKPCAOAJ@PEM?5lib?$AA@ ; "PEM	lib"
		dd 0Ah
		dd offset ??_C@_07EBMPFIFH@DSA?5lib?$AA@ ; "DSA	lib"
		dd 0Bh
		dd offset ??_C@_08DGLLDICE@X509?5lib?$AA@ ; "X509 lib"
		dd 0Dh
		dd offset ??_C@_08HAFIEMCJ@ASN1?5lib?$AA@ ; "ASN1 lib"
		dd 0Eh
		dd offset ??_C@_08GDJNHNLC@CONF?5lib?$AA@ ; "CONF lib"
		dd 0Fh
		dd offset ??_C@_0L@GEIMIIEL@CRYPTO?5lib?$AA@ ; "CRYPTO lib"
		dd 10h
		dd offset ??_C@_06FNJAJMKI@EC?5lib?$AA@	; "EC lib"
		dd 14h
		dd offset ??_C@_07ILCPHDLL@SSL?5lib?$AA@ ; "SSL	lib"
		dd offset dword_20
		dd offset ??_C@_07HOAEPDCA@BIO?5lib?$AA@ ; "BIO	lib"
		dd offset dword_20+1
		dd offset ??_C@_09PFAKBDBP@PKCS7?5lib?$AA@ ; "PKCS7 lib"
		dd offset dword_20+2
		dd offset ??_C@_0L@OHLIEDB@X509V3?5lib?$AA@ ; "X509V3 lib"
		dd offset dword_20+3
		dd offset ??_C@_0L@FBHADCPC@PKCS12?5lib?$AA@ ; "PKCS12 lib"
		dd offset off_24
		dd offset ??_C@_08IAGEJILJ@RAND?5lib?$AA@ ; "RAND lib"
		dd offset off_24+1
		dd offset ??_C@_07HLMFDJCH@DSO?5lib?$AA@ ; "DSO	lib"
		dd offset off_24+2
		dd offset ??_C@_0L@NEGIHAGL@ENGINE?5lib?$AA@ ; "ENGINE lib"
		dd offset off_24+3
		dd offset ??_C@_08BIAIHGB@OCSP?5lib?$AA@ ; "OCSP lib"
		dd offset off_2C+3
		dd offset ??_C@_06JPOPAJEJ@TS?5lib?$AA@	; "TS lib"
		dd offset dword_38+2
		dd offset ??_C@_0BC@JPACPGKL@nested?5asn1?5error?$AA@ ;	"nested	asn1 error"
		dd offset dword_38+3
		dd offset ??_C@_0BH@LJENPHMF@bad?5asn1?5object?5header?$AA@ ; "bad asn1	object header"
		dd offset off_3C
		dd offset ??_C@_0BJ@KHBMOGBI@bad?5get?5asn1?5object?5call?$AA@ ; "bad get asn1 object call"
		dd offset off_3C+1
		dd offset ??_C@_0BL@PKJJDDDF@expecting?5an?5asn1?5sequence?$AA@	; "expecting an	asn1 sequence"
		dd offset off_3C+2
		dd offset ??_C@_0BF@JKEELALH@asn1?5length?5mismatch?$AA@ ; "asn1 length	mismatch"
		dd offset off_3C+3
		dd offset ??_C@_0BB@LLCBNOLO@missing?5asn1?5eos?$AA@ ; "missing	asn1 eos"
		dd offset dword_40
		dd offset ??_C@_05FAMCFOJB@fatal?$AA@ ;	"fatal"
		dd offset dword_40+1
		dd offset ??_C@_0P@BOLAOBGL@malloc?5failure?$AA@ ; "malloc failure"
		dd offset dword_40+2
		dd offset ??_C@_0CG@JFIACAPA@called?5a?5function?5you?5should?5not@ ; "called a	function you should not	call"
		dd offset dword_40+3
		dd offset ??_C@_0BI@MMHLKOF@passed?5a?5null?5parameter?$AA@ ; "passed a	null parameter"
		dd offset off_44
		dd offset ??_C@_0P@LPIEGNHB@internal?5error?$AA@ ; "internal error"
		dd offset off_44+1
		dd offset ??_C@_0DE@JBNNAKOP@called?5a?5function?5that?5was?5disab@ ; "called a	function that was disabled at "...
		align 10h
_int_err_library_number	dd offset dword_80 ; DATA XREF:	_int_err_get_next_lib+14r
					; _int_err_get_next_lib+2Bw
; `build_SYS_str_reasons'::`2'::init
?init@?1??build_SYS_str_reasons@@9@9 dd	1 ; DATA XREF: _build_SYS_str_reasons+16r
					; _build_SYS_str_reasons+5Fr ...
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 278h
; COMDAT (pick any)
		public ??_C@_0BA@JLJAKIKL@unknown?5library?$AA@
; `string'
??_C@_0BA@JLJAKIKL@unknown?5library?$AA@ db 'unknown library',0 ; DATA XREF: .data:00000004o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 288h
; COMDAT (pick any)
		public ??_C@_0P@KJHLNCML@system?5library?$AA@
; `string'
??_C@_0P@KJHLNCML@system?5library?$AA@ db 'system library',0 ; DATA XREF: .data:0000000Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 298h
; COMDAT (pick any)
		public ??_C@_0BA@BALAMMCD@bignum?5routines?$AA@
; `string'
??_C@_0BA@BALAMMCD@bignum?5routines?$AA@ db 'bignum routines',0 ; DATA XREF: .data:00000014o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2A8h
; COMDAT (pick any)
		public ??_C@_0N@FLFIDGHD@rsa?5routines?$AA@
; `string'
??_C@_0N@FLFIDGHD@rsa?5routines?$AA@ db	'rsa routines',0 ; DATA XREF: .data:0000001Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2B8h
; COMDAT (pick any)
		public ??_C@_0BI@BELEOFAM@Diffie?9Hellman?5routines?$AA@
; `string'
??_C@_0BI@BELEOFAM@Diffie?9Hellman?5routines?$AA@ db 'Diffie-Hellman routines',0
					; DATA XREF: .data:off_24o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2D0h
; COMDAT (pick any)
		public ??_C@_0BK@KCBHLAIJ@digital?5envelope?5routines?$AA@
; `string'
??_C@_0BK@KCBHLAIJ@digital?5envelope?5routines?$AA@ db 'digital envelope routines',0
					; DATA XREF: .data:off_2Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2ECh
; COMDAT (pick any)
		public ??_C@_0BH@GHBGFOKA@memory?5buffer?5routines?$AA@
; `string'
??_C@_0BH@GHBGFOKA@memory?5buffer?5routines?$AA@ db 'memory buffer routines',0
					; DATA XREF: .data:00000034o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 304h
; COMDAT (pick any)
		public ??_C@_0BL@GAJLDLEG@object?5identifier?5routines?$AA@
; `string'
??_C@_0BL@GAJLDLEG@object?5identifier?5routines?$AA@ db	'object identifier routines',0
					; DATA XREF: .data:off_3Co
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 320h
; COMDAT (pick any)
		public ??_C@_0N@PPOIEGDJ@PEM?5routines?$AA@
; `string'
??_C@_0N@PPOIEGDJ@PEM?5routines?$AA@ db	'PEM routines',0 ; DATA XREF: .data:off_44o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 330h
; COMDAT (pick any)
		public ??_C@_0N@EPLKEPHE@dsa?5routines?$AA@
; `string'
??_C@_0N@EPLKEPHE@dsa?5routines?$AA@ db	'dsa routines',0 ; DATA XREF: .data:0000004Co
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 340h
; COMDAT (pick any)
		public ??_C@_0BK@MLDIFNOG@x509?5certificate?5routines?$AA@
; `string'
??_C@_0BK@MLDIFNOG@x509?5certificate?5routines?$AA@ db 'x509 certificate routines',0
					; DATA XREF: .data:00000054o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 35Ch
; COMDAT (pick any)
		public ??_C@_0BH@OKMDKJBH@asn1?5encoding?5routines?$AA@
; `string'
??_C@_0BH@OKMDKJBH@asn1?5encoding?5routines?$AA@ db 'asn1 encoding routines',0
					; DATA XREF: .data:0000005Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 374h
; COMDAT (pick any)
		public ??_C@_0BM@FNIFPKKP@configuration?5file?5routines?$AA@
; `string'
??_C@_0BM@FNIFPKKP@configuration?5file?5routines?$AA@ db 'configuration file routines',0
					; DATA XREF: .data:00000064o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 390h
; COMDAT (pick any)
		public ??_C@_0BK@GOIAPJCF@common?5libcrypto?5routines?$AA@
; `string'
??_C@_0BK@GOIAPJCF@common?5libcrypto?5routines?$AA@ db 'common libcrypto routines',0
					; DATA XREF: .data:0000006Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3ACh
; COMDAT (pick any)
		public ??_C@_0BI@NNCFPCDI@elliptic?5curve?5routines?$AA@
; `string'
??_C@_0BI@NNCFPCDI@elliptic?5curve?5routines?$AA@ db 'elliptic curve routines',0
					; DATA XREF: .data:00000074o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3C4h
; COMDAT (pick any)
		public ??_C@_0N@GAIJLNCL@SSL?5routines?$AA@
; `string'
??_C@_0N@GAIJLNCL@SSL?5routines?$AA@ db	'SSL routines',0 ; DATA XREF: .data:0000007Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3D4h
; COMDAT (pick any)
		public ??_C@_0N@HGNFKBOI@BIO?5routines?$AA@
; `string'
??_C@_0N@HGNFKBOI@BIO?5routines?$AA@ db	'BIO routines',0 ; DATA XREF: .data:00000084o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3E4h
; COMDAT (pick any)
		public ??_C@_0P@FBDCKDAN@PKCS7?5routines?$AA@
; `string'
??_C@_0P@FBDCKDAN@PKCS7?5routines?$AA@ db 'PKCS7 routines',0 ; DATA XREF: .data:0000008Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3F4h
; COMDAT (pick any)
		public ??_C@_0BB@LKDEPKLM@X509?5V3?5routines?$AA@
; `string'
??_C@_0BB@LKDEPKLM@X509?5V3?5routines?$AA@ db 'X509 V3 routines',0
					; DATA XREF: .data:00000094o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 408h
; COMDAT (pick any)
		public ??_C@_0BA@KPFPMFD@PKCS12?5routines?$AA@
; `string'
??_C@_0BA@KPFPMFD@PKCS12?5routines?$AA@	db 'PKCS12 routines',0 ; DATA XREF: .data:0000009Co
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 418h
; COMDAT (pick any)
		public ??_C@_0BI@GMPKPCPG@random?5number?5generator?$AA@
; `string'
??_C@_0BI@GMPKPCPG@random?5number?5generator?$AA@ db 'random number generator',0
					; DATA XREF: .data:000000A4o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 430h
; COMDAT (pick any)
		public ??_C@_0BF@BDHLAIEM@DSO?5support?5routines?$AA@
; `string'
??_C@_0BF@BDHLAIEM@DSO?5support?5routines?$AA@ db 'DSO support routines',0
					; DATA XREF: .data:000000ACo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 448h
; COMDAT (pick any)
		public ??_C@_0BE@IMHDPIMO@time?5stamp?5routines?$AA@
; `string'
??_C@_0BE@IMHDPIMO@time?5stamp?5routines?$AA@ db 'time stamp routines',0
					; DATA XREF: .data:000000B4o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 45Ch
; COMDAT (pick any)
		public ??_C@_0BA@MMHCJFKD@engine?5routines?$AA@
; `string'
??_C@_0BA@MMHCJFKD@engine?5routines?$AA@ db 'engine routines',0 ; DATA XREF: .data:000000BCo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 46Ch
; COMDAT (pick any)
		public ??_C@_0O@LJIADBLP@OCSP?5routines?$AA@
; `string'
??_C@_0O@LJIADBLP@OCSP?5routines?$AA@ db 'OCSP routines',0 ; DATA XREF: .data:000000C4o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 47Ch
; COMDAT (pick any)
		public ??_C@_0O@MDPFBMCI@FIPS?5routines?$AA@
; `string'
??_C@_0O@MDPFBMCI@FIPS?5routines?$AA@ db 'FIPS routines',0 ; DATA XREF: .data:000000CCo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48Ch
; COMDAT (pick any)
		public ??_C@_0N@MKJBFBO@CMS?5routines?$AA@
; `string'
??_C@_0N@MKJBFBO@CMS?5routines?$AA@ db 'CMS routines',0 ; DATA XREF: .data:000000D4o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 49Ch
; COMDAT (pick any)
		public ??_C@_0O@PBJMEGGG@HMAC?5routines?$AA@
; `string'
??_C@_0O@PBJMEGGG@HMAC?5routines?$AA@ db 'HMAC routines',0 ; DATA XREF: .data:000000DCo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4ACh
; COMDAT (pick any)
		public ??_C@_05FFKPLNPJ@fopen?$AA@
; `string'
??_C@_05FFKPLNPJ@fopen?$AA@ db 'fopen',0 ; DATA XREF: .data:000000ECo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4B4h
; COMDAT (pick any)
		public ??_C@_07KAIBNCHO@connect?$AA@
; `string'
??_C@_07KAIBNCHO@connect?$AA@ db 'connect',0 ; DATA XREF: .data:000000F4o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4BCh
; COMDAT (pick any)
		public ??_C@_0O@NKLJGHIL@getservbyname?$AA@
; `string'
??_C@_0O@NKLJGHIL@getservbyname?$AA@ db	'getservbyname',0 ; DATA XREF: .data:000000FCo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4CCh
; COMDAT (pick any)
		public ??_C@_06HBELJPBO@socket?$AA@
; `string'
??_C@_06HBELJPBO@socket?$AA@ db	'socket',0 ; DATA XREF: .data:00000104o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4D4h
; COMDAT (pick any)
		public ??_C@_0M@PBPOCKDG@ioctlsocket?$AA@
; `string'
??_C@_0M@PBPOCKDG@ioctlsocket?$AA@ db 'ioctlsocket',0 ; DATA XREF: .data:0000010Co
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4E0h
; COMDAT (pick any)
		public ??_C@_04NPNJNMMP@bind?$AA@
; `string'
??_C@_04NPNJNMMP@bind?$AA@ db 'bind',0  ; DATA XREF: .data:00000114o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4E8h
; COMDAT (pick any)
		public ??_C@_06OODDLKLE@listen?$AA@
; `string'
??_C@_06OODDLKLE@listen?$AA@ db	'listen',0 ; DATA XREF: .data:0000011Co
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4F0h
; COMDAT (pick any)
		public ??_C@_06MPKMECK@accept?$AA@
; `string'
??_C@_06MPKMECK@accept?$AA@ db 'accept',0 ; DATA XREF: .data:00000124o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4F8h
; COMDAT (pick any)
		public ??_C@_0L@LNCNEFCG@WSAstartup?$AA@
; `string'
??_C@_0L@LNCNEFCG@WSAstartup?$AA@ db 'WSAstartup',0 ; DATA XREF: .data:0000012Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 504h
; COMDAT (pick any)
		public ??_C@_07OPAOJOOA@opendir?$AA@
; `string'
??_C@_07OPAOJOOA@opendir?$AA@ db 'opendir',0 ; DATA XREF: .data:00000134o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50Ch
; COMDAT (pick any)
		public ??_C@_05FHPOAJDB@fread?$AA@
; `string'
??_C@_05FHPOAJDB@fread?$AA@ db 'fread',0 ; DATA XREF: .data:0000013Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 514h
; COMDAT (pick any)
		public ??_C@_0L@NFMIFFDK@system?5lib?$AA@
; `string'
??_C@_0L@NFMIFFDK@system?5lib?$AA@ db 'system lib',0 ; DATA XREF: .data:0000014Co
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 520h
; COMDAT (pick any)
		public ??_C@_06CEKJLBPI@BN?5lib?$AA@
; `string'
??_C@_06CEKJLBPI@BN?5lib?$AA@ db 'BN lib',0 ; DATA XREF: .data:00000154o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 528h
; COMDAT (pick any)
		public ??_C@_07PLBLGAPL@RSA?5lib?$AA@
; `string'
??_C@_07PLBLGAPL@RSA?5lib?$AA@ db 'RSA lib',0 ; DATA XREF: .data:0000015Co
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 530h
; COMDAT (pick any)
		public ??_C@_06JBCAGHNP@DH?5lib?$AA@
; `string'
??_C@_06JBCAGHNP@DH?5lib?$AA@ db 'DH lib',0 ; DATA XREF: .data:00000164o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 538h
; COMDAT (pick any)
		public ??_C@_07BHNHKGFA@EVP?5lib?$AA@
; `string'
??_C@_07BHNHKGFA@EVP?5lib?$AA@ db 'EVP lib',0 ; DATA XREF: .data:0000016Co
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 540h
; COMDAT (pick any)
		public ??_C@_07PJHFFEFC@BUF?5lib?$AA@
; `string'
??_C@_07PJHFFEFC@BUF?5lib?$AA@ db 'BUF lib',0 ; DATA XREF: .data:00000174o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 548h
; COMDAT (pick any)
		public ??_C@_07LHMLCDLI@OBJ?5lib?$AA@
; `string'
??_C@_07LHMLCDLI@OBJ?5lib?$AA@ db 'OBJ lib',0 ; DATA XREF: .data:0000017Co
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 550h
; COMDAT (pick any)
		public ??_C@_07MKPCAOAJ@PEM?5lib?$AA@
; `string'
??_C@_07MKPCAOAJ@PEM?5lib?$AA@ db 'PEM lib',0 ; DATA XREF: .data:00000184o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 558h
; COMDAT (pick any)
		public ??_C@_07EBMPFIFH@DSA?5lib?$AA@
; `string'
??_C@_07EBMPFIFH@DSA?5lib?$AA@ db 'DSA lib',0 ; DATA XREF: .data:0000018Co
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 560h
; COMDAT (pick any)
		public ??_C@_08DGLLDICE@X509?5lib?$AA@
; `string'
??_C@_08DGLLDICE@X509?5lib?$AA@	db 'X509 lib',0 ; DATA XREF: .data:00000194o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 56Ch
; COMDAT (pick any)
		public ??_C@_08HAFIEMCJ@ASN1?5lib?$AA@
; `string'
??_C@_08HAFIEMCJ@ASN1?5lib?$AA@	db 'ASN1 lib',0 ; DATA XREF: .data:0000019Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 578h
; COMDAT (pick any)
		public ??_C@_08GDJNHNLC@CONF?5lib?$AA@
; `string'
??_C@_08GDJNHNLC@CONF?5lib?$AA@	db 'CONF lib',0 ; DATA XREF: .data:000001A4o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 584h
; COMDAT (pick any)
		public ??_C@_0L@GEIMIIEL@CRYPTO?5lib?$AA@
; `string'
??_C@_0L@GEIMIIEL@CRYPTO?5lib?$AA@ db 'CRYPTO lib',0 ; DATA XREF: .data:000001ACo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 590h
; COMDAT (pick any)
		public ??_C@_06FNJAJMKI@EC?5lib?$AA@
; `string'
??_C@_06FNJAJMKI@EC?5lib?$AA@ db 'EC lib',0 ; DATA XREF: .data:000001B4o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 598h
; COMDAT (pick any)
		public ??_C@_07ILCPHDLL@SSL?5lib?$AA@
; `string'
??_C@_07ILCPHDLL@SSL?5lib?$AA@ db 'SSL lib',0 ; DATA XREF: .data:000001BCo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5A0h
; COMDAT (pick any)
		public ??_C@_07HOAEPDCA@BIO?5lib?$AA@
; `string'
??_C@_07HOAEPDCA@BIO?5lib?$AA@ db 'BIO lib',0 ; DATA XREF: .data:000001C4o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5A8h
; COMDAT (pick any)
		public ??_C@_09PFAKBDBP@PKCS7?5lib?$AA@
; `string'
??_C@_09PFAKBDBP@PKCS7?5lib?$AA@ db 'PKCS7 lib',0 ; DATA XREF: .data:000001CCo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5B4h
; COMDAT (pick any)
		public ??_C@_0L@OHLIEDB@X509V3?5lib?$AA@
; `string'
??_C@_0L@OHLIEDB@X509V3?5lib?$AA@ db 'X509V3 lib',0 ; DATA XREF: .data:000001D4o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5C0h
; COMDAT (pick any)
		public ??_C@_0L@FBHADCPC@PKCS12?5lib?$AA@
; `string'
??_C@_0L@FBHADCPC@PKCS12?5lib?$AA@ db 'PKCS12 lib',0 ; DATA XREF: .data:000001DCo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5CCh
; COMDAT (pick any)
		public ??_C@_08IAGEJILJ@RAND?5lib?$AA@
; `string'
??_C@_08IAGEJILJ@RAND?5lib?$AA@	db 'RAND lib',0 ; DATA XREF: .data:000001E4o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5D8h
; COMDAT (pick any)
		public ??_C@_07HLMFDJCH@DSO?5lib?$AA@
; `string'
??_C@_07HLMFDJCH@DSO?5lib?$AA@ db 'DSO lib',0 ; DATA XREF: .data:000001ECo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5E0h
; COMDAT (pick any)
		public ??_C@_0L@NEGIHAGL@ENGINE?5lib?$AA@
; `string'
??_C@_0L@NEGIHAGL@ENGINE?5lib?$AA@ db 'ENGINE lib',0 ; DATA XREF: .data:000001F4o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5ECh
; COMDAT (pick any)
		public ??_C@_08BIAIHGB@OCSP?5lib?$AA@
; `string'
??_C@_08BIAIHGB@OCSP?5lib?$AA@ db 'OCSP lib',0 ; DATA XREF: .data:000001FCo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5F8h
; COMDAT (pick any)
		public ??_C@_06JPOPAJEJ@TS?5lib?$AA@
; `string'
??_C@_06JPOPAJEJ@TS?5lib?$AA@ db 'TS lib',0 ; DATA XREF: .data:00000204o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 600h
; COMDAT (pick any)
		public ??_C@_0BC@JPACPGKL@nested?5asn1?5error?$AA@
; `string'
??_C@_0BC@JPACPGKL@nested?5asn1?5error?$AA@ db 'nested asn1 error',0
					; DATA XREF: .data:0000020Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 614h
; COMDAT (pick any)
		public ??_C@_0BH@LJENPHMF@bad?5asn1?5object?5header?$AA@
; `string'
??_C@_0BH@LJENPHMF@bad?5asn1?5object?5header?$AA@ db 'bad asn1 object header',0
					; DATA XREF: .data:00000214o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 62Ch
; COMDAT (pick any)
		public ??_C@_0BJ@KHBMOGBI@bad?5get?5asn1?5object?5call?$AA@
; `string'
??_C@_0BJ@KHBMOGBI@bad?5get?5asn1?5object?5call?$AA@ db	'bad get asn1 object call',0
					; DATA XREF: .data:0000021Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 648h
; COMDAT (pick any)
		public ??_C@_0BL@PKJJDDDF@expecting?5an?5asn1?5sequence?$AA@
; `string'
??_C@_0BL@PKJJDDDF@expecting?5an?5asn1?5sequence?$AA@ db 'expecting an asn1 sequence',0
					; DATA XREF: .data:00000224o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 664h
; COMDAT (pick any)
		public ??_C@_0BF@JKEELALH@asn1?5length?5mismatch?$AA@
; `string'
??_C@_0BF@JKEELALH@asn1?5length?5mismatch?$AA@ db 'asn1 length mismatch',0
					; DATA XREF: .data:0000022Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 67Ch
; COMDAT (pick any)
		public ??_C@_0BB@LLCBNOLO@missing?5asn1?5eos?$AA@
; `string'
??_C@_0BB@LLCBNOLO@missing?5asn1?5eos?$AA@ db 'missing asn1 eos',0
					; DATA XREF: .data:00000234o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 690h
; COMDAT (pick any)
		public ??_C@_05FAMCFOJB@fatal?$AA@
; `string'
??_C@_05FAMCFOJB@fatal?$AA@ db 'fatal',0 ; DATA XREF: .data:0000023Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 698h
; COMDAT (pick any)
		public ??_C@_0P@BOLAOBGL@malloc?5failure?$AA@
; `string'
??_C@_0P@BOLAOBGL@malloc?5failure?$AA@ db 'malloc failure',0 ; DATA XREF: .data:00000244o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6A8h
; COMDAT (pick any)
		public ??_C@_0CG@JFIACAPA@called?5a?5function?5you?5should?5not@
; `string'
??_C@_0CG@JFIACAPA@called?5a?5function?5you?5should?5not@ db 'called a function you should not call',0
					; DATA XREF: .data:0000024Co
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6D0h
; COMDAT (pick any)
		public ??_C@_0BI@MMHLKOF@passed?5a?5null?5parameter?$AA@
; `string'
??_C@_0BI@MMHLKOF@passed?5a?5null?5parameter?$AA@ db 'passed a null parameter',0
					; DATA XREF: .data:00000254o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6E8h
; COMDAT (pick any)
		public ??_C@_0P@LPIEGNHB@internal?5error?$AA@
; `string'
??_C@_0P@LPIEGNHB@internal?5error?$AA@ db 'internal error',0 ; DATA XREF: .data:0000025Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6F8h
; COMDAT (pick any)
		public ??_C@_0DE@JBNNAKOP@called?5a?5function?5that?5was?5disab@
; `string'
??_C@_0DE@JBNNAKOP@called?5a?5function?5that?5was?5disab@ db 'called a function that was disabled at compile-time',0
					; DATA XREF: .data:00000264o
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 72Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_int_err_get	proc near		; DATA XREF: .rdata:_err_defaultso

arg_0		= dword	ptr  4

		push	esi
		push	168h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		xor	esi, esi
		call	_CRYPTO_lock
		mov	eax, ds:_int_error_hash
		add	esp, 10h
		test	eax, eax
		jnz	short loc_78D
		cmp	[esp+4+arg_0], esi
		jz	short loc_78F
		push	16Ah
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	offset ??_C@_0BE@CGMKPIME@int_err_get?5?$CIerr?4c?$CJ?$AA@ ; "int_err_get (err.c)"
		call	_CRYPTO_push_info_
		push	offset _err_string_data_LHASH_COMP
		push	offset _err_string_data_LHASH_HASH
		call	_lh_new
		add	esp, 14h
		mov	ds:_int_error_hash, eax
		call	_CRYPTO_pop_info
		mov	eax, ds:_int_error_hash
		test	eax, eax
		jz	short loc_78F

loc_78D:				; CODE XREF: _int_err_get+20j
		mov	esi, eax

loc_78F:				; CODE XREF: _int_err_get+26j
					; _int_err_get+5Fj
		push	170h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h
		mov	eax, esi
		pop	esi
		retn
_int_err_get	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7ACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_int_err_del	proc near		; DATA XREF: .rdata:00000D30o
		push	177h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_int_error_hash
		add	esp, 10h
		test	eax, eax
		jz	short loc_7DE
		push	eax
		call	_lh_free
		add	esp, 4
		mov	ds:_int_error_hash, 0

loc_7DE:				; CODE XREF: _int_err_del+1Dj
		push	17Ch
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h
		retn
_int_err_del	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7F8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_int_err_get_item proc near		; DATA XREF: .rdata:00000D34o

arg_0		= dword	ptr  4

		mov	eax, ds:_err_fns
		test	eax, eax
		jnz	short loc_844
		push	127h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		mov	ecx, offset _err_defaults
		push	12Ah
		test	eax, eax
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		cmovnz	ecx, eax
		push	1
		push	0Ah
		mov	ds:_err_fns, ecx
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		add	esp, 20h

loc_844:				; CODE XREF: _int_err_get_item+7j
		mov	eax, [eax]
		push	esi
		push	0
		call	eax
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jnz	short loc_856
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_856:				; CODE XREF: _int_err_get_item+5Aj
		push	189h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	5
		call	_CRYPTO_lock
		push	[esp+14h+arg_0]
		push	esi
		call	_lh_retrieve
		push	18Bh
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	6
		mov	esi, eax
		call	_CRYPTO_lock
		add	esp, 28h
		mov	eax, esi
		pop	esi
		retn
_int_err_get_item endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 890h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_int_err_set_item proc near		; DATA XREF: .rdata:00000D38o

arg_0		= dword	ptr  4

		mov	eax, ds:_err_fns
		test	eax, eax
		jnz	short loc_8DC
		push	127h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		mov	ecx, offset _err_defaults
		push	12Ah
		test	eax, eax
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		cmovnz	ecx, eax
		push	1
		push	0Ah
		mov	ds:_err_fns, ecx
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		add	esp, 20h

loc_8DC:				; CODE XREF: _int_err_set_item+7j
		mov	eax, [eax]
		push	esi
		push	1
		call	eax
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jnz	short loc_8EE
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_8EE:				; CODE XREF: _int_err_set_item+5Aj
		push	19Ah
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		push	[esp+14h+arg_0]
		push	esi
		call	_lh_insert
		push	19Ch
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	0Ah
		mov	esi, eax
		call	_CRYPTO_lock
		add	esp, 28h
		mov	eax, esi
		pop	esi
		retn
_int_err_set_item endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 928h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_int_err_del_item proc near		; DATA XREF: .rdata:00000D3Co

arg_0		= dword	ptr  4

		mov	eax, ds:_err_fns
		test	eax, eax
		jnz	short loc_974
		push	127h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		mov	ecx, offset _err_defaults
		push	12Ah
		test	eax, eax
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		cmovnz	ecx, eax
		push	1
		push	0Ah
		mov	ds:_err_fns, ecx
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		add	esp, 20h

loc_974:				; CODE XREF: _int_err_del_item+7j
		mov	eax, [eax]
		push	esi
		push	0
		call	eax
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jnz	short loc_986
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_986:				; CODE XREF: _int_err_del_item+5Aj
		push	1ABh
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		push	[esp+14h+arg_0]
		push	esi
		call	_lh_delete
		push	1ADh
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	0Ah
		mov	esi, eax
		call	_CRYPTO_lock
		add	esp, 28h
		mov	eax, esi
		pop	esi
		retn
_int_err_del_item endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 9C0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_int_thread_get	proc near		; DATA XREF: .rdata:00000D40o

arg_0		= dword	ptr  4

		push	esi
		push	1C4h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		xor	esi, esi
		call	_CRYPTO_lock
		mov	eax, ds:_int_thread_hash
		add	esp, 10h
		test	eax, eax
		jnz	short loc_A21
		cmp	[esp+4+arg_0], esi
		jz	short loc_A29
		push	1C6h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	offset ??_C@_0BH@KBGLDIDO@int_thread_get?5?$CIerr?4c?$CJ?$AA@ ;	"int_thread_get	(err.c)"
		call	_CRYPTO_push_info_
		push	offset _err_state_LHASH_COMP
		push	offset _err_state_LHASH_HASH
		call	_lh_new
		add	esp, 14h
		mov	ds:_int_thread_hash, eax
		call	_CRYPTO_pop_info
		mov	eax, ds:_int_thread_hash
		test	eax, eax
		jz	short loc_A29

loc_A21:				; CODE XREF: _int_thread_get+20j
		inc	ds:_int_thread_hash_references
		mov	esi, eax

loc_A29:				; CODE XREF: _int_thread_get+26j
					; _int_thread_get+5Fj
		push	1CEh
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h
		mov	eax, esi
		pop	esi
		retn
_int_thread_get	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A44h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_int_thread_release proc near		; DATA XREF: .rdata:00000D44o

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	short loc_A77
		cmp	dword ptr [esi], 0
		jz	short loc_A77
		push	1D9h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	0FFFFFFFFh
		push	offset _int_thread_hash_references
		call	_CRYPTO_add_lock
		add	esp, 14h
		test	eax, eax
		jg	short loc_A77
		mov	dword ptr [esi], 0

loc_A77:				; CODE XREF: _int_thread_release+7j
					; _int_thread_release+Cj ...
		pop	esi
		retn
_int_thread_release endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A7Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_int_thread_get_item proc near		; DATA XREF: .rdata:00000D48o

var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 4
		call	__chkstk
		mov	eax, ds:_err_fns
		test	eax, eax
		jnz	short loc_AD2
		push	127h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		mov	ecx, offset _err_defaults
		push	12Ah
		test	eax, eax
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		cmovnz	ecx, eax
		push	1
		push	0Ah
		mov	ds:_err_fns, ecx
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		add	esp, 20h

loc_AD2:				; CODE XREF: _int_thread_get_item+11j
		mov	eax, [eax+14h]
		push	0
		call	eax
		add	esp, 4
		mov	[esp+4+var_4], eax
		test	eax, eax
		jnz	short loc_AE5
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_AE5:				; CODE XREF: _int_thread_get_item+65j
		push	esi
		push	1F3h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	5
		call	_CRYPTO_lock
		push	[esp+18h+arg_0]
		push	[esp+1Ch+var_4]
		call	_lh_retrieve
		push	1F5h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	6
		mov	esi, eax
		call	_CRYPTO_lock
		mov	ecx, ds:_err_fns
		lea	eax, [esp+30h+var_4]
		push	eax
		mov	eax, [ecx+18h]
		call	eax
		add	esp, 2Ch
		mov	eax, esi
		pop	esi
		pop	ecx
		retn
_int_thread_get_item endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B34h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_int_thread_set_item proc near		; DATA XREF: .rdata:00000D4Co

var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 4
		call	__chkstk
		mov	eax, ds:_err_fns
		test	eax, eax
		jnz	short loc_B8A
		push	127h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		mov	ecx, offset _err_defaults
		push	12Ah
		test	eax, eax
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		cmovnz	ecx, eax
		push	1
		push	0Ah
		mov	ds:_err_fns, ecx
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		add	esp, 20h

loc_B8A:				; CODE XREF: _int_thread_set_item+11j
		mov	eax, [eax+14h]
		push	1
		call	eax
		add	esp, 4
		mov	[esp+4+var_4], eax
		test	eax, eax
		jnz	short loc_B9D
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_B9D:				; CODE XREF: _int_thread_set_item+65j
		push	esi
		push	205h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		push	[esp+18h+arg_0]
		push	[esp+1Ch+var_4]
		call	_lh_insert
		push	207h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	0Ah
		mov	esi, eax
		call	_CRYPTO_lock
		mov	ecx, ds:_err_fns
		lea	eax, [esp+30h+var_4]
		push	eax
		mov	eax, [ecx+18h]
		call	eax
		add	esp, 2Ch
		mov	eax, esi
		pop	esi
		pop	ecx
		retn
_int_thread_set_item endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0BECh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_int_thread_del_item proc near		; DATA XREF: .rdata:00000D50o

var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 4
		call	__chkstk
		mov	eax, ds:_err_fns
		test	eax, eax
		jnz	short loc_C42
		push	127h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		mov	ecx, offset _err_defaults
		push	12Ah
		test	eax, eax
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		cmovnz	ecx, eax
		push	1
		push	0Ah
		mov	ds:_err_fns, ecx
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		add	esp, 20h

loc_C42:				; CODE XREF: _int_thread_del_item+11j
		mov	eax, [eax+14h]
		push	0
		call	eax
		add	esp, 4
		mov	[esp+4+var_4], eax
		test	eax, eax
		jz	loc_CE8
		push	esi
		push	217h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		push	[esp+18h+arg_0]
		push	[esp+1Ch+var_4]
		call	_lh_delete
		add	esp, 18h
		mov	esi, eax
		cmp	ds:_int_thread_hash_references,	1
		jnz	short loc_CB5
		mov	ecx, ds:_int_thread_hash
		test	ecx, ecx
		jz	short loc_CB5
		push	ecx
		call	_lh_num_items
		add	esp, 4
		test	eax, eax
		jnz	short loc_CB5
		push	ds:_int_thread_hash
		call	_lh_free
		add	esp, 4
		mov	ds:_int_thread_hash, 0

loc_CB5:				; CODE XREF: _int_thread_del_item+98j
					; _int_thread_del_item+A2j ...
		push	21Fh
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	0Ah
		call	_CRYPTO_lock
		lea	eax, [esp+18h+var_4]
		push	eax
		mov	eax, ds:_err_fns
		mov	eax, [eax+18h]
		call	eax
		add	esp, 14h
		test	esi, esi
		jz	short loc_CE7
		push	esi
		call	_ERR_STATE_free
		add	esp, 4

loc_CE7:				; CODE XREF: _int_thread_del_item+F0j
		pop	esi

loc_CE8:				; CODE XREF: _int_thread_del_item+65j
		pop	ecx
		retn
_int_thread_del_item endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0CECh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_int_err_get_next_lib proc near		; DATA XREF: .rdata:00000D54o
		push	esi
		push	22Ah
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		mov	ecx, _int_err_library_number
		mov	esi, ecx
		push	22Ch
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		inc	ecx
		push	1
		push	0Ah
		mov	_int_err_library_number, ecx
		call	_CRYPTO_lock
		add	esp, 20h
		mov	eax, esi
		pop	esi
		retn
_int_err_get_next_lib endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D2Ch
_err_defaults	dd offset _int_err_get	; DATA XREF: _int_err_get_item+21o
					; _int_err_set_item+21o ...
		dd offset _int_err_del
		dd offset _int_err_get_item
		dd offset _int_err_set_item
		dd offset _int_err_del_item
		dd offset _int_thread_get
		dd offset _int_thread_release
		dd offset _int_thread_get_item
		dd offset _int_thread_set_item
		dd offset _int_thread_del_item
		dd offset _int_err_get_next_lib
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_bss		segment	para public 'BSS' use32
		assume cs:_bss
		;org 0D58h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
_err_fns	dd ?			; DATA XREF: _int_err_get_itemr
					; _int_err_get_item+1Cr ...
_int_error_hash	dd ?			; DATA XREF: _int_err_get+16r
					; _int_err_get+4Ew ...
_int_thread_hash dd ?			; DATA XREF: _int_thread_get+16r
					; _int_thread_get+4Ew ...
_int_thread_hash_references dd ?	; DATA XREF: _int_thread_get:loc_A21w
					; _int_thread_release+1Co ...
_SYS_str_reasons dd ?			; DATA XREF: _ERR_load_ERR_strings+C5r
					; _ERR_load_ERR_strings+CCo
dword_D6C	dd 0A5h	dup(?)		; DATA XREF: _build_SYS_str_reasons+93o
dword_1000	dd 57h dup(?)		; DATA XREF: .data:_ERR_str_functso
dword_115C	dd 3 dup(?)		; DATA XREF: _build_SYS_str_reasons+CFo
; char `build_SYS_str_reasons'::`2'::strerror_tab[4064]
?strerror_tab@?1??build_SYS_str_reasons@@9@9 db	0FE0h dup(?)
					; DATA XREF: _build_SYS_str_reasons+8Eo
; `ERR_error_string'::`2'::buf
?buf@?1??ERR_error_string@@9@9 dd 40h dup(?) ; DATA XREF: _ERR_error_string+7o
; `ERR_get_state'::`2'::fallback
?fallback@?1??ERR_get_state@@9@9 dd 64h	dup(?) ; DATA XREF: _ERR_get_state+120o
_bss		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 23D8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ERR_STATE_free	proc near		; CODE XREF: _int_thread_del_item+F3p
					; _ERR_get_state+117p ...

arg_0		= dword	ptr  4

		push	ebx
		mov	ebx, [esp+4+arg_0]
		test	ebx, ebx
		jz	short loc_2423
		push	esi
		push	edi
		lea	esi, [ebx+88h]
		mov	edi, 10h

loc_23EE:				; CODE XREF: _ERR_STATE_free+3Ej
		mov	eax, [esi]
		test	eax, eax
		jz	short loc_2409
		test	byte ptr [esi+40h], 1
		jz	short loc_2409
		push	eax
		call	_CRYPTO_free
		add	esp, 4
		mov	dword ptr [esi], 0

loc_2409:				; CODE XREF: _ERR_STATE_free+1Aj
					; _ERR_STATE_free+20j
		mov	dword ptr [esi+40h], 0
		add	esi, 4
		sub	edi, 1
		jnz	short loc_23EE
		push	ebx
		call	_CRYPTO_free
		add	esp, 4
		pop	edi
		pop	esi

loc_2423:				; CODE XREF: _ERR_STATE_free+7j
		pop	ebx
		retn
_ERR_STATE_free	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2428h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_add_error_data
_ERR_add_error_data proc near

arg_0		= dword	ptr  4
arg_4		= byte ptr  8

		lea	eax, [esp+arg_4]
		push	eax
		push	[esp+4+arg_0]
		call	_ERR_add_error_vdata
		add	esp, 8
		retn
_ERR_add_error_data endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 243Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_add_error_vdata
_ERR_add_error_vdata proc near		; CODE XREF: _ERR_add_error_data+9p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 8
		call	__chkstk
		push	esi
		push	441h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	51h ; 'Q'
		mov	[esp+18h+var_8], 50h ; 'P'
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jz	loc_2547
		push	ebx
		xor	edx, edx
		mov	byte ptr [esi],	0
		push	ebp
		xor	ebx, ebx
		push	edi
		cmp	[esp+18h+arg_0], edx
		jle	short loc_24F2
		mov	ebp, [esp+18h+arg_4]
		add	ebp, 0FFFFFFFCh

loc_2484:				; CODE XREF: _ERR_add_error_vdata+B4j
		mov	edi, [ebp+4]
		lea	ebp, [ebp+4]
		test	edi, edi
		jz	short loc_24EB
		mov	eax, edi
		lea	ecx, [eax+1]
		mov	[esp+18h+var_4], ecx
		nop	dword ptr [eax+eax+00h]

loc_249C:				; CODE XREF: _ERR_add_error_vdata+65j
		mov	cl, [eax]
		inc	eax
		test	cl, cl
		jnz	short loc_249C
		sub	eax, [esp+18h+var_4]
		add	edx, eax
		mov	eax, [esp+18h+var_8]
		mov	[esp+18h+var_4], edx
		cmp	edx, eax
		jle	short loc_24DB
		lea	eax, [edx+14h]
		push	44Eh
		mov	[esp+1Ch+var_8], eax
		inc	eax
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	eax
		push	esi
		call	_CRYPTO_realloc
		add	esp, 10h
		test	eax, eax
		jz	short loc_254C
		mov	esi, eax
		mov	eax, [esp+18h+var_8]

loc_24DB:				; CODE XREF: _ERR_add_error_vdata+77j
		inc	eax
		push	eax
		push	edi
		push	esi
		call	_BUF_strlcat
		mov	edx, [esp+24h+var_4]
		add	esp, 0Ch

loc_24EB:				; CODE XREF: _ERR_add_error_vdata+50j
		inc	ebx
		cmp	ebx, [esp+18h+arg_0]
		jl	short loc_2484

loc_24F2:				; CODE XREF: _ERR_add_error_vdata+3Fj
		call	_ERR_get_state
		mov	ebx, eax
		mov	eax, 0Fh
		mov	edi, [ebx+188h]
		test	edi, edi
		cmovz	edi, eax
		mov	eax, [ebx+edi*4+88h]
		test	eax, eax
		jz	short loc_2532
		test	byte ptr [ebx+edi*4+0C8h], 1
		jz	short loc_2532
		push	eax
		call	_CRYPTO_free
		add	esp, 4
		mov	dword ptr [ebx+edi*4+88h], 0

loc_2532:				; CODE XREF: _ERR_add_error_vdata+D6j
					; _ERR_add_error_vdata+E0j
		mov	[ebx+edi*4+88h], esi
		mov	dword ptr [ebx+edi*4+0C8h], 3
		pop	edi
		pop	ebp
		pop	ebx

loc_2547:				; CODE XREF: _ERR_add_error_vdata+2Bj
		pop	esi
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_254C:				; CODE XREF: _ERR_add_error_vdata+97j
		push	esi
		call	_CRYPTO_free
		add	esp, 4
		pop	edi
		pop	ebp
		pop	ebx
		pop	esi
		add	esp, 8
		retn
_ERR_add_error_vdata endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2560h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_clear_error
_ERR_clear_error proc near
		push	ebx
		push	esi
		push	edi
		call	_ERR_get_state
		mov	ebx, eax
		mov	edi, 10h
		lea	esi, [ebx+88h]
		db	66h, 66h
		nop	word ptr [eax+eax+00000000h]

loc_2580:				; CODE XREF: _ERR_clear_error+6Aj
		mov	eax, [esi]
		mov	dword ptr [esi-80h], 0
		mov	dword ptr [esi-40h], 0
		test	eax, eax
		jz	short loc_25A9
		test	byte ptr [esi+40h], 1
		jz	short loc_25A9
		push	eax
		call	_CRYPTO_free
		add	esp, 4
		mov	dword ptr [esi], 0

loc_25A9:				; CODE XREF: _ERR_clear_error+32j
					; _ERR_clear_error+38j
		mov	dword ptr [esi+40h], 0
		mov	dword ptr [esi+80h], 0
		mov	dword ptr [esi+0C0h], 0FFFFFFFFh
		add	esi, 4
		sub	edi, 1
		jnz	short loc_2580
		mov	[ebx+18Ch], edi
		mov	[ebx+188h], edi
		pop	edi
		pop	esi
		pop	ebx
		retn
_ERR_clear_error endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 25DCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl ERR_error_string(int, char *Str)
		public _ERR_error_string
_ERR_error_string proc near

arg_0		= dword	ptr  4
Str		= dword	ptr  8

		mov	ecx, [esp+Str]
		test	ecx, ecx
		push	esi
		mov	esi, offset ?buf@?1??ERR_error_string@@9@9 ; `ERR_error_string'::`2'::buf
		cmovnz	esi, ecx
		push	100h		; int
		push	esi		; Str
		push	[esp+0Ch+arg_0]	; int
		call	_ERR_error_string_n
		add	esp, 0Ch
		mov	eax, esi
		pop	esi
		retn
_ERR_error_string endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2604h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl ERR_error_string_n(int, char *Str, int)
		public _ERR_error_string_n
_ERR_error_string_n proc near		; CODE XREF: _ERR_error_string+19p

var_D4		= dword	ptr -0D4h
var_D0		= dword	ptr -0D0h
var_CC		= dword	ptr -0CCh
var_C8		= dword	ptr -0C8h
var_C4		= byte ptr -0C4h
var_84		= byte ptr -84h
var_44		= byte ptr -44h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
Str		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 0D4h ; ''
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+0D4h+var_4], eax
		push	ebx
		mov	ebx, [esp+0D8h+arg_8]
		push	ebp
		push	esi
		mov	esi, [esp+0E0h+arg_0]
		mov	ebp, esi
		push	edi
		mov	edi, [esp+0E4h+Str]
		mov	eax, esi
		and	eax, 0FFFh
		shr	ebp, 0Ch
		push	esi
		and	ebp, 0FFFh
		mov	[esp+0E8h+var_C8], eax
		call	_ERR_lib_error_string
		push	esi
		mov	[esp+0ECh+var_D0], eax
		call	_ERR_func_error_string
		push	esi
		mov	[esp+0F0h+var_D4], eax
		call	_ERR_reason_error_string
		add	esp, 0Ch
		mov	[esp+0E4h+var_CC], eax
		cmp	[esp+0E4h+var_D0], 0
		jnz	short loc_2690
		mov	ecx, esi
		lea	eax, [esp+0E4h+var_44]
		shr	ecx, 18h
		push	ecx
		push	offset ??_C@_08PFHOCFHJ@lib?$CI?$CFlu?$CJ?$AA@ ; "lib(%lu)"
		push	40h ; '@'
		push	eax
		call	_BIO_snprintf
		add	esp, 10h

loc_2690:				; CODE XREF: _ERR_error_string_n+6Dj
		cmp	[esp+0E4h+var_D4], 0
		jnz	short loc_26AC
		push	ebp
		push	offset ??_C@_09IANFNLBB@func?$CI?$CFlu?$CJ?$AA@	; "func(%lu)"
		lea	eax, [esp+0ECh+var_84]
		push	40h ; '@'
		push	eax
		call	_BIO_snprintf
		add	esp, 10h

loc_26AC:				; CODE XREF: _ERR_error_string_n+91j
		mov	ebp, [esp+0E4h+var_CC]
		test	ebp, ebp
		jnz	short loc_26CC
		push	[esp+0E4h+var_C8]
		lea	eax, [esp+0E8h+var_C4]
		push	offset ??_C@_0M@MNMDFDLE@reason?$CI?$CFlu?$CJ?$AA@ ; "reason(%lu)"
		push	40h ; '@'
		push	eax
		call	_BIO_snprintf
		add	esp, 10h

loc_26CC:				; CODE XREF: _ERR_error_string_n+AEj
		mov	ecx, [esp+0E4h+var_D4]
		lea	eax, [esp+0E4h+var_C4]
		test	ebp, ebp
		cmovnz	eax, ebp
		test	ecx, ecx
		push	eax
		lea	eax, [esp+0E8h+var_84]
		cmovnz	eax, ecx
		mov	ecx, [esp+0E8h+var_D0]
		push	eax
		test	ecx, ecx
		lea	eax, [esp+0ECh+var_44]
		cmovnz	eax, ecx
		push	eax
		push	esi
		push	offset ??_C@_0BF@IKLBHEFA@error?3?$CF08lX?3?$CFs?3?$CFs?3?$CFs?$AA@ ; "error:%08lX:%s:%s:%s"
		push	ebx
		push	edi
		call	_BIO_snprintf
		mov	ecx, edi
		add	esp, 1Ch
		lea	edx, [ecx+1]

loc_270A:				; CODE XREF: _ERR_error_string_n+10Bj
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_270A
		sub	ecx, edx
		lea	eax, [ebx-1]
		cmp	ecx, eax
		jnz	short loc_274F
		cmp	ebx, 4
		jbe	short loc_274F
		mov	ebp, dword ptr ds:__imp__strchr
		xor	esi, esi
		add	ebx, edi

loc_2729:				; CODE XREF: _ERR_error_string_n+149j
		push	3Ah ; ':'       ; Val
		push	edi		; Str
		call	ebp ; __imp__strchr
		add	esp, 8
		test	eax, eax
		jz	short loc_273E
		lea	ecx, [ebx-5]
		add	ecx, esi
		cmp	eax, ecx
		jbe	short loc_2746

loc_273E:				; CODE XREF: _ERR_error_string_n+12Fj
		lea	eax, [ebx-5]
		add	eax, esi
		mov	byte ptr [eax],	3Ah ; ':'

loc_2746:				; CODE XREF: _ERR_error_string_n+138j
		inc	esi
		lea	edi, [eax+1]
		cmp	esi, 4
		jl	short loc_2729

loc_274F:				; CODE XREF: _ERR_error_string_n+114j
					; _ERR_error_string_n+119j
		mov	ecx, [esp+0E4h+var_4]
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 0D4h
		retn
_ERR_error_string_n endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2768h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_free_strings
_ERR_free_strings proc near
		mov	eax, ds:_err_fns
		test	eax, eax
		jnz	short loc_27B4
		push	127h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		mov	ecx, offset _err_defaults
		push	12Ah
		test	eax, eax
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		cmovnz	ecx, eax
		push	1
		push	0Ah
		mov	ds:_err_fns, ecx
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		add	esp, 20h

loc_27B4:				; CODE XREF: _ERR_free_strings+7j
		mov	eax, [eax+4]
		jmp	eax
_ERR_free_strings endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 27BCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_func_error_string
_ERR_func_error_string proc near	; CODE XREF: _ERR_error_string_n+52p

var_8		= dword	ptr -8
arg_0		= dword	ptr  4

		mov	eax, 8
		call	__chkstk
		mov	edx, ds:_err_fns
		test	edx, edx
		jnz	short loc_2814
		push	127h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		mov	ecx, offset _err_defaults
		push	12Ah
		test	eax, eax
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		cmovnz	ecx, eax
		push	1
		push	0Ah
		mov	ds:_err_fns, ecx
		call	_CRYPTO_lock
		mov	edx, ds:_err_fns
		add	esp, 20h

loc_2814:				; CODE XREF: _ERR_func_error_string+12j
		mov	eax, [esp+8+arg_0]
		mov	ecx, eax
		shr	ecx, 0Ch
		and	eax, 0FF000000h
		and	ecx, 0FFFh
		shl	ecx, 0Ch
		or	ecx, eax
		lea	eax, [esp+8+var_8]
		mov	[esp+8+var_8], ecx
		push	eax
		mov	eax, [edx+8]
		call	eax
		add	esp, 4
		test	eax, eax
		jnz	short loc_2844
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_2844:				; CODE XREF: _ERR_func_error_string+82j
		mov	eax, [eax+4]
		add	esp, 8
		retn
_ERR_func_error_string endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 284Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_get_err_state_table
_ERR_get_err_state_table proc near
		mov	eax, ds:_err_fns
		test	eax, eax
		jnz	short loc_2898
		push	127h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		mov	ecx, offset _err_defaults
		push	12Ah
		test	eax, eax
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		cmovnz	ecx, eax
		push	1
		push	0Ah
		mov	ds:_err_fns, ecx
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		add	esp, 20h

loc_2898:				; CODE XREF: _ERR_get_err_state_table+7j
		mov	eax, [eax+14h]
		push	0
		call	eax
		add	esp, 4
		retn
_ERR_get_err_state_table endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 28A4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_get_error
_ERR_get_error	proc near
		push	esi
		push	edi
		call	_ERR_get_state
		mov	esi, eax
		mov	edi, [esi+18Ch]
		cmp	edi, [esi+188h]
		jnz	short loc_28C0
		pop	edi
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_28C0:				; CODE XREF: _ERR_get_error+15j
		inc	edi
		push	ebx
		and	edi, 8000000Fh
		jns	short loc_28CF
		dec	edi
		or	edi, 0FFFFFFF0h
		inc	edi

loc_28CF:				; CODE XREF: _ERR_get_error+24j
		mov	ebx, [esi+edi*4+48h]
		mov	[esi+18Ch], edi
		mov	ecx, [esi+edi*4+88h]
		mov	dword ptr [esi+edi*4+48h], 0
		test	ecx, ecx
		jz	short loc_290A
		test	byte ptr [esi+edi*4+0C8h], 1
		jz	short loc_290A
		push	ecx
		call	_CRYPTO_free
		add	esp, 4
		mov	dword ptr [esi+edi*4+88h], 0

loc_290A:				; CODE XREF: _ERR_get_error+46j
					; _ERR_get_error+50j
		mov	eax, ebx
		mov	dword ptr [esi+edi*4+0C8h], 0
		pop	ebx
		pop	edi
		pop	esi
		retn
_ERR_get_error	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 291Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_get_error_line
_ERR_get_error_line proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		push	edi
		call	_ERR_get_state
		mov	esi, eax
		mov	edi, [esi+18Ch]
		cmp	edi, [esi+188h]
		jnz	short loc_2938
		pop	edi
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_2938:				; CODE XREF: _ERR_get_error_line+15j
		inc	edi
		push	ebx
		and	edi, 8000000Fh
		jns	short loc_2947
		dec	edi
		or	edi, 0FFFFFFF0h
		inc	edi

loc_2947:				; CODE XREF: _ERR_get_error_line+24j
		mov	ebx, [esi+edi*4+48h]
		mov	eax, [esp+0Ch+arg_0]
		mov	[esi+18Ch], edi
		mov	dword ptr [esi+edi*4+48h], 0
		test	eax, eax
		jz	short loc_2989
		mov	ecx, [esp+0Ch+arg_4]
		test	ecx, ecx
		jz	short loc_2989
		mov	edx, [esi+edi*4+108h]
		test	edx, edx
		jnz	short loc_297E
		mov	dword ptr [eax], offset	??_C@_02JDNIPIGD@NA?$AA@ ; `string'
		mov	[ecx], edx
		jmp	short loc_2989
; ---------------------------------------------------------------------------

loc_297E:				; CODE XREF: _ERR_get_error_line+56j
		mov	[eax], edx
		mov	eax, [esi+edi*4+148h]
		mov	[ecx], eax

loc_2989:				; CODE XREF: _ERR_get_error_line+43j
					; _ERR_get_error_line+4Bj ...
		mov	ecx, [esi+edi*4+88h]
		test	ecx, ecx
		jz	short loc_29B2
		test	byte ptr [esi+edi*4+0C8h], 1
		jz	short loc_29B2
		push	ecx
		call	_CRYPTO_free
		add	esp, 4
		mov	dword ptr [esi+edi*4+88h], 0

loc_29B2:				; CODE XREF: _ERR_get_error_line+76j
					; _ERR_get_error_line+80j
		mov	eax, ebx
		mov	dword ptr [esi+edi*4+0C8h], 0
		pop	ebx
		pop	edi
		pop	esi
		retn
_ERR_get_error_line endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 29C4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_get_error_line_data
_ERR_get_error_line_data proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	esi
		push	edi
		call	_ERR_get_state
		mov	esi, eax
		mov	edi, [esi+18Ch]
		cmp	edi, [esi+188h]
		jnz	short loc_29E0
		pop	edi
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_29E0:				; CODE XREF: _ERR_get_error_line_data+15j
		inc	edi
		push	ebx
		and	edi, 8000000Fh
		jns	short loc_29EF
		dec	edi
		or	edi, 0FFFFFFF0h
		inc	edi

loc_29EF:				; CODE XREF: _ERR_get_error_line_data+24j
		mov	ebx, [esi+edi*4+48h]
		mov	eax, [esp+0Ch+arg_0]
		mov	[esi+18Ch], edi
		mov	dword ptr [esi+edi*4+48h], 0
		test	eax, eax
		jz	short loc_2A31
		mov	ecx, [esp+0Ch+arg_4]
		test	ecx, ecx
		jz	short loc_2A31
		mov	edx, [esi+edi*4+108h]
		test	edx, edx
		jnz	short loc_2A26
		mov	dword ptr [eax], offset	??_C@_02JDNIPIGD@NA?$AA@ ; `string'
		mov	[ecx], edx
		jmp	short loc_2A31
; ---------------------------------------------------------------------------

loc_2A26:				; CODE XREF: _ERR_get_error_line_data+56j
		mov	[eax], edx
		mov	eax, [esi+edi*4+148h]
		mov	[ecx], eax

loc_2A31:				; CODE XREF: _ERR_get_error_line_data+43j
					; _ERR_get_error_line_data+4Bj	...
		mov	eax, [esp+0Ch+arg_8]
		test	eax, eax
		jnz	short loc_2A73
		mov	eax, [esi+edi*4+88h]
		test	eax, eax
		jz	short loc_2A62
		test	byte ptr [esi+edi*4+0C8h], 1
		jz	short loc_2A62
		push	eax
		call	_CRYPTO_free
		add	esp, 4
		mov	dword ptr [esi+edi*4+88h], 0

loc_2A62:				; CODE XREF: _ERR_get_error_line_data+7Ej
					; _ERR_get_error_line_data+88j
		mov	eax, ebx
		mov	dword ptr [esi+edi*4+0C8h], 0
		pop	ebx
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_2A73:				; CODE XREF: _ERR_get_error_line_data+73j
		mov	ecx, [esi+edi*4+88h]
		test	ecx, ecx
		jnz	short loc_2A94
		mov	dword ptr [eax], offset	??_C@_00CNPNBAHC@?$AA@ ; `string'
		mov	eax, [esp+0Ch+arg_C]
		test	eax, eax
		jz	short loc_2AA7
		mov	[eax], ecx
		mov	eax, ebx
		pop	ebx
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_2A94:				; CODE XREF: _ERR_get_error_line_data+B8j
		mov	edx, [esp+0Ch+arg_C]
		mov	[eax], ecx
		test	edx, edx
		jz	short loc_2AA7
		mov	ecx, [esi+edi*4+0C8h]
		mov	[edx], ecx

loc_2AA7:				; CODE XREF: _ERR_get_error_line_data+C6j
					; _ERR_get_error_line_data+D8j
		mov	eax, ebx
		pop	ebx
		pop	edi
		pop	esi
		retn
_ERR_get_error_line_data endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2AB0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_get_implementation
_ERR_get_implementation	proc near
		mov	eax, ds:_err_fns
		test	eax, eax
		jnz	short locret_2AFC
		push	127h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		mov	ecx, offset _err_defaults
		push	12Ah
		test	eax, eax
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		cmovnz	ecx, eax
		push	1
		push	0Ah
		mov	ds:_err_fns, ecx
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		add	esp, 20h

locret_2AFC:				; CODE XREF: _ERR_get_implementation+7j
		retn
_ERR_get_implementation	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2B00h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_get_next_error_library
_ERR_get_next_error_library proc near
		mov	eax, ds:_err_fns
		test	eax, eax
		jnz	short loc_2B4C
		push	127h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		mov	ecx, offset _err_defaults
		push	12Ah
		test	eax, eax
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		cmovnz	ecx, eax
		push	1
		push	0Ah
		mov	ds:_err_fns, ecx
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		add	esp, 20h

loc_2B4C:				; CODE XREF: _ERR_get_next_error_library+7j
		mov	eax, [eax+28h]
		jmp	eax
_ERR_get_next_error_library endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2B54h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_get_state
_ERR_get_state	proc near		; CODE XREF: _ERR_add_error_vdata:loc_24F2p
					; _ERR_clear_error+3p ...

var_19C		= byte ptr -19Ch
var_194		= byte ptr -194h
var_4		= dword	ptr -4

		mov	eax, 19Ch
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+19Ch+var_4], eax
		cmp	ds:_err_fns, 0
		jnz	short loc_2BB3
		push	127h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		mov	ecx, offset _err_defaults
		push	12Ah
		test	eax, eax
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		cmovnz	ecx, eax
		push	1
		push	0Ah
		mov	ds:_err_fns, ecx
		call	_CRYPTO_lock
		add	esp, 20h

loc_2BB3:				; CODE XREF: _ERR_get_state+1Fj
		push	esi
		lea	eax, [esp+1A0h+var_19C]
		push	edi
		push	eax
		call	_CRYPTO_THREADID_current
		lea	eax, [esp+1A8h+var_19C]
		push	eax
		lea	eax, [esp+1ACh+var_194]
		push	eax
		call	_CRYPTO_THREADID_cpy
		lea	eax, [esp+1B0h+var_194]
		push	eax
		mov	eax, ds:_err_fns
		mov	eax, [eax+1Ch]
		call	eax
		mov	esi, eax
		add	esp, 10h
		test	esi, esi
		jnz	loc_2C9C
		push	403h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	190h
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jz	short loc_2C73
		lea	eax, [esp+1A4h+var_19C]
		push	eax
		push	esi
		call	_CRYPTO_THREADID_cpy
		add	esp, 8
		mov	dword ptr [esi+188h], 0
		mov	dword ptr [esi+18Ch], 0
		lea	eax, [esi+0C8h]
		mov	ecx, 10h

loc_2C34:				; CODE XREF: _ERR_get_state+F4j
		mov	dword ptr [eax-40h], 0
		lea	eax, [eax+4]
		mov	dword ptr [eax-4], 0
		sub	ecx, 1
		jnz	short loc_2C34
		mov	eax, ds:_err_fns
		push	esi
		mov	eax, [eax+20h]
		call	eax
		mov	ecx, ds:_err_fns
		mov	edi, eax
		push	esi
		mov	ecx, [ecx+1Ch]
		call	ecx
		add	esp, 8
		cmp	eax, esi
		jz	short loc_2C8F
		push	esi
		call	_ERR_STATE_free
		add	esp, 4

loc_2C73:				; CODE XREF: _ERR_get_state+B1j
		pop	edi
		mov	eax, offset ?fallback@?1??ERR_get_state@@9@9 ; `ERR_get_state'::`2'::fallback
		pop	esi
		mov	ecx, [esp+19Ch+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 19Ch
		retn
; ---------------------------------------------------------------------------

loc_2C8F:				; CODE XREF: _ERR_get_state+114j
		test	edi, edi
		jz	short loc_2C9C
		push	edi
		call	_ERR_STATE_free
		add	esp, 4

loc_2C9C:				; CODE XREF: _ERR_get_state+90j
					; _ERR_get_state+13Dj
		mov	ecx, [esp+1A4h+var_4]
		mov	eax, esi
		pop	edi
		pop	esi
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 19Ch
		retn
_ERR_get_state	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2CB8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_get_string_table
_ERR_get_string_table proc near
		mov	eax, ds:_err_fns
		test	eax, eax
		jnz	short loc_2D04
		push	127h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		mov	ecx, offset _err_defaults
		push	12Ah
		test	eax, eax
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		cmovnz	ecx, eax
		push	1
		push	0Ah
		mov	ds:_err_fns, ecx
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		add	esp, 20h

loc_2D04:				; CODE XREF: _ERR_get_string_table+7j
		mov	eax, [eax]
		push	0
		call	eax
		add	esp, 4
		retn
_ERR_get_string_table endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2D10h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_lib_error_string
_ERR_lib_error_string proc near		; CODE XREF: _ERR_error_string_n+48p

var_8		= dword	ptr -8
arg_0		= dword	ptr  4

		mov	eax, 8
		call	__chkstk
		mov	ecx, ds:_err_fns
		test	ecx, ecx
		jnz	short loc_2D68
		push	127h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		mov	ecx, offset _err_defaults
		push	12Ah
		test	eax, eax
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		cmovnz	ecx, eax
		push	1
		push	0Ah
		mov	ds:_err_fns, ecx
		call	_CRYPTO_lock
		mov	ecx, ds:_err_fns
		add	esp, 20h

loc_2D68:				; CODE XREF: _ERR_lib_error_string+12j
		mov	eax, [esp+8+arg_0]
		and	eax, 0FF000000h
		mov	[esp+8+var_8], eax
		lea	eax, [esp+8+var_8]
		push	eax
		mov	eax, [ecx+8]
		call	eax
		add	esp, 4
		test	eax, eax
		jnz	short loc_2D88
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_2D88:				; CODE XREF: _ERR_lib_error_string+72j
		mov	eax, [eax+4]
		add	esp, 8
		retn
_ERR_lib_error_string endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2D90h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_load_ERR_strings
_ERR_load_ERR_strings proc near		; CODE XREF: _ERR_load_stringsp
		cmp	ds:_err_fns, 0
		jnz	short loc_2DD7
		push	127h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		mov	ecx, offset _err_defaults
		push	12Ah
		test	eax, eax
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		cmovnz	ecx, eax
		push	1
		push	0Ah
		mov	ds:_err_fns, ecx
		call	_CRYPTO_lock
		add	esp, 20h

loc_2DD7:				; CODE XREF: _ERR_load_ERR_strings+7j
		cmp	_ERR_str_libraries, 0
		push	esi
		mov	esi, offset _ERR_str_libraries
		jz	short loc_2DFC

loc_2DE6:				; CODE XREF: _ERR_load_ERR_strings+6Aj
		mov	eax, ds:_err_fns
		push	esi
		mov	eax, [eax+0Ch]
		call	eax
		add	esi, 8
		add	esp, 4
		cmp	dword ptr [esi], 0
		jnz	short loc_2DE6

loc_2DFC:				; CODE XREF: _ERR_load_ERR_strings+54j
		cmp	_ERR_str_reasons, 0
		mov	esi, offset _ERR_str_reasons
		jz	short loc_2E26
		nop	word ptr [eax+eax+00h]

loc_2E10:				; CODE XREF: _ERR_load_ERR_strings+94j
		mov	eax, ds:_err_fns
		push	esi
		mov	eax, [eax+0Ch]
		call	eax
		add	esi, 8
		add	esp, 4
		cmp	dword ptr [esi], 0
		jnz	short loc_2E10

loc_2E26:				; CODE XREF: _ERR_load_ERR_strings+78j
		cmp	_ERR_str_functs, 0
		mov	esi, offset _ERR_str_functs
		jz	short loc_2E50

loc_2E34:				; CODE XREF: _ERR_load_ERR_strings+BEj
		mov	eax, ds:_err_fns
		or	dword ptr [esi], 2000000h
		push	esi
		mov	eax, [eax+0Ch]
		call	eax
		add	esi, 8
		add	esp, 4
		cmp	dword ptr [esi], 0
		jnz	short loc_2E34

loc_2E50:				; CODE XREF: _ERR_load_ERR_strings+A2j
		call	_build_SYS_str_reasons
		cmp	ds:_SYS_str_reasons, 0
		mov	esi, offset _SYS_str_reasons
		jz	short loc_2E7F

loc_2E63:				; CODE XREF: _ERR_load_ERR_strings+EDj
		mov	eax, ds:_err_fns
		or	dword ptr [esi], 2000000h
		push	esi
		mov	eax, [eax+0Ch]
		call	eax
		add	esi, 8
		add	esp, 4
		cmp	dword ptr [esi], 0
		jnz	short loc_2E63

loc_2E7F:				; CODE XREF: _ERR_load_ERR_strings+D1j
		pop	esi
		retn
_ERR_load_ERR_strings endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E84h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_load_strings
_ERR_load_strings proc near
		call	_ERR_load_ERR_strings
		jmp	_err_load_strings
_ERR_load_strings endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E90h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_peek_error
_ERR_peek_error	proc near
		call	_ERR_get_state
		mov	ecx, eax
		mov	eax, [ecx+18Ch]
		cmp	eax, [ecx+188h]
		jnz	short loc_2EA8
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_2EA8:				; CODE XREF: _ERR_peek_error+13j
		inc	eax
		and	eax, 8000000Fh
		jns	short loc_2EB5
		dec	eax
		or	eax, 0FFFFFFF0h
		inc	eax

loc_2EB5:				; CODE XREF: _ERR_peek_error+1Ej
		mov	eax, [ecx+eax*4+48h]
		retn
_ERR_peek_error	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2EBCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_peek_error_line
_ERR_peek_error_line proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		call	_ERR_get_state
		mov	ecx, [eax+18Ch]
		cmp	ecx, [eax+188h]
		jnz	short loc_2ED2
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_2ED2:				; CODE XREF: _ERR_peek_error_line+11j
		inc	ecx
		push	ebx
		push	esi
		and	ecx, 8000000Fh
		jns	short loc_2EE2
		dec	ecx
		or	ecx, 0FFFFFFF0h
		inc	ecx

loc_2EE2:				; CODE XREF: _ERR_peek_error_line+1Fj
		mov	esi, [esp+8+arg_0]
		mov	ebx, [eax+ecx*4+48h]
		test	esi, esi
		jz	short loc_2F1C
		mov	edx, [esp+8+arg_4]
		test	edx, edx
		jz	short loc_2F1C
		push	edi
		mov	edi, [eax+ecx*4+108h]
		test	edi, edi
		jnz	short loc_2F10
		mov	dword ptr [esi], offset	??_C@_02JDNIPIGD@NA?$AA@ ; `string'
		mov	eax, ebx
		mov	[edx], edi
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_2F10:				; CODE XREF: _ERR_peek_error_line+44j
		mov	[esi], edi
		mov	ecx, [eax+ecx*4+148h]
		mov	[edx], ecx
		pop	edi

loc_2F1C:				; CODE XREF: _ERR_peek_error_line+30j
					; _ERR_peek_error_line+38j
		pop	esi
		mov	eax, ebx
		pop	ebx
		retn
_ERR_peek_error_line endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2F24h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_peek_error_line_data
_ERR_peek_error_line_data proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		call	_ERR_get_state
		mov	ecx, eax
		mov	edx, [ecx+18Ch]
		cmp	edx, [ecx+188h]
		jnz	short loc_2F3C
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_2F3C:				; CODE XREF: _ERR_peek_error_line_data+13j
		inc	edx
		push	ebx
		push	esi
		and	edx, 8000000Fh
		jns	short loc_2F4C
		dec	edx
		or	edx, 0FFFFFFF0h
		inc	edx

loc_2F4C:				; CODE XREF: _ERR_peek_error_line_data+21j
		mov	eax, [esp+8+arg_0]
		mov	ebx, [ecx+edx*4+48h]
		test	eax, eax
		jz	short loc_2F82
		mov	esi, [esp+8+arg_4]
		test	esi, esi
		jz	short loc_2F82
		push	edi
		mov	edi, [ecx+edx*4+108h]
		test	edi, edi
		jnz	short loc_2F76
		mov	dword ptr [eax], offset	??_C@_02JDNIPIGD@NA?$AA@ ; `string'
		mov	[esi], edi
		jmp	short loc_2F81
; ---------------------------------------------------------------------------

loc_2F76:				; CODE XREF: _ERR_peek_error_line_data+46j
		mov	[eax], edi
		mov	eax, [ecx+edx*4+148h]
		mov	[esi], eax

loc_2F81:				; CODE XREF: _ERR_peek_error_line_data+50j
		pop	edi

loc_2F82:				; CODE XREF: _ERR_peek_error_line_data+32j
					; _ERR_peek_error_line_data+3Aj
		mov	eax, [esp+8+arg_8]
		test	eax, eax
		jz	short loc_2FBD
		mov	esi, [ecx+edx*4+88h]
		test	esi, esi
		jnz	short loc_2FAA
		mov	dword ptr [eax], offset	??_C@_00CNPNBAHC@?$AA@ ; `string'
		mov	eax, [esp+8+arg_C]
		test	eax, eax
		jz	short loc_2FBD
		mov	[eax], esi
		mov	eax, ebx
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_2FAA:				; CODE XREF: _ERR_peek_error_line_data+6Fj
		mov	[eax], esi
		mov	esi, [esp+8+arg_C]
		test	esi, esi
		jz	short loc_2FBD
		mov	ecx, [ecx+edx*4+0C8h]
		mov	[esi], ecx

loc_2FBD:				; CODE XREF: _ERR_peek_error_line_data+64j
					; _ERR_peek_error_line_data+7Dj ...
		pop	esi
		mov	eax, ebx
		pop	ebx
		retn
_ERR_peek_error_line_data endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2FC4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_peek_last_error
_ERR_peek_last_error proc near
		call	_ERR_get_state
		mov	ecx, [eax+188h]
		cmp	[eax+18Ch], ecx
		jnz	short loc_2FDA
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_2FDA:				; CODE XREF: _ERR_peek_last_error+11j
		mov	eax, [eax+ecx*4+48h]
		retn
_ERR_peek_last_error endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2FE0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_peek_last_error_line
_ERR_peek_last_error_line proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		call	_ERR_get_state
		mov	ecx, [eax+188h]
		cmp	[eax+18Ch], ecx
		jnz	short loc_2FF6
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_2FF6:				; CODE XREF: _ERR_peek_last_error_line+11j
		push	ebx
		mov	ebx, [eax+ecx*4+48h]
		push	esi
		mov	esi, [esp+8+arg_0]

loc_3000:				; DATA XREF: .data:000000F8o
		test	esi, esi
		jz	short loc_3032
		mov	edx, [esp+8+arg_4]
		test	edx, edx
		jz	short loc_3032
		push	edi
		mov	edi, [eax+ecx*4+108h]
		test	edi, edi
		jnz	short loc_3026
		mov	dword ptr [esi], offset	??_C@_02JDNIPIGD@NA?$AA@ ; `string'
		mov	eax, ebx
		mov	[edx], edi
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_3026:				; CODE XREF: _ERR_peek_last_error_line+36j
		mov	[esi], edi
		mov	ecx, [eax+ecx*4+148h]
		mov	[edx], ecx
		pop	edi

loc_3032:				; CODE XREF: _ERR_peek_last_error_line+22j
					; _ERR_peek_last_error_line+2Aj
		pop	esi
		mov	eax, ebx
		pop	ebx
		retn
_ERR_peek_last_error_line endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3038h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_peek_last_error_line_data
_ERR_peek_last_error_line_data proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		call	_ERR_get_state
		mov	ecx, eax
		mov	edx, [ecx+188h]
		cmp	[ecx+18Ch], edx
		jnz	short loc_3050
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_3050:				; CODE XREF: _ERR_peek_last_error_line_data+13j
		mov	eax, [esp+arg_0]
		push	ebx
		mov	ebx, [ecx+edx*4+48h]
		push	esi
		test	eax, eax
		jz	short loc_3088
		mov	esi, [esp+8+arg_4]
		test	esi, esi
		jz	short loc_3088
		push	edi
		mov	edi, [ecx+edx*4+108h]
		test	edi, edi
		jnz	short loc_307C
		mov	dword ptr [eax], offset	??_C@_02JDNIPIGD@NA?$AA@ ; `string'
		mov	[esi], edi
		jmp	short loc_3087
; ---------------------------------------------------------------------------

loc_307C:				; CODE XREF: _ERR_peek_last_error_line_data+38j
		mov	[eax], edi
		mov	eax, [ecx+edx*4+148h]
		mov	[esi], eax

loc_3087:				; CODE XREF: _ERR_peek_last_error_line_data+42j
		pop	edi

loc_3088:				; CODE XREF: _ERR_peek_last_error_line_data+24j
					; _ERR_peek_last_error_line_data+2Cj
		mov	eax, [esp+8+arg_8]
		test	eax, eax
		jz	short loc_30C3
		mov	esi, [ecx+edx*4+88h]
		test	esi, esi
		jnz	short loc_30B0
		mov	dword ptr [eax], offset	??_C@_00CNPNBAHC@?$AA@ ; `string'
		mov	eax, [esp+8+arg_C]
		test	eax, eax
		jz	short loc_30C3
		mov	[eax], esi
		mov	eax, ebx
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_30B0:				; CODE XREF: _ERR_peek_last_error_line_data+61j
		mov	[eax], esi
		mov	esi, [esp+8+arg_C]
		test	esi, esi
		jz	short loc_30C3
		mov	ecx, [ecx+edx*4+0C8h]
		mov	[esi], ecx

loc_30C3:				; CODE XREF: _ERR_peek_last_error_line_data+56j
					; _ERR_peek_last_error_line_data+6Fj ...
		pop	esi
		mov	eax, ebx
		pop	ebx
		retn
_ERR_peek_last_error_line_data endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 30C8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_pop_to_mark
_ERR_pop_to_mark proc near
		push	esi
		call	_ERR_get_state
		mov	esi, eax
		mov	eax, [esi+188h]
		cmp	[esi+18Ch], eax
		jz	loc_319C
		nop	word ptr [eax+eax+00h]

loc_30E8:				; CODE XREF: _ERR_pop_to_mark+CEj
		test	byte ptr [esi+eax*4+8],	1
		jnz	loc_319C
		mov	dword ptr [esi+eax*4+8], 0
		mov	eax, [esi+188h]
		mov	dword ptr [esi+eax*4+48h], 0
		mov	eax, [esi+188h]
		mov	ecx, [esi+eax*4+88h]
		test	ecx, ecx
		jz	short loc_313E
		test	byte ptr [esi+eax*4+0C8h], 1
		jz	short loc_313E
		push	ecx
		call	_CRYPTO_free
		mov	eax, [esi+188h]
		add	esp, 4
		mov	dword ptr [esi+eax*4+88h], 0

loc_313E:				; CODE XREF: _ERR_pop_to_mark+50j
					; _ERR_pop_to_mark+5Aj
		mov	eax, [esi+188h]
		mov	dword ptr [esi+eax*4+0C8h], 0
		mov	eax, [esi+188h]
		mov	dword ptr [esi+eax*4+108h], 0
		mov	eax, [esi+188h]
		mov	dword ptr [esi+eax*4+148h], 0FFFFFFFFh
		dec	dword ptr [esi+188h]
		cmp	dword ptr [esi+188h], 0FFFFFFFFh
		jnz	short loc_318A
		mov	dword ptr [esi+188h], 0Fh

loc_318A:				; CODE XREF: _ERR_pop_to_mark+B6j
		mov	eax, [esi+188h]
		cmp	[esi+18Ch], eax
		jnz	loc_30E8

loc_319C:				; CODE XREF: _ERR_pop_to_mark+14j
					; _ERR_pop_to_mark+25j
		mov	eax, [esi+188h]
		cmp	[esi+18Ch], eax
		jnz	short loc_31AE
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_31AE:				; CODE XREF: _ERR_pop_to_mark+E0j
		and	dword ptr [esi+eax*4+8], 0FFFFFFFEh
		mov	eax, 1
		pop	esi
		retn
_ERR_pop_to_mark endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 31BCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_put_error
_ERR_put_error	proc near

arg_0		= byte ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		push	esi
		call	_ERR_get_state
		mov	esi, eax
		mov	ecx, [esi+188h]
		inc	ecx
		and	ecx, 8000000Fh
		jns	short loc_31D8
		dec	ecx
		or	ecx, 0FFFFFFF0h
		inc	ecx

loc_31D8:				; CODE XREF: _ERR_put_error+15j
		mov	eax, [esi+18Ch]
		mov	[esi+188h], ecx
		cmp	ecx, eax
		jnz	short loc_31FB
		inc	eax
		and	eax, 8000000Fh
		jns	short loc_31F5
		dec	eax
		or	eax, 0FFFFFFF0h
		inc	eax

loc_31F5:				; CODE XREF: _ERR_put_error+32j
		mov	[esi+18Ch], eax

loc_31FB:				; CODE XREF: _ERR_put_error+2Aj
		movzx	eax, [esp+4+arg_0]
		mov	dword ptr [esi+ecx*4+8], 0
		mov	ecx, [esp+4+arg_4]
		and	ecx, 0FFFh
		shl	eax, 18h
		shl	ecx, 0Ch
		or	ecx, eax
		mov	eax, [esp+4+arg_8]
		and	eax, 0FFFh
		or	ecx, eax
		mov	eax, [esi+188h]
		mov	[esi+eax*4+48h], ecx
		mov	ecx, [esi+188h]
		mov	eax, [esp+4+arg_C]
		mov	[esi+ecx*4+108h], eax
		mov	ecx, [esi+188h]
		mov	eax, [esp+4+arg_10]
		mov	[esi+ecx*4+148h], eax
		mov	eax, [esi+188h]
		mov	ecx, [esi+eax*4+88h]
		test	ecx, ecx
		jz	short loc_328C
		test	byte ptr [esi+eax*4+0C8h], 1
		jz	short loc_328C
		push	ecx
		call	_CRYPTO_free
		mov	eax, [esi+188h]
		add	esp, 4
		mov	dword ptr [esi+eax*4+88h], 0
		mov	eax, [esi+188h]

loc_328C:				; CODE XREF: _ERR_put_error+A4j
					; _ERR_put_error+AEj
		mov	dword ptr [esi+eax*4+0C8h], 0
		pop	esi
		retn
_ERR_put_error	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 329Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_reason_error_string
_ERR_reason_error_string proc near	; CODE XREF: _ERR_error_string_n+5Cp

var_8		= dword	ptr -8
arg_0		= dword	ptr  4

		mov	eax, 8
		call	__chkstk
		mov	ecx, ds:_err_fns
		test	ecx, ecx
		jnz	short loc_32F4
		push	127h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		mov	ecx, offset _err_defaults
		push	12Ah
		test	eax, eax
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		cmovnz	ecx, eax
		push	1
		push	0Ah
		mov	ds:_err_fns, ecx
		call	_CRYPTO_lock
		mov	ecx, ds:_err_fns
		add	esp, 20h

loc_32F4:				; CODE XREF: _ERR_reason_error_string+12j
		mov	eax, [esp+8+arg_0]
		push	esi
		mov	esi, eax
		and	eax, 0FF000000h
		and	esi, 0FFFh
		or	eax, esi
		mov	[esp+0Ch+var_8], eax
		lea	eax, [esp+0Ch+var_8]
		push	eax
		mov	eax, [ecx+8]
		call	eax
		add	esp, 4
		test	eax, eax
		jnz	short loc_333C
		lea	eax, [esp+0Ch+var_8]
		mov	[esp+0Ch+var_8], esi
		push	eax
		mov	eax, ds:_err_fns
		mov	eax, [eax+8]
		call	eax
		add	esp, 4
		test	eax, eax
		jnz	short loc_333C
		pop	esi
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_333C:				; CODE XREF: _ERR_reason_error_string+7Fj
					; _ERR_reason_error_string+99j
		mov	eax, [eax+4]
		pop	esi
		add	esp, 8
		retn
_ERR_reason_error_string endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3344h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_release_err_state_table
_ERR_release_err_state_table proc near
		mov	eax, ds:_err_fns
		test	eax, eax
		jnz	short loc_3390
		push	127h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		mov	ecx, offset _err_defaults
		push	12Ah
		test	eax, eax
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		cmovnz	ecx, eax
		push	1
		push	0Ah
		mov	ds:_err_fns, ecx
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		add	esp, 20h

loc_3390:				; CODE XREF: _ERR_release_err_state_table+7j
		mov	eax, [eax+18h]
		jmp	eax
_ERR_release_err_state_table endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3398h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_remove_state
_ERR_remove_state proc near

arg_0		= dword	ptr  4

		mov	[esp+arg_0], 0
		jmp	_ERR_remove_thread_state
_ERR_remove_state endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 33A8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_remove_thread_state
_ERR_remove_thread_state proc near	; CODE XREF: _ERR_remove_state+8j

var_194		= byte ptr -194h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 194h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+194h+var_4], eax
		mov	eax, [esp+194h+arg_0]
		test	eax, eax
		jz	short loc_33DB
		push	eax
		lea	eax, [esp+198h+var_194]
		push	eax
		call	_CRYPTO_THREADID_cpy
		add	esp, 8
		jmp	short loc_33E7
; ---------------------------------------------------------------------------

loc_33DB:				; CODE XREF: _ERR_remove_thread_state+21j
		lea	eax, [esp+194h+var_194]
		push	eax
		call	_CRYPTO_THREADID_current
		add	esp, 4

loc_33E7:				; CODE XREF: _ERR_remove_thread_state+31j
		mov	eax, ds:_err_fns
		test	eax, eax
		jnz	short loc_3433
		push	127h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		mov	ecx, offset _err_defaults
		push	12Ah
		test	eax, eax
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		cmovnz	ecx, eax
		push	1
		push	0Ah
		mov	ds:_err_fns, ecx
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		add	esp, 20h

loc_3433:				; CODE XREF: _ERR_remove_thread_state+46j
		mov	eax, [eax+24h]
		lea	ecx, [esp+194h+var_194]
		push	ecx
		call	eax
		mov	ecx, [esp+198h+var_4]
		add	esp, 4
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 194h
		retn
_ERR_remove_thread_state endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3454h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_set_error_data
_ERR_set_error_data proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		push	edi
		call	_ERR_get_state
		mov	edi, eax
		mov	eax, 0Fh
		mov	esi, [edi+188h]
		test	esi, esi
		cmovz	esi, eax
		mov	eax, [edi+esi*4+88h]
		test	eax, eax
		jz	short loc_3496
		test	byte ptr [edi+esi*4+0C8h], 1
		jz	short loc_3496
		push	eax
		call	_CRYPTO_free
		add	esp, 4
		mov	dword ptr [edi+esi*4+88h], 0

loc_3496:				; CODE XREF: _ERR_set_error_data+22j
					; _ERR_set_error_data+2Cj
		mov	eax, [esp+8+arg_0]
		mov	[edi+esi*4+88h], eax
		mov	eax, [esp+8+arg_4]
		mov	[edi+esi*4+0C8h], eax
		pop	edi
		pop	esi
		retn
_ERR_set_error_data endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 34B0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_set_implementation
_ERR_set_implementation	proc near

arg_0		= dword	ptr  4

		push	esi
		push	139h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		xor	esi, esi
		call	_CRYPTO_lock
		add	esp, 10h
		cmp	ds:_err_fns, esi
		jnz	short loc_34DF
		mov	eax, [esp+4+arg_0]
		mov	esi, 1
		mov	ds:_err_fns, eax

loc_34DF:				; CODE XREF: _ERR_set_implementation+1Fj
		push	142h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h
		mov	eax, esi
		pop	esi
		retn
_ERR_set_implementation	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 34FCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_set_mark
_ERR_set_mark	proc near
		call	_ERR_get_state
		mov	ecx, [eax+188h]
		cmp	[eax+18Ch], ecx
		jnz	short loc_3512
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_3512:				; CODE XREF: _ERR_set_mark+11j
		or	dword ptr [eax+ecx*4+8], 1
		mov	eax, 1
		retn
_ERR_set_mark	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3520h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ERR_unload_strings
_ERR_unload_strings proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_4]
		cmp	dword ptr [esi], 0
		jz	short loc_3553
		push	ebx
		mov	ebx, [esp+8+arg_0]
		nop

loc_3530:				; CODE XREF: _ERR_unload_strings+30j
		test	ebx, ebx
		jz	short loc_353C
		movzx	eax, bl
		shl	eax, 18h
		or	[esi], eax

loc_353C:				; CODE XREF: _ERR_unload_strings+12j
		mov	eax, ds:_err_fns
		push	esi
		mov	eax, [eax+10h]
		call	eax
		add	esi, 8
		add	esp, 4
		cmp	dword ptr [esi], 0
		jnz	short loc_3530
		pop	ebx

loc_3553:				; CODE XREF: _ERR_unload_strings+8j
		pop	esi
		retn
_ERR_unload_strings endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3558h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_build_SYS_str_reasons proc near	; CODE XREF: _ERR_load_ERR_strings:loc_2E50p
		push	247h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	5
		call	_CRYPTO_lock
		add	esp, 10h
		cmp	?init@?1??build_SYS_str_reasons@@9@9, 0	; `build_SYS_str_reasons'::`2'::init
		jnz	short loc_358E
		push	249h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	6
		call	_CRYPTO_lock
		add	esp, 10h
		retn
; ---------------------------------------------------------------------------

loc_358E:				; CODE XREF: _build_SYS_str_reasons+1Dj
		push	24Dh
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	6
		call	_CRYPTO_lock
		push	24Eh
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		add	esp, 20h
		cmp	?init@?1??build_SYS_str_reasons@@9@9, 0	; `build_SYS_str_reasons'::`2'::init
		jnz	short loc_35D7
		push	250h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h
		retn
; ---------------------------------------------------------------------------

loc_35D7:				; CODE XREF: _build_SYS_str_reasons+66j
		push	ebx
		push	ebp
		mov	ebp, dword ptr ds:__imp__strncpy
		mov	ebx, 1
		push	esi
		push	edi
		mov	edi, offset ?strerror_tab@?1??build_SYS_str_reasons@@9@9 ; `build_SYS_str_reasons'::`2'::strerror_tab
		mov	esi, offset dword_D6C

loc_35F0:				; CODE XREF: _build_SYS_str_reasons+D5j
		cmp	dword ptr [esi], 0
		mov	[esi-4], ebx
		jnz	short loc_3620
		push	ebx		; int
		call	dword ptr ds:__imp__strerror
		add	esp, 4
		test	eax, eax
		jz	short loc_3615
		push	20h ; ' '       ; Count
		push	eax		; Source
		push	edi		; Dest
		call	ebp ; __imp__strncpy
		add	esp, 0Ch
		mov	byte ptr [edi+1Fh], 0
		mov	[esi], edi

loc_3615:				; CODE XREF: _build_SYS_str_reasons+ACj
		cmp	dword ptr [esi], 0
		jnz	short loc_3620
		mov	dword ptr [esi], offset	??_C@_07CIFAGBMG@unknown?$AA@ ;	"unknown"

loc_3620:				; CODE XREF: _build_SYS_str_reasons+9Ej
					; _build_SYS_str_reasons+C0j
		add	esi, 8
		inc	ebx
		add	edi, 20h ; ' '
		cmp	esi, offset dword_115C
		jle	short loc_35F0
		push	26Ch
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	0Ah
		mov	?init@?1??build_SYS_str_reasons@@9@9, 0	; `build_SYS_str_reasons'::`2'::init
		call	_CRYPTO_lock
		add	esp, 10h
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_build_SYS_str_reasons endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3654h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_err_fns_check	proc near
		cmp	ds:_err_fns, 0
		jnz	short locret_369B
		push	127h
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		push	1
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_err_fns
		mov	ecx, offset _err_defaults
		push	12Ah
		test	eax, eax
		push	offset ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@ ; ".\\crypto\\err\\err.c"
		cmovnz	ecx, eax
		push	1
		push	0Ah
		mov	ds:_err_fns, ecx
		call	_CRYPTO_lock
		add	esp, 20h

locret_369B:				; CODE XREF: _err_fns_check+7j
		retn
_err_fns_check	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 369Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_err_load_strings proc near		; CODE XREF: _ERR_load_strings+5j

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_4]
		cmp	dword ptr [esi], 0
		jz	short loc_36CF
		push	ebx
		mov	ebx, [esp+8+arg_0]
		nop

loc_36AC:				; CODE XREF: _err_load_strings+30j
		test	ebx, ebx
		jz	short loc_36B8
		movzx	eax, bl
		shl	eax, 18h
		or	[esi], eax

loc_36B8:				; CODE XREF: _err_load_strings+12j
		mov	eax, ds:_err_fns
		push	esi
		mov	eax, [eax+0Ch]
		call	eax
		add	esi, 8
		add	esp, 4
		cmp	dword ptr [esi], 0
		jnz	short loc_36AC
		pop	ebx

loc_36CF:				; CODE XREF: _err_load_strings+8j
		pop	esi
		retn
_err_load_strings endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 36D4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_err_state_LHASH_COMP proc near		; DATA XREF: _int_thread_get+3Co
		jmp	_CRYPTO_THREADID_cmp
_err_state_LHASH_COMP endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 36DCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_err_state_LHASH_HASH proc near		; DATA XREF: _int_thread_get+41o

arg_0		= dword	ptr  4

		push	[esp+arg_0]
		call	_CRYPTO_THREADID_hash
		add	esp, 4
		imul	eax, 0Dh
		retn
_err_state_LHASH_HASH endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 36ECh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_err_state_cmp	proc near
		jmp	_CRYPTO_THREADID_cmp
_err_state_cmp	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 36F4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_err_state_hash	proc near

arg_0		= dword	ptr  4

		push	[esp+arg_0]
		call	_CRYPTO_THREADID_hash
		add	esp, 4
		imul	eax, 0Dh
		retn
_err_state_hash	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3704h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_err_string_data_LHASH_COMP proc near	; DATA XREF: _int_err_get+3Co

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	eax, [eax]
		sub	eax, [ecx]
		retn
_err_string_data_LHASH_COMP endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3714h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_err_string_data_LHASH_HASH proc near	; DATA XREF: _int_err_get+41o

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		push	esi
		mov	eax, [eax]
		mov	esi, eax
		shr	esi, 0Ch
		xor	esi, eax
		shr	esi, 0Ch
		and	esi, 0FFFh
		xor	esi, eax
		mov	eax, 0AF286BCBh
		mul	esi
		mov	eax, esi
		mov	ecx, esi
		sub	eax, edx
		shr	eax, 1
		add	eax, edx
		shr	eax, 4
		imul	eax, 13h
		sub	ecx, eax
		imul	eax, ecx, 0Dh
		xor	eax, esi
		pop	esi
		retn
_err_string_data_LHASH_HASH endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3750h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_err_string_data_cmp proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	eax, [eax]
		sub	eax, [ecx]
		retn
_err_string_data_cmp endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3760h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_err_string_data_hash proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		push	esi
		mov	eax, [eax]
		mov	esi, eax
		shr	esi, 0Ch
		xor	esi, eax
		shr	esi, 0Ch
		and	esi, 0FFFh
		xor	esi, eax
		mov	eax, 0AF286BCBh
		mul	esi
		mov	eax, esi
		mov	ecx, esi
		sub	eax, edx
		shr	eax, 1
		add	eax, edx
		shr	eax, 4
		imul	eax, 13h
		sub	ecx, eax
		imul	eax, ecx, 0Dh
		xor	eax, esi
		pop	esi
		retn
_err_string_data_hash endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 379Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_get_error_values proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		push	edi
		call	_ERR_get_state
		mov	ecx, [esp+4+arg_0]
		mov	edi, eax
		mov	eax, [esp+4+arg_4]
		test	ecx, ecx
		jz	short loc_37F3
		test	eax, eax
		jz	short loc_37F3
		mov	eax, [esp+4+arg_8]
		test	eax, eax
		jz	short loc_37C2
		mov	dword ptr [eax], offset	??_C@_00CNPNBAHC@?$AA@ ; `string'

loc_37C2:				; CODE XREF: _get_error_values+1Ej
		mov	eax, [esp+4+arg_C]
		test	eax, eax
		jz	short loc_37D0
		mov	dword ptr [eax], 0

loc_37D0:				; CODE XREF: _get_error_values+2Cj
		mov	eax, [esp+4+arg_10]
		test	eax, eax
		jz	short loc_37DE
		mov	dword ptr [eax], offset	??_C@_00CNPNBAHC@?$AA@ ; `string'

loc_37DE:				; CODE XREF: _get_error_values+3Aj
		mov	eax, [esp+4+arg_14]
		test	eax, eax
		jz	short loc_37EC
		mov	dword ptr [eax], 0

loc_37EC:				; CODE XREF: _get_error_values+48j
		mov	eax, 44h ; 'D'
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_37F3:				; CODE XREF: _get_error_values+12j
					; _get_error_values+16j
		mov	edx, [edi+18Ch]
		push	esi
		mov	esi, [edi+188h]
		cmp	edx, esi
		jnz	short loc_3809
		pop	esi
		xor	eax, eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_3809:				; CODE XREF: _get_error_values+66j
		test	eax, eax
		jnz	short loc_381D
		lea	esi, [edx+1]
		and	esi, 8000000Fh
		jns	short loc_381D
		dec	esi
		or	esi, 0FFFFFFF0h
		inc	esi

loc_381D:				; CODE XREF: _get_error_values+6Fj
					; _get_error_values+7Aj
		push	ebp
		mov	ebp, [edi+esi*4+48h]
		test	ecx, ecx
		jz	short loc_3834
		mov	[edi+18Ch], esi
		mov	dword ptr [edi+esi*4+48h], 0

loc_3834:				; CODE XREF: _get_error_values+88j
		mov	eax, [esp+0Ch+arg_8]
		test	eax, eax
		jz	short loc_3866
		mov	edx, [esp+0Ch+arg_C]
		test	edx, edx
		jz	short loc_3866
		push	ebx
		mov	ebx, [edi+esi*4+108h]
		test	ebx, ebx
		jnz	short loc_385A
		mov	dword ptr [eax], offset	??_C@_02JDNIPIGD@NA?$AA@ ; `string'
		mov	[edx], ebx
		jmp	short loc_3865
; ---------------------------------------------------------------------------

loc_385A:				; CODE XREF: _get_error_values+B2j
		mov	[eax], ebx
		mov	eax, [edi+esi*4+148h]
		mov	[edx], eax

loc_3865:				; CODE XREF: _get_error_values+BCj
		pop	ebx

loc_3866:				; CODE XREF: _get_error_values+9Ej
					; _get_error_values+A6j
		mov	eax, [esp+0Ch+arg_10]
		test	eax, eax
		jnz	short loc_38AC
		test	ecx, ecx
		jz	short loc_38E0
		mov	eax, [edi+esi*4+88h]
		test	eax, eax
		jz	short loc_389B
		test	byte ptr [edi+esi*4+0C8h], 1
		jz	short loc_389B
		push	eax
		call	_CRYPTO_free
		add	esp, 4
		mov	dword ptr [edi+esi*4+88h], 0

loc_389B:				; CODE XREF: _get_error_values+DFj
					; _get_error_values+E9j
		mov	eax, ebp
		mov	dword ptr [edi+esi*4+0C8h], 0
		pop	ebp
		pop	esi
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_38AC:				; CODE XREF: _get_error_values+D0j
		mov	ecx, [edi+esi*4+88h]
		test	ecx, ecx
		jnz	short loc_38CD
		mov	dword ptr [eax], offset	??_C@_00CNPNBAHC@?$AA@ ; `string'
		mov	eax, [esp+0Ch+arg_14]
		test	eax, eax
		jz	short loc_38E0
		mov	[eax], ecx
		mov	eax, ebp
		pop	ebp
		pop	esi
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_38CD:				; CODE XREF: _get_error_values+119j
		mov	edx, [esp+0Ch+arg_14]
		mov	[eax], ecx
		test	edx, edx
		jz	short loc_38E0
		mov	ecx, [edi+esi*4+0C8h]
		mov	[edx], ecx

loc_38E0:				; CODE XREF: _get_error_values+D4j
					; _get_error_values+127j ...
		mov	eax, ebp
		pop	ebp
		pop	esi
		pop	edi
		retn
_get_error_values endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38E8h
; COMDAT (pick any)
		public ??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@
; `string'
??_C@_0BD@CKILGKAI@?4?2crypto?2err?2err?4c?$AA@	db '.\crypto\err\err.c',0
					; DATA XREF: _int_err_get+6o
					; _int_err_get+2Do ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38FCh
; COMDAT (pick any)
		public ??_C@_0BE@CGMKPIME@int_err_get?5?$CIerr?4c?$CJ?$AA@
; `string'
??_C@_0BE@CGMKPIME@int_err_get?5?$CIerr?4c?$CJ?$AA@ db 'int_err_get (err.c)',0
					; DATA XREF: _int_err_get+32o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3910h
; COMDAT (pick any)
		public ??_C@_0BH@KBGLDIDO@int_thread_get?5?$CIerr?4c?$CJ?$AA@
; `string'
??_C@_0BH@KBGLDIDO@int_thread_get?5?$CIerr?4c?$CJ?$AA@ db 'int_thread_get (err.c)',0
					; DATA XREF: _int_thread_get+32o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3928h
; COMDAT (pick any)
		public ??_C@_07CIFAGBMG@unknown?$AA@
; `string'
??_C@_07CIFAGBMG@unknown?$AA@ db 'unknown',0 ; DATA XREF: _build_SYS_str_reasons+C2o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 3930h
; COMDAT (pick any)
		public ??_C@_00CNPNBAHC@?$AA@
; `string'
??_C@_00CNPNBAHC@?$AA@ db 0		; DATA XREF: _ERR_get_error_line_data+BAo
					; _ERR_peek_error_line_data+71o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3934h
; COMDAT (pick any)
		public ??_C@_02JDNIPIGD@NA?$AA@
; `string'
??_C@_02JDNIPIGD@NA?$AA@ db 4Eh, 41h, 0	; DATA XREF: _ERR_get_error_line+58o
					; _ERR_get_error_line_data+58o	...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3938h
; COMDAT (pick any)
		public ??_C@_08PFHOCFHJ@lib?$CI?$CFlu?$CJ?$AA@
; `string'
??_C@_08PFHOCFHJ@lib?$CI?$CFlu?$CJ?$AA@	db 'lib(%lu)',0 ; DATA XREF: _ERR_error_string_n+7Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3944h
; COMDAT (pick any)
		public ??_C@_09IANFNLBB@func?$CI?$CFlu?$CJ?$AA@
; `string'
??_C@_09IANFNLBB@func?$CI?$CFlu?$CJ?$AA@ db 'func(%lu)',0
					; DATA XREF: _ERR_error_string_n+94o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3950h
; COMDAT (pick any)
		public ??_C@_0M@MNMDFDLE@reason?$CI?$CFlu?$CJ?$AA@
; `string'
??_C@_0M@MNMDFDLE@reason?$CI?$CFlu?$CJ?$AA@ db 'reason(%lu)',0
					; DATA XREF: _ERR_error_string_n+B8o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 395Ch
; COMDAT (pick any)
		public ??_C@_0BF@IKLBHEFA@error?3?$CF08lX?3?$CFs?3?$CFs?3?$CFs?$AA@
; `string'
??_C@_0BF@IKLBHEFA@error?3?$CF08lX?3?$CFs?3?$CFs?3?$CFs?$AA@ db	'error:%08lX:%s:%s:%s',0
					; DATA XREF: _ERR_error_string_n+F2o
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; char *__cdecl	_strchr(const char *Str, int Val)
		extrn __imp__strchr:near ; CODE	XREF: _ERR_error_string_n+128p
					; DATA XREF: _ERR_error_string_n+11Br
; char *__cdecl	_strerror(int)
		extrn __imp__strerror:near ; CODE XREF:	_build_SYS_str_reasons+A1p
					; DATA XREF: _build_SYS_str_reasons+A1r
; char *__cdecl	_strncpy(char *Dest, const char	*Source, size_t	Count)
		extrn __imp__strncpy:near ; CODE XREF: _build_SYS_str_reasons+B2p
					; DATA XREF: _build_SYS_str_reasons+81r
		extrn _CRYPTO_lock:near	; CODE XREF: _int_err_get+11p
					; _int_err_get+71p ...
		extrn _CRYPTO_THREADID_current:near ; CODE XREF: _ERR_get_state+66p
					; _ERR_remove_thread_state+37p
		extrn _CRYPTO_THREADID_cmp:near	; CODE XREF: _err_state_LHASH_COMPj
					; _err_state_cmpj
		extrn _CRYPTO_THREADID_cpy:near	; CODE XREF: _ERR_get_state+75p
					; _ERR_get_state+B9p ...
		extrn _CRYPTO_THREADID_hash:near ; CODE	XREF: _err_state_LHASH_HASH+4p
					; _err_state_hash+4p
		extrn _CRYPTO_add_lock:near ; CODE XREF: _int_thread_release+21p
		extrn _CRYPTO_malloc:near ; CODE XREF: _ERR_add_error_vdata+1Fp
					; _ERR_get_state+A5p
		extrn _CRYPTO_free:near	; CODE XREF: _ERR_STATE_free+23p
					; _ERR_STATE_free+41p ...
		extrn _CRYPTO_realloc:near ; CODE XREF:	_ERR_add_error_vdata+8Dp
		extrn _CRYPTO_push_info_:near ;	CODE XREF: _int_err_get+37p
					; _int_thread_get+37p
		extrn _CRYPTO_pop_info:near ; CODE XREF: _int_err_get+53p
					; _int_thread_get+53p
		extrn _BUF_strlcat:near	; CODE XREF: _ERR_add_error_vdata+A3p
		extrn _BIO_snprintf:near ; CODE	XREF: _ERR_error_string_n+84p
					; _ERR_error_string_n+A0p ...
		extrn _lh_new:near	; CODE XREF: _int_err_get+46p
					; _int_thread_get+46p
		extrn _lh_free:near	; CODE XREF: _int_err_del+20p
					; _int_thread_del_item+B7p
		extrn _lh_insert:near	; CODE XREF: _int_err_set_item+76p
					; _int_thread_set_item+85p
		extrn _lh_delete:near	; CODE XREF: _int_err_del_item+76p
					; _int_thread_del_item+87p
		extrn _lh_retrieve:near	; CODE XREF: _int_err_get_item+76p
					; _int_thread_get_item+85p
		extrn _lh_num_items:near ; CODE	XREF: _int_thread_del_item+A5p
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _ERR_error_string_n+158p
					; _ERR_get_state+12Fp ...
		extrn __chkstk:near	; CODE XREF: _int_thread_get_item+5p
					; _int_thread_set_item+5p ...
		extrn ___security_cookie:near ;	DATA XREF: _ERR_error_string_n+Ar
					; _ERR_get_state+Ar ...


		end
