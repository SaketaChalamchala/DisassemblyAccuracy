;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	F23AF9954E97B79F0B609F2C88FB11A4
; Input	CRC32 :	96FB56E4

; File Name   :	C:\compspace\Diff\openssl\obj\d1_lib.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data		segment	para public 'DATA' use32
		assume cs:_data
		public _DTLSv1_enc_data
_DTLSv1_enc_data dd offset _tls1_enc
		dd offset _tls1_mac
		dd offset _tls1_setup_key_block
		dd offset _tls1_generate_master_secret
		dd offset _tls1_change_cipher_state
		dd offset _tls1_final_finish_mac
		dd 0Ch
		dd offset _tls1_cert_verify_mac
		dd offset ??_C@_0BA@OOFGCNEE@client?5finished?$AA@ ; "client finished"
		dd 0Fh
		dd offset ??_C@_0BA@MHGDKHGN@server?5finished?$AA@ ; "server finished"
		dd 0Fh
		dd offset _tls1_alert_code
		dd offset _tls1_export_keying_material
		dd 9, 0Ch
		dd offset _dtls1_set_handshake_header
		dd offset _dtls1_handshake_write
		public _DTLSv1_2_enc_data
_DTLSv1_2_enc_data dd offset _tls1_enc
		dd offset _tls1_mac
		dd offset _tls1_setup_key_block
		dd offset _tls1_generate_master_secret
		dd offset _tls1_change_cipher_state
		dd offset _tls1_final_finish_mac
		dd 0Ch
		dd offset _tls1_cert_verify_mac
		dd offset ??_C@_0BA@OOFGCNEE@client?5finished?$AA@ ; "client finished"
		dd 0Fh
		dd offset ??_C@_0BA@MHGDKHGN@server?5finished?$AA@ ; "server finished"
		dd 0Fh
		dd offset _tls1_alert_code
		dd offset _tls1_export_keying_material
		dd 1Fh,	0Ch
		dd offset _dtls1_set_handshake_header
		dd offset _dtls1_handshake_write
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 90h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_dtls1_set_handshake_header proc near	; DATA XREF: .data:00000040o
					; .data:00000088o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		mov	edi, [esp+8+arg_8]
		push	edi
		mov	eax, [esi+3Ch]
		push	0
		push	edi
		push	[esp+14h+arg_4]
		push	dword ptr [eax+4]
		push	esi
		call	_dtls1_set_message_header
		lea	eax, [edi+0Ch]
		mov	dword ptr [esi+48h], 0
		push	0
		push	esi
		mov	[esi+44h], eax
		call	_dtls1_buffer_message
		add	esp, 20h
		pop	edi
		pop	esi
		retn
_dtls1_set_handshake_header endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0CCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_dtls1_handshake_write proc near	; DATA XREF: .data:00000044o
					; .data:0000008Co

arg_0		= dword	ptr  4

		push	16h
		push	[esp+4+arg_0]
		call	_dtls1_do_write
		add	esp, 8
		retn
_dtls1_handshake_write endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DCh
		public _dtls1_version_str
_dtls1_version_str db 'DTLSv1 part of OpenSSL 1.0.2h  3 May 2016',0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 108h
; COMDAT (pick any)
		public ??_C@_0BA@OOFGCNEE@client?5finished?$AA@
; `string'
??_C@_0BA@OOFGCNEE@client?5finished?$AA@ db 'client finished',0 ; DATA XREF: .data:00000020o
					; .data:00000068o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 118h
; COMDAT (pick any)
		public ??_C@_0BA@MHGDKHGN@server?5finished?$AA@
; `string'
??_C@_0BA@MHGDKHGN@server?5finished?$AA@ db 'server finished',0 ; DATA XREF: .data:00000028o
					; .data:00000070o
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 128h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_check_timeout_num
_dtls1_check_timeout_num proc near	; CODE XREF: _dtls1_handle_timeout+6Fp

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, [esi+5Ch]
		inc	dword ptr [eax+2C0h]
		mov	eax, [esi+5Ch]
		cmp	dword ptr [eax+2C0h], 2
		jbe	short loc_181
		push	0
		push	0
		push	20h ; ' '
		push	esi
		call	_SSL_ctrl
		add	esp, 10h
		test	eax, 1000h
		jnz	short loc_181
		push	0
		push	0
		push	2Fh ; '/'
		push	esi
		call	_SSL_get_wbio
		add	esp, 4
		push	eax
		call	_BIO_ctrl
		mov	ecx, [esi+5Ch]
		add	esp, 10h
		cmp	eax, [ecx+25Ch]
		jnb	short loc_181
		mov	[ecx+25Ch], eax

loc_181:				; CODE XREF: _dtls1_check_timeout_num+18j
					; _dtls1_check_timeout_num+2Ej	...
		mov	eax, [esi+5Ch]
		pop	esi
		cmp	dword ptr [eax+2C0h], 0Ch
		jbe	short loc_1B0
		push	1E0h
		push	offset ??_C@_0P@HGCFANDK@?4?2ssl?2d1_lib?4c?$AA@ ; ".\\ssl\\d1_lib.c"
		push	138h
		push	13Ch
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_1B0:				; CODE XREF: _dtls1_check_timeout_num+64j
		xor	eax, eax
		retn
_dtls1_check_timeout_num endp ;	sp-analysis failed

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1B4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_clear
_dtls1_clear	proc near

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 0Ch
		call	__chkstk
		push	esi
		mov	esi, [esp+10h+arg_0]
		mov	eax, [esi+5Ch]
		test	eax, eax
		jz	loc_29E
		mov	ecx, [eax+240h]
		push	ebx
		mov	ebx, [eax+258h]
		mov	[esp+14h+arg_0], ecx
		mov	ecx, [eax+244h]
		push	ebp
		mov	ebp, [eax+238h]
		mov	[esp+18h+var_C], ecx
		mov	ecx, [eax+248h]
		push	edi
		mov	edi, [eax+25Ch]
		mov	[esp+1Ch+var_8], ecx
		mov	ecx, [eax+250h]
		push	esi
		mov	[esp+20h+var_4], ecx
		call	_dtls1_clear_queues
		push	2ECh		; Size
		push	0		; Val
		push	dword ptr [esi+5Ch] ; Dst
		call	_memset
		add	esp, 10h
		cmp	dword ptr [esi+24h], 0
		jz	short loc_236
		mov	eax, [esi+5Ch]
		mov	dword ptr [eax+204h], 100h

loc_236:				; CODE XREF: _dtls1_clear+73j
		push	0
		push	0
		push	20h ; ' '
		push	esi
		call	_SSL_ctrl
		add	esp, 10h
		test	eax, 1000h
		jz	short loc_25E
		mov	eax, [esi+5Ch]
		mov	[eax+25Ch], edi
		mov	eax, [esi+5Ch]
		mov	[eax+258h], ebx

loc_25E:				; CODE XREF: _dtls1_clear+96j
		mov	eax, [esi+5Ch]
		mov	ecx, [esp+1Ch+arg_0]
		pop	edi
		mov	[eax+238h], ebp
		mov	eax, [esi+5Ch]
		pop	ebp
		pop	ebx
		mov	[eax+240h], ecx
		mov	eax, [esi+5Ch]
		mov	ecx, [esp+10h+var_C]
		mov	[eax+244h], ecx
		mov	eax, [esi+5Ch]
		mov	ecx, [esp+10h+var_8]
		mov	[eax+248h], ecx
		mov	eax, [esi+5Ch]
		mov	ecx, [esp+10h+var_4]
		mov	[eax+250h], ecx

loc_29E:				; CODE XREF: _dtls1_clear+14j
		push	esi
		call	_ssl3_clear
		add	esp, 4
		test	dword ptr [esi+100h], 8000h
		jz	short loc_2C8
		mov	dword ptr [esi], 100h
		mov	dword ptr [esi+110h], 100h
		pop	esi
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_2C8:				; CODE XREF: _dtls1_clear+FDj
		mov	eax, [esi+8]
		mov	ecx, 0FEFDh
		mov	eax, [eax]
		cmp	eax, 1FFFFh
		cmovz	eax, ecx
		mov	[esi], eax
		pop	esi
		add	esp, 0Ch
		retn
_dtls1_clear	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_dtls1_clear_queues proc near		; CODE XREF: _dtls1_clear+58p
					; _dtls1_free+Cp

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		mov	eax, [esi+5Ch]
		push	dword ptr [eax+238h]
		call	_pqueue_pop
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jz	short loc_33C
		nop	dword ptr [eax]

loc_304:				; CODE XREF: _dtls1_clear_queues+56j
		mov	ecx, [edi+8]
		mov	eax, [ecx+8]
		test	eax, eax
		jz	short loc_317
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_317:				; CODE XREF: _dtls1_clear_queues+28j
		push	dword ptr [edi+8]
		call	_CRYPTO_free
		push	edi
		call	_pitem_free
		mov	eax, [esi+5Ch]
		push	dword ptr [eax+238h]
		call	_pqueue_pop
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jnz	short loc_304

loc_33C:				; CODE XREF: _dtls1_clear_queues+1Bj
		mov	eax, [esi+5Ch]
		push	dword ptr [eax+240h]
		call	_pqueue_pop
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jz	short loc_38C
		nop

loc_354:				; CODE XREF: _dtls1_clear_queues+A6j
		mov	ecx, [edi+8]
		mov	eax, [ecx+8]
		test	eax, eax
		jz	short loc_367
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_367:				; CODE XREF: _dtls1_clear_queues+78j
		push	dword ptr [edi+8]
		call	_CRYPTO_free
		push	edi
		call	_pitem_free
		mov	eax, [esi+5Ch]
		push	dword ptr [eax+240h]
		call	_pqueue_pop
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jnz	short loc_354

loc_38C:				; CODE XREF: _dtls1_clear_queues+6Dj
		mov	eax, [esi+5Ch]
		push	dword ptr [eax+244h]
		call	_pqueue_pop
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jz	short loc_3C9
		nop

loc_3A4:				; CODE XREF: _dtls1_clear_queues+E3j
		push	dword ptr [edi+8]
		call	_dtls1_hm_fragment_free
		push	edi
		call	_pitem_free
		mov	eax, [esi+5Ch]
		push	dword ptr [eax+244h]
		call	_pqueue_pop
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jnz	short loc_3A4

loc_3C9:				; CODE XREF: _dtls1_clear_queues+BDj
		mov	eax, [esi+5Ch]
		push	dword ptr [eax+248h]
		call	_pqueue_pop
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jz	short loc_409
		nop	dword ptr [eax+00h]

loc_3E4:				; CODE XREF: _dtls1_clear_queues+123j
		push	dword ptr [edi+8]
		call	_dtls1_hm_fragment_free
		push	edi
		call	_pitem_free
		mov	eax, [esi+5Ch]
		push	dword ptr [eax+248h]
		call	_pqueue_pop
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jnz	short loc_3E4

loc_409:				; CODE XREF: _dtls1_clear_queues+FAj
		mov	eax, [esi+5Ch]
		push	dword ptr [eax+250h]
		call	_pqueue_pop
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jz	short loc_45C
		nop	dword ptr [eax+00h]

loc_424:				; CODE XREF: _dtls1_clear_queues+176j
		mov	ecx, [edi+8]
		mov	eax, [ecx+8]
		test	eax, eax
		jz	short loc_437
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_437:				; CODE XREF: _dtls1_clear_queues+148j
		push	dword ptr [edi+8]
		call	_CRYPTO_free
		push	edi
		call	_pitem_free
		mov	eax, [esi+5Ch]
		push	dword ptr [eax+250h]
		call	_pqueue_pop
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jnz	short loc_424

loc_45C:				; CODE XREF: _dtls1_clear_queues+13Aj
		pop	edi
		pop	esi
		retn
_dtls1_clear_queues endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 460h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_ctrl
_dtls1_ctrl	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	ecx, [esp+arg_4]
		push	esi
		xor	esi, esi
		lea	eax, [ecx-11h]	; switch 105 cases
		cmp	eax, 68h ; 'h'
		ja	$LN18		; jumptable 0000047A default case
		movzx	eax, ds:$LN20[eax]
		jmp	ds:$LN26[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN4:					; CODE XREF: _dtls1_ctrl+1Aj
					; DATA XREF: .text$mn:$LN26o
		push	[esp+4+arg_C]	; jumptable 0000047A case 73
		push	[esp+8+arg_0]
		call	_dtls1_get_timeout
		add	esp, 8
		test	eax, eax
		jz	loc_57C
		mov	esi, 1
		mov	eax, esi
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN6:					; CODE XREF: _dtls1_ctrl+1Aj
					; DATA XREF: .text$mn:$LN26o
		push	[esp+4+arg_0]	; jumptable 0000047A case 74
		call	_dtls1_handle_timeout
		add	esp, 4
		mov	esi, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN7:					; CODE XREF: _dtls1_ctrl+1Aj
					; DATA XREF: .text$mn:$LN26o
		push	[esp+4+arg_C]	; jumptable 0000047A case 75
		push	[esp+8+arg_0]
		call	_dtls1_listen
		add	esp, 8
		mov	esi, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN8:					; CODE XREF: _dtls1_ctrl+1Aj
					; DATA XREF: .text$mn:$LN26o
		mov	esi, [esp+4+arg_0] ; jumptable 0000047A	case 119
		mov	eax, [esi+0E4h]
		mov	ecx, [eax]
		mov	eax, [esi]
		cmp	eax, [ecx]
		jz	short loc_537
		call	_DTLS_method
		mov	ecx, [esi+0E4h]
		mov	ecx, [ecx]
		mov	ecx, [ecx]
		cmp	ecx, [eax]
		jnz	short loc_519
		mov	eax, [esi+100h]
		test	eax, 8000000h
		jnz	short loc_505
		xor	eax, eax
		cmp	dword ptr [esi], 0FEFDh
		pop	esi
		setz	al
		retn
; ---------------------------------------------------------------------------

loc_505:				; CODE XREF: _dtls1_ctrl+96j
		test	eax, 4000000h
		jnz	short loc_519
		xor	eax, eax
		cmp	dword ptr [esi], 0FEFFh
		pop	esi
		setz	al
		retn
; ---------------------------------------------------------------------------

loc_519:				; CODE XREF: _dtls1_ctrl+89j
					; _dtls1_ctrl+AAj ...
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN13:					; CODE XREF: _dtls1_ctrl+1Aj
					; DATA XREF: .text$mn:$LN26o
		call	_dtls1_link_min_mtu ; jumptable	0000047A case 120
		mov	ecx, [esp+4+arg_8]
		cmp	ecx, eax
		jl	short loc_519
		mov	eax, [esp+4+arg_0]
		mov	eax, [eax+5Ch]
		mov	[eax+258h], ecx

loc_537:				; CODE XREF: _dtls1_ctrl+76j
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN15:					; CODE XREF: _dtls1_ctrl+1Aj
					; DATA XREF: .text$mn:$LN26o
		pop	esi		; jumptable 0000047A case 121
		jmp	_dtls1_link_min_mtu
; ---------------------------------------------------------------------------

$LN16:					; CODE XREF: _dtls1_ctrl+1Aj
					; DATA XREF: .text$mn:$LN26o
		call	_dtls1_link_min_mtu ; jumptable	0000047A case 17
		mov	edx, [esp+4+arg_8]
		sub	eax, 30h ; '0'
		cmp	edx, eax
		jl	short loc_519
		mov	ecx, [esp+4+arg_0]
		mov	eax, edx
		pop	esi
		mov	ecx, [ecx+5Ch]
		mov	[ecx+25Ch], edx
		retn
; ---------------------------------------------------------------------------

$LN18:					; CODE XREF: _dtls1_ctrl+Dj
					; _dtls1_ctrl+1Aj
					; DATA XREF: ...
		push	[esp+4+arg_C]	; jumptable 0000047A default case
		push	[esp+8+arg_8]
		push	ecx
		push	[esp+10h+arg_0]
		call	_ssl3_ctrl
		add	esp, 10h
		mov	esi, eax

loc_57C:				; CODE XREF: _dtls1_ctrl+33j
		mov	eax, esi
		pop	esi
		retn
_dtls1_ctrl	endp

; ---------------------------------------------------------------------------
$LN26		dd offset $LN16, offset	$LN4, offset $LN6, offset $LN7
					; DATA XREF: _dtls1_ctrl+1Ar
		dd offset $LN8,	offset $LN13, offset $LN15, offset $LN18 ; jump	table for switch statement
$LN20		db	0,     7,     7,     7 ; DATA XREF: _dtls1_ctrl+13r
		db	7,     7,     7,     7 ; indirect table	for switch statement
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	1,     2,     3,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     4,     5
		db	6
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 60Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_default_timeout
_dtls1_default_timeout proc near
		mov	eax, 1C20h
		retn
_dtls1_default_timeout endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 614h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_double_timeout
_dtls1_double_timeout proc near

arg_0		= dword	ptr  4

		mov	edx, [esp+arg_0]
		mov	ecx, [edx+5Ch]
		mov	ax, [ecx+2CCh]
		add	ax, ax
		mov	[ecx+2CCh], ax
		mov	eax, [edx+5Ch]
		cmp	word ptr [eax+2CCh], 3Ch ; '<'
		jbe	short loc_645
		mov	ecx, 3Ch ; '<'
		mov	[eax+2CCh], cx

loc_645:				; CODE XREF: _dtls1_double_timeout+23j
		mov	[esp+arg_0], edx
		jmp	_dtls1_start_timer
_dtls1_double_timeout endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 650h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_free
_dtls1_free	proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		push	esi
		call	_ssl3_free
		push	esi
		call	_dtls1_clear_queues
		mov	eax, [esi+5Ch]
		push	dword ptr [eax+238h]
		call	_pqueue_free
		mov	eax, [esi+5Ch]
		push	dword ptr [eax+240h]
		call	_pqueue_free
		mov	eax, [esi+5Ch]
		push	dword ptr [eax+244h]
		call	_pqueue_free
		mov	eax, [esi+5Ch]
		push	dword ptr [eax+248h]
		call	_pqueue_free
		mov	eax, [esi+5Ch]
		push	dword ptr [eax+250h]
		call	_pqueue_free
		push	dword ptr [esi+5Ch]
		call	_CRYPTO_free
		add	esp, 20h
		mov	dword ptr [esi+5Ch], 0
		pop	esi
		retn
_dtls1_free	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6BCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_get_cipher
_dtls1_get_cipher proc near

arg_0		= dword	ptr  4

		push	[esp+arg_0]
		call	_ssl3_get_cipher
		add	esp, 4
		test	eax, eax
		jz	short locret_6D4
		cmp	dword ptr [eax+14h], 4
		jnz	short locret_6D4
		xor	eax, eax

locret_6D4:				; CODE XREF: _dtls1_get_cipher+Ej
					; _dtls1_get_cipher+14j
		retn
_dtls1_get_cipher endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6D8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_get_timeout
_dtls1_get_timeout proc	near		; CODE XREF: _dtls1_ctrl+29p
					; _dtls1_handle_timeout+15p ...

FileTime	= _FILETIME ptr	-1Ch
SystemTime	= _SYSTEMTIME ptr -14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 1Ch
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+1Ch+var_4], eax
		push	ebx
		mov	ebx, [esp+20h+arg_0]
		push	edi
		mov	edi, [esp+24h+arg_4]
		mov	eax, [ebx+5Ch]
		cmp	dword ptr [eax+2C4h], 0
		jnz	short loc_71F
		cmp	dword ptr [eax+2C8h], 0
		jnz	short loc_71F
		pop	edi
		xor	eax, eax
		pop	ebx
		mov	ecx, [esp+1Ch+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_71F:				; CODE XREF: _dtls1_get_timeout+29j
					; _dtls1_get_timeout+32j
		push	ebp
		push	esi
		lea	eax, [esp+2Ch+SystemTime]
		push	eax		; lpSystemTime
		call	dword ptr ds:__imp__GetSystemTime@4 ; GetSystemTime(x)
		lea	eax, [esp+2Ch+FileTime]
		push	eax		; lpFileTime
		lea	eax, [esp+30h+SystemTime]
		push	eax		; lpSystemTime
		call	dword ptr ds:__imp__SystemTimeToFileTime@8 ; SystemTimeToFileTime(x,x)
		mov	esi, [esp+2Ch+FileTime.dwLowDateTime]
		mov	eax, [esp+2Ch+FileTime.dwHighDateTime]
		add	esi, 2AC18000h
		push	0
		push	989680h
		adc	eax, 0FE624E21h
		push	eax
		push	esi
		call	__aulldiv
		mov	ecx, [ebx+5Ch]
		mov	ebp, eax
		imul	eax, ebp, 989680h
		sub	esi, eax
		mov	eax, 66666667h
		imul	esi
		mov	eax, [ecx+2C4h]
		sar	edx, 2
		mov	esi, edx
		shr	esi, 1Fh
		add	esi, edx
		cmp	eax, ebp
		jl	short loc_7C4
		jnz	short loc_78F
		cmp	[ecx+2C8h], esi
		jle	short loc_7C4

loc_78F:				; CODE XREF: _dtls1_get_timeout+ADj
		mov	[edi], eax
		mov	eax, [ecx+2C8h]
		mov	[edi+4], eax
		mov	eax, [edi]
		mov	ecx, [edi+4]
		sub	eax, ebp
		sub	ecx, esi
		mov	[edi], eax
		mov	[edi+4], ecx
		jns	short loc_7B6
		dec	eax
		mov	[edi], eax
		lea	eax, [ecx+0F4240h]
		mov	[edi+4], eax

loc_7B6:				; CODE XREF: _dtls1_get_timeout+D0j
		cmp	dword ptr [edi], 0
		jnz	short loc_7CB
		cmp	dword ptr [edi+4], 3A98h
		jge	short loc_7CB

loc_7C4:				; CODE XREF: _dtls1_get_timeout+ABj
					; _dtls1_get_timeout+B5j
		xorps	xmm0, xmm0
		movq	qword ptr [edi], xmm0

loc_7CB:				; CODE XREF: _dtls1_get_timeout+E1j
					; _dtls1_get_timeout+EAj
		mov	ecx, [esp+2Ch+var_4]
		mov	eax, edi
		pop	esi
		pop	ebp
		pop	edi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1Ch
		retn
_dtls1_get_timeout endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7E0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_handle_timeout
_dtls1_handle_timeout proc near		; CODE XREF: _dtls1_ctrl+46p

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 8
		call	__chkstk
		push	esi
		mov	esi, [esp+0Ch+arg_0]
		lea	eax, [esp+0Ch+var_8]
		push	eax
		push	esi
		call	_dtls1_get_timeout
		add	esp, 8
		test	eax, eax
		jz	loc_8B6
		cmp	[esp+0Ch+var_8], 0
		jg	loc_8B6
		cmp	[esp+0Ch+var_4], 0
		jg	loc_8B6
		mov	ecx, [esi+5Ch]
		mov	ax, [ecx+2CCh]
		add	ax, ax
		mov	[ecx+2CCh], ax
		mov	eax, [esi+5Ch]
		cmp	word ptr [eax+2CCh], 3Ch ; '<'
		jbe	short loc_848
		mov	ecx, 3Ch ; '<'
		mov	[eax+2CCh], cx

loc_848:				; CODE XREF: _dtls1_handle_timeout+5Aj
		push	esi
		call	_dtls1_start_timer
		push	esi
		call	_dtls1_check_timeout_num
		add	esp, 8
		test	eax, eax
		jns	short loc_863
		or	eax, 0FFFFFFFFh
		pop	esi
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_863:				; CODE XREF: _dtls1_handle_timeout+79j
		mov	eax, [esi+5Ch]
		inc	dword ptr [eax+2B8h]
		mov	eax, [esi+5Ch]
		cmp	dword ptr [eax+2B8h], 2
		jbe	short loc_882
		mov	dword ptr [eax+2B8h], 1

loc_882:				; CODE XREF: _dtls1_handle_timeout+96j
		cmp	dword ptr [esi+188h], 0
		push	esi
		jz	short loc_8A3
		mov	dword ptr [esi+188h], 0
		call	_dtls1_heartbeat
		add	esp, 4
		pop	esi
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_8A3:				; CODE XREF: _dtls1_handle_timeout+AAj
		call	_dtls1_start_timer
		push	esi
		call	_dtls1_retransmit_buffered_messages
		add	esp, 8
		pop	esi
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_8B6:				; CODE XREF: _dtls1_handle_timeout+1Fj
					; _dtls1_handle_timeout+2Aj ...
		xor	eax, eax
		pop	esi
		add	esp, 8
		retn
_dtls1_handle_timeout endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8C0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_is_timer_expired
_dtls1_is_timer_expired	proc near

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 8
		call	__chkstk
		lea	eax, [esp+8+var_8]
		push	eax
		push	[esp+0Ch+arg_0]
		call	_dtls1_get_timeout
		add	esp, 8
		test	eax, eax
		jz	short loc_8F4
		cmp	[esp+8+var_8], 0
		jg	short loc_8F4
		cmp	[esp+8+var_4], 0
		jg	short loc_8F4
		mov	eax, 1
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_8F4:				; CODE XREF: _dtls1_is_timer_expired+1Cj
					; _dtls1_is_timer_expired+22j ...
		xor	eax, eax
		add	esp, 8
		retn
_dtls1_is_timer_expired	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8FCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_listen
_dtls1_listen	proc near		; CODE XREF: _dtls1_ctrl+5Ap

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		push	esi
		call	_SSL_clear
		push	0
		push	2000h
		push	20h ; ' '
		push	esi
		call	_SSL_ctrl
		mov	eax, [esi+5Ch]
		push	esi
		mov	dword ptr [eax+254h], 1
		call	_SSL_accept
		add	esp, 18h
		test	eax, eax
		jle	short loc_94F
		push	[esp+4+arg_4]
		push	0
		push	2Eh ; '.'
		push	esi
		call	_SSL_get_rbio
		add	esp, 4
		push	eax
		call	_BIO_ctrl
		add	esp, 10h
		mov	eax, 1

loc_94F:				; CODE XREF: _dtls1_listen+32j
		pop	esi
		retn
_dtls1_listen	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 954h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_new
_dtls1_new	proc near

arg_0		= dword	ptr  4

		push	edi
		mov	edi, [esp+4+arg_0]
		push	edi
		call	_ssl3_new
		add	esp, 4
		test	eax, eax
		jnz	short loc_968
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_968:				; CODE XREF: _dtls1_new+10j
		push	esi
		push	81h ; ''
		push	offset ??_C@_0P@HGCFANDK@?4?2ssl?2d1_lib?4c?$AA@ ; ".\\ssl\\d1_lib.c"
		push	2ECh
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jz	loc_A99
		push	2ECh		; Size
		push	0		; Val
		push	esi		; Dst
		call	_memset
		add	esp, 0Ch
		call	_pqueue_new
		mov	[esi+238h], eax
		call	_pqueue_new
		mov	[esi+240h], eax
		call	_pqueue_new
		mov	[esi+244h], eax
		call	_pqueue_new
		mov	[esi+248h], eax
		call	_pqueue_new
		mov	ecx, eax
		mov	[esi+250h], ecx
		cmp	dword ptr [edi+24h], 0
		jz	short loc_9E3
		mov	dword ptr [esi+204h], 100h

loc_9E3:				; CODE XREF: _dtls1_new+83j
		mov	eax, [esi+238h]
		mov	dword ptr [esi+258h], 0
		mov	dword ptr [esi+25Ch], 0
		test	eax, eax
		jz	short loc_A44
		cmp	dword ptr [esi+240h], 0
		jz	short loc_A37
		cmp	dword ptr [esi+244h], 0
		jz	short loc_A37
		cmp	dword ptr [esi+248h], 0
		jz	short loc_A37
		test	ecx, ecx
		jz	short loc_A37
		mov	eax, [edi+8]
		mov	[edi+5Ch], esi
		push	edi
		mov	eax, [eax+8]
		call	eax
		add	esp, 4
		mov	eax, 1
		pop	esi
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_A37:				; CODE XREF: _dtls1_new+B4j
					; _dtls1_new+BDj ...
		test	eax, eax
		jz	short loc_A44
		push	eax
		call	_pqueue_free
		add	esp, 4

loc_A44:				; CODE XREF: _dtls1_new+ABj
					; _dtls1_new+E5j
		mov	eax, [esi+240h]
		test	eax, eax
		jz	short loc_A57
		push	eax
		call	_pqueue_free
		add	esp, 4

loc_A57:				; CODE XREF: _dtls1_new+F8j
		mov	eax, [esi+244h]
		test	eax, eax
		jz	short loc_A6A
		push	eax
		call	_pqueue_free
		add	esp, 4

loc_A6A:				; CODE XREF: _dtls1_new+10Bj
		mov	eax, [esi+248h]
		test	eax, eax
		jz	short loc_A7D
		push	eax
		call	_pqueue_free
		add	esp, 4

loc_A7D:				; CODE XREF: _dtls1_new+11Ej
		mov	eax, [esi+250h]
		test	eax, eax
		jz	short loc_A90
		push	eax
		call	_pqueue_free
		add	esp, 4

loc_A90:				; CODE XREF: _dtls1_new+131j
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_A99:				; CODE XREF: _dtls1_new+30j
		pop	esi
		xor	eax, eax
		pop	edi
		retn
_dtls1_new	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0AA0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_start_timer
_dtls1_start_timer proc	near		; CODE XREF: _dtls1_double_timeout+35j
					; _dtls1_handle_timeout+69p ...

FileTime	= _FILETIME ptr	-1Ch
SystemTime	= _SYSTEMTIME ptr -14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 1Ch
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+1Ch+var_4], eax
		push	ebx
		mov	ebx, [esp+20h+arg_0]
		push	esi
		push	edi
		mov	eax, [ebx+5Ch]
		cmp	dword ptr [eax+2C4h], 0
		jnz	short loc_ADD
		cmp	dword ptr [eax+2C8h], 0
		jnz	short loc_ADD
		mov	ecx, 1
		mov	[eax+2CCh], cx

loc_ADD:				; CODE XREF: _dtls1_start_timer+26j
					; _dtls1_start_timer+2Fj
		mov	edi, [ebx+5Ch]
		lea	eax, [esp+28h+SystemTime]
		push	eax		; lpSystemTime
		call	dword ptr ds:__imp__GetSystemTime@4 ; GetSystemTime(x)
		lea	eax, [esp+28h+FileTime]
		push	eax		; lpFileTime
		lea	eax, [esp+2Ch+SystemTime]
		push	eax		; lpSystemTime
		call	dword ptr ds:__imp__SystemTimeToFileTime@8 ; SystemTimeToFileTime(x,x)
		mov	esi, [esp+28h+FileTime.dwLowDateTime]
		mov	eax, [esp+28h+FileTime.dwHighDateTime]
		add	esi, 2AC18000h
		push	0
		push	989680h
		adc	eax, 0FE624E21h
		push	eax
		push	esi
		call	__aulldiv
		mov	[edi+2C4h], eax
		imul	eax, 989680h
		sub	esi, eax
		mov	eax, 66666667h
		imul	esi
		sar	edx, 2
		mov	eax, edx
		shr	eax, 1Fh
		add	eax, edx
		mov	[edi+2C8h], eax
		mov	ecx, [ebx+5Ch]
		movzx	eax, word ptr [ecx+2CCh]
		add	[ecx+2C4h], eax
		mov	eax, [ebx+5Ch]
		add	eax, 2C4h
		push	eax
		push	0
		push	2Dh ; '-'
		push	ebx
		call	_SSL_get_rbio
		add	esp, 4
		push	eax
		call	_BIO_ctrl
		mov	ecx, [esp+38h+var_4]
		add	esp, 10h
		pop	edi
		pop	esi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1Ch
		retn
_dtls1_start_timer endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B84h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_stop_timer
_dtls1_stop_timer proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		xorps	xmm0, xmm0
		mov	ecx, 1
		mov	eax, [esi+5Ch]
		movq	qword ptr [eax+2B8h], xmm0
		mov	dword ptr [eax+2C0h], 0
		mov	eax, [esi+5Ch]
		movq	qword ptr [eax+2C4h], xmm0
		mov	eax, [esi+5Ch]
		mov	[eax+2CCh], cx
		mov	eax, [esi+5Ch]
		add	eax, 2C4h
		push	eax
		push	0
		push	2Dh ; '-'
		push	esi
		call	_SSL_get_rbio
		add	esp, 4
		push	eax
		call	_BIO_ctrl
		push	esi
		call	_dtls1_clear_record_buffer
		add	esp, 14h
		pop	esi
		retn
_dtls1_stop_timer endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0BE4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_get_current_time proc near

FileTime	= _FILETIME ptr	-1Ch
SystemTime	= _SYSTEMTIME ptr -14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 1Ch
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+1Ch+var_4], eax
		push	esi
		push	edi
		mov	edi, [esp+24h+arg_0]
		lea	eax, [esp+24h+SystemTime]
		push	eax		; lpSystemTime
		call	dword ptr ds:__imp__GetSystemTime@4 ; GetSystemTime(x)
		lea	eax, [esp+24h+FileTime]
		push	eax		; lpFileTime
		lea	eax, [esp+28h+SystemTime]
		push	eax		; lpSystemTime
		call	dword ptr ds:__imp__SystemTimeToFileTime@8 ; SystemTimeToFileTime(x,x)
		mov	esi, [esp+24h+FileTime.dwLowDateTime]
		mov	eax, [esp+24h+FileTime.dwHighDateTime]
		add	esi, 2AC18000h
		push	0
		push	989680h
		adc	eax, 0FE624E21h
		push	eax
		push	esi
		call	__aulldiv
		mov	[edi], eax
		imul	eax, 989680h
		mov	ecx, [esp+24h+var_4]
		sub	esi, eax
		mov	eax, 66666667h
		imul	esi
		sar	edx, 2
		mov	eax, edx
		shr	eax, 1Fh
		add	eax, edx
		mov	[edi+4], eax
		pop	edi
		pop	esi
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1Ch
		retn
_get_current_time endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C6Ch
; COMDAT (pick any)
		public ??_C@_0P@HGCFANDK@?4?2ssl?2d1_lib?4c?$AA@
; `string'
??_C@_0P@HGCFANDK@?4?2ssl?2d1_lib?4c?$AA@ db '.\ssl\d1_lib.c',0
					; DATA XREF: _dtls1_check_timeout_num+6Bo
					; _dtls1_new+1Ao
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _tls1_change_cipher_state:near ; DATA XREF: .data:00000010o
					; .data:00000058o
		extrn _tls1_setup_key_block:near ; DATA	XREF: .data:00000008o
					; .data:00000050o
		extrn _tls1_enc:near	; DATA XREF: .data:_DTLSv1_enc_datao
					; .data:_DTLSv1_2_enc_datao
		extrn _tls1_final_finish_mac:near ; DATA XREF: .data:00000014o
					; .data:0000005Co
		extrn _tls1_cert_verify_mac:near ; DATA	XREF: .data:0000001Co
					; .data:00000064o
		extrn _tls1_mac:near	; DATA XREF: .data:00000004o
					; .data:0000004Co
		extrn _tls1_generate_master_secret:near	; DATA XREF: .data:0000000Co
					; .data:00000054o
		extrn _tls1_export_keying_material:near	; DATA XREF: .data:00000034o
					; .data:0000007Co
		extrn _tls1_alert_code:near ; DATA XREF: .data:00000030o
					; .data:00000078o
		extrn _CRYPTO_malloc:near ; CODE XREF: _dtls1_new+24p
		extrn _CRYPTO_free:near	; CODE XREF: _dtls1_clear_queues+2Bp
					; _dtls1_clear_queues+36p ...
		extrn _BIO_ctrl:near	; CODE XREF: _dtls1_check_timeout_num+40p
					; _dtls1_listen+46p ...
; void __stdcall GetSystemTime(LPSYSTEMTIME lpSystemTime)
		extrn __imp__GetSystemTime@4:near ; CODE XREF: _dtls1_get_timeout+4Ep
					; _dtls1_start_timer+45p ...
; BOOL __stdcall SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime)
		extrn __imp__SystemTimeToFileTime@8:near ; CODE	XREF: _dtls1_get_timeout+5Ep
					; _dtls1_start_timer+55p ...
		extrn _ERR_put_error:near ; CODE XREF: _dtls1_check_timeout_num+7Cp
		extrn _pitem_free:near	; CODE XREF: _dtls1_clear_queues+3Cp
					; _dtls1_clear_queues+8Cp ...
		extrn _pqueue_new:near	; CODE XREF: _dtls1_new+46p
					; _dtls1_new+51p ...
		extrn _pqueue_free:near	; CODE XREF: _dtls1_free+1Ap
					; _dtls1_free+28p ...
		extrn _pqueue_pop:near	; CODE XREF: _dtls1_clear_queues+Fp
					; _dtls1_clear_queues+4Ap ...
		extrn _SSL_clear:near	; CODE XREF: _dtls1_listen+6p
		extrn _SSL_get_rbio:near ; CODE	XREF: _dtls1_listen+3Dp
					; _dtls1_start_timer+BFp ...
		extrn _SSL_get_wbio:near ; CODE	XREF: _dtls1_check_timeout_num+37p
		extrn _SSL_accept:near	; CODE XREF: _dtls1_listen+28p
		extrn _SSL_ctrl:near	; CODE XREF: _dtls1_check_timeout_num+21p
					; _dtls1_clear+89p ...
		extrn _DTLS_method:near	; CODE XREF: _dtls1_ctrl+78p
		extrn _ssl3_get_cipher:near ; CODE XREF: _dtls1_get_cipher+4p
		extrn _ssl3_new:near	; CODE XREF: _dtls1_new+6p
		extrn _ssl3_free:near	; CODE XREF: _dtls1_free+6p
		extrn _ssl3_clear:near	; CODE XREF: _dtls1_clear+EBp
		extrn _ssl3_ctrl:near	; CODE XREF: _dtls1_ctrl+112p
		extrn _dtls1_do_write:near ; CODE XREF:	_dtls1_handshake_write+6p
		extrn _dtls1_set_message_header:near
					; CODE XREF: _dtls1_set_handshake_header+19p
		extrn _dtls1_buffer_message:near
					; CODE XREF: _dtls1_set_handshake_header+2Ep
		extrn _dtls1_retransmit_buffered_messages:near
					; CODE XREF: _dtls1_handle_timeout+C9p
		extrn _dtls1_clear_record_buffer:near ;	CODE XREF: _dtls1_stop_timer+54p
		extrn _dtls1_link_min_mtu:near ; CODE XREF: _dtls1_ctrl:$LN13p
					; _dtls1_ctrl+DFj ...
		extrn _dtls1_hm_fragment_free:near ; CODE XREF:	_dtls1_clear_queues+C3p
					; _dtls1_clear_queues+103p
		extrn _dtls1_heartbeat:near ; CODE XREF: _dtls1_handle_timeout+B6p
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _dtls1_get_timeout+3Ep
					; _dtls1_get_timeout+FFp ...
		extrn __aulldiv:near	; CODE XREF: _dtls1_get_timeout+80p
					; _dtls1_start_timer+77p ...
		extrn __chkstk:near	; CODE XREF: _dtls1_clear+5p
					; _dtls1_get_timeout+5p ...
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _dtls1_clear+67p
					; _dtls1_new+3Ep
		extrn ___security_cookie:near ;	DATA XREF: _dtls1_get_timeout+Ar
					; _dtls1_start_timer+Ar ...


		end
