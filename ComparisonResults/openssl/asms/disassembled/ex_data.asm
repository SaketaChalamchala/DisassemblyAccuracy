;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	205A54CE6D3B89DD50554F122AE98167
; Input	CRC32 :	79128FAA

; File Name   :	C:\compspace\Diff\openssl\obj\ex_data.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
_impl		dd ?			; DATA XREF: _int_cleanup+3Aw
					; _CRYPTO_cleanup_all_ex_datar	...
_ex_data	dd ?			; DATA XREF: _int_cleanupr
					; _int_cleanup+12r ...
_bss		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_int_new_class	proc near		; DATA XREF: .data:_impl_defaulto
		push	esi
		push	181h
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	2
		push	9
		call	_CRYPTO_lock
		mov	ecx, _ex_class
		mov	esi, ecx
		push	183h
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		inc	ecx
		push	2
		push	0Ah
		mov	_ex_class, ecx
		call	_CRYPTO_lock
		add	esp, 20h
		mov	eax, esi
		pop	esi
		retn
_int_new_class	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 48h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_int_cleanup	proc near		; DATA XREF: .data:000004B4o
		mov	eax, ds:_ex_data
		test	eax, eax
		jnz	short loc_5F
		call	_ex_data_check
		test	eax, eax
		jz	short locret_8C
		mov	eax, ds:_ex_data

loc_5F:					; CODE XREF: _int_cleanup+7j
		push	offset _def_cleanup_cb

loc_64:					; DATA XREF: .data:_ex_classo
		push	eax
		call	_lh_doall
		push	ds:_ex_data
		call	_lh_free
		add	esp, 0Ch
		mov	ds:_ex_data, 0
		mov	ds:_impl, 0

locret_8C:				; CODE XREF: _int_cleanup+10j
		retn
_int_cleanup	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 90h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_int_get_new_index proc	near		; DATA XREF: .data:000004B8o

arg_0		= dword	ptr  4

		push	[esp+arg_0]
		call	_def_get_class
		add	esp, 4
		test	eax, eax
		jnz	short loc_A4
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_A4:					; CODE XREF: _int_get_new_index+Ej
		mov	[esp+arg_0], eax
		jmp	_def_add_index
_int_get_new_index endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_int_new_ex_data proc near		; DATA XREF: .data:000004BCo

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebp
		push	edi
		push	[esp+8+arg_0]
		xor	edi, edi
		call	_def_get_class
		mov	ebp, eax
		add	esp, 4
		test	ebp, ebp
		jnz	short loc_C9
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_C9:					; CODE XREF: _int_new_ex_data+14j
		mov	eax, [esp+8+arg_8]
		push	ebx
		push	esi
		push	1AAh
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	2
		push	5
		mov	[eax], edi
		call	_CRYPTO_lock
		push	dword ptr [ebp+4]
		call	_sk_num
		mov	ebx, eax
		add	esp, 14h
		test	ebx, ebx
		jle	short $skip$32
		push	1ADh
		lea	eax, ds:0[ebx*4]
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	eax
		call	_CRYPTO_malloc
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jz	short $skip$32
		xor	esi, esi
		test	ebx, ebx
		jle	short $skip$32
		nop	dword ptr [eax+eax+00h]

loc_120:				; CODE XREF: _int_new_ex_data+82j
		push	esi
		push	dword ptr [ebp+4]
		call	_sk_value
		mov	[edi+esi*4], eax
		add	esp, 8
		inc	esi
		cmp	esi, ebx
		jl	short loc_120

$skip$32:				; CODE XREF: _int_new_ex_data+43j
					; _int_new_ex_data+63j	...
		push	1B4h
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	2
		push	6
		call	_CRYPTO_lock
		add	esp, 10h
		test	ebx, ebx
		jle	short loc_171
		test	edi, edi
		jnz	short loc_171
		push	1B6h
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	41h ; 'A'
		push	6Ch ; 'l'
		push	0Fh
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		pop	ebx
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_171:				; CODE XREF: _int_new_ex_data+9Cj
					; _int_new_ex_data+A0j
		xor	esi, esi
		test	ebx, ebx
		jle	short loc_1CE

loc_177:				; CODE XREF: _int_new_ex_data+11Cj
		mov	eax, [edi+esi*4]
		test	eax, eax
		jz	short loc_1C9
		cmp	dword ptr [eax+8], 0
		jz	short loc_1C9
		mov	ebp, [esp+10h+arg_8]
		mov	eax, [ebp+0]
		test	eax, eax
		jnz	short loc_193
		xor	ecx, ecx
		jmp	short loc_1B2
; ---------------------------------------------------------------------------

loc_193:				; CODE XREF: _int_new_ex_data+DDj
		push	eax
		call	_sk_num
		add	esp, 4
		cmp	esi, eax
		jl	short loc_1A4
		xor	ecx, ecx
		jmp	short loc_1B2
; ---------------------------------------------------------------------------

loc_1A4:				; CODE XREF: _int_new_ex_data+EEj
		push	esi
		push	dword ptr [ebp+0]
		call	_sk_value
		add	esp, 8
		mov	ecx, eax

loc_1B2:				; CODE XREF: _int_new_ex_data+E1j
					; _int_new_ex_data+F2j
		mov	eax, [edi+esi*4]
		push	dword ptr [eax+4]
		push	dword ptr [eax]
		mov	eax, [eax+8]
		push	esi
		push	ebp
		push	ecx
		push	[esp+24h+arg_4]
		call	eax
		add	esp, 18h

loc_1C9:				; CODE XREF: _int_new_ex_data+CCj
					; _int_new_ex_data+D2j
		inc	esi
		cmp	esi, ebx
		jl	short loc_177

loc_1CE:				; CODE XREF: _int_new_ex_data+C5j
		test	edi, edi
		jz	short loc_1DB
		push	edi
		call	_CRYPTO_free
		add	esp, 4

loc_1DB:				; CODE XREF: _int_new_ex_data+120j
		pop	esi
		pop	ebx
		pop	edi
		mov	eax, 1
		pop	ebp
		retn
_int_new_ex_data endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1E8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_int_dup_ex_data proc near		; DATA XREF: .data:000004C0o

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 8
		call	__chkstk
		push	ebp
		mov	ebp, [esp+0Ch+arg_8]
		push	edi
		xor	edi, edi
		cmp	[ebp+0], edi
		jnz	short loc_208
		lea	eax, [edi+1]
		pop	edi
		pop	ebp
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_208:				; CODE XREF: _int_dup_ex_data+15j
		push	ebx
		push	[esp+14h+arg_0]
		call	_def_get_class
		mov	ebx, eax
		add	esp, 4
		mov	[esp+14h+var_4], ebx
		test	ebx, ebx
		jnz	short loc_226
		pop	ebx
		pop	edi
		pop	ebp
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_226:				; CODE XREF: _int_dup_ex_data+35j
		push	esi
		push	1D2h
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	2
		push	5
		call	_CRYPTO_lock
		push	dword ptr [ebx+4]
		call	_sk_num
		push	dword ptr [ebp+0]
		mov	ebx, eax
		call	_sk_num
		add	esp, 18h
		cmp	eax, ebx
		cmovl	ebx, eax
		test	ebx, ebx
		jle	short $skip$34
		push	1D8h
		lea	eax, ds:0[ebx*4]
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	eax
		call	_CRYPTO_malloc
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jz	short $skip$34
		xor	esi, esi
		test	ebx, ebx
		jle	short $skip$34
		mov	ebp, [esp+18h+var_4]
		nop	word ptr [eax+eax+00h]

loc_288:				; CODE XREF: _int_dup_ex_data+B2j
		push	esi
		push	dword ptr [ebp+4]
		call	_sk_value
		mov	[edi+esi*4], eax
		add	esp, 8
		inc	esi
		cmp	esi, ebx
		jl	short loc_288
		mov	ebp, [esp+18h+arg_8]

$skip$34:				; CODE XREF: _int_dup_ex_data+6Ej
					; _int_dup_ex_data+8Ej	...
		push	1DFh
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	2
		push	6
		call	_CRYPTO_lock
		add	esp, 10h
		test	ebx, ebx
		jle	short loc_2E0
		test	edi, edi
		jnz	short loc_2E0
		push	1E1h
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	41h ; 'A'
		push	6Ah ; 'j'
		push	0Fh
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		pop	ebx
		pop	edi
		pop	ebp
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_2E0:				; CODE XREF: _int_dup_ex_data+D0j
					; _int_dup_ex_data+D4j
		xor	esi, esi
		test	ebx, ebx
		jle	short loc_34A
		xchg	ax, ax

loc_2E8:				; CODE XREF: _int_dup_ex_data+160j
		mov	eax, [ebp+0]
		test	eax, eax
		jz	short loc_30C
		push	eax
		call	_sk_num
		add	esp, 4
		cmp	esi, eax
		jl	short loc_300
		xor	eax, eax
		jmp	short loc_30C
; ---------------------------------------------------------------------------

loc_300:				; CODE XREF: _int_dup_ex_data+112j
		push	esi
		push	dword ptr [ebp+0]
		call	_sk_value
		add	esp, 8

loc_30C:				; CODE XREF: _int_dup_ex_data+105j
					; _int_dup_ex_data+116j
		mov	[esp+18h+var_8], eax
		mov	ecx, [edi+esi*4]
		test	ecx, ecx
		jz	short loc_337
		mov	edx, [ecx+10h]
		test	edx, edx
		jz	short loc_337
		push	dword ptr [ecx+4]
		lea	eax, [esp+1Ch+var_8]
		push	dword ptr [ecx]
		push	esi
		push	eax
		push	ebp
		push	[esp+2Ch+arg_4]
		call	edx
		mov	eax, [esp+30h+var_8]
		add	esp, 18h

loc_337:				; CODE XREF: _int_dup_ex_data+12Dj
					; _int_dup_ex_data+134j
		push	eax
		push	esi
		push	[esp+20h+arg_4]
		call	_CRYPTO_set_ex_data
		inc	esi
		add	esp, 0Ch
		cmp	esi, ebx
		jl	short loc_2E8

loc_34A:				; CODE XREF: _int_dup_ex_data+FCj
		test	edi, edi
		jz	short loc_357
		push	edi
		call	_CRYPTO_free
		add	esp, 4

loc_357:				; CODE XREF: _int_dup_ex_data+164j
		pop	esi
		pop	ebx
		pop	edi
		mov	eax, 1
		pop	ebp
		add	esp, 8
		retn
_int_dup_ex_data endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 364h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_int_free_ex_data proc near		; DATA XREF: .data:000004C4o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	edi
		xor	edi, edi
		cmp	ds:_ex_data, edi
		jz	loc_4AE
		push	ebp
		push	[esp+8+arg_0]
		call	_def_get_class
		mov	ebp, eax
		add	esp, 4
		test	ebp, ebp
		jz	loc_4AD
		push	ebx
		push	esi
		push	1FBh
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	2
		push	5
		call	_CRYPTO_lock
		push	dword ptr [ebp+4]
		call	_sk_num
		mov	ebx, eax
		add	esp, 14h
		test	ebx, ebx
		jle	short $skip$35
		push	1FEh
		lea	eax, ds:0[ebx*4]
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	eax
		call	_CRYPTO_malloc
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jz	short $skip$35
		xor	esi, esi
		test	ebx, ebx
		jle	short $skip$35

loc_3D6:				; CODE XREF: _int_free_ex_data+84j
		push	esi
		push	dword ptr [ebp+4]
		call	_sk_value
		mov	[edi+esi*4], eax
		add	esp, 8
		inc	esi
		cmp	esi, ebx
		jl	short loc_3D6

$skip$35:				; CODE XREF: _int_free_ex_data+4Aj
					; _int_free_ex_data+6Aj ...
		push	205h
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	2
		push	6
		call	_CRYPTO_lock
		add	esp, 10h
		test	ebx, ebx
		jle	short loc_425
		test	edi, edi
		jnz	short loc_425
		push	207h
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	41h ; 'A'
		push	6Bh ; 'k'
		push	0Fh
		call	_ERR_put_error
		add	esp, 14h
		pop	esi
		pop	ebx
		pop	ebp
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_425:				; CODE XREF: _int_free_ex_data+9Ej
					; _int_free_ex_data+A2j
		mov	ebp, [esp+10h+arg_8]
		xor	esi, esi
		test	ebx, ebx
		jle	short loc_487
		nop	dword ptr [eax+eax+00h]

loc_434:				; CODE XREF: _int_free_ex_data+121j
		mov	eax, [edi+esi*4]
		test	eax, eax
		jz	short loc_482
		cmp	dword ptr [eax+0Ch], 0
		jz	short loc_482
		mov	eax, [ebp+0]
		test	eax, eax
		jnz	short loc_44C
		xor	ecx, ecx
		jmp	short loc_46B
; ---------------------------------------------------------------------------

loc_44C:				; CODE XREF: _int_free_ex_data+E2j
		push	eax
		call	_sk_num
		add	esp, 4
		cmp	esi, eax
		jl	short loc_45D
		xor	ecx, ecx
		jmp	short loc_46B
; ---------------------------------------------------------------------------

loc_45D:				; CODE XREF: _int_free_ex_data+F3j
		push	esi
		push	dword ptr [ebp+0]
		call	_sk_value
		add	esp, 8
		mov	ecx, eax

loc_46B:				; CODE XREF: _int_free_ex_data+E6j
					; _int_free_ex_data+F7j
		mov	eax, [edi+esi*4]
		push	dword ptr [eax+4]
		push	dword ptr [eax]
		mov	eax, [eax+0Ch]
		push	esi
		push	ebp
		push	ecx
		push	[esp+24h+arg_4]
		call	eax
		add	esp, 18h

loc_482:				; CODE XREF: _int_free_ex_data+D5j
					; _int_free_ex_data+DBj
		inc	esi
		cmp	esi, ebx
		jl	short loc_434

loc_487:				; CODE XREF: _int_free_ex_data+C9j
		test	edi, edi
		jz	short loc_494
		push	edi
		call	_CRYPTO_free
		add	esp, 4

loc_494:				; CODE XREF: _int_free_ex_data+125j
		mov	eax, [ebp+0]
		test	eax, eax
		jz	short loc_4AB
		push	eax
		call	_sk_free
		add	esp, 4
		mov	dword ptr [ebp+0], 0

loc_4AB:				; CODE XREF: _int_free_ex_data+135j
		pop	esi
		pop	ebx

loc_4AD:				; CODE XREF: _int_free_ex_data+20j
		pop	ebp

loc_4AE:				; CODE XREF: _int_free_ex_data+9j
		pop	edi
		retn
_int_free_ex_data endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 4B0h
_impl_default	dd offset _int_new_class ; DATA	XREF: _CRYPTO_cleanup_all_ex_data+21o
					; _CRYPTO_dup_ex_data+21o ...
		dd offset _int_cleanup
		dd offset _int_get_new_index
		dd offset _int_new_ex_data
		dd offset _int_dup_ex_data
		dd offset _int_free_ex_data
_ex_class	dd offset loc_64	; DATA XREF: _int_new_class+14r
					; _int_new_class+2Bw
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4CCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_cleanup_all_ex_data
_CRYPTO_cleanup_all_ex_data proc near
		mov	eax, ds:_impl
		test	eax, eax
		jnz	short loc_518
		push	0C9h ; 'É'
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	2
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_impl
		mov	ecx, offset _impl_default
		push	0CCh ; 'Ì'
		test	eax, eax
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		cmovnz	ecx, eax
		push	2
		push	0Ah
		mov	ds:_impl, ecx
		call	_CRYPTO_lock
		mov	eax, ds:_impl
		add	esp, 20h

loc_518:				; CODE XREF: _CRYPTO_cleanup_all_ex_data+7j
		mov	eax, [eax+4]
		jmp	eax
_CRYPTO_cleanup_all_ex_data endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 520h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_dup_ex_data
_CRYPTO_dup_ex_data proc near
		mov	eax, ds:_impl
		test	eax, eax
		jnz	short loc_56C
		push	0C9h ; 'É'
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	2
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_impl
		mov	ecx, offset _impl_default
		push	0CCh ; 'Ì'
		test	eax, eax
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		cmovnz	ecx, eax
		push	2
		push	0Ah
		mov	ds:_impl, ecx
		call	_CRYPTO_lock
		mov	eax, ds:_impl
		add	esp, 20h

loc_56C:				; CODE XREF: _CRYPTO_dup_ex_data+7j
		mov	eax, [eax+10h]
		jmp	eax
_CRYPTO_dup_ex_data endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 574h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_ex_data_new_class
_CRYPTO_ex_data_new_class proc near
		mov	eax, ds:_impl
		test	eax, eax
		jnz	short loc_5C0
		push	0C9h ; 'É'
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	2
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_impl
		mov	ecx, offset _impl_default
		push	0CCh ; 'Ì'
		test	eax, eax
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		cmovnz	ecx, eax
		push	2
		push	0Ah
		mov	ds:_impl, ecx
		call	_CRYPTO_lock
		mov	eax, ds:_impl
		add	esp, 20h

loc_5C0:				; CODE XREF: _CRYPTO_ex_data_new_class+7j
		mov	eax, [eax]
		jmp	eax
_CRYPTO_ex_data_new_class endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5C4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_free_ex_data
_CRYPTO_free_ex_data proc near
		mov	eax, ds:_impl
		test	eax, eax
		jnz	short loc_610
		push	0C9h ; 'É'
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	2
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_impl
		mov	ecx, offset _impl_default
		push	0CCh ; 'Ì'
		test	eax, eax
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		cmovnz	ecx, eax
		push	2
		push	0Ah
		mov	ds:_impl, ecx
		call	_CRYPTO_lock
		mov	eax, ds:_impl
		add	esp, 20h

loc_610:				; CODE XREF: _CRYPTO_free_ex_data+7j
		mov	eax, [eax+14h]
		jmp	eax
_CRYPTO_free_ex_data endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 618h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_get_ex_data
_CRYPTO_get_ex_data proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, [esi]
		test	eax, eax
		jnz	short loc_627

loc_623:				; CODE XREF: _CRYPTO_get_ex_data+1Ej
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_627:				; CODE XREF: _CRYPTO_get_ex_data+9j
		push	eax
		call	_sk_num
		mov	ecx, [esp+8+arg_4]
		add	esp, 4
		cmp	ecx, eax
		jge	short loc_623
		push	ecx
		push	dword ptr [esi]
		call	_sk_value
		add	esp, 8
		pop	esi
		retn
_CRYPTO_get_ex_data endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 648h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_get_ex_data_implementation
_CRYPTO_get_ex_data_implementation proc	near
		mov	eax, ds:_impl
		test	eax, eax
		jnz	short locret_694
		push	0C9h ; 'É'
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	2
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_impl
		mov	ecx, offset _impl_default
		push	0CCh ; 'Ì'
		test	eax, eax
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		cmovnz	ecx, eax
		push	2
		push	0Ah
		mov	ds:_impl, ecx
		call	_CRYPTO_lock
		mov	eax, ds:_impl
		add	esp, 20h

locret_694:				; CODE XREF: _CRYPTO_get_ex_data_implementation+7j
		retn
_CRYPTO_get_ex_data_implementation endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 698h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_get_ex_new_index
_CRYPTO_get_ex_new_index proc near
		mov	eax, ds:_impl
		test	eax, eax
		jnz	short loc_6E4
		push	0C9h ; 'É'
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	2
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_impl
		mov	ecx, offset _impl_default
		push	0CCh ; 'Ì'
		test	eax, eax
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		cmovnz	ecx, eax
		push	2
		push	0Ah
		mov	ds:_impl, ecx
		call	_CRYPTO_lock
		mov	eax, ds:_impl
		add	esp, 20h

loc_6E4:				; CODE XREF: _CRYPTO_get_ex_new_index+7j
		mov	eax, [eax+8]
		jmp	eax
_CRYPTO_get_ex_new_index endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6ECh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_new_ex_data
_CRYPTO_new_ex_data proc near
		mov	eax, ds:_impl
		test	eax, eax
		jnz	short loc_738
		push	0C9h ; 'É'
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	2
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_impl
		mov	ecx, offset _impl_default
		push	0CCh ; 'Ì'
		test	eax, eax
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		cmovnz	ecx, eax
		push	2
		push	0Ah
		mov	ds:_impl, ecx
		call	_CRYPTO_lock
		mov	eax, ds:_impl
		add	esp, 20h

loc_738:				; CODE XREF: _CRYPTO_new_ex_data+7j
		mov	eax, [eax+0Ch]
		jmp	eax
_CRYPTO_new_ex_data endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 740h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_set_ex_data
_CRYPTO_set_ex_data proc near		; CODE XREF: _int_dup_ex_data+155p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	edi
		mov	edi, [esp+4+arg_0]
		cmp	dword ptr [edi], 0
		jnz	short loc_771
		call	_sk_new_null
		mov	[edi], eax
		test	eax, eax
		jnz	short loc_771
		push	267h
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	41h ; 'A'
		push	66h ; 'f'
		push	0Fh
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_771:				; CODE XREF: _CRYPTO_set_ex_data+8j
					; _CRYPTO_set_ex_data+13j
		push	ebx
		push	esi
		push	dword ptr [edi]
		call	_sk_num
		mov	ebx, [esp+10h+arg_4]
		mov	esi, eax
		add	esp, 4
		cmp	esi, ebx
		jg	short loc_79C

loc_787:				; CODE XREF: _CRYPTO_set_ex_data+5Aj
		push	0
		push	dword ptr [edi]
		call	_sk_push
		add	esp, 8
		test	eax, eax
		jz	short loc_7B4
		inc	esi
		cmp	esi, ebx
		jle	short loc_787

loc_79C:				; CODE XREF: _CRYPTO_set_ex_data+45j
		push	[esp+0Ch+arg_8]
		push	ebx
		push	dword ptr [edi]
		call	_sk_set
		add	esp, 0Ch
		mov	eax, 1
		pop	esi
		pop	ebx
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_7B4:				; CODE XREF: _CRYPTO_set_ex_data+55j
		push	26Fh
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	41h ; 'A'
		push	66h ; 'f'
		push	0Fh
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		pop	ebx
		pop	edi
		retn
_CRYPTO_set_ex_data endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7D4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_set_ex_data_implementation
_CRYPTO_set_ex_data_implementation proc	near

arg_0		= dword	ptr  4

		push	esi
		push	0DEh ; 'Þ'
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	2
		push	9
		xor	esi, esi
		call	_CRYPTO_lock
		add	esp, 10h
		cmp	ds:_impl, esi
		jnz	short loc_803
		mov	eax, [esp+4+arg_0]
		mov	esi, 1
		mov	ds:_impl, eax

loc_803:				; CODE XREF: _CRYPTO_set_ex_data_implementation+1Fj
		push	0E3h ; 'ã'
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	2
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h
		mov	eax, esi
		pop	esi
		retn
_CRYPTO_set_ex_data_implementation endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 820h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_def_add_index	proc near		; CODE XREF: _int_get_new_index+18j

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		push	ebx
		push	edi
		push	162h
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	14h
		or	ebx, 0FFFFFFFFh
		call	_CRYPTO_malloc
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jnz	short loc_85C
		push	164h
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	41h ; 'A'
		push	68h ; 'h'
		push	0Fh
		call	_ERR_put_error
		add	esp, 14h
		or	eax, ebx
		pop	edi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_85C:				; CODE XREF: _def_add_index+1Dj
		mov	eax, [esp+8+arg_4]
		push	esi
		mov	[edi], eax
		mov	eax, [esp+0Ch+arg_8]
		mov	[edi+4], eax
		mov	eax, [esp+0Ch+arg_C]
		push	16Ch
		mov	[edi+8], eax
		mov	eax, [esp+10h+arg_10]
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		mov	[edi+10h], eax
		mov	eax, [esp+14h+arg_14]
		push	2
		push	9
		mov	[edi+0Ch], eax
		call	_CRYPTO_lock
		mov	esi, [esp+1Ch+arg_0]
		push	dword ptr [esi+4]
		call	_sk_num
		add	esp, 14h
		cmp	eax, [esi+8]
		jg	short loc_8C7

loc_8A6:				; CODE XREF: _def_add_index+A5j
		push	0
		push	dword ptr [esi+4]
		call	_sk_push
		add	esp, 8
		test	eax, eax
		jz	short loc_8F9
		push	dword ptr [esi+4]
		call	_sk_num
		add	esp, 4
		cmp	eax, [esi+8]
		jle	short loc_8A6

loc_8C7:				; CODE XREF: _def_add_index+84j
		mov	ebx, [esi+8]
		push	edi
		push	ebx
		push	dword ptr [esi+4]
		lea	eax, [ebx+1]
		mov	[esi+8], eax
		call	_sk_set
		add	esp, 0Ch

$err$12:				; CODE XREF: _def_add_index+F7j
		push	177h
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	2
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h
		mov	eax, ebx
		pop	esi
		pop	edi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_8F9:				; CODE XREF: _def_add_index+95j
		push	16Fh
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	41h ; 'A'
		push	68h ; 'h'
		push	0Fh
		call	_ERR_put_error
		push	edi
		call	_CRYPTO_free
		add	esp, 18h
		jmp	short $err$12
_def_add_index	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 91Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_def_cleanup_cb	proc near		; DATA XREF: _int_cleanup:loc_5Fo

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		push	offset _def_cleanup_util_cb
		push	dword ptr [esi+4]
		call	_sk_pop_free
		push	esi
		call	_CRYPTO_free
		add	esp, 0Ch
		pop	esi
		retn
_def_cleanup_cb	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 93Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_def_cleanup_util_cb proc near		; DATA XREF: _def_cleanup_cb+5o
		jmp	_CRYPTO_free
_def_cleanup_util_cb endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 944h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_def_get_class	proc near		; CODE XREF: _int_get_new_index+4p
					; _int_new_ex_data+8p ...

var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  4

		mov	eax, 0Ch
		call	__chkstk
		cmp	ds:_ex_data, 0
		jnz	short loc_964
		call	_ex_data_check
		test	eax, eax
		jnz	short loc_964
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_964:				; CODE XREF: _def_get_class+11j
					; _def_get_class+1Aj
		push	ebx
		mov	ebx, [esp+10h+arg_0]
		push	edi
		push	13Eh
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	2
		push	9
		mov	[esp+24h+var_C], ebx
		call	_CRYPTO_lock
		lea	eax, [esp+24h+var_C]
		push	eax
		push	ds:_ex_data
		call	_lh_retrieve
		mov	edi, eax
		add	esp, 18h
		test	edi, edi
		jnz	short loc_9E2
		push	esi
		push	141h
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	0Ch
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jz	short loc_9E1
		mov	[esi], ebx
		mov	[esi+8], edi
		call	_sk_new_null
		mov	[esi+4], eax
		push	esi
		test	eax, eax
		jnz	short loc_9D1
		call	_CRYPTO_free
		add	esp, 4
		jmp	short loc_9E1
; ---------------------------------------------------------------------------

loc_9D1:				; CODE XREF: _def_get_class+81j
		push	ds:_ex_data
		call	_lh_insert
		add	esp, 8
		mov	edi, esi

loc_9E1:				; CODE XREF: _def_get_class+6Fj
					; _def_get_class+8Bj
		pop	esi

loc_9E2:				; CODE XREF: _def_get_class+54j
		push	152h
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	2
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h
		test	edi, edi
		jnz	short loc_A14
		push	154h
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	41h ; 'A'
		push	69h ; 'i'
		push	0Fh
		call	_ERR_put_error
		add	esp, 14h

loc_A14:				; CODE XREF: _def_get_class+B6j
		mov	eax, edi
		pop	edi
		pop	ebx
		add	esp, 0Ch
		retn
_def_get_class	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A1Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ex_class_item_LHASH_COMP proc near	; DATA XREF: _ex_data_check+25o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	eax, [eax]
		sub	eax, [ecx]
		retn
_ex_class_item_LHASH_COMP endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A2Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ex_class_item_LHASH_HASH proc near	; DATA XREF: _ex_data_check+2Ao

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax]
		retn
_ex_class_item_LHASH_HASH endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A34h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ex_class_item_cmp proc	near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	eax, [eax]
		sub	eax, [ecx]
		retn
_ex_class_item_cmp endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A44h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ex_class_item_hash proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax]
		retn
_ex_class_item_hash endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A4Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ex_data_check	proc near		; CODE XREF: _int_cleanup+9p
					; _def_get_class+13p
		push	esi
		push	116h
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	2
		push	9
		mov	esi, 1
		call	_CRYPTO_lock
		add	esp, 10h
		cmp	ds:_ex_data, 0
		jnz	short loc_A8F
		push	offset _ex_class_item_LHASH_COMP
		push	offset _ex_class_item_LHASH_HASH
		call	_lh_new
		xor	ecx, ecx
		mov	ds:_ex_data, eax
		add	esp, 8
		test	eax, eax
		cmovz	esi, ecx

loc_A8F:				; CODE XREF: _ex_data_check+23j
		push	119h
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	2
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h
		mov	eax, esi
		pop	esi
		retn
_ex_data_check	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0AACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_impl_check	proc near
		push	0C9h ; 'É'
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		push	2
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_impl
		mov	ecx, offset _impl_default
		push	0CCh ; 'Ì'
		test	eax, eax
		push	offset ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ ;	".\\crypto\\ex_data.c"
		cmovnz	ecx, eax
		push	2
		push	0Ah
		mov	ds:_impl, ecx
		call	_CRYPTO_lock
		add	esp, 20h
		retn
_impl_check	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0AECh
; COMDAT (pick any)
		public ??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@
; `string'
??_C@_0BD@BACHDDOD@?4?2crypto?2ex_data?4c?$AA@ db '.\crypto\ex_data.c',0
					; DATA XREF: _int_new_class+6o
					; _int_new_class+21o ...
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _sk_num:near	; CODE XREF: _int_new_ex_data+37p
					; _int_new_ex_data+E4p	...
		extrn _sk_value:near	; CODE XREF: _int_new_ex_data+74p
					; _int_new_ex_data+F8p	...
		extrn _sk_set:near	; CODE XREF: _CRYPTO_set_ex_data+63p
					; _def_add_index+B5p
		extrn _sk_new_null:near	; CODE XREF: _CRYPTO_set_ex_data+Ap
					; _def_get_class+76p
		extrn _sk_free:near	; CODE XREF: _int_free_ex_data+138p
		extrn _sk_pop_free:near	; CODE XREF: _def_cleanup_cb+Dp
		extrn _sk_push:near	; CODE XREF: _CRYPTO_set_ex_data+4Bp
					; _def_add_index+8Bp
		extrn _CRYPTO_lock:near	; CODE XREF: _int_new_class+Fp
					; _int_new_class+31p ...
		extrn _CRYPTO_malloc:near ; CODE XREF: _int_new_ex_data+57p
					; _int_dup_ex_data+82p	...
		extrn _CRYPTO_free:near	; CODE XREF: _int_new_ex_data+123p
					; _int_dup_ex_data+167p ...
		extrn _lh_new:near	; CODE XREF: _ex_data_check+2Fp
		extrn _lh_free:near	; CODE XREF: _int_cleanup+28p
		extrn _lh_insert:near	; CODE XREF: _def_get_class+93p
		extrn _lh_retrieve:near	; CODE XREF: _def_get_class+48p
		extrn _lh_doall:near	; CODE XREF: _int_cleanup+1Dp
		extrn _ERR_put_error:near ; CODE XREF: _int_new_ex_data+B2p
					; _int_dup_ex_data+E6p	...
		extrn __chkstk:near	; CODE XREF: _int_dup_ex_data+5p
					; _def_get_class+5p


		end
