;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	B0640C21811EB9B078E7C418F658C4F7
; Input	CRC32 :	F7E1F1E8

; File Name   :	C:\compspace\Diff\openssl\obj\encode.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
_data_bin2ascii	db 41h			; DATA XREF: _EVP_EncodeBlock+42r
					; _EVP_EncodeBlock+53r	...
aBcdefghijklmno	db 'BCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',0
		align 8
_data_ascii2bin	db 0FFh			; DATA XREF: _EVP_DecodeBlock+29r
					; _EVP_DecodeBlock+51r	...
		db 3 dup(0FFh)
		dd 0FFFFFFFFh, 0FFF0E0FFh, 0FFFFF1FFh, 4 dup(0FFFFFFFFh)
		dd 0FFFFFFE0h, 0FFFFFFFFh, 3EFFFFFFh, 3FFFF2FFh, 37363534h
		dd 3B3A3938h, 0FFFF3D3Ch, 0FFFF00FFh, 20100FFh,	6050403h
		dd 0A090807h, 0E0D0C0Bh, 1211100Fh, 16151413h, 0FF191817h
		dd 0FFFFFFFFh, 1C1B1AFFh, 201F1E1Dh, 24232221h,	28272625h
		dd 2C2B2A29h, 302F2E2Dh, 0FF333231h, 0FFFFFFFFh
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_DecodeBlock
_EVP_DecodeBlock proc near		; CODE XREF: _EVP_DecodeFinal+1Fp
					; _EVP_DecodeUpdate+F6p ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 4
		call	__chkstk
		mov	edx, [esp+4+arg_8]
		mov	eax, [esp+4+arg_4]
		push	ebp
		xor	ebp, ebp
		mov	[esp+8+var_4], ebp
		nop	dword ptr [eax+00000000h]

loc_E8:					; CODE XREF: _EVP_DecodeBlock+3Aj
		mov	cl, [eax]
		test	cl, cl
		js	short loc_104
		movzx	ecx, cl
		mov	cl, _data_ascii2bin[ecx]
		cmp	cl, 0E0h ; 'à'
		jnz	short loc_104
		test	edx, edx
		jle	short loc_104
		inc	eax
		dec	edx
		jmp	short loc_E8
; ---------------------------------------------------------------------------

loc_104:				; CODE XREF: _EVP_DecodeBlock+24j
					; _EVP_DecodeBlock+32j	...
		cmp	edx, 3
		jle	short loc_12D

loc_109:				; CODE XREF: _EVP_DecodeBlock+63j
		mov	cl, [eax+edx-1]
		test	cl, cl
		jns	short loc_116
		or	cl, 0FFh
		jmp	short loc_11F
; ---------------------------------------------------------------------------

loc_116:				; CODE XREF: _EVP_DecodeBlock+47j
		movzx	ecx, cl
		mov	cl, _data_ascii2bin[ecx]

loc_11F:				; CODE XREF: _EVP_DecodeBlock+4Cj
		or	cl, 13h
		cmp	cl, 0F3h ; 'ó'
		jnz	short loc_12D
		dec	edx
		cmp	edx, 3
		jg	short loc_109

loc_12D:				; CODE XREF: _EVP_DecodeBlock+3Fj
					; _EVP_DecodeBlock+5Dj
		mov	ecx, edx
		and	ecx, 80000003h
		jns	short loc_13C
		dec	ecx
		or	ecx, 0FFFFFFFCh
		inc	ecx

loc_13C:				; CODE XREF: _EVP_DecodeBlock+6Dj
		jz	short loc_144
		or	eax, 0FFFFFFFFh
		pop	ebp
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_144:				; CODE XREF: _EVP_DecodeBlock:loc_13Cj
		mov	[esp+8+arg_4], ebp
		push	ebx
		push	esi
		push	edi
		test	edx, edx
		jle	loc_214
		mov	esi, [esp+14h+arg_0]
		nop

loc_158:				; CODE XREF: _EVP_DecodeBlock+146j
		mov	cl, [eax]
		test	cl, cl
		jns	short loc_163
		or	cl, 0FFh
		jmp	short loc_16C
; ---------------------------------------------------------------------------

loc_163:				; CODE XREF: _EVP_DecodeBlock+94j
		movzx	ecx, cl
		mov	cl, _data_ascii2bin[ecx]

loc_16C:				; CODE XREF: _EVP_DecodeBlock+99j
		movzx	ebx, cl
		mov	cl, [eax+1]
		test	cl, cl
		jns	short loc_17B
		or	cl, 0FFh
		jmp	short loc_184
; ---------------------------------------------------------------------------

loc_17B:				; CODE XREF: _EVP_DecodeBlock+ACj
		movzx	ecx, cl
		mov	cl, _data_ascii2bin[ecx]

loc_184:				; CODE XREF: _EVP_DecodeBlock+B1j
		movzx	ecx, cl
		mov	[esp+14h+arg_8], ecx
		mov	cl, [eax+2]
		test	cl, cl
		jns	short loc_197
		or	cl, 0FFh
		jmp	short loc_1A0
; ---------------------------------------------------------------------------

loc_197:				; CODE XREF: _EVP_DecodeBlock+C8j
		movzx	ecx, cl
		mov	cl, _data_ascii2bin[ecx]

loc_1A0:				; CODE XREF: _EVP_DecodeBlock+CDj
		movzx	ebp, cl
		mov	cl, [eax+3]
		test	cl, cl
		jns	short loc_1AF
		or	cl, 0FFh
		jmp	short loc_1B8
; ---------------------------------------------------------------------------

loc_1AF:				; CODE XREF: _EVP_DecodeBlock+E0j
		movzx	ecx, cl
		mov	cl, _data_ascii2bin[ecx]

loc_1B8:				; CODE XREF: _EVP_DecodeBlock+E5j
		movzx	edi, cl
		add	eax, 4
		mov	ecx, [esp+14h+arg_8]
		or	ecx, ebx
		test	cl, cl
		js	short loc_21C
		mov	ecx, edi
		or	ecx, ebp
		test	cl, cl
		js	short loc_21C
		shl	ebx, 6
		or	ebx, [esp+14h+arg_8]
		shl	ebx, 6
		or	ebx, ebp
		mov	ebp, [esp+14h+var_4]
		shl	ebx, 6
		add	ebp, 3
		or	ebx, edi
		mov	[esp+14h+var_4], ebp
		mov	ecx, ebx
		shr	ecx, 10h
		mov	[esi], cl
		mov	ecx, ebx
		shr	ecx, 8
		mov	[esi+1], cl
		mov	[esi+2], bl
		add	esi, 3
		mov	ebx, [esp+14h+arg_4]
		add	ebx, 4
		mov	[esp+14h+arg_4], ebx
		cmp	ebx, edx
		jl	loc_158

loc_214:				; CODE XREF: _EVP_DecodeBlock+85j
		pop	edi
		pop	esi
		pop	ebx
		mov	eax, ebp
		pop	ebp
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_21C:				; CODE XREF: _EVP_DecodeBlock+FEj
					; _EVP_DecodeBlock+106j
		pop	edi
		pop	esi
		pop	ebx
		or	eax, 0FFFFFFFFh
		pop	ebp
		pop	ecx
		retn
_EVP_DecodeBlock endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 228h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_DecodeFinal
_EVP_DecodeFinal proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		mov	edi, [esp+8+arg_8]
		mov	dword ptr [edi], 0
		mov	eax, [esi]
		test	eax, eax
		jz	short loc_261
		push	eax
		lea	eax, [esi+8]
		push	eax
		push	[esp+10h+arg_4]
		call	_EVP_DecodeBlock
		add	esp, 0Ch
		test	eax, eax
		jns	short loc_259
		pop	edi
		or	eax, 0FFFFFFFFh
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_259:				; CODE XREF: _EVP_DecodeFinal+29j
		mov	dword ptr [esi], 0
		mov	[edi], eax

loc_261:				; CODE XREF: _EVP_DecodeFinal+14j
		pop	edi
		mov	eax, 1
		pop	esi
		retn
_EVP_DecodeFinal endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 26Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_DecodeInit
_EVP_DecodeInit	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	dword ptr [eax], 0
		mov	dword ptr [eax+4], 0
		mov	dword ptr [eax+58h], 0
		mov	dword ptr [eax+5Ch], 0
		retn
_EVP_DecodeInit	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 28Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_DecodeUpdate
_EVP_DecodeUpdate proc near

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	eax, 8
		call	__chkstk
		mov	eax, [esp+8+arg_0]
		push	ebx
		push	esi
		xor	ebx, ebx
		xor	esi, esi
		mov	edx, [eax]
		add	eax, 8
		mov	[esp+10h+var_8], ebx
		mov	[esp+10h+var_4], eax
		test	edx, edx
		jle	short loc_2CC
		cmp	byte ptr [eax+edx-1], 3Dh ; '='
		jnz	short loc_2CC
		lea	esi, [ebx+1]
		cmp	edx, esi
		jle	short loc_2CC
		cmp	byte ptr [eax+edx-2], 3Dh ; '='
		mov	ecx, 2
		cmovz	esi, ecx

loc_2CC:				; CODE XREF: _EVP_DecodeUpdate+23j
					; _EVP_DecodeUpdate+2Aj ...
		mov	ecx, [esp+10h+arg_10]
		test	ecx, ecx
		jnz	short loc_2EC
		mov	ecx, [esp+10h+arg_8]
		xor	eax, eax
		mov	esi, [esp+10h+var_8]
		mov	[ecx], esi
		mov	ecx, [esp+10h+arg_0]
		pop	esi
		pop	ebx
		mov	[ecx], edx
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_2EC:				; CODE XREF: _EVP_DecodeUpdate+46j
		push	ebp
		mov	ebp, [esp+14h+arg_4]
		push	edi
		xor	edi, edi
		test	ecx, ecx
		jle	loc_3B7

loc_2FC:				; CODE XREF: _EVP_DecodeUpdate+121j
		mov	eax, [esp+18h+arg_C]
		movzx	ebx, byte ptr [eax]
		inc	eax
		mov	[esp+18h+arg_C], eax
		test	bl, bl
		jns	short loc_310
		or	al, 0FFh
		jmp	short loc_318
; ---------------------------------------------------------------------------

loc_310:				; CODE XREF: _EVP_DecodeUpdate+7Ej
		mov	eax, ebx
		mov	al, _data_ascii2bin[eax]

loc_318:				; CODE XREF: _EVP_DecodeUpdate+82j
		movzx	ecx, al
		cmp	ecx, 0FFh
		jz	loc_405
		cmp	ebx, 3Dh ; '='
		jnz	short loc_32F
		inc	esi
		jmp	short loc_343
; ---------------------------------------------------------------------------

loc_32F:				; CODE XREF: _EVP_DecodeUpdate+9Ej
		test	esi, esi
		jle	short loc_343
		mov	eax, ecx
		or	eax, 13h
		cmp	eax, 0F3h ; 'ó'
		jnz	loc_405

loc_343:				; CODE XREF: _EVP_DecodeUpdate+A1j
					; _EVP_DecodeUpdate+A5j
		cmp	esi, 2
		jg	loc_405
		cmp	ecx, 0F2h ; 'ò'
		jz	loc_3F2
		or	ecx, 13h
		cmp	ecx, 0F3h ; 'ó'
		jz	short loc_376
		cmp	edx, 40h ; '@'
		jge	loc_405
		mov	eax, [esp+18h+var_4]
		mov	[eax+edx], bl
		inc	edx
		jmp	short loc_37A
; ---------------------------------------------------------------------------

loc_376:				; CODE XREF: _EVP_DecodeUpdate+D5j
		mov	eax, [esp+18h+var_4]

loc_37A:				; CODE XREF: _EVP_DecodeUpdate+E8j
		cmp	edx, 40h ; '@'
		jnz	short loc_3A4
		push	edx
		push	eax
		push	ebp
		call	_EVP_DecodeBlock
		add	esp, 0Ch
		xor	edx, edx
		test	eax, eax
		js	short loc_405
		cmp	esi, eax
		jg	short loc_405
		mov	ebx, [esp+18h+var_8]
		sub	eax, esi
		add	ebx, eax
		add	ebp, eax
		mov	[esp+18h+var_8], ebx
		jmp	short loc_3A8
; ---------------------------------------------------------------------------

loc_3A4:				; CODE XREF: _EVP_DecodeUpdate+F1j
		mov	ebx, [esp+18h+var_8]

loc_3A8:				; CODE XREF: _EVP_DecodeUpdate+116j
		inc	edi
		cmp	edi, [esp+18h+arg_10]
		jl	loc_2FC
		mov	eax, [esp+18h+var_4]

loc_3B7:				; CODE XREF: _EVP_DecodeUpdate+6Aj
		xor	edi, edi

$tail$52:				; CODE XREF: _EVP_DecodeUpdate+173j
		test	edx, edx
		jle	short loc_3DF
		test	dl, 3
		jnz	short loc_401
		push	edx
		push	eax
		push	ebp
		call	_EVP_DecodeBlock
		add	esp, 0Ch
		xor	edx, edx
		test	eax, eax
		js	short loc_405
		cmp	esi, eax
		jg	short loc_405
		sub	eax, esi
		add	ebx, eax
		mov	[esp+18h+var_8], ebx

loc_3DF:				; CODE XREF: _EVP_DecodeUpdate+12Fj
		test	edi, edi
		jnz	short loc_40A

loc_3E3:				; CODE XREF: _EVP_DecodeUpdate+177j
		test	edx, edx
		jnz	short loc_3EB
		test	esi, esi
		jnz	short loc_40A

loc_3EB:				; CODE XREF: _EVP_DecodeUpdate+159j
		mov	eax, 1
		jmp	short loc_40C
; ---------------------------------------------------------------------------

loc_3F2:				; CODE XREF: _EVP_DecodeUpdate+C6j
		mov	eax, [esp+18h+var_4]
		mov	edi, 1
		mov	ebx, [esp+18h+var_8]
		jmp	short $tail$52
; ---------------------------------------------------------------------------

loc_401:				; CODE XREF: _EVP_DecodeUpdate+134j
		test	edi, edi
		jz	short loc_3E3

loc_405:				; CODE XREF: _EVP_DecodeUpdate+95j
					; _EVP_DecodeUpdate+B1j ...
		or	eax, 0FFFFFFFFh
		jmp	short loc_40C
; ---------------------------------------------------------------------------

loc_40A:				; CODE XREF: _EVP_DecodeUpdate+155j
					; _EVP_DecodeUpdate+15Dj
		xor	eax, eax

loc_40C:				; CODE XREF: _EVP_DecodeUpdate+164j
					; _EVP_DecodeUpdate+17Cj
		pop	edi
		pop	ebp

$end$53:
		mov	ecx, [esp+10h+arg_8]
		mov	esi, [esp+10h+var_8]
		mov	[ecx], esi
		mov	ecx, [esp+10h+arg_0]
		pop	esi
		pop	ebx
		mov	[ecx], edx
		add	esp, 8
		retn
_EVP_DecodeUpdate endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 424h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_EncodeBlock
_EVP_EncodeBlock proc near		; CODE XREF: _EVP_EncodeFinal+16p
					; _EVP_EncodeUpdate+8Ep ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, [esp+arg_0]
		push	ebx
		push	esi
		mov	esi, [esp+8+arg_8]
		xor	ebx, ebx
		test	esi, esi
		jle	loc_510
		push	edi
		mov	edi, [esp+0Ch+arg_4]
		inc	edi
		nop	word ptr [eax+eax+00h]

loc_444:				; CODE XREF: _EVP_EncodeBlock+DDj
		movzx	edx, byte ptr [edi-1]
		cmp	esi, 3
		jl	short loc_4A2
		movzx	ecx, byte ptr [edi]
		shl	edx, 8
		or	edx, ecx
		movzx	ecx, byte ptr [edi+1]
		shl	edx, 8
		or	edx, ecx
		mov	ecx, edx
		shr	ecx, 12h
		and	ecx, 3Fh
		movzx	ecx, _data_bin2ascii[ecx]
		mov	[eax], cl
		mov	ecx, edx
		shr	ecx, 0Ch
		and	ecx, 3Fh
		movzx	ecx, _data_bin2ascii[ecx]
		mov	[eax+1], cl
		mov	ecx, edx
		shr	ecx, 6
		and	ecx, 3Fh
		and	edx, 3Fh
		movzx	ecx, _data_bin2ascii[ecx]
		mov	[eax+2], cl
		movzx	ecx, _data_bin2ascii[edx]
		mov	[eax+3], cl
		jmp	short loc_4F3
; ---------------------------------------------------------------------------

loc_4A2:				; CODE XREF: _EVP_EncodeBlock+27j
		shl	edx, 10h
		cmp	esi, 2
		jnz	short loc_4B2
		movzx	ecx, byte ptr [edi]
		shl	ecx, 8
		or	edx, ecx

loc_4B2:				; CODE XREF: _EVP_EncodeBlock+84j
		mov	ecx, edx
		shr	ecx, 12h
		and	ecx, 3Fh
		movzx	ecx, _data_bin2ascii[ecx]
		mov	[eax], cl
		mov	ecx, edx
		shr	ecx, 0Ch
		and	ecx, 3Fh
		movzx	ecx, _data_bin2ascii[ecx]
		mov	[eax+1], cl
		cmp	esi, 1
		jnz	short loc_4DF
		lea	ecx, [esi+3Ch]
		jmp	short loc_4EC
; ---------------------------------------------------------------------------

loc_4DF:				; CODE XREF: _EVP_EncodeBlock+B4j
		shr	edx, 6
		and	edx, 3Fh
		movzx	ecx, _data_bin2ascii[edx]

loc_4EC:				; CODE XREF: _EVP_EncodeBlock+B9j
		mov	[eax+2], cl
		mov	byte ptr [eax+3], 3Dh ;	'='

loc_4F3:				; CODE XREF: _EVP_EncodeBlock+7Cj
		sub	esi, 3
		add	eax, 4
		add	ebx, 4
		add	edi, 3
		test	esi, esi
		jg	loc_444
		pop	edi
		mov	byte ptr [eax],	0
		mov	eax, ebx
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_510:				; CODE XREF: _EVP_EncodeBlock+Ej
		mov	[eax], bl
		mov	eax, ebx
		pop	esi
		pop	ebx
		retn
_EVP_EncodeBlock endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 518h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_EncodeFinal
_EVP_EncodeFinal proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	edi
		mov	edi, [esp+4+arg_0]
		mov	eax, [edi]
		test	eax, eax
		jz	short loc_54E
		push	esi
		mov	esi, [esp+8+arg_4]
		push	eax
		lea	eax, [edi+8]
		push	eax
		push	esi
		call	_EVP_EncodeBlock
		mov	ecx, [esp+14h+arg_8]
		add	esp, 0Ch
		mov	byte ptr [eax+esi], 0Ah
		inc	eax
		mov	byte ptr [eax+esi], 0
		mov	dword ptr [edi], 0
		pop	esi
		mov	[ecx], eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_54E:				; CODE XREF: _EVP_EncodeFinal+9j
		mov	eax, [esp+4+arg_8]
		pop	edi
		mov	dword ptr [eax], 0
		retn
_EVP_EncodeFinal endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 55Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_EncodeInit
_EVP_EncodeInit	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	dword ptr [eax+4], 30h ; '0'
		mov	dword ptr [eax], 0
		mov	dword ptr [eax+58h], 0
		retn
_EVP_EncodeInit	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 578h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl EVP_EncodeUpdate(int, int, int, void *Src, size_t	Size)
		public _EVP_EncodeUpdate
_EVP_EncodeUpdate proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
Src		= dword	ptr  10h
Size		= dword	ptr  14h

		mov	eax, [esp+arg_8]
		push	ebx
		mov	ebx, [esp+4+Size]
		push	ebp
		xor	ebp, ebp
		mov	[eax], ebp
		test	ebx, ebx
		jle	loc_69F
		push	edi
		mov	edi, [esp+0Ch+arg_0]
		cmp	dword ptr [edi+4], 50h ; 'P'
		jle	short loc_5B0
		push	offset ??_C@_0CK@NJACHFBA@ctx?9?$DOlength?5?$DM?$DN?5?$CIint?$CJsizeof?$CIctx?9?$DO@ ; "ctx->length <= (int)sizeof(ctx->enc_dat"...
		push	0A0h ; ' '
		push	offset ??_C@_0BG@FMGDOINB@?4?2crypto?2evp?2encode?4c?$AA@ ; ".\\crypto\\evp\\encode.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_5B0:				; CODE XREF: _EVP_EncodeUpdate+1Fj
		mov	eax, [edi+4]
		mov	ecx, [edi]
		sub	eax, ecx
		mov	[esp+0Ch+Size],	eax
		cmp	eax, ebx
		jle	short loc_5D8
		push	ebx		; Size
		push	[esp+10h+Src]	; Src
		lea	eax, [edi+8]
		add	eax, ecx
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		add	[edi], ebx
		pop	edi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_5D8:				; CODE XREF: _EVP_EncodeUpdate+45j
		push	esi
		test	ecx, ecx
		jz	short loc_622
		mov	esi, [esp+10h+Src]
		push	eax		; Size
		lea	eax, [edi+8]
		add	eax, ecx
		push	esi		; Src
		push	eax		; Dst
		call	_memcpy
		mov	eax, [esp+1Ch+Size]
		add	esi, eax
		push	dword ptr [edi+4]
		sub	ebx, eax
		mov	[esp+20h+Size],	esi
		mov	esi, [esp+20h+arg_4]
		lea	eax, [edi+8]
		push	eax
		push	esi
		call	_EVP_EncodeBlock
		mov	edx, [esp+28h+Size]
		add	esi, eax
		mov	[edi], ebp
		add	esp, 18h
		lea	ebp, [eax+1]
		mov	byte ptr [esi],	0Ah
		inc	esi
		mov	byte ptr [esi],	0
		jmp	short loc_62E
; ---------------------------------------------------------------------------

loc_622:				; CODE XREF: _EVP_EncodeUpdate+63j
		mov	edx, [esp+10h+Src]
		mov	esi, [esp+10h+arg_4]
		mov	[esp+10h+Size],	edx

loc_62E:				; CODE XREF: _EVP_EncodeUpdate+A8j
		cmp	ebx, [edi+4]
		jl	short loc_66C
		nop	dword ptr [eax+eax+00h]

loc_638:				; CODE XREF: _EVP_EncodeUpdate+F2j
		cmp	ebp, 7FFFFFFFh
		ja	short loc_674
		push	dword ptr [edi+4]
		push	edx
		push	esi
		call	_EVP_EncodeBlock
		mov	edx, [esp+1Ch+Size]
		add	esi, eax
		add	edx, [edi+4]
		inc	ebp
		sub	ebx, [edi+4]
		add	esp, 0Ch
		add	ebp, eax
		mov	[esp+10h+Size],	edx
		mov	byte ptr [esi],	0Ah
		inc	esi
		mov	byte ptr [esi],	0
		cmp	ebx, [edi+4]
		jge	short loc_638

loc_66C:				; CODE XREF: _EVP_EncodeUpdate+B9j
		cmp	ebp, 7FFFFFFFh
		jbe	short loc_683

loc_674:				; CODE XREF: _EVP_EncodeUpdate+C6j
		mov	eax, [esp+10h+arg_8]
		pop	esi
		pop	edi
		pop	ebp
		mov	dword ptr [eax], 0
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_683:				; CODE XREF: _EVP_EncodeUpdate+FAj
		test	ebx, ebx
		jz	short loc_695
		push	ebx		; Size
		push	edx		; Src
		lea	eax, [edi+8]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_695:				; CODE XREF: _EVP_EncodeUpdate+10Dj
		mov	eax, [esp+10h+arg_8]
		mov	[edi], ebx
		pop	esi
		pop	edi
		mov	[eax], ebp

loc_69F:				; CODE XREF: _EVP_EncodeUpdate+10j
		pop	ebp
		pop	ebx
		retn
_EVP_EncodeUpdate endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6A4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_conv_ascii2bin	proc near

arg_0		= byte ptr  4

		mov	al, [esp+arg_0]
		test	al, al
		jns	short loc_6AF
		or	al, 0FFh
		retn
; ---------------------------------------------------------------------------

loc_6AF:				; CODE XREF: _conv_ascii2bin+6j
		movzx	eax, al
		mov	al, _data_ascii2bin[eax]
		retn
_conv_ascii2bin	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6BCh
; COMDAT (pick any)
		public ??_C@_0CK@NJACHFBA@ctx?9?$DOlength?5?$DM?$DN?5?$CIint?$CJsizeof?$CIctx?9?$DO@
; `string'
??_C@_0CK@NJACHFBA@ctx?9?$DOlength?5?$DM?$DN?5?$CIint?$CJsizeof?$CIctx?9?$DO@ db 'ctx->length <= (int)sizeof(ctx->enc_data)',0
					; DATA XREF: _EVP_EncodeUpdate+21o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6E8h
; COMDAT (pick any)
		public ??_C@_0BG@FMGDOINB@?4?2crypto?2evp?2encode?4c?$AA@
; `string'
??_C@_0BG@FMGDOINB@?4?2crypto?2evp?2encode?4c?$AA@ db '.\crypto\evp\encode.c',0
					; DATA XREF: _EVP_EncodeUpdate+2Bo
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _OpenSSLDie:near	; CODE XREF: _EVP_EncodeUpdate+30p
		extrn __chkstk:near	; CODE XREF: _EVP_DecodeBlock+5p
					; _EVP_DecodeUpdate+5p
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _EVP_EncodeUpdate+52p
					; _EVP_EncodeUpdate+71p ...


		end
