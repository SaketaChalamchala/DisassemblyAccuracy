;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	800D228CA441A54982FD8BD332FA1D2B
; Input	CRC32 :	1D2B36B2

; File Name   :	C:\compspace\Diff\openssl\obj\e_atalla.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data		segment	para public 'DATA' use32
		assume cs:_data
_ATALLA_str_functs dd 64000h		; DATA XREF: _ERR_load_ATALLA_strings+1Co
					; _ERR_unload_ATALLA_strings+9o ...
		dd offset ??_C@_0M@KHALKDNC@ATALLA_CTRL?$AA@ ; "ATALLA_CTRL"
		dd 65000h
		dd offset ??_C@_0O@NFDFBDHD@ATALLA_FINISH?$AA@ ; "ATALLA_FINISH"
		dd 66000h
		dd offset ??_C@_0M@EAHHNIEA@ATALLA_INIT?$AA@ ; "ATALLA_INIT"
		dd 67000h
		dd offset ??_C@_0P@GKLHILNK@ATALLA_MOD_EXP?$AA@	; "ATALLA_MOD_EXP"
		dd 68000h
		dd offset ??_C@_0BD@LJGFNJFB@ATALLA_RSA_MOD_EXP?$AA@ ; "ATALLA_RSA_MOD_EXP"
		align 10h
_ATALLA_str_reasons dd offset off_64	; DATA XREF: _ERR_load_ATALLA_strings+31o
					; _ERR_unload_ATALLA_strings+19o ...
		dd offset ??_C@_0P@BJJHFGDF@already?5loaded?$AA@ ; "already loaded"
		dd offset off_64+1
		dd offset ??_C@_0M@FKHFAIDE@bn?5ctx?5full?$AA@ ; "bn ctx full"
		dd offset off_64+2
		dd offset ??_C@_0P@NJHPDICB@bn?5expand?5fail?$AA@ ; "bn	expand fail"
		dd offset off_64+3
		dd offset ??_C@_0BN@NJGGMLOG@ctrl?5command?5not?5implemented?$AA@ ; "ctrl command not implemented"
		dd offset off_68
		dd offset ??_C@_0BH@KAGGBJK@missing?5key?5components?$AA@ ; "missing key components"
		dd offset off_68+1
		dd offset ??_C@_0L@ICAFOIA@not?5loaded?$AA@ ; "not loaded"
		dd offset off_68+2
off_64		dd offset ??_C@_0P@LMFGIOCF@request?5failed?$AA@
					; DATA XREF: .data:_ATALLA_str_reasonso
					; .data:00000038o ...
					; "request failed"
off_68		dd offset off_68+3	; DATA XREF: .data:00000050o
					; .data:00000058o ...
		dd offset ??_C@_0N@JLJLJPMB@unit?5failure?$AA@ ; "unit failure"
		dd 2 dup(0)
_ATALLA_lib_name dd 0			; DATA XREF: _ERR_load_ATALLA_strings+4Bo
					; _ERR_load_ATALLA_strings+52w	...
		dd offset ??_C@_0O@JNIKONG@atalla?5engine?$AA@ ; "atalla engine"
		dd 2 dup(0)
_ATALLA_error_init dd 1			; DATA XREF: _ERR_load_ATALLA_strings:loc_4FBr
					; _ERR_load_ATALLA_strings+22w	...
_atalla_rsa	dd offset ??_C@_0BC@GHPFANJE@Atalla?5RSA?5method?$AA@
					; DATA XREF: _bind_helper+33o
					; "Atalla RSA method"
dword_90	dd 0			; DATA XREF: _bind_helper+E3w
dword_94	dd 0			; DATA XREF: _bind_helper+ECw
dword_98	dd 0			; DATA XREF: _bind_helper+F5w
dword_9C	dd 0			; DATA XREF: _bind_helper+FEw
		dd offset _atalla_rsa_mod_exp
		dd offset _atalla_mod_exp_mont
		dd 7 dup(0)
_atalla_dsa	dd offset ??_C@_0BC@CBLGADBM@Atalla?5DSA?5method?$AA@
					; DATA XREF: _bind_helper+49o
					; "Atalla DSA method"
dword_C8	dd 0			; DATA XREF: .rdata:_atalla_cmd_defnso
					; _bind_helper+10Bw
dword_CC	dd 0			; DATA XREF: _bind_helper+114w
dword_D0	dd 0			; DATA XREF: _bind_helper+11Dw
		dd offset _atalla_dsa_mod_exp
		dd offset _atalla_mod_exp_dsa
		dd 6 dup(0)
_atalla_dh	dd offset ??_C@_0BB@BCIHHPHD@Atalla?5DH?5method?$AA@
					; DATA XREF: _bind_helper+5Fo
					; "Atalla DH method"
dword_F8	dd 0			; DATA XREF: _bind_helper+12Aw
dword_FC	dd 0			; DATA XREF: _bind_helper+133w
		dd offset _atalla_mod_exp_dh
		dd 5 dup(0)
_engine_atalla_id dd offset ??_C@_06DHGIFGOD@atalla?$AA@ ; DATA	XREF: _bind_engine+75r
					; _bind_fn+8r ...
					; "atalla"
_engine_atalla_name dd offset ??_C@_0BP@GHPMLIGA@Atalla?5hardware?5engine?5support?$AA@
					; DATA XREF: _bind_helper+1Cr
					; "Atalla hardware engine support"
_ATALLA_F1	dd offset ??_C@_0BG@NKAPHCAI@ASI_GetHardwareConfig?$AA@
					; DATA XREF: _atalla_init:loc_7EBr
					; "ASI_GetHardwareConfig"
_ATALLA_F2	dd offset ??_C@_0BG@JGHPKJFD@ASI_RSAPrivateKeyOpFn?$AA@
					; DATA XREF: _atalla_init+A4r
					; "ASI_RSAPrivateKeyOpFn"
_ATALLA_F3	dd offset ??_C@_0BN@IBHBIHKD@ASI_GetPerformanceStatistics?$AA@
					; DATA XREF: _atalla_init+BEr
_data		ends			; "ASI_GetPerformanceStatistics"

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 12Ch
; COMDAT (pick any)
		public ??_C@_0M@KHALKDNC@ATALLA_CTRL?$AA@
; `string'
??_C@_0M@KHALKDNC@ATALLA_CTRL?$AA@ db 'ATALLA_CTRL',0 ; DATA XREF: .data:00000004o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 138h
; COMDAT (pick any)
		public ??_C@_0O@NFDFBDHD@ATALLA_FINISH?$AA@
; `string'
??_C@_0O@NFDFBDHD@ATALLA_FINISH?$AA@ db	'ATALLA_FINISH',0 ; DATA XREF: .data:0000000Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 148h
; COMDAT (pick any)
		public ??_C@_0M@EAHHNIEA@ATALLA_INIT?$AA@
; `string'
??_C@_0M@EAHHNIEA@ATALLA_INIT?$AA@ db 'ATALLA_INIT',0 ; DATA XREF: .data:00000014o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 154h
; COMDAT (pick any)
		public ??_C@_0P@GKLHILNK@ATALLA_MOD_EXP?$AA@
; `string'
??_C@_0P@GKLHILNK@ATALLA_MOD_EXP?$AA@ db 'ATALLA_MOD_EXP',0 ; DATA XREF: .data:0000001Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 164h
; COMDAT (pick any)
		public ??_C@_0BD@LJGFNJFB@ATALLA_RSA_MOD_EXP?$AA@
; `string'
??_C@_0BD@LJGFNJFB@ATALLA_RSA_MOD_EXP?$AA@ db 'ATALLA_RSA_MOD_EXP',0
					; DATA XREF: .data:00000024o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 178h
; COMDAT (pick any)
		public ??_C@_0P@BJJHFGDF@already?5loaded?$AA@
; `string'
??_C@_0P@BJJHFGDF@already?5loaded?$AA@ db 'already loaded',0 ; DATA XREF: .data:00000034o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 188h
; COMDAT (pick any)
		public ??_C@_0M@FKHFAIDE@bn?5ctx?5full?$AA@
; `string'
??_C@_0M@FKHFAIDE@bn?5ctx?5full?$AA@ db	'bn ctx full',0 ; DATA XREF: .data:0000003Co
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 194h
; COMDAT (pick any)
		public ??_C@_0P@NJHPDICB@bn?5expand?5fail?$AA@
; `string'
??_C@_0P@NJHPDICB@bn?5expand?5fail?$AA@	db 'bn expand fail',0 ; DATA XREF: .data:00000044o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1A4h
; COMDAT (pick any)
		public ??_C@_0BN@NJGGMLOG@ctrl?5command?5not?5implemented?$AA@
; `string'
??_C@_0BN@NJGGMLOG@ctrl?5command?5not?5implemented?$AA@	db 'ctrl command not implemented',0
					; DATA XREF: .data:0000004Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1C4h
; COMDAT (pick any)
		public ??_C@_0BH@KAGGBJK@missing?5key?5components?$AA@
; `string'
??_C@_0BH@KAGGBJK@missing?5key?5components?$AA@	db 'missing key components',0
					; DATA XREF: .data:00000054o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1DCh
; COMDAT (pick any)
		public ??_C@_0L@ICAFOIA@not?5loaded?$AA@
; `string'
??_C@_0L@ICAFOIA@not?5loaded?$AA@ db 'not loaded',0 ; DATA XREF: .data:0000005Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1E8h
; COMDAT (pick any)
		public ??_C@_0P@LMFGIOCF@request?5failed?$AA@
; `string'
??_C@_0P@LMFGIOCF@request?5failed?$AA@ db 'request failed',0 ; DATA XREF: .data:off_64o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1F8h
; COMDAT (pick any)
		public ??_C@_0N@JLJLJPMB@unit?5failure?$AA@
; `string'
??_C@_0N@JLJLJPMB@unit?5failure?$AA@ db	'unit failure',0 ; DATA XREF: .data:0000006Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 208h
; COMDAT (pick any)
		public ??_C@_0O@JNIKONG@atalla?5engine?$AA@
; `string'
??_C@_0O@JNIKONG@atalla?5engine?$AA@ db	'atalla engine',0 ; DATA XREF: .data:0000007Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 218h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
_ATALLA_lib_error_code dd ?		; DATA XREF: _atalla_rsa_mod_exp+9r
					; _atalla_rsa_mod_exp+17w ...
_atalla_dso	dd ?			; DATA XREF: _atalla_rsa_mod_expr
					; _atalla_ctrl+2r ...
_p_Atalla_GetHardwareConfig dd ?	; DATA XREF: _atalla_finish+9Bw
					; _atalla_init+E2w ...
_p_Atalla_RSAPrivateKeyOpFn dd ?	; DATA XREF: _atalla_finish+A5w
					; _atalla_init+E8w ...
_p_Atalla_GetPerformanceStatistics dd ?	; DATA XREF: _atalla_finish+AFw
					; _atalla_init+D6w ...
_ATALLA_LIBNAME	dd ?			; DATA XREF: _atalla_destroyr
					; _atalla_destroy+19w ...
_bss		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 230h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_atalla_rsa_mod_exp proc near		; DATA XREF: .data:000000A0o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		cmp	ds:_atalla_dso,	0
		jnz	short loc_266
		mov	eax, ds:_ATALLA_lib_error_code
		test	eax, eax
		jnz	short loc_24C
		call	_ERR_get_next_error_library
		mov	ds:_ATALLA_lib_error_code, eax

loc_24C:				; CODE XREF: _atalla_rsa_mod_exp+10j
		push	215h
		push	offset ??_C@_0BF@ICBHMHHE@?4?2engines?2e_atalla?4c?$AA@	; ".\\engines\\e_atalla.c"
		push	69h ; 'i'
		push	68h ; 'h'
		push	eax
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_266:				; CODE XREF: _atalla_rsa_mod_exp+7j
		mov	eax, [esp+arg_8]
		mov	ecx, [eax+18h]
		test	ecx, ecx
		jz	short loc_28F
		mov	eax, [eax+10h]
		test	eax, eax
		jz	short loc_28F
		push	[esp+arg_C]
		push	eax
		push	ecx
		push	[esp+0Ch+arg_4]
		push	[esp+10h+arg_0]
		call	_atalla_mod_exp
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_28F:				; CODE XREF: _atalla_rsa_mod_exp+3Fj
					; _atalla_rsa_mod_exp+46j
		mov	eax, ds:_ATALLA_lib_error_code
		test	eax, eax
		jnz	short loc_2A2
		call	_ERR_get_next_error_library
		mov	ds:_ATALLA_lib_error_code, eax

loc_2A2:				; CODE XREF: _atalla_rsa_mod_exp+66j
		push	21Ah
		push	offset ??_C@_0BF@ICBHMHHE@?4?2engines?2e_atalla?4c?$AA@	; ".\\engines\\e_atalla.c"
		push	68h ; 'h'
		push	68h ; 'h'
		push	eax
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax

$err$14:
		retn
_atalla_rsa_mod_exp endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2BCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_atalla_mod_exp_mont proc near		; DATA XREF: .data:000000A4o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		push	[esp+arg_10]
		push	[esp+4+arg_C]
		push	[esp+8+arg_8]
		push	[esp+0Ch+arg_4]
		push	[esp+10h+arg_0]
		call	_atalla_mod_exp
		add	esp, 14h
		retn
_atalla_mod_exp_mont endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2DCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_atalla_dsa_mod_exp proc near		; DATA XREF: .data:000000D4o

var_14		= byte ptr -14h
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h
arg_18		= dword	ptr  1Ch
arg_1C		= dword	ptr  20h

		mov	eax, 14h
		call	__chkstk
		push	ebx
		push	ebp
		push	esi
		lea	eax, [esp+20h+var_14]
		xor	esi, esi
		push	edi
		push	eax
		call	_BN_init
		mov	edi, [esp+28h+arg_1C]
		mov	ebx, [esp+28h+arg_18]
		mov	ebp, [esp+28h+arg_4]
		push	edi
		push	ebx
		push	[esp+30h+arg_C]
		push	[esp+34h+arg_8]
		push	ebp
		call	_atalla_mod_exp
		add	esp, 18h
		test	eax, eax
		jz	short $end$7
		push	edi
		push	ebx
		push	[esp+2Ch+arg_14]
		lea	eax, [esp+30h+var_14]
		push	[esp+30h+arg_10]
		push	eax
		call	_atalla_mod_exp
		add	esp, 14h
		test	eax, eax
		jz	short $end$7
		push	edi
		push	ebx
		lea	eax, [esp+2Ch+var_14]
		push	eax
		push	ebp
		push	ebp
		call	_BN_mod_mul
		add	esp, 14h
		mov	ecx, 1
		test	eax, eax
		cmovnz	esi, ecx

$end$7:					; CODE XREF: _atalla_dsa_mod_exp+3Bj
					; _atalla_dsa_mod_exp+56j
		lea	eax, [esp+24h+var_14]
		push	eax
		call	_BN_free
		add	esp, 4
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 14h
		retn
_atalla_dsa_mod_exp endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 368h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_atalla_mod_exp_dsa proc near		; DATA XREF: .data:000000D8o

arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		push	[esp+arg_14]
		push	[esp+4+arg_10]
		push	[esp+8+arg_C]
		push	[esp+0Ch+arg_8]
		push	[esp+10h+arg_4]
		call	_atalla_mod_exp
		add	esp, 14h
		retn
_atalla_mod_exp_dsa endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 388h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_atalla_mod_exp_dh proc	near		; DATA XREF: .data:00000100o

arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		push	[esp+arg_14]
		push	[esp+4+arg_10]
		push	[esp+8+arg_C]
		push	[esp+0Ch+arg_8]
		push	[esp+10h+arg_4]
		call	_atalla_mod_exp
		add	esp, 14h
		retn
_atalla_mod_exp_dh endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3A8h
_atalla_cmd_defns dd offset dword_C8	; DATA XREF: _bind_helper+C9o
		dd offset ??_C@_07EGEBNIPD@SO_PATH?$AA@	; "SO_PATH"
		dd offset ??_C@_0DB@KLIAEKBI@Specifies?5the?5path?5to?5the?5?8atasi@ ; "Specifies the path to the 'atasi' share"...
		dd 2, 4	dup(0)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3C8h
; COMDAT (pick any)
		public ??_C@_07EGEBNIPD@SO_PATH?$AA@
; `string'
??_C@_07EGEBNIPD@SO_PATH?$AA@ db 'SO_PATH',0 ; DATA XREF: .rdata:000003ACo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3D0h
; COMDAT (pick any)
		public ??_C@_0DB@KLIAEKBI@Specifies?5the?5path?5to?5the?5?8atasi@
; `string'
??_C@_0DB@KLIAEKBI@Specifies?5the?5path?5to?5the?5?8atasi@ db 'Specifies the path to the ',27h,'atasi',27h,' shared library',0
					; DATA XREF: .rdata:000003B0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 404h
; COMDAT (pick any)
		public ??_C@_0BC@GHPFANJE@Atalla?5RSA?5method?$AA@
; `string'
??_C@_0BC@GHPFANJE@Atalla?5RSA?5method?$AA@ db 'Atalla RSA method',0
					; DATA XREF: .data:_atalla_rsao
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 418h
; COMDAT (pick any)
		public ??_C@_0BC@CBLGADBM@Atalla?5DSA?5method?$AA@
; `string'
??_C@_0BC@CBLGADBM@Atalla?5DSA?5method?$AA@ db 'Atalla DSA method',0
					; DATA XREF: .data:_atalla_dsao
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 42Ch
; COMDAT (pick any)
		public ??_C@_0BB@BCIHHPHD@Atalla?5DH?5method?$AA@
; `string'
??_C@_0BB@BCIHHPHD@Atalla?5DH?5method?$AA@ db 'Atalla DH method',0
					; DATA XREF: .data:_atalla_dho
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 440h
; COMDAT (pick any)
		public ??_C@_06DHGIFGOD@atalla?$AA@
; `string'
??_C@_06DHGIFGOD@atalla?$AA@ db	'atalla',0 ; DATA XREF: .data:_engine_atalla_ido
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 448h
; COMDAT (pick any)
		public ??_C@_0BP@GHPMLIGA@Atalla?5hardware?5engine?5support?$AA@
; `string'
??_C@_0BP@GHPMLIGA@Atalla?5hardware?5engine?5support?$AA@ db 'Atalla hardware engine support',0
					; DATA XREF: .data:_engine_atalla_nameo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 468h
; COMDAT (pick any)
		public ??_C@_0BG@NKAPHCAI@ASI_GetHardwareConfig?$AA@
; `string'
??_C@_0BG@NKAPHCAI@ASI_GetHardwareConfig?$AA@ db 'ASI_GetHardwareConfig',0
					; DATA XREF: .data:_ATALLA_F1o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 480h
; COMDAT (pick any)
		public ??_C@_0BG@JGHPKJFD@ASI_RSAPrivateKeyOpFn?$AA@
; `string'
??_C@_0BG@JGHPKJFD@ASI_RSAPrivateKeyOpFn?$AA@ db 'ASI_RSAPrivateKeyOpFn',0
					; DATA XREF: .data:_ATALLA_F2o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 498h
; COMDAT (pick any)
		public ??_C@_0BN@IBHBIHKD@ASI_GetPerformanceStatistics?$AA@
; `string'
??_C@_0BN@IBHBIHKD@ASI_GetPerformanceStatistics?$AA@ db	'ASI_GetPerformanceStatistics',0
					; DATA XREF: .data:_ATALLA_F3o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4B8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ERR_ATALLA_error proc near		; CODE XREF: _atalla_init+105p
					; _atalla_mod_exp+264p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, ds:_ATALLA_lib_error_code
		test	eax, eax
		jnz	short loc_4CB
		call	_ERR_get_next_error_library
		mov	ds:_ATALLA_lib_error_code, eax

loc_4CB:				; CODE XREF: _ERR_ATALLA_error+7j
		push	[esp+arg_C]
		push	[esp+4+arg_8]
		push	[esp+8+arg_4]
		push	[esp+0Ch+arg_0]
		push	eax
		call	_ERR_put_error
		add	esp, 14h
		retn
_ERR_ATALLA_error endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4E8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ERR_load_ATALLA_strings proc near	; CODE XREF: _bind_helper+138p
		mov	eax, ds:_ATALLA_lib_error_code
		test	eax, eax
		jnz	short loc_4FB
		call	_ERR_get_next_error_library
		mov	ds:_ATALLA_lib_error_code, eax

loc_4FB:				; CODE XREF: _ERR_load_ATALLA_strings+7j
		cmp	_ATALLA_error_init, 0
		jz	short locret_547
		push	offset _ATALLA_str_functs
		push	eax
		mov	_ATALLA_error_init, 0
		call	_ERR_load_strings
		push	offset _ATALLA_str_reasons
		push	ds:_ATALLA_lib_error_code
		call	_ERR_load_strings
		movzx	eax, byte ptr ds:_ATALLA_lib_error_code
		shl	eax, 18h
		push	offset _ATALLA_lib_name
		push	0
		mov	_ATALLA_lib_name, eax
		call	_ERR_load_strings
		add	esp, 18h

locret_547:				; CODE XREF: _ERR_load_ATALLA_strings+1Aj
		retn
_ERR_load_ATALLA_strings endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 548h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ERR_unload_ATALLA_strings proc	near
		cmp	_ATALLA_error_init, 0
		jnz	short locret_58A
		push	offset _ATALLA_str_functs
		push	ds:_ATALLA_lib_error_code
		call	_ERR_unload_strings
		push	offset _ATALLA_str_reasons
		push	ds:_ATALLA_lib_error_code
		call	_ERR_unload_strings
		push	offset _ATALLA_lib_name
		push	0
		call	_ERR_unload_strings
		add	esp, 18h
		mov	_ATALLA_error_init, 1

locret_58A:				; CODE XREF: _ERR_unload_ATALLA_strings+7j
		retn
_ERR_unload_ATALLA_strings endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 58Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_atalla_ctrl	proc near		; DATA XREF: _bind_helper+B7o

arg_4		= dword	ptr  8
arg_C		= dword	ptr  10h

		xor	eax, eax
		cmp	ds:_atalla_dso,	eax
		setnz	al
		cmp	[esp+arg_4], 0C8h ; 'È'
		jz	short loc_5CE
		mov	eax, ds:_ATALLA_lib_error_code
		test	eax, eax
		jnz	short loc_5B4
		call	_ERR_get_next_error_library
		mov	ds:_ATALLA_lib_error_code, eax

loc_5B4:				; CODE XREF: _atalla_ctrl+1Cj
		push	1C6h
		push	offset ??_C@_0BF@ICBHMHHE@?4?2engines?2e_atalla?4c?$AA@	; ".\\engines\\e_atalla.c"
		push	67h ; 'g'
		push	64h ; 'd'
		push	eax
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_5CE:				; CODE XREF: _atalla_ctrl+13j
		mov	ecx, [esp+arg_C]
		test	ecx, ecx
		jnz	short loc_603
		mov	eax, ds:_ATALLA_lib_error_code
		test	eax, eax
		jnz	short loc_5E9
		call	_ERR_get_next_error_library
		mov	ds:_ATALLA_lib_error_code, eax

loc_5E9:				; CODE XREF: _atalla_ctrl+51j
		push	1BBh
		push	offset ??_C@_0BF@ICBHMHHE@?4?2engines?2e_atalla?4c?$AA@	; ".\\engines\\e_atalla.c"
		push	43h ; 'C'
		push	64h ; 'd'
		push	eax
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_603:				; CODE XREF: _atalla_ctrl+48j
		test	eax, eax
		jz	short loc_634
		mov	eax, ds:_ATALLA_lib_error_code
		test	eax, eax
		jnz	short loc_61A
		call	_ERR_get_next_error_library
		mov	ds:_ATALLA_lib_error_code, eax

loc_61A:				; CODE XREF: _atalla_ctrl+82j
		push	1BFh
		push	offset ??_C@_0BF@ICBHMHHE@?4?2engines?2e_atalla?4c?$AA@	; ".\\engines\\e_atalla.c"
		push	64h ; 'd'
		push	64h ; 'd'
		push	eax
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_634:				; CODE XREF: _atalla_ctrl+79j
		push	ecx
		call	_set_ATALLA_LIBNAME
		add	esp, 4
		retn
_atalla_ctrl	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 640h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_atalla_destroy	proc near		; DATA XREF: _bind_helper+75o
		mov	eax, ds:_ATALLA_LIBNAME
		test	eax, eax
		jz	short loc_652
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_652:				; CODE XREF: _atalla_destroy+7j
		cmp	_ATALLA_error_init, 0
		mov	ds:_ATALLA_LIBNAME, 0
		jnz	short loc_69E
		push	offset _ATALLA_str_functs
		push	ds:_ATALLA_lib_error_code
		call	_ERR_unload_strings
		push	offset _ATALLA_str_reasons
		push	ds:_ATALLA_lib_error_code
		call	_ERR_unload_strings
		push	offset _ATALLA_lib_name
		push	0
		call	_ERR_unload_strings
		add	esp, 18h
		mov	_ATALLA_error_init, 1

loc_69E:				; CODE XREF: _atalla_destroy+23j
		mov	eax, 1
		retn
_atalla_destroy	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6A4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_atalla_finish	proc near		; DATA XREF: _bind_helper+A1o
		mov	eax, ds:_ATALLA_LIBNAME
		test	eax, eax
		jz	short loc_6B6
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_6B6:				; CODE XREF: _atalla_finish+7j
		mov	eax, ds:_atalla_dso
		mov	ds:_ATALLA_LIBNAME, 0
		test	eax, eax
		jnz	short loc_6F6
		mov	eax, ds:_ATALLA_lib_error_code
		test	eax, eax
		jnz	short loc_6DC
		call	_ERR_get_next_error_library
		mov	ds:_ATALLA_lib_error_code, eax

loc_6DC:				; CODE XREF: _atalla_finish+2Cj
		push	1A7h
		push	offset ??_C@_0BF@ICBHMHHE@?4?2engines?2e_atalla?4c?$AA@	; ".\\engines\\e_atalla.c"
		push	69h ; 'i'
		push	65h ; 'e'
		push	eax
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_6F6:				; CODE XREF: _atalla_finish+23j
		push	eax
		call	_DSO_free
		add	esp, 4
		test	eax, eax
		jnz	short loc_730
		mov	eax, ds:_ATALLA_lib_error_code
		test	eax, eax
		jnz	short loc_716
		call	_ERR_get_next_error_library
		mov	ds:_ATALLA_lib_error_code, eax

loc_716:				; CODE XREF: _atalla_finish+66j
		push	1ABh
		push	offset ??_C@_0BF@ICBHMHHE@?4?2engines?2e_atalla?4c?$AA@	; ".\\engines\\e_atalla.c"
		push	6Bh ; 'k'
		push	65h ; 'e'
		push	eax
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_730:				; CODE XREF: _atalla_finish+5Dj
		mov	ds:_atalla_dso,	0
		mov	eax, 1
		mov	ds:_p_Atalla_GetHardwareConfig,	0
		mov	ds:_p_Atalla_RSAPrivateKeyOpFn,	0
		mov	ds:_p_Atalla_GetPerformanceStatistics, 0
		retn
_atalla_finish	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 760h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_atalla_init	proc near		; DATA XREF: _bind_helper+8Bo

var_1004	= byte ptr -1004h
var_4		= dword	ptr -4

		mov	eax, 1004h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+1004h+var_4], eax
		cmp	ds:_atalla_dso,	0
		push	esi
		push	edi
		jz	short loc_7A7
		mov	eax, ds:_ATALLA_lib_error_code
		test	eax, eax
		jnz	short loc_796
		call	_ERR_get_next_error_library
		mov	ds:_ATALLA_lib_error_code, eax

loc_796:				; CODE XREF: _atalla_init+2Aj
		push	170h
		push	offset ??_C@_0BF@ICBHMHHE@?4?2engines?2e_atalla?4c?$AA@	; ".\\engines\\e_atalla.c"
		push	64h ; 'd'
		jmp	loc_8AA
; ---------------------------------------------------------------------------

loc_7A7:				; CODE XREF: _atalla_init+21j
		mov	eax, ds:_ATALLA_LIBNAME
		mov	ecx, offset ??_C@_05OANFFCCN@atasi?$AA@	; "atasi"
		test	eax, eax
		push	0
		cmovnz	ecx, eax
		push	0
		push	ecx
		push	0
		call	_DSO_load
		add	esp, 10h
		mov	ds:_atalla_dso,	eax
		test	eax, eax
		jnz	short loc_7EB
		mov	eax, ds:_ATALLA_lib_error_code
		test	eax, eax
		jnz	short loc_7E1
		call	_ERR_get_next_error_library
		mov	ds:_ATALLA_lib_error_code, eax

loc_7E1:				; CODE XREF: _atalla_init+75j
		push	17Fh
		jmp	loc_8A3
; ---------------------------------------------------------------------------

loc_7EB:				; CODE XREF: _atalla_init+6Cj
		push	_ATALLA_F1
		push	eax
		call	_DSO_bind_func
		mov	esi, eax
		add	esp, 8
		test	esi, esi
		jz	loc_88B
		push	_ATALLA_F2
		push	ds:_atalla_dso
		call	_DSO_bind_func
		mov	edi, eax
		add	esp, 8
		test	edi, edi
		jz	short loc_88B
		push	_ATALLA_F3
		push	ds:_atalla_dso
		call	_DSO_bind_func
		add	esp, 8
		test	eax, eax
		jz	short loc_88B
		mov	ds:_p_Atalla_GetPerformanceStatistics, eax
		lea	eax, [esp+100Ch+var_1004]
		push	eax
		push	0
		mov	ds:_p_Atalla_GetHardwareConfig,	esi
		mov	ds:_p_Atalla_RSAPrivateKeyOpFn,	edi
		call	esi
		add	esp, 8
		test	eax, eax
		jz	short loc_86F
		push	194h
		push	offset ??_C@_0BF@ICBHMHHE@?4?2engines?2e_atalla?4c?$AA@	; ".\\engines\\e_atalla.c"
		push	6Bh ; 'k'
		push	66h ; 'f'
		call	_ERR_ATALLA_error
		add	esp, 10h
		jmp	short $err$24
; ---------------------------------------------------------------------------

loc_86F:				; CODE XREF: _atalla_init+F5j
		pop	edi
		mov	eax, 1
		pop	esi
		mov	ecx, [esp+1004h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1004h
		retn
; ---------------------------------------------------------------------------

loc_88B:				; CODE XREF: _atalla_init+9Ej
					; _atalla_init+BCj ...
		mov	eax, ds:_ATALLA_lib_error_code
		test	eax, eax
		jnz	short loc_89E
		call	_ERR_get_next_error_library
		mov	ds:_ATALLA_lib_error_code, eax

loc_89E:				; CODE XREF: _atalla_init+132j
		push	189h

loc_8A3:				; CODE XREF: _atalla_init+86j
		push	offset ??_C@_0BF@ICBHMHHE@?4?2engines?2e_atalla?4c?$AA@	; ".\\engines\\e_atalla.c"
		push	69h ; 'i'

loc_8AA:				; CODE XREF: _atalla_init+42j
		push	66h ; 'f'
		push	eax
		call	_ERR_put_error
		add	esp, 14h

$err$24:				; CODE XREF: _atalla_init+10Dj
		mov	eax, ds:_atalla_dso
		test	eax, eax
		jz	short loc_8C7
		push	eax
		call	_DSO_free
		add	esp, 4

loc_8C7:				; CODE XREF: _atalla_init+15Cj
		mov	ecx, [esp+100Ch+var_4]
		xor	eax, eax
		pop	edi
		pop	esi
		xor	ecx, esp
		mov	ds:_atalla_dso,	0
		mov	ds:_p_Atalla_GetHardwareConfig,	0
		mov	ds:_p_Atalla_RSAPrivateKeyOpFn,	0
		mov	ds:_p_Atalla_GetPerformanceStatistics, 0
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1004h
		retn
_atalla_init	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 908h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_atalla_mod_exp	proc near		; CODE XREF: _atalla_rsa_mod_exp+56p
					; _atalla_mod_exp_mont+14p ...

Size		= dword	ptr -6Ch
var_68		= dword	ptr -68h
var_64		= dword	ptr -64h
var_60		= dword	ptr -60h
var_5C		= dword	ptr -5Ch
var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
Dst		= byte ptr -50h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	eax, 6Ch ; 'l'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+6Ch+var_4], eax
		cmp	ds:_atalla_dso,	0
		mov	eax, [esp+6Ch+arg_0]
		mov	[esp+6Ch+var_54], eax
		mov	eax, [esp+6Ch+arg_4]
		push	ebx
		mov	ebx, [esp+70h+arg_C]
		mov	[esp+70h+var_5C], eax
		mov	eax, [esp+70h+arg_8]
		push	esi
		mov	esi, [esp+74h+arg_10]
		mov	[esp+74h+var_64], eax
		mov	[esp+74h+var_58], 0
		jnz	short loc_985
		mov	eax, ds:_ATALLA_lib_error_code
		test	eax, eax
		jnz	short loc_969
		call	_ERR_get_next_error_library
		mov	ds:_ATALLA_lib_error_code, eax

loc_969:				; CODE XREF: _atalla_mod_exp+55j
		push	1DEh
		push	offset ??_C@_0BF@ICBHMHHE@?4?2engines?2e_atalla?4c?$AA@	; ".\\engines\\e_atalla.c"
		push	69h ; 'i'
		push	67h ; 'g'
		push	eax
		call	_ERR_put_error
		add	esp, 14h
		jmp	$err$29
; ---------------------------------------------------------------------------

loc_985:				; CODE XREF: _atalla_mod_exp+4Cj
		push	ebp
		push	edi
		push	esi
		call	_BN_CTX_start
		push	esi
		call	_BN_CTX_get
		push	esi
		mov	ebp, eax
		call	_BN_CTX_get
		push	esi
		mov	[esp+8Ch+var_68], eax
		call	_BN_CTX_get
		push	esi
		mov	[esp+90h+var_60], eax
		call	_BN_CTX_get
		mov	edi, eax
		add	esp, 14h
		test	edi, edi
		jnz	short loc_9DC
		mov	eax, ds:_ATALLA_lib_error_code
		test	eax, eax
		jnz	short loc_9CB
		call	_ERR_get_next_error_library
		mov	ds:_ATALLA_lib_error_code, eax

loc_9CB:				; CODE XREF: _atalla_mod_exp+B7j
		push	1E8h
		push	offset ??_C@_0BF@ICBHMHHE@?4?2engines?2e_atalla?4c?$AA@	; ".\\engines\\e_atalla.c"
		push	65h ; 'e'
		jmp	loc_BAE
; ---------------------------------------------------------------------------

loc_9DC:				; CODE XREF: _atalla_mod_exp+AEj
		mov	eax, [ebx+4]
		cmp	eax, [ebp+8]
		jg	short loc_9E8
		mov	eax, ebp
		jmp	short loc_9F2
; ---------------------------------------------------------------------------

loc_9E8:				; CODE XREF: _atalla_mod_exp+DAj
		push	eax
		push	ebp
		call	_bn_expand2
		add	esp, 8

loc_9F2:				; CODE XREF: _atalla_mod_exp+DEj
		test	eax, eax
		jz	loc_B8F
		mov	eax, [esp+7Ch+var_68]
		mov	ecx, [ebx+4]
		cmp	ecx, [eax+8]
		jle	short loc_A10
		push	ecx
		push	eax
		call	_bn_expand2
		add	esp, 8

loc_A10:				; CODE XREF: _atalla_mod_exp+FCj
		test	eax, eax
		jz	loc_B8F
		mov	eax, [esp+7Ch+var_60]
		mov	ecx, [ebx+4]
		cmp	ecx, [eax+8]
		jle	short loc_A2E
		push	ecx
		push	eax
		call	_bn_expand2
		add	esp, 8

loc_A2E:				; CODE XREF: _atalla_mod_exp+11Aj
		test	eax, eax
		jz	loc_B8F
		mov	eax, [ebx+4]
		cmp	eax, [edi+8]
		jg	short loc_A42
		mov	eax, edi
		jmp	short loc_A4C
; ---------------------------------------------------------------------------

loc_A42:				; CODE XREF: _atalla_mod_exp+134j
		push	eax
		push	edi
		call	_bn_expand2
		add	esp, 8

loc_A4C:				; CODE XREF: _atalla_mod_exp+138j
		test	eax, eax
		jz	loc_B8F
		push	4Ch ; 'L'       ; Size
		lea	eax, [esp+80h+Dst]
		push	0		; Val
		push	eax		; Dst
		call	_memset
		push	ebx
		call	_BN_num_bits
		add	eax, 7
		cdq
		and	edx, 7
		add	eax, edx
		sar	eax, 3
		push	eax		; Size
		mov	[esp+90h+Size],	eax
		mov	eax, [esp+90h+var_68]
		push	0		; Val
		push	dword ptr [eax]	; Dst
		call	_memset
		push	[esp+98h+Size]	; Size
		push	0		; Val
		push	dword ptr [ebp+0] ; Dst
		call	_memset
		push	[esp+0A4h+var_64]
		call	_BN_num_bits
		mov	ecx, [esp+0A8h+Size]
		add	eax, 7
		cdq
		and	edx, 7
		add	eax, edx
		sar	eax, 3
		sub	ecx, eax
		mov	eax, [esp+0A8h+var_68]
		mov	eax, [eax]
		add	eax, ecx
		push	eax
		push	[esp+0ACh+var_64]
		call	_BN_bn2bin
		push	ebx
		call	_BN_num_bits
		mov	ecx, [ebp+0]
		add	eax, 7
		cdq
		and	edx, 7
		add	eax, edx
		sar	eax, 3
		sub	ecx, eax
		add	ecx, [esp+0B4h+Size]
		push	ecx
		push	ebx
		call	_BN_bn2bin
		mov	eax, [esp+0BCh+var_68]
		add	esp, 40h
		mov	ebx, [esp+7Ch+var_60]
		mov	eax, [eax]
		mov	[esp+7Ch+var_34], eax
		mov	eax, [esp+7Ch+Size]
		mov	[esp+7Ch+var_30], eax
		mov	eax, [ebp+0]
		mov	ebp, [esp+7Ch+Size]
		push	ebp		; Size
		mov	[esp+80h+var_44], eax
		mov	[esp+80h+var_40], ebp
		push	0		; Val
		push	dword ptr [ebx]	; Dst
		call	_memset
		push	ebp		; Size
		push	0		; Val
		push	dword ptr [edi]	; Dst
		call	_memset
		push	[esp+94h+var_5C]
		call	_BN_num_bits
		mov	ecx, [ebx]
		add	eax, 7
		cdq
		and	edx, 7
		add	eax, edx
		sar	eax, 3
		sub	ecx, eax
		add	ecx, ebp
		push	ecx
		push	[esp+9Ch+var_5C]
		call	_BN_bn2bin
		push	[esp+0A0h+var_40]
		lea	eax, [esp+0A4h+Dst]
		push	dword ptr [ebx]
		push	dword ptr [edi]
		push	eax
		call	ds:_p_Atalla_RSAPrivateKeyOpFn
		add	esp, 34h
		test	eax, eax
		jz	short loc_B76
		push	203h
		push	offset ??_C@_0BF@ICBHMHHE@?4?2engines?2e_atalla?4c?$AA@	; ".\\engines\\e_atalla.c"
		push	6Ah ; 'j'
		push	67h ; 'g'
		call	_ERR_ATALLA_error
		add	esp, 10h
		jmp	short loc_BB9
; ---------------------------------------------------------------------------

loc_B76:				; CODE XREF: _atalla_mod_exp+254j
		push	[esp+7Ch+var_54]
		push	ebp
		push	dword ptr [edi]
		call	_BN_bin2bn
		add	esp, 0Ch
		mov	[esp+7Ch+var_58], 1
		jmp	short loc_BB9
; ---------------------------------------------------------------------------

loc_B8F:				; CODE XREF: _atalla_mod_exp+ECj
					; _atalla_mod_exp+10Aj	...
		mov	eax, ds:_ATALLA_lib_error_code
		test	eax, eax
		jnz	short loc_BA2
		call	_ERR_get_next_error_library
		mov	ds:_ATALLA_lib_error_code, eax

loc_BA2:				; CODE XREF: _atalla_mod_exp+28Ej
		push	1EDh
		push	offset ??_C@_0BF@ICBHMHHE@?4?2engines?2e_atalla?4c?$AA@	; ".\\engines\\e_atalla.c"
		push	66h ; 'f'

loc_BAE:				; CODE XREF: _atalla_mod_exp+CFj
		push	67h ; 'g'
		push	eax
		call	_ERR_put_error
		add	esp, 14h

loc_BB9:				; CODE XREF: _atalla_mod_exp+26Cj
					; _atalla_mod_exp+285j
		pop	edi
		pop	ebp

$err$29:				; CODE XREF: _atalla_mod_exp+78j
		push	esi
		call	_BN_CTX_end
		mov	ecx, [esp+78h+var_4]
		add	esp, 4
		mov	eax, [esp+74h+var_58]
		pop	esi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 6Ch
		retn
_atalla_mod_exp	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0BDCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _bind_engine
_bind_engine	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		call	_ENGINE_get_static_state
		mov	esi, [esp+4+arg_8]
		cmp	eax, [esi]
		jz	short $skip_cbs$19
		push	dword ptr [esi+14h]
		push	dword ptr [esi+10h]
		push	dword ptr [esi+0Ch]
		call	_CRYPTO_set_mem_functions
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_C03

loc_BFF:				; CODE XREF: _bind_engine+5Cj
					; _bind_engine+6Bj ...
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_C03:				; CODE XREF: _bind_engine+21j
		push	dword ptr [esi+18h]
		call	_CRYPTO_set_locking_callback
		push	dword ptr [esi+1Ch]
		call	_CRYPTO_set_add_lock_callback
		push	dword ptr [esi+20h]
		call	_CRYPTO_set_dynlock_create_callback
		push	dword ptr [esi+24h]
		call	_CRYPTO_set_dynlock_lock_callback
		push	dword ptr [esi+28h]
		call	_CRYPTO_set_dynlock_destroy_callback
		push	dword ptr [esi+8]
		call	_CRYPTO_set_ex_data_implementation
		add	esp, 18h
		test	eax, eax
		jz	short loc_BFF
		push	dword ptr [esi+4]
		call	_ERR_set_implementation
		add	esp, 4
		test	eax, eax
		jz	short loc_BFF

$skip_cbs$19:				; CODE XREF: _bind_engine+Cj
		mov	eax, [esp+4+arg_4]
		test	eax, eax
		jz	short loc_C89
		mov	ecx, _engine_atalla_id
		nop	dword ptr [eax+eax+00h]

loc_C5C:				; CODE XREF: _bind_engine+9Aj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_C7C
		test	dl, dl
		jz	short loc_C78
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_C7C
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_C5C

loc_C78:				; CODE XREF: _bind_engine+88j
		xor	eax, eax
		jmp	short loc_C81
; ---------------------------------------------------------------------------

loc_C7C:				; CODE XREF: _bind_engine+84j
					; _bind_engine+90j
		sbb	eax, eax
		or	eax, 1

loc_C81:				; CODE XREF: _bind_engine+9Ej
		test	eax, eax
		jnz	loc_BFF

loc_C89:				; CODE XREF: _bind_engine+73j
		push	[esp+4+arg_0]
		call	_bind_helper
		add	esp, 4
		test	eax, eax
		jz	loc_BFF
		mov	eax, 1
		pop	esi
		retn
_bind_engine	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0CA4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_bind_fn	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_4]
		test	eax, eax
		jz	short loc_CE0
		mov	ecx, _engine_atalla_id
		xchg	ax, ax

loc_CB4:				; CODE XREF: _bind_fn+2Aj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_CD4
		test	dl, dl
		jz	short loc_CD0
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_CD4
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_CB4

loc_CD0:				; CODE XREF: _bind_fn+18j
		xor	eax, eax
		jmp	short loc_CD9
; ---------------------------------------------------------------------------

loc_CD4:				; CODE XREF: _bind_fn+14j _bind_fn+20j
		sbb	eax, eax
		or	eax, 1

loc_CD9:				; CODE XREF: _bind_fn+2Ej
		test	eax, eax
		jz	short loc_CE0
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_CE0:				; CODE XREF: _bind_fn+6j _bind_fn+37j
		push	[esp+arg_0]
		call	_bind_helper
		add	esp, 4
		neg	eax
		sbb	eax, eax
		neg	eax
		retn
_bind_fn	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0CF4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_bind_helper	proc near		; CODE XREF: _bind_engine+B1p
					; _bind_fn+40p

arg_0		= dword	ptr  4

		push	esi
		push	_engine_atalla_id
		mov	esi, [esp+8+arg_0]
		push	esi
		call	_ENGINE_set_id
		add	esp, 8
		test	eax, eax
		jz	loc_E38
		push	_engine_atalla_name
		push	esi
		call	_ENGINE_set_name
		add	esp, 8
		test	eax, eax
		jz	loc_E38
		push	offset _atalla_rsa
		push	esi
		call	_ENGINE_set_RSA
		add	esp, 8
		test	eax, eax
		jz	loc_E38
		push	offset _atalla_dsa
		push	esi
		call	_ENGINE_set_DSA
		add	esp, 8
		test	eax, eax
		jz	loc_E38
		push	offset _atalla_dh
		push	esi
		call	_ENGINE_set_DH
		add	esp, 8
		test	eax, eax
		jz	loc_E38
		push	offset _atalla_destroy
		push	esi
		call	_ENGINE_set_destroy_function
		add	esp, 8
		test	eax, eax
		jz	loc_E38
		push	offset _atalla_init
		push	esi
		call	_ENGINE_set_init_function
		add	esp, 8
		test	eax, eax
		jz	loc_E38
		push	offset _atalla_finish
		push	esi
		call	_ENGINE_set_finish_function
		add	esp, 8
		test	eax, eax
		jz	loc_E38
		push	offset _atalla_ctrl
		push	esi
		call	_ENGINE_set_ctrl_function
		add	esp, 8
		test	eax, eax
		jz	short loc_E38
		push	offset _atalla_cmd_defns
		push	esi
		call	_ENGINE_set_cmd_defns
		add	esp, 8
		test	eax, eax
		jz	short loc_E38
		call	_RSA_PKCS1_SSLeay
		mov	ecx, [eax+4]
		mov	dword_90, ecx
		mov	ecx, [eax+8]
		mov	dword_94, ecx
		mov	ecx, [eax+0Ch]
		mov	dword_98, ecx
		mov	eax, [eax+10h]
		mov	dword_9C, eax
		call	_DSA_OpenSSL
		mov	ecx, [eax+4]
		mov	dword_C8, ecx
		mov	ecx, [eax+8]
		mov	dword_CC, ecx
		mov	eax, [eax+0Ch]
		mov	dword_D0, eax
		call	_DH_OpenSSL
		mov	ecx, [eax+4]
		mov	dword_F8, ecx
		mov	eax, [eax+8]
		mov	dword_FC, eax
		call	_ERR_load_ATALLA_strings
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_E38:				; CODE XREF: _bind_helper+16j
					; _bind_helper+2Dj ...
		xor	eax, eax
		pop	esi
		retn
_bind_helper	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E3Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_free_ATALLA_LIBNAME proc near
		mov	eax, ds:_ATALLA_LIBNAME
		test	eax, eax
		jz	short loc_E4E
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_E4E:				; CODE XREF: _free_ATALLA_LIBNAME+7j
		mov	ds:_ATALLA_LIBNAME, 0
		retn
_free_ATALLA_LIBNAME endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E5Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_get_ATALLA_LIBNAME proc near
		mov	ecx, ds:_ATALLA_LIBNAME
		mov	eax, offset ??_C@_05OANFFCCN@atasi?$AA@	; "atasi"
		test	ecx, ecx
		cmovnz	eax, ecx
		retn
_get_ATALLA_LIBNAME endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E70h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_set_ATALLA_LIBNAME proc near		; CODE XREF: _atalla_ctrl+A9p

arg_0		= dword	ptr  4

		mov	eax, ds:_ATALLA_LIBNAME
		test	eax, eax
		jz	short loc_E82
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_E82:				; CODE XREF: _set_ATALLA_LIBNAME+7j
		push	[esp+arg_0]
		mov	ds:_ATALLA_LIBNAME, 0
		call	_BUF_strdup
		xor	ecx, ecx
		mov	ds:_ATALLA_LIBNAME, eax
		add	esp, 4
		test	eax, eax
		setnz	cl
		mov	eax, ecx
		retn
_set_ATALLA_LIBNAME endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0EA8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _v_check
_v_check	proc near

arg_0		= dword	ptr  4

		cmp	[esp+arg_0], 20000h
		sbb	eax, eax
		and	eax, 0FFFE0000h
		add	eax, 20000h
		retn
_v_check	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0EC0h
; COMDAT (pick any)
		public ??_C@_05OANFFCCN@atasi?$AA@
; `string'
??_C@_05OANFFCCN@atasi?$AA@ db 'atasi',0 ; DATA XREF: _atalla_init+4Co
					; _get_ATALLA_LIBNAME+6o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0EC8h
; COMDAT (pick any)
		public ??_C@_0BF@ICBHMHHE@?4?2engines?2e_atalla?4c?$AA@
; `string'
??_C@_0BF@ICBHMHHE@?4?2engines?2e_atalla?4c?$AA@ db '.\engines\e_atalla.c',0
					; DATA XREF: _atalla_rsa_mod_exp+21o
					; _atalla_rsa_mod_exp+77o ...
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _CRYPTO_set_ex_data_implementation:near ;	CODE XREF: _bind_engine+52p
		extrn _CRYPTO_set_locking_callback:near	; CODE XREF: _bind_engine+2Ap
		extrn _CRYPTO_set_add_lock_callback:near ; CODE	XREF: _bind_engine+32p
		extrn _CRYPTO_set_dynlock_create_callback:near ; CODE XREF: _bind_engine+3Ap
		extrn _CRYPTO_set_dynlock_lock_callback:near ; CODE XREF: _bind_engine+42p
		extrn _CRYPTO_set_dynlock_destroy_callback:near
					; CODE XREF: _bind_engine+4Ap
		extrn _CRYPTO_set_mem_functions:near ; CODE XREF: _bind_engine+17p
		extrn _CRYPTO_free:near	; CODE XREF: _atalla_destroy+Ap
					; _atalla_finish+Ap ...
		extrn _BUF_strdup:near	; CODE XREF: _set_ATALLA_LIBNAME+20p
		extrn _DSO_free:near	; CODE XREF: _atalla_finish+53p
					; _atalla_init+15Fp
		extrn _DSO_load:near	; CODE XREF: _atalla_init+5Dp
		extrn _DSO_bind_func:near ; CODE XREF: _atalla_init+92p
					; _atalla_init+B0p ...
		extrn _BN_CTX_start:near ; CODE	XREF: _atalla_mod_exp+80p
		extrn _BN_CTX_get:near	; CODE XREF: _atalla_mod_exp+86p
					; _atalla_mod_exp+8Ep ...
		extrn _BN_CTX_end:near	; CODE XREF: _atalla_mod_exp+2B4p
		extrn _BN_num_bits:near	; CODE XREF: _atalla_mod_exp+15Bp
					; _atalla_mod_exp+190p	...
		extrn _BN_init:near	; CODE XREF: _atalla_dsa_mod_exp+15p
		extrn _BN_bin2bn:near	; CODE XREF: _atalla_mod_exp+275p
		extrn _BN_bn2bin:near	; CODE XREF: _atalla_mod_exp+1B4p
					; _atalla_mod_exp+1D6p	...
		extrn _BN_mod_mul:near	; CODE XREF: _atalla_dsa_mod_exp+61p
		extrn _BN_free:near	; CODE XREF: _atalla_dsa_mod_exp+78p
		extrn _bn_expand2:near	; CODE XREF: _atalla_mod_exp+E2p
					; _atalla_mod_exp+100p	...
		extrn _RSA_PKCS1_SSLeay:near ; CODE XREF: _bind_helper+DBp
		extrn _DH_OpenSSL:near	; CODE XREF: _bind_helper+122p
		extrn _DSA_OpenSSL:near	; CODE XREF: _bind_helper+103p
		extrn _ERR_put_error:near ; CODE XREF: _atalla_rsa_mod_exp+2Bp
					; _atalla_rsa_mod_exp+81p ...
		extrn _ERR_load_strings:near ; CODE XREF: _ERR_load_ATALLA_strings+2Cp
					; _ERR_load_ATALLA_strings+3Cp	...
		extrn _ERR_unload_strings:near ; CODE XREF: _ERR_unload_ATALLA_strings+14p
					; _ERR_unload_ATALLA_strings+24p ...
		extrn _ERR_get_next_error_library:near ; CODE XREF: _atalla_rsa_mod_exp+12p
					; _atalla_rsa_mod_exp+68p ...
		extrn _ERR_set_implementation:near ; CODE XREF:	_bind_engine+61p
		extrn _ENGINE_set_id:near ; CODE XREF: _bind_helper+Cp
		extrn _ENGINE_set_name:near ; CODE XREF: _bind_helper+23p
		extrn _ENGINE_set_RSA:near ; CODE XREF:	_bind_helper+39p
		extrn _ENGINE_set_DSA:near ; CODE XREF:	_bind_helper+4Fp
		extrn _ENGINE_set_DH:near ; CODE XREF: _bind_helper+65p
		extrn _ENGINE_set_destroy_function:near	; CODE XREF: _bind_helper+7Bp
		extrn _ENGINE_set_init_function:near ; CODE XREF: _bind_helper+91p
		extrn _ENGINE_set_finish_function:near ; CODE XREF: _bind_helper+A7p
		extrn _ENGINE_set_ctrl_function:near ; CODE XREF: _bind_helper+BDp
		extrn _ENGINE_set_cmd_defns:near ; CODE	XREF: _bind_helper+CFp
		extrn _ENGINE_get_static_state:near ; CODE XREF: _bind_engine+1p
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _atalla_init+11Fp
					; _atalla_init+19Cp ...
		extrn __chkstk:near	; CODE XREF: _atalla_dsa_mod_exp+5p
					; _atalla_init+5p ...
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _atalla_mod_exp+155p
					; _atalla_mod_exp+179p	...
		extrn ___security_cookie:near ;	DATA XREF: _atalla_init+Ar
					; _atalla_mod_exp+Ar


		end
