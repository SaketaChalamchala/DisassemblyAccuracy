;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	BC407C696ED59083BE45E44C69191CD4
; Input	CRC32 :	37389921

; File Name   :	C:\compspace\Diff\openssl\obj\ccm128.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_ccm128_aad
_CRYPTO_ccm128_aad proc	near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		mov	ebx, [esp+4+arg_8]
		push	esi
		mov	esi, [esp+8+arg_0]
		mov	eax, [esi+28h]
		mov	[esp+8+arg_0], eax
		test	ebx, ebx
		jz	loc_B6
		or	byte ptr [esi],	40h
		push	ebp
		push	edi
		push	dword ptr [esi+2Ch]
		lea	ebp, [esi+10h]
		push	ebp
		push	esi
		call	eax
		add	esp, 0Ch
		mov	eax, ebx
		add	dword ptr [esi+20h], 1
		adc	dword ptr [esi+24h], 0
		cmp	ebx, 0FF00h
		jnb	short loc_4D
		shr	eax, 8
		xor	[ebp+0], al
		mov	eax, 2
		xor	[esi+11h], bl
		jmp	short loc_72
; ---------------------------------------------------------------------------

loc_4D:					; CODE XREF: _CRYPTO_ccm128_aad+3Bj
		xor	byte ptr [esi+11h], 0FEh
		not	byte ptr [ebp+0]
		shr	eax, 18h
		xor	[esi+12h], al
		mov	eax, ebx
		shr	eax, 10h
		xor	[esi+13h], al
		mov	eax, ebx
		shr	eax, 8
		xor	[esi+14h], al
		mov	eax, 6
		xor	[esi+15h], bl

loc_72:					; CODE XREF: _CRYPTO_ccm128_aad+4Bj
		mov	edi, [esp+10h+arg_4]

loc_76:					; CODE XREF: _CRYPTO_ccm128_aad+B2j
		cmp	eax, 10h
		jnb	short loc_9A
		add	eax, 10h
		mov	edx, 0FFFFFFF0h
		add	eax, esi
		sub	edx, esi

loc_87:					; CODE XREF: _CRYPTO_ccm128_aad+98j
		test	ebx, ebx
		jz	short loc_9A
		mov	cl, [edi]
		dec	ebx
		xor	[eax], cl
		inc	edi
		inc	eax
		lea	ecx, [edx+eax]
		cmp	ecx, 10h
		jb	short loc_87

loc_9A:					; CODE XREF: _CRYPTO_ccm128_aad+79j
					; _CRYPTO_ccm128_aad+89j
		push	dword ptr [esi+2Ch]
		push	ebp
		push	ebp
		call	[esp+1Ch+arg_0]
		add	esp, 0Ch
		add	dword ptr [esi+20h], 1
		adc	dword ptr [esi+24h], 0
		xor	eax, eax
		test	ebx, ebx
		jnz	short loc_76
		pop	edi
		pop	ebp

loc_B6:					; CODE XREF: _CRYPTO_ccm128_aad+13j
		pop	esi
		pop	ebx
		retn
_CRYPTO_ccm128_aad endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0BCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_ccm128_decrypt
_CRYPTO_ccm128_decrypt proc near

var_2D		= byte ptr -2Dh
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, 30h ; '0'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+30h+var_4], eax
		mov	eax, [esp+30h+arg_8]
		push	ebx
		push	ebp
		push	esi
		mov	esi, [esp+3Ch+arg_0]
		push	edi
		mov	[esp+40h+var_2C], eax
		mov	[esp+40h+var_1C], esi
		mov	bl, [esi]
		mov	edi, [esi+28h]
		mov	eax, [esi+2Ch]
		mov	[esp+40h+var_2D], bl
		mov	[esp+40h+var_24], edi
		mov	[esp+40h+var_28], eax
		test	bl, 40h
		jnz	short loc_109
		push	eax
		lea	eax, [esi+10h]
		push	eax
		push	esi
		call	edi
		add	esp, 0Ch

loc_109:				; CODE XREF: _CRYPTO_ccm128_decrypt+40j
		movzx	eax, bl
		mov	edx, 0Fh
		and	eax, 7
		xor	ecx, ecx
		sub	edx, eax
		mov	[esi], al
		mov	[esp+40h+var_18], edx
		cmp	edx, 0Fh
		jnb	short loc_13F
		nop	word ptr [eax+eax+00000000h]

loc_12C:				; CODE XREF: _CRYPTO_ccm128_decrypt+81j
		movzx	eax, byte ptr [esi+edx]
		or	ecx, eax
		mov	byte ptr [esi+edx], 0
		inc	edx
		shl	ecx, 8
		cmp	edx, 0Fh
		jb	short loc_12C

loc_13F:				; CODE XREF: _CRYPTO_ccm128_decrypt+65j
		movzx	eax, byte ptr [esi+0Fh]
		mov	ebp, [esp+40h+arg_C]
		or	ecx, eax
		mov	byte ptr [esi+0Fh], 1
		cmp	ecx, ebp
		jz	short loc_167
		pop	edi
		pop	esi
		pop	ebp
		or	eax, 0FFFFFFFFh
		pop	ebx
		mov	ecx, [esp+30h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 30h
		retn
; ---------------------------------------------------------------------------

loc_167:				; CODE XREF: _CRYPTO_ccm128_decrypt+93j
		mov	ebx, [esp+40h+arg_4]
		cmp	ebp, 10h
		jb	loc_20C
		mov	edi, 0FFFFFFF8h
		mov	eax, ebp
		sub	edi, esi
		shr	eax, 4
		mov	[esp+40h+var_20], eax
		nop	dword ptr [eax+eax+00000000h]

loc_18C:				; CODE XREF: _CRYPTO_ccm128_decrypt+14Aj
		push	[esp+40h+var_28]
		lea	eax, [esp+44h+var_14]
		push	eax
		push	esi
		call	[esp+4Ch+var_24]
		add	esp, 0Ch
		lea	eax, [esi+10h]

loc_1A0:				; CODE XREF: _CRYPTO_ccm128_decrypt+F2j
		add	byte ptr [eax-1], 1
		lea	eax, [eax-1]
		jnz	short loc_1B0
		lea	ecx, [edi+eax]
		test	ecx, ecx
		jnz	short loc_1A0

loc_1B0:				; CODE XREF: _CRYPTO_ccm128_decrypt+EBj
		mov	ecx, [ebx]
		mov	eax, [ebx+4]
		mov	edx, [esp+40h+var_2C]
		xor	eax, [esp+40h+var_10]
		xor	ecx, [esp+40h+var_14]
		push	[esp+40h+var_28]
		mov	[edx+4], eax
		mov	[edx], ecx
		xor	[esi+14h], eax
		xor	[esi+10h], ecx
		mov	ecx, [ebx+8]
		mov	eax, [ebx+0Ch]
		xor	eax, [esp+44h+var_8]
		xor	ecx, [esp+44h+var_C]
		mov	[edx+0Ch], eax
		mov	[edx+8], ecx
		xor	[esi+1Ch], eax
		lea	eax, [esi+10h]
		xor	[esi+18h], ecx
		push	eax
		push	eax
		call	[esp+4Ch+var_24]
		add	[esp+4Ch+var_2C], 10h
		add	esp, 0Ch
		add	ebx, 10h
		sub	ebp, 10h
		sub	[esp+40h+var_20], 1
		jnz	short loc_18C
		mov	edi, [esp+40h+var_24]

loc_20C:				; CODE XREF: _CRYPTO_ccm128_decrypt+B2j
		test	ebp, ebp
		jz	short loc_273
		push	[esp+40h+var_28]
		lea	eax, [esp+44h+var_14]
		push	eax
		push	esi
		call	edi
		add	esp, 0Ch
		xor	edi, edi
		test	ebp, ebp
		jz	short loc_25E
		lea	eax, [esp+40h+var_14]
		sub	ebx, eax
		sub	[esp+40h+var_2C], eax
		lea	eax, [esi+10h]
		mov	esi, [esp+40h+var_2C]
		mov	[esp+40h+var_20], eax
		xchg	ax, ax

loc_23C:				; CODE XREF: _CRYPTO_ccm128_decrypt+19Cj
		lea	ecx, [esp+40h+var_14]
		add	ecx, edi
		movzx	edx, byte ptr [ebx+ecx]
		movzx	eax, byte ptr [ecx]
		xor	edx, eax
		mov	eax, [esp+40h+var_20]
		mov	[esi+ecx], dl
		xor	[eax+edi], dl
		inc	edi
		cmp	edi, ebp
		jb	short loc_23C
		mov	esi, [esp+40h+var_1C]

loc_25E:				; CODE XREF: _CRYPTO_ccm128_decrypt+167j
		mov	ebx, [esp+40h+var_28]
		lea	eax, [esi+10h]
		mov	edi, [esp+40h+var_24]
		push	ebx
		push	eax
		push	eax
		call	edi
		add	esp, 0Ch
		jmp	short loc_277
; ---------------------------------------------------------------------------

loc_273:				; CODE XREF: _CRYPTO_ccm128_decrypt+152j
		mov	ebx, [esp+40h+var_28]

loc_277:				; CODE XREF: _CRYPTO_ccm128_decrypt+1B5j
		mov	edx, [esp+40h+var_18]
		cmp	edx, 10h
		jnb	short loc_29E
		mov	ecx, 10h
		lea	edi, [edx+esi]
		sub	ecx, edx
		xor	eax, eax
		mov	edx, ecx
		shr	ecx, 2
		rep stosd
		mov	ecx, edx
		and	ecx, 3
		rep stosb
		mov	edi, [esp+40h+var_24]

loc_29E:				; CODE XREF: _CRYPTO_ccm128_decrypt+1C2j
		push	ebx
		lea	eax, [esp+44h+var_14]
		push	eax
		push	esi
		call	edi
		mov	eax, [esp+4Ch+var_14]
		add	esp, 0Ch
		xor	[esi+10h], eax
		mov	eax, [esp+40h+var_10]
		xor	[esi+14h], eax
		mov	eax, [esp+40h+var_C]
		xor	[esi+18h], eax
		mov	eax, [esp+40h+var_8]
		xor	[esi+1Ch], eax
		mov	al, [esp+40h+var_2D]
		mov	ecx, [esp+40h+var_4]
		pop	edi
		mov	[esi], al
		xor	eax, eax
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 30h
		retn
_CRYPTO_ccm128_decrypt endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_ccm128_decrypt_ccm64
_CRYPTO_ccm128_decrypt_ccm64 proc near

var_2D		= byte ptr -2Dh
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	eax, 30h ; '0'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+30h+var_4], eax
		mov	eax, [esp+30h+arg_8]
		push	ebx
		push	ebp
		mov	ebp, [esp+38h+arg_4]
		push	esi
		mov	esi, [esp+3Ch+arg_0]
		mov	[esp+3Ch+var_2C], eax
		mov	eax, [esp+3Ch+arg_10]
		mov	[esp+3Ch+var_20], eax
		mov	bl, [esi]
		mov	ecx, [esi+28h]
		mov	eax, [esi+2Ch]
		mov	[esp+3Ch+var_1C], esi
		mov	[esp+3Ch+var_2D], bl
		mov	[esp+3Ch+var_24], ecx
		mov	[esp+3Ch+var_28], eax
		test	bl, 40h
		jnz	short loc_33C
		push	eax
		lea	eax, [esi+10h]
		push	eax
		push	esi
		call	ecx
		add	esp, 0Ch

loc_33C:				; CODE XREF: _CRYPTO_ccm128_decrypt_ccm64+4Bj
		movzx	eax, bl
		mov	edx, 0Fh
		and	eax, 7
		xor	ecx, ecx
		sub	edx, eax
		mov	[esi], al
		mov	[esp+3Ch+var_18], edx
		cmp	edx, 0Fh
		jnb	short loc_369

loc_356:				; CODE XREF: _CRYPTO_ccm128_decrypt_ccm64+83j
		movzx	eax, byte ptr [esi+edx]
		or	ecx, eax
		mov	byte ptr [esi+edx], 0
		inc	edx
		shl	ecx, 8
		cmp	edx, 0Fh
		jb	short loc_356

loc_369:				; CODE XREF: _CRYPTO_ccm128_decrypt_ccm64+70j
		movzx	eax, byte ptr [esi+0Fh]
		mov	ebx, [esp+3Ch+arg_C]
		or	ecx, eax
		mov	byte ptr [esi+0Fh], 1
		cmp	ecx, ebx
		jz	short loc_390
		pop	esi
		pop	ebp
		or	eax, 0FFFFFFFFh
		pop	ebx
		mov	ecx, [esp+30h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 30h
		retn
; ---------------------------------------------------------------------------

loc_390:				; CODE XREF: _CRYPTO_ccm128_decrypt_ccm64+95j
		push	edi
		mov	edi, ebx
		shr	edi, 4
		test	edi, edi
		jz	short loc_3CA
		lea	eax, [esi+10h]
		push	eax
		push	esi
		push	[esp+48h+var_28]
		push	edi
		push	[esp+50h+var_2C]
		push	ebp
		call	[esp+58h+var_20]
		shl	edi, 4
		add	esp, 18h
		add	[esp+40h+var_2C], edi
		add	ebp, edi
		sub	ebx, edi
		jz	short loc_431
		shr	edi, 4
		push	edi
		push	esi
		call	_ctr64_add
		add	esp, 8

loc_3CA:				; CODE XREF: _CRYPTO_ccm128_decrypt_ccm64+B4j
		test	ebx, ebx
		jz	short loc_431
		push	[esp+40h+var_28]
		lea	eax, [esp+44h+var_14]
		push	eax
		push	esi
		call	[esp+4Ch+var_24]
		add	esp, 0Ch
		xor	edi, edi
		test	ebx, ebx
		jz	short loc_41C
		lea	eax, [esp+40h+var_14]
		sub	ebp, eax
		sub	[esp+40h+var_2C], eax
		lea	eax, [esi+10h]
		mov	esi, [esp+40h+var_2C]
		mov	[esp+40h+var_20], eax

loc_3FA:				; CODE XREF: _CRYPTO_ccm128_decrypt_ccm64+132j
		lea	ecx, [esp+40h+var_14]
		add	ecx, edi
		movzx	edx, byte ptr [ecx+ebp]
		movzx	eax, byte ptr [ecx]
		xor	edx, eax
		mov	eax, [esp+40h+var_20]
		mov	[esi+ecx], dl
		xor	[eax+edi], dl
		inc	edi
		cmp	edi, ebx
		jb	short loc_3FA
		mov	esi, [esp+40h+var_1C]

loc_41C:				; CODE XREF: _CRYPTO_ccm128_decrypt_ccm64+FFj
		mov	ebx, [esp+40h+var_28]
		lea	eax, [esi+10h]
		mov	ebp, [esp+40h+var_24]
		push	ebx
		push	eax
		push	eax
		call	ebp
		add	esp, 0Ch
		jmp	short loc_439
; ---------------------------------------------------------------------------

loc_431:				; CODE XREF: _CRYPTO_ccm128_decrypt_ccm64+D7j
					; _CRYPTO_ccm128_decrypt_ccm64+E8j
		mov	ebp, [esp+40h+var_24]
		mov	ebx, [esp+40h+var_28]

loc_439:				; CODE XREF: _CRYPTO_ccm128_decrypt_ccm64+14Bj
		mov	edx, [esp+40h+var_18]
		cmp	edx, 10h
		jnb	short loc_45C
		mov	ecx, 10h
		lea	edi, [edx+esi]
		sub	ecx, edx
		xor	eax, eax
		mov	edx, ecx
		shr	ecx, 2
		rep stosd
		mov	ecx, edx
		and	ecx, 3
		rep stosb

loc_45C:				; CODE XREF: _CRYPTO_ccm128_decrypt_ccm64+15Cj
		push	ebx
		lea	eax, [esp+44h+var_14]
		push	eax
		push	esi
		call	ebp
		mov	eax, [esp+4Ch+var_14]
		add	esp, 0Ch
		xor	[esi+10h], eax
		mov	eax, [esp+40h+var_10]
		xor	[esi+14h], eax
		mov	eax, [esp+40h+var_C]
		xor	[esi+18h], eax
		mov	eax, [esp+40h+var_8]
		xor	[esi+1Ch], eax
		mov	al, [esp+40h+var_2D]
		mov	ecx, [esp+40h+var_4]
		pop	edi
		mov	[esi], al
		xor	eax, eax
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 30h
		retn
_CRYPTO_ccm128_decrypt_ccm64 endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4A0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_ccm128_encrypt
_CRYPTO_ccm128_encrypt proc near

var_3D		= byte ptr -3Dh
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, 40h ; '@'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+40h+var_4], eax
		push	ebx
		push	ebp
		mov	ebp, [esp+48h+arg_8]
		push	esi
		mov	esi, [esp+4Ch+arg_0]
		mov	[esp+4Ch+var_1C], esi
		mov	[esp+4Ch+var_30], ebp
		mov	bl, [esi]
		mov	ecx, [esi+28h]
		mov	eax, [esi+2Ch]
		mov	[esp+4Ch+var_3D], bl
		mov	[esp+4Ch+var_38], ecx
		mov	[esp+4Ch+var_3C], eax
		test	bl, 40h
		jnz	short loc_4F4
		push	eax
		lea	eax, [esi+10h]
		push	eax
		push	esi
		call	ecx
		add	esp, 0Ch
		add	dword ptr [esi+20h], 1
		adc	dword ptr [esi+24h], 0

loc_4F4:				; CODE XREF: _CRYPTO_ccm128_encrypt+3Fj
		movzx	eax, bl
		mov	edx, 0Fh
		and	eax, 7
		xor	ecx, ecx
		sub	edx, eax
		mov	[esi], al
		mov	[esp+4Ch+var_18], edx
		cmp	edx, 0Fh
		jnb	short loc_523
		xchg	ax, ax

loc_510:				; CODE XREF: _CRYPTO_ccm128_encrypt+81j
		movzx	eax, byte ptr [esi+edx]
		or	ecx, eax
		mov	byte ptr [esi+edx], 0
		inc	edx
		shl	ecx, 8
		cmp	edx, 0Fh
		jb	short loc_510

loc_523:				; CODE XREF: _CRYPTO_ccm128_encrypt+6Cj
		movzx	eax, byte ptr [esi+0Fh]
		mov	ebx, [esp+4Ch+arg_C]
		or	ecx, eax
		mov	byte ptr [esi+0Fh], 1
		cmp	ecx, ebx
		jz	short loc_54A
		pop	esi
		pop	ebp
		or	eax, 0FFFFFFFFh
		pop	ebx
		mov	ecx, [esp+40h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 40h
		retn
; ---------------------------------------------------------------------------

loc_54A:				; CODE XREF: _CRYPTO_ccm128_encrypt+93j
		lea	eax, [ebx+0Fh]
		or	eax, 8
		shr	eax, 3
		add	[esi+20h], eax
		adc	dword ptr [esi+24h], 0
		cmp	dword ptr [esi+24h], 20000000h
		jb	short loc_582
		ja	short loc_56B
		cmp	dword ptr [esi+20h], 0
		jbe	short loc_582

loc_56B:				; CODE XREF: _CRYPTO_ccm128_encrypt+C3j
		pop	esi
		pop	ebp
		mov	eax, 0FFFFFFFEh
		pop	ebx
		mov	ecx, [esp+40h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 40h
		retn
; ---------------------------------------------------------------------------

loc_582:				; CODE XREF: _CRYPTO_ccm128_encrypt+C1j
					; _CRYPTO_ccm128_encrypt+C9j
		push	edi
		mov	edi, [esp+50h+arg_4]
		cmp	ebx, 10h
		jb	loc_624
		mov	eax, ebx
		lea	ecx, [esi+10h]
		shr	eax, 4
		mov	[esp+50h+var_34], eax
		nop	dword ptr [eax+00h]

loc_5A0:				; CODE XREF: _CRYPTO_ccm128_encrypt+17Aj
		mov	eax, [edi]
		xor	[ecx], eax
		mov	eax, [edi+4]
		xor	[ecx+4], eax
		push	[esp+50h+var_3C]
		mov	eax, [edi+8]
		xor	[esi+18h], eax
		mov	eax, [edi+0Ch]
		xor	[esi+1Ch], eax
		push	ecx
		push	ecx
		call	[esp+5Ch+var_38]
		push	[esp+5Ch+var_3C]
		lea	eax, [esp+60h+var_14]
		push	eax
		push	esi
		call	[esp+68h+var_38]
		add	esp, 18h
		mov	ecx, 8

loc_5D6:				; CODE XREF: _CRYPTO_ccm128_encrypt+140j
		dec	ecx
		add	byte ptr [ecx+esi+8], 1
		jnz	short loc_5E2
		test	ecx, ecx
		jnz	short loc_5D6

loc_5E2:				; CODE XREF: _CRYPTO_ccm128_encrypt+13Cj
		mov	ecx, [edi]
		sub	ebx, 10h
		mov	eax, [edi+4]
		xor	ecx, [esp+50h+var_14]
		xor	eax, [esp+50h+var_10]
		mov	[ebp+0], ecx
		mov	[ebp+4], eax
		mov	ecx, [edi+8]
		mov	eax, [edi+0Ch]
		add	edi, 10h
		xor	ecx, [esp+50h+var_C]
		xor	eax, [esp+50h+var_8]
		mov	[ebp+8], ecx
		lea	ecx, [esi+10h]
		mov	[ebp+0Ch], eax
		add	ebp, 10h
		sub	[esp+50h+var_34], 1
		jnz	short loc_5A0
		mov	[esp+50h+var_30], ebp
		mov	[esp+50h+arg_C], ebx

loc_624:				; CODE XREF: _CRYPTO_ccm128_encrypt+EAj
		mov	[esp+50h+var_34], edi
		test	ebx, ebx
		jz	loc_733
		xor	ecx, ecx
		test	ebx, ebx
		jz	short loc_642

loc_636:				; CODE XREF: _CRYPTO_ccm128_encrypt+1A0j
		mov	al, [ecx+edi]
		xor	[esi+ecx+10h], al
		inc	ecx
		cmp	ecx, ebx
		jb	short loc_636

loc_642:				; CODE XREF: _CRYPTO_ccm128_encrypt+194j
		push	[esp+50h+var_3C]
		lea	eax, [esi+10h]
		push	eax
		push	eax
		call	[esp+5Ch+var_38]
		push	[esp+5Ch+var_3C]
		lea	eax, [esp+60h+var_14]
		push	eax
		push	esi
		call	[esp+68h+var_38]
		add	esp, 18h
		xor	edx, edx
		test	ebx, ebx
		jz	loc_733
		cmp	ebx, 20h ; ' '
		jb	loc_711
		lea	ecx, [ebp-1]
		lea	eax, [esp+ebx+50h+var_18+3]
		add	ecx, ebx
		cmp	ebp, eax
		ja	short loc_68C
		lea	eax, [esp+50h+var_14]
		cmp	ecx, eax
		jnb	loc_711

loc_68C:				; CODE XREF: _CRYPTO_ccm128_encrypt+1DEj
		lea	eax, [edi-1]
		add	eax, ebx
		cmp	ebp, eax
		ja	short loc_699
		cmp	ecx, edi
		jnb	short loc_711

loc_699:				; CODE XREF: _CRYPTO_ccm128_encrypt+1F3j
		mov	eax, ebx
		mov	ecx, ebx
		lea	ebx, [esp+50h+var_14]
		and	eax, 1Fh
		sub	ebx, edi
		mov	esi, ebp
		mov	[esp+50h+var_28], ebx
		sub	esi, edi
		sub	ecx, eax
		mov	[esp+50h+var_2C], esi
		lea	ebx, [esp+50h+var_4]
		mov	eax, edi
		sub	ebx, edi
		mov	[esp+50h+var_24], ebx
		lea	ebx, [ebp+10h]
		mov	ebp, [esp+50h+var_28]
		mov	edi, [esp+50h+var_24]
		mov	[esp+50h+var_20], ebx
		mov	ebx, esi

loc_6D1:				; CODE XREF: _CRYPTO_ccm128_encrypt+263j
		movups	xmm0, xmmword ptr [eax]
		mov	esi, [esp+50h+var_20]
		lea	eax, [eax+20h]
		movups	xmm1, xmmword ptr [eax+ebp-20h]
		pxor	xmm1, xmm0
		movups	xmmword	ptr [ebx+eax-20h], xmm1
		movups	xmm0, xmmword ptr [eax-10h]
		movups	xmm1, xmmword ptr [edi+eax-20h]
		pxor	xmm1, xmm0
		movups	xmmword	ptr [esi+edx], xmm1
		mov	esi, [esp+50h+var_1C]
		add	edx, 20h ; ' '
		cmp	edx, ecx
		jb	short loc_6D1
		mov	edi, [esp+50h+var_34]
		mov	ebx, [esp+50h+arg_C]
		mov	ebp, [esp+50h+var_30]

loc_711:				; CODE XREF: _CRYPTO_ccm128_encrypt+1CDj
					; _CRYPTO_ccm128_encrypt+1E6j ...
		cmp	edx, ebx
		jnb	short loc_733
		lea	eax, [esp+50h+var_14]
		sub	edi, eax
		sub	ebp, eax
		nop	dword ptr [eax]

loc_720:				; CODE XREF: _CRYPTO_ccm128_encrypt+291j
		lea	ecx, [esp+50h+var_14]
		add	ecx, edx
		inc	edx
		mov	al, [ecx+edi]
		xor	al, [ecx]
		mov	[ecx+ebp], al
		cmp	edx, ebx
		jb	short loc_720

loc_733:				; CODE XREF: _CRYPTO_ccm128_encrypt+18Aj
					; _CRYPTO_ccm128_encrypt+1C4j ...
		mov	edx, [esp+50h+var_18]
		cmp	edx, 10h
		jnb	short loc_756
		mov	ecx, 10h
		lea	edi, [edx+esi]
		sub	ecx, edx
		xor	eax, eax
		mov	edx, ecx
		shr	ecx, 2
		rep stosd
		mov	ecx, edx
		and	ecx, 3
		rep stosb

loc_756:				; CODE XREF: _CRYPTO_ccm128_encrypt+29Aj
		push	[esp+50h+var_3C]
		lea	eax, [esp+54h+var_14]
		push	eax
		push	esi
		call	[esp+5Ch+var_38]
		mov	eax, [esp+5Ch+var_14]
		add	esp, 0Ch
		xor	[esi+10h], eax
		mov	eax, [esp+50h+var_10]
		xor	[esi+14h], eax
		mov	eax, [esp+50h+var_C]
		xor	[esi+18h], eax
		mov	eax, [esp+50h+var_8]
		xor	[esi+1Ch], eax
		mov	al, [esp+50h+var_3D]
		mov	ecx, [esp+50h+var_4]
		pop	edi
		mov	[esi], al
		xor	eax, eax
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 40h
		retn
_CRYPTO_ccm128_encrypt endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7A0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_ccm128_encrypt_ccm64
_CRYPTO_ccm128_encrypt_ccm64 proc near

var_3D		= byte ptr -3Dh
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	eax, 40h ; '@'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+40h+var_4], eax
		mov	eax, [esp+40h+arg_8]
		push	ebx
		mov	ebx, [esp+44h+arg_4]
		push	esi
		mov	esi, [esp+48h+arg_0]
		mov	[esp+48h+var_3C], eax
		mov	eax, [esp+48h+arg_10]
		mov	[esp+48h+var_30], eax
		mov	dl, [esi]
		mov	ecx, [esi+28h]
		mov	eax, [esi+2Ch]
		mov	[esp+48h+var_1C], esi
		mov	[esp+48h+var_2C], ebx
		mov	[esp+48h+var_3D], dl
		mov	[esp+48h+var_34], ecx
		mov	[esp+48h+var_38], eax
		push	edi
		test	dl, 40h
		jnz	short loc_808
		push	eax
		lea	eax, [esi+10h]
		push	eax
		push	esi
		call	ecx
		mov	dl, [esp+58h+var_3D]
		add	esp, 0Ch
		add	dword ptr [esi+20h], 1
		adc	dword ptr [esi+24h], 0

loc_808:				; CODE XREF: _CRYPTO_ccm128_encrypt_ccm64+4Fj
		movzx	eax, dl
		xor	ecx, ecx
		and	eax, 7
		mov	edx, 0Fh
		sub	edx, eax
		mov	[esi], al
		mov	[esp+4Ch+var_18], edx
		cmp	edx, 0Fh
		jnb	short loc_835

loc_822:				; CODE XREF: _CRYPTO_ccm128_encrypt_ccm64+93j
		movzx	eax, byte ptr [esi+edx]
		or	ecx, eax
		mov	byte ptr [esi+edx], 0
		inc	edx
		shl	ecx, 8
		cmp	edx, 0Fh
		jb	short loc_822

loc_835:				; CODE XREF: _CRYPTO_ccm128_encrypt_ccm64+80j
		movzx	eax, byte ptr [esi+0Fh]
		mov	edi, [esp+4Ch+arg_C]
		or	ecx, eax
		mov	byte ptr [esi+0Fh], 1
		cmp	ecx, edi
		jz	short loc_85C
		pop	edi
		pop	esi
		or	eax, 0FFFFFFFFh
		pop	ebx
		mov	ecx, [esp+40h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 40h
		retn
; ---------------------------------------------------------------------------

loc_85C:				; CODE XREF: _CRYPTO_ccm128_encrypt_ccm64+A5j
		lea	eax, [edi+0Fh]
		or	eax, 8
		shr	eax, 3
		add	[esi+20h], eax
		adc	dword ptr [esi+24h], 0
		cmp	dword ptr [esi+24h], 20000000h
		jb	short loc_894
		ja	short loc_87D
		cmp	dword ptr [esi+20h], 0
		jbe	short loc_894

loc_87D:				; CODE XREF: _CRYPTO_ccm128_encrypt_ccm64+D5j
		pop	edi
		pop	esi
		mov	eax, 0FFFFFFFEh
		pop	ebx
		mov	ecx, [esp+40h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 40h
		retn
; ---------------------------------------------------------------------------

loc_894:				; CODE XREF: _CRYPTO_ccm128_encrypt_ccm64+D3j
					; _CRYPTO_ccm128_encrypt_ccm64+DBj
		push	ebp
		mov	ebp, edi
		shr	ebp, 4
		test	ebp, ebp
		jz	short loc_8DA
		lea	eax, [esi+10h]
		push	eax
		push	esi
		push	[esp+58h+var_38]
		push	ebp
		push	[esp+60h+var_3C]
		push	ebx
		call	[esp+68h+var_30]
		shl	ebp, 4
		add	esp, 18h
		add	[esp+50h+var_3C], ebp
		add	ebx, ebp
		sub	edi, ebp
		mov	[esp+50h+var_2C], ebx
		mov	[esp+50h+arg_C], edi
		jz	loc_9E4
		shr	ebp, 4
		push	ebp
		push	esi
		call	_ctr64_add
		add	esp, 8

loc_8DA:				; CODE XREF: _CRYPTO_ccm128_encrypt_ccm64+FCj
		test	edi, edi
		jz	loc_9E4
		xor	ecx, ecx
		test	edi, edi
		jz	short loc_8F4

loc_8E8:				; CODE XREF: _CRYPTO_ccm128_encrypt_ccm64+152j
		mov	al, [ebx+ecx]
		xor	[esi+ecx+10h], al
		inc	ecx
		cmp	ecx, edi
		jb	short loc_8E8

loc_8F4:				; CODE XREF: _CRYPTO_ccm128_encrypt_ccm64+146j
		mov	ebp, [esp+50h+var_38]
		lea	eax, [esi+10h]
		push	ebp
		push	eax
		push	eax
		call	[esp+5Ch+var_34]
		push	ebp
		lea	eax, [esp+60h+var_14]
		push	eax
		push	esi
		call	[esp+68h+var_34]
		add	esp, 18h
		xor	edx, edx
		test	edi, edi
		jz	loc_9E8
		mov	ebp, [esp+50h+var_3C]
		cmp	edi, 20h ; ' '
		jb	loc_9C5
		lea	ecx, [ebp-1]
		lea	eax, [esp+edi+50h+var_18+3]
		add	ecx, edi
		cmp	ebp, eax
		ja	short loc_940
		lea	eax, [esp+50h+var_14]
		cmp	ecx, eax
		jnb	loc_9C5

loc_940:				; CODE XREF: _CRYPTO_ccm128_encrypt_ccm64+192j
		lea	eax, [ebx-1]
		add	eax, edi
		cmp	ebp, eax
		ja	short loc_94D
		cmp	ecx, ebx
		jnb	short loc_9C5

loc_94D:				; CODE XREF: _CRYPTO_ccm128_encrypt_ccm64+1A7j
		mov	esi, ebp
		mov	eax, edi
		sub	esi, ebx
		and	eax, 1Fh
		mov	[esp+50h+var_30], esi
		mov	ecx, edi
		lea	esi, [esp+50h+var_14]
		sub	ecx, eax
		sub	esi, ebx
		mov	eax, ebx
		mov	[esp+50h+var_28], esi
		lea	esi, [esp+50h+var_4]
		mov	edi, [esp+50h+var_28]
		sub	esi, ebx
		lea	ebx, [ebp+10h]
		mov	[esp+50h+var_24], esi
		mov	ebp, [esp+50h+var_30]
		mov	[esp+50h+var_20], ebx
		mov	ebx, esi

loc_985:				; CODE XREF: _CRYPTO_ccm128_encrypt_ccm64+217j
		movups	xmm0, xmmword ptr [eax]
		mov	esi, [esp+50h+var_20]
		lea	eax, [eax+20h]
		movups	xmm1, xmmword ptr [edi+eax-20h]
		pxor	xmm1, xmm0
		movups	xmmword	ptr [eax+ebp-20h], xmm1
		movups	xmm0, xmmword ptr [eax-10h]
		movups	xmm1, xmmword ptr [ebx+eax-20h]
		pxor	xmm1, xmm0
		movups	xmmword	ptr [esi+edx], xmm1
		mov	esi, [esp+50h+var_1C]
		add	edx, 20h ; ' '
		cmp	edx, ecx
		jb	short loc_985
		mov	edi, [esp+50h+arg_C]
		mov	ebx, [esp+50h+var_2C]
		mov	ebp, [esp+50h+var_3C]

loc_9C5:				; CODE XREF: _CRYPTO_ccm128_encrypt_ccm64+181j
					; _CRYPTO_ccm128_encrypt_ccm64+19Aj ...
		cmp	edx, edi
		jnb	short loc_9E4
		lea	eax, [esp+50h+var_14]
		sub	ebx, eax
		sub	ebp, eax

loc_9D1:				; CODE XREF: _CRYPTO_ccm128_encrypt_ccm64+242j
		lea	ecx, [esp+50h+var_14]
		add	ecx, edx
		inc	edx
		mov	al, [ebx+ecx]
		xor	al, [ecx]
		mov	[ecx+ebp], al
		cmp	edx, edi
		jb	short loc_9D1

loc_9E4:				; CODE XREF: _CRYPTO_ccm128_encrypt_ccm64+127j
					; _CRYPTO_ccm128_encrypt_ccm64+13Cj ...
		mov	ebp, [esp+50h+var_38]

loc_9E8:				; CODE XREF: _CRYPTO_ccm128_encrypt_ccm64+174j
		mov	edx, [esp+50h+var_18]
		cmp	edx, 10h
		jnb	short loc_A0B
		mov	ecx, 10h
		lea	edi, [edx+esi]
		sub	ecx, edx
		xor	eax, eax
		mov	edx, ecx
		shr	ecx, 2
		rep stosd
		mov	ecx, edx
		and	ecx, 3
		rep stosb

loc_A0B:				; CODE XREF: _CRYPTO_ccm128_encrypt_ccm64+24Fj
		push	ebp
		lea	eax, [esp+54h+var_14]
		push	eax
		push	esi
		call	[esp+5Ch+var_34]
		mov	eax, [esp+5Ch+var_14]
		add	esp, 0Ch
		xor	[esi+10h], eax
		mov	eax, [esp+50h+var_10]
		xor	[esi+14h], eax
		mov	eax, [esp+50h+var_C]
		xor	[esi+18h], eax
		mov	eax, [esp+50h+var_8]
		xor	[esi+1Ch], eax
		mov	al, [esp+50h+var_3D]
		mov	ecx, [esp+50h+var_4]
		pop	ebp
		pop	edi
		mov	[esi], al
		xor	eax, eax
		pop	esi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 40h
		retn
_CRYPTO_ccm128_encrypt_ccm64 endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A50h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_ccm128_init
_CRYPTO_ccm128_init proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= byte ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	ecx, [esp+arg_4]
		xorps	xmm0, xmm0
		mov	edx, [esp+arg_0]
		mov	al, [esp+arg_8]
		dec	al
		lea	ecx, [ecx-2]
		and	al, 7
		shr	ecx, 1
		and	cl, 7
		movups	xmmword	ptr [edx], xmm0
		shl	cl, 3
		or	cl, al
		mov	dword ptr [edx+20h], 0
		mov	eax, [esp+arg_10]
		mov	[edx+28h], eax
		mov	eax, [esp+arg_C]
		mov	[edx], cl
		mov	dword ptr [edx+24h], 0
		mov	[edx+2Ch], eax
		retn
_CRYPTO_ccm128_init endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A94h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl CRYPTO_ccm128_setiv(int, void *Src, int, int)
		public _CRYPTO_ccm128_setiv
_CRYPTO_ccm128_setiv proc near

arg_0		= dword	ptr  4
Src		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	edx, [esp+arg_0]
		push	ebx
		push	esi
		mov	esi, 0Eh
		mov	bl, [edx]
		movzx	eax, bl
		and	eax, 7
		sub	esi, eax
		cmp	[esp+8+arg_8], esi
		jnb	short loc_AB5
		pop	esi
		or	eax, 0FFFFFFFFh
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_AB5:				; CODE XREF: _CRYPTO_ccm128_setiv+19j
		mov	ecx, [esp+8+arg_C]
		and	bl, 0BFh
		mov	dword ptr [edx+0Ch], 0
		mov	eax, ecx
		shr	eax, 18h
		mov	[edx+0Ch], al
		mov	eax, ecx
		shr	eax, 10h
		mov	[edx+0Dh], al
		mov	eax, ecx
		shr	eax, 8
		push	esi		; Size
		push	[esp+0Ch+Src]	; Src
		mov	[edx+0Eh], al
		lea	eax, [edx+1]
		push	eax		; Dst
		mov	dword ptr [edx+8], 0
		mov	[edx+0Fh], cl
		mov	[edx], bl
		call	_memcpy
		add	esp, 0Ch
		xor	eax, eax
		pop	esi
		pop	ebx
		retn
_CRYPTO_ccm128_setiv endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B00h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl CRYPTO_ccm128_tag(int, void *Dst,	int)
		public _CRYPTO_ccm128_tag
_CRYPTO_ccm128_tag proc	near

arg_0		= dword	ptr  4
Dst		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		push	esi
		movzx	eax, byte ptr [ecx]
		shr	eax, 3
		and	eax, 7
		lea	esi, ds:2[eax*2]
		cmp	[esp+4+arg_8], esi
		jnb	short loc_B1F
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_B1F:				; CODE XREF: _CRYPTO_ccm128_tag+19j
		push	esi		; Size
		add	ecx, 10h
		push	ecx		; Src
		push	[esp+0Ch+Dst]	; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, esi
		pop	esi
		retn
_CRYPTO_ccm128_tag endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B34h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ctr64_add	proc near		; CODE XREF: _CRYPTO_ccm128_decrypt_ccm64+DEp
					; _CRYPTO_ccm128_encrypt_ccm64+132p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		mov	ebx, [esp+4+arg_4]
		xor	eax, eax
		push	esi
		push	edi
		mov	edi, [esp+0Ch+arg_0]
		mov	esi, 8

loc_B46:				; CODE XREF: _ctr64_add+2Fj
					; _ctr64_add+33j
		movzx	ecx, byte ptr [esi+edi+7]
		dec	esi
		add	eax, ecx
		movzx	edx, bl
		add	eax, edx
		shr	ebx, 8
		mov	[esi+edi+8], al
		shr	eax, 8
		test	esi, esi
		jz	short loc_B69
		test	ebx, ebx
		jnz	short loc_B46
		test	eax, eax
		jnz	short loc_B46

loc_B69:				; CODE XREF: _ctr64_add+2Bj
		pop	edi
		pop	esi
		pop	ebx
		retn
_ctr64_add	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B70h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ctr64_inc	proc near

arg_0		= dword	ptr  4

		mov	edx, [esp+arg_0]
		mov	eax, 8
		nop	dword ptr [eax+00000000h]

loc_B80:				; CODE XREF: _ctr64_inc+1Aj
		dec	eax
		add	byte ptr [eax+edx+8], 1
		jnz	short locret_B8C
		test	eax, eax
		jnz	short loc_B80

locret_B8C:				; CODE XREF: _ctr64_inc+16j
		retn
_ctr64_inc	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: _CRYPTO_ccm128_decrypt+A2p
					; _CRYPTO_ccm128_decrypt+21Cp ...
		extrn __chkstk:near	; CODE XREF: _CRYPTO_ccm128_decrypt+5p
					; _CRYPTO_ccm128_decrypt_ccm64+5p ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _CRYPTO_ccm128_setiv+5Cp
					; _CRYPTO_ccm128_tag+28p
		extrn ___security_cookie:near ;	DATA XREF: _CRYPTO_ccm128_decrypt+Ar
					; _CRYPTO_ccm128_decrypt_ccm64+Ar ...


		end
