;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	CE51CF3957EAA18A051614FF242345CA
; Input	CRC32 :	185E1BA0

; File Name   :	C:\compspace\Diff\openssl\obj\ec_lib.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		public _EC_version
_EC_version	db 'EC part of OpenSSL 1.0.2h  3 May 2016',0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 28h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_EX_DATA_clear_free_all_data
_EC_EX_DATA_clear_free_all_data	proc near ; CODE XREF: _EC_GROUP_clear_free+27p

arg_0		= dword	ptr  4

		push	ebx
		mov	ebx, [esp+4+arg_0]
		test	ebx, ebx
		jz	short loc_5A
		push	esi
		mov	esi, [ebx]
		test	esi, esi
		jz	short loc_53
		push	edi

loc_39:					; CODE XREF: _EC_EX_DATA_clear_free_all_data+28j
		push	dword ptr [esi+4]
		mov	eax, [esi+10h]
		mov	edi, [esi]
		call	eax
		push	esi
		call	_CRYPTO_free
		add	esp, 8
		mov	esi, edi
		test	edi, edi
		jnz	short loc_39
		pop	edi

loc_53:					; CODE XREF: _EC_EX_DATA_clear_free_all_data+Ej
		mov	dword ptr [ebx], 0
		pop	esi

loc_5A:					; CODE XREF: _EC_EX_DATA_clear_free_all_data+7j
		pop	ebx
		retn
_EC_EX_DATA_clear_free_all_data	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_EX_DATA_clear_free_data
_EC_EX_DATA_clear_free_data proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	edi
		mov	edi, [esp+4+arg_0]
		test	edi, edi
		jz	short loc_AE
		cmp	dword ptr [edi], 0
		jz	short loc_AE
		mov	ecx, [esp+4+arg_C]
		mov	edx, [esp+4+arg_8]
		push	esi
		mov	esi, [esp+8+arg_4]
		nop	dword ptr [eax+eax+00h]

loc_7C:					; CODE XREF: _EC_EX_DATA_clear_free_data+36j
		mov	eax, [edi]
		cmp	[eax+8], esi
		jnz	short loc_8D
		cmp	[eax+0Ch], edx
		jnz	short loc_8D
		cmp	[eax+10h], ecx
		jz	short loc_97

loc_8D:					; CODE XREF: _EC_EX_DATA_clear_free_data+25j
					; _EC_EX_DATA_clear_free_data+2Aj
		mov	edi, eax
		cmp	dword ptr [edi], 0
		jnz	short loc_7C
		pop	esi
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_97:					; CODE XREF: _EC_EX_DATA_clear_free_data+2Fj
		mov	esi, [eax]
		push	dword ptr [eax+4]
		mov	eax, [eax+10h]
		call	eax
		push	dword ptr [edi]
		call	_CRYPTO_free
		add	esp, 8
		mov	[edi], esi
		pop	esi

loc_AE:					; CODE XREF: _EC_EX_DATA_clear_free_data+7j
					; _EC_EX_DATA_clear_free_data+Cj
		pop	edi
		retn
_EC_EX_DATA_clear_free_data endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_EX_DATA_free_all_data
_EC_EX_DATA_free_all_data proc near	; CODE XREF: _EC_GROUP_copy+61p
					; _EC_GROUP_free+20p

arg_0		= dword	ptr  4

		push	ebx
		mov	ebx, [esp+4+arg_0]
		test	ebx, ebx
		jz	short loc_E2
		push	esi
		mov	esi, [ebx]
		test	esi, esi
		jz	short loc_DB
		push	edi

loc_C1:					; CODE XREF: _EC_EX_DATA_free_all_data+28j
		push	dword ptr [esi+4]
		mov	eax, [esi+0Ch]
		mov	edi, [esi]
		call	eax
		push	esi
		call	_CRYPTO_free
		add	esp, 8
		mov	esi, edi
		test	edi, edi
		jnz	short loc_C1
		pop	edi

loc_DB:					; CODE XREF: _EC_EX_DATA_free_all_data+Ej
		mov	dword ptr [ebx], 0
		pop	esi

loc_E2:					; CODE XREF: _EC_EX_DATA_free_all_data+7j
		pop	ebx
		retn
_EC_EX_DATA_free_all_data endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_EX_DATA_free_data
_EC_EX_DATA_free_data proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	edi
		mov	edi, [esp+4+arg_0]
		test	edi, edi
		jz	short loc_136
		cmp	dword ptr [edi], 0
		jz	short loc_136
		mov	ecx, [esp+4+arg_C]
		mov	edx, [esp+4+arg_8]
		push	esi
		mov	esi, [esp+8+arg_4]
		nop	dword ptr [eax+eax+00h]

loc_104:				; CODE XREF: _EC_EX_DATA_free_data+36j
		mov	eax, [edi]
		cmp	[eax+8], esi
		jnz	short loc_115
		cmp	[eax+0Ch], edx
		jnz	short loc_115
		cmp	[eax+10h], ecx
		jz	short loc_11F

loc_115:				; CODE XREF: _EC_EX_DATA_free_data+25j
					; _EC_EX_DATA_free_data+2Aj
		mov	edi, eax
		cmp	dword ptr [edi], 0
		jnz	short loc_104
		pop	esi
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_11F:				; CODE XREF: _EC_EX_DATA_free_data+2Fj
		mov	esi, [eax]
		push	dword ptr [eax+4]
		mov	eax, [eax+0Ch]
		call	eax
		push	dword ptr [edi]
		call	_CRYPTO_free
		add	esp, 8
		mov	[edi], esi
		pop	esi

loc_136:				; CODE XREF: _EC_EX_DATA_free_data+7j
					; _EC_EX_DATA_free_data+Cj
		pop	edi
		retn
_EC_EX_DATA_free_data endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 138h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_EX_DATA_get_data
_EC_EX_DATA_get_data proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, [esp+arg_0]
		push	esi
		test	eax, eax
		jz	short loc_162
		mov	ecx, [esp+4+arg_C]
		mov	edx, [esp+4+arg_8]
		mov	esi, [esp+4+arg_4]

loc_14D:				; CODE XREF: _EC_EX_DATA_get_data+28j
		cmp	[eax+8], esi
		jnz	short loc_15C
		cmp	[eax+0Ch], edx
		jnz	short loc_15C
		cmp	[eax+10h], ecx
		jz	short loc_166

loc_15C:				; CODE XREF: _EC_EX_DATA_get_data+18j
					; _EC_EX_DATA_get_data+1Dj
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_14D

loc_162:				; CODE XREF: _EC_EX_DATA_get_data+7j
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_166:				; CODE XREF: _EC_EX_DATA_get_data+22j
		mov	eax, [eax+4]
		pop	esi
		retn
_EC_EX_DATA_get_data endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 16Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_EX_DATA_set_data
_EC_EX_DATA_set_data proc near		; CODE XREF: _EC_GROUP_copy+8Ep

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		push	ebp
		mov	ebp, [esp+4+arg_0]
		test	ebp, ebp
		jnz	short loc_179
		xor	eax, eax
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_179:				; CODE XREF: _EC_EX_DATA_set_data+7j
		mov	eax, [ebp+0]
		push	ebx
		mov	ebx, [esp+8+arg_8]
		push	esi
		mov	esi, [esp+0Ch+arg_10]
		push	edi
		mov	edi, [esp+10h+arg_C]
		test	eax, eax
		jz	short loc_1A4

loc_18F:				; CODE XREF: _EC_EX_DATA_set_data+36j
		cmp	[eax+8], ebx
		jnz	short loc_19E
		cmp	[eax+0Ch], edi
		jnz	short loc_19E
		cmp	[eax+10h], esi
		jz	short loc_1E7

loc_19E:				; CODE XREF: _EC_EX_DATA_set_data+26j
					; _EC_EX_DATA_set_data+2Bj
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_18F

loc_1A4:				; CODE XREF: _EC_EX_DATA_set_data+21j
		cmp	[esp+10h+arg_4], 0
		jz	short loc_1DD
		push	242h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	14h
		call	_CRYPTO_malloc
		mov	ecx, eax
		add	esp, 0Ch
		test	ecx, ecx
		jz	short loc_202
		mov	eax, [esp+10h+arg_4]
		mov	[ecx+4], eax
		mov	[ecx+8], ebx
		mov	[ecx+0Ch], edi
		mov	[ecx+10h], esi
		mov	eax, [ebp+0]
		mov	[ecx], eax
		mov	[ebp+0], ecx

loc_1DD:				; CODE XREF: _EC_EX_DATA_set_data+3Dj
		pop	edi
		pop	esi
		pop	ebx
		mov	eax, 1
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1E7:				; CODE XREF: _EC_EX_DATA_set_data+30j
		push	239h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	6Ch ; 'l'
		push	0D3h ; 'Ó'
		push	10h
		call	_ERR_put_error
		add	esp, 14h

loc_202:				; CODE XREF: _EC_EX_DATA_set_data+57j
		pop	edi
		pop	esi
		pop	ebx
		xor	eax, eax
		pop	ebp
		retn
_EC_EX_DATA_set_data endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 20Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_check_discriminant
_EC_GROUP_check_discriminant proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	eax, [eax+24h]
		test	eax, eax
		jnz	short loc_237
		push	1DDh
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	0ABh ; '«'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_237:				; CODE XREF: _EC_GROUP_check_discriminant+Bj
		mov	[esp+arg_0], ecx
		jmp	eax
_EC_GROUP_check_discriminant endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 240h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_clear_free
_EC_GROUP_clear_free proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	loc_2FF
		mov	ecx, [esi]
		mov	eax, [ecx+10h]
		test	eax, eax
		jnz	short loc_25D
		mov	eax, [ecx+0Ch]
		test	eax, eax
		jz	short loc_263

loc_25D:				; CODE XREF: _EC_GROUP_clear_free+14j
		push	esi
		call	eax
		add	esp, 4

loc_263:				; CODE XREF: _EC_GROUP_clear_free+1Bj
		lea	eax, [esi+44h]
		push	eax
		call	_EC_EX_DATA_clear_free_all_data
		add	esp, 4
		test	dword ptr [esi+34h], 80000000h
		jz	short loc_28B
		mov	eax, [esi+0ACh]
		test	eax, eax
		jz	short loc_28B
		push	eax
		call	_BN_MONT_CTX_free
		add	esp, 4

loc_28B:				; CODE XREF: _EC_GROUP_clear_free+36j
					; _EC_GROUP_clear_free+40j
		push	edi
		mov	edi, [esi+4]
		test	edi, edi
		jz	short loc_2BA
		mov	ecx, [edi]
		mov	eax, [ecx+30h]
		test	eax, eax
		jnz	short loc_2A3
		mov	eax, [ecx+2Ch]
		test	eax, eax
		jz	short loc_2A9

loc_2A3:				; CODE XREF: _EC_GROUP_clear_free+5Aj
		push	edi
		call	eax
		add	esp, 4

loc_2A9:				; CODE XREF: _EC_GROUP_clear_free+61j
		push	44h ; 'D'
		push	edi
		call	_OPENSSL_cleanse
		push	edi
		call	_CRYPTO_free
		add	esp, 0Ch

loc_2BA:				; CODE XREF: _EC_GROUP_clear_free+51j
		lea	eax, [esi+8]
		push	eax
		call	_BN_clear_free
		lea	eax, [esi+1Ch]
		push	eax
		call	_BN_clear_free
		mov	eax, [esi+3Ch]
		add	esp, 8
		pop	edi
		test	eax, eax
		jz	short loc_2EB
		push	dword ptr [esi+40h]
		push	eax
		call	_OPENSSL_cleanse
		push	dword ptr [esi+3Ch]
		call	_CRYPTO_free
		add	esp, 0Ch

loc_2EB:				; CODE XREF: _EC_GROUP_clear_free+95j
		push	0B0h ; '°'
		push	esi
		call	_OPENSSL_cleanse
		push	esi
		call	_CRYPTO_free
		add	esp, 0Ch

loc_2FF:				; CODE XREF: _EC_GROUP_clear_free+7j
		pop	esi
		retn
_EC_GROUP_clear_free endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 304h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_cmp
_EC_GROUP_cmp	proc near

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 10h
		call	__chkstk
		push	ebx
		mov	ebx, [esp+14h+arg_4]
		push	ebp
		push	edi
		mov	edi, [esp+1Ch+arg_0]
		xor	ebp, ebp
		mov	ecx, [ebx]
		mov	eax, [edi]
		mov	eax, [eax+4]
		cmp	eax, [ecx+4]
		jz	short loc_333

loc_327:				; CODE XREF: _EC_GROUP_cmp+3Fj
		pop	edi
		pop	ebp
		mov	eax, 1
		pop	ebx
		add	esp, 10h
		retn
; ---------------------------------------------------------------------------

loc_333:				; CODE XREF: _EC_GROUP_cmp+21j
		mov	eax, [edi+30h]
		test	eax, eax
		jz	short loc_345
		mov	ecx, [ebx+30h]
		test	ecx, ecx
		jz	short loc_345
		cmp	eax, ecx
		jnz	short loc_327

loc_345:				; CODE XREF: _EC_GROUP_cmp+34j
					; _EC_GROUP_cmp+3Bj
		push	esi
		mov	esi, [esp+20h+arg_8]
		test	esi, esi
		jnz	short loc_35F
		call	_BN_CTX_new
		mov	esi, eax
		mov	ebp, esi
		test	esi, esi
		jz	loc_4D3

loc_35F:				; CODE XREF: _EC_GROUP_cmp+48j
		push	esi
		call	_BN_CTX_start
		push	esi
		call	_BN_CTX_get
		push	esi
		mov	[esp+2Ch+arg_4], eax
		call	_BN_CTX_get
		push	esi
		mov	[esp+30h+var_10], eax
		call	_BN_CTX_get
		push	esi
		mov	[esp+34h+var_4], eax
		call	_BN_CTX_get
		push	esi
		mov	[esp+38h+arg_0], eax
		call	_BN_CTX_get
		push	esi
		mov	[esp+3Ch+var_C], eax
		call	_BN_CTX_get
		add	esp, 1Ch
		mov	[esp+20h+var_8], eax
		push	esi
		test	eax, eax
		jz	loc_4BE
		push	[esp+24h+var_4]
		mov	eax, [edi]
		push	[esp+28h+var_10]
		push	[esp+2Ch+arg_4]
		mov	eax, [eax+1Ch]
		push	edi
		call	eax
		add	esp, 14h
		test	eax, eax
		jz	loc_4B6
		mov	eax, [ebx]
		push	esi
		push	[esp+24h+var_8]
		push	[esp+28h+var_C]
		mov	eax, [eax+1Ch]
		push	[esp+2Ch+arg_0]
		push	ebx
		call	eax
		add	esp, 14h
		test	eax, eax
		jz	loc_4B6
		push	[esp+20h+arg_0]
		push	[esp+24h+arg_4]
		call	_BN_cmp
		add	esp, 8
		test	eax, eax
		jnz	loc_4B6
		push	[esp+20h+var_C]
		push	[esp+24h+var_10]
		call	_BN_cmp
		add	esp, 8
		test	eax, eax
		jnz	loc_4B6
		push	[esp+20h+var_8]
		push	[esp+24h+var_4]
		call	_BN_cmp
		add	esp, 8
		test	eax, eax
		jnz	loc_4B6
		push	esi
		push	dword ptr [ebx+4]
		push	dword ptr [edi+4]
		push	edi
		call	_EC_POINT_cmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_4B6
		push	esi
		push	[esp+24h+arg_4]
		push	edi
		call	_EC_GROUP_get_order
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_4BD
		push	esi
		push	[esp+24h+arg_0]
		push	ebx
		call	_EC_GROUP_get_order
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_4BD
		push	esi
		push	[esp+24h+var_10]
		push	edi
		call	_EC_GROUP_get_cofactor
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_4BD
		mov	edi, [esp+20h+var_C]
		push	esi
		push	edi
		push	ebx
		call	_EC_GROUP_get_cofactor
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_4BD
		push	[esp+20h+arg_0]
		push	[esp+24h+arg_4]
		call	_BN_cmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_4B6
		push	edi
		push	[esp+24h+var_10]
		call	_BN_cmp
		add	esp, 8
		test	eax, eax
		jz	short loc_4DE

loc_4B6:				; CODE XREF: _EC_GROUP_cmp+C2j
					; _EC_GROUP_cmp+E2j ...
		mov	ebx, 1
		jmp	short loc_4E0
; ---------------------------------------------------------------------------

loc_4BD:				; CODE XREF: _EC_GROUP_cmp+154j
					; _EC_GROUP_cmp+166j ...
		push	esi

loc_4BE:				; CODE XREF: _EC_GROUP_cmp+A3j
		call	_BN_CTX_end
		add	esp, 4
		test	ebp, ebp
		jz	short loc_4D3
		push	esi
		call	_BN_CTX_free
		add	esp, 4

loc_4D3:				; CODE XREF: _EC_GROUP_cmp+55j
					; _EC_GROUP_cmp+1C4j
		pop	esi
		pop	edi
		pop	ebp
		or	eax, 0FFFFFFFFh
		pop	ebx
		add	esp, 10h
		retn
; ---------------------------------------------------------------------------

loc_4DE:				; CODE XREF: _EC_GROUP_cmp+1B0j
		xor	ebx, ebx

loc_4E0:				; CODE XREF: _EC_GROUP_cmp+1B7j
		push	esi
		call	_BN_CTX_end
		add	esp, 4
		test	ebp, ebp
		jz	short loc_4F6
		push	esi
		call	_BN_CTX_free
		add	esp, 4

loc_4F6:				; CODE XREF: _EC_GROUP_cmp+1E7j
		pop	esi
		pop	edi
		pop	ebp
		mov	eax, ebx
		pop	ebx
		add	esp, 10h
		retn
_EC_GROUP_cmp	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 500h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_copy
_EC_GROUP_copy	proc near		; CODE XREF: _EC_GROUP_dup+20p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, [esi]
		cmp	dword ptr [eax+14h], 0
		jnz	short loc_529
		push	0B0h ; '°'
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	6Ah ; 'j'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_529:				; CODE XREF: _EC_GROUP_copy+Bj
		push	ebx
		mov	ebx, [esp+8+arg_4]
		cmp	eax, [ebx]
		jz	short loc_54F
		push	0B4h ; '´'
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	65h ; 'e'
		push	6Ah ; 'j'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	ebx
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_54F:				; CODE XREF: _EC_GROUP_copy+30j
		cmp	esi, ebx
		jnz	short loc_55B
		pop	ebx
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_55B:				; CODE XREF: _EC_GROUP_copy+51j
		push	ebp
		push	edi
		lea	ebp, [esi+44h]
		push	ebp
		call	_EC_EX_DATA_free_all_data
		mov	edi, [ebx+44h]
		add	esp, 4
		test	edi, edi
		jz	short loc_5A4

loc_570:				; CODE XREF: _EC_GROUP_copy+A2j
		push	dword ptr [edi+4]
		mov	eax, [edi+8]
		call	eax
		add	esp, 4
		test	eax, eax
		jz	loc_63F
		push	dword ptr [edi+10h]
		push	dword ptr [edi+0Ch]
		push	dword ptr [edi+8]
		push	eax
		push	ebp
		call	_EC_EX_DATA_set_data
		add	esp, 14h
		test	eax, eax
		jz	loc_63F
		mov	edi, [edi]
		test	edi, edi
		jnz	short loc_570

loc_5A4:				; CODE XREF: _EC_GROUP_copy+6Ej
		test	dword ptr [ebx+34h], 80000000h
		jz	short loc_5EB
		cmp	dword ptr [ebx+0ACh], 0
		jz	short loc_5EB
		cmp	dword ptr [esi+0ACh], 0
		jnz	short loc_5CE
		call	_BN_MONT_CTX_new
		mov	[esi+0ACh], eax
		test	eax, eax
		jz	short loc_63F

loc_5CE:				; CODE XREF: _EC_GROUP_copy+BDj
		push	dword ptr [ebx+0ACh]
		push	dword ptr [esi+0ACh]
		call	_BN_MONT_CTX_copy
		add	esp, 8
		test	eax, eax
		jnz	short loc_611
		pop	edi
		pop	ebp
		pop	ebx
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_5EB:				; CODE XREF: _EC_GROUP_copy+ABj
					; _EC_GROUP_copy+B4j
		test	dword ptr [esi+34h], 80000000h
		jz	short loc_611
		mov	eax, [esi+0ACh]
		test	eax, eax
		jz	short loc_611
		push	eax
		call	_BN_MONT_CTX_free
		add	esp, 4
		mov	dword ptr [esi+0ACh], 0

loc_611:				; CODE XREF: _EC_GROUP_copy+E4j
					; _EC_GROUP_copy+F2j ...
		cmp	dword ptr [ebx+4], 0
		jz	short loc_646
		cmp	dword ptr [esi+4], 0
		jnz	short loc_62D
		push	esi
		call	_EC_POINT_new
		add	esp, 4
		mov	[esi+4], eax
		test	eax, eax
		jz	short loc_63F

loc_62D:				; CODE XREF: _EC_GROUP_copy+11Bj
		push	dword ptr [ebx+4]
		push	dword ptr [esi+4]
		call	_EC_POINT_copy
		add	esp, 8
		test	eax, eax
		jnz	short loc_65D

loc_63F:				; CODE XREF: _EC_GROUP_copy+7Dj
					; _EC_GROUP_copy+98j ...
		pop	edi
		pop	ebp
		pop	ebx
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_646:				; CODE XREF: _EC_GROUP_copy+115j
		mov	eax, [esi+4]
		test	eax, eax
		jz	short loc_65D
		push	eax
		call	_EC_POINT_clear_free
		add	esp, 4
		mov	dword ptr [esi+4], 0

loc_65D:				; CODE XREF: _EC_GROUP_copy+13Dj
					; _EC_GROUP_copy+14Bj
		lea	eax, [ebx+8]
		push	eax
		lea	eax, [esi+8]
		push	eax
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jz	short loc_63F
		lea	eax, [ebx+1Ch]
		push	eax
		lea	eax, [esi+1Ch]
		push	eax
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jz	short loc_63F
		mov	eax, [ebx+30h]
		mov	[esi+30h], eax
		mov	eax, [ebx+34h]
		mov	[esi+34h], eax
		mov	eax, [ebx+38h]
		mov	[esi+38h], eax
		cmp	dword ptr [ebx+3Ch], 0
		mov	eax, [esi+3Ch]
		jz	short loc_6FB
		test	eax, eax
		jz	short loc_6AD
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_6AD:				; CODE XREF: _EC_GROUP_copy+1A2j
		push	0F3h ; 'ó'
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	dword ptr [ebx+40h]
		call	_CRYPTO_malloc
		add	esp, 0Ch
		mov	[esi+3Ch], eax
		test	eax, eax
		jz	loc_63F
		push	dword ptr [ebx+40h] ; Size
		push	dword ptr [ebx+3Ch] ; Src
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		test	eax, eax
		jz	loc_63F
		mov	eax, [ebx+40h]
		mov	[esi+40h], eax
		mov	eax, [esi]
		push	ebx
		push	esi
		mov	eax, [eax+14h]
		call	eax
		add	esp, 8
		pop	edi
		pop	ebp
		pop	ebx
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_6FB:				; CODE XREF: _EC_GROUP_copy+19Ej
		test	eax, eax
		jz	short loc_708
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_708:				; CODE XREF: _EC_GROUP_copy+1FDj
		mov	eax, [esi]
		mov	dword ptr [esi+3Ch], 0
		mov	dword ptr [esi+40h], 0
		push	ebx
		mov	eax, [eax+14h]
		push	esi
		call	eax
		add	esp, 8
		pop	edi
		pop	ebp
		pop	ebx
		pop	esi
		retn
_EC_GROUP_copy	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 728h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_dup
_EC_GROUP_dup	proc near

arg_0		= dword	ptr  4

		push	edi
		mov	edi, [esp+4+arg_0]
		test	edi, edi
		jnz	short loc_735
		xor	eax, eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_735:				; CODE XREF: _EC_GROUP_dup+7j
		push	esi
		push	dword ptr [edi]
		call	_EC_GROUP_new
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jz	short loc_75D
		push	edi
		push	esi
		call	_EC_GROUP_copy
		add	esp, 8
		test	eax, eax
		jnz	short loc_762
		push	esi
		call	_EC_GROUP_free
		add	esp, 4

loc_75D:				; CODE XREF: _EC_GROUP_dup+1Cj
		pop	esi
		xor	eax, eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_762:				; CODE XREF: _EC_GROUP_dup+2Aj
		mov	eax, esi
		pop	esi
		pop	edi
		retn
_EC_GROUP_dup	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 768h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_free
_EC_GROUP_free	proc near		; CODE XREF: _EC_GROUP_dup+2Dp

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	loc_7FB
		mov	eax, [esi]
		mov	eax, [eax+0Ch]
		test	eax, eax
		jz	short loc_784
		push	esi
		call	eax
		add	esp, 4

loc_784:				; CODE XREF: _EC_GROUP_free+14j
		lea	eax, [esi+44h]
		push	eax
		call	_EC_EX_DATA_free_all_data
		add	esp, 4
		test	dword ptr [esi+34h], 80000000h
		jz	short loc_7AC
		mov	eax, [esi+0ACh]
		test	eax, eax
		jz	short loc_7AC
		push	eax
		call	_BN_MONT_CTX_free
		add	esp, 4

loc_7AC:				; CODE XREF: _EC_GROUP_free+2Fj
					; _EC_GROUP_free+39j
		push	edi
		mov	edi, [esi+4]
		test	edi, edi
		jz	short loc_7CC
		mov	eax, [edi]
		mov	eax, [eax+2Ch]
		test	eax, eax
		jz	short loc_7C3
		push	edi
		call	eax
		add	esp, 4

loc_7C3:				; CODE XREF: _EC_GROUP_free+53j
		push	edi
		call	_CRYPTO_free
		add	esp, 4

loc_7CC:				; CODE XREF: _EC_GROUP_free+4Aj
		lea	eax, [esi+8]
		push	eax
		call	_BN_free
		lea	eax, [esi+1Ch]
		push	eax
		call	_BN_free
		mov	eax, [esi+3Ch]
		add	esp, 8
		pop	edi
		test	eax, eax
		jz	short loc_7F2
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_7F2:				; CODE XREF: _EC_GROUP_free+7Fj
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_7FB:				; CODE XREF: _EC_GROUP_free+7j
		pop	esi
		retn
_EC_GROUP_free	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 800h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_get0_generator
_EC_GROUP_get0_generator proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+4]
		retn
_EC_GROUP_get0_generator endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 808h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_get0_seed
_EC_GROUP_get0_seed proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+3Ch]
		retn
_EC_GROUP_get0_seed endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 810h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_get_asn1_flag
_EC_GROUP_get_asn1_flag	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+34h]
		and	eax, 7FFFFFFFh
		retn
_EC_GROUP_get_asn1_flag	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 820h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_get_cofactor
_EC_GROUP_get_cofactor proc near	; CODE XREF: _EC_GROUP_cmp+16Ep
					; _EC_GROUP_cmp+181p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		lea	eax, [esi+1Ch]
		push	eax
		push	[esp+8+arg_4]
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jnz	short loc_83B
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_83B:				; CODE XREF: _EC_GROUP_get_cofactor+17j
		xor	eax, eax
		cmp	[esi+20h], eax
		pop	esi
		setnz	al
		retn
_EC_GROUP_get_cofactor endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 848h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_get_curve_GF2m
_EC_GROUP_get_curve_GF2m proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	eax, [eax+1Ch]
		test	eax, eax
		jnz	short loc_873
		push	1C9h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	0ACh ; '¬'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_873:				; CODE XREF: _EC_GROUP_get_curve_GF2m+Bj
		mov	[esp+arg_0], ecx
		jmp	eax
_EC_GROUP_get_curve_GF2m endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 87Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_get_curve_GFp
_EC_GROUP_get_curve_GFp	proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	eax, [eax+1Ch]
		test	eax, eax
		jnz	short loc_8A7
		push	1B2h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	82h ; '‚'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_8A7:				; CODE XREF: _EC_GROUP_get_curve_GFp+Bj
		mov	[esp+arg_0], ecx
		jmp	eax
_EC_GROUP_get_curve_GFp	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8B0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_get_curve_name
_EC_GROUP_get_curve_name proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+30h]
		retn
_EC_GROUP_get_curve_name endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8B8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_get_degree
_EC_GROUP_get_degree proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	eax, [eax+20h]
		test	eax, eax
		jnz	short loc_8E3
		push	1D3h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	0ADh ; '­'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_8E3:				; CODE XREF: _EC_GROUP_get_degree+Bj
		mov	[esp+arg_0], ecx
		jmp	eax
_EC_GROUP_get_degree endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8ECh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_get_mont_data
_EC_GROUP_get_mont_data	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	dword ptr [eax+34h], 80000000h
		jz	short loc_900
		mov	eax, [eax+0ACh]
		retn
; ---------------------------------------------------------------------------

loc_900:				; CODE XREF: _EC_GROUP_get_mont_data+Bj
		xor	eax, eax
		retn
_EC_GROUP_get_mont_data	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 904h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_get_order
_EC_GROUP_get_order proc near		; CODE XREF: _EC_GROUP_cmp+14Ap
					; _EC_GROUP_cmp+15Cp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		push	esi
		mov	esi, [esp+4+arg_4]
		add	eax, 8
		push	eax
		push	esi
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jnz	short loc_920
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_920:				; CODE XREF: _EC_GROUP_get_order+18j
		xor	eax, eax
		cmp	[esi+4], eax
		pop	esi
		setnz	al
		retn
_EC_GROUP_get_order endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 92Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_get_point_conversion_form
_EC_GROUP_get_point_conversion_form proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+38h]
		retn
_EC_GROUP_get_point_conversion_form endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 934h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_get_seed_len
_EC_GROUP_get_seed_len proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+40h]
		retn
_EC_GROUP_get_seed_len endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 93Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_have_precompute_mult
_EC_GROUP_have_precompute_mult proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	ecx, [eax]
		cmp	dword ptr [ecx+78h], 0
		jnz	short loc_951
		mov	[esp+arg_0], eax
		jmp	_ec_wNAF_have_precompute_mult
; ---------------------------------------------------------------------------

loc_951:				; CODE XREF: _EC_GROUP_have_precompute_mult+Aj
		mov	ecx, [ecx+80h]
		test	ecx, ecx
		jz	short loc_961
		mov	[esp+arg_0], eax
		jmp	ecx
; ---------------------------------------------------------------------------

loc_961:				; CODE XREF: _EC_GROUP_have_precompute_mult+1Dj
		xor	eax, eax
		retn
_EC_GROUP_have_precompute_mult endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 964h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_method_of
_EC_GROUP_method_of proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax]
		retn
_EC_GROUP_method_of endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 96Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_new
_EC_GROUP_new	proc near		; CODE XREF: _EC_GROUP_dup+10p

arg_0		= dword	ptr  4

		push	edi
		mov	edi, [esp+4+arg_0]
		test	edi, edi
		jnz	short loc_98E
		push	50h ; 'P'
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	6Ch ; 'l'
		push	6Ch ; 'l'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_98E:				; CODE XREF: _EC_GROUP_new+7j
		cmp	dword ptr [edi+8], 0
		jnz	short loc_9AD
		push	54h ; 'T'
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	6Ch ; 'l'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_9AD:				; CODE XREF: _EC_GROUP_new+26j
		push	esi
		push	58h ; 'X'
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	0B0h ; '°'
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jnz	short loc_9E2
		push	5Ah ; 'Z'
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	41h ; 'A'
		push	6Ch ; 'l'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_9E2:				; CODE XREF: _EC_GROUP_new+5Aj
		lea	eax, [esi+8]
		mov	[esi], edi
		push	eax
		mov	dword ptr [esi+44h], 0
		mov	dword ptr [esi+0ACh], 0
		mov	dword ptr [esi+4], 0
		call	_BN_init
		lea	eax, [esi+1Ch]
		push	eax
		call	_BN_init
		mov	dword ptr [esi+30h], 0
		mov	dword ptr [esi+34h], 80000000h
		mov	dword ptr [esi+38h], 4
		mov	dword ptr [esi+3Ch], 0
		mov	dword ptr [esi+40h], 0
		mov	eax, [edi+8]
		push	esi
		call	eax
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_A4C
		push	esi
		call	_CRYPTO_free
		add	esp, 4
		xor	eax, eax
		pop	esi
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_A4C:				; CODE XREF: _EC_GROUP_new+D0j
		mov	eax, esi
		pop	esi
		pop	edi
		retn
_EC_GROUP_new	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A54h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_precompute_mult
_EC_GROUP_precompute_mult proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	ecx, [eax]
		cmp	dword ptr [ecx+78h], 0
		jnz	short loc_A69
		mov	[esp+arg_0], eax
		jmp	_ec_wNAF_precompute_mult
; ---------------------------------------------------------------------------

loc_A69:				; CODE XREF: _EC_GROUP_precompute_mult+Aj
		mov	ecx, [ecx+7Ch]
		test	ecx, ecx
		jz	short loc_A76
		mov	[esp+arg_0], eax
		jmp	ecx
; ---------------------------------------------------------------------------

loc_A76:				; CODE XREF: _EC_GROUP_precompute_mult+1Aj
		mov	eax, 1
		retn
_EC_GROUP_precompute_mult endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A7Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_set_asn1_flag
_EC_GROUP_set_asn1_flag	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx+34h]
		xor	eax, [esp+arg_4]
		and	eax, 7FFFFFFFh
		xor	[ecx+34h], eax
		retn
_EC_GROUP_set_asn1_flag	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A90h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_set_curve_GF2m
_EC_GROUP_set_curve_GF2m proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	eax, [eax+18h]
		test	eax, eax
		jnz	short loc_ABB
		push	1BEh
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	0B0h ; '°'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_ABB:				; CODE XREF: _EC_GROUP_set_curve_GF2m+Bj
		mov	[esp+arg_0], ecx
		jmp	eax
_EC_GROUP_set_curve_GF2m endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0AC4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_set_curve_GFp
_EC_GROUP_set_curve_GFp	proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	eax, [eax+18h]
		test	eax, eax
		jnz	short loc_AEC
		push	1A8h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	6Dh ; 'm'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_AEC:				; CODE XREF: _EC_GROUP_set_curve_GFp+Bj
		mov	[esp+arg_0], ecx
		jmp	eax
_EC_GROUP_set_curve_GFp	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0AF4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_set_curve_name
_EC_GROUP_set_curve_name proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+30h], ecx
		retn
_EC_GROUP_set_curve_name endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B00h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_set_generator
_EC_GROUP_set_generator	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		cmp	[esp+arg_4], 0
		jnz	short loc_B22
		push	129h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	43h ; 'C'
		push	6Fh ; 'o'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_B22:				; CODE XREF: _EC_GROUP_set_generator+5j
		push	esi
		mov	esi, [esp+4+arg_0]
		cmp	dword ptr [esi+4], 0
		jnz	short loc_B3D
		push	esi
		call	_EC_POINT_new
		add	esp, 4
		mov	[esi+4], eax
		test	eax, eax
		jz	short loc_B92

loc_B3D:				; CODE XREF: _EC_GROUP_set_generator+2Bj
		push	[esp+4+arg_4]
		push	dword ptr [esi+4]
		call	_EC_POINT_copy
		add	esp, 8
		test	eax, eax
		jz	short loc_B92
		mov	eax, [esp+4+arg_8]
		test	eax, eax
		jz	short loc_B6B
		push	eax
		lea	eax, [esi+8]
		push	eax
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jnz	short loc_B79
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_B6B:				; CODE XREF: _EC_GROUP_set_generator+56j
		lea	eax, [esi+8]
		push	0
		push	eax
		call	_BN_set_word
		add	esp, 8

loc_B79:				; CODE XREF: _EC_GROUP_set_generator+67j
		mov	eax, [esp+4+arg_C]
		test	eax, eax
		jz	short loc_B96
		push	eax
		lea	eax, [esi+1Ch]
		push	eax
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jnz	short loc_BA4

loc_B92:				; CODE XREF: _EC_GROUP_set_generator+3Bj
					; _EC_GROUP_set_generator+4Ej
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_B96:				; CODE XREF: _EC_GROUP_set_generator+7Fj
		lea	eax, [esi+1Ch]
		push	0
		push	eax
		call	_BN_set_word
		add	esp, 8

loc_BA4:				; CODE XREF: _EC_GROUP_set_generator+90j
		push	esi
		call	_ec_precompute_mont_data
		add	esp, 4
		mov	eax, 1
		pop	esi
		retn
_EC_GROUP_set_generator	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0BB4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GROUP_set_point_conversion_form
_EC_GROUP_set_point_conversion_form proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+38h], ecx
		retn
_EC_GROUP_set_point_conversion_form endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0BC0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl EC_GROUP_set_seed(int, void *Src,	size_t Size)
		public _EC_GROUP_set_seed
_EC_GROUP_set_seed proc	near

arg_0		= dword	ptr  4
Src		= dword	ptr  8
Size		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		mov	eax, [esi+3Ch]
		test	eax, eax
		jz	short loc_BE4
		push	eax
		call	_CRYPTO_free
		add	esp, 4
		mov	dword ptr [esi+3Ch], 0
		mov	dword ptr [esi+40h], 0

loc_BE4:				; CODE XREF: _EC_GROUP_set_seed+Bj
		mov	edi, [esp+8+Size]
		test	edi, edi
		jz	short loc_C26
		cmp	[esp+8+Src], 0
		jz	short loc_C26
		push	192h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	edi
		call	_CRYPTO_malloc
		add	esp, 0Ch
		mov	[esi+3Ch], eax
		test	eax, eax
		jnz	short loc_C10
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_C10:				; CODE XREF: _EC_GROUP_set_seed+4Bj
		push	edi		; Size
		push	[esp+0Ch+Src]	; Src
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	[esi+40h], edi
		mov	eax, edi
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_C26:				; CODE XREF: _EC_GROUP_set_seed+2Aj
					; _EC_GROUP_set_seed+31j
		pop	edi
		mov	eax, 1
		pop	esi
		retn
_EC_GROUP_set_seed endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C30h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_METHOD_get_field_type
_EC_METHOD_get_field_type proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+4]
		retn
_EC_METHOD_get_field_type endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C38h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINT_add
_EC_POINT_add	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	edx, [esp+arg_0]
		push	esi
		mov	eax, [edx]
		mov	esi, [eax+58h]
		test	esi, esi
		jnz	short loc_C62
		push	399h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	70h ; 'p'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_C62:				; CODE XREF: _EC_POINT_add+Cj
		push	ebx
		push	edi
		mov	edi, [esp+0Ch+arg_4]
		mov	ecx, [edi]
		cmp	eax, ecx
		jnz	short loc_C91
		mov	ebx, [esp+0Ch+arg_8]
		mov	eax, [ebx]
		cmp	ecx, eax
		jnz	short loc_C91
		mov	ecx, [esp+0Ch+arg_C]
		cmp	eax, [ecx]
		jnz	short loc_C91
		push	[esp+0Ch+arg_10]
		push	ecx
		push	ebx
		push	edi
		push	edx
		call	esi
		add	esp, 14h
		pop	edi
		pop	ebx
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_C91:				; CODE XREF: _EC_POINT_add+34j
					; _EC_POINT_add+3Ej ...
		push	39Eh
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	65h ; 'e'
		push	70h ; 'p'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	ebx
		pop	esi
		retn
_EC_POINT_add	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0CB0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINT_clear_free
_EC_POINT_clear_free proc near		; CODE XREF: _EC_GROUP_copy+14Ep

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	short loc_CE0
		mov	ecx, [esi]
		mov	eax, [ecx+30h]
		test	eax, eax
		jnz	short loc_CC9
		mov	eax, [ecx+2Ch]
		test	eax, eax
		jz	short loc_CCF

loc_CC9:				; CODE XREF: _EC_POINT_clear_free+10j
		push	esi
		call	eax
		add	esp, 4

loc_CCF:				; CODE XREF: _EC_POINT_clear_free+17j
		push	44h ; 'D'
		push	esi
		call	_OPENSSL_cleanse
		push	esi
		call	_CRYPTO_free
		add	esp, 0Ch

loc_CE0:				; CODE XREF: _EC_POINT_clear_free+7j
		pop	esi
		retn
_EC_POINT_clear_free endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0CE4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINT_cmp
_EC_POINT_cmp	proc near		; CODE XREF: _EC_GROUP_cmp+138p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	edx, [eax+6Ch]
		test	edx, edx
		jnz	short loc_D0D
		push	3E6h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	71h ; 'q'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_D0D:				; CODE XREF: _EC_POINT_cmp+Bj
		push	esi
		push	edi
		mov	edi, [esp+8+arg_4]
		mov	esi, [edi]
		cmp	eax, esi
		jnz	short loc_D30
		mov	eax, [esp+8+arg_8]
		cmp	esi, [eax]
		jnz	short loc_D30
		push	[esp+8+arg_C]
		push	eax
		push	edi
		push	ecx
		call	edx
		add	esp, 10h
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_D30:				; CODE XREF: _EC_POINT_cmp+33j
					; _EC_POINT_cmp+3Bj
		push	3EAh
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	65h ; 'e'
		push	71h ; 'q'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		pop	edi
		pop	esi
		retn
_EC_POINT_cmp	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D50h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINT_copy
_EC_POINT_copy	proc near		; CODE XREF: _EC_GROUP_copy+133p
					; _EC_GROUP_set_generator+44p ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		push	esi
		mov	edx, [eax]
		mov	esi, [edx+34h]
		test	esi, esi
		jnz	short loc_D7A
		push	2F5h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	72h ; 'r'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_D7A:				; CODE XREF: _EC_POINT_copy+Cj
		mov	ecx, [esp+4+arg_4]
		cmp	edx, [ecx]
		jz	short loc_D9E
		push	2F9h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	65h ; 'e'
		push	72h ; 'r'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_D9E:				; CODE XREF: _EC_POINT_copy+30j
		cmp	eax, ecx
		jnz	short loc_DA9
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_DA9:				; CODE XREF: _EC_POINT_copy+50j
		push	ecx
		push	eax
		call	esi
		add	esp, 8
		pop	esi
		retn
_EC_POINT_copy	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0DB4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINT_dbl
_EC_POINT_dbl	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	edx, [eax+5Ch]
		test	edx, edx
		jnz	short loc_DDC
		push	3A8h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	73h ; 's'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_DDC:				; CODE XREF: _EC_POINT_dbl+Bj
		push	esi
		push	edi
		mov	edi, [esp+8+arg_4]
		mov	esi, [edi]
		cmp	eax, esi
		jnz	short loc_DFF
		mov	eax, [esp+8+arg_8]
		cmp	esi, [eax]
		jnz	short loc_DFF
		push	[esp+8+arg_C]
		push	eax
		push	edi
		push	ecx
		call	edx
		add	esp, 10h
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_DFF:				; CODE XREF: _EC_POINT_dbl+32j
					; _EC_POINT_dbl+3Aj
		push	3ACh
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	65h ; 'e'
		push	73h ; 's'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
_EC_POINT_dbl	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E1Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINT_dup
_EC_POINT_dup	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		cmp	[esp+arg_0], 0
		jnz	short loc_E26
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_E26:				; CODE XREF: _EC_POINT_dup+5j
		push	esi
		push	[esp+4+arg_4]
		call	_EC_POINT_new
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jz	short loc_E62
		push	[esp+4+arg_0]
		push	esi
		call	_EC_POINT_copy
		add	esp, 8
		test	eax, eax
		jnz	short loc_E66
		mov	eax, [esi]
		mov	eax, [eax+2Ch]
		test	eax, eax
		jz	short loc_E59
		push	esi
		call	eax
		add	esp, 4

loc_E59:				; CODE XREF: _EC_POINT_dup+35j
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_E62:				; CODE XREF: _EC_POINT_dup+1Bj
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_E66:				; CODE XREF: _EC_POINT_dup+2Cj
		mov	eax, esi
		pop	esi
		retn
_EC_POINT_dup	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E6Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINT_free
_EC_POINT_free	proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	short loc_E8D
		mov	eax, [esi]
		mov	eax, [eax+2Ch]
		test	eax, eax
		jz	short loc_E84
		push	esi
		call	eax
		add	esp, 4

loc_E84:				; CODE XREF: _EC_POINT_free+10j
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_E8D:				; CODE XREF: _EC_POINT_free+7j
		pop	esi
		retn
_EC_POINT_free	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E90h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINT_get_Jprojective_coordinates_GFp
_EC_POINT_get_Jprojective_coordinates_GFp proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	edx, [eax+40h]
		test	edx, edx
		jnz	short loc_EB8
		push	341h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	75h ; 'u'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_EB8:				; CODE XREF: _EC_POINT_get_Jprojective_coordinates_GFp+Bj
		push	esi
		mov	esi, [esp+4+arg_4]
		cmp	eax, [esi]
		jz	short loc_EDD
		push	346h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	65h ; 'e'
		push	75h ; 'u'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_EDD:				; CODE XREF: _EC_POINT_get_Jprojective_coordinates_GFp+2Fj
		push	[esp+4+arg_14]
		push	[esp+8+arg_10]
		push	[esp+0Ch+arg_C]
		push	[esp+10h+arg_8]
		push	esi
		push	ecx
		call	edx
		add	esp, 18h
		pop	esi
		retn
_EC_POINT_get_Jprojective_coordinates_GFp endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0EF8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINT_get_affine_coordinates_GF2m
_EC_POINT_get_affine_coordinates_GF2m proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	edx, [eax+48h]
		test	edx, edx
		jnz	short loc_F23
		push	389h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	0B7h ; '·'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_F23:				; CODE XREF: _EC_POINT_get_affine_coordinates_GF2m+Bj
		push	esi
		mov	esi, [esp+4+arg_4]
		cmp	eax, [esi]
		jz	short loc_F4B
		push	38Eh
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	65h ; 'e'
		push	0B7h ; '·'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_F4B:				; CODE XREF: _EC_POINT_get_affine_coordinates_GF2m+32j
		push	[esp+4+arg_10]
		push	[esp+8+arg_C]
		push	[esp+0Ch+arg_8]
		push	esi
		push	ecx
		call	edx
		add	esp, 14h
		pop	esi
		retn
_EC_POINT_get_affine_coordinates_GF2m endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F60h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINT_get_affine_coordinates_GFp
_EC_POINT_get_affine_coordinates_GFp proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	edx, [eax+48h]
		test	edx, edx
		jnz	short loc_F88
		push	377h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	74h ; 't'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_F88:				; CODE XREF: _EC_POINT_get_affine_coordinates_GFp+Bj
		push	esi
		mov	esi, [esp+4+arg_4]
		cmp	eax, [esi]
		jz	short loc_FAD
		push	37Ch
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	65h ; 'e'
		push	74h ; 't'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_FAD:				; CODE XREF: _EC_POINT_get_affine_coordinates_GFp+2Fj
		push	[esp+4+arg_10]
		push	[esp+8+arg_C]
		push	[esp+0Ch+arg_8]
		push	esi
		push	ecx
		call	edx
		add	esp, 14h
		pop	esi
		retn
_EC_POINT_get_affine_coordinates_GFp endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0FC4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINT_invert
_EC_POINT_invert proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	edx, [eax+60h]
		test	edx, edx
		jnz	short loc_FEF
		push	3B5h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	0D2h ; 'Ò'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_FEF:				; CODE XREF: _EC_POINT_invert+Bj
		push	esi
		mov	esi, [esp+4+arg_4]
		cmp	eax, [esi]
		jz	short loc_1017
		push	3B9h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	65h ; 'e'
		push	0D2h ; 'Ò'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1017:				; CODE XREF: _EC_POINT_invert+32j
		push	[esp+4+arg_8]
		push	esi
		push	ecx
		call	edx
		add	esp, 0Ch
		pop	esi
		retn
_EC_POINT_invert endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1024h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINT_is_at_infinity
_EC_POINT_is_at_infinity proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	edx, [eax+64h]
		test	edx, edx
		jnz	short loc_104C
		push	3C3h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	76h ; 'v'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_104C:				; CODE XREF: _EC_POINT_is_at_infinity+Bj
		push	esi
		mov	esi, [esp+4+arg_4]
		cmp	eax, [esi]
		jz	short loc_1071
		push	3C7h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	65h ; 'e'
		push	76h ; 'v'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1071:				; CODE XREF: _EC_POINT_is_at_infinity+2Fj
		push	esi
		push	ecx
		call	edx
		add	esp, 8
		pop	esi
		retn
_EC_POINT_is_at_infinity endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 107Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINT_is_on_curve
_EC_POINT_is_on_curve proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	edx, [eax+68h]
		test	edx, edx
		jnz	short loc_10A4
		push	3D8h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	77h ; 'w'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_10A4:				; CODE XREF: _EC_POINT_is_on_curve+Bj
		push	esi
		mov	esi, [esp+4+arg_4]
		cmp	eax, [esi]
		jz	short loc_10C9
		push	3DCh
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	65h ; 'e'
		push	77h ; 'w'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_10C9:				; CODE XREF: _EC_POINT_is_on_curve+2Fj
		push	[esp+4+arg_8]
		push	esi
		push	ecx
		call	edx
		add	esp, 0Ch
		pop	esi
		retn
_EC_POINT_is_on_curve endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 10D8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINT_make_affine
_EC_POINT_make_affine proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	edx, [eax+70h]
		test	edx, edx
		jnz	short loc_1100
		push	3F3h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	78h ; 'x'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1100:				; CODE XREF: _EC_POINT_make_affine+Bj
		push	esi
		mov	esi, [esp+4+arg_4]
		cmp	eax, [esi]
		jz	short loc_1125
		push	3F7h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	65h ; 'e'
		push	78h ; 'x'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1125:				; CODE XREF: _EC_POINT_make_affine+2Fj
		push	[esp+4+arg_8]
		push	esi
		push	ecx
		call	edx
		add	esp, 0Ch
		pop	esi
		retn
_EC_POINT_make_affine endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1134h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINT_method_of
_EC_POINT_method_of proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax]
		retn
_EC_POINT_method_of endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 113Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINT_mul
_EC_POINT_mul	proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	eax, 4
		call	__chkstk
		mov	eax, [esp+4+arg_C]
		mov	ecx, [esp+4+arg_10]
		mov	[esp+4+var_4], eax
		mov	[esp+4+arg_C], ecx
		test	eax, eax
		jz	short loc_1164
		test	ecx, ecx
		jz	short loc_1164
		mov	ecx, 1
		jmp	short loc_1166
; ---------------------------------------------------------------------------

loc_1164:				; CODE XREF: _EC_POINT_mul+1Bj
					; _EC_POINT_mul+1Fj
		xor	ecx, ecx

loc_1166:				; CODE XREF: _EC_POINT_mul+26j
		mov	edx, [esp+4+arg_0]
		mov	eax, [edx]
		mov	eax, [eax+78h]
		test	eax, eax
		jnz	short loc_1195
		push	[esp+4+arg_14]
		lea	eax, [esp+8+arg_C]
		push	eax
		lea	eax, [esp+0Ch+var_4]
		push	eax
		push	ecx
		push	[esp+14h+arg_8]
		push	[esp+18h+arg_4]
		push	edx
		call	_ec_wNAF_mul
		add	esp, 1Ch
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_1195:				; CODE XREF: _EC_POINT_mul+35j
		push	esi
		push	[esp+8+arg_14]
		lea	esi, [esp+0Ch+arg_C]
		push	esi
		lea	esi, [esp+10h+var_4]
		push	esi
		push	ecx
		push	[esp+18h+arg_8]
		push	[esp+1Ch+arg_4]
		push	edx
		call	eax
		add	esp, 1Ch
		pop	esi
		pop	ecx
		retn
_EC_POINT_mul	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 11B8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINT_new
_EC_POINT_new	proc near		; CODE XREF: _EC_GROUP_copy+11Ep
					; _EC_GROUP_set_generator+2Ep ...

arg_0		= dword	ptr  4

		push	edi
		mov	edi, [esp+4+arg_0]
		test	edi, edi
		jnz	short loc_11DD
		push	2C3h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	43h ; 'C'
		push	79h ; 'y'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_11DD:				; CODE XREF: _EC_POINT_new+7j
		mov	eax, [edi]
		cmp	dword ptr [eax+28h], 0
		jnz	short loc_1201
		push	2C7h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	79h ; 'y'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_1201:				; CODE XREF: _EC_POINT_new+2Bj
		push	esi
		push	2CBh
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	44h ; 'D'
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jnz	short loc_1239
		push	2CDh
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	41h ; 'A'
		push	79h ; 'y'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_1239:				; CODE XREF: _EC_POINT_new+62j
		mov	eax, [edi]
		mov	[esi], eax
		push	esi
		mov	eax, [eax+28h]
		call	eax
		add	esp, 4
		test	eax, eax
		jnz	short loc_1258
		push	esi
		call	_CRYPTO_free
		add	esp, 4
		xor	eax, eax
		pop	esi
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_1258:				; CODE XREF: _EC_POINT_new+90j
		mov	eax, esi
		pop	esi
		pop	edi
		retn
_EC_POINT_new	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1260h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINT_set_Jprojective_coordinates_GFp
_EC_POINT_set_Jprojective_coordinates_GFp proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	edx, [eax+3Ch]
		test	edx, edx
		jnz	short loc_1288
		push	32Eh
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	7Eh ; '~'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1288:				; CODE XREF: _EC_POINT_set_Jprojective_coordinates_GFp+Bj
		push	esi
		mov	esi, [esp+4+arg_4]
		cmp	eax, [esi]
		jz	short loc_12AD
		push	333h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	65h ; 'e'
		push	7Eh ; '~'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_12AD:				; CODE XREF: _EC_POINT_set_Jprojective_coordinates_GFp+2Fj
		push	[esp+4+arg_14]
		push	[esp+8+arg_10]
		push	[esp+0Ch+arg_C]
		push	[esp+10h+arg_8]
		push	esi
		push	ecx
		call	edx
		add	esp, 18h
		pop	esi
		retn
_EC_POINT_set_Jprojective_coordinates_GFp endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 12C8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINT_set_affine_coordinates_GF2m
_EC_POINT_set_affine_coordinates_GF2m proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	edx, [eax+44h]
		test	edx, edx
		jnz	short loc_12F3
		push	365h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	0B9h ; '¹'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_12F3:				; CODE XREF: _EC_POINT_set_affine_coordinates_GF2m+Bj
		push	esi
		mov	esi, [esp+4+arg_4]
		cmp	eax, [esi]
		jz	short loc_131B
		push	36Ah
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	65h ; 'e'
		push	0B9h ; '¹'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_131B:				; CODE XREF: _EC_POINT_set_affine_coordinates_GF2m+32j
		push	[esp+4+arg_10]
		push	[esp+8+arg_C]
		push	[esp+0Ch+arg_8]
		push	esi
		push	ecx
		call	edx
		add	esp, 14h
		pop	esi
		retn
_EC_POINT_set_affine_coordinates_GF2m endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1330h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINT_set_affine_coordinates_GFp
_EC_POINT_set_affine_coordinates_GFp proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	edx, [eax+44h]
		test	edx, edx
		jnz	short loc_1358
		push	353h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	7Ch ; '|'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1358:				; CODE XREF: _EC_POINT_set_affine_coordinates_GFp+Bj
		push	esi
		mov	esi, [esp+4+arg_4]
		cmp	eax, [esi]
		jz	short loc_137D
		push	358h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	65h ; 'e'
		push	7Ch ; '|'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_137D:				; CODE XREF: _EC_POINT_set_affine_coordinates_GFp+2Fj
		push	[esp+4+arg_10]
		push	[esp+8+arg_C]
		push	[esp+0Ch+arg_8]
		push	esi
		push	ecx
		call	edx
		add	esp, 14h
		pop	esi
		retn
_EC_POINT_set_affine_coordinates_GFp endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1394h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINT_set_to_infinity
_EC_POINT_set_to_infinity proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	edx, [eax+38h]
		test	edx, edx
		jnz	short loc_13BC
		push	31Dh
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	7Fh ; ''
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_13BC:				; CODE XREF: _EC_POINT_set_to_infinity+Bj
		push	esi
		mov	esi, [esp+4+arg_4]
		cmp	eax, [esi]
		jz	short loc_13E1
		push	321h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	65h ; 'e'
		push	7Fh ; ''
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_13E1:				; CODE XREF: _EC_POINT_set_to_infinity+2Fj
		push	esi
		push	ecx
		call	edx
		add	esp, 8
		pop	esi
		retn
_EC_POINT_set_to_infinity endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 13ECh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINTs_make_affine
_EC_POINTs_make_affine proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	ebp
		push	esi
		mov	esi, [ebx]
		mov	ebp, [esi+74h]
		test	ebp, ebp
		jnz	short loc_141D
		push	403h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	42h ; 'B'
		push	88h ; 'ˆ'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_141D:				; CODE XREF: _EC_POINTs_make_affine+Ej
		mov	edx, [esp+0Ch+arg_4]
		xor	ecx, ecx
		push	edi
		mov	edi, [esp+10h+arg_8]
		test	edx, edx
		jz	short loc_1438

loc_142C:				; CODE XREF: _EC_POINTs_make_affine+4Aj
		mov	eax, [edi+ecx*4]
		cmp	esi, [eax]
		jnz	short loc_1449
		inc	ecx
		cmp	ecx, edx
		jb	short loc_142C

loc_1438:				; CODE XREF: _EC_POINTs_make_affine+3Ej
		push	[esp+10h+arg_C]
		push	edi
		push	edx
		push	ebx
		call	ebp
		add	esp, 10h
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1449:				; CODE XREF: _EC_POINTs_make_affine+45j
		push	408h
		push	offset ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ ; ".\\crypto\\ec\\ec_lib.c"
		push	65h ; 'e'
		push	88h ; 'ˆ'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_EC_POINTs_make_affine endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 146Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_POINTs_mul
_EC_POINTs_mul	proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	eax, [eax+78h]
		test	eax, eax
		jnz	short loc_1482
		mov	[esp+arg_0], ecx
		jmp	_ec_wNAF_mul
; ---------------------------------------------------------------------------

loc_1482:				; CODE XREF: _EC_POINTs_mul+Bj
		mov	[esp+arg_0], ecx
		jmp	eax
_EC_POINTs_mul	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1488h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_precompute_mont_data
_ec_precompute_mont_data proc near	; CODE XREF: _EC_GROUP_set_generator+A5p

arg_0		= dword	ptr  4

		push	ebx
		push	esi
		push	edi
		call	_BN_CTX_new
		mov	esi, [esp+0Ch+arg_0]
		xor	edi, edi
		mov	ebx, eax
		test	dword ptr [esi+34h], 80000000h
		jz	short $err$12
		mov	eax, [esi+0ACh]
		test	eax, eax
		jz	short loc_14BA
		push	eax
		call	_BN_MONT_CTX_free
		add	esp, 4
		mov	[esi+0ACh], edi

loc_14BA:				; CODE XREF: _ec_precompute_mont_data+21j
		test	ebx, ebx
		jz	short loc_1507
		call	_BN_MONT_CTX_new
		mov	[esi+0ACh], eax
		test	eax, eax
		jz	short $err$12
		push	ebx
		lea	ecx, [esi+8]
		push	ecx
		push	eax
		call	_BN_MONT_CTX_set
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_14F5
		push	dword ptr [esi+0ACh]
		call	_BN_MONT_CTX_free
		add	esp, 4
		mov	[esi+0ACh], edi
		jmp	short $err$12
; ---------------------------------------------------------------------------

loc_14F5:				; CODE XREF: _ec_precompute_mont_data+55j
		mov	edi, 1

$err$12:				; CODE XREF: _ec_precompute_mont_data+17j
					; _ec_precompute_mont_data+43j	...
		test	ebx, ebx
		jz	short loc_1507
		push	ebx
		call	_BN_CTX_free
		add	esp, 4

loc_1507:				; CODE XREF: _ec_precompute_mont_data+34j
					; _ec_precompute_mont_data+74j
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebx
		retn
_ec_precompute_mont_data endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1510h
; COMDAT (pick any)
		public ??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@
; `string'
??_C@_0BF@KGHFPEKG@?4?2crypto?2ec?2ec_lib?4c?$AA@ db '.\crypto\ec\ec_lib.c',0
					; DATA XREF: _EC_EX_DATA_set_data+44o
					; _EC_EX_DATA_set_data+80o ...
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _CRYPTO_malloc:near ; CODE XREF: _EC_EX_DATA_set_data+4Bp
					; _EC_GROUP_copy+1BAp ...
		extrn _CRYPTO_free:near	; CODE XREF: _EC_EX_DATA_clear_free_all_data+1Cp
					; _EC_EX_DATA_clear_free_data+47p ...
		extrn _OPENSSL_cleanse:near ; CODE XREF: _EC_GROUP_clear_free+6Cp
					; _EC_GROUP_clear_free+9Bp ...
		extrn _ERR_put_error:near ; CODE XREF: _EC_EX_DATA_set_data+8Ep
					; _EC_GROUP_check_discriminant+20p ...
		extrn _BN_CTX_new:near	; CODE XREF: _EC_GROUP_cmp+4Ap
					; _ec_precompute_mont_data+3p
		extrn _BN_CTX_free:near	; CODE XREF: _EC_GROUP_cmp+1C7p
					; _EC_GROUP_cmp+1EAp ...
		extrn _BN_CTX_start:near ; CODE	XREF: _EC_GROUP_cmp+5Cp
		extrn _BN_CTX_get:near	; CODE XREF: _EC_GROUP_cmp+62p
					; _EC_GROUP_cmp+6Cp ...
		extrn _BN_CTX_end:near	; CODE XREF: _EC_GROUP_cmp:loc_4BEp
					; _EC_GROUP_cmp+1DDp
		extrn _BN_init:near	; CODE XREF: _EC_GROUP_new+94p
					; _EC_GROUP_new+9Dp
		extrn _BN_clear_free:near ; CODE XREF: _EC_GROUP_clear_free+7Ep
					; _EC_GROUP_clear_free+87p
		extrn _BN_copy:near	; CODE XREF: _EC_GROUP_copy+165p
					; _EC_GROUP_copy+179p ...
		extrn _BN_set_word:near	; CODE XREF: _EC_GROUP_set_generator+71p
					; _EC_GROUP_set_generator+9Cp
		extrn _BN_cmp:near	; CODE XREF: _EC_GROUP_cmp+F0p
					; _EC_GROUP_cmp+108p ...
		extrn _BN_free:near	; CODE XREF: _EC_GROUP_free+68p
					; _EC_GROUP_free+71p
		extrn _BN_MONT_CTX_new:near ; CODE XREF: _EC_GROUP_copy+BFp
					; _ec_precompute_mont_data+36p
		extrn _BN_MONT_CTX_free:near ; CODE XREF: _EC_GROUP_clear_free+43p
					; _EC_GROUP_copy+FFp ...
		extrn _BN_MONT_CTX_set:near ; CODE XREF: _ec_precompute_mont_data+4Bp
		extrn _BN_MONT_CTX_copy:near ; CODE XREF: _EC_GROUP_copy+DAp
		extrn _ec_wNAF_mul:near	; CODE XREF: _EC_POINT_mul+4Fp
					; _EC_POINTs_mul+11j
		extrn _ec_wNAF_precompute_mult:near
					; CODE XREF: _EC_GROUP_precompute_mult+10j
		extrn _ec_wNAF_have_precompute_mult:near
					; CODE XREF: _EC_GROUP_have_precompute_mult+10j
		extrn __chkstk:near	; CODE XREF: _EC_GROUP_cmp+5p
					; _EC_POINT_mul+5p
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _EC_GROUP_copy+1D4p
					; _EC_GROUP_set_seed+56p


		end
