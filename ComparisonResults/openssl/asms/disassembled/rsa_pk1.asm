;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	8A2B72997B1D2E77679DD2587C66F67F
; Input	CRC32 :	41A560D7

; File Name   :	C:\compspace\Diff\openssl\obj\rsa_pk1.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl RSA_padding_add_PKCS1_type_1(int,	int, void *Src,	size_t Size)
		public _RSA_padding_add_PKCS1_type_1
_RSA_padding_add_PKCS1_type_1 proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
Src		= dword	ptr  0Ch
Size		= dword	ptr  10h

		push	ebx
		mov	ebx, [esp+4+Size]
		push	edi
		mov	edi, [esp+8+arg_4]
		lea	eax, [edi-0Bh]
		cmp	ebx, eax
		jle	short loc_2B
		push	4Bh ; 'K'
		push	offset ??_C@_0BH@BDEBAHMM@?4?2crypto?2rsa?2rsa_pk1?4c?$AA@ ; ".\\crypto\\rsa\\rsa_pk1.c"
		push	6Eh ; 'n'
		push	6Ch ; 'l'
		push	4
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_2B:					; CODE XREF: _RSA_padding_add_PKCS1_type_1+Fj
		mov	eax, [esp+8+arg_0]
		sub	edi, ebx
		push	esi
		lea	esi, [eax+1]
		sub	edi, 3
		push	edi		; Size
		mov	byte ptr [eax],	0
		mov	byte ptr [esi],	1
		inc	esi
		push	0FFh		; Val
		push	esi		; Dst
		call	_memset
		push	ebx		; Size
		push	[esp+1Ch+Src]	; Src
		lea	eax, [esi+1]
		mov	byte ptr [esi+edi], 0
		add	eax, edi
		push	eax		; Dst
		call	_memcpy
		add	esp, 18h
		mov	eax, 1
		pop	esi
		pop	edi
		pop	ebx
		retn
_RSA_padding_add_PKCS1_type_1 endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl RSA_padding_add_PKCS1_type_2(int,	int, void *Src,	size_t Size)
		public _RSA_padding_add_PKCS1_type_2
_RSA_padding_add_PKCS1_type_2 proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
Src		= dword	ptr  0Ch
Size		= dword	ptr  10h

		push	ebx
		mov	ebx, [esp+4+arg_4]
		push	ebp
		mov	ebp, [esp+8+Size]
		lea	eax, [ebx-0Bh]
		cmp	ebp, eax
		jle	short loc_9A
		push	99h ; '™'
		push	offset ??_C@_0BH@BDEBAHMM@?4?2crypto?2rsa?2rsa_pk1?4c?$AA@ ; ".\\crypto\\rsa\\rsa_pk1.c"
		push	6Eh ; 'n'
		push	6Dh ; 'm'
		push	4
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_9A:					; CODE XREF: _RSA_padding_add_PKCS1_type_2+Fj
		push	esi
		mov	esi, [esp+0Ch+arg_0]
		sub	ebx, ebp
		sub	ebx, 3
		push	ebx
		mov	word ptr [esi],	200h
		add	esi, 2
		push	esi
		call	_RAND_bytes
		add	esp, 8
		test	eax, eax
		jg	short loc_C0
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_C0:					; CODE XREF: _RSA_padding_add_PKCS1_type_2+4Cj
		push	edi
		xor	edi, edi
		test	ebx, ebx
		jle	short loc_EB
		nop	dword ptr [eax+eax+00h]

loc_CC:					; CODE XREF: _RSA_padding_add_PKCS1_type_2+7Dj
		cmp	byte ptr [esi],	0
		jnz	short loc_E5

loc_D1:					; CODE XREF: _RSA_padding_add_PKCS1_type_2+77j
		push	1
		push	esi
		call	_RAND_bytes
		add	esp, 8
		test	eax, eax
		jle	short loc_107
		cmp	byte ptr [esi],	0
		jz	short loc_D1

loc_E5:					; CODE XREF: _RSA_padding_add_PKCS1_type_2+63j
		inc	edi
		inc	esi
		cmp	edi, ebx
		jl	short loc_CC

loc_EB:					; CODE XREF: _RSA_padding_add_PKCS1_type_2+59j
		push	ebp		; Size
		push	[esp+14h+Src]	; Src
		mov	byte ptr [esi],	0
		inc	esi
		push	esi		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, 1
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_107:				; CODE XREF: _RSA_padding_add_PKCS1_type_2+72j
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
_RSA_padding_add_PKCS1_type_2 endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 110h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl RSA_padding_check_PKCS1_type_1(void *Dst,	int, int, int, int)
		public _RSA_padding_check_PKCS1_type_1
_RSA_padding_check_PKCS1_type_1	proc near

Dst		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		push	esi
		mov	esi, [esp+4+arg_C]
		lea	eax, [esi+1]
		cmp	[esp+4+arg_10],	eax
		jnz	loc_1E9
		mov	eax, [esp+4+arg_8]
		cmp	byte ptr [eax],	1
		lea	ecx, [eax+1]
		jnz	loc_1E9
		dec	esi
		xor	edx, edx
		test	esi, esi
		jle	short loc_14B
		nop	dword ptr [eax+00000000h]

loc_140:				; CODE XREF: _RSA_padding_check_PKCS1_type_1+39j
		cmp	byte ptr [ecx],	0FFh
		jnz	short loc_169
		inc	edx
		inc	ecx
		cmp	edx, esi
		jl	short loc_140

loc_14B:				; CODE XREF: _RSA_padding_check_PKCS1_type_1+27j
					; _RSA_padding_check_PKCS1_type_1+5Fj
		cmp	edx, esi
		jnz	short loc_18B
		push	7Dh ; '}'
		push	offset ??_C@_0BH@BDEBAHMM@?4?2crypto?2rsa?2rsa_pk1?4c?$AA@ ; ".\\crypto\\rsa\\rsa_pk1.c"
		push	71h ; 'q'
		push	70h ; 'p'
		push	4
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_169:				; CODE XREF: _RSA_padding_check_PKCS1_type_1+33j
		cmp	byte ptr [ecx],	0
		jnz	short loc_171
		inc	ecx
		jmp	short loc_14B
; ---------------------------------------------------------------------------

loc_171:				; CODE XREF: _RSA_padding_check_PKCS1_type_1+5Cj
		push	74h ; 't'
		push	offset ??_C@_0BH@BDEBAHMM@?4?2crypto?2rsa?2rsa_pk1?4c?$AA@ ; ".\\crypto\\rsa\\rsa_pk1.c"
		push	66h ; 'f'
		push	70h ; 'p'
		push	4
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_18B:				; CODE XREF: _RSA_padding_check_PKCS1_type_1+3Dj
		cmp	edx, 8
		jge	short loc_1AD
		push	83h ; 'ƒ'
		push	offset ??_C@_0BH@BDEBAHMM@?4?2crypto?2rsa?2rsa_pk1?4c?$AA@ ; ".\\crypto\\rsa\\rsa_pk1.c"
		push	67h ; 'g'
		push	70h ; 'p'
		push	4
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1AD:				; CODE XREF: _RSA_padding_check_PKCS1_type_1+7Ej
		or	eax, 0FFFFFFFFh
		sub	eax, edx
		add	esi, eax
		cmp	esi, [esp+4+arg_4]
		jle	short loc_1D7
		push	89h ; '‰'
		push	offset ??_C@_0BH@BDEBAHMM@?4?2crypto?2rsa?2rsa_pk1?4c?$AA@ ; ".\\crypto\\rsa\\rsa_pk1.c"
		push	6Dh ; 'm'
		push	70h ; 'p'
		push	4
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1D7:				; CODE XREF: _RSA_padding_check_PKCS1_type_1+A8j
		push	esi		; Size
		push	ecx		; Src
		push	[esp+0Ch+Dst]	; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, esi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1E9:				; CODE XREF: _RSA_padding_check_PKCS1_type_1+Cj
					; _RSA_padding_check_PKCS1_type_1+1Cj
		push	67h ; 'g'
		push	offset ??_C@_0BH@BDEBAHMM@?4?2crypto?2rsa?2rsa_pk1?4c?$AA@ ; ".\\crypto\\rsa\\rsa_pk1.c"
		push	6Ah ; 'j'
		push	70h ; 'p'
		push	4
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		pop	esi
		retn
_RSA_padding_check_PKCS1_type_1	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 204h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl RSA_padding_check_PKCS1_type_2(void *Dst,	int, void *Src,	size_t,	size_t Size)
		public _RSA_padding_check_PKCS1_type_2
_RSA_padding_check_PKCS1_type_2	proc near

var_8		= dword	ptr -8
var_4		= dword	ptr -4
Dst		= dword	ptr  4
arg_4		= dword	ptr  8
Src		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
Size		= dword	ptr  14h

		mov	eax, 8
		call	__chkstk
		push	ebp
		push	esi
		xor	ebp, ebp
		or	esi, 0FFFFFFFFh
		cmp	[esp+10h+arg_4], ebp
		jl	loc_386
		mov	eax, [esp+10h+arg_C]
		test	eax, eax
		js	loc_386
		push	ebx
		push	edi
		mov	edi, [esp+18h+Size]
		cmp	eax, edi
		jg	loc_361
		cmp	edi, 0Bh
		jl	loc_361
		push	0CEh ; 'Î'
		push	offset ??_C@_0BH@BDEBAHMM@?4?2crypto?2rsa?2rsa_pk1?4c?$AA@ ; ".\\crypto\\rsa\\rsa_pk1.c"
		push	edi
		call	_CRYPTO_malloc
		mov	ebx, eax
		add	esp, 0Ch
		test	ebx, ebx
		jnz	short loc_27D
		push	0D0h ; 'Ð'
		push	offset ??_C@_0BH@BDEBAHMM@?4?2crypto?2rsa?2rsa_pk1?4c?$AA@ ; ".\\crypto\\rsa\\rsa_pk1.c"
		push	41h ; 'A'
		push	71h ; 'q'
		push	4
		call	_ERR_put_error
		add	esp, 14h
		or	eax, esi
		pop	edi
		pop	ebx
		pop	esi
		pop	ebp
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_27D:				; CODE XREF: _RSA_padding_check_PKCS1_type_2+55j
		push	edi		; Size
		push	0		; Val
		push	ebx		; Dst
		call	_memset
		mov	ecx, [esp+24h+arg_C]
		mov	eax, ebx
		push	ecx		; Size
		push	[esp+28h+Src]	; Src
		sub	eax, ecx
		add	eax, edi
		push	eax		; Dst
		call	_memcpy
		movzx	eax, byte ptr [ebx+1]
		mov	esi, 2
		movzx	ecx, byte ptr [ebx]
		xor	eax, 2
		add	esp, 18h
		lea	edx, [eax-1]
		not	eax
		shr	eax, 1Fh
		shr	edx, 1Fh
		and	edx, eax
		lea	eax, [ecx-1]
		not	ecx
		shr	eax, 1Fh
		shr	ecx, 1Fh
		neg	edx
		and	eax, ecx
		xor	ecx, ecx
		neg	eax
		mov	[esp+18h+var_8], ecx
		and	edx, eax
		mov	[esp+18h+var_4], edx
		cmp	edi, esi
		jle	short loc_30B

loc_2DB:				; CODE XREF: _RSA_padding_check_PKCS1_type_2+105j
		movzx	eax, byte ptr [esi+ebx]
		not	ecx
		lea	edx, [eax-1]
		not	eax
		shr	eax, 1Fh
		shr	edx, 1Fh
		and	edx, eax
		neg	edx
		and	ecx, edx
		mov	eax, ecx
		and	ecx, esi
		not	eax
		inc	esi
		and	ebp, eax
		or	ebp, ecx
		mov	ecx, [esp+18h+var_8]
		or	ecx, edx
		mov	[esp+18h+var_8], ecx
		cmp	esi, edi
		jl	short loc_2DB

loc_30B:				; CODE XREF: _RSA_padding_check_PKCS1_type_2+D5j
		mov	edx, [esp+18h+arg_4]
		lea	eax, [ebp+1]
		mov	esi, edi
		mov	ecx, edx
		sub	esi, eax
		sub	ecx, esi
		mov	eax, esi
		xor	eax, edx
		xor	ecx, esi
		or	ecx, eax
		lea	eax, [ebp-0Ah]
		or	eax, ebp
		xor	ecx, edx
		xor	eax, ebp
		shr	ecx, 1Fh
		shr	eax, 1Fh
		dec	ecx
		dec	eax
		and	ecx, eax
		test	[esp+18h+var_4], ecx
		jnz	short loc_340
		or	esi, 0FFFFFFFFh
		jmp	short $err$54
; ---------------------------------------------------------------------------

loc_340:				; CODE XREF: _RSA_padding_check_PKCS1_type_2+135j
		lea	eax, [ebx+1]
		push	esi		; Size
		add	eax, ebp
		push	eax		; Src
		push	[esp+20h+Dst]	; Dst
		call	_memcpy
		add	esp, 0Ch

$err$54:				; CODE XREF: _RSA_padding_check_PKCS1_type_2+13Aj
		push	ebx
		call	_CRYPTO_free
		add	esp, 4
		cmp	esi, 0FFFFFFFFh
		jnz	short loc_37C

loc_361:				; CODE XREF: _RSA_padding_check_PKCS1_type_2+2Fj
					; _RSA_padding_check_PKCS1_type_2+38j
		push	111h
		push	offset ??_C@_0BH@BDEBAHMM@?4?2crypto?2rsa?2rsa_pk1?4c?$AA@ ; ".\\crypto\\rsa\\rsa_pk1.c"
		push	9Fh ; 'Ÿ'
		push	71h ; 'q'
		push	4
		call	_ERR_put_error
		add	esp, 14h

loc_37C:				; CODE XREF: _RSA_padding_check_PKCS1_type_2+15Bj
		pop	edi
		pop	ebx
		mov	eax, esi
		pop	esi
		pop	ebp
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_386:				; CODE XREF: _RSA_padding_check_PKCS1_type_2+15j
					; _RSA_padding_check_PKCS1_type_2+21j
		pop	esi
		or	eax, 0FFFFFFFFh
		pop	ebp
		add	esp, 8
		retn
_RSA_padding_check_PKCS1_type_2	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 390h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_constant_time_eq proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		xor	ecx, [esp+arg_4]
		lea	eax, [ecx-1]
		not	ecx
		shr	eax, 1Fh
		shr	ecx, 1Fh
		and	eax, ecx
		neg	eax
		retn
_constant_time_eq endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3A8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_constant_time_ge proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, esi
		sub	eax, edx
		mov	ecx, esi
		xor	eax, edx
		xor	ecx, edx
		or	eax, ecx
		xor	eax, esi
		shr	eax, 1Fh
		dec	eax
		pop	esi
		retn
_constant_time_ge endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3C8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_constant_time_is_zero proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		lea	eax, [ecx-1]
		not	ecx
		shr	eax, 1Fh
		shr	ecx, 1Fh
		and	eax, ecx
		neg	eax
		retn
_constant_time_is_zero endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3DCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_constant_time_lt proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, esi
		sub	eax, edx
		mov	ecx, esi
		xor	eax, edx
		xor	ecx, edx
		or	eax, ecx
		xor	eax, esi
		shr	eax, 1Fh
		neg	eax
		pop	esi
		retn
_constant_time_lt endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3FCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_constant_time_msb proc	near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		shr	eax, 1Fh
		neg	eax
		retn
_constant_time_msb endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 408h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_constant_time_select proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		mov	eax, ecx
		and	ecx, [esp+arg_4]
		not	eax
		and	eax, [esp+arg_8]
		or	eax, ecx
		retn
_constant_time_select endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 41Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_constant_time_select_int proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		mov	eax, ecx
		and	ecx, [esp+arg_4]
		not	eax
		and	eax, [esp+arg_8]
		or	eax, ecx
		retn
_constant_time_select_int endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 430h
; COMDAT (pick any)
		public ??_C@_0BH@BDEBAHMM@?4?2crypto?2rsa?2rsa_pk1?4c?$AA@
; `string'
??_C@_0BH@BDEBAHMM@?4?2crypto?2rsa?2rsa_pk1?4c?$AA@ db '.\crypto\rsa\rsa_pk1.c',0
					; DATA XREF: _RSA_padding_add_PKCS1_type_1+13o
					; _RSA_padding_add_PKCS1_type_2+16o ...
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _CRYPTO_malloc:near ; CODE XREF: _RSA_padding_check_PKCS1_type_2+49p
		extrn _CRYPTO_free:near	; CODE XREF: _RSA_padding_check_PKCS1_type_2+150p
		extrn _ERR_put_error:near ; CODE XREF: _RSA_padding_add_PKCS1_type_1+1Ep
					; _RSA_padding_add_PKCS1_type_2+21p ...
		extrn _RAND_bytes:near	; CODE XREF: _RSA_padding_add_PKCS1_type_2+42p
					; _RSA_padding_add_PKCS1_type_2+68p
		extrn __chkstk:near	; CODE XREF: _RSA_padding_check_PKCS1_type_2+5p
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _RSA_padding_add_PKCS1_type_1+5Ap
					; _RSA_padding_add_PKCS1_type_2+89p ...
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _RSA_padding_add_PKCS1_type_1+46p
					; _RSA_padding_check_PKCS1_type_2+7Dp


		end
