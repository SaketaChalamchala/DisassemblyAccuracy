;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	16C22F7B821A8CCB15EE51E6C09CFF48
; Input	CRC32 :	49788380

; File Name   :	C:\compspace\Diff\openssl\obj\cryptlib.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_bss		segment	para public 'BSS' use32
		assume cs:_bss
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
		public _OPENSSL_NONPIC_relocated
_OPENSSL_NONPIC_relocated dd ?		; DATA XREF: DllMain(x,x,x)+30r
					; DllMain(x,x,x)+39w
_app_locks	dd ?			; DATA XREF: _CRYPTO_get_lock_name+1Cr
					; _CRYPTO_get_lock_name+39r ...
_SSLeay_MSVC5_hack dq ?			; DATA XREF: _CRYPTO_get_new_lockid+27w
_dyn_locks	dd ?			; DATA XREF: _CRYPTO_destroy_dynlockid+30r
					; _CRYPTO_destroy_dynlockid+4Br ...
_locking_callback dd ?			; DATA XREF: _CRYPTO_get_locking_callbackr
					; _CRYPTO_get_new_dynlockid:loc_584r ...
_add_lock_callback dd ?			; DATA XREF: _CRYPTO_add_lockr
					; _CRYPTO_get_add_lock_callbackr ...
_id_callback	dd ?			; DATA XREF: _CRYPTO_THREADID_current:loc_2CBr
					; _CRYPTO_get_id_callbackr ...
_threadid_callback dd ?			; DATA XREF: _CRYPTO_THREADID_currentr
					; _CRYPTO_THREADID_get_callbackr ...
_dynlock_create_callback dd ?		; DATA XREF: _CRYPTO_get_dynlock_create_callbackr
					; _CRYPTO_get_new_dynlockidr ...
_dynlock_lock_callback dd ?		; DATA XREF: _CRYPTO_get_dynlock_lock_callbackr
					; _CRYPTO_lock+9r ...
_dynlock_destroy_callback dd ?		; DATA XREF: _CRYPTO_destroy_dynlockid:loc_3ACr
					; _CRYPTO_destroy_dynlockid+A2r ...
; `OPENSSL_cpuid_setup'::`2'::trigger
?trigger@?1??OPENSSL_cpuid_setup@@9@9 dd ? ; DATA XREF:	_OPENSSL_cpuid_setup+Ar
					; _OPENSSL_cpuid_setup+1Ew
; LPCSTR `OPENSSL_isservice'::`2'::_OPENSSL_isservice
?_OPENSSL_isservice@?1??OPENSSL_isservice@@9@9 dd ? ; DATA XREF: _OPENSSL_isservice+17r
					; _OPENSSL_isservice+3Dw ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 38h
_lock_names	dd offset ??_C@_09OGFJIAEE@?$DM?$DMERROR?$DO?$DO?$AA@
					; DATA XREF: _CRYPTO_get_lock_name+13r
					; "<<ERROR>>"
		dd offset ??_C@_03JIDPIAJI@err?$AA@ ; `string'
		dd offset ??_C@_07OALPHBKG@ex_data?$AA@	; "ex_data"
		dd offset ??_C@_04BNGFMDFF@x509?$AA@ ; "x509"
		dd offset ??_C@_09DJEHILFA@x509_info?$AA@ ; "x509_info"
		dd offset ??_C@_09HNLHIFBP@x509_pkey?$AA@ ; "x509_pkey"
		dd offset ??_C@_08BJFLLMNA@x509_crl?$AA@ ; "x509_crl"
		dd offset ??_C@_08BHPLFFMD@x509_req?$AA@ ; "x509_req"
		dd offset ??_C@_03EAKOMMFI@dsa?$AA@ ; `string'
		dd offset ??_C@_03DFNMMEBL@rsa?$AA@ ; `string'
		dd offset ??_C@_08NBJJIGBN@evp_pkey?$AA@ ; "evp_pkey"
		dd offset ??_C@_0L@JCDDFIOK@x509_store?$AA@ ; "x509_store"
		dd offset ??_C@_07DNHKIAPH@ssl_ctx?$AA@	; "ssl_ctx"
		dd offset ??_C@_08INIFBEOB@ssl_cert?$AA@ ; "ssl_cert"
		dd offset ??_C@_0M@OAEAFGMD@ssl_session?$AA@ ; "ssl_session"
		dd offset ??_C@_0O@LOCLBOHA@ssl_sess_cert?$AA@ ; "ssl_sess_cert"
		dd offset ??_C@_03DIMONNDD@ssl?$AA@ ; `string'
		dd offset ??_C@_0L@NKBFNPDB@ssl_method?$AA@ ; "ssl_method"
		dd offset ??_C@_04HKINGDKC@rand?$AA@ ; "rand"
		dd offset ??_C@_05NFNCBLNG@rand2?$AA@ ;	"rand2"
		dd offset ??_C@_0N@CLEMOJNL@debug_malloc?$AA@ ;	"debug_malloc"
		dd offset ??_C@_03OHAMFFNA@BIO?$AA@ ; `string'
		dd offset ??_C@_0O@BFBCKHPD@gethostbyname?$AA@ ; "gethostbyname"
		dd offset ??_C@_0O@NKLJGHIL@getservbyname?$AA@ ; "getservbyname"
		dd offset ??_C@_07OMHHFDME@readdir?$AA@	; "readdir"
		dd offset ??_C@_0N@BGAJKBNF@RSA_blinding?$AA@ ;	"RSA_blinding"
		dd offset ??_C@_02OCEEKELO@dh?$AA@ ; `string'
		dd offset ??_C@_0O@PMFKBDME@debug_malloc2?$AA@ ; "debug_malloc2"
		dd offset ??_C@_03NOCNOBNG@dso?$AA@ ; `string'
		dd offset ??_C@_07HGGNMPAJ@dynlock?$AA@	; "dynlock"
		dd offset ??_C@_06LOBMEHPF@engine?$AA@ ; "engine"
		dd offset ??_C@_02OGLLFMLI@ui?$AA@ ; `string'
		dd offset ??_C@_05FGIDCBJD@ecdsa?$AA@ ;	"ecdsa"
		dd offset ??_C@_02HCBHEC@ec?$AA@ ; `string'
		dd offset ??_C@_04KDGGCKGB@ecdh?$AA@ ; "ecdh"
		dd offset ??_C@_02LAJDHPIK@bn?$AA@ ; `string'
		dd offset ??_C@_0M@FNJFEIGB@ec_pre_comp?$AA@ ; "ec_pre_comp"
		dd offset ??_C@_05ODGDKDLF@store?$AA@ ;	"store"
		dd offset ??_C@_04OLDKMDKP@comp?$AA@ ; "comp"
		dd offset ??_C@_04DJGCHAOD@fips?$AA@ ; "fips"
		dd offset ??_C@_05NEEKIFMD@fips2?$AA@ ;	"fips2"
_hash_coeffs	dd 0B070503h, 1713110Dh
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4h
; COMDAT (pick any)
		public ??_C@_09OGFJIAEE@?$DM?$DMERROR?$DO?$DO?$AA@
; `string'
??_C@_09OGFJIAEE@?$DM?$DMERROR?$DO?$DO?$AA@ db '<<ERROR>>',0
					; DATA XREF: .rdata:_lock_nameso
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F0h
; COMDAT (pick any)
		public ??_C@_03JIDPIAJI@err?$AA@
; `string'
??_C@_03JIDPIAJI@err?$AA@ dd 727265h	; DATA XREF: .rdata:0000003Co
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F4h
; COMDAT (pick any)
		public ??_C@_07OALPHBKG@ex_data?$AA@
; `string'
??_C@_07OALPHBKG@ex_data?$AA@ db 'ex_data',0 ; DATA XREF: .rdata:00000040o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0FCh
; COMDAT (pick any)
		public ??_C@_04BNGFMDFF@x509?$AA@
; `string'
??_C@_04BNGFMDFF@x509?$AA@ db 'x509',0  ; DATA XREF: .rdata:00000044o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 104h
; COMDAT (pick any)
		public ??_C@_09DJEHILFA@x509_info?$AA@
; `string'
??_C@_09DJEHILFA@x509_info?$AA@	db 'x509_info',0 ; DATA XREF: .rdata:00000048o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 110h
; COMDAT (pick any)
		public ??_C@_09HNLHIFBP@x509_pkey?$AA@
; `string'
??_C@_09HNLHIFBP@x509_pkey?$AA@	db 'x509_pkey',0 ; DATA XREF: .rdata:0000004Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 11Ch
; COMDAT (pick any)
		public ??_C@_08BJFLLMNA@x509_crl?$AA@
; `string'
??_C@_08BJFLLMNA@x509_crl?$AA@ db 'x509_crl',0 ; DATA XREF: .rdata:00000050o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 128h
; COMDAT (pick any)
		public ??_C@_08BHPLFFMD@x509_req?$AA@
; `string'
??_C@_08BHPLFFMD@x509_req?$AA@ db 'x509_req',0 ; DATA XREF: .rdata:00000054o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 134h
; COMDAT (pick any)
		public ??_C@_03EAKOMMFI@dsa?$AA@
; `string'
??_C@_03EAKOMMFI@dsa?$AA@ dd 617364h	; DATA XREF: .rdata:00000058o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 138h
; COMDAT (pick any)
		public ??_C@_03DFNMMEBL@rsa?$AA@
; `string'
??_C@_03DFNMMEBL@rsa?$AA@ dd 617372h	; DATA XREF: .rdata:0000005Co
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 13Ch
; COMDAT (pick any)
		public ??_C@_08NBJJIGBN@evp_pkey?$AA@
; `string'
??_C@_08NBJJIGBN@evp_pkey?$AA@ db 'evp_pkey',0 ; DATA XREF: .rdata:00000060o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 148h
; COMDAT (pick any)
		public ??_C@_0L@JCDDFIOK@x509_store?$AA@
; `string'
??_C@_0L@JCDDFIOK@x509_store?$AA@ db 'x509_store',0 ; DATA XREF: .rdata:00000064o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 154h
; COMDAT (pick any)
		public ??_C@_07DNHKIAPH@ssl_ctx?$AA@
; `string'
??_C@_07DNHKIAPH@ssl_ctx?$AA@ db 'ssl_ctx',0 ; DATA XREF: .rdata:00000068o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 15Ch
; COMDAT (pick any)
		public ??_C@_08INIFBEOB@ssl_cert?$AA@
; `string'
??_C@_08INIFBEOB@ssl_cert?$AA@ db 'ssl_cert',0 ; DATA XREF: .rdata:0000006Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 168h
; COMDAT (pick any)
		public ??_C@_0M@OAEAFGMD@ssl_session?$AA@
; `string'
??_C@_0M@OAEAFGMD@ssl_session?$AA@ db 'ssl_session',0 ; DATA XREF: .rdata:00000070o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 174h
; COMDAT (pick any)
		public ??_C@_0O@LOCLBOHA@ssl_sess_cert?$AA@
; `string'
??_C@_0O@LOCLBOHA@ssl_sess_cert?$AA@ db	'ssl_sess_cert',0 ; DATA XREF: .rdata:00000074o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 184h
; COMDAT (pick any)
		public ??_C@_03DIMONNDD@ssl?$AA@
; `string'
??_C@_03DIMONNDD@ssl?$AA@ dd 6C7373h	; DATA XREF: .rdata:00000078o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 188h
; COMDAT (pick any)
		public ??_C@_0L@NKBFNPDB@ssl_method?$AA@
; `string'
??_C@_0L@NKBFNPDB@ssl_method?$AA@ db 'ssl_method',0 ; DATA XREF: .rdata:0000007Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 194h
; COMDAT (pick any)
		public ??_C@_04HKINGDKC@rand?$AA@
; `string'
??_C@_04HKINGDKC@rand?$AA@ db 'rand',0  ; DATA XREF: .rdata:00000080o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 19Ch
; COMDAT (pick any)
		public ??_C@_05NFNCBLNG@rand2?$AA@
; `string'
??_C@_05NFNCBLNG@rand2?$AA@ db 'rand2',0 ; DATA XREF: .rdata:00000084o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1A4h
; COMDAT (pick any)
		public ??_C@_0N@CLEMOJNL@debug_malloc?$AA@
; `string'
??_C@_0N@CLEMOJNL@debug_malloc?$AA@ db 'debug_malloc',0 ; DATA XREF: .rdata:00000088o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1B4h
; COMDAT (pick any)
		public ??_C@_03OHAMFFNA@BIO?$AA@
; `string'
??_C@_03OHAMFFNA@BIO?$AA@ dd 4F4942h	; DATA XREF: .rdata:0000008Co
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1B8h
; COMDAT (pick any)
		public ??_C@_0O@BFBCKHPD@gethostbyname?$AA@
; `string'
??_C@_0O@BFBCKHPD@gethostbyname?$AA@ db	'gethostbyname',0 ; DATA XREF: .rdata:00000090o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1C8h
; COMDAT (pick any)
		public ??_C@_0O@NKLJGHIL@getservbyname?$AA@
; `string'
??_C@_0O@NKLJGHIL@getservbyname?$AA@ db	'getservbyname',0 ; DATA XREF: .rdata:00000094o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1D8h
; COMDAT (pick any)
		public ??_C@_07OMHHFDME@readdir?$AA@
; `string'
??_C@_07OMHHFDME@readdir?$AA@ db 'readdir',0 ; DATA XREF: .rdata:00000098o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1E0h
; COMDAT (pick any)
		public ??_C@_0N@BGAJKBNF@RSA_blinding?$AA@
; `string'
??_C@_0N@BGAJKBNF@RSA_blinding?$AA@ db 'RSA_blinding',0 ; DATA XREF: .rdata:0000009Co
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1F0h
; COMDAT (pick any)
		public ??_C@_02OCEEKELO@dh?$AA@
; `string'
??_C@_02OCEEKELO@dh?$AA@ db 64h, 68h, 0	; DATA XREF: .rdata:000000A0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1F4h
; COMDAT (pick any)
		public ??_C@_0O@PMFKBDME@debug_malloc2?$AA@
; `string'
??_C@_0O@PMFKBDME@debug_malloc2?$AA@ db	'debug_malloc2',0 ; DATA XREF: .rdata:000000A4o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 204h
; COMDAT (pick any)
		public ??_C@_03NOCNOBNG@dso?$AA@
; `string'
??_C@_03NOCNOBNG@dso?$AA@ dd 6F7364h	; DATA XREF: .rdata:000000A8o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 208h
; COMDAT (pick any)
		public ??_C@_07HGGNMPAJ@dynlock?$AA@
; `string'
??_C@_07HGGNMPAJ@dynlock?$AA@ db 'dynlock',0 ; DATA XREF: .rdata:000000ACo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 210h
; COMDAT (pick any)
		public ??_C@_06LOBMEHPF@engine?$AA@
; `string'
??_C@_06LOBMEHPF@engine?$AA@ db	'engine',0 ; DATA XREF: .rdata:000000B0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 218h
; COMDAT (pick any)
		public ??_C@_02OGLLFMLI@ui?$AA@
; `string'
??_C@_02OGLLFMLI@ui?$AA@ db 75h, 69h, 0	; DATA XREF: .rdata:000000B4o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 21Ch
; COMDAT (pick any)
		public ??_C@_05FGIDCBJD@ecdsa?$AA@
; `string'
??_C@_05FGIDCBJD@ecdsa?$AA@ db 'ecdsa',0 ; DATA XREF: .rdata:000000B8o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 224h
; COMDAT (pick any)
		public ??_C@_02HCBHEC@ec?$AA@
; `string'
??_C@_02HCBHEC@ec?$AA@ db 65h, 63h, 0	; DATA XREF: .rdata:000000BCo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 228h
; COMDAT (pick any)
		public ??_C@_04KDGGCKGB@ecdh?$AA@
; `string'
??_C@_04KDGGCKGB@ecdh?$AA@ db 'ecdh',0  ; DATA XREF: .rdata:000000C0o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 230h
; COMDAT (pick any)
		public ??_C@_02LAJDHPIK@bn?$AA@
; `string'
??_C@_02LAJDHPIK@bn?$AA@ db 62h, 6Eh, 0	; DATA XREF: .rdata:000000C4o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 234h
; COMDAT (pick any)
		public ??_C@_0M@FNJFEIGB@ec_pre_comp?$AA@
; `string'
??_C@_0M@FNJFEIGB@ec_pre_comp?$AA@ db 'ec_pre_comp',0 ; DATA XREF: .rdata:000000C8o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 240h
; COMDAT (pick any)
		public ??_C@_05ODGDKDLF@store?$AA@
; `string'
??_C@_05ODGDKDLF@store?$AA@ db 'store',0 ; DATA XREF: .rdata:000000CCo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 248h
; COMDAT (pick any)
		public ??_C@_04OLDKMDKP@comp?$AA@
; `string'
??_C@_04OLDKMDKP@comp?$AA@ db 'comp',0  ; DATA XREF: .rdata:000000D0o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 250h
; COMDAT (pick any)
		public ??_C@_04DJGCHAOD@fips?$AA@
; `string'
??_C@_04DJGCHAOD@fips?$AA@ db 'fips',0  ; DATA XREF: .rdata:000000D4o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 258h
; COMDAT (pick any)
		public ??_C@_05NEEKIFMD@fips2?$AA@
; `string'
??_C@_05NEEKIFMD@fips2?$AA@ db 'fips2',0 ; DATA XREF: .rdata:000000D8o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 260h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_THREADID_cmp
_CRYPTO_THREADID_cmp proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		mov	edx, [esp+arg_4]
		push	esi
		mov	esi, 4
		xchg	ax, ax

loc_270:				; CODE XREF: _CRYPTO_THREADID_cmp+1Fj
		mov	eax, [ecx]
		cmp	eax, [edx]
		jnz	short loc_285
		add	ecx, 4
		add	edx, 4
		sub	esi, 4
		jnb	short loc_270
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_285:				; CODE XREF: _CRYPTO_THREADID_cmp+14j
		cmp	al, [edx]
		jnz	short loc_2A5
		mov	al, [ecx+1]
		cmp	al, [edx+1]
		jnz	short loc_2A5
		mov	al, [ecx+2]
		cmp	al, [edx+2]
		jnz	short loc_2A5
		mov	al, [ecx+3]
		cmp	al, [edx+3]
		jnz	short loc_2A5
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_2A5:				; CODE XREF: _CRYPTO_THREADID_cmp+27j
					; _CRYPTO_THREADID_cmp+2Fj ...
		sbb	eax, eax
		or	eax, 1
		pop	esi
		retn
_CRYPTO_THREADID_cmp endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2ACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_THREADID_cpy
_CRYPTO_THREADID_cpy proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		mov	ecx, [esp+arg_0]
		mov	eax, [edx]
		mov	[ecx], eax
		mov	eax, [edx+4]
		mov	[ecx+4], eax
		retn
_CRYPTO_THREADID_cpy endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2C0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_THREADID_current
_CRYPTO_THREADID_current proc near

arg_0		= dword	ptr  4

		mov	eax, ds:_threadid_callback
		test	eax, eax
		jz	short loc_2CB
		jmp	eax
; ---------------------------------------------------------------------------

loc_2CB:				; CODE XREF: _CRYPTO_THREADID_current+7j
		mov	eax, ds:_id_callback
		test	eax, eax
		jz	short loc_2E5
		call	eax ; _id_callback
		mov	ecx, [esp+arg_0]
		xorps	xmm0, xmm0
		movq	qword ptr [ecx], xmm0
		mov	[ecx+4], eax
		retn
; ---------------------------------------------------------------------------

loc_2E5:				; CODE XREF: _CRYPTO_THREADID_current+12j
		call	dword ptr ds:__imp__GetCurrentThreadId@0 ; GetCurrentThreadId()
		mov	ecx, [esp+arg_0]
		xorps	xmm0, xmm0
		movq	qword ptr [ecx], xmm0
		mov	[ecx+4], eax
		retn
_CRYPTO_THREADID_current endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2FCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_THREADID_get_callback
_CRYPTO_THREADID_get_callback proc near
		mov	eax, ds:_threadid_callback
		retn
_CRYPTO_THREADID_get_callback endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 304h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_THREADID_hash
_CRYPTO_THREADID_hash proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+4]
		retn
_CRYPTO_THREADID_hash endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 30Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_THREADID_set_callback
_CRYPTO_THREADID_set_callback proc near

arg_0		= dword	ptr  4

		cmp	ds:_threadid_callback, 0
		jz	short loc_318
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_318:				; CODE XREF: _CRYPTO_THREADID_set_callback+7j
		mov	eax, [esp+arg_0]
		mov	ds:_threadid_callback, eax
		mov	eax, 1
		retn
_CRYPTO_THREADID_set_callback endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 328h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_THREADID_set_numeric
_CRYPTO_THREADID_set_numeric proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		xorps	xmm0, xmm0
		mov	eax, [esp+arg_4]
		movq	qword ptr [ecx], xmm0
		mov	[ecx+4], eax
		retn
_CRYPTO_THREADID_set_numeric endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 33Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_THREADID_set_pointer
_CRYPTO_THREADID_set_pointer proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		xorps	xmm0, xmm0
		mov	eax, [esp+arg_4]
		movq	qword ptr [ecx], xmm0
		mov	[ecx], eax
		mov	[ecx+4], eax
		retn
_CRYPTO_THREADID_set_pointer endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 354h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_add_lock
_CRYPTO_add_lock proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	eax, ds:_add_lock_callback
		test	eax, eax
		jz	short loc_35F
		jmp	eax
; ---------------------------------------------------------------------------

loc_35F:				; CODE XREF: _CRYPTO_add_lock+7j
		push	esi
		push	[esp+4+arg_10]
		push	[esp+8+arg_C]
		push	[esp+0Ch+arg_8]
		push	9
		call	_CRYPTO_lock
		push	[esp+14h+arg_10]
		mov	ecx, [esp+18h+arg_0]
		push	[esp+18h+arg_C]
		push	[esp+1Ch+arg_8]
		mov	esi, [ecx]
		add	esi, [esp+20h+arg_4]
		push	0Ah
		mov	[ecx], esi
		call	_CRYPTO_lock
		add	esp, 20h
		mov	eax, esi
		pop	esi
		retn
_CRYPTO_add_lock endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 39Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_destroy_dynlockid
_CRYPTO_destroy_dynlockid proc near	; CODE XREF: _CRYPTO_lock+33p

arg_0		= dword	ptr  4

		push	edi
		mov	edi, [esp+4+arg_0]
		test	edi, edi
		jz	short loc_3AC
		or	eax, 0FFFFFFFFh
		sub	eax, edi
		mov	edi, eax

loc_3AC:				; CODE XREF: _CRYPTO_destroy_dynlockid+7j
		cmp	ds:_dynlock_destroy_callback, 0
		jz	loc_44E
		push	133h
		push	offset ??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@ ; ".\\crypto\\cryptlib.c"
		push	1Dh
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_dyn_locks
		add	esp, 10h
		test	eax, eax
		jz	short loc_450
		push	eax
		call	_sk_num
		add	esp, 4
		cmp	edi, eax
		jge	short loc_450
		push	esi
		push	edi
		push	ds:_dyn_locks
		call	_sk_value
		mov	esi, eax
		add	esp, 8
		test	esi, esi
		jz	short loc_417
		dec	dword ptr [esi]
		cmp	dword ptr [esi], 0
		jg	short loc_415
		push	0
		push	edi
		push	ds:_dyn_locks
		call	_sk_set
		add	esp, 0Ch
		jmp	short loc_417
; ---------------------------------------------------------------------------

loc_415:				; CODE XREF: _CRYPTO_destroy_dynlockid+64j
		xor	esi, esi

loc_417:				; CODE XREF: _CRYPTO_destroy_dynlockid+5Dj
					; _CRYPTO_destroy_dynlockid+77j
		push	148h
		push	offset ??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@ ; ".\\crypto\\cryptlib.c"
		push	1Dh
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h
		test	esi, esi
		jz	short loc_44D
		push	14Bh
		push	offset ??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@ ; ".\\crypto\\cryptlib.c"
		push	dword ptr [esi+4]
		call	ds:_dynlock_destroy_callback
		push	esi
		call	_CRYPTO_free
		add	esp, 10h

loc_44D:				; CODE XREF: _CRYPTO_destroy_dynlockid+93j
		pop	esi

loc_44E:				; CODE XREF: _CRYPTO_destroy_dynlockid+17j
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_450:				; CODE XREF: _CRYPTO_destroy_dynlockid+3Aj
					; _CRYPTO_destroy_dynlockid+47j
		push	136h
		push	offset ??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@ ; ".\\crypto\\cryptlib.c"
		push	1Dh
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h
		pop	edi
		retn
_CRYPTO_destroy_dynlockid endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 468h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_get_add_lock_callback
_CRYPTO_get_add_lock_callback proc near
		mov	eax, ds:_add_lock_callback
		retn
_CRYPTO_get_add_lock_callback endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 470h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_get_dynlock_create_callback
_CRYPTO_get_dynlock_create_callback proc near
		mov	eax, ds:_dynlock_create_callback
		retn
_CRYPTO_get_dynlock_create_callback endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 478h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_get_dynlock_destroy_callback
_CRYPTO_get_dynlock_destroy_callback proc near
		mov	eax, ds:_dynlock_destroy_callback
		retn
_CRYPTO_get_dynlock_destroy_callback endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 480h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_get_dynlock_lock_callback
_CRYPTO_get_dynlock_lock_callback proc near
		mov	eax, ds:_dynlock_lock_callback
		retn
_CRYPTO_get_dynlock_lock_callback endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 488h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_get_dynlock_value
_CRYPTO_get_dynlock_value proc near	; CODE XREF: _CRYPTO_lock+13p

arg_0		= dword	ptr  4

		push	esi
		push	edi
		mov	edi, [esp+8+arg_0]
		xor	esi, esi
		test	edi, edi
		jz	short loc_49B
		or	eax, 0FFFFFFFFh
		sub	eax, edi
		mov	edi, eax

loc_49B:				; CODE XREF: _CRYPTO_get_dynlock_value+Aj
		push	156h
		push	offset ??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@ ; ".\\crypto\\cryptlib.c"
		push	1Dh
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_dyn_locks
		add	esp, 10h
		test	eax, eax
		jz	short loc_4DE
		push	eax
		call	_sk_num
		add	esp, 4
		cmp	edi, eax
		jge	short loc_4DE
		push	edi
		push	ds:_dyn_locks
		call	_sk_value
		mov	esi, eax
		add	esp, 8
		test	esi, esi
		jz	short loc_4DE
		inc	dword ptr [esi]

loc_4DE:				; CODE XREF: _CRYPTO_get_dynlock_value+30j
					; _CRYPTO_get_dynlock_value+3Dj ...
		push	15Dh
		push	offset ??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@ ; ".\\crypto\\cryptlib.c"
		push	1Dh
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h
		test	esi, esi
		jz	short loc_4FE
		mov	eax, [esi+4]
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_4FE:				; CODE XREF: _CRYPTO_get_dynlock_value+6Ej
		pop	edi
		xor	eax, eax
		pop	esi
		retn
_CRYPTO_get_dynlock_value endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 504h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_get_id_callback
_CRYPTO_get_id_callback	proc near
		mov	eax, ds:_id_callback
		retn
_CRYPTO_get_id_callback	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 50Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_get_lock_name
_CRYPTO_get_lock_name proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jns	short loc_51A
		mov	eax, offset ??_C@_07OBLKMMON@dynamic?$AA@ ; "dynamic"
		retn
; ---------------------------------------------------------------------------

loc_51A:				; CODE XREF: _CRYPTO_get_lock_name+6j
		cmp	eax, 29h ; ')'
		jge	short loc_527
		mov	eax, _lock_names[eax*4]
		retn
; ---------------------------------------------------------------------------

loc_527:				; CODE XREF: _CRYPTO_get_lock_name+11j
		push	esi
		push	ds:_app_locks
		lea	esi, [eax-29h]
		call	_sk_num
		add	esp, 4
		cmp	esi, eax
		jle	short loc_544
		mov	eax, offset ??_C@_05MBDEGLCK@ERROR?$AA@	; "ERROR"
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_544:				; CODE XREF: _CRYPTO_get_lock_name+2Fj
		push	esi
		push	ds:_app_locks
		call	_sk_value
		add	esp, 8
		pop	esi
		retn
_CRYPTO_get_lock_name endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 558h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_get_locking_callback
_CRYPTO_get_locking_callback proc near
		mov	eax, ds:_locking_callback
		retn
_CRYPTO_get_locking_callback endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 560h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_get_new_dynlockid
_CRYPTO_get_new_dynlockid proc near
		cmp	ds:_dynlock_create_callback, 0
		jnz	short loc_584
		push	0F8h ; 'ø'
		push	offset ??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@ ; ".\\crypto\\cryptlib.c"
		push	64h ; 'd'
		push	67h ; 'g'
		push	0Fh
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_584:				; CODE XREF: _CRYPTO_get_new_dynlockid+7j
		mov	eax, ds:_locking_callback
		test	eax, eax
		jz	short loc_5A5
		push	0FBh ; 'û'
		push	offset ??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@ ; ".\\crypto\\cryptlib.c"
		push	1Dh
		push	9
		call	eax ; _locking_callback
		mov	eax, ds:_locking_callback
		add	esp, 10h

loc_5A5:				; CODE XREF: _CRYPTO_get_new_dynlockid+2Bj
		cmp	ds:_dyn_locks, 0
		jnz	short loc_5F3
		call	_sk_new_null
		mov	ds:_dyn_locks, eax
		test	eax, eax
		mov	eax, ds:_locking_callback
		jnz	short loc_5F3
		test	eax, eax
		jz	short loc_5D8
		push	0FEh ; 'þ'
		push	offset ??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@ ; ".\\crypto\\cryptlib.c"
		push	1Dh
		push	0Ah
		call	eax ; _locking_callback
		add	esp, 10h

loc_5D8:				; CODE XREF: _CRYPTO_get_new_dynlockid+63j
		push	0FFh
		push	offset ??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@ ; ".\\crypto\\cryptlib.c"
		push	41h ; 'A'
		push	67h ; 'g'
		push	0Fh
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_5F3:				; CODE XREF: _CRYPTO_get_new_dynlockid+4Cj
					; _CRYPTO_get_new_dynlockid+5Fj
		test	eax, eax
		jz	short loc_60A
		push	102h
		push	offset ??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@ ; ".\\crypto\\cryptlib.c"
		push	1Dh
		push	0Ah
		call	eax ; _locking_callback
		add	esp, 10h

loc_60A:				; CODE XREF: _CRYPTO_get_new_dynlockid+95j
		push	edi
		push	104h
		push	offset ??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@ ; ".\\crypto\\cryptlib.c"
		push	8
		call	_CRYPTO_malloc
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jnz	short loc_641
		push	106h
		push	offset ??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@ ; ".\\crypto\\cryptlib.c"
		push	41h ; 'A'
		push	67h ; 'g'
		push	0Fh
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_641:				; CODE XREF: _CRYPTO_get_new_dynlockid+C3j
		push	10Ah
		push	offset ??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@ ; ".\\crypto\\cryptlib.c"
		mov	dword ptr [edi], 1
		call	ds:_dynlock_create_callback
		add	esp, 8
		mov	[edi+4], eax
		test	eax, eax
		jnz	short loc_683
		push	edi
		call	_CRYPTO_free
		push	10Dh
		push	offset ??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@ ; ".\\crypto\\cryptlib.c"
		push	41h ; 'A'
		push	67h ; 'g'
		push	0Fh
		call	_ERR_put_error
		add	esp, 18h
		xor	eax, eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_683:				; CODE XREF: _CRYPTO_get_new_dynlockid+FFj
		mov	eax, ds:_locking_callback
		test	eax, eax
		jz	short loc_69F
		push	111h
		push	offset ??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@ ; ".\\crypto\\cryptlib.c"
		push	1Dh
		push	9
		call	eax ; _locking_callback
		add	esp, 10h

loc_69F:				; CODE XREF: _CRYPTO_get_new_dynlockid+12Aj
		push	esi
		push	0
		push	ds:_dyn_locks
		call	_sk_find
		add	esp, 8
		mov	esi, eax
		push	edi
		cmp	esi, 0FFFFFFFFh
		jnz	short loc_6CB
		push	ds:_dyn_locks
		call	_sk_push
		add	esp, 8
		lea	esi, [eax-1]
		jmp	short loc_6DA
; ---------------------------------------------------------------------------

loc_6CB:				; CODE XREF: _CRYPTO_get_new_dynlockid+156j
		push	esi
		push	ds:_dyn_locks
		call	_sk_set
		add	esp, 0Ch

loc_6DA:				; CODE XREF: _CRYPTO_get_new_dynlockid+169j
		mov	eax, ds:_locking_callback
		test	eax, eax
		jz	short loc_6F6
		push	121h
		push	offset ??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@ ; ".\\crypto\\cryptlib.c"
		push	1Dh
		push	0Ah
		call	eax ; _locking_callback
		add	esp, 10h

loc_6F6:				; CODE XREF: _CRYPTO_get_new_dynlockid+181j
		cmp	esi, 0FFFFFFFFh
		jnz	short loc_71E
		push	124h
		push	offset ??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@ ; ".\\crypto\\cryptlib.c"
		push	dword ptr [edi+4]
		call	ds:_dynlock_destroy_callback
		push	edi
		call	_CRYPTO_free
		add	esp, 10h
		neg	esi
		mov	eax, esi
		pop	esi
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_71E:				; CODE XREF: _CRYPTO_get_new_dynlockid+199j
		inc	esi
		neg	esi
		mov	eax, esi
		pop	esi
		pop	edi
		retn
_CRYPTO_get_new_dynlockid endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 728h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_get_new_lockid
_CRYPTO_get_new_lockid proc near

arg_0		= dword	ptr  4

		cmp	ds:_app_locks, 0
		push	esi
		mov	esi, [esp+4+arg_0]
		movsx	eax, byte ptr [esi+1]
		movd	xmm1, eax
		movsx	eax, byte ptr [esi]
		cvtdq2pd xmm1, xmm1
		movd	xmm0, eax
		cvtdq2pd xmm0, xmm0
		mulsd	xmm1, xmm0
		movsd	ds:_SSLeay_MSVC5_hack, xmm1
		jnz	short loc_783
		call	_sk_new_null
		mov	ds:_app_locks, eax
		test	eax, eax
		jnz	short loc_783
		push	0DDh ; 'Ý'
		push	offset ??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@ ; ".\\crypto\\cryptlib.c"
		push	41h ; 'A'
		push	65h ; 'e'
		push	0Fh
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_783:				; CODE XREF: _CRYPTO_get_new_lockid+2Fj
					; _CRYPTO_get_new_lockid+3Dj
		push	edi
		push	esi
		call	_BUF_strdup
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jnz	short loc_7B0
		push	0E1h ; 'á'
		push	offset ??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@ ; ".\\crypto\\cryptlib.c"
		push	41h ; 'A'
		push	65h ; 'e'
		push	0Fh
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_7B0:				; CODE XREF: _CRYPTO_get_new_lockid+69j
		push	edi
		push	ds:_app_locks
		call	_sk_push
		mov	esi, eax
		add	esp, 8
		test	esi, esi
		jnz	short loc_7D3
		push	edi
		call	_CRYPTO_free
		add	esp, 4
		mov	eax, esi
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_7D3:				; CODE XREF: _CRYPTO_get_new_lockid+9Bj
		add	esi, 29h ; ')'
		pop	edi
		mov	eax, esi
		pop	esi
		retn
_CRYPTO_get_new_lockid endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7DCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_lock
_CRYPTO_lock	proc near		; CODE XREF: _CRYPTO_add_lock+1Ap
					; _CRYPTO_add_lock+39p	...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	esi
		mov	esi, [esp+4+arg_4]
		test	esi, esi
		jns	short loc_819
		cmp	ds:_dynlock_lock_callback, 0
		jz	short loc_834
		push	esi
		call	_CRYPTO_get_dynlock_value
		add	esp, 4
		test	eax, eax
		jz	short loc_836
		push	[esp+4+arg_C]
		push	[esp+8+arg_8]
		push	eax
		push	[esp+10h+arg_0]
		call	ds:_dynlock_lock_callback
		push	esi
		call	_CRYPTO_destroy_dynlockid
		add	esp, 14h
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_819:				; CODE XREF: _CRYPTO_lock+7j
		mov	eax, ds:_locking_callback
		test	eax, eax
		jz	short loc_834
		push	[esp+4+arg_C]
		push	[esp+8+arg_8]
		push	esi
		push	[esp+10h+arg_0]
		call	eax ; _locking_callback
		add	esp, 10h

loc_834:				; CODE XREF: _CRYPTO_lock+10j
					; _CRYPTO_lock+44j
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_836:				; CODE XREF: _CRYPTO_lock+1Dj
		push	offset ??_C@_0BA@LPBALOME@pointer?5?$CB?$DN?5NULL?$AA@ ; "pointer != NULL"
		push	24Dh
		push	offset ??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@ ; ".\\crypto\\cryptlib.c"
		call	_OpenSSLDie
_CRYPTO_lock	endp

; ---------------------------------------------------------------------------
$LN11		db 0CCh
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 84Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_memcmp
_CRYPTO_memcmp	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_8]
		xor	dl, dl
		test	esi, esi
		jz	short loc_873
		mov	eax, [esp+4+arg_0]
		push	edi
		mov	edi, [esp+8+arg_4]
		sub	edi, eax

loc_862:				; CODE XREF: _CRYPTO_memcmp+24j
		mov	cl, [edi+eax]
		lea	eax, [eax+1]
		xor	cl, [eax-1]
		or	dl, cl
		sub	esi, 1
		jnz	short loc_862
		pop	edi

loc_873:				; CODE XREF: _CRYPTO_memcmp+9j
		movzx	eax, dl
		pop	esi
		retn
_CRYPTO_memcmp	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 878h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_num_locks
_CRYPTO_num_locks proc near
		mov	eax, 29h ; ')'
		retn
_CRYPTO_num_locks endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 880h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_set_add_lock_callback
_CRYPTO_set_add_lock_callback proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	ds:_add_lock_callback, eax
		retn
_CRYPTO_set_add_lock_callback endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 88Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_set_dynlock_create_callback
_CRYPTO_set_dynlock_create_callback proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	ds:_dynlock_create_callback, eax
		retn
_CRYPTO_set_dynlock_create_callback endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 898h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_set_dynlock_destroy_callback
_CRYPTO_set_dynlock_destroy_callback proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	ds:_dynlock_destroy_callback, eax
		retn
_CRYPTO_set_dynlock_destroy_callback endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8A4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_set_dynlock_lock_callback
_CRYPTO_set_dynlock_lock_callback proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	ds:_dynlock_lock_callback, eax
		retn
_CRYPTO_set_dynlock_lock_callback endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8B0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_set_id_callback
_CRYPTO_set_id_callback	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	ds:_id_callback, eax
		retn
_CRYPTO_set_id_callback	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8BCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_set_locking_callback
_CRYPTO_set_locking_callback proc near

arg_0		= dword	ptr  4

		call	_OPENSSL_init
		mov	eax, [esp+arg_0]
		mov	ds:_locking_callback, eax
		retn
_CRYPTO_set_locking_callback endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8CCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_thread_id
_CRYPTO_thread_id proc near
		mov	eax, ds:_id_callback
		test	eax, eax
		jnz	short loc_8DB
		jmp	dword ptr ds:__imp__GetCurrentThreadId@0 ; GetCurrentThreadId()
; ---------------------------------------------------------------------------

loc_8DB:				; CODE XREF: _CRYPTO_thread_id+7j
		jmp	eax
_CRYPTO_thread_id endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8E0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
		public _DllMain@12
_DllMain@12	proc near

hinstDLL	= dword	ptr  4
fdwReason	= dword	ptr  8
lpvReserved	= dword	ptr  0Ch

		sub	[esp+fdwReason], 1
		jnz	short loc_923
		call	_OPENSSL_cpuid_setup
		mov	edx, [esp+hinstDLL]
		mov	eax, 5A4Dh
		cmp	[edx], ax
		jnz	short loc_923
		push	esi
		mov	esi, [edx+3Ch]
		mov	eax, 1
		cmp	dword ptr [esi+edx], 4550h
		jnz	short loc_91F
		cmp	edx, [esi+edx+34h]
		mov	ecx, ds:_OPENSSL_NONPIC_relocated
		cmovnz	ecx, eax
		mov	ds:_OPENSSL_NONPIC_relocated, ecx

loc_91F:				; CODE XREF: DllMain(x,x,x)+2Aj
		pop	esi
		retn	0Ch
; ---------------------------------------------------------------------------

loc_923:				; CODE XREF: DllMain(x,x,x)+5j
					; DllMain(x,x,x)+18j
		mov	eax, 1
		retn	0Ch
_DllMain@12	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 92Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _OPENSSL_cpuid_setup
_OPENSSL_cpuid_setup proc near		; CODE XREF: DllMain(x,x,x)+7p

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		mov	eax, 8
		call	__chkstk
		cmp	ds:?trigger@?1??OPENSSL_cpuid_setup@@9@9, 0 ; `OPENSSL_cpuid_setup'::`2'::trigger
		jnz	loc_A56
		push	ebx
		push	edi
		push	offset ??_C@_0BA@MIDPHNKH@OPENSSL_ia32cap?$AA@ ; "OPENSSL_ia32cap"
		mov	ds:?trigger@?1??OPENSSL_cpuid_setup@@9@9, 1 ; `OPENSSL_cpuid_setup'::`2'::trigger
		call	dword ptr ds:__imp__getenv
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jz	loc_A28
		xor	ebx, ebx
		lea	eax, [esp+10h+var_8]
		cmp	byte ptr [edi],	7Eh ; '~'
		push	esi
		setz	bl
		push	eax
		push	offset ??_C@_05OKCMKDO@?$CFI64i?$AA@ ; "%I64i"
		lea	esi, [ebx+edi]
		push	esi		; Src
		call	_sscanf
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_9A2
		push	eax		; Radix
		push	eax		; EndPtr
		push	esi		; Str
		call	dword ptr ds:__imp__strtoul
		add	esp, 0Ch
		mov	[esp+14h+var_8], eax
		mov	[esp+14h+var_4], 0

loc_9A2:				; CODE XREF: _OPENSSL_cpuid_setup+5Cj
		test	ebx, ebx
		jz	short loc_9C5
		push	offset _OPENSSL_ia32cap_P
		call	_OPENSSL_ia32_cpuid
		mov	esi, [esp+18h+var_8]
		add	esp, 4
		mov	ecx, [esp+14h+var_4]
		not	esi
		not	ecx
		and	eax, esi
		and	edx, ecx
		jmp	short loc_9D7
; ---------------------------------------------------------------------------

loc_9C5:				; CODE XREF: _OPENSSL_cpuid_setup+78j
		cmp	byte ptr [edi],	3Ah ; ':'
		jnz	short loc_9DF
		push	offset _OPENSSL_ia32cap_P
		call	_OPENSSL_ia32_cpuid
		add	esp, 4

loc_9D7:				; CODE XREF: _OPENSSL_cpuid_setup+97j
		mov	[esp+14h+var_4], edx
		mov	[esp+14h+var_8], eax

loc_9DF:				; CODE XREF: _OPENSSL_cpuid_setup+9Cj
		push	3Ah ; ':'       ; Val
		push	edi		; Str
		mov	dword ptr ds:_OPENSSL_ia32cap_P+8, 0
		call	dword ptr ds:__imp__strchr
		add	esp, 8
		pop	esi
		test	eax, eax
		jz	short loc_A3D
		inc	eax
		xor	ebx, ebx
		push	0		; Radix
		push	0		; EndPtr
		cmp	byte ptr [eax],	7Eh ; '~'
		setz	bl
		add	eax, ebx
		push	eax		; Str
		call	dword ptr ds:__imp__strtoul
		add	esp, 0Ch
		test	ebx, ebx
		jz	short loc_A21
		not	eax
		and	dword ptr ds:_OPENSSL_ia32cap_P+8, eax
		jmp	short loc_A3D
; ---------------------------------------------------------------------------

loc_A21:				; CODE XREF: _OPENSSL_cpuid_setup+E9j
		mov	dword ptr ds:_OPENSSL_ia32cap_P+8, eax
		jmp	short loc_A3D
; ---------------------------------------------------------------------------

loc_A28:				; CODE XREF: _OPENSSL_cpuid_setup+35j
		push	offset _OPENSSL_ia32cap_P
		call	_OPENSSL_ia32_cpuid
		add	esp, 4
		mov	[esp+10h+var_8], eax
		mov	[esp+10h+var_4], edx

loc_A3D:				; CODE XREF: _OPENSSL_cpuid_setup+CCj
					; _OPENSSL_cpuid_setup+F3j ...
		mov	eax, [esp+10h+var_8]
		or	eax, 400h
		mov	dword ptr ds:_OPENSSL_ia32cap_P, eax
		mov	eax, [esp+10h+var_4]
		pop	edi
		mov	dword ptr ds:_OPENSSL_ia32cap_P+4, eax
		pop	ebx

loc_A56:				; CODE XREF: _OPENSSL_cpuid_setup+11j
		add	esp, 8
		retn
_OPENSSL_cpuid_setup endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A5Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _OPENSSL_ia32cap_loc
_OPENSSL_ia32cap_loc proc near
		mov	dword ptr ds:_OPENSSL_ia32cap_P+4, 0
		mov	eax, offset _OPENSSL_ia32cap_P
		mov	dword ptr ds:_OPENSSL_ia32cap_P+8, 0
		retn
_OPENSSL_ia32cap_loc endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A78h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _OPENSSL_isservice
_OPENSSL_isservice proc	near		; CODE XREF: _OPENSSL_showfatal+DAp

Str		= dword	ptr -0Ch
nLengthNeeded	= dword	ptr -8
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		mov	eax, 0Ch
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, ebp
		mov	[ebp+var_4], eax
		mov	eax, ds:?_OPENSSL_isservice@?1??OPENSSL_isservice@@9@9 ; `OPENSSL_isservice'::`2'::_OPENSSL_isservice
		push	esi
		push	edi
		test	eax, eax
		jnz	loc_B7E
		push	eax		; lpModuleName
		call	dword ptr ds:__imp__GetModuleHandleA@4 ; GetModuleHandleA(x)
		test	eax, eax
		jz	short loc_ABC
		push	offset ??_C@_0BD@EHKNLPFP@_OPENSSL_isservice?$AA@ ; "_OPENSSL_isservice"
		push	eax		; hModule
		call	dword ptr ds:__imp__GetProcAddress@8 ; GetProcAddress(x,x)
		mov	ds:?_OPENSSL_isservice@?1??OPENSSL_isservice@@9@9, eax ; `OPENSSL_isservice'::`2'::_OPENSSL_isservice
		jmp	short loc_AC1
; ---------------------------------------------------------------------------

loc_ABC:				; CODE XREF: _OPENSSL_isservice+2Fj
		mov	eax, ds:?_OPENSSL_isservice@?1??OPENSSL_isservice@@9@9 ; `OPENSSL_isservice'::`2'::_OPENSSL_isservice

loc_AC1:				; CODE XREF: _OPENSSL_isservice+42j
		test	eax, eax
		jnz	loc_B7E
		mov	ds:?_OPENSSL_isservice@?1??OPENSSL_isservice@@9@9, 0FFFFFFFFh ;	`OPENSSL_isservice'::`2'::_OPENSSL_isservice

loc_AD3:				; CODE XREF: _OPENSSL_isservice+109j
		call	dword ptr ds:__imp__GetProcessWindowStation@0 ;	GetProcessWindowStation()
		mov	edi, eax
		test	edi, edi
		jz	loc_B9C
		lea	eax, [ebp+nLengthNeeded]
		push	eax		; lpnLengthNeeded
		push	0		; nLength
		push	0		; pvInfo
		push	2		; nIndex
		push	edi		; hObj
		call	dword ptr ds:__imp__GetUserObjectInformationW@20 ; GetUserObjectInformationW(x,x,x,x,x)
		test	eax, eax
		jnz	loc_B9C
		call	dword ptr ds:__imp__GetLastError@0 ; GetLastError()
		cmp	eax, 7Ah ; 'z'
		jnz	loc_B9C
		mov	esi, [ebp+nLengthNeeded]
		cmp	esi, 200h
		ja	loc_B9C
		inc	esi
		and	esi, 0FFFFFFFEh
		mov	[ebp+nLengthNeeded], esi
		lea	eax, [esi+2]
		call	__alloca_probe_16
		mov	eax, esp
		lea	ecx, [ebp+nLengthNeeded]
		push	ecx		; lpnLengthNeeded
		push	esi		; nLength
		push	eax		; pvInfo
		push	2		; nIndex
		push	edi		; hObj
		mov	[ebp+Str], eax
		call	dword ptr ds:__imp__GetUserObjectInformationW@20 ; GetUserObjectInformationW(x,x,x,x,x)
		test	eax, eax
		jz	short loc_B9C
		mov	eax, [ebp+nLengthNeeded]
		xor	edx, edx
		mov	ecx, [ebp+Str]
		inc	eax
		and	eax, 0FFFFFFFEh
		mov	[ebp+nLengthNeeded], eax
		shr	eax, 1
		push	offset ??_C@_1BG@MLNJHGBB@?$AAS?$AAe?$AAr?$AAv?$AAi?$AAc?$AAe?$AA?9?$AA0?$AAx?$AA?$AA@ ; "Service-0x"
		push	ecx		; Str
		mov	[ecx+eax*2], dx
		call	dword ptr ds:__imp__wcsstr
		add	esp, 8
		neg	eax
		sbb	eax, eax
		neg	eax
		lea	esp, [ebp-14h]
		pop	edi
		pop	esi
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_B7E:				; CODE XREF: _OPENSSL_isservice+20j
					; _OPENSSL_isservice+4Bj
		cmp	eax, 0FFFFFFFFh
		jz	loc_AD3
		call	eax ; `OPENSSL_isservice'::`2'::_OPENSSL_isservice
		lea	esp, [ebp-14h]
		pop	edi
		pop	esi
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_B9C:				; CODE XREF: _OPENSSL_isservice+65j
					; _OPENSSL_isservice+7Ej ...
		or	eax, 0FFFFFFFFh
		lea	esp, [ebp-14h]
		pop	edi
		pop	esi
		mov	ecx, [ebp+var_4]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
_OPENSSL_isservice endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0BB4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _OPENSSL_showfatal
_OPENSSL_showfatal proc	near		; CODE XREF: _OpenSSLDie+11p

NumberOfBytesWritten= dword ptr	-108h
Buffer		= byte ptr -104h
var_5		= byte ptr -5
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= byte ptr  8

		mov	eax, 108h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+108h+var_4], eax
		push	esi
		push	0FFFFFFF4h	; nStdHandle
		call	dword ptr ds:__imp__GetStdHandle@4 ; GetStdHandle(x)
		mov	esi, eax
		test	esi, esi
		jz	short loc_C54
		push	esi		; hFile
		call	dword ptr ds:__imp__GetFileType@4 ; GetFileType(x)
		test	eax, eax
		jz	short loc_C54
		lea	eax, [esp+10Ch+arg_4]
		push	eax
		push	0
		push	[esp+114h+arg_0]
		lea	eax, [esp+118h+Buffer]
		push	100h
		push	eax
		call	___local_stdio_printf_options
		mov	ecx, [eax]
		push	dword ptr [eax+4]
		or	ecx, 1
		push	ecx
		call	dword ptr ds:__imp____stdio_common_vsprintf
		add	esp, 1Ch
		or	ecx, 0FFFFFFFFh
		test	eax, eax
		cmovs	eax, ecx
		lea	ecx, [esp+10Ch+NumberOfBytesWritten]
		push	0		; lpOverlapped
		push	ecx		; lpNumberOfBytesWritten
		test	eax, eax
		mov	ecx, 100h
		cmovs	eax, ecx
		push	eax		; nNumberOfBytesToWrite
		lea	eax, [esp+118h+Buffer]
		push	eax		; lpBuffer
		push	esi		; hFile
		call	dword ptr ds:__imp__WriteFile@20 ; WriteFile(x,x,x,x,x)
		pop	esi
		mov	ecx, [esp+108h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 108h
		retn
; ---------------------------------------------------------------------------

loc_C54:				; CODE XREF: _OPENSSL_showfatal+25j
					; _OPENSSL_showfatal+30j
		lea	eax, [esp+10Ch+arg_4]
		push	eax
		push	0
		push	[esp+114h+arg_0]
		lea	eax, [esp+118h+Buffer]
		push	0FFh
		push	eax
		call	___local_stdio_printf_options
		mov	ecx, [eax]
		push	dword ptr [eax+4]
		or	ecx, 1
		push	ecx
		call	dword ptr ds:__imp____stdio_common_vsprintf
		add	esp, 1Ch
		mov	[esp+10Ch+var_5], 0
		call	_OPENSSL_isservice
		test	eax, eax
		jle	short loc_CE9
		push	offset ??_C@_07BDLNEHJF@OpenSSL?$AA@ ; "OpenSSL"
		push	0		; lpUNCServerName
		call	dword ptr ds:__imp__RegisterEventSourceA@8 ; RegisterEventSourceA(x,x)
		mov	esi, eax
		test	esi, esi
		jz	short loc_CFD
		push	0		; lpRawData
		lea	eax, [esp+110h+Buffer]
		mov	[esp+110h+NumberOfBytesWritten], eax
		lea	eax, [esp+110h+NumberOfBytesWritten]
		push	eax		; lpStrings
		push	0		; dwDataSize
		push	1		; wNumStrings
		push	0		; lpUserSid
		push	0		; dwEventID
		push	0		; wCategory
		push	1		; wType
		push	esi		; hEventLog
		call	dword ptr ds:__imp__ReportEventA@36 ; ReportEventA(x,x,x,x,x,x,x,x,x)
		push	esi		; hEventLog
		call	dword ptr ds:__imp__DeregisterEventSource@4 ; DeregisterEventSource(x)
		pop	esi
		mov	ecx, [esp+108h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 108h
		retn
; ---------------------------------------------------------------------------

loc_CE9:				; CODE XREF: _OPENSSL_showfatal+E1j
		push	10h		; uType
		push	offset ??_C@_0P@LIPMGDB@OpenSSL?3?5FATAL?$AA@ ;	"OpenSSL: FATAL"
		lea	eax, [esp+114h+Buffer]
		push	eax		; lpText
		push	0		; hWnd
		call	dword ptr ds:__imp__MessageBoxA@16 ; MessageBoxA(x,x,x,x)

loc_CFD:				; CODE XREF: _OPENSSL_showfatal+F4j
		mov	ecx, [esp+10Ch+var_4]
		pop	esi
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 108h
		retn
_OPENSSL_showfatal endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D14h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _OPENSSL_stderr
_OPENSSL_stderr	proc near
		push	2
		call	dword ptr ds:__imp____acrt_iob_func
		add	esp, 4
		retn
_OPENSSL_stderr	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D20h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

		public _OpenSSLDie
_OpenSSLDie	proc near		; CODE XREF: _CRYPTO_lock+69p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	[esp+arg_8]
		push	[esp+4+arg_4]
		push	[esp+8+arg_0]
		push	offset ??_C@_0DG@JJAMFCAP@?$CFs?$CI?$CFd?$CJ?3?5OpenSSL?5internal?5error?0?5@ ;	"%s(%d): OpenSSL internal error, asserti"...
		call	_OPENSSL_showfatal
		push	16h
		call	dword ptr ds:__imp__raise
		add	esp, 14h
		push	3		; Code
		call	dword ptr ds:__imp___exit
_OpenSSLDie	endp

; ---------------------------------------------------------------------------
$LN4		db 0CCh
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D4Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public ___local_stdio_printf_options
___local_stdio_printf_options proc near	; CODE XREF: _OPENSSL_showfatal+4Dp
					; _OPENSSL_showfatal+BBp ...
		mov	eax, offset ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
		retn
___local_stdio_printf_options endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D54h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public ___local_stdio_scanf_options
___local_stdio_scanf_options proc near	; CODE XREF: __vsscanf_l+12p
					; _sscanf+11p
		mov	eax, offset ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
		retn
___local_stdio_scanf_options endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D5Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl _vsnprintf(char *Dest, size_t Count, const char *Format, va_list Args)
		public __vsnprintf
__vsnprintf	proc near

Dest		= dword	ptr  4
Count		= dword	ptr  8
Format		= dword	ptr  0Ch
Args		= dword	ptr  10h

		push	[esp+Args]
		push	0
		push	[esp+8+Format]
		push	[esp+0Ch+Count]
		push	[esp+10h+Dest]
		call	___local_stdio_printf_options
		mov	ecx, [eax]
		push	dword ptr [eax+4]
		or	ecx, 1
		push	ecx
		call	dword ptr ds:__imp____stdio_common_vsprintf
		or	ecx, 0FFFFFFFFh
		add	esp, 1Ch
		test	eax, eax
		cmovs	eax, ecx
		retn
__vsnprintf	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D90h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl _vsnprintf_l(char	*DstBuf, size_t	MaxCount, const	char *Format, _locale_t	Locale,	va_list	ArgList)
		public __vsnprintf_l
__vsnprintf_l	proc near

DstBuf		= dword	ptr  4
MaxCount	= dword	ptr  8
Format		= dword	ptr  0Ch
Locale		= dword	ptr  10h
ArgList		= dword	ptr  14h

		push	[esp+ArgList]
		push	[esp+4+Locale]
		push	[esp+8+Format]
		push	[esp+0Ch+MaxCount]
		push	[esp+10h+DstBuf]
		call	___local_stdio_printf_options
		mov	ecx, [eax]
		push	dword ptr [eax+4]
		or	ecx, 1
		push	ecx
		call	dword ptr ds:__imp____stdio_common_vsprintf
		or	ecx, 0FFFFFFFFh
		add	esp, 1Ch
		test	eax, eax
		cmovs	eax, ecx
		retn
__vsnprintf_l	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0DC4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public __vsscanf_l
__vsscanf_l	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	[esp+arg_C]
		push	[esp+4+arg_8]
		push	[esp+8+arg_4]
		push	0FFFFFFFFh
		push	[esp+10h+arg_0]
		call	___local_stdio_scanf_options
		push	dword ptr [eax+4]
		push	dword ptr [eax]
		call	dword ptr ds:__imp____stdio_common_vsscanf
		add	esp, 1Ch
		retn
__vsscanf_l	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0DECh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int sscanf(const char	*Src, const char *Format, ...)
		public _sscanf
_sscanf		proc near		; CODE XREF: _OPENSSL_cpuid_setup+52p

Src		= dword	ptr  4
Format		= dword	ptr  8
arg_8		= byte ptr  0Ch

		lea	eax, [esp+arg_8]
		push	eax
		push	0
		push	[esp+8+Format]
		push	0FFFFFFFFh
		push	[esp+10h+Src]
		call	___local_stdio_scanf_options
		push	dword ptr [eax+4]
		push	dword ptr [eax]
		call	dword ptr ds:__imp____stdio_common_vsscanf
		add	esp, 1Ch
		retn
_sscanf		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E14h
; COMDAT (pick any)
		public ??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@
; `string'
??_C@_0BE@MCNNLDKP@?4?2crypto?2cryptlib?4c?$AA@	db '.\crypto\cryptlib.c',0
					; DATA XREF: _CRYPTO_destroy_dynlockid+22o
					; _CRYPTO_destroy_dynlockid+80o ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E28h
; COMDAT (pick any)
		public ??_C@_0BA@LPBALOME@pointer?5?$CB?$DN?5NULL?$AA@
; `string'
??_C@_0BA@LPBALOME@pointer?5?$CB?$DN?5NULL?$AA@	db 'pointer != NULL',0
					; DATA XREF: _CRYPTO_lock:loc_836o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E38h
; COMDAT (pick any)
		public ??_C@_07OBLKMMON@dynamic?$AA@
; `string'
??_C@_07OBLKMMON@dynamic?$AA@ db 'dynamic',0 ; DATA XREF: _CRYPTO_get_lock_name+8o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E40h
; COMDAT (pick any)
		public ??_C@_05MBDEGLCK@ERROR?$AA@
; `string'
??_C@_05MBDEGLCK@ERROR?$AA@ db 'ERROR',0 ; DATA XREF: _CRYPTO_get_lock_name+31o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E48h
; COMDAT (pick any)
		public ??_C@_0BA@MIDPHNKH@OPENSSL_ia32cap?$AA@
; char `string'[]
??_C@_0BA@MIDPHNKH@OPENSSL_ia32cap?$AA@	db 'OPENSSL_ia32cap',0
					; DATA XREF: _OPENSSL_cpuid_setup+19o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E58h
; COMDAT (pick any)
		public ??_C@_05OKCMKDO@?$CFI64i?$AA@
; char `string'[]
??_C@_05OKCMKDO@?$CFI64i?$AA@ db '%I64i',0 ; DATA XREF: _OPENSSL_cpuid_setup+49o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E60h
; COMDAT (pick any)
		public ??_C@_0BD@EHKNLPFP@_OPENSSL_isservice?$AA@
; CHAR `string'[]
??_C@_0BD@EHKNLPFP@_OPENSSL_isservice?$AA@ db '_OPENSSL_isservice',0
					; DATA XREF: _OPENSSL_isservice+31o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E74h
; COMDAT (pick any)
		public ??_C@_1BG@MLNJHGBB@?$AAS?$AAe?$AAr?$AAv?$AAi?$AAc?$AAe?$AA?9?$AA0?$AAx?$AA?$AA@
; wchar_t `string'
??_C@_1BG@MLNJHGBB@?$AAS?$AAe?$AAr?$AAv?$AAi?$AAc?$AAe?$AA?9?$AA0?$AAx?$AA?$AA@:
					; DATA XREF: _OPENSSL_isservice+DAo
		unicode	0, <Service-0x>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8Ch
; COMDAT (pick any)
		public ??_C@_07BDLNEHJF@OpenSSL?$AA@
; CHAR `string'[]
??_C@_07BDLNEHJF@OpenSSL?$AA@ db 'OpenSSL',0 ; DATA XREF: _OPENSSL_showfatal+E3o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E94h
; COMDAT (pick any)
		public ??_C@_0P@LIPMGDB@OpenSSL?3?5FATAL?$AA@
; CHAR `string'[]
??_C@_0P@LIPMGDB@OpenSSL?3?5FATAL?$AA@ db 'OpenSSL: FATAL',0
					; DATA XREF: _OPENSSL_showfatal+137o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0EA4h
; COMDAT (pick any)
		public ??_C@_0DG@JJAMFCAP@?$CFs?$CI?$CFd?$CJ?3?5OpenSSL?5internal?5error?0?5@
; `string'
??_C@_0DG@JJAMFCAP@?$CFs?$CI?$CFd?$CJ?3?5OpenSSL?5internal?5error?0?5@ db '%s(%d): OpenSSL internal error, assertion failed: %s',0Ah,0
					; DATA XREF: _OpenSSLDie+Co
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; void __cdecl __noreturn __exit(int Code)
		extrn __imp___exit:near	; CODE XREF: _OpenSSLDie+23p
					; DATA XREF: _OpenSSLDie+23r
; unsigned __int32 __cdecl _strtoul(const char *Str, char **EndPtr, int	Radix)
		extrn __imp__strtoul:near ; CODE XREF: _OPENSSL_cpuid_setup+61p
					; _OPENSSL_cpuid_setup+DEp
					; DATA XREF: ...
; char *__cdecl	_getenv(const char *VarName)
		extrn __imp__getenv:near ; CODE	XREF: _OPENSSL_cpuid_setup+28p
					; DATA XREF: _OPENSSL_cpuid_setup+28r
; char *__cdecl	_strchr(const char *Str, int Val)
		extrn __imp__strchr:near ; CODE	XREF: _OPENSSL_cpuid_setup+C0p
					; DATA XREF: _OPENSSL_cpuid_setup+C0r
; wchar_t *__cdecl _wcsstr(const wchar_t *Str, const wchar_t *SubStr)
		extrn __imp__wcsstr:near ; CODE	XREF: _OPENSSL_isservice+E4p
					; DATA XREF: _OPENSSL_isservice+E4r
; HANDLE __stdcall GetStdHandle(DWORD nStdHandle)
		extrn __imp__GetStdHandle@4:near ; CODE	XREF: _OPENSSL_showfatal+1Bp
					; DATA XREF: _OPENSSL_showfatal+1Br
; DWORD	__stdcall GetFileType(HANDLE hFile)
		extrn __imp__GetFileType@4:near	; CODE XREF: _OPENSSL_showfatal+28p
					; DATA XREF: _OPENSSL_showfatal+28r
; BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite,	LPDWORD	lpNumberOfBytesWritten,	LPOVERLAPPED lpOverlapped)
		extrn __imp__WriteFile@20:near ; CODE XREF: _OPENSSL_showfatal+84p
					; DATA XREF: _OPENSSL_showfatal+84r
; DWORD	__stdcall GetLastError()
		extrn __imp__GetLastError@0:near ; CODE	XREF: _OPENSSL_isservice+84p
					; DATA XREF: _OPENSSL_isservice+84r
; DWORD	__stdcall GetCurrentThreadId()
		extrn __imp__GetCurrentThreadId@0:near
					; CODE XREF: _CRYPTO_THREADID_current:loc_2E5p
					; DATA XREF: _CRYPTO_THREADID_current:loc_2E5r	...
; HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName)
		extrn __imp__GetModuleHandleA@4:near ; CODE XREF: _OPENSSL_isservice+27p
					; DATA XREF: _OPENSSL_isservice+27r
; FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName)
		extrn __imp__GetProcAddress@8:near ; CODE XREF:	_OPENSSL_isservice+37p
					; DATA XREF: _OPENSSL_isservice+37r
; BOOL __stdcall DeregisterEventSource(HANDLE hEventLog)
		extrn __imp__DeregisterEventSource@4:near
					; CODE XREF: _OPENSSL_showfatal+119p
					; DATA XREF: _OPENSSL_showfatal+119r
; HANDLE __stdcall RegisterEventSourceA(LPCSTR lpUNCServerName,	LPCSTR lpSourceName)
		extrn __imp__RegisterEventSourceA@8:near ; CODE	XREF: _OPENSSL_showfatal+EAp
					; DATA XREF: _OPENSSL_showfatal+EAr
; BOOL __stdcall ReportEventA(HANDLE hEventLog,	WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCSTR	*lpStrings, LPVOID lpRawData)
		extrn __imp__ReportEventA@36:near ; CODE XREF: _OPENSSL_showfatal+112p
					; DATA XREF: _OPENSSL_showfatal+112r
; HWINSTA __stdcall GetProcessWindowStation()
		extrn __imp__GetProcessWindowStation@0:near
					; CODE XREF: _OPENSSL_isservice:loc_AD3p
					; DATA XREF: _OPENSSL_isservice:loc_AD3r
; BOOL __stdcall GetUserObjectInformationW(HANDLE hObj,	int nIndex, PVOID pvInfo, DWORD	nLength, LPDWORD lpnLengthNeeded)
		extrn __imp__GetUserObjectInformationW@20:near
					; CODE XREF: _OPENSSL_isservice+76p
					; _OPENSSL_isservice+BFp
					; DATA XREF: ...
; int __stdcall	MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption,	UINT uType)
		extrn __imp__MessageBoxA@16:near ; CODE	XREF: _OPENSSL_showfatal+143p
					; DATA XREF: _OPENSSL_showfatal+143r
		extrn __imp____acrt_iob_func:near ; CODE XREF: _OPENSSL_stderr+2p
					; DATA XREF: _OPENSSL_stderr+2r
		extrn __imp____stdio_common_vsprintf:near
					; CODE XREF: _OPENSSL_showfatal+5Bp
					; _OPENSSL_showfatal+C9p ...
		extrn __imp____stdio_common_vsscanf:near ; CODE	XREF: __vsscanf_l+1Cp
					; _sscanf+1Bp
					; DATA XREF: ...
		extrn _sk_num:near	; CODE XREF: _CRYPTO_destroy_dynlockid+3Dp
					; _CRYPTO_get_dynlock_value+33p ...
		extrn _sk_value:near	; CODE XREF: _CRYPTO_destroy_dynlockid+51p
					; _CRYPTO_get_dynlock_value+46p ...
		extrn _sk_set:near	; CODE XREF: _CRYPTO_destroy_dynlockid+6Fp
					; _CRYPTO_get_new_dynlockid+172p
		extrn _sk_new_null:near	; CODE XREF: _CRYPTO_get_new_dynlockid+4Ep
					; _CRYPTO_get_new_lockid+31p
		extrn _sk_find:near	; CODE XREF: _CRYPTO_get_new_dynlockid+148p
		extrn _sk_push:near	; CODE XREF: _CRYPTO_get_new_dynlockid+15Ep
					; _CRYPTO_get_new_lockid+8Fp
		extrn _CRYPTO_malloc:near ; CODE XREF: _CRYPTO_get_new_dynlockid+B7p
		extrn _CRYPTO_free:near	; CODE XREF: _CRYPTO_destroy_dynlockid+A9p
					; _CRYPTO_get_new_dynlockid+102p ...
		extrn _OPENSSL_init:near ; CODE	XREF: _CRYPTO_set_locking_callbackp
		extrn _BUF_strdup:near	; CODE XREF: _CRYPTO_get_new_lockid+5Dp
		extrn _ERR_put_error:near ; CODE XREF: _CRYPTO_get_new_dynlockid+19p
					; _CRYPTO_get_new_dynlockid+88p ...
		extrn _OPENSSL_ia32_cpuid:near ; CODE XREF: _OPENSSL_cpuid_setup+7Fp
					; _OPENSSL_cpuid_setup+A3p ...
		extrn __imp__raise:near	; CODE XREF: _OpenSSLDie+18p
					; DATA XREF: _OpenSSLDie+18r
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _OPENSSL_isservice+FDp
					; _OPENSSL_isservice+11Bp ...
		extrn __alloca_probe_16:near ; CODE XREF: _OPENSSL_isservice+ACp
		extrn __chkstk:near	; CODE XREF: _OPENSSL_cpuid_setup+5p
					; _OPENSSL_isservice+8p ...
; `__local_stdio_printf_options'::`2'::_OptionsStorage
		extrn ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:near
					; DATA XREF: ___local_stdio_printf_optionso
; `__local_stdio_scanf_options'::`2'::_OptionsStorage
		extrn ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:near
					; DATA XREF: ___local_stdio_scanf_optionso
		extrn _OPENSSL_ia32cap_P:near ;	DATA XREF: _OPENSSL_cpuid_setup+7Ao
					; _OPENSSL_cpuid_setup+9Eo ...
		extrn ___security_cookie:near ;	DATA XREF: _OPENSSL_isservice+Dr
					; _OPENSSL_showfatal+Ar
		extrn __fltused:near


		end
