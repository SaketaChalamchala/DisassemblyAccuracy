;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	EB4212D483A741D4BE56420182A9E986
; Input	CRC32 :	ECA39F85

; File Name   :	C:\compspace\Diff\openssl\obj\a_mbstr.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ASN1_mbstring_copy
_ASN1_mbstring_copy proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		push	0
		push	0
		push	[esp+8+arg_10]
		push	[esp+0Ch+arg_C]
		push	[esp+10h+arg_8]
		push	[esp+14h+arg_4]
		push	[esp+18h+arg_0]
		call	_ASN1_mbstring_ncopy
		add	esp, 1Ch
		retn
_ASN1_mbstring_copy endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 24h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ASN1_mbstring_ncopy
_ASN1_mbstring_ncopy proc near		; CODE XREF: _ASN1_mbstring_copy+18p

var_3D		= byte ptr -3Dh
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= byte ptr -24h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h
arg_18		= dword	ptr  1Ch

		mov	eax, 40h ; '@'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+40h+var_4], eax
		mov	edx, [esp+40h+arg_4]
		push	ebx
		mov	ebx, [esp+44h+arg_8]
		mov	[esp+44h+var_3C], edx
		mov	[esp+44h+var_38], 0
		mov	[esp+44h+var_34], 0
		push	ebp
		mov	ebp, [esp+48h+arg_0]
		mov	[esp+48h+var_2C], ebp
		push	esi
		push	edi
		cmp	ebx, 0FFFFFFFFh
		jnz	short loc_74
		mov	ebx, edx
		lea	ecx, [ebx+1]

loc_6B:					; CODE XREF: _ASN1_mbstring_ncopy+4Cj
		mov	al, [ebx]
		inc	ebx
		test	al, al
		jnz	short loc_6B
		sub	ebx, ecx

loc_74:					; CODE XREF: _ASN1_mbstring_ncopy+40j
		mov	eax, [esp+50h+arg_10]
		mov	ecx, 2806h
		test	eax, eax
		cmovz	eax, ecx
		mov	ecx, [esp+50h+arg_C]
		mov	[esp+50h+arg_10], eax
		lea	eax, [ecx-1000h] ; switch 5 cases
		cmp	eax, 4
		ja	$LN15		; jumptable 00000099 default case
		jmp	ds:$LN72[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN8:					; CODE XREF: _ASN1_mbstring_ncopy+75j
					; DATA XREF: .text$mn:$LN72o
		test	bl, 1		; jumptable 00000099 case 4098
		jz	short loc_B6
		push	74h ; 't'
		push	offset ??_C@_0BI@LIGHHEPI@?4?2crypto?2asn1?2a_mbstr?4c?$AA@ ; ".\\crypto\\asn1\\a_mbstr.c"
		push	81h ; 'Å'
		jmp	loc_3FB
; ---------------------------------------------------------------------------

loc_B6:					; CODE XREF: _ASN1_mbstring_ncopy+7Fj
		mov	esi, ebx
		sar	esi, 1
		jmp	short loc_115
; ---------------------------------------------------------------------------

$LN10:					; CODE XREF: _ASN1_mbstring_ncopy+75j
					; DATA XREF: .text$mn:$LN72o
		test	bl, 3		; jumptable 00000099 case 4100
		jz	short loc_D2
		push	7Dh ; '}'
		push	offset ??_C@_0BI@LIGHHEPI@?4?2crypto?2asn1?2a_mbstr?4c?$AA@ ; ".\\crypto\\asn1\\a_mbstr.c"
		push	85h ; 'Ö'
		jmp	loc_3FB
; ---------------------------------------------------------------------------

loc_D2:					; CODE XREF: _ASN1_mbstring_ncopy+9Bj
		mov	esi, ebx
		sar	esi, 2
		jmp	short loc_115
; ---------------------------------------------------------------------------

$LN12:					; CODE XREF: _ASN1_mbstring_ncopy+75j
					; DATA XREF: .text$mn:$LN72o
		xor	esi, esi	; jumptable 00000099 case 4096
		mov	edi, ebx
		mov	ebp, edx
		test	ebx, ebx
		jz	short loc_111
		nop

loc_E4:					; CODE XREF: _ASN1_mbstring_ncopy+E3j
		lea	eax, [esp+50h+var_30]
		push	eax
		push	edi
		push	ebp
		call	_UTF8_getc
		add	esp, 0Ch
		test	eax, eax
		js	short loc_164
		sub	edi, eax
		add	ebp, eax
		mov	eax, offset _in_utf8
		test	eax, eax
		jz	short loc_105
		inc	esi

loc_105:				; CODE XREF: _ASN1_mbstring_ncopy+DEj
		test	edi, edi
		jnz	short loc_E4
		mov	edx, [esp+50h+var_3C]
		mov	ecx, [esp+50h+arg_C]

loc_111:				; CODE XREF: _ASN1_mbstring_ncopy+BDj
		mov	ebp, [esp+50h+var_2C]

loc_115:				; CODE XREF: _ASN1_mbstring_ncopy+96j
					; _ASN1_mbstring_ncopy+B3j ...
		mov	edi, [esp+50h+arg_14]
		test	edi, edi
		jle	short loc_17C
		cmp	esi, edi
		jge	short loc_17C
		push	97h ; 'ó'
		push	offset ??_C@_0BI@LIGHHEPI@?4?2crypto?2asn1?2a_mbstr?4c?$AA@ ; ".\\crypto\\asn1\\a_mbstr.c"
		push	98h ; 'ò'
		push	7Ah ; 'z'
		push	0Dh
		call	_ERR_put_error
		push	edi
		push	offset ??_C@_03JALODAI@?$CFld?$AA@ ; "%ld"
		lea	eax, [esp+6Ch+var_24]
		push	20h ; ' '
		push	eax
		call	_BIO_snprintf
		lea	eax, [esp+74h+var_24]
		push	eax
		push	offset ??_C@_08JJBFGKFE@minsize?$DN?$AA@ ; "minsize="
		push	2
		call	_ERR_add_error_data
		add	esp, 30h
		jmp	loc_407
; ---------------------------------------------------------------------------

loc_164:				; CODE XREF: _ASN1_mbstring_ncopy+D1j
		push	88h ; 'à'
		push	offset ??_C@_0BI@LIGHHEPI@?4?2crypto?2asn1?2a_mbstr?4c?$AA@ ; ".\\crypto\\asn1\\a_mbstr.c"
		push	86h ; 'Ü'
		jmp	loc_3FB
; ---------------------------------------------------------------------------

$LN14:					; CODE XREF: _ASN1_mbstring_ncopy+75j
					; DATA XREF: .text$mn:$LN72o
		mov	esi, ebx	; jumptable 00000099 case 4097
		jmp	short loc_115
; ---------------------------------------------------------------------------

loc_17C:				; CODE XREF: _ASN1_mbstring_ncopy+F7j
					; _ASN1_mbstring_ncopy+FBj
		mov	edi, [esp+50h+arg_18]
		test	edi, edi
		jle	short loc_1CB
		cmp	esi, edi
		jle	short loc_1CB
		push	9Eh ; 'û'
		push	offset ??_C@_0BI@LIGHHEPI@?4?2crypto?2asn1?2a_mbstr?4c?$AA@ ; ".\\crypto\\asn1\\a_mbstr.c"
		push	97h ; 'ó'
		push	7Ah ; 'z'
		push	0Dh
		call	_ERR_put_error
		push	edi
		push	offset ??_C@_03JALODAI@?$CFld?$AA@ ; "%ld"
		lea	eax, [esp+6Ch+var_24]
		push	20h ; ' '
		push	eax
		call	_BIO_snprintf
		lea	eax, [esp+74h+var_24]
		push	eax
		push	offset ??_C@_08EOPONIBF@maxsize?$DN?$AA@ ; "maxsize="
		push	2
		call	_ERR_add_error_data
		add	esp, 30h
		jmp	loc_407
; ---------------------------------------------------------------------------

loc_1CB:				; CODE XREF: _ASN1_mbstring_ncopy+15Ej
					; _ASN1_mbstring_ncopy+162j
		lea	eax, [esp+50h+arg_10]
		push	eax
		push	offset _type_str
		push	ecx
		push	ebx
		push	edx
		call	_traverse_string
		add	esp, 14h
		test	eax, eax
		jns	short loc_1F5
		push	0A6h ; '¶'
		push	offset ??_C@_0BI@LIGHHEPI@?4?2crypto?2asn1?2a_mbstr?4c?$AA@ ; ".\\crypto\\asn1\\a_mbstr.c"
		push	7Ch ; '|'
		jmp	loc_3FB
; ---------------------------------------------------------------------------

loc_1F5:				; CODE XREF: _ASN1_mbstring_ncopy+1BEj
		mov	eax, [esp+50h+arg_10]
		mov	[esp+50h+var_30], 1001h
		test	al, 2
		jz	short loc_20C
		mov	edi, 13h
		jmp	short loc_25B
; ---------------------------------------------------------------------------

loc_20C:				; CODE XREF: _ASN1_mbstring_ncopy+1DFj
		test	al, 10h
		jz	short loc_217
		mov	edi, 16h
		jmp	short loc_25B
; ---------------------------------------------------------------------------

loc_217:				; CODE XREF: _ASN1_mbstring_ncopy+1EAj
		test	al, 4
		jz	short loc_222
		mov	edi, 14h
		jmp	short loc_25B
; ---------------------------------------------------------------------------

loc_222:				; CODE XREF: _ASN1_mbstring_ncopy+1F5j
		test	eax, 800h
		jz	short loc_238
		mov	edi, 1Eh
		mov	[esp+50h+var_30], 1002h
		jmp	short loc_25B
; ---------------------------------------------------------------------------

loc_238:				; CODE XREF: _ASN1_mbstring_ncopy+203j
		test	eax, 100h
		jz	short loc_24E
		mov	edi, 1Ch
		mov	[esp+50h+var_30], 1004h
		jmp	short loc_25B
; ---------------------------------------------------------------------------

loc_24E:				; CODE XREF: _ASN1_mbstring_ncopy+219j
		mov	edi, 0Ch
		mov	[esp+50h+var_30], 1000h

loc_25B:				; CODE XREF: _ASN1_mbstring_ncopy+1E6j
					; _ASN1_mbstring_ncopy+1F1j ...
		test	ebp, ebp
		jz	loc_3D7
		mov	ebp, [ebp+0]
		test	ebp, ebp
		jz	short loc_292
		mov	eax, [ebp+8]
		mov	[esp+50h+var_3D], 0
		test	eax, eax
		jz	short loc_28D
		push	eax
		mov	dword ptr [ebp+0], 0
		call	_CRYPTO_free
		add	esp, 4
		mov	dword ptr [ebp+8], 0

loc_28D:				; CODE XREF: _ASN1_mbstring_ncopy+250j
		mov	[ebp+4], edi
		jmp	short loc_2BD
; ---------------------------------------------------------------------------

loc_292:				; CODE XREF: _ASN1_mbstring_ncopy+244j
		push	edi
		mov	[esp+54h+var_3D], 1
		call	_ASN1_STRING_type_new
		mov	ebp, eax
		add	esp, 4
		test	ebp, ebp
		jnz	short loc_2B7
		push	0CBh ; 'À'
		push	offset ??_C@_0BI@LIGHHEPI@?4?2crypto?2asn1?2a_mbstr?4c?$AA@ ; ".\\crypto\\asn1\\a_mbstr.c"
		push	41h ; 'A'
		jmp	loc_3FB
; ---------------------------------------------------------------------------

loc_2B7:				; CODE XREF: _ASN1_mbstring_ncopy+280j
		mov	eax, [esp+50h+var_2C]
		mov	[eax], ebp

loc_2BD:				; CODE XREF: _ASN1_mbstring_ncopy+26Cj
		mov	eax, [esp+50h+var_30]
		mov	ecx, [esp+50h+arg_C]
		cmp	ecx, eax
		jnz	short loc_2F1
		mov	esi, [esp+50h+var_3C]
		push	ebx
		push	esi
		push	ebp
		call	_ASN1_STRING_set
		add	esp, 0Ch
		test	eax, eax
		jnz	loc_3D7
		push	0D3h ; '”'
		push	offset ??_C@_0BI@LIGHHEPI@?4?2crypto?2asn1?2a_mbstr?4c?$AA@ ; ".\\crypto\\asn1\\a_mbstr.c"
		push	41h ; 'A'
		jmp	loc_3FB
; ---------------------------------------------------------------------------

loc_2F1:				; CODE XREF: _ASN1_mbstring_ncopy+2A3j
		add	eax, 0FFFFF000h	; switch 5 cases
		cmp	eax, 4
		ja	short $LN67	; jumptable 000002FB default case
		jmp	ds:$LN73[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN36:					; CODE XREF: _ASN1_mbstring_ncopy+2D7j
					; DATA XREF: .text$mn:$LN73o
		mov	[esp+50h+var_38], esi ;	jumptable 000002FB case	4097
		mov	[esp+50h+var_34], offset _cpy_asc

$LN67:					; CODE XREF: _ASN1_mbstring_ncopy+2D5j
					; _ASN1_mbstring_ncopy+2D7j ...
		mov	esi, [esp+50h+var_3C] ;	jumptable 000002FB default case

loc_312:				; CODE XREF: _ASN1_mbstring_ncopy+37Dj
		mov	eax, [esp+50h+var_38]
		push	0F0h ; ''
		inc	eax
		push	offset ??_C@_0BI@LIGHHEPI@?4?2crypto?2asn1?2a_mbstr?4c?$AA@ ; ".\\crypto\\asn1\\a_mbstr.c"
		push	eax
		call	_CRYPTO_malloc
		add	esp, 0Ch
		mov	[esp+50h+var_28], eax
		test	eax, eax
		jnz	short loc_3A6
		cmp	[esp+50h+var_3D], al
		jz	short loc_341
		push	ebp
		call	_ASN1_STRING_free
		add	esp, 4

loc_341:				; CODE XREF: _ASN1_mbstring_ncopy+312j
		push	0F3h ; 'Û'
		push	offset ??_C@_0BI@LIGHHEPI@?4?2crypto?2asn1?2a_mbstr?4c?$AA@ ; ".\\crypto\\asn1\\a_mbstr.c"
		push	41h ; 'A'
		jmp	loc_3FB
; ---------------------------------------------------------------------------

$LN37:					; CODE XREF: _ASN1_mbstring_ncopy+2D7j
					; DATA XREF: .text$mn:$LN73o
		lea	eax, [esi+esi]	; jumptable 000002FB case 4098
		mov	[esp+50h+var_34], offset _cpy_bmp
		mov	[esp+50h+var_38], eax
		jmp	short $LN67	; jumptable 000002FB default case
; ---------------------------------------------------------------------------

$LN38:					; CODE XREF: _ASN1_mbstring_ncopy+2D7j
					; DATA XREF: .text$mn:$LN73o
		lea	eax, ds:0[esi*4] ; jumptable 000002FB case 4100
		mov	[esp+50h+var_34], offset _cpy_univ
		mov	[esp+50h+var_38], eax
		jmp	short $LN67	; jumptable 000002FB default case
; ---------------------------------------------------------------------------

$LN39:					; CODE XREF: _ASN1_mbstring_ncopy+2D7j
					; DATA XREF: .text$mn:$LN73o
		mov	esi, [esp+50h+var_3C] ;	jumptable 000002FB case	4096
		lea	eax, [esp+50h+var_38]
		push	eax
		push	offset _out_utf8
		push	ecx
		push	ebx
		push	esi
		mov	[esp+64h+var_38], 0
		call	_traverse_string
		add	esp, 14h
		mov	[esp+50h+var_34], offset _cpy_utf8
		jmp	loc_312
; ---------------------------------------------------------------------------

loc_3A6:				; CODE XREF: _ASN1_mbstring_ncopy+30Cj
		mov	eax, [esp+50h+var_38]
		mov	[ebp+0], eax
		mov	eax, [esp+50h+var_28]
		mov	[ebp+8], eax
		mov	eax, [esp+50h+var_28]
		mov	ecx, [esp+50h+var_38]
		mov	byte ptr [eax+ecx], 0
		lea	eax, [esp+50h+var_28]
		push	eax
		push	[esp+54h+var_34]
		push	[esp+58h+arg_C]
		push	ebx
		push	esi
		call	_traverse_string
		add	esp, 14h

loc_3D7:				; CODE XREF: _ASN1_mbstring_ncopy+239j
					; _ASN1_mbstring_ncopy+2B6j
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+40h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 40h
		retn
; ---------------------------------------------------------------------------

$LN15:					; CODE XREF: _ASN1_mbstring_ncopy+6Fj
					; _ASN1_mbstring_ncopy+75j
					; DATA XREF: ...
		push	92h ; 'í'       ; jumptable 00000099 default case
		push	offset ??_C@_0BI@LIGHHEPI@?4?2crypto?2asn1?2a_mbstr?4c?$AA@ ; ".\\crypto\\asn1\\a_mbstr.c"
		push	0A0h ; '†'

loc_3FB:				; CODE XREF: _ASN1_mbstring_ncopy+8Dj
					; _ASN1_mbstring_ncopy+A9j ...
		push	7Ah ; 'z'
		push	0Dh
		call	_ERR_put_error
		add	esp, 14h

loc_407:				; CODE XREF: _ASN1_mbstring_ncopy+13Bj
					; _ASN1_mbstring_ncopy+1A2j
		mov	ecx, [esp+50h+var_4]
		or	eax, 0FFFFFFFFh
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 40h
		retn
_ASN1_mbstring_ncopy endp

; ---------------------------------------------------------------------------
		align 10h
$LN72		dd offset $LN12		; DATA XREF: _ASN1_mbstring_ncopy+75r
		dd offset $LN14		; jump table for switch	statement
		dd offset $LN8
		dd offset $LN15
		dd offset $LN10
$LN73		dd offset $LN39		; DATA XREF: _ASN1_mbstring_ncopy+2D7r
		dd offset $LN36		; jump table for switch	statement
		dd offset $LN37
		dd offset $LN67
		dd offset $LN38
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 448h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_cpy_asc	proc near		; DATA XREF: _ASN1_mbstring_ncopy+2E2o

arg_0		= byte ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		mov	al, [esp+arg_0]
		mov	ecx, [edx]
		mov	[ecx], al
		mov	eax, 1
		inc	dword ptr [edx]
		retn
_cpy_asc	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 45Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_cpy_bmp	proc near		; DATA XREF: _ASN1_mbstring_ncopy+331o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		mov	eax, ecx
		push	esi
		mov	esi, [esp+4+arg_4]
		shr	eax, 8
		mov	edx, [esi]
		mov	[edx], al
		mov	eax, 1
		mov	[edx+1], cl
		add	dword ptr [esi], 2
		pop	esi
		retn
_cpy_bmp	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 47Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_cpy_univ	proc near		; DATA XREF: _ASN1_mbstring_ncopy+346o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		mov	eax, ecx
		push	esi
		mov	esi, [esp+4+arg_4]
		shr	eax, 18h
		mov	edx, [esi]
		mov	[edx], al
		mov	eax, ecx
		shr	eax, 10h
		mov	[edx+1], al
		mov	eax, ecx
		shr	eax, 8
		mov	[edx+2], al
		mov	eax, 1
		mov	[edx+3], cl
		add	dword ptr [esi], 4
		pop	esi
		retn
_cpy_univ	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4ACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_cpy_utf8	proc near		; DATA XREF: _ASN1_mbstring_ncopy+375o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		push	[esp+4+arg_0]
		mov	esi, [esp+8+arg_4]
		push	0FFh
		push	dword ptr [esi]
		call	_UTF8_putc
		add	[esi], eax
		add	esp, 0Ch
		mov	eax, 1
		pop	esi
		retn
_cpy_utf8	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4D0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_in_utf8	proc near		; DATA XREF: _ASN1_mbstring_ncopy+D7o

arg_4		= dword	ptr  8

		mov	eax, [esp+arg_4]
		inc	dword ptr [eax]
		mov	eax, 1
		retn
_in_utf8	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4DCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl is_printable(int Val)
_is_printable	proc near

Val		= dword	ptr  4

		mov	ecx, [esp+Val]
		cmp	ecx, 7Fh ; ''
		jbe	short loc_4E8

loc_4E5:				; CODE XREF: _is_printable+3Aj
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_4E8:				; CODE XREF: _is_printable+7j
		lea	eax, [ecx-61h]
		cmp	eax, 19h
		jbe	short loc_518
		lea	eax, [ecx-41h]
		cmp	eax, 19h
		jbe	short loc_518
		lea	eax, [ecx-30h]
		cmp	eax, 9
		jbe	short loc_518
		cmp	ecx, 20h ; ' '
		jz	short loc_518
		push	ecx		; Val
		push	offset ??_C@_0M@PCEPOGPN@?8?$CI?$CJ?$CL?0?9?4?1?3?$DN?$DP?$AA@ ; "'()+,-./:=?"
		call	dword ptr ds:__imp__strchr
		add	esp, 8
		test	eax, eax
		jz	short loc_4E5

loc_518:				; CODE XREF: _is_printable+12j
					; _is_printable+1Aj ...
		mov	eax, 1
		retn
_is_printable	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 520h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_out_utf8	proc near		; DATA XREF: _ASN1_mbstring_ncopy+35Do

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	[esp+arg_0]
		push	0FFFFFFFFh
		push	0
		call	_UTF8_putc
		mov	ecx, [esp+0Ch+arg_4]
		add	esp, 0Ch
		add	[ecx], eax
		mov	eax, 1
		retn
_out_utf8	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 53Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_traverse_string proc near		; CODE XREF: _ASN1_mbstring_ncopy+1B4p
					; _ASN1_mbstring_ncopy+36Dp ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	edi, [esp+10h+arg_4]
		test	edi, edi
		jz	loc_606
		mov	ebp, [esp+10h+arg_C]
		mov	ebx, [esp+10h+arg_8]
		mov	esi, [esp+10h+arg_0]
		nop	dword ptr [eax+00h]

loc_55C:				; CODE XREF: _traverse_string+C4j
		cmp	ebx, 1001h
		jnz	short loc_56F
		movzx	ecx, byte ptr [esi]
		inc	esi
		mov	[esp+10h+arg_4], ecx
		dec	edi
		jmp	short loc_5EC
; ---------------------------------------------------------------------------

loc_56F:				; CODE XREF: _traverse_string+26j
		cmp	ebx, 1002h
		jnz	short loc_593
		movzx	ecx, byte ptr [esi]
		shl	ecx, 8
		mov	[esp+10h+arg_4], ecx
		movzx	eax, byte ptr [esi+1]
		add	esi, 2
		or	ecx, eax
		sub	edi, 2
		mov	[esp+10h+arg_4], ecx
		jmp	short loc_5EC
; ---------------------------------------------------------------------------

loc_593:				; CODE XREF: _traverse_string+39j
		cmp	ebx, 1004h
		jnz	short loc_5D1
		movzx	ecx, byte ptr [esi]
		shl	ecx, 18h
		mov	[esp+10h+arg_4], ecx
		movzx	eax, byte ptr [esi+1]
		shl	eax, 10h
		or	ecx, eax
		mov	[esp+10h+arg_4], ecx
		movzx	eax, byte ptr [esi+2]
		shl	eax, 8
		or	ecx, eax
		mov	[esp+10h+arg_4], ecx
		movzx	eax, byte ptr [esi+3]
		add	esi, 4
		or	ecx, eax
		sub	edi, 4
		mov	[esp+10h+arg_4], ecx
		jmp	short loc_5EC
; ---------------------------------------------------------------------------

loc_5D1:				; CODE XREF: _traverse_string+5Dj
		lea	eax, [esp+10h+arg_4]
		push	eax
		push	edi
		push	esi
		call	_UTF8_getc
		add	esp, 0Ch
		test	eax, eax
		js	short loc_610
		mov	ecx, [esp+10h+arg_4]
		sub	edi, eax
		add	esi, eax

loc_5EC:				; CODE XREF: _traverse_string+31j
					; _traverse_string+55j	...
		test	ebp, ebp
		jz	short loc_5FE
		push	[esp+10h+arg_10]
		push	ecx
		call	ebp
		add	esp, 8
		test	eax, eax
		jle	short loc_60B

loc_5FE:				; CODE XREF: _traverse_string+B2j
		test	edi, edi
		jnz	loc_55C

loc_606:				; CODE XREF: _traverse_string+Aj
		mov	eax, 1

loc_60B:				; CODE XREF: _traverse_string+C0j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_610:				; CODE XREF: _traverse_string+A6j
		pop	edi
		pop	esi
		pop	ebp
		or	eax, 0FFFFFFFFh
		pop	ebx
		retn
_traverse_string endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 618h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl type_str(int Val,	int)
_type_str	proc near		; DATA XREF: _ASN1_mbstring_ncopy+1ACo

Val		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		push	esi
		mov	esi, [esp+8+Val]
		push	edi
		mov	edi, [esp+0Ch+arg_4]
		mov	ebx, [edi]
		test	bl, 2
		jz	short loc_662
		cmp	esi, 7Fh ; ''
		ja	short loc_65F
		lea	eax, [esi-61h]
		cmp	eax, 19h
		jbe	short loc_662
		lea	eax, [esi-41h]
		cmp	eax, 19h
		jbe	short loc_662
		lea	eax, [esi-30h]
		cmp	eax, 9
		jbe	short loc_662
		cmp	esi, 20h ; ' '
		jz	short loc_662
		push	esi		; Val
		push	offset ??_C@_0M@PCEPOGPN@?8?$CI?$CJ?$CL?0?9?4?1?3?$DN?$DP?$AA@ ; "'()+,-./:=?"
		call	dword ptr ds:__imp__strchr
		add	esp, 8
		test	eax, eax
		jnz	short loc_662

loc_65F:				; CODE XREF: _type_str+15j
		and	ebx, 0FFFFFFFDh

loc_662:				; CODE XREF: _type_str+10j
					; _type_str+1Dj ...
		test	bl, 10h
		jz	short loc_66F
		cmp	esi, 7Fh ; ''
		jbe	short loc_66F
		and	ebx, 0FFFFFFEFh

loc_66F:				; CODE XREF: _type_str+4Dj
					; _type_str+52j
		test	bl, 4
		jz	short loc_67F
		cmp	esi, 0FFh
		jbe	short loc_67F
		and	ebx, 0FFFFFFFBh

loc_67F:				; CODE XREF: _type_str+5Aj
					; _type_str+62j
		test	ebx, 800h
		jz	short loc_695
		cmp	esi, 0FFFFh
		jbe	short loc_695
		and	ebx, 0FFFFF7FFh

loc_695:				; CODE XREF: _type_str+6Dj
					; _type_str+75j
		test	ebx, ebx
		jnz	short loc_6A0
		pop	edi
		pop	esi
		or	eax, 0FFFFFFFFh
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_6A0:				; CODE XREF: _type_str+7Fj
		mov	[edi], ebx
		mov	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		retn
_type_str	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6ACh
; COMDAT (pick any)
		public ??_C@_0BI@LIGHHEPI@?4?2crypto?2asn1?2a_mbstr?4c?$AA@
; `string'
??_C@_0BI@LIGHHEPI@?4?2crypto?2asn1?2a_mbstr?4c?$AA@ db	'.\crypto\asn1\a_mbstr.c',0
					; DATA XREF: _ASN1_mbstring_ncopy+83o
					; _ASN1_mbstring_ncopy+9Fo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6C4h
; COMDAT (pick any)
		public ??_C@_03JALODAI@?$CFld?$AA@
; `string'
??_C@_03JALODAI@?$CFld?$AA@ db '%ld',0  ; DATA XREF: _ASN1_mbstring_ncopy+116o
					; _ASN1_mbstring_ncopy+17Do
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6C8h
; COMDAT (pick any)
		public ??_C@_08JJBFGKFE@minsize?$DN?$AA@
; `string'
??_C@_08JJBFGKFE@minsize?$DN?$AA@ db 'minsize=',0 ; DATA XREF: _ASN1_mbstring_ncopy+12Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6D4h
; COMDAT (pick any)
		public ??_C@_08EOPONIBF@maxsize?$DN?$AA@
; `string'
??_C@_08EOPONIBF@maxsize?$DN?$AA@ db 'maxsize=',0 ; DATA XREF: _ASN1_mbstring_ncopy+193o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6E0h
; COMDAT (pick any)
		public ??_C@_0M@PCEPOGPN@?8?$CI?$CJ?$CL?0?9?4?1?3?$DN?$DP?$AA@
; char `string'[]
??_C@_0M@PCEPOGPN@?8?$CI?$CJ?$CL?0?9?4?1?3?$DN?$DP?$AA@	db 27h,'()+,-./:=?',0
					; DATA XREF: _is_printable+2Ao
					; _type_str+35o
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; char *__cdecl	_strchr(const char *Str, int Val)
		extrn __imp__strchr:near ; CODE	XREF: _is_printable+2Fp
					; _type_str+3Ap
					; DATA XREF: ...
		extrn _CRYPTO_malloc:near ; CODE XREF: _ASN1_mbstring_ncopy+2FEp
		extrn _CRYPTO_free:near	; CODE XREF: _ASN1_mbstring_ncopy+25Ap
		extrn _BIO_snprintf:near ; CODE	XREF: _ASN1_mbstring_ncopy+122p
					; _ASN1_mbstring_ncopy+189p
		extrn _ERR_put_error:near ; CODE XREF: _ASN1_mbstring_ncopy+110p
					; _ASN1_mbstring_ncopy+177p ...
		extrn _ERR_add_error_data:near ; CODE XREF: _ASN1_mbstring_ncopy+133p
					; _ASN1_mbstring_ncopy+19Ap
		extrn _ASN1_STRING_free:near ; CODE XREF: _ASN1_mbstring_ncopy+315p
		extrn _ASN1_STRING_type_new:near ; CODE	XREF: _ASN1_mbstring_ncopy+274p
		extrn _ASN1_STRING_set:near ; CODE XREF: _ASN1_mbstring_ncopy+2ACp
		extrn _UTF8_getc:near	; CODE XREF: _ASN1_mbstring_ncopy+C7p
					; _traverse_string+9Cp
		extrn _UTF8_putc:near	; CODE XREF: _cpy_utf8+10p
					; _out_utf8+8p
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _ASN1_mbstring_ncopy+3BFp
					; _ASN1_mbstring_ncopy+3F0p
		extrn __chkstk:near	; CODE XREF: _ASN1_mbstring_ncopy+5p
		extrn ___security_cookie:near ;	DATA XREF: _ASN1_mbstring_ncopy+Ar


		end
