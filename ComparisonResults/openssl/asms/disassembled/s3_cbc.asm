;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	93EC2B1C2F07F99B6AEFDBFBA1311232
; Input	CRC32 :	CE3239E8

; File Name   :	C:\compspace\Diff\openssl\obj\s3_cbc.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_constant_time_eq proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		xor	ecx, [esp+arg_4]
		lea	eax, [ecx-1]
		not	ecx
		shr	eax, 1Fh
		shr	ecx, 1Fh
		and	eax, ecx
		neg	eax
		retn
_constant_time_eq endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 18h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_constant_time_eq_8 proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		xor	ecx, [esp+arg_4]
		lea	eax, [ecx-1]
		not	ecx
		shr	eax, 1Fh
		shr	ecx, 1Fh
		and	eax, ecx
		neg	eax
		retn
_constant_time_eq_8 endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 30h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_constant_time_ge proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, esi
		sub	eax, edx
		mov	ecx, esi
		xor	eax, edx
		xor	ecx, edx
		or	eax, ecx
		xor	eax, esi
		shr	eax, 1Fh
		dec	eax
		pop	esi
		retn
_constant_time_ge endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 50h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_constant_time_ge_8 proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, esi
		sub	eax, edx
		mov	ecx, esi
		xor	eax, edx
		xor	ecx, edx
		or	eax, ecx
		xor	eax, esi
		shr	eax, 1Fh
		dec	eax
		pop	esi
		retn
_constant_time_ge_8 endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 70h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_constant_time_is_zero proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		lea	eax, [ecx-1]
		not	ecx
		shr	eax, 1Fh
		shr	ecx, 1Fh
		and	eax, ecx
		neg	eax
		retn
_constant_time_is_zero endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 84h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_constant_time_lt proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, esi
		sub	eax, edx
		mov	ecx, esi
		xor	eax, edx
		xor	ecx, edx
		or	eax, ecx
		xor	eax, esi
		shr	eax, 1Fh
		neg	eax
		pop	esi
		retn
_constant_time_lt endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_constant_time_msb proc	near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		shr	eax, 1Fh
		neg	eax
		retn
_constant_time_msb endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_constant_time_select proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		mov	eax, ecx
		and	ecx, [esp+arg_4]
		not	eax
		and	eax, [esp+arg_8]
		or	eax, ecx
		retn
_constant_time_select endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_constant_time_select_8	proc near

arg_0		= byte ptr  4
arg_4		= byte ptr  8
arg_8		= byte ptr  0Ch

		movzx	edx, [esp+arg_0]
		movzx	ecx, [esp+arg_8]
		mov	eax, edx
		not	eax
		and	eax, ecx
		movzx	ecx, [esp+arg_4]
		and	ecx, edx
		or	eax, ecx
		retn
_constant_time_select_8	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E0h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_constant_time_select_int proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		mov	eax, ecx
		and	ecx, [esp+arg_4]
		not	eax
		and	eax, [esp+arg_8]
		or	eax, ecx
		retn
_constant_time_select_int endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl ssl3_cbc_copy_mac(int, int, size_t Size, int)
		public _ssl3_cbc_copy_mac
_ssl3_cbc_copy_mac proc	near

var_A8		= dword	ptr -0A8h
var_A4		= dword	ptr -0A4h
var_A0		= dword	ptr -0A0h
var_9C		= dword	ptr -9Ch
var_98		= dword	ptr -98h
var_94		= dword	ptr -94h
var_90		= dword	ptr -90h
var_8C		= dword	ptr -8Ch
var_88		= dword	ptr -88h
var_84		= byte ptr -84h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
Size		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, 0A8h ; '¨'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+0A8h+var_4], eax
		mov	eax, [esp+0A8h+arg_0]
		push	ebx
		mov	[esp+0ACh+var_88], eax
		mov	eax, [esp+0ACh+arg_4]
		push	ebp
		push	esi
		mov	esi, [esp+0B4h+arg_C]
		xor	ebp, ebp
		mov	eax, [eax+4]
		push	edi
		mov	edi, [esp+0B8h+Size]
		mov	[esp+0B8h+var_A4], eax
		sub	eax, edi
		mov	[esp+0B8h+var_A8], eax
		cmp	esi, edi
		jnb	short loc_15A
		push	offset ??_C@_0BE@FDMJMLAH@orig_len?5?$DO?$DN?5md_size?$AA@ ; "orig_len >= md_size"
		push	0F8h ; 'ø'
		push	offset ??_C@_0P@MCJLMBFO@?4?2ssl?2s3_cbc?4c?$AA@ ; ".\\ssl\\s3_cbc.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_15A:				; CODE XREF: _ssl3_cbc_copy_mac+4Dj
		cmp	edi, 40h ; '@'
		jbe	short loc_176
		push	offset ??_C@_0BL@DNIGBJK@md_size?5?$DM?$DN?5EVP_MAX_MD_SIZE?$AA@ ; "md_size <= EVP_MAX_MD_SIZE"
		push	0F9h ; 'ù'
		push	offset ??_C@_0P@MCJLMBFO@?4?2ssl?2s3_cbc?4c?$AA@ ; ".\\ssl\\s3_cbc.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_176:				; CODE XREF: _ssl3_cbc_copy_mac+69j
		lea	eax, [esp+0B8h+var_84]
		neg	eax
		lea	ebx, [esp+0B8h+var_84]
		and	eax, 3Fh
		add	ebx, eax
		lea	eax, [edi+100h]
		mov	[esp+0B8h+var_9C], ebx
		cmp	esi, eax
		jbe	short loc_19D
		mov	ebp, esi
		sub	ebp, edi
		sub	ebp, 100h

loc_19D:				; CODE XREF: _ssl3_cbc_copy_mac+9Dj
		mov	eax, edi
		xor	edx, edx
		and	eax, 0FFFFFFFEh
		shl	eax, 17h
		sub	eax, ebp
		add	eax, [esp+0B8h+var_A8]
		div	edi
		push	edi		; Size
		mov	esi, edx
		push	0		; Val
		push	ebx		; Dst
		mov	[esp+0C4h+var_8C], esi
		call	_memset
		add	esp, 0Ch
		mov	[esp+0B8h+var_A0], 0
		cmp	ebp, [esp+0B8h+arg_C]
		jnb	loc_293
		mov	ecx, [esp+0B8h+var_A8]
		mov	edx, ecx
		mov	ebx, [esp+0B8h+var_A4]
		mov	esi, ebx
		mov	eax, [esp+0B8h+arg_4]
		sub	esi, ecx
		shr	edx, 1Fh
		mov	[esp+0B8h+var_94], edx
		mov	edx, ebx
		shr	edx, 1Fh
		mov	eax, [eax+0Ch]
		mov	[esp+0B8h+var_A4], edx
		mov	edx, ebp
		sub	edx, ebx
		mov	[esp+0B8h+var_98], esi
		mov	esi, [esp+0B8h+var_9C]
		add	eax, ebx
		mov	[esp+0B8h+var_A8], edx
		mov	[esp+0B8h+var_90], eax

loc_214:				; CODE XREF: _ssl3_cbc_copy_mac+195j
		mov	ebx, [esp+0B8h+var_98]
		mov	ecx, ebp
		mov	eax, [esp+0B8h+var_94]
		inc	ebp
		shr	ecx, 1Fh
		lea	ebx, [ebx+edx]
		shr	edx, 1Fh
		xor	dl, byte ptr [esp+0B8h+var_A4]
		shr	ebx, 1Fh
		xor	bl, al
		xor	al, cl
		or	bl, al
		mov	al, cl
		xor	al, byte ptr [esp+0B8h+var_A4]
		xor	bl, cl
		or	dl, al
		dec	bl
		mov	eax, [esp+0B8h+var_A8]
		xor	dl, cl
		mov	ecx, [esp+0B8h+var_90]
		dec	dl
		not	dl
		mov	al, [ecx+eax]
		mov	ecx, [esp+0B8h+var_A0]
		and	dl, al
		and	dl, bl
		or	[ecx+esi], dl
		mov	edx, ecx
		inc	edx
		mov	ecx, edx
		mov	eax, edx
		sub	ecx, edi
		xor	eax, edi
		xor	ecx, edi
		or	ecx, eax
		xor	ecx, edx
		shr	ecx, 1Fh
		neg	ecx
		and	edx, ecx
		mov	[esp+0B8h+var_A0], edx
		mov	edx, [esp+0B8h+var_A8]
		inc	edx
		mov	[esp+0B8h+var_A8], edx
		cmp	ebp, [esp+0B8h+arg_C]
		jb	short loc_214
		mov	esi, [esp+0B8h+var_8C]
		mov	ebx, [esp+0B8h+var_9C]

loc_293:				; CODE XREF: _ssl3_cbc_copy_mac+DCj
		xor	edx, edx
		test	edi, edi
		jz	short loc_2CE
		mov	ebp, [esp+0B8h+var_88]
		nop	dword ptr [eax+00000000h]

loc_2A4:				; CODE XREF: _ssl3_cbc_copy_mac+1D8j
		mov	eax, esi
		xor	eax, 20h
		mov	al, [eax+ebx]
		movzx	eax, byte ptr [esi+ebx]
		inc	esi
		mov	[edx+ebp], al
		mov	ecx, esi
		sub	ecx, edi
		mov	eax, esi
		xor	ecx, edi
		xor	eax, edi
		or	ecx, eax
		inc	edx
		xor	ecx, esi
		shr	ecx, 1Fh
		neg	ecx
		and	esi, ecx
		cmp	edx, edi
		jb	short loc_2A4

loc_2CE:				; CODE XREF: _ssl3_cbc_copy_mac+1A3j
		mov	ecx, [esp+0B8h+var_4]
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 0A8h
		retn
_ssl3_cbc_copy_mac endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl ssl3_cbc_digest_record(int, int, int, int, int, int, int,	int, size_t Size, char)
		public _ssl3_cbc_digest_record
_ssl3_cbc_digest_record	proc near

var_349		= byte ptr -349h
var_348		= dword	ptr -348h
var_344		= dword	ptr -344h
var_340		= dword	ptr -340h
var_339		= byte ptr -339h
var_338		= dword	ptr -338h
var_334		= dword	ptr -334h
var_330		= dword	ptr -330h
var_32C		= dword	ptr -32Ch
var_328		= dword	ptr -328h
var_324		= dword	ptr -324h
var_320		= dword	ptr -320h
var_31C		= dword	ptr -31Ch
var_318		= dword	ptr -318h
var_314		= dword	ptr -314h
var_310		= dword	ptr -310h
var_30C		= dword	ptr -30Ch
var_308		= dword	ptr -308h
Src		= dword	ptr -304h
var_300		= dword	ptr -300h
var_2FC		= dword	ptr -2FCh
var_2F8		= dword	ptr -2F8h
var_2F4		= dword	ptr -2F4h
var_2F0		= dword	ptr -2F0h
var_2EC		= dword	ptr -2ECh
var_2E8		= dword	ptr -2E8h
var_2E4		= dword	ptr -2E4h
var_2E0		= dword	ptr -2E0h
var_2DC		= byte ptr -2DCh
var_2D8		= dword	ptr -2D8h
var_2D4		= dword	ptr -2D4h
var_2D0		= byte ptr -2D0h
var_2C0		= xmmword ptr -2C0h
var_2B0		= byte ptr -2B0h
var_1E0		= byte ptr -1E0h
var_1DF		= byte ptr -1DFh
var_1DE		= byte ptr -1DEh
var_1DD		= byte ptr -1DDh
var_1DC		= byte ptr -1DCh
var_1DB		= byte ptr -1DBh
var_1DA		= byte ptr -1DAh
var_1D9		= byte ptr -1D9h
var_1D8		= byte ptr -1D8h
var_1C8		= xmmword ptr -1C8h
var_1B8		= xmmword ptr -1B8h
Dst		= byte ptr -188h
var_178		= byte ptr -178h
var_108		= qword	ptr -108h
var_100		= dword	ptr -100h
var_FC		= byte ptr -0FCh
var_FB		= byte ptr -0FBh
var_88		= xmmword ptr -88h
var_78		= xmmword ptr -78h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h
Size		= dword	ptr  28h
arg_24		= byte ptr  2Ch

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFF0h
		mov	eax, 354h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+354h+var_4], eax
		mov	eax, [ebp+arg_0]
		mov	[esp+354h+var_30C], eax
		mov	eax, [ebp+arg_4]
		mov	[esp+354h+var_2E4], eax
		mov	eax, [ebp+arg_C]
		push	ebx
		mov	ebx, [ebp+arg_18]
		mov	[esp+358h+var_320], eax
		mov	eax, [ebp+arg_10]
		mov	[esp+358h+var_328], eax
		mov	eax, [ebp+arg_1C]
		mov	[esp+358h+Src],	eax
		mov	[esp+358h+var_308], 28h	; '('
		mov	[esp+358h+var_344], 8
		mov	[esp+358h+var_349], 1
		push	esi
		mov	esi, [ebp+arg_8]
		mov	[esp+35Ch+var_2E0], esi
		push	edi
		mov	edi, 40h ; '@'
		cmp	ebx, 100000h
		jb	short loc_36F
		push	offset ??_C@_0CO@LFAHLKMA@data_plus_mac_plus_padding_size?5@ ; "data_plus_mac_plus_padding_size	< 1024 "...
		push	1C7h
		push	offset ??_C@_0P@MCJLMBFO@?4?2ssl?2s3_cbc?4c?$AA@ ; ".\\ssl\\s3_cbc.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_36F:				; CODE XREF: _ssl3_cbc_digest_record+6Ej
		push	[esp+360h+var_30C]
		call	_EVP_MD_CTX_md
		push	eax
		call	_EVP_MD_type
		add	esp, 8
		cmp	eax, 2A0h
		jg	loc_444
		jz	loc_412
		cmp	eax, 4
		jz	short loc_3D2
		cmp	eax, 40h ; '@'
		jnz	loc_459
		lea	eax, [esp+360h+var_2B0]
		push	eax
		call	_SHA1_Init
		add	esp, 4
		test	eax, eax
		jle	loc_B84
		mov	[esp+360h+var_330], offset _tls1_sha1_final_raw
		mov	eax, 14h
		mov	[esp+360h+var_348], offset _SHA1_Transform
		jmp	loc_51A
; ---------------------------------------------------------------------------

loc_3D2:				; CODE XREF: _ssl3_cbc_digest_record+ADj
		lea	eax, [esp+360h+var_2B0]
		push	eax
		call	_MD5_Init
		add	esp, 4
		test	eax, eax
		jle	loc_B84
		mov	edx, 30h ; '0'
		mov	[esp+360h+var_330], offset _tls1_md5_final_raw
		mov	[esp+360h+var_348], offset _MD5_Transform
		mov	eax, 10h
		mov	[esp+360h+var_308], edx
		mov	[esp+360h+var_349], 0
		jmp	loc_51F
; ---------------------------------------------------------------------------

loc_412:				; CODE XREF: _ssl3_cbc_digest_record+A4j
		lea	eax, [esp+360h+var_2B0]
		push	eax
		call	_SHA256_Init
		add	esp, 4
		test	eax, eax
		jle	loc_B84
		mov	[esp+360h+var_330], offset _tls1_sha256_final_raw
		mov	eax, 20h ; ' '
		mov	[esp+360h+var_348], offset _SHA256_Transform
		jmp	loc_51A
; ---------------------------------------------------------------------------

loc_444:				; CODE XREF: _ssl3_cbc_digest_record+9Ej
		sub	eax, 2A1h
		jz	loc_4E0
		sub	eax, 1
		jz	short loc_4C4
		sub	eax, 1
		jz	short loc_495

loc_459:				; CODE XREF: _ssl3_cbc_digest_record+B2j
		push	offset ??_C@_01GBGANLPD@0?$AA@ ; `string'
		push	209h
		push	offset ??_C@_0P@MCJLMBFO@?4?2ssl?2s3_cbc?4c?$AA@ ; ".\\ssl\\s3_cbc.c"
		call	_OpenSSLDie
		add	esp, 0Ch
		test	esi, esi
		jz	loc_B84
		mov	dword ptr [esi], 0
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [esp+354h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_495:				; CODE XREF: _ssl3_cbc_digest_record+16Fj
		lea	eax, [esp+360h+var_2B0]
		push	eax
		call	_SHA224_Init
		add	esp, 4
		test	eax, eax
		jle	loc_B84
		mov	[esp+360h+var_330], offset _tls1_sha256_final_raw
		mov	eax, 1Ch
		mov	[esp+360h+var_348], offset _SHA256_Transform
		jmp	short loc_51A
; ---------------------------------------------------------------------------

loc_4C4:				; CODE XREF: _ssl3_cbc_digest_record+16Aj
		lea	eax, [esp+360h+var_2B0]
		push	eax
		call	_SHA512_Init
		add	esp, 4
		test	eax, eax
		jle	loc_B84
		mov	eax, edi
		jmp	short loc_4FD
; ---------------------------------------------------------------------------

loc_4E0:				; CODE XREF: _ssl3_cbc_digest_record+161j
		lea	eax, [esp+360h+var_2B0]
		push	eax
		call	_SHA384_Init
		add	esp, 4
		test	eax, eax
		jle	loc_B84
		mov	eax, 30h ; '0'

loc_4FD:				; CODE XREF: _ssl3_cbc_digest_record+1F6j
		mov	[esp+360h+var_344], 10h
		mov	edi, 80h ; ''
		mov	[esp+360h+var_348], offset _SHA512_Transform
		mov	[esp+360h+var_330], offset _tls1_sha512_final_raw

loc_51A:				; CODE XREF: _ssl3_cbc_digest_record+E5j
					; _ssl3_cbc_digest_record+157j	...
		mov	edx, 28h ; '('

loc_51F:				; CODE XREF: _ssl3_cbc_digest_record+125j
		cmp	[ebp+arg_24], 0
		mov	ecx, 0Dh
		mov	[esp+360h+var_340], eax
		mov	[esp+360h+var_318], ecx
		jz	short loc_53E
		mov	ecx, [ebp+Size]
		add	ecx, 0Bh
		add	ecx, edx
		mov	[esp+360h+var_318], ecx

loc_53E:				; CODE XREF: _ssl3_cbc_digest_record+248j
		xor	edx, edx
		mov	esi, ecx
		cmp	[ebp+arg_24], dl
		setz	dl
		sub	esi, eax
		mov	eax, [esp+360h+var_344]
		dec	ebx
		add	eax, esi
		xor	ecx, ecx
		add	eax, edi
		add	esi, [ebp+arg_14]
		lea	edx, ds:2[edx*4]
		add	eax, ebx
		mov	[esp+360h+var_324], edx
		xor	ebx, ebx
		xor	edx, edx
		mov	[esp+360h+var_338], ebx
		div	edi
		xor	edx, edx
		mov	[esp+360h+var_32C], eax
		xor	eax, eax
		mov	[esp+360h+var_31C], eax
		mov	eax, esi
		div	edi
		mov	[esp+360h+var_300], eax
		mov	eax, [esp+360h+var_344]
		mov	[esp+360h+var_314], edx
		add	eax, esi
		xor	edx, edx
		div	edi
		cmp	[ebp+arg_24], cl
		mov	edx, [esp+360h+var_324]
		setnz	cl
		mov	[esp+360h+var_2FC], eax
		mov	eax, [esp+360h+var_32C]
		add	ecx, edx
		cmp	eax, ecx
		jbe	short loc_5B8
		sub	eax, edx
		mov	ebx, eax
		mov	[esp+360h+var_31C], eax
		imul	ebx, edi
		mov	[esp+360h+var_338], ebx

loc_5B8:				; CODE XREF: _ssl3_cbc_digest_record+2BFj
		cmp	[ebp+arg_24], 0
		lea	eax, ds:0[esi*8]
		mov	[esp+360h+var_334], eax
		jnz	loc_6A0
		lea	eax, [eax+edi*8]
		push	edi		; Size
		mov	[esp+364h+var_334], eax
		lea	eax, [esp+364h+Dst]
		push	0		; Val
		push	eax		; Dst
		call	_memset
		mov	esi, [ebp+Size]
		add	esp, 0Ch
		cmp	esi, 80h ; ''
		jbe	short loc_609
		push	offset ??_C@_0CG@BPMBJPDA@mac_secret_length?5?$DM?$DN?5sizeof?$CIhmac@ ; "mac_secret_length <= sizeof(hmac_pad)"
		push	271h
		push	offset ??_C@_0P@MCJLMBFO@?4?2ssl?2s3_cbc?4c?$AA@ ; ".\\ssl\\s3_cbc.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_609:				; CODE XREF: _ssl3_cbc_digest_record+308j
		push	esi		; Size
		push	[esp+364h+Src]	; Src
		lea	eax, [esp+368h+Dst]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		xor	ecx, ecx
		test	edi, edi
		jz	short loc_685
		cmp	edi, 20h ; ' '
		jb	short loc_66A
		movaps	xmm1, ds:__xmm@36363636363636363636363636363636
		mov	eax, edi
		and	eax, 1Fh
		mov	edx, edi
		sub	edx, eax
		lea	eax, [esp+360h+var_178]
		nop	dword ptr [eax+eax+00000000h]

loc_648:				; CODE XREF: _ssl3_cbc_digest_record+380j
		movups	xmm0, xmmword ptr [eax-10h]
		add	ecx, 20h ; ' '
		lea	eax, [eax+20h]
		pxor	xmm0, xmm1
		movups	xmmword	ptr [eax-30h], xmm0
		movups	xmm0, xmmword ptr [eax-20h]
		pxor	xmm0, xmm1
		movups	xmmword	ptr [eax-20h], xmm0
		cmp	ecx, edx
		jb	short loc_648

loc_66A:				; CODE XREF: _ssl3_cbc_digest_record+33Fj
		cmp	ecx, edi
		jnb	short loc_685
		db	66h, 66h
		nop	word ptr [eax+eax+00000000h]

loc_678:				; CODE XREF: _ssl3_cbc_digest_record+39Bj
		xor	[esp+ecx+360h+Dst], 36h
		inc	ecx
		cmp	ecx, edi
		jb	short loc_678

loc_685:				; CODE XREF: _ssl3_cbc_digest_record+33Aj
					; _ssl3_cbc_digest_record+384j
		mov	esi, [esp+360h+var_348]
		lea	eax, [esp+360h+Dst]
		push	eax
		lea	eax, [esp+364h+var_2B0]
		push	eax
		call	esi
		add	esp, 8
		jmp	short loc_6A4
; ---------------------------------------------------------------------------

loc_6A0:				; CODE XREF: _ssl3_cbc_digest_record+2DFj
		mov	esi, [esp+360h+var_348]

loc_6A4:				; CODE XREF: _ssl3_cbc_digest_record+3B6j
		cmp	[esp+360h+var_349], 0
		jz	short loc_6FA
		mov	eax, [esp+360h+var_344]
		add	eax, 0FFFFFFFCh
		push	eax		; Size
		lea	eax, [esp+364h+var_1D8]
		push	0		; Val
		push	eax		; Dst
		call	_memset
		mov	ecx, [esp+36Ch+var_334]
		add	esp, 0Ch
		mov	edx, [esp+360h+var_344]
		mov	eax, ecx
		shr	eax, 18h
		mov	[esp+edx+360h+var_1DC],	al
		mov	eax, ecx
		shr	eax, 10h
		mov	[esp+edx+360h+var_1DB],	al
		mov	eax, ecx
		shr	eax, 8
		mov	[esp+edx+360h+var_1DA],	al
		mov	[esp+edx+360h+var_1D9],	cl
		jmp	short loc_743
; ---------------------------------------------------------------------------

loc_6FA:				; CODE XREF: _ssl3_cbc_digest_record+3C1j
		push	[esp+360h+var_344] ; Size
		lea	eax, [esp+364h+var_1D8]
		push	0		; Val
		push	eax		; Dst
		call	_memset
		mov	ecx, [esp+36Ch+var_334]
		add	esp, 0Ch
		mov	edx, [esp+360h+var_344]
		mov	eax, ecx
		shr	eax, 18h
		mov	[esp+edx+360h+var_1DD],	al
		mov	eax, ecx
		shr	eax, 10h
		mov	[esp+edx+360h+var_1DE],	al
		mov	eax, ecx
		shr	eax, 8
		mov	[esp+edx+360h+var_1DF],	al
		mov	[esp+edx+360h+var_1E0],	cl

loc_743:				; CODE XREF: _ssl3_cbc_digest_record+410j
		test	ebx, ebx
		jz	loc_871
		cmp	[ebp+arg_24], 0
		jz	loc_7F4
		mov	esi, [esp+360h+var_318]
		cmp	esi, edi
		jbe	loc_B84
		push	[esp+360h+var_320]
		lea	eax, [esp+364h+var_2B0]
		sub	esi, edi
		push	eax
		mov	[esp+368h+var_32C], esi
		call	[esp+368h+var_348]
		mov	eax, [esp+368h+var_320]
		add	eax, edi
		push	esi		; Size
		push	eax		; Src
		lea	eax, [esp+370h+var_108]
		push	eax		; Dst
		call	_memcpy
		mov	eax, edi
		sub	eax, esi
		push	eax		; Size
		push	[esp+378h+var_328] ; Src
		lea	eax, [esp+37Ch+var_108]
		add	eax, esi
		push	eax		; Dst
		call	_memcpy
		lea	eax, [esp+380h+var_108]
		push	eax
		lea	eax, [esp+384h+var_2B0]
		push	eax
		call	[esp+388h+var_348]
		xor	edx, edx
		mov	eax, ebx
		div	edi
		add	esp, 28h
		dec	eax
		cmp	eax, 1
		jbe	loc_871
		mov	esi, [esp+360h+var_328]
		lea	ebx, [eax-1]
		sub	esi, [esp+360h+var_32C]
		add	esi, edi

loc_7D8:				; CODE XREF: _ssl3_cbc_digest_record+505j
		lea	eax, [esp+360h+var_2B0]
		push	esi
		push	eax
		call	[esp+368h+var_348]
		add	esp, 8
		add	esi, edi
		sub	ebx, 1
		jnz	short loc_7D8
		jmp	loc_871
; ---------------------------------------------------------------------------

loc_7F4:				; CODE XREF: _ssl3_cbc_digest_record+467j
		mov	ecx, [esp+360h+var_320]
		mov	eax, [ecx+8]
		movq	xmm0, qword ptr	[ecx]
		mov	[esp+360h+var_100], eax
		mov	al, [ecx+0Ch]
		mov	[esp+360h+var_FC], al
		lea	eax, [edi-0Dh]
		push	eax		; Size
		push	[esp+364h+var_328] ; Src
		lea	eax, [esp+368h+var_FB]
		movq	[esp+368h+var_108], xmm0
		push	eax		; Dst
		call	_memcpy
		lea	eax, [esp+36Ch+var_108]
		push	eax
		lea	eax, [esp+370h+var_2B0]
		push	eax
		call	esi
		xor	edx, edx
		mov	eax, ebx
		div	edi
		add	esp, 14h
		cmp	eax, 1
		jbe	short loc_871
		mov	esi, [esp+360h+var_328]
		lea	ebx, [eax-1]
		add	esi, 0FFFFFFF3h
		add	esi, edi

loc_85A:				; CODE XREF: _ssl3_cbc_digest_record+587j
		lea	eax, [esp+360h+var_2B0]
		push	esi
		push	eax
		call	[esp+368h+var_348]
		add	esp, 8
		add	esi, edi
		sub	ebx, 1
		jnz	short loc_85A

loc_871:				; CODE XREF: _ssl3_cbc_digest_record+45Dj
					; _ssl3_cbc_digest_record+4DDj	...
		push	40h ; '@'       ; Size
		lea	eax, [esp+364h+var_1C8]
		push	0		; Val
		push	eax		; Dst
		call	_memset
		mov	eax, [esp+36Ch+var_324]
		add	esp, 0Ch
		mov	edx, [esp+360h+var_31C]
		add	eax, edx
		mov	esi, [esp+360h+var_340]
		mov	[esp+360h+var_2E8], eax
		cmp	edx, eax
		ja	loc_AD0

loc_89F:				; CODE XREF: _ssl3_cbc_digest_record+7E2j
		mov	eax, edx
		xor	eax, [esp+360h+var_300]
		lea	ecx, [eax-1]
		not	eax
		shr	ecx, 1Fh
		shr	eax, 1Fh
		and	cl, al
		mov	eax, edx
		xor	eax, [esp+360h+var_2FC]
		neg	cl
		mov	[esp+360h+var_324], ecx
		xor	edx, edx
		mov	[esp+360h+var_310], edx
		lea	ecx, [eax-1]
		not	eax
		shr	ecx, 1Fh
		shr	eax, 1Fh
		and	cl, al
		neg	cl
		movsx	eax, cl
		mov	[esp+360h+var_32C], ecx
		movd	xmm0, eax
		punpcklbw xmm0,	xmm0
		punpcklwd xmm0,	xmm0
		pshufd	xmm0, xmm0, 0
		movaps	[esp+360h+var_2C0], xmm0
		test	edi, edi
		jz	loc_A0B
		mov	eax, [esp+360h+var_314]
		not	cl
		lea	esi, [eax+1]
		shr	eax, 1Fh
		mov	[esp+360h+var_2F8], eax
		mov	eax, [esp+360h+var_324]
		or	cl, al
		movzx	ebx, al
		mov	eax, edi
		sub	eax, [esp+360h+var_344]
		shr	esi, 1Fh
		mov	[esp+360h+var_2EC], eax
		mov	eax, [esp+360h+var_344]
		mov	[esp+360h+var_2F0], esi
		sub	eax, edi
		mov	esi, [esp+360h+var_314]
		mov	[esp+360h+var_2F4], ebx
		neg	esi
		lea	ebx, [esp+360h+var_1D8]
		mov	[esp+360h+var_339], cl
		add	eax, ebx
		mov	ebx, [esp+360h+var_338]
		mov	[esp+360h+var_334], eax

loc_94A:				; CODE XREF: _ssl3_cbc_digest_record+719j
		mov	ecx, [esp+360h+var_318]
		mov	[esp+360h+var_349], 0
		cmp	ebx, ecx
		jnb	short loc_95D
		mov	eax, [esp+360h+var_320]
		jmp	short loc_96C
; ---------------------------------------------------------------------------

loc_95D:				; CODE XREF: _ssl3_cbc_digest_record+66Dj
		mov	eax, [ebp+arg_18]
		add	eax, ecx
		cmp	ebx, eax
		jnb	short loc_973
		mov	eax, [esp+360h+var_328]
		sub	eax, ecx

loc_96C:				; CODE XREF: _ssl3_cbc_digest_record+673j
		mov	al, [eax+ebx]
		mov	[esp+360h+var_349], al

loc_973:				; CODE XREF: _ssl3_cbc_digest_record+67Cj
		mov	eax, [esp+360h+var_2F8]
		inc	ebx
		mov	[esp+360h+var_338], ebx
		mov	ecx, esi
		shr	ecx, 1Fh
		lea	ebx, [esi-1]
		xor	cl, al
		shr	edx, 1Fh
		xor	al, dl
		shr	ebx, 1Fh
		or	cl, al
		mov	eax, [esp+360h+var_2F0]
		xor	bl, al
		xor	cl, dl
		xor	al, dl
		dec	cl
		or	bl, al
		movzx	ecx, cl
		and	ecx, [esp+360h+var_2F4]
		xor	bl, dl
		mov	edx, [esp+360h+var_310]
		dec	bl
		and	bl, byte ptr [esp+360h+var_324]
		mov	al, cl
		not	al
		and	cl, 80h
		and	al, [esp+360h+var_349]
		not	bl
		or	al, cl
		and	bl, al
		and	bl, [esp+360h+var_339]
		cmp	edx, [esp+360h+var_2EC]
		jb	short loc_9E3
		mov	eax, [esp+360h+var_32C]
		movzx	ecx, al
		mov	al, cl
		not	al
		and	al, bl
		mov	ebx, [esp+360h+var_334]
		and	cl, [ebx]
		or	al, cl
		mov	bl, al

loc_9E3:				; CODE XREF: _ssl3_cbc_digest_record+6E2j
		inc	[esp+360h+var_334]
		lea	eax, [esp+360h+var_88]
		add	eax, [esp+360h+var_314]
		inc	edx
		mov	[esp+360h+var_310], edx
		mov	[eax+esi], bl
		inc	esi
		mov	ebx, [esp+360h+var_338]
		cmp	edx, edi
		jb	loc_94A
		mov	esi, [esp+360h+var_340]

loc_A0B:				; CODE XREF: _ssl3_cbc_digest_record+60Dj
		lea	eax, [esp+360h+var_88]
		push	eax
		lea	eax, [esp+364h+var_2B0]
		push	eax
		call	[esp+368h+var_348]
		lea	eax, [esp+368h+var_88]
		push	eax
		lea	eax, [esp+36Ch+var_2B0]
		push	eax
		call	[esp+370h+var_330]
		add	esp, 10h
		xor	eax, eax
		test	esi, esi
		jz	loc_ABD
		cmp	esi, 20h ; ' '
		jb	short loc_A9F
		movaps	xmm2, [esp+360h+var_2C0]
		mov	ecx, esi
		and	ecx, 1Fh
		mov	edx, esi
		sub	edx, ecx
		xchg	ax, ax

loc_A58:				; CODE XREF: _ssl3_cbc_digest_record+7B5j
		movups	xmm0, [esp+eax+360h+var_1C8]
		movups	xmm1, [esp+eax+360h+var_88]
		pand	xmm1, xmm2
		por	xmm1, xmm0
		movups	[esp+eax+360h+var_1C8],	xmm1
		movups	xmm1, [esp+eax+360h+var_78]
		movups	xmm0, [esp+eax+360h+var_1B8]
		pand	xmm1, xmm2
		por	xmm1, xmm0
		movups	[esp+eax+360h+var_1B8],	xmm1
		add	eax, 20h ; ' '
		cmp	eax, edx
		jb	short loc_A58

loc_A9F:				; CODE XREF: _ssl3_cbc_digest_record+75Bj
		cmp	eax, esi
		jnb	short loc_ABD
		mov	edx, [esp+360h+var_32C]
		nop

loc_AA8:				; CODE XREF: _ssl3_cbc_digest_record+7D3j
		mov	cl, byte ptr [esp+eax+360h+var_88]
		and	cl, dl
		or	byte ptr [esp+eax+360h+var_1C8], cl
		inc	eax
		cmp	eax, esi
		jb	short loc_AA8

loc_ABD:				; CODE XREF: _ssl3_cbc_digest_record+752j
					; _ssl3_cbc_digest_record+7B9j
		mov	edx, [esp+360h+var_31C]
		inc	edx
		mov	[esp+360h+var_31C], edx
		cmp	edx, [esp+360h+var_2E8]
		jbe	loc_89F

loc_AD0:				; CODE XREF: _ssl3_cbc_digest_record+5B1j
		lea	eax, [esp+360h+var_2D8]
		push	eax
		call	_EVP_MD_CTX_init
		mov	eax, [esp+364h+var_30C]
		push	0
		push	dword ptr [eax]
		lea	eax, [esp+36Ch+var_2D8]
		push	eax
		call	_EVP_DigestInit_ex
		add	esp, 10h
		test	eax, eax
		jle	$err$163
		cmp	[ebp+arg_24], 0
		jz	loc_B9B
		mov	ebx, [esp+360h+var_308]
		lea	eax, [esp+360h+Dst]
		push	ebx		; Size
		push	5Ch ; '\'       ; Val
		push	eax		; Dst
		call	_memset
		push	[ebp+Size]
		lea	eax, [esp+370h+var_2D8]
		push	[esp+370h+Src]
		push	eax
		call	_EVP_DigestUpdate
		add	esp, 18h
		test	eax, eax
		jle	short $err$163
		push	ebx
		lea	eax, [esp+364h+Dst]
		push	eax
		lea	eax, [esp+368h+var_2D8]
		push	eax
		call	_EVP_DigestUpdate
		add	esp, 0Ch
		test	eax, eax
		jle	short $err$163
		push	esi
		lea	eax, [esp+364h+var_1C8]
		push	eax
		lea	eax, [esp+368h+var_2D8]
		push	eax
		call	_EVP_DigestUpdate
		add	esp, 0Ch
		test	eax, eax
		jg	loc_C37

$err$163:				; CODE XREF: _ssl3_cbc_digest_record+80Fj
					; _ssl3_cbc_digest_record+84Cj	...
		lea	eax, [esp+360h+var_2D8]
		push	eax
		call	_EVP_MD_CTX_cleanup
		add	esp, 4

loc_B84:				; CODE XREF: _ssl3_cbc_digest_record+CAj
					; _ssl3_cbc_digest_record+FCj ...
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [esp+354h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_B9B:				; CODE XREF: _ssl3_cbc_digest_record+819j
		xor	ecx, ecx
		test	edi, edi
		jz	short loc_BF5
		cmp	edi, 20h ; ' '
		jb	short loc_BDF
		movaps	xmm1, ds:__xmm@6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a
		mov	eax, edi
		and	eax, 1Fh
		mov	edx, edi
		sub	edx, eax
		lea	eax, [esp+360h+var_178]

loc_BBD:				; CODE XREF: _ssl3_cbc_digest_record+8F5j
		movups	xmm0, xmmword ptr [eax-10h]
		add	ecx, 20h ; ' '
		lea	eax, [eax+20h]
		pxor	xmm0, xmm1
		movups	xmmword	ptr [eax-30h], xmm0
		movups	xmm0, xmmword ptr [eax-20h]
		pxor	xmm0, xmm1
		movups	xmmword	ptr [eax-20h], xmm0
		cmp	ecx, edx
		jb	short loc_BBD

loc_BDF:				; CODE XREF: _ssl3_cbc_digest_record+8BCj
		cmp	ecx, edi
		jnb	short loc_BF5
		nop	dword ptr [eax+eax+00h]

loc_BE8:				; CODE XREF: _ssl3_cbc_digest_record+90Bj
		xor	[esp+ecx+360h+Dst], 6Ah
		inc	ecx
		cmp	ecx, edi
		jb	short loc_BE8

loc_BF5:				; CODE XREF: _ssl3_cbc_digest_record+8B7j
					; _ssl3_cbc_digest_record+8F9j
		push	edi
		lea	eax, [esp+364h+Dst]
		push	eax
		lea	eax, [esp+368h+var_2D8]
		push	eax
		call	_EVP_DigestUpdate
		add	esp, 0Ch
		test	eax, eax
		jle	$err$163
		push	esi
		lea	eax, [esp+364h+var_1C8]
		push	eax
		lea	eax, [esp+368h+var_2D8]
		push	eax
		call	_EVP_DigestUpdate
		add	esp, 0Ch
		test	eax, eax
		jle	$err$163

loc_C37:				; CODE XREF: _ssl3_cbc_digest_record+886j
		lea	eax, [esp+360h+var_2DC]
		push	eax
		push	[esp+364h+var_2E4]
		lea	eax, [esp+368h+var_2D8]
		push	eax
		call	_EVP_DigestFinal
		mov	ecx, [esp+364h+var_2D8]
		add	esp, 0Ch
		test	ecx, ecx
		jz	short loc_C6A
		mov	eax, [esp+358h+var_2D4]
		mov	[ecx], eax

loc_C6A:				; CODE XREF: _ssl3_cbc_digest_record+977j
		lea	eax, [esp+358h+var_2D0]
		push	eax
		call	_EVP_MD_CTX_cleanup
		mov	ecx, [esp+360h]
		add	esp, 4
		mov	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
_ssl3_cbc_digest_record	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C94h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl3_cbc_record_digest_supported
_ssl3_cbc_record_digest_supported proc near

arg_0		= dword	ptr  4

		push	[esp+arg_0]
		call	_EVP_MD_CTX_md
		push	eax
		call	_EVP_MD_type
		add	esp, 8
		cmp	eax, 40h ; '@'
		jg	short loc_CB5
		jz	short loc_CBF
		cmp	eax, 4
		jz	short loc_CBF

loc_CB2:				; CODE XREF: _ssl3_cbc_record_digest_supported+29j
		xor	al, al
		retn
; ---------------------------------------------------------------------------

loc_CB5:				; CODE XREF: _ssl3_cbc_record_digest_supported+15j
		add	eax, 0FFFFFD60h
		cmp	eax, 3
		ja	short loc_CB2

loc_CBF:				; CODE XREF: _ssl3_cbc_record_digest_supported+17j
					; _ssl3_cbc_record_digest_supported+1Cj
		mov	al, 1
		retn
_ssl3_cbc_record_digest_supported endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0CC4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl3_cbc_remove_padding
_ssl3_cbc_remove_padding proc near

arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	ecx, [esp+arg_C]
		push	ebx
		push	ebp
		mov	ebp, [esp+8+arg_4]
		inc	ecx
		mov	ebx, [ebp+4]
		cmp	ecx, ebx
		jbe	short loc_CDB
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_CDB:				; CODE XREF: _ssl3_cbc_remove_padding+10j
		mov	eax, [ebp+0Ch]
		push	esi
		push	edi
		mov	edi, ebx
		movzx	eax, byte ptr [eax+ebx-1]
		add	ecx, eax
		sub	edi, ecx
		xor	edi, ecx
		lea	esi, [eax+1]
		mov	eax, ebx
		xor	eax, ecx
		mov	ecx, [esp+10h+arg_8]
		or	edi, eax
		mov	edx, ecx
		sub	edx, esi
		mov	eax, esi
		xor	edx, esi
		xor	eax, ecx
		or	edx, eax
		xor	edi, ebx
		shr	edi, 1Fh
		xor	edx, ecx
		dec	edi
		shr	edx, 1Fh
		dec	edx
		and	edi, edx
		and	esi, edi
		mov	eax, edi
		sub	ebx, esi
		not	edi
		and	eax, 1
		shl	esi, 8
		or	[ebp+0], esi
		or	eax, edi
		pop	edi
		pop	esi
		mov	[ebp+4], ebx
		pop	ebp
		pop	ebx
		retn
_ssl3_cbc_remove_padding endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D30h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _tls1_cbc_remove_padding
_tls1_cbc_remove_padding proc near

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, 8
		call	__chkstk
		push	ebp
		mov	ebp, [esp+0Ch+arg_C]
		push	esi
		mov	esi, [esp+10h+arg_4]
		inc	ebp
		push	edi
		mov	edi, [esp+14h+arg_0]
		mov	eax, [edi+8]
		mov	eax, [eax+64h]
		test	byte ptr [eax+38h], 1
		jz	short loc_D7A
		mov	ecx, [esp+14h+arg_8]
		mov	edx, [esi+4]
		lea	eax, [ecx+ebp]
		cmp	eax, edx
		jbe	short loc_D6D

loc_D64:				; CODE XREF: _tls1_cbc_remove_padding+4Dj
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebp
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_D6D:				; CODE XREF: _tls1_cbc_remove_padding+32j
		add	[esi+0Ch], ecx
		add	[esi+10h], ecx
		sub	edx, ecx
		mov	[esi+4], edx
		jmp	short loc_D7F
; ---------------------------------------------------------------------------

loc_D7A:				; CODE XREF: _tls1_cbc_remove_padding+24j
		cmp	ebp, [esi+4]
		ja	short loc_D64

loc_D7F:				; CODE XREF: _tls1_cbc_remove_padding+48j
		test	dword ptr [edi+100h], 200h
		mov	ecx, [esi+0Ch]
		mov	eax, [esi+4]
		push	ebx
		movzx	ebx, byte ptr [ecx+eax-1]
		jz	short loc_DD2
		cmp	dword ptr [edi+88h], 0
		jnz	short loc_DD2
		mov	eax, [edi+58h]
		push	8
		add	eax, 8
		push	offset ??_C@_08BJPGOLFB@?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA@ ;	`string'
		push	eax
		call	_CRYPTO_memcmp
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_DC5
		test	bl, 1
		jnz	short loc_DC5
		mov	eax, [edi+58h]
		or	dword ptr [eax], 8

loc_DC5:				; CODE XREF: _tls1_cbc_remove_padding+88j
					; _tls1_cbc_remove_padding+8Dj
		mov	eax, [edi+58h]
		test	byte ptr [eax],	8
		jz	short loc_DD2
		test	ebx, ebx
		jz	short loc_DD2
		dec	ebx

loc_DD2:				; CODE XREF: _tls1_cbc_remove_padding+65j
					; _tls1_cbc_remove_padding+6Ej	...
		mov	eax, [edi+80h]
		push	dword ptr [eax]
		call	_EVP_CIPHER_flags
		add	esp, 4
		test	eax, 200000h
		jz	short loc_DFE
		or	eax, 0FFFFFFFFh
		sub	eax, ebx
		add	[esi+4], eax
		mov	eax, 1
		pop	ebx
		pop	edi
		pop	esi
		pop	ebp
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_DFE:				; CODE XREF: _tls1_cbc_remove_padding+B7j
		lea	ecx, [ebx+ebp]
		mov	ebp, [esi+4]
		mov	edx, ebp
		mov	[esp+18h+var_4], ebp
		sub	edx, ecx
		mov	eax, ebp
		xor	edx, ecx
		xor	eax, ecx
		or	edx, eax
		mov	ecx, 0FFh
		xor	edx, ebp
		lea	eax, [ebp-1]
		shr	edx, 1Fh
		dec	edx
		cmp	eax, ecx
		mov	[esp+18h+arg_0], edx
		cmovb	ecx, eax
		xor	edi, edi
		mov	[esp+18h+var_8], ecx
		test	ecx, ecx
		jz	short loc_E89
		mov	ecx, ebx
		dec	ebp
		shr	ecx, 1Fh
		add	ebp, [esi+0Ch]
		mov	esi, [esp+18h+var_8]
		mov	[esp+18h+arg_C], ecx

loc_E46:				; CODE XREF: _tls1_cbc_remove_padding+14Fj
		mov	al, byte ptr [esp+18h+arg_C]
		lea	ebp, [ebp-1]
		mov	edx, ebx
		mov	ecx, edi
		sub	edx, edi
		shr	ecx, 1Fh
		shr	edx, 1Fh
		xor	al, cl
		xor	dl, cl
		inc	edi
		or	dl, al
		movzx	eax, byte ptr [ebp+1]
		xor	dl, byte ptr [esp+18h+arg_C]
		xor	eax, ebx
		dec	dl
		movzx	ecx, dl
		mov	edx, [esp+18h+arg_0]
		and	ecx, eax
		not	ecx
		and	edx, ecx
		mov	[esp+18h+arg_0], edx
		cmp	edi, esi
		jb	short loc_E46
		mov	esi, [esp+18h+arg_4]
		mov	ebp, [esp+18h+var_4]

loc_E89:				; CODE XREF: _tls1_cbc_remove_padding+103j
		not	edx
		movzx	eax, dl
		lea	ecx, [eax-1]
		not	eax
		shr	eax, 1Fh
		shr	ecx, 1Fh
		and	ecx, eax
		lea	eax, [ebx+1]
		neg	ecx
		and	eax, ecx
		sub	ebp, eax
		shl	eax, 8
		or	[esi], eax
		mov	eax, ecx
		pop	ebx
		pop	edi
		mov	[esi+4], ebp
		and	eax, 1
		not	ecx
		pop	esi
		or	eax, ecx
		pop	ebp
		add	esp, 8
		retn
_tls1_cbc_remove_padding endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0EC0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_tls1_md5_final_raw proc near		; DATA XREF: _ssl3_cbc_digest_record+107o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		movzx	eax, byte ptr [edx]
		mov	[ecx], al
		mov	eax, [edx]
		shr	eax, 8
		mov	[ecx+1], al
		movzx	eax, byte ptr [edx+2]
		mov	[ecx+2], al
		movzx	eax, byte ptr [edx+3]
		mov	[ecx+3], al
		movzx	eax, byte ptr [edx+4]
		mov	[ecx+4], al
		mov	eax, [edx+4]
		shr	eax, 8
		mov	[ecx+5], al
		movzx	eax, byte ptr [edx+6]
		mov	[ecx+6], al
		movzx	eax, byte ptr [edx+7]
		mov	[ecx+7], al
		movzx	eax, byte ptr [edx+8]
		mov	[ecx+8], al
		mov	eax, [edx+8]
		shr	eax, 8
		mov	[ecx+9], al
		movzx	eax, byte ptr [edx+0Ah]
		mov	[ecx+0Ah], al
		movzx	eax, byte ptr [edx+0Bh]
		mov	[ecx+0Bh], al
		movzx	eax, byte ptr [edx+0Ch]
		mov	[ecx+0Ch], al
		mov	eax, [edx+0Ch]
		shr	eax, 8
		mov	[ecx+0Dh], al
		movzx	eax, byte ptr [edx+0Eh]
		mov	[ecx+0Eh], al
		movzx	eax, byte ptr [edx+0Fh]
		mov	[ecx+0Fh], al
		retn
_tls1_md5_final_raw endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F40h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_tls1_sha1_final_raw proc near		; DATA XREF: _ssl3_cbc_digest_record+D0o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		movzx	eax, byte ptr [edx+3]
		mov	[ecx], al
		movzx	eax, byte ptr [edx+2]
		mov	[ecx+1], al
		movzx	eax, byte ptr [edx+1]
		mov	[ecx+2], al
		movzx	eax, byte ptr [edx]
		mov	[ecx+3], al
		movzx	eax, byte ptr [edx+7]
		mov	[ecx+4], al
		movzx	eax, byte ptr [edx+6]
		mov	[ecx+5], al
		movzx	eax, byte ptr [edx+5]
		mov	[ecx+6], al
		movzx	eax, byte ptr [edx+4]
		mov	[ecx+7], al
		movzx	eax, byte ptr [edx+0Bh]
		mov	[ecx+8], al
		movzx	eax, byte ptr [edx+0Ah]
		mov	[ecx+9], al
		movzx	eax, byte ptr [edx+9]
		mov	[ecx+0Ah], al
		movzx	eax, byte ptr [edx+8]
		mov	[ecx+0Bh], al
		movzx	eax, byte ptr [edx+0Fh]
		mov	[ecx+0Ch], al
		movzx	eax, byte ptr [edx+0Eh]
		mov	[ecx+0Dh], al
		movzx	eax, byte ptr [edx+0Dh]
		mov	[ecx+0Eh], al
		movzx	eax, byte ptr [edx+0Ch]
		mov	[ecx+0Fh], al
		movzx	eax, byte ptr [edx+13h]
		mov	[ecx+10h], al
		movzx	eax, byte ptr [edx+12h]
		mov	[ecx+11h], al
		movzx	eax, byte ptr [edx+11h]
		mov	[ecx+12h], al
		movzx	eax, byte ptr [edx+10h]
		mov	[ecx+13h], al
		retn
_tls1_sha1_final_raw endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0FD4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_tls1_sha256_final_raw proc near	; DATA XREF: _ssl3_cbc_digest_record+142o
					; _ssl3_cbc_digest_record+1C5o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		movzx	eax, byte ptr [edx+3]
		mov	[ecx], al
		movzx	eax, byte ptr [edx+2]
		mov	[ecx+1], al
		movzx	eax, byte ptr [edx+1]
		mov	[ecx+2], al
		movzx	eax, byte ptr [edx]
		mov	[ecx+3], al
		movzx	eax, byte ptr [edx+7]
		mov	[ecx+4], al
		movzx	eax, byte ptr [edx+6]
		mov	[ecx+5], al
		movzx	eax, byte ptr [edx+5]
		mov	[ecx+6], al
		movzx	eax, byte ptr [edx+4]
		mov	[ecx+7], al
		movzx	eax, byte ptr [edx+0Bh]
		mov	[ecx+8], al
		movzx	eax, byte ptr [edx+0Ah]
		mov	[ecx+9], al
		movzx	eax, byte ptr [edx+9]
		mov	[ecx+0Ah], al
		movzx	eax, byte ptr [edx+8]
		mov	[ecx+0Bh], al
		movzx	eax, byte ptr [edx+0Fh]
		mov	[ecx+0Ch], al
		movzx	eax, byte ptr [edx+0Eh]
		mov	[ecx+0Dh], al
		movzx	eax, byte ptr [edx+0Dh]
		mov	[ecx+0Eh], al
		movzx	eax, byte ptr [edx+0Ch]
		mov	[ecx+0Fh], al
		movzx	eax, byte ptr [edx+13h]
		mov	[ecx+10h], al
		movzx	eax, byte ptr [edx+12h]
		mov	[ecx+11h], al
		movzx	eax, byte ptr [edx+11h]
		mov	[ecx+12h], al
		movzx	eax, byte ptr [edx+10h]
		mov	[ecx+13h], al
		movzx	eax, byte ptr [edx+17h]
		mov	[ecx+14h], al
		movzx	eax, byte ptr [edx+16h]
		mov	[ecx+15h], al
		movzx	eax, byte ptr [edx+15h]
		mov	[ecx+16h], al
		movzx	eax, byte ptr [edx+14h]
		mov	[ecx+17h], al
		movzx	eax, byte ptr [edx+1Bh]
		mov	[ecx+18h], al
		movzx	eax, byte ptr [edx+1Ah]
		mov	[ecx+19h], al
		movzx	eax, byte ptr [edx+19h]
		mov	[ecx+1Ah], al
		movzx	eax, byte ptr [edx+18h]
		mov	[ecx+1Bh], al
		movzx	eax, byte ptr [edx+1Fh]
		mov	[ecx+1Ch], al
		movzx	eax, byte ptr [edx+1Eh]
		mov	[ecx+1Dh], al
		movzx	eax, byte ptr [edx+1Dh]
		mov	[ecx+1Eh], al
		movzx	eax, byte ptr [edx+1Ch]
		mov	[ecx+1Fh], al
		retn
_tls1_sha256_final_raw endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 10BCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_tls1_sha512_final_raw proc near	; DATA XREF: _ssl3_cbc_digest_record+22Ao

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		movzx	eax, byte ptr [edx+7]
		mov	[ecx], al
		movzx	eax, byte ptr [edx+6]
		mov	[ecx+1], al
		movzx	eax, byte ptr [edx+5]
		mov	[ecx+2], al
		movzx	eax, byte ptr [edx+4]
		mov	[ecx+3], al
		movzx	eax, byte ptr [edx+3]
		mov	[ecx+4], al
		movzx	eax, byte ptr [edx+2]
		mov	[ecx+5], al
		movzx	eax, byte ptr [edx+1]
		mov	[ecx+6], al
		movzx	eax, byte ptr [edx]
		mov	[ecx+7], al
		movzx	eax, byte ptr [edx+0Fh]
		mov	[ecx+8], al
		movzx	eax, byte ptr [edx+0Eh]
		mov	[ecx+9], al
		movzx	eax, byte ptr [edx+0Dh]
		mov	[ecx+0Ah], al
		movzx	eax, byte ptr [edx+0Ch]
		mov	[ecx+0Bh], al
		movzx	eax, byte ptr [edx+0Bh]
		mov	[ecx+0Ch], al
		movzx	eax, byte ptr [edx+0Ah]
		mov	[ecx+0Dh], al
		movzx	eax, byte ptr [edx+9]
		mov	[ecx+0Eh], al
		movzx	eax, byte ptr [edx+8]
		mov	[ecx+0Fh], al
		movzx	eax, byte ptr [edx+17h]
		mov	[ecx+10h], al
		movzx	eax, byte ptr [edx+16h]
		mov	[ecx+11h], al
		movzx	eax, byte ptr [edx+15h]
		mov	[ecx+12h], al
		movzx	eax, byte ptr [edx+14h]
		mov	[ecx+13h], al
		movzx	eax, byte ptr [edx+13h]
		mov	[ecx+14h], al
		movzx	eax, byte ptr [edx+12h]
		mov	[ecx+15h], al
		movzx	eax, byte ptr [edx+11h]
		mov	[ecx+16h], al
		movzx	eax, byte ptr [edx+10h]
		mov	[ecx+17h], al
		movzx	eax, byte ptr [edx+1Fh]
		mov	[ecx+18h], al
		movzx	eax, byte ptr [edx+1Eh]
		mov	[ecx+19h], al
		movzx	eax, byte ptr [edx+1Dh]
		mov	[ecx+1Ah], al
		movzx	eax, byte ptr [edx+1Ch]
		mov	[ecx+1Bh], al
		movzx	eax, byte ptr [edx+1Bh]
		mov	[ecx+1Ch], al
		movzx	eax, byte ptr [edx+1Ah]
		mov	[ecx+1Dh], al
		movzx	eax, byte ptr [edx+19h]
		mov	[ecx+1Eh], al
		movzx	eax, byte ptr [edx+18h]
		mov	[ecx+1Fh], al
		movzx	eax, byte ptr [edx+27h]
		mov	[ecx+20h], al
		movzx	eax, byte ptr [edx+26h]
		mov	[ecx+21h], al
		movzx	eax, byte ptr [edx+25h]
		mov	[ecx+22h], al
		movzx	eax, byte ptr [edx+24h]
		mov	[ecx+23h], al
		movzx	eax, byte ptr [edx+23h]
		mov	[ecx+24h], al
		movzx	eax, byte ptr [edx+22h]
		mov	[ecx+25h], al
		movzx	eax, byte ptr [edx+21h]
		mov	[ecx+26h], al
		movzx	eax, byte ptr [edx+20h]
		mov	[ecx+27h], al
		movzx	eax, byte ptr [edx+2Fh]
		mov	[ecx+28h], al
		movzx	eax, byte ptr [edx+2Eh]
		mov	[ecx+29h], al
		movzx	eax, byte ptr [edx+2Dh]
		mov	[ecx+2Ah], al
		movzx	eax, byte ptr [edx+2Ch]
		mov	[ecx+2Bh], al
		movzx	eax, byte ptr [edx+2Bh]
		mov	[ecx+2Ch], al
		movzx	eax, byte ptr [edx+2Ah]
		mov	[ecx+2Dh], al
		movzx	eax, byte ptr [edx+29h]
		mov	[ecx+2Eh], al
		movzx	eax, byte ptr [edx+28h]
		mov	[ecx+2Fh], al
		movzx	eax, byte ptr [edx+37h]
		mov	[ecx+30h], al
		movzx	eax, byte ptr [edx+36h]
		mov	[ecx+31h], al
		movzx	eax, byte ptr [edx+35h]
		mov	[ecx+32h], al
		movzx	eax, byte ptr [edx+34h]
		mov	[ecx+33h], al
		movzx	eax, byte ptr [edx+33h]
		mov	[ecx+34h], al
		movzx	eax, byte ptr [edx+32h]
		mov	[ecx+35h], al
		movzx	eax, byte ptr [edx+31h]
		mov	[ecx+36h], al
		movzx	eax, byte ptr [edx+30h]
		mov	[ecx+37h], al
		movzx	eax, byte ptr [edx+3Fh]
		mov	[ecx+38h], al
		movzx	eax, byte ptr [edx+3Eh]
		mov	[ecx+39h], al
		movzx	eax, byte ptr [edx+3Dh]
		mov	[ecx+3Ah], al
		movzx	eax, byte ptr [edx+3Ch]
		mov	[ecx+3Bh], al
		movzx	eax, byte ptr [edx+3Bh]
		mov	[ecx+3Ch], al
		movzx	eax, byte ptr [edx+3Ah]
		mov	[ecx+3Dh], al
		movzx	eax, byte ptr [edx+39h]
		mov	[ecx+3Eh], al
		movzx	eax, byte ptr [edx+38h]
		mov	[ecx+3Fh], al
		retn
_tls1_sha512_final_raw endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1284h
; COMDAT (pick any)
		public ??_C@_08BJPGOLFB@?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA@
; `string'
??_C@_08BJPGOLFB@?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA?$AA@ dd 2 dup(0)
					; DATA XREF: _tls1_cbc_remove_padding+78o
		db 0
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1290h
; COMDAT (pick any)
		public ??_C@_0BE@FDMJMLAH@orig_len?5?$DO?$DN?5md_size?$AA@
; `string'
??_C@_0BE@FDMJMLAH@orig_len?5?$DO?$DN?5md_size?$AA@ db 'orig_len >= md_size',0
					; DATA XREF: _ssl3_cbc_copy_mac+4Fo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 12A4h
; COMDAT (pick any)
		public ??_C@_0P@MCJLMBFO@?4?2ssl?2s3_cbc?4c?$AA@
; `string'
??_C@_0P@MCJLMBFO@?4?2ssl?2s3_cbc?4c?$AA@ db '.\ssl\s3_cbc.c',0
					; DATA XREF: _ssl3_cbc_copy_mac+59o
					; _ssl3_cbc_copy_mac+75o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 12B4h
; COMDAT (pick any)
		public ??_C@_0BL@DNIGBJK@md_size?5?$DM?$DN?5EVP_MAX_MD_SIZE?$AA@
; `string'
??_C@_0BL@DNIGBJK@md_size?5?$DM?$DN?5EVP_MAX_MD_SIZE?$AA@ db 'md_size <= EVP_MAX_MD_SIZE',0
					; DATA XREF: _ssl3_cbc_copy_mac+6Bo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 12D0h
; COMDAT (pick any)
		public ??_C@_0CO@LFAHLKMA@data_plus_mac_plus_padding_size?5@
; `string'
??_C@_0CO@LFAHLKMA@data_plus_mac_plus_padding_size?5@ db 'data_plus_mac_plus_padding_size < 1024 * 1024',0
					; DATA XREF: _ssl3_cbc_digest_record+70o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1300h
; COMDAT (pick any)
		public ??_C@_01GBGANLPD@0?$AA@
; `string'
??_C@_01GBGANLPD@0?$AA@	db 30h,	0	; DATA XREF: _ssl3_cbc_digest_record:loc_459o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1304h
; COMDAT (pick any)
		public ??_C@_0CG@BPMBJPDA@mac_secret_length?5?$DM?$DN?5sizeof?$CIhmac@
; `string'
??_C@_0CG@BPMBJPDA@mac_secret_length?5?$DM?$DN?5sizeof?$CIhmac@	db 'mac_secret_length <= sizeof(hmac_pad)',0
					; DATA XREF: _ssl3_cbc_digest_record+30Ao
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 132Ch
; COMDAT (pick any)
		public __xmm@36363636363636363636363636363636
__xmm@36363636363636363636363636363636 xmmword 36363636363636363636363636363636h
					; DATA XREF: _ssl3_cbc_digest_record+341r
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 133Ch
; COMDAT (pick any)
		public __xmm@6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a
__xmm@6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a6a xmmword 6A6A6A6A6A6A6A6A6A6A6A6A6A6A6A6Ah
					; DATA XREF: _ssl3_cbc_digest_record+8BEr
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _OpenSSLDie:near	; CODE XREF: _ssl3_cbc_copy_mac+5Ep
					; _ssl3_cbc_copy_mac+7Ap ...
		extrn _CRYPTO_memcmp:near ; CODE XREF: _tls1_cbc_remove_padding+7Ep
		extrn _EVP_MD_type:near	; CODE XREF: _ssl3_cbc_digest_record+91p
					; _ssl3_cbc_record_digest_supported+Ap
		extrn _EVP_MD_CTX_md:near ; CODE XREF: _ssl3_cbc_digest_record+8Bp
					; _ssl3_cbc_record_digest_supported+4p
		extrn _EVP_CIPHER_flags:near ; CODE XREF: _tls1_cbc_remove_padding+AAp
		extrn _EVP_MD_CTX_init:near ; CODE XREF: _ssl3_cbc_digest_record+7F0p
		extrn _EVP_MD_CTX_cleanup:near ; CODE XREF: _ssl3_cbc_digest_record+894p
					; _ssl3_cbc_digest_record+98Ap
		extrn _EVP_DigestInit_ex:near ;	CODE XREF: _ssl3_cbc_digest_record+805p
		extrn _EVP_DigestUpdate:near ; CODE XREF: _ssl3_cbc_digest_record+842p
					; _ssl3_cbc_digest_record+85Fp	...
		extrn _EVP_DigestFinal:near ; CODE XREF: _ssl3_cbc_digest_record+966p
		extrn _SHA1_Init:near	; CODE XREF: _ssl3_cbc_digest_record+C0p
		extrn _SHA1_Transform:near ; DATA XREF:	_ssl3_cbc_digest_record+DDo
		extrn _SHA224_Init:near	; CODE XREF: _ssl3_cbc_digest_record+1B5p
		extrn _SHA256_Init:near	; CODE XREF: _ssl3_cbc_digest_record+132p
		extrn _SHA256_Transform:near ; DATA XREF: _ssl3_cbc_digest_record+14Fo
					; _ssl3_cbc_digest_record+1D2o
		extrn _SHA384_Init:near	; CODE XREF: _ssl3_cbc_digest_record+200p
		extrn _SHA512_Init:near	; CODE XREF: _ssl3_cbc_digest_record+1E4p
		extrn _SHA512_Transform:near ; DATA XREF: _ssl3_cbc_digest_record+222o
		extrn _MD5_Init:near	; CODE XREF: _ssl3_cbc_digest_record+F2p
		extrn _MD5_Transform:near ; DATA XREF: _ssl3_cbc_digest_record+10Fo
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _ssl3_cbc_copy_mac+1E7p
					; _ssl3_cbc_digest_record+1A4p	...
		extrn __chkstk:near	; CODE XREF: _ssl3_cbc_copy_mac+5p
					; _ssl3_cbc_digest_record+Bp ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _ssl3_cbc_digest_record+32Ep
					; _ssl3_cbc_digest_record+49Fp	...
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _ssl3_cbc_copy_mac+C5p
					; _ssl3_cbc_digest_record+2F7p	...
		extrn ___security_cookie:near ;	DATA XREF: _ssl3_cbc_copy_mac+Ar
					; _ssl3_cbc_digest_record+10r


		end
