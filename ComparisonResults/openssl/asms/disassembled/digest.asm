;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	F73E44BAD9DEE8866F8AED49F8316E65
; Input	CRC32 :	5BC0F79A

; File Name   :	C:\compspace\Diff\openssl\obj\digest.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_Digest
_EVP_Digest	proc near

var_18		= xmmword ptr -18h
var_8		= qword	ptr -8
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	eax, 18h
		call	__chkstk
		push	esi
		xorps	xmm0, xmm0
		lea	eax, [esp+1Ch+var_18]
		push	1
		push	eax
		movups	[esp+24h+var_18], xmm0
		movq	[esp+24h+var_8], xmm0
		call	_EVP_MD_CTX_set_flags
		push	[esp+24h+arg_14]
		lea	eax, [esp+28h+var_18]
		push	[esp+28h+arg_10]
		push	eax
		call	_EVP_DigestInit_ex
		add	esp, 14h
		test	eax, eax
		jz	short loc_88
		push	[esp+1Ch+arg_4]
		lea	eax, [esp+20h+var_18]
		push	[esp+20h+arg_0]
		push	eax
		call	dword ptr [esp+28h+var_8+4]
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_88
		push	[esp+1Ch+arg_C]
		lea	eax, [esp+20h+var_18]
		push	[esp+20h+arg_8]
		push	eax
		call	_EVP_DigestFinal_ex
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_88
		lea	eax, [esp+1Ch+var_18]
		mov	esi, 1
		push	eax
		call	_EVP_MD_CTX_cleanup
		add	esp, 4
		mov	eax, esi
		pop	esi
		add	esp, 18h
		retn
; ---------------------------------------------------------------------------

loc_88:					; CODE XREF: _EVP_Digest+3Cj
					; _EVP_Digest+54j ...
		lea	eax, [esp+1Ch+var_18]
		xor	esi, esi
		push	eax
		call	_EVP_MD_CTX_cleanup
		add	esp, 4
		mov	eax, esi
		pop	esi
		add	esp, 18h
		retn
_EVP_Digest	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_DigestFinal
_EVP_DigestFinal proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		push	[esp+4+arg_8]
		push	[esp+8+arg_4]
		push	[esp+0Ch+arg_0]
		call	_EVP_DigestFinal_ex
		push	[esp+10h+arg_0]
		mov	esi, eax
		call	_EVP_MD_CTX_cleanup
		add	esp, 10h
		mov	eax, esi
		pop	esi
		retn
_EVP_DigestFinal endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_DigestFinal_ex
_EVP_DigestFinal_ex proc near		; CODE XREF: _EVP_Digest+63p
					; _EVP_DigestFinal+Dp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		mov	eax, [esi]
		cmp	dword ptr [eax+8], 40h ; '@'
		jle	short loc_E9
		push	offset ??_C@_0CI@KPJFNDOF@ctx?9?$DOdigest?9?$DOmd_size?5?$DM?$DN?5EVP_MAX_@ ; "ctx->digest->md_size <= EVP_MAX_MD_SIZE"
		push	117h
		push	offset ??_C@_0BG@COGMIJJG@?4?2crypto?2evp?2digest?4c?$AA@ ; ".\\crypto\\evp\\digest.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_E9:					; CODE XREF: _EVP_DigestFinal_ex+Cj
		mov	eax, [esi]
		push	[esp+8+arg_4]
		push	esi
		mov	eax, [eax+18h]
		call	eax
		mov	edx, [esp+10h+arg_8]
		add	esp, 8
		mov	edi, eax
		test	edx, edx
		jz	short loc_109
		mov	ecx, [esi]
		mov	ecx, [ecx+8]
		mov	[edx], ecx

loc_109:				; CODE XREF: _EVP_DigestFinal_ex+3Cj
		mov	eax, [esi]
		mov	eax, [eax+20h]
		test	eax, eax
		jz	short loc_120
		push	esi
		call	eax
		push	2
		push	esi
		call	_EVP_MD_CTX_set_flags
		add	esp, 0Ch

loc_120:				; CODE XREF: _EVP_DigestFinal_ex+4Cj
		mov	eax, [esi]
		push	dword ptr [eax+44h] ; Size
		push	0		; Val
		push	dword ptr [esi+0Ch] ; Dst
		call	_memset
		add	esp, 0Ch
		mov	eax, edi
		pop	edi
		pop	esi
		retn
_EVP_DigestFinal_ex endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 138h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_DigestInit
_EVP_DigestInit	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		xorps	xmm0, xmm0
		push	0
		push	[esp+4+arg_4]
		movups	xmmword	ptr [eax], xmm0
		push	eax
		movq	qword ptr [eax+10h], xmm0
		call	_EVP_DigestInit_ex
		add	esp, 0Ch
		retn
_EVP_DigestInit	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 158h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_DigestInit_ex
_EVP_DigestInit_ex proc	near		; CODE XREF: _EVP_Digest+32p
					; _EVP_DigestInit+16p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		push	esi
		mov	esi, [esp+8+arg_0]
		push	edi
		push	2
		push	esi
		call	_EVP_MD_CTX_clear_flags
		mov	ecx, [esi+4]
		add	esp, 8
		mov	edi, [esp+0Ch+arg_4]
		test	ecx, ecx
		jz	short loc_18D
		mov	edx, [esi]
		test	edx, edx
		jz	short loc_18D
		test	edi, edi
		jz	$skip_to_init$25
		mov	eax, [edi]
		cmp	eax, [edx]
		jz	$skip_to_init$25

loc_18D:				; CODE XREF: _EVP_DigestInit_ex+1Bj
					; _EVP_DigestInit_ex+21j
		test	edi, edi
		jz	loc_2A0
		test	ecx, ecx
		jz	short loc_1A2
		push	ecx
		call	_ENGINE_finish
		add	esp, 4

loc_1A2:				; CODE XREF: _EVP_DigestInit_ex+3Fj
		mov	ebx, [esp+0Ch+arg_8]
		test	ebx, ebx
		jz	short loc_1DB
		push	ebx
		call	_ENGINE_init
		add	esp, 4
		test	eax, eax
		jnz	short loc_1E7
		push	0B6h ; '¶'
		push	offset ??_C@_0BG@COGMIJJG@?4?2crypto?2evp?2digest?4c?$AA@ ; ".\\crypto\\evp\\digest.c"
		push	86h ; '†'

loc_1C6:				; CODE XREF: _EVP_DigestInit_ex+13Aj
					; _EVP_DigestInit_ex+15Dj
		push	80h ; '€'
		push	6
		call	_ERR_put_error
		add	esp, 14h

loc_1D5:				; CODE XREF: _EVP_DigestInit_ex+185j
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1DB:				; CODE XREF: _EVP_DigestInit_ex+50j
		push	dword ptr [edi]
		call	_ENGINE_get_digest_engine
		add	esp, 4
		mov	ebx, eax

loc_1E7:				; CODE XREF: _EVP_DigestInit_ex+5Dj
		test	ebx, ebx
		jz	loc_297
		push	dword ptr [edi]
		push	ebx
		call	_ENGINE_get_digest
		mov	edi, eax
		add	esp, 8
		test	edi, edi
		jnz	short loc_22A
		push	0C1h ; 'Á'
		push	offset ??_C@_0BG@COGMIJJG@?4?2crypto?2evp?2digest?4c?$AA@ ; ".\\crypto\\evp\\digest.c"
		push	86h ; '†'
		push	80h ; '€'
		push	6
		call	_ERR_put_error
		push	ebx
		call	_ENGINE_finish
		add	esp, 18h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_22A:				; CODE XREF: _EVP_DigestInit_ex+A6j
		mov	[esi+4], ebx

loc_22D:				; CODE XREF: _EVP_DigestInit_ex+146j
					; _EVP_DigestInit_ex+14Cj
		mov	eax, [esi]
		cmp	eax, edi
		jz	$skip_to_init$25
		test	eax, eax
		jz	short loc_253
		cmp	dword ptr [eax+44h], 0
		jz	short loc_253
		push	dword ptr [esi+0Ch]
		call	_CRYPTO_free
		add	esp, 4
		mov	dword ptr [esi+0Ch], 0

loc_253:				; CODE XREF: _EVP_DigestInit_ex+E1j
					; _EVP_DigestInit_ex+E7j
		test	dword ptr [esi+8], 100h
		mov	[esi], edi
		jnz	short $skip_to_init$25
		cmp	dword ptr [edi+44h], 0
		jz	short $skip_to_init$25
		mov	eax, [edi+14h]
		push	0DEh ; 'Þ'
		mov	[esi+14h], eax
		push	offset ??_C@_0BG@COGMIJJG@?4?2crypto?2evp?2digest?4c?$AA@ ; ".\\crypto\\evp\\digest.c"
		push	dword ptr [edi+44h]
		call	_CRYPTO_malloc
		add	esp, 0Ch
		mov	[esi+0Ch], eax
		test	eax, eax
		jnz	short $skip_to_init$25
		push	0E0h ; 'à'
		push	offset ??_C@_0BG@COGMIJJG@?4?2crypto?2evp?2digest?4c?$AA@ ; ".\\crypto\\evp\\digest.c"
		push	41h ; 'A'
		jmp	loc_1C6
; ---------------------------------------------------------------------------

loc_297:				; CODE XREF: _EVP_DigestInit_ex+91j
		mov	dword ptr [esi+4], 0
		jmp	short loc_22D
; ---------------------------------------------------------------------------

loc_2A0:				; CODE XREF: _EVP_DigestInit_ex+37j
		mov	edi, [esi]
		test	edi, edi
		jnz	short loc_22D
		push	0D0h ; 'Ð'
		push	offset ??_C@_0BG@COGMIJJG@?4?2crypto?2evp?2digest?4c?$AA@ ; ".\\crypto\\evp\\digest.c"
		push	8Bh ; '‹'
		jmp	loc_1C6
; ---------------------------------------------------------------------------

$skip_to_init$25:			; CODE XREF: _EVP_DigestInit_ex+25j
					; _EVP_DigestInit_ex+2Fj ...
		mov	eax, [esi+10h]
		test	eax, eax
		jz	short loc_2E3
		push	esi
		push	0
		push	7
		push	0F8h ; 'ø'
		push	0FFFFFFFFh
		push	eax
		call	_EVP_PKEY_CTX_ctrl
		add	esp, 18h
		test	eax, eax
		jg	short loc_2E3
		cmp	eax, 0FFFFFFFEh
		jnz	loc_1D5

loc_2E3:				; CODE XREF: _EVP_DigestInit_ex+167j
					; _EVP_DigestInit_ex+180j
		test	dword ptr [esi+8], 100h
		jz	short loc_2F5
		pop	edi
		pop	esi
		mov	eax, 1
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_2F5:				; CODE XREF: _EVP_DigestInit_ex+192j
		mov	eax, [esi]
		push	esi
		mov	eax, [eax+10h]
		call	eax
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		retn
_EVP_DigestInit_ex endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 304h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_DigestUpdate
_EVP_DigestUpdate proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	[esp+arg_0], eax
		mov	eax, [eax+14h]
		jmp	eax
_EVP_DigestUpdate endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 314h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_MD_CTX_cleanup
_EVP_MD_CTX_cleanup proc near		; CODE XREF: _EVP_Digest+79p
					; _EVP_Digest+8Fp ...

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, [esi]
		test	eax, eax
		jz	short loc_378
		cmp	dword ptr [eax+20h], 0
		jz	short loc_33F
		push	2
		push	esi
		call	_EVP_MD_CTX_test_flags
		add	esp, 8
		test	eax, eax
		jnz	short loc_33F
		mov	eax, [esi]
		push	esi
		mov	eax, [eax+20h]
		call	eax
		add	esp, 4

loc_33F:				; CODE XREF: _EVP_MD_CTX_cleanup+Fj
					; _EVP_MD_CTX_cleanup+1Ej
		mov	eax, [esi]
		test	eax, eax
		jz	short loc_378
		cmp	dword ptr [eax+44h], 0
		jz	short loc_378
		cmp	dword ptr [esi+0Ch], 0
		jz	short loc_378
		push	4
		push	esi
		call	_EVP_MD_CTX_test_flags
		add	esp, 8
		test	eax, eax
		jnz	short loc_378
		mov	eax, [esi]
		push	dword ptr [eax+44h]
		push	dword ptr [esi+0Ch]
		call	_OPENSSL_cleanse
		push	dword ptr [esi+0Ch]
		call	_CRYPTO_free
		add	esp, 0Ch

loc_378:				; CODE XREF: _EVP_MD_CTX_cleanup+9j
					; _EVP_MD_CTX_cleanup+2Fj ...
		mov	eax, [esi+10h]
		test	eax, eax
		jz	short loc_388
		push	eax
		call	_EVP_PKEY_CTX_free
		add	esp, 4

loc_388:				; CODE XREF: _EVP_MD_CTX_cleanup+69j
		mov	eax, [esi+4]
		test	eax, eax
		jz	short loc_398
		push	eax
		call	_ENGINE_finish
		add	esp, 4

loc_398:				; CODE XREF: _EVP_MD_CTX_cleanup+79j
		xorps	xmm0, xmm0
		mov	eax, 1
		movups	xmmword	ptr [esi], xmm0
		movq	qword ptr [esi+10h], xmm0
		pop	esi
		retn
_EVP_MD_CTX_cleanup endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3ACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_MD_CTX_copy
_EVP_MD_CTX_copy proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		xorps	xmm0, xmm0
		movups	xmmword	ptr [eax], xmm0
		movq	qword ptr [eax+10h], xmm0
		mov	[esp+arg_0], eax
		jmp	$+5
_EVP_MD_CTX_copy endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3C4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_MD_CTX_copy_ex
_EVP_MD_CTX_copy_ex proc near		; CODE XREF: _EVP_MD_CTX_copy+13j

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	edi
		mov	edi, [esp+4+arg_4]
		test	edi, edi
		jz	loc_4EB
		cmp	dword ptr [edi], 0
		jz	loc_4EB
		mov	eax, [edi+4]
		test	eax, eax
		jz	short loc_40A
		push	eax
		call	_ENGINE_init
		add	esp, 4
		test	eax, eax
		jnz	short loc_40A
		push	134h
		push	offset ??_C@_0BG@COGMIJJG@?4?2crypto?2evp?2digest?4c?$AA@ ; ".\\crypto\\evp\\digest.c"
		push	26h ; '&'
		push	6Eh ; 'n'
		push	6
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_40A:				; CODE XREF: _EVP_MD_CTX_copy_ex+1Bj
					; _EVP_MD_CTX_copy_ex+28j
		push	ebx
		push	esi
		mov	esi, [esp+0Ch+arg_0]
		mov	eax, [esi]
		cmp	eax, [edi]
		jnz	short loc_426
		mov	ebx, [esi+0Ch]
		push	4
		push	esi
		call	_EVP_MD_CTX_set_flags
		add	esp, 8
		jmp	short loc_428
; ---------------------------------------------------------------------------

loc_426:				; CODE XREF: _EVP_MD_CTX_copy_ex+50j
		xor	ebx, ebx

loc_428:				; CODE XREF: _EVP_MD_CTX_copy_ex+60j
		push	esi
		call	_EVP_MD_CTX_cleanup
		movups	xmm0, xmmword ptr [edi]
		add	esp, 4
		movups	xmmword	ptr [esi], xmm0
		movq	xmm0, qword ptr	[edi+10h]
		movq	qword ptr [esi+10h], xmm0
		cmp	dword ptr [edi+0Ch], 0
		jz	short loc_46A
		mov	eax, [esi]
		mov	eax, [eax+44h]
		test	eax, eax
		jz	short loc_46A
		test	ebx, ebx
		jz	short loc_496
		mov	[esi+0Ch], ebx

loc_457:				; CODE XREF: _EVP_MD_CTX_copy_ex+EAj
		mov	eax, [esi]
		push	dword ptr [eax+44h] ; Size
		push	dword ptr [edi+0Ch] ; Src
		push	dword ptr [esi+0Ch] ; Dst
		call	_memcpy
		add	esp, 0Ch

loc_46A:				; CODE XREF: _EVP_MD_CTX_copy_ex+81j
					; _EVP_MD_CTX_copy_ex+8Aj
		mov	eax, [edi+14h]
		mov	[esi+14h], eax
		mov	eax, [edi+10h]
		test	eax, eax
		jz	short loc_4CE
		push	eax
		call	_EVP_PKEY_CTX_dup
		add	esp, 4
		mov	[esi+10h], eax
		test	eax, eax
		jnz	short loc_4CE
		push	esi
		call	_EVP_MD_CTX_cleanup
		add	esp, 4
		xor	eax, eax
		pop	esi
		pop	ebx
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_496:				; CODE XREF: _EVP_MD_CTX_copy_ex+8Ej
		push	145h
		push	offset ??_C@_0BG@COGMIJJG@?4?2crypto?2evp?2digest?4c?$AA@ ; ".\\crypto\\evp\\digest.c"
		push	eax
		call	_CRYPTO_malloc
		add	esp, 0Ch
		mov	[esi+0Ch], eax
		test	eax, eax
		jnz	short loc_457
		push	147h
		push	offset ??_C@_0BG@COGMIJJG@?4?2crypto?2evp?2digest?4c?$AA@ ; ".\\crypto\\evp\\digest.c"
		push	41h ; 'A'
		push	6Eh ; 'n'
		push	6
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		pop	ebx
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_4CE:				; CODE XREF: _EVP_MD_CTX_copy_ex+B1j
					; _EVP_MD_CTX_copy_ex+C1j
		mov	eax, [esi]
		mov	eax, [eax+1Ch]
		test	eax, eax
		jz	short loc_4E2
		push	edi
		push	esi
		call	eax
		add	esp, 8
		pop	esi
		pop	ebx
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_4E2:				; CODE XREF: _EVP_MD_CTX_copy_ex+111j
		pop	esi
		pop	ebx
		mov	eax, 1
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_4EB:				; CODE XREF: _EVP_MD_CTX_copy_ex+7j
					; _EVP_MD_CTX_copy_ex+10j
		push	12Eh
		push	offset ??_C@_0BG@COGMIJJG@?4?2crypto?2evp?2digest?4c?$AA@ ; ".\\crypto\\evp\\digest.c"
		push	6Fh ; 'o'
		push	6Eh ; 'n'
		push	6
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		retn
_EVP_MD_CTX_copy_ex endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 508h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_MD_CTX_create
_EVP_MD_CTX_create proc	near
		push	84h ; '„'
		push	offset ??_C@_0BG@COGMIJJG@?4?2crypto?2evp?2digest?4c?$AA@ ; ".\\crypto\\evp\\digest.c"
		push	18h
		call	_CRYPTO_malloc
		add	esp, 0Ch
		test	eax, eax
		jz	short locret_52B
		xorps	xmm0, xmm0
		movups	xmmword	ptr [eax], xmm0
		movq	qword ptr [eax+10h], xmm0

locret_52B:				; CODE XREF: _EVP_MD_CTX_create+16j
		retn
_EVP_MD_CTX_create endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 52Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_MD_CTX_destroy
_EVP_MD_CTX_destroy proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	short loc_544
		push	esi
		call	_EVP_MD_CTX_cleanup
		push	esi
		call	_CRYPTO_free
		add	esp, 8

loc_544:				; CODE XREF: _EVP_MD_CTX_destroy+7j
		pop	esi
		retn
_EVP_MD_CTX_destroy endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 548h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_MD_CTX_init
_EVP_MD_CTX_init proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		xorps	xmm0, xmm0
		movups	xmmword	ptr [eax], xmm0
		movq	qword ptr [eax+10h], xmm0
		retn
_EVP_MD_CTX_init endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 558h
; COMDAT (pick any)
		public ??_C@_0BG@COGMIJJG@?4?2crypto?2evp?2digest?4c?$AA@
; `string'
??_C@_0BG@COGMIJJG@?4?2crypto?2evp?2digest?4c?$AA@ db '.\crypto\evp\digest.c',0
					; DATA XREF: _EVP_DigestFinal_ex+18o
					; _EVP_DigestInit_ex+64o ...
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 570h
; COMDAT (pick any)
		public ??_C@_0CI@KPJFNDOF@ctx?9?$DOdigest?9?$DOmd_size?5?$DM?$DN?5EVP_MAX_@
; `string'
??_C@_0CI@KPJFNDOF@ctx?9?$DOdigest?9?$DOmd_size?5?$DM?$DN?5EVP_MAX_@ db	'ctx->digest->md_size <= EVP_MAX_MD_SIZE',0
					; DATA XREF: _EVP_DigestFinal_ex+Eo
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _CRYPTO_malloc:near ; CODE XREF: _EVP_DigestInit_ex+11Fp
					; _EVP_MD_CTX_copy_ex+DDp ...
		extrn _CRYPTO_free:near	; CODE XREF: _EVP_DigestInit_ex+ECp
					; _EVP_MD_CTX_cleanup+5Cp ...
		extrn _OPENSSL_cleanse:near ; CODE XREF: _EVP_MD_CTX_cleanup+54p
		extrn _OpenSSLDie:near	; CODE XREF: _EVP_DigestFinal_ex+1Dp
		extrn _ERR_put_error:near ; CODE XREF: _EVP_DigestInit_ex+75p
					; _EVP_DigestInit_ex+BEp ...
		extrn _EVP_MD_CTX_set_flags:near ; CODE	XREF: _EVP_Digest+20p
					; _EVP_DigestFinal_ex+54p ...
		extrn _EVP_MD_CTX_clear_flags:near ; CODE XREF:	_EVP_DigestInit_ex+Ap
		extrn _EVP_MD_CTX_test_flags:near ; CODE XREF: _EVP_MD_CTX_cleanup+14p
					; _EVP_MD_CTX_cleanup+40p
		extrn _EVP_PKEY_CTX_dup:near ; CODE XREF: _EVP_MD_CTX_copy_ex+B4p
		extrn _EVP_PKEY_CTX_free:near ;	CODE XREF: _EVP_MD_CTX_cleanup+6Cp
		extrn _EVP_PKEY_CTX_ctrl:near ;	CODE XREF: _EVP_DigestInit_ex+176p
		extrn _ENGINE_get_digest:near ;	CODE XREF: _EVP_DigestInit_ex+9Ap
		extrn _ENGINE_init:near	; CODE XREF: _EVP_DigestInit_ex+53p
					; _EVP_MD_CTX_copy_ex+1Ep
		extrn _ENGINE_finish:near ; CODE XREF: _EVP_DigestInit_ex+42p
					; _EVP_DigestInit_ex+C4p ...
		extrn _ENGINE_get_digest_engine:near ; CODE XREF: _EVP_DigestInit_ex+85p
		extrn __chkstk:near	; CODE XREF: _EVP_Digest+5p
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _EVP_MD_CTX_copy_ex+9Ep
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _EVP_DigestFinal_ex+66p


		end
