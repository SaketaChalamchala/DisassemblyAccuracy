;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	9D545A95AD87C8CDE003EC8FD03E64CD
; Input	CRC32 :	69A72445

; File Name   :	C:\compspace\Diff\openssl\obj\bio_ok.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl ok_write(int, void *Src, int)
_ok_write	proc near		; DATA XREF: .data:0000058Co

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
Src		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 4
		call	__chkstk
		push	ebx
		mov	ebx, [esp+8+arg_8]
		test	ebx, ebx
		jg	short loc_18
		mov	eax, ebx
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_18:					; CODE XREF: _ok_write+11j
		push	ebp
		mov	ebp, [esp+0Ch+arg_0]
		push	esi
		mov	[esp+10h+var_4], ebx
		mov	esi, [ebp+20h]
		test	esi, esi
		jz	loc_16F
		cmp	dword ptr [ebp+24h], 0
		jz	loc_16F
		cmp	dword ptr [ebp+0Ch], 0
		jz	loc_16F
		cmp	dword ptr [esi+34h], 0
		jz	short loc_58
		push	ebp
		call	_sig_out
		add	esp, 4
		test	eax, eax
		jz	loc_16F

loc_58:					; CODE XREF: _ok_write+45j
		push	edi
		nop	dword ptr [eax+00000000h]

loc_60:					; CODE XREF: _ok_write+11Bj
		push	0Fh
		push	ebp
		call	_BIO_clear_flags
		mov	edi, [esi]
		add	esp, 8
		sub	edi, [esi+4]
		cmp	dword ptr [esi+30h], 0
		jz	short loc_A8

loc_76:					; CODE XREF: _ok_write+A2j
		test	edi, edi
		jle	short loc_A4
		mov	eax, [esi+4]
		add	eax, 38h ; '8'
		push	edi
		add	eax, esi
		push	eax
		push	dword ptr [ebp+24h]
		call	_BIO_write
		mov	ebx, eax
		add	esp, 0Ch
		test	ebx, ebx
		jle	loc_13C
		add	[esi+4], ebx
		sub	edi, ebx
		cmp	dword ptr [esi+30h], 0
		jnz	short loc_76

loc_A4:					; CODE XREF: _ok_write+78j
		mov	ebx, [esp+14h+arg_8]

loc_A8:					; CODE XREF: _ok_write+74j
		mov	eax, [esi]
		mov	dword ptr [esi+30h], 0
		cmp	eax, [esi+4]
		jnz	short loc_C3
		mov	dword ptr [esi], 4
		mov	dword ptr [esi+4], 0

loc_C3:					; CODE XREF: _ok_write+B4j
		cmp	[esp+14h+Src], 0
		jz	loc_167
		mov	eax, [esi]
		mov	edx, 1004h
		sub	edx, eax
		mov	edi, ebx
		lea	ecx, [eax+ebx]
		cmp	ecx, 1004h
		cmova	edi, edx
		add	eax, 38h ; '8'
		push	edi		; Size
		push	[esp+18h+Src]	; Src
		add	eax, esi
		push	eax		; Dst
		call	_memcpy
		add	[esi], edi
		sub	ebx, edi
		add	[esp+20h+Src], edi
		add	esp, 0Ch
		cmp	dword ptr [esi], 1004h
		mov	[esp+14h+arg_8], ebx
		jb	short loc_119
		push	ebp
		call	_block_out
		add	esp, 4
		test	eax, eax
		jz	short loc_15C

loc_119:				; CODE XREF: _ok_write+10Aj
		test	ebx, ebx
		jg	loc_60
		push	0Fh
		push	ebp
		call	_BIO_clear_flags
		push	ebp
		call	_BIO_copy_next_retry
		mov	eax, [esp+20h+var_4]
		add	esp, 0Ch
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_13C:				; CODE XREF: _ok_write+93j
		push	ebp
		call	_BIO_copy_next_retry
		push	8
		push	ebp
		call	_BIO_test_flags
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_154
		mov	[esi+10h], eax

loc_154:				; CODE XREF: _ok_write+14Fj
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, ebx
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_15C:				; CODE XREF: _ok_write+117j
		push	0Fh
		push	ebp
		call	_BIO_clear_flags
		add	esp, 8

loc_167:				; CODE XREF: _ok_write+C8j
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_16F:				; CODE XREF: _ok_write+27j
					; _ok_write+31j ...
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		pop	ecx
		retn
_ok_write	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 178h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl ok_read(int, void	*Dst, size_t Size)
_ok_read	proc near		; DATA XREF: .data:00000590o

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
Dst		= dword	ptr  8
Size		= dword	ptr  0Ch

		mov	eax, 4
		call	__chkstk
		mov	ecx, [esp+4+Dst]
		push	edi
		xor	edi, edi
		mov	[esp+8+var_4], edi
		test	ecx, ecx
		jnz	short loc_196
		xor	eax, eax
		pop	edi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_196:				; CODE XREF: _ok_read+17j
		push	ebx
		mov	ebx, [esp+0Ch+arg_0]
		push	esi
		mov	esi, [ebx+20h]
		test	esi, esi
		jz	loc_2C1
		cmp	[ebx+24h], edi
		jz	loc_2C1
		cmp	[ebx+0Ch], edi
		jz	loc_2C1
		push	ebp
		mov	ebp, [esp+14h+Size]
		test	ebp, ebp
		jle	loc_2A8
		xchg	ax, ax

loc_1C8:				; CODE XREF: _ok_read+114j
		cmp	dword ptr [esi+30h], 0
		jz	short loc_235
		mov	edi, [esi]
		sub	edi, [esi+4]
		mov	eax, [esi+4]
		cmp	edi, ebp
		cmovg	edi, ebp
		add	eax, 38h ; '8'
		push	edi		; Size
		add	eax, esi
		push	eax		; Src
		push	ecx		; Dst
		call	_memcpy
		add	[esi+4], edi
		add	esp, 0Ch
		add	[esp+14h+var_4], edi
		sub	ebp, edi
		add	[esp+14h+Dst], edi
		mov	eax, [esi+4]
		cmp	[esi], eax
		jnz	short loc_235
		mov	eax, [esi+8]
		mov	ecx, [esi+0Ch]

loc_205:				; DATA XREF: .data:_methods_oko
		mov	dword ptr [esi+4], 0
		sub	eax, ecx
		jz	short loc_228
		push	eax		; Size
		mov	[esi], eax
		lea	eax, [esi+38h]
		add	eax, ecx
		push	eax		; Src
		lea	eax, [esi+38h]
		push	eax		; Dst
		call	dword ptr ds:__imp__memmove
		add	esp, 0Ch
		jmp	short loc_22E
; ---------------------------------------------------------------------------

loc_228:				; CODE XREF: _ok_read+96j
		mov	dword ptr [esi], 0

loc_22E:				; CODE XREF: _ok_read+AEj
		mov	dword ptr [esi+30h], 0

loc_235:				; CODE XREF: _ok_read+54j _ok_read+85j
		test	ebp, ebp
		jz	short loc_2A4
		mov	eax, 10C4h
		sub	eax, [esi]
		push	eax
		lea	eax, [esi+38h]
		add	eax, [esi]
		push	eax
		push	dword ptr [ebx+24h]
		call	_BIO_read
		add	esp, 0Ch
		test	eax, eax
		jle	short loc_2A4
		add	[esi], eax
		cmp	dword ptr [esi+34h], 1
		jnz	short loc_26B
		push	ebx
		call	_sig_in
		add	esp, 4
		test	eax, eax
		jz	short loc_291

loc_26B:				; CODE XREF: _ok_read+E4j
		cmp	dword ptr [esi+34h], 0
		jnz	short loc_27E
		push	ebx
		call	_block_in
		add	esp, 4
		test	eax, eax
		jz	short loc_291

loc_27E:				; CODE XREF: _ok_read+F7j
		cmp	dword ptr [esi+10h], 0
		jle	short loc_2A4
		test	ebp, ebp
		jle	short loc_2A4
		mov	ecx, [esp+14h+Dst]
		jmp	loc_1C8
; ---------------------------------------------------------------------------

loc_291:				; CODE XREF: _ok_read+F1j
					; _ok_read+104j
		push	0Fh
		push	ebx
		call	_BIO_clear_flags
		add	esp, 8
		xor	eax, eax
		pop	ebp
		pop	esi
		pop	ebx
		pop	edi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_2A4:				; CODE XREF: _ok_read+BFj _ok_read+DCj ...
		mov	edi, [esp+14h+var_4]

loc_2A8:				; CODE XREF: _ok_read+48j
		push	0Fh
		push	ebx
		call	_BIO_clear_flags
		push	ebx
		call	_BIO_copy_next_retry
		add	esp, 0Ch
		mov	eax, edi
		pop	ebp
		pop	esi
		pop	ebx
		pop	edi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_2C1:				; CODE XREF: _ok_read+29j _ok_read+32j ...
		pop	esi
		pop	ebx
		xor	eax, eax
		pop	edi
		pop	ecx
		retn
_ok_read	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2C8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ok_ctrl	proc near		; DATA XREF: .data:0000059Co

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	ebp
		mov	ebp, [esp+8+arg_4]
		push	esi
		mov	esi, [ebx+20h]
		push	edi
		lea	eax, [ebp-1]	; switch 112 cases
		mov	edi, 1
		cmp	eax, 6Fh ; 'o'
		ja	short $LN23	; jumptable 000002EB default case
		movzx	eax, ds:$LN68[eax]
		jmp	ds:$LN73[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN6:					; CODE XREF: _ok_ctrl+23j
					; DATA XREF: .text$mn:$LN73o
		mov	dword ptr [esi], 0 ; jumptable 000002EB	case 1
		mov	dword ptr [esi+4], 0
		mov	dword ptr [esi+8], 0
		mov	dword ptr [esi+0Ch], 0
		mov	[esi+10h], edi
		mov	dword ptr [esi+14h], 0
		mov	dword ptr [esi+30h], 0
		mov	[esi+34h], edi

$LN23:					; CODE XREF: _ok_ctrl+1Aj _ok_ctrl+23j ...
		push	[esp+10h+arg_C]	; jumptable 000002EB default case
		push	[esp+14h+arg_8]
		push	ebp
		push	dword ptr [ebx+24h]
		call	_BIO_ctrl
		add	esp, 10h
		mov	edi, eax

loc_337:				; CODE XREF: _ok_ctrl+7Aj _ok_ctrl+8Bj
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN7:					; CODE XREF: _ok_ctrl+23j
					; DATA XREF: .text$mn:$LN73o
		cmp	dword ptr [esi+10h], 0 ; jumptable 000002EB case 2
		jle	short loc_337
		jmp	short $LN23	; jumptable 000002EB default case
; ---------------------------------------------------------------------------

$LN10:					; CODE XREF: _ok_ctrl+23j
					; DATA XREF: .text$mn:$LN73o
		cmp	dword ptr [esi+30h], 0 ; jumptable 000002EB cases 10,13
		jz	short $LN23	; jumptable 000002EB default case
		mov	edi, [esi]
		sub	edi, [esi+4]
		test	edi, edi
		jg	short loc_337
		jmp	short $LN23	; jumptable 000002EB default case
; ---------------------------------------------------------------------------

$LN12:					; CODE XREF: _ok_ctrl+23j
					; DATA XREF: .text$mn:$LN73o
		cmp	dword ptr [esi+30h], 0 ; jumptable 000002EB case 11
		jnz	short loc_377
		push	ebx
		call	_block_out
		add	esp, 4
		test	eax, eax
		jnz	short loc_371

loc_36A:				; CODE XREF: _ok_ctrl+114j
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_371:				; CODE XREF: _ok_ctrl+A0j
		cmp	dword ptr [esi+30h], 0
		jz	short loc_37E

loc_377:				; CODE XREF: _ok_ctrl+93j
		mov	eax, [esi+30h]

loc_37A:				; CODE XREF: _ok_ctrl+B4j
		test	eax, eax
		jnz	short loc_37A

loc_37E:				; CODE XREF: _ok_ctrl+ADj
		mov	[esi+14h], edi
		mov	dword ptr [esi], 0
		mov	dword ptr [esi+4], 0
		mov	[esi+10h], edi
		jmp	short $LN23	; jumptable 000002EB default case
; ---------------------------------------------------------------------------

$LN16:					; CODE XREF: _ok_ctrl+23j
					; DATA XREF: .text$mn:$LN73o
		push	0Fh		; jumptable 000002EB case 101
		push	ebx
		call	_BIO_clear_flags
		push	[esp+18h+arg_C]
		push	[esp+1Ch+arg_8]
		push	ebp
		push	dword ptr [ebx+24h]
		call	_BIO_ctrl
		push	ebx
		mov	edi, eax
		call	_BIO_copy_next_retry
		add	esp, 1Ch
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN17:					; CODE XREF: _ok_ctrl+23j
					; DATA XREF: .text$mn:$LN73o
		mov	edi, [esi+10h]	; jumptable 000002EB case 3
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN18:					; CODE XREF: _ok_ctrl+23j
					; DATA XREF: .text$mn:$LN73o
		push	0		; jumptable 000002EB case 111
		push	[esp+14h+arg_C]
		lea	eax, [esi+18h]
		push	eax
		call	_EVP_DigestInit_ex
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_36A
		mov	[ebx+0Ch], edi
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN20:					; CODE XREF: _ok_ctrl+23j
					; DATA XREF: .text$mn:$LN73o
		cmp	dword ptr [ebx+0Ch], 0 ; jumptable 000002EB case 112
		jz	short loc_3FE
		mov	eax, [esp+10h+arg_C]
		mov	ecx, [esi+18h]
		mov	[eax], ecx
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_3FE:				; CODE XREF: _ok_ctrl+124j
		xor	edi, edi
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_ok_ctrl	endp

; ---------------------------------------------------------------------------
		align 4
$LN73		dd offset $LN6,	offset $LN7, offset $LN17, offset $LN10
					; DATA XREF: _ok_ctrl+23r
		dd offset $LN12, offset	$LN16, offset $LN18, offset $LN20 ; jump table for switch statement
		dd offset $LN23
$LN68		db	0,     1,     2,     8 ; DATA XREF: _ok_ctrl+1Cr
		db	8,     8,     8,     8 ; indirect table	for switch statement
		db	8,     3,     4,     8
		db	3,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	5,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     6,     7
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 49Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ok_new		proc near		; DATA XREF: .data:000005A0o

arg_0		= dword	ptr  4

		push	esi
		push	0B3h ; '³'
		push	offset ??_C@_0BG@GGBCKHPK@?4?2crypto?2evp?2bio_ok?4c?$AA@ ; ".\\crypto\\evp\\bio_ok.c"
		push	10FCh
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jnz	short loc_4BC
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_4BC:				; CODE XREF: _ok_new+1Cj
		lea	eax, [esi+18h]
		mov	dword ptr [esi], 0
		push	eax
		mov	dword ptr [esi+4], 0
		mov	dword ptr [esi+8], 0
		mov	dword ptr [esi+0Ch], 0
		mov	dword ptr [esi+10h], 1
		mov	dword ptr [esi+14h], 0
		mov	dword ptr [esi+30h], 0
		mov	dword ptr [esi+34h], 1
		call	_EVP_MD_CTX_init
		mov	eax, [esp+8+arg_0]
		add	esp, 4
		mov	[eax+20h], esi
		mov	dword ptr [eax+0Ch], 0
		mov	dword ptr [eax+14h], 0
		mov	eax, 1
		pop	esi
		retn
_ok_new		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 51Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ok_free	proc near		; DATA XREF: .data:000005A4o

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jnz	short loc_529
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_529:				; CODE XREF: _ok_free+7j
		mov	eax, [esi+20h]
		add	eax, 18h
		push	eax
		call	_EVP_MD_CTX_cleanup
		push	10FCh
		push	dword ptr [esi+20h]
		call	_OPENSSL_cleanse
		push	dword ptr [esi+20h]
		call	_CRYPTO_free
		add	esp, 10h
		mov	dword ptr [esi+20h], 0
		mov	dword ptr [esi+0Ch], 0
		mov	eax, 1
		mov	dword ptr [esi+14h], 0
		pop	esi
		retn
_ok_free	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 56Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ok_callback_ctrl proc near		; DATA XREF: .data:000005A8o

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+24h]
		test	eax, eax
		jnz	short loc_578
		retn
; ---------------------------------------------------------------------------

loc_578:				; CODE XREF: _ok_callback_ctrl+9j
		mov	[esp+arg_0], eax
		jmp	_BIO_callback_ctrl
_ok_callback_ctrl endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 584h
_methods_ok	dd offset loc_205+5	; DATA XREF: _BIO_f_reliableo
		dd offset ??_C@_08FAHPBKAN@reliable?$AA@ ; "reliable"
		dd offset _ok_write
		dd offset _ok_read
		dd 2 dup(0)
		dd offset _ok_ctrl
		dd offset _ok_new
		dd offset _ok_free
		dd offset _ok_callback_ctrl
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5ACh
; COMDAT (pick any)
		public ??_C@_08FAHPBKAN@reliable?$AA@
; `string'
??_C@_08FAHPBKAN@reliable?$AA@ db 'reliable',0 ; DATA XREF: .data:00000588o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5B8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_f_reliable
_BIO_f_reliable	proc near
		mov	eax, offset _methods_ok
		retn
_BIO_f_reliable	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5C0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_block_in	proc near		; CODE XREF: _ok_read+FAp

var_44		= byte ptr -44h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 44h ; 'D'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+44h+var_4], eax
		push	ebx
		push	ebp
		mov	ebp, [esp+4Ch+arg_0]
		push	esi
		push	edi
		mov	edi, [ebp+20h]
		lea	esi, [edi+18h]
		movzx	ebx, byte ptr [edi+38h]
		movzx	eax, byte ptr [edi+39h]
		shl	ebx, 8
		or	ebx, eax
		movzx	eax, byte ptr [edi+3Ah]
		shl	ebx, 8
		or	ebx, eax
		movzx	eax, byte ptr [edi+3Bh]
		shl	ebx, 8
		or	ebx, eax
		mov	eax, [esi]
		mov	eax, [eax+8]
		add	eax, 4
		add	eax, ebx
		cmp	[edi], eax
		jb	loc_6D9
		push	ebx
		lea	eax, [edi+3Ch]
		push	eax
		push	esi
		call	_EVP_DigestUpdate
		add	esp, 0Ch
		test	eax, eax
		jz	$berr$13
		push	0
		lea	eax, [esp+58h+var_44]
		push	eax
		push	esi
		call	_EVP_DigestFinal_ex
		add	esp, 0Ch
		test	eax, eax
		jz	$berr$13
		mov	eax, [esi]
		lea	ecx, [edi+3Ch]
		add	ecx, ebx
		lea	edx, [esp+54h+var_44]
		mov	ebp, [eax+8]
		mov	esi, ebp
		sub	esi, 4
		jb	short loc_668

loc_657:				; CODE XREF: _block_in+A6j
		mov	eax, [ecx]
		cmp	eax, [edx]
		jnz	short loc_66D
		add	ecx, 4
		add	edx, 4
		sub	esi, 4
		jnb	short loc_657

loc_668:				; CODE XREF: _block_in+95j
		cmp	esi, 0FFFFFFFCh
		jz	short loc_6B9

loc_66D:				; CODE XREF: _block_in+9Bj
		mov	al, [ecx]
		cmp	al, [edx]
		jnz	short loc_69A
		cmp	esi, 0FFFFFFFDh
		jz	short loc_6B9
		mov	al, [ecx+1]
		cmp	al, [edx+1]
		jnz	short loc_69A
		cmp	esi, 0FFFFFFFEh
		jz	short loc_6B9
		mov	al, [ecx+2]
		cmp	al, [edx+2]
		jnz	short loc_69A
		cmp	esi, 0FFFFFFFFh
		jz	short loc_6B9
		mov	al, [ecx+3]
		cmp	al, [edx+3]
		jz	short loc_6B9

loc_69A:				; CODE XREF: _block_in+B1j
					; _block_in+BEj ...
		mov	dword ptr [edi+10h], 0
		mov	eax, 1
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+44h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 44h
		retn
; ---------------------------------------------------------------------------

loc_6B9:				; CODE XREF: _block_in+ABj
					; _block_in+B6j ...
		lea	eax, [ebp+4]
		mov	dword ptr [edi+4], 4
		add	eax, ebx
		mov	dword ptr [edi+30h], 1
		mov	[edi+0Ch], eax
		mov	eax, [edi]
		mov	[edi+8], eax
		lea	eax, [ebx+4]
		mov	[edi], eax

loc_6D9:				; CODE XREF: _block_in+4Ej
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, 1
		pop	ebx
		mov	ecx, [esp+44h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 44h
		retn
; ---------------------------------------------------------------------------

$berr$13:				; CODE XREF: _block_in+64j
					; _block_in+7Cj
		push	0Fh
		push	ebp
		call	_BIO_clear_flags
		mov	ecx, [esp+5Ch+var_4]
		add	esp, 8
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 44h
		retn
_block_in	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 714h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_block_out	proc near		; CODE XREF: _ok_write+10Dp
					; _ok_ctrl+96p

arg_0		= dword	ptr  4

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	esi
		push	edi
		mov	esi, [ebx+20h]
		mov	ecx, [esi]
		lea	edi, [esi+18h]
		sub	ecx, 4
		mov	eax, ecx
		mov	[esi+3Bh], cl
		shr	eax, 18h
		mov	[esi+38h], al
		mov	eax, ecx
		shr	eax, 10h
		mov	[esi+39h], al
		mov	eax, ecx
		shr	eax, 8
		mov	[esi+3Ah], al
		lea	eax, [esi+3Ch]
		push	ecx
		push	eax
		push	edi
		call	_EVP_DigestUpdate
		add	esp, 0Ch
		test	eax, eax
		jz	short $berr$6
		mov	eax, [esi]
		add	eax, 38h ; '8'
		push	0
		add	eax, esi
		push	eax
		push	edi
		call	_EVP_DigestFinal_ex
		add	esp, 0Ch
		test	eax, eax
		jz	short $berr$6
		mov	eax, [edi]
		pop	edi
		mov	eax, [eax+8]
		add	[esi], eax
		mov	eax, 1
		mov	dword ptr [esi+30h], 1
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$berr$6:				; CODE XREF: _block_out+3Dj
					; _block_out+54j
		push	0Fh
		push	ebx
		call	_BIO_clear_flags
		add	esp, 8
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		retn
_block_out	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 794h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_longswap	proc near		; CODE XREF: _sig_in+69p _sig_out+6Dp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		test	edx, edx
		jz	short locret_7CF
		mov	eax, [esp+arg_0]
		dec	edx
		push	ebx
		shr	edx, 2
		inc	edx
		mov	bl, [eax+3]
		mov	ch, [eax+1]
		mov	bh, [eax+2]
		nop	dword ptr [eax+eax+00h]

loc_7B4:				; CODE XREF: _longswap+2Fj
		mov	cl, [eax]
		mov	[eax], bl
		mov	bl, cl
		mov	cl, ch
		mov	ch, bh
		mov	bh, cl
		sub	edx, 1
		jnz	short loc_7B4
		mov	[eax+3], bl
		mov	[eax+1], ch
		mov	[eax+2], cl
		pop	ebx

locret_7CF:				; CODE XREF: _longswap+6j
		retn
_longswap	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7D0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_sig_in		proc near		; CODE XREF: _ok_read+E7p

var_44		= byte ptr -44h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 44h ; 'D'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+44h+var_4], eax
		push	ebx
		mov	ebx, [esp+48h+arg_0]
		push	esi
		push	edi
		mov	esi, [ebx+20h]
		mov	edx, [esi+18h]
		lea	edi, [esi+18h]
		mov	ecx, [esi]
		mov	eax, [edx+8]
		sub	ecx, [esi+4]
		add	eax, eax
		cmp	ecx, eax
		jl	loc_933
		push	0
		push	edx
		push	edi
		call	_EVP_DigestInit_ex
		add	esp, 0Ch
		test	eax, eax
		jz	$berr$17
		mov	eax, [edi]
		push	dword ptr [eax+8] ; Size
		mov	eax, [esi+4]
		add	eax, 38h ; '8'
		add	eax, esi
		push	eax		; Src
		push	dword ptr [edi+0Ch] ; Dst
		call	_memcpy
		mov	eax, [edi]
		push	dword ptr [eax+8]
		push	dword ptr [edi+0Ch]
		call	_longswap
		mov	eax, [edi]
		push	34h ; '4'
		push	offset ??_C@_0DF@EEKJLJOP@The?5quick?5brown?5fox?5jumped?5over?5@ ; "The quick brown fox jumped	over the laz"...
		push	edi
		mov	eax, [eax+8]
		add	[esi+4], eax
		call	_EVP_DigestUpdate
		add	esp, 20h
		test	eax, eax
		jz	$berr$17
		push	0
		lea	eax, [esp+54h+var_44]
		push	eax
		push	edi
		call	_EVP_DigestFinal_ex
		add	esp, 0Ch
		test	eax, eax
		jz	$berr$17
		mov	eax, [edi]
		lea	ecx, [esi+38h]
		push	ebp
		mov	ebp, [esi+4]
		lea	edx, [esp+54h+var_44]
		add	ecx, ebp
		mov	ebx, [eax+8]
		mov	edi, ebx
		sub	edi, 4
		jb	short loc_8A1
		nop

loc_890:				; CODE XREF: _sig_in+CFj
		mov	eax, [ecx]
		cmp	eax, [edx]
		jnz	short loc_8A6
		add	ecx, 4
		add	edx, 4
		sub	edi, 4
		jnb	short loc_890

loc_8A1:				; CODE XREF: _sig_in+BDj
		cmp	edi, 0FFFFFFFCh
		jz	short loc_8DA

loc_8A6:				; CODE XREF: _sig_in+C4j
		mov	al, [ecx]
		cmp	al, [edx]
		jnz	short loc_8D3
		cmp	edi, 0FFFFFFFDh
		jz	short loc_8DA
		mov	al, [ecx+1]
		cmp	al, [edx+1]
		jnz	short loc_8D3
		cmp	edi, 0FFFFFFFEh
		jz	short loc_8DA
		mov	al, [ecx+2]
		cmp	al, [edx+2]
		jnz	short loc_8D3
		cmp	edi, 0FFFFFFFFh
		jz	short loc_8DA
		mov	al, [ecx+3]
		cmp	al, [edx+3]
		jz	short loc_8DA

loc_8D3:				; CODE XREF: _sig_in+DAj _sig_in+E7j ...
		sbb	ecx, ecx
		or	ecx, 1
		jmp	short loc_8DC
; ---------------------------------------------------------------------------

loc_8DA:				; CODE XREF: _sig_in+D4j _sig_in+DFj ...
		xor	ecx, ecx

loc_8DC:				; CODE XREF: _sig_in+108j
		lea	eax, [ebx+ebp]
		mov	[esi+4], eax
		pop	ebp
		test	ecx, ecx
		jnz	short loc_92C
		mov	eax, [esi]
		mov	[esi+34h], ecx
		mov	ecx, [esi+4]
		cmp	eax, ecx
		jz	short loc_909
		sub	eax, ecx
		push	eax		; Size
		lea	eax, [esi+38h]
		add	eax, ecx
		push	eax		; Src
		lea	eax, [esi+38h]
		push	eax		; Dst
		call	dword ptr ds:__imp__memmove
		add	esp, 0Ch

loc_909:				; CODE XREF: _sig_in+121j
		mov	eax, [esi+4]
		sub	[esi], eax
		mov	eax, 1
		pop	edi
		mov	dword ptr [esi+4], 0
		pop	esi
		pop	ebx
		mov	ecx, [esp+44h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 44h
		retn
; ---------------------------------------------------------------------------

loc_92C:				; CODE XREF: _sig_in+115j
		mov	dword ptr [esi+10h], 0

loc_933:				; CODE XREF: _sig_in+31j
		pop	edi
		pop	esi
		mov	eax, 1
		pop	ebx
		mov	ecx, [esp+44h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 44h
		retn
; ---------------------------------------------------------------------------

$berr$17:				; CODE XREF: _sig_in+45j _sig_in+88j ...
		push	0Fh
		push	ebx
		call	_BIO_clear_flags
		mov	ecx, [esp+58h+var_4]
		add	esp, 8
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 44h
		retn
_sig_in		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 96Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_sig_out	proc near		; CODE XREF: _ok_write+48p

arg_0		= dword	ptr  4

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	esi
		push	edi
		mov	esi, [ebx+20h]
		mov	edx, [esi+18h]
		lea	edi, [esi+18h]
		mov	eax, [esi]
		mov	ecx, [edx+8]
		lea	eax, [eax+ecx*2]
		cmp	eax, 1000h
		ja	loc_A25
		push	0
		push	edx
		push	edi
		call	_EVP_DigestInit_ex
		add	esp, 0Ch
		test	eax, eax
		jz	$berr$10
		mov	eax, [edi]
		push	dword ptr [eax+8]
		push	dword ptr [edi+0Ch]
		call	_RAND_pseudo_bytes
		add	esp, 8
		test	eax, eax
		js	short $berr$10
		mov	eax, [edi]
		push	dword ptr [eax+8] ; Size
		mov	eax, [esi]
		push	dword ptr [edi+0Ch] ; Src
		add	eax, 38h ; '8'
		add	eax, esi
		push	eax		; Dst
		call	_memcpy
		mov	eax, [edi]
		push	dword ptr [eax+8]
		mov	eax, [esi]
		add	eax, 38h ; '8'
		add	eax, esi
		push	eax
		call	_longswap
		mov	eax, [edi]
		push	34h ; '4'
		push	offset ??_C@_0DF@EEKJLJOP@The?5quick?5brown?5fox?5jumped?5over?5@ ; "The quick brown fox jumped	over the laz"...
		push	edi
		mov	eax, [eax+8]
		add	[esi], eax
		call	_EVP_DigestUpdate
		add	esp, 20h
		test	eax, eax
		jz	short $berr$10
		mov	eax, [esi]
		add	eax, 38h ; '8'
		push	0
		add	eax, esi
		push	eax
		push	edi
		call	_EVP_DigestFinal_ex
		add	esp, 0Ch
		test	eax, eax
		jz	short $berr$10
		mov	eax, [edi]
		mov	eax, [eax+8]
		add	[esi], eax
		mov	dword ptr [esi+30h], 1
		mov	dword ptr [esi+34h], 0

loc_A25:				; CODE XREF: _sig_out+1Dj
		pop	edi
		pop	esi
		mov	eax, 1
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$berr$10:				; CODE XREF: _sig_out+31j _sig_out+49j ...
		push	0Fh
		push	ebx
		call	_BIO_clear_flags
		add	esp, 8
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		retn
_sig_out	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A40h
; COMDAT (pick any)
		public ??_C@_0BG@GGBCKHPK@?4?2crypto?2evp?2bio_ok?4c?$AA@
; `string'
??_C@_0BG@GGBCKHPK@?4?2crypto?2evp?2bio_ok?4c?$AA@ db '.\crypto\evp\bio_ok.c',0
					; DATA XREF: _ok_new+6o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A58h
; COMDAT (pick any)
		public ??_C@_0DF@EEKJLJOP@The?5quick?5brown?5fox?5jumped?5over?5@
; `string'
??_C@_0DF@EEKJLJOP@The?5quick?5brown?5fox?5jumped?5over?5@ db 'The quick brown fox jumped over the lazy dog',27h,'s back.',0
					; DATA XREF: _sig_in+72o _sig_out+76o
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; void *__cdecl	_memmove(void *Dst, const void *Src, size_t Size)
		extrn __imp__memmove:near ; CODE XREF: _ok_read+A5p
					; _sig_in+130p
					; DATA XREF: ...
		extrn _CRYPTO_malloc:near ; CODE XREF: _ok_new+10p
		extrn _CRYPTO_free:near	; CODE XREF: _ok_free+29p
		extrn _OPENSSL_cleanse:near ; CODE XREF: _ok_free+21p
		extrn _BIO_test_flags:near ; CODE XREF:	_ok_write+145p
		extrn _BIO_clear_flags:near ; CODE XREF: _ok_write+63p
					; _ok_write+124p ...
		extrn _BIO_read:near	; CODE XREF: _ok_read+D2p
		extrn _BIO_write:near	; CODE XREF: _ok_write+87p
		extrn _BIO_ctrl:near	; CODE XREF: _ok_ctrl+65p _ok_ctrl+DFp
		extrn _BIO_callback_ctrl:near ;	CODE XREF: _ok_callback_ctrl+10j
		extrn _BIO_copy_next_retry:near	; CODE XREF: _ok_write+12Ap
					; _ok_write+13Dp ...
		extrn _EVP_MD_CTX_init:near ; CODE XREF: _ok_new+5Bp
		extrn _EVP_MD_CTX_cleanup:near ; CODE XREF: _ok_free+14p
		extrn _EVP_DigestInit_ex:near ;	CODE XREF: _ok_ctrl+10Ap
					; _sig_in+3Bp ...
		extrn _EVP_DigestUpdate:near ; CODE XREF: _block_in+5Ap
					; _block_out+33p ...
		extrn _EVP_DigestFinal_ex:near ; CODE XREF: _block_in+72p
					; _block_out+4Ap ...
		extrn _RAND_pseudo_bytes:near ;	CODE XREF: _sig_out+3Fp
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _block_in+F0p
					; _block_in+128p ...
		extrn __chkstk:near	; CODE XREF: _ok_write+5p _ok_read+5p	...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _ok_write+F0p
					; _ok_read+6Bp	...
		extrn ___security_cookie:near ;	DATA XREF: _block_in+Ar
					; _sig_in+Ar


		end
