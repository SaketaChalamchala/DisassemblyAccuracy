;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	6D0A63B5CA7E6B2AEB0E05063F31BEE1
; Input	CRC32 :	88A6B95F

; File Name   :	C:\compspace\Diff\openssl\obj\bn_mont.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_MONT_CTX_copy
_BN_MONT_CTX_copy proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		mov	edi, [esp+8+arg_4]
		cmp	esi, edi
		jz	short loc_5F
		lea	eax, [edi+4]
		push	eax
		lea	eax, [esi+4]
		push	eax
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jnz	short loc_27

loc_22:					; CODE XREF: _BN_MONT_CTX_copy+39j
					; _BN_MONT_CTX_copy+4Dj
		pop	edi
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_27:					; CODE XREF: _BN_MONT_CTX_copy+20j
		lea	eax, [edi+18h]
		push	eax
		lea	eax, [esi+18h]
		push	eax
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jz	short loc_22
		lea	eax, [edi+2Ch]
		push	eax
		lea	eax, [esi+2Ch]
		push	eax
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jz	short loc_22
		mov	eax, [edi]
		mov	[esi], eax
		mov	eax, [edi+40h]
		mov	[esi+40h], eax
		mov	eax, [edi+44h]
		mov	[esi+44h], eax

loc_5F:					; CODE XREF: _BN_MONT_CTX_copy+Cj
		pop	edi
		mov	eax, esi
		pop	esi
		retn
_BN_MONT_CTX_copy endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 64h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_MONT_CTX_free
_BN_MONT_CTX_free proc near		; CODE XREF: _BN_MONT_CTX_set_locked+59p
					; _BN_MONT_CTX_set_locked+82p

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	short loc_9A
		lea	eax, [esi+4]
		push	eax
		call	_BN_clear_free
		lea	eax, [esi+18h]
		push	eax
		call	_BN_clear_free
		lea	eax, [esi+2Ch]
		push	eax
		call	_BN_clear_free
		add	esp, 0Ch
		test	byte ptr [esi+48h], 1
		jz	short loc_9A
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_9A:					; CODE XREF: _BN_MONT_CTX_free+7j
					; _BN_MONT_CTX_free+2Bj
		pop	esi
		retn
_BN_MONT_CTX_free endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 9Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_MONT_CTX_init
_BN_MONT_CTX_init proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		lea	eax, [esi+4]
		mov	dword ptr [esi], 0
		push	eax
		call	_BN_init
		lea	eax, [esi+18h]
		push	eax
		call	_BN_init
		lea	eax, [esi+2Ch]
		push	eax
		call	_BN_init
		add	esp, 0Ch
		mov	dword ptr [esi+44h], 0
		mov	dword ptr [esi+40h], 0
		mov	dword ptr [esi+48h], 0
		pop	esi
		retn
_BN_MONT_CTX_init endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0DCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_MONT_CTX_new
_BN_MONT_CTX_new proc near		; CODE XREF: _BN_MONT_CTX_set_locked+38p
		push	esi
		push	155h
		push	offset ??_C@_0BG@OIKAEECI@?4?2crypto?2bn?2bn_mont?4c?$AA@ ; ".\\crypto\\bn\\bn_mont.c"
		push	4Ch ; 'L'
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jnz	short loc_F9
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_F9:					; CODE XREF: _BN_MONT_CTX_new+19j
		lea	eax, [esi+4]
		mov	dword ptr [esi], 0
		push	eax
		call	_BN_init
		lea	eax, [esi+18h]
		push	eax
		call	_BN_init
		lea	eax, [esi+2Ch]
		push	eax
		call	_BN_init
		add	esp, 0Ch
		mov	dword ptr [esi+44h], 0
		mov	dword ptr [esi+40h], 0
		mov	eax, esi
		mov	dword ptr [esi+48h], 1
		pop	esi
		retn
_BN_MONT_CTX_new endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 138h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_MONT_CTX_set
_BN_MONT_CTX_set proc near		; CODE XREF: _BN_MONT_CTX_set_locked+4Cp

var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 20h ; ' '
		call	__chkstk
		push	ebx
		mov	ebx, [esp+24h+arg_4]
		push	ebp
		xor	ebp, ebp
		cmp	[ebx+4], ebp
		jnz	short loc_157
		pop	ebp
		xor	eax, eax
		pop	ebx
		add	esp, 20h
		retn
; ---------------------------------------------------------------------------

loc_157:				; CODE XREF: _BN_MONT_CTX_set+15j
		push	esi
		push	edi
		mov	edi, [esp+30h+arg_8]
		push	edi
		call	_BN_CTX_start
		push	edi
		call	_BN_CTX_get
		mov	esi, eax
		add	esp, 8
		test	esi, esi
		jz	$err$27_0
		mov	eax, [esp+30h+arg_0]
		push	ebx
		lea	ecx, [eax+4]
		add	eax, 18h
		push	eax
		mov	[esp+38h+arg_4], ecx
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jz	$err$27_0
		mov	eax, [esp+30h+arg_0]
		mov	[eax+24h], ebp
		lea	eax, [esp+30h+var_14]
		push	eax
		call	_BN_init
		lea	eax, [esp+34h+var_1C]
		mov	[esp+34h+var_C], 2
		push	ebx
		mov	[esp+38h+var_14], eax
		mov	[esp+38h+var_8], ebp
		call	_BN_num_bits
		mov	ecx, [esp+38h+arg_0]
		add	eax, 1Fh
		cdq
		and	edx, 1Fh
		add	eax, edx
		and	eax, 0FFFFFFE0h
		mov	[ecx], eax
		lea	eax, [ecx+4]
		push	0
		push	eax
		call	_BN_set_word
		push	40h ; '@'
		push	[esp+44h+arg_4]
		call	_BN_set_bit
		add	esp, 18h
		test	eax, eax
		jz	$err$27_0
		mov	edx, [ebx]
		xor	ecx, ecx
		mov	[esp+30h+var_10], ecx
		mov	[esp+30h+var_20], 1
		mov	eax, [edx]
		test	eax, eax
		mov	[esp+30h+var_1C], eax
		cmovnz	ecx, [esp+30h+var_20]
		cmp	dword ptr [ebx+4], 1
		mov	[esp+30h+var_10], ecx
		jle	short loc_220
		mov	eax, [edx+4]
		jmp	short loc_222
; ---------------------------------------------------------------------------

loc_220:				; CODE XREF: _BN_MONT_CTX_set+E1j
		xor	eax, eax

loc_222:				; CODE XREF: _BN_MONT_CTX_set+E6j
		test	eax, eax
		mov	[esp+30h+var_18], eax
		push	edi
		lea	eax, [esp+34h+var_14]
		mov	edx, 2
		push	eax
		push	[esp+38h+arg_4]
		cmovnz	ecx, edx
		push	esi
		mov	[esp+40h+var_10], ecx
		call	_BN_mod_inverse
		add	esp, 10h
		test	eax, eax
		jz	$err$27_0
		push	40h ; '@'
		push	esi
		push	esi
		call	_BN_lshift
		add	esp, 0Ch
		test	eax, eax
		jz	$err$27_0
		cmp	[esi+4], ebp
		jz	short loc_27D
		push	1
		push	esi
		call	_BN_sub_word
		add	esp, 8
		test	eax, eax
		jz	$err$27_0
		jmp	short loc_2B5
; ---------------------------------------------------------------------------

loc_27D:				; CODE XREF: _BN_MONT_CTX_set+12Ej
		cmp	dword ptr [esi+8], 1
		jl	short loc_287
		mov	eax, esi
		jmp	short loc_292
; ---------------------------------------------------------------------------

loc_287:				; CODE XREF: _BN_MONT_CTX_set+149j
		push	1
		push	esi
		call	_bn_expand2
		add	esp, 8

loc_292:				; CODE XREF: _BN_MONT_CTX_set+14Dj
		test	eax, eax
		jz	$err$27_0
		mov	eax, [esi]
		mov	[esi+0Ch], ebp
		mov	dword ptr [eax], 0FFFFFFFFh
		mov	eax, [esi]
		mov	dword ptr [eax+4], 0FFFFFFFFh
		mov	dword ptr [esi+4], 2

loc_2B5:				; CODE XREF: _BN_MONT_CTX_set+143j
		push	edi
		lea	eax, [esp+34h+var_14]
		push	eax
		push	esi
		push	0
		push	esi
		call	_BN_div
		add	esp, 14h
		test	eax, eax
		jz	short $err$27_0
		cmp	[esi+4], ebp
		jle	short loc_2D6
		mov	eax, [esi]
		mov	eax, [eax]
		jmp	short loc_2D8
; ---------------------------------------------------------------------------

loc_2D6:				; CODE XREF: _BN_MONT_CTX_set+196j
		xor	eax, eax

loc_2D8:				; CODE XREF: _BN_MONT_CTX_set+19Cj
		mov	ebx, [esp+30h+arg_0]
		mov	[ebx+40h], eax
		cmp	dword ptr [esi+4], 1
		jle	short loc_2EC
		mov	eax, [esi]
		mov	eax, [eax+4]
		jmp	short loc_2EE
; ---------------------------------------------------------------------------

loc_2EC:				; CODE XREF: _BN_MONT_CTX_set+1ABj
		xor	eax, eax

loc_2EE:				; CODE XREF: _BN_MONT_CTX_set+1B2j
		push	0
		lea	esi, [ebx+4]
		mov	[ebx+44h], eax
		push	esi
		call	_BN_set_word
		mov	eax, [ebx]
		add	eax, eax
		push	eax
		push	esi
		call	_BN_set_bit
		add	esp, 10h
		test	eax, eax
		jz	short $err$27_0
		push	edi
		lea	eax, [ebx+18h]
		push	eax
		push	esi
		push	esi
		push	0
		call	_BN_div
		add	esp, 14h
		test	eax, eax
		cmovnz	ebp, [esp+30h+var_20]

$err$27_0:				; CODE XREF: _BN_MONT_CTX_set+38j
					; _BN_MONT_CTX_set+58j	...
		push	edi
		call	_BN_CTX_end
		add	esp, 4
		mov	eax, ebp
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 20h
		retn
_BN_MONT_CTX_set endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 33Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_MONT_CTX_set_locked
_BN_MONT_CTX_set_locked	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	ebx
		push	esi
		push	edi
		mov	edi, [esp+0Ch+arg_4]
		push	20Fh
		push	offset ??_C@_0BG@OIKAEECI@?4?2crypto?2bn?2bn_mont?4c?$AA@ ; ".\\crypto\\bn\\bn_mont.c"
		push	edi
		push	5
		call	_CRYPTO_lock
		mov	ebx, [esp+1Ch+arg_0]
		push	211h
		push	offset ??_C@_0BG@OIKAEECI@?4?2crypto?2bn?2bn_mont?4c?$AA@ ; ".\\crypto\\bn\\bn_mont.c"
		push	edi
		mov	esi, [ebx]
		push	6
		call	_CRYPTO_lock
		add	esp, 20h
		test	esi, esi
		jnz	short loc_3E1
		call	_BN_MONT_CTX_new
		mov	esi, eax
		test	esi, esi
		jz	short loc_39D
		push	[esp+0Ch+arg_C]
		push	[esp+10h+arg_8]
		push	esi
		call	_BN_MONT_CTX_set
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_3A3
		push	esi
		call	_BN_MONT_CTX_free
		add	esp, 4

loc_39D:				; CODE XREF: _BN_MONT_CTX_set_locked+41j
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_3A3:				; CODE XREF: _BN_MONT_CTX_set_locked+56j
		push	226h
		push	offset ??_C@_0BG@OIKAEECI@?4?2crypto?2bn?2bn_mont?4c?$AA@ ; ".\\crypto\\bn\\bn_mont.c"
		push	edi
		push	9
		call	_CRYPTO_lock
		add	esp, 10h
		cmp	dword ptr [ebx], 0
		jz	short loc_3CA
		push	esi
		call	_BN_MONT_CTX_free
		mov	esi, [ebx]
		add	esp, 4
		jmp	short loc_3CC
; ---------------------------------------------------------------------------

loc_3CA:				; CODE XREF: _BN_MONT_CTX_set_locked+7Fj
		mov	[ebx], esi

loc_3CC:				; CODE XREF: _BN_MONT_CTX_set_locked+8Cj
		push	22Ch
		push	offset ??_C@_0BG@OIKAEECI@?4?2crypto?2bn?2bn_mont?4c?$AA@ ; ".\\crypto\\bn\\bn_mont.c"
		push	edi
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h

loc_3E1:				; CODE XREF: _BN_MONT_CTX_set_locked+36j
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebx
		retn
_BN_MONT_CTX_set_locked	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3E8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_from_montgomery
_BN_from_montgomery proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	ebx
		push	esi
		mov	esi, [esp+8+arg_C]
		xor	ebx, ebx
		push	edi
		push	esi
		call	_BN_CTX_start
		push	esi
		call	_BN_CTX_get
		mov	edi, eax
		add	esp, 8
		test	edi, edi
		jz	short loc_42A
		push	[esp+0Ch+arg_4]
		push	edi
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jz	short loc_42A
		push	[esp+0Ch+arg_8]
		push	edi
		push	[esp+14h+arg_0]
		call	_BN_from_montgomery_word
		add	esp, 0Ch
		mov	ebx, eax

loc_42A:				; CODE XREF: _BN_from_montgomery+1Cj
					; _BN_from_montgomery+2Dj
		push	esi
		call	_BN_CTX_end
		add	esp, 4
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebx
		retn
_BN_from_montgomery endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 43Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_BN_from_montgomery_word proc near	; CODE XREF: _BN_from_montgomery+38p
					; _BN_mod_mul_montgomery+F4p

var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 20h ; ' '
		call	__chkstk
		mov	edx, [esp+20h+arg_8]
		push	ebx
		mov	ebx, [edx+1Ch]
		test	ebx, ebx
		jnz	short loc_461
		mov	eax, [esp+24h+arg_0]
		mov	[eax+4], ebx
		lea	eax, [ebx+1]
		pop	ebx
		add	esp, 20h
		retn
; ---------------------------------------------------------------------------

loc_461:				; CODE XREF: _BN_from_montgomery_word+14j
		push	ebp
		mov	ebp, [esp+28h+arg_4]
		push	esi
		lea	esi, [ebx+ebx]
		cmp	esi, [ebp+8]
		jg	short loc_473
		mov	eax, ebp
		jmp	short loc_481
; ---------------------------------------------------------------------------

loc_473:				; CODE XREF: _BN_from_montgomery_word+31j
		push	esi
		push	ebp
		call	_bn_expand2
		mov	edx, [esp+34h+arg_8]
		add	esp, 8

loc_481:				; CODE XREF: _BN_from_montgomery_word+35j
		test	eax, eax
		jnz	short loc_48C
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 20h
		retn
; ---------------------------------------------------------------------------

loc_48C:				; CODE XREF: _BN_from_montgomery_word+47j
		mov	eax, [edx+24h]
		xor	[ebp+0Ch], eax
		mov	eax, [edx+18h]
		mov	[esp+2Ch+var_1C], eax
		mov	eax, [ebp+4]
		push	edi
		mov	edi, [ebp+0]
		mov	[esp+30h+arg_8], edi
		cmp	eax, esi
		jge	short loc_4B7
		lea	edi, [edi+eax*4]
		mov	ecx, esi
		sub	ecx, eax
		xor	eax, eax
		rep stosd
		mov	edi, [esp+30h+arg_8]

loc_4B7:				; CODE XREF: _BN_from_montgomery_word+6Aj
		mov	[ebp+4], esi
		mov	ecx, [edx+40h]
		mov	[esp+30h+var_18], ecx
		mov	[esp+30h+var_20], 0
		test	ebx, ebx
		jle	short loc_518
		mov	[esp+30h+arg_8], ebx
		xor	ebp, ebp

loc_4D3:				; CODE XREF: _BN_from_montgomery_word+D2j
		mov	eax, [edi]
		imul	eax, ecx
		push	eax
		push	ebx
		push	[esp+38h+var_1C]
		push	edi
		call	_bn_mul_add_words
		mov	edx, [edi+ebx*4]
		xor	ecx, ecx
		add	esp, 10h
		lea	esi, [edx+ebp]
		add	esi, eax
		cmp	esi, edx
		mov	[edi+ebx*4], esi
		setnz	cl
		or	ebp, ecx
		mov	ecx, [esp+30h+var_18]
		cmp	edx, esi
		sbb	eax, eax
		add	edi, 4
		inc	eax
		and	ebp, eax
		sub	[esp+30h+arg_8], 1
		jnz	short loc_4D3
		mov	[esp+30h+var_20], ebp
		mov	ebp, [esp+30h+arg_4]

loc_518:				; CODE XREF: _BN_from_montgomery_word+8Fj
		mov	edi, [esp+30h+arg_0]
		cmp	ebx, [edi+8]
		jg	short loc_525
		mov	eax, edi
		jmp	short loc_52F
; ---------------------------------------------------------------------------

loc_525:				; CODE XREF: _BN_from_montgomery_word+E3j
		push	ebx
		push	edi
		call	_bn_expand2
		add	esp, 8

loc_52F:				; CODE XREF: _BN_from_montgomery_word+E7j
		test	eax, eax
		jnz	short loc_53B
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 20h
		retn
; ---------------------------------------------------------------------------

loc_53B:				; CODE XREF: _BN_from_montgomery_word+F5j
		mov	ecx, [edi]
		mov	[edi+4], ebx
		mov	eax, [ebp+0Ch]
		mov	[edi+0Ch], eax
		mov	eax, [ebp+0]
		push	ebx
		push	[esp+34h+var_1C]
		mov	[esp+38h+var_18], ecx
		lea	esi, [eax+ebx*4]
		push	esi
		push	ecx
		mov	[esp+40h+arg_8], esi
		call	_bn_sub_words
		mov	ecx, [esp+40h+var_20]
		sub	ebx, 4
		sub	ecx, eax
		mov	[esp+40h+var_8], ebx
		mov	eax, ecx
		xor	edx, edx
		not	eax
		mov	[esp+40h+var_20], edx
		and	eax, [esp+40h+var_18]
		and	ecx, esi
		or	eax, ecx
		add	esp, 10h
		mov	[esp+30h+var_4], eax
		test	ebx, ebx
		jle	loc_63A
		mov	edx, [esp+30h+var_18]
		lea	edi, [eax+8]
		mov	ebp, esi
		lea	ecx, [edx+4]
		mov	[esp+30h+var_1C], ecx
		mov	ecx, esi
		sub	ecx, eax
		mov	[esp+30h+var_10], ecx
		mov	ecx, edx
		sub	ecx, eax
		mov	eax, esi
		sub	eax, edx
		mov	[esp+30h+var_C], ecx
		mov	[esp+30h+var_14], eax
		nop	word ptr [eax+eax+00h]

loc_5BC:				; CODE XREF: _BN_from_montgomery_word+1F0j
		mov	ecx, [edi-8]
		lea	edi, [edi+10h]
		mov	edx, [edi-14h]
		mov	esi, [edi-10h]
		mov	eax, [esp+30h+var_20]
		mov	ebx, [esp+30h+var_14]
		mov	dword ptr [ebp+eax*4+0], 0
		mov	ebp, [esp+30h+var_1C]
		mov	eax, [edi-0Ch]
		mov	dword ptr [ebx+ebp], 0
		mov	ebx, [esp+30h+var_8]
		mov	[ebp-4], ecx
		mov	ecx, [esp+30h+var_10]
		mov	dword ptr [ecx+edi-10h], 0
		mov	ecx, ebp
		mov	ebp, [esp+30h+arg_8]
		mov	[ecx], edx
		mov	edx, [esp+30h+var_20]
		mov	dword ptr [ebp+edx*4+0Ch], 0
		add	edx, 4
		mov	ebp, [esp+30h+var_C]
		mov	[ecx+8], eax
		add	ecx, 10h
		mov	[esp+30h+var_20], edx
		mov	[esp+30h+var_1C], ecx
		mov	[edi+ebp-10h], esi
		mov	ebp, [esp+30h+arg_8]
		cmp	edx, ebx
		jl	short loc_5BC
		mov	ebp, [esp+30h+arg_4]
		mov	esi, [esp+30h+arg_8]
		mov	edi, [esp+30h+arg_0]

loc_63A:				; CODE XREF: _BN_from_montgomery_word+14Cj
		add	ebx, 4
		cmp	edx, ebx
		jge	short loc_66C
		mov	eax, [esp+30h+var_18]
		sub	esi, eax
		mov	ebp, [esp+30h+var_4]
		sub	ebp, eax
		sub	ebx, edx
		lea	ecx, [eax+edx*4]

loc_652:				; CODE XREF: _BN_from_montgomery_word+22Aj
		mov	eax, [ecx+ebp]
		lea	ecx, [ecx+4]
		mov	[ecx-4], eax
		mov	dword ptr [esi+ecx-4], 0
		sub	ebx, 1
		jnz	short loc_652
		mov	ebp, [esp+30h+arg_4]

loc_66C:				; CODE XREF: _BN_from_montgomery_word+203j
		mov	ecx, [ebp+4]
		test	ecx, ecx
		jle	short loc_68D
		mov	eax, [ebp+0]
		lea	edx, [ecx-1]
		lea	edx, [eax+edx*4]

loc_67C:				; CODE XREF: _BN_from_montgomery_word+24Cj
		mov	eax, [edx]
		lea	edx, [edx-4]
		test	eax, eax
		jnz	short loc_68A
		dec	ecx
		test	ecx, ecx
		jg	short loc_67C

loc_68A:				; CODE XREF: _BN_from_montgomery_word+247j
		mov	[ebp+4], ecx

loc_68D:				; CODE XREF: _BN_from_montgomery_word+235j
		mov	ecx, [edi+4]
		test	ecx, ecx
		jle	short loc_6AD
		mov	eax, [edi]
		lea	edx, [ecx-1]
		lea	edx, [eax+edx*4]

loc_69C:				; CODE XREF: _BN_from_montgomery_word+26Cj
		mov	eax, [edx]
		lea	edx, [edx-4]
		test	eax, eax
		jnz	short loc_6AA
		dec	ecx
		test	ecx, ecx
		jg	short loc_69C

loc_6AA:				; CODE XREF: _BN_from_montgomery_word+267j
		mov	[edi+4], ecx

loc_6AD:				; CODE XREF: _BN_from_montgomery_word+256j
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, 1
		pop	ebx
		add	esp, 20h
		retn
_BN_from_montgomery_word endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6BCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_mod_mul_montgomery
_BN_mod_mul_montgomery proc near

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	eax, 8
		call	__chkstk
		mov	ecx, [esp+8+arg_C]
		push	ebx
		mov	ebx, [esp+0Ch+arg_4]
		push	ebp
		mov	ebp, [esp+10h+arg_8]
		push	esi
		mov	esi, [ecx+1Ch]
		mov	[esp+14h+var_8], 0
		push	edi
		mov	edi, [esp+18h+arg_0]
		cmp	esi, 1
		jle	loc_76C
		cmp	[ebx+4], esi
		jnz	short loc_76C
		cmp	[ebp+4], esi
		jnz	short loc_76C
		cmp	esi, [edi+8]
		jg	short loc_701
		mov	eax, edi
		jmp	short loc_70F
; ---------------------------------------------------------------------------

loc_701:				; CODE XREF: _BN_mod_mul_montgomery+3Fj
		push	esi
		push	edi
		call	_bn_expand2
		mov	ecx, [esp+20h+arg_C]
		add	esp, 8

loc_70F:				; CODE XREF: _BN_mod_mul_montgomery+43j
		test	eax, eax
		jnz	short loc_71B
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_71B:				; CODE XREF: _BN_mod_mul_montgomery+55j
		push	esi
		lea	eax, [ecx+40h]
		push	eax
		push	dword ptr [ecx+18h]
		push	dword ptr [ebp+0]
		push	dword ptr [ebx]
		push	dword ptr [edi]
		call	_bn_mul_mont
		add	esp, 18h
		test	eax, eax
		jz	short loc_76C
		mov	eax, [ebx+0Ch]
		xor	eax, [ebp+0Ch]
		mov	[edi+0Ch], eax
		mov	[edi+4], esi
		test	esi, esi
		jle	short loc_75F
		mov	eax, [edi]
		lea	ecx, [esi-1]
		lea	ecx, [eax+ecx*4]

loc_74E:				; CODE XREF: _BN_mod_mul_montgomery+9Ej
		mov	eax, [ecx]
		lea	ecx, [ecx-4]
		test	eax, eax
		jnz	short loc_75C
		dec	esi
		test	esi, esi
		jg	short loc_74E

loc_75C:				; CODE XREF: _BN_mod_mul_montgomery+99j
		mov	[edi+4], esi

loc_75F:				; CODE XREF: _BN_mod_mul_montgomery+88j
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, 1
		pop	ebx
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_76C:				; CODE XREF: _BN_mod_mul_montgomery+2Cj
					; _BN_mod_mul_montgomery+35j ...
		mov	esi, [esp+18h+arg_10]
		push	esi
		call	_BN_CTX_start
		push	esi
		call	_BN_CTX_get
		add	esp, 8
		mov	[esp+18h+var_4], eax
		test	eax, eax
		jz	short $err$27
		push	esi
		cmp	ebx, ebp
		jnz	short loc_798
		push	ebx
		push	eax
		call	_BN_sqr
		add	esp, 0Ch
		jmp	short loc_7A3
; ---------------------------------------------------------------------------

loc_798:				; CODE XREF: _BN_mod_mul_montgomery+CEj
		push	ebp
		push	ebx
		push	eax
		call	_BN_mul
		add	esp, 10h

loc_7A3:				; CODE XREF: _BN_mod_mul_montgomery+DAj
		test	eax, eax
		jz	short $err$27
		push	[esp+18h+arg_C]
		push	[esp+1Ch+var_4]
		push	edi
		call	_BN_from_montgomery_word
		xor	ecx, ecx
		add	esp, 0Ch
		test	eax, eax
		mov	edx, 1
		cmovnz	ecx, edx
		mov	[esp+18h+var_8], ecx

$err$27:				; CODE XREF: _BN_mod_mul_montgomery+C9j
					; _BN_mod_mul_montgomery+E9j
		push	esi
		call	_BN_CTX_end
		mov	eax, [esp+1Ch+var_8]
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 8
		retn
_BN_mod_mul_montgomery endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7E0h
; COMDAT (pick any)
		public ??_C@_0BG@OIKAEECI@?4?2crypto?2bn?2bn_mont?4c?$AA@
; `string'
??_C@_0BG@OIKAEECI@?4?2crypto?2bn?2bn_mont?4c?$AA@ db '.\crypto\bn\bn_mont.c',0
					; DATA XREF: _BN_MONT_CTX_new+6o
					; _BN_MONT_CTX_set_locked+Co ...
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _CRYPTO_lock:near	; CODE XREF: _BN_MONT_CTX_set_locked+14p
					; _BN_MONT_CTX_set_locked+2Cp ...
		extrn _CRYPTO_malloc:near ; CODE XREF: _BN_MONT_CTX_new+Dp
		extrn _CRYPTO_free:near	; CODE XREF: _BN_MONT_CTX_free+2Ep
		extrn _BN_CTX_start:near ; CODE	XREF: _BN_MONT_CTX_set+26p
					; _BN_from_montgomery+Ap ...
		extrn _BN_CTX_get:near	; CODE XREF: _BN_MONT_CTX_set+2Cp
					; _BN_from_montgomery+10p ...
		extrn _BN_CTX_end:near	; CODE XREF: _BN_MONT_CTX_set+1EFp
					; _BN_from_montgomery+43p ...
		extrn _BN_num_bits:near	; CODE XREF: _BN_MONT_CTX_set+84p
		extrn _BN_init:near	; CODE XREF: _BN_MONT_CTX_init+Fp
					; _BN_MONT_CTX_init+18p ...
		extrn _BN_clear_free:near ; CODE XREF: _BN_MONT_CTX_free+Dp
					; _BN_MONT_CTX_free+16p ...
		extrn _BN_copy:near	; CODE XREF: _BN_MONT_CTX_copy+16p
					; _BN_MONT_CTX_copy+2Fp ...
		extrn _BN_mul:near	; CODE XREF: _BN_mod_mul_montgomery+DFp
		extrn _BN_sqr:near	; CODE XREF: _BN_mod_mul_montgomery+D2p
		extrn _BN_div:near	; CODE XREF: _BN_MONT_CTX_set+187p
					; _BN_MONT_CTX_set+1DFp
		extrn _BN_sub_word:near	; CODE XREF: _BN_MONT_CTX_set+133p
		extrn _BN_set_word:near	; CODE XREF: _BN_MONT_CTX_set+A1p
					; _BN_MONT_CTX_set+1BFp
		extrn _BN_lshift:near	; CODE XREF: _BN_MONT_CTX_set+11Bp
		extrn _BN_set_bit:near	; CODE XREF: _BN_MONT_CTX_set+ACp
					; _BN_MONT_CTX_set+1CAp
		extrn _BN_mod_inverse:near ; CODE XREF:	_BN_MONT_CTX_set+107p
		extrn _bn_expand2:near	; CODE XREF: _BN_MONT_CTX_set+152p
					; _BN_from_montgomery_word+39p	...
		extrn _bn_mul_add_words:near ; CODE XREF: _BN_from_montgomery_word+A3p
		extrn _bn_sub_words:near ; CODE	XREF: _BN_from_montgomery_word+11Fp
		extrn _bn_mul_mont:near	; CODE XREF: _BN_mod_mul_montgomery+6Ep
		extrn __chkstk:near	; CODE XREF: _BN_MONT_CTX_set+5p
					; _BN_from_montgomery_word+5p ...


		end
