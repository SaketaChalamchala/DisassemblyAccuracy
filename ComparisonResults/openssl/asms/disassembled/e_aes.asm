;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	07636A8779CFD5E5B0A11448379E04D2
; Input	CRC32 :	019F7E8F

; File Name   :	C:\compspace\Diff\openssl\obj\e_aes.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
_aesni_128_xts	dd offset byte_391	; DATA XREF: _EVP_aes_128_xts+Ao
		dd 1, 20h, 10h,	11471h
		dd offset _aesni_xts_init_key
		dd offset _aes_xts_cipher
		align 10h
		dd offset _aes_128_wrap
		dd 2 dup(0)
		dd offset _aes_xts_ctrl
		dd 0
_aes_128_xts	dd offset byte_391	; DATA XREF: _EVP_aes_128_xts+Fo
		dd 1, 20h, 10h,	11471h
		dd offset _aes_xts_init_key
		dd offset _aes_xts_cipher
		dd 0
		dd offset _aes_128_wrap
		align 10h
		dd offset _aes_xts_ctrl
		align 8
_aesni_256_xts	dd offset word_392	; DATA XREF: _EVP_aes_256_xts+Ao
		dd 1, 40h, 10h,	11471h
		dd offset _aesni_xts_init_key
		dd offset _aes_xts_cipher
		align 8
		dd offset _aes_128_wrap
		dd 2 dup(0)
		dd offset _aes_xts_ctrl
		dd 0
_aes_256_xts	dd offset word_392	; DATA XREF: _EVP_aes_256_xts+Fo
		dd 1, 40h, 10h,	11471h
		dd offset _aes_xts_init_key
		dd offset _aes_xts_cipher
		dd 0
		dd offset _aes_128_wrap
		dd 2 dup(0)
		dd offset _aes_xts_ctrl
		align 10h
_aesni_128_ccm	dd offset byte_380	; DATA XREF: _EVP_aes_128_ccm+Ao
		dd 1, 10h, 0Ch,	101477h
		dd offset _aesni_ccm_init_key
		dd offset _aes_ccm_cipher
		align 10h
		dd offset dword_148
		dd 2 dup(0)
		dd offset _aes_ccm_ctrl
dword_100	dd 0			; DATA XREF: .rdata:00000228o
					; .rdata:0000025Co ...
_aes_128_ccm	dd offset byte_380	; DATA XREF: _EVP_aes_128_ccm+Fo
		dd 1, 10h, 0Ch,	101477h
		dd offset _aes_ccm_init_key
		dd offset _aes_ccm_cipher
		dd 0
		dd offset dword_148
		align 10h
		dd offset _aes_ccm_ctrl
		align 8
_aesni_192_ccm	dd offset byte_383	; DATA XREF: _EVP_aes_192_ccm+Ao
		dd 1, 18h, 0Ch
dword_148	dd 101477h		; DATA XREF: .rdata:000000F0o
					; .rdata:00000124o ...
		dd offset _aesni_ccm_init_key
		dd offset _aes_ccm_cipher
		align 8
		dd offset dword_148
		dd 2 dup(0)
		dd offset _aes_ccm_ctrl
		dd 0
_aes_192_ccm	dd offset byte_383	; DATA XREF: _EVP_aes_192_ccm+Fo
		dd 1, 18h, 0Ch,	101477h
		dd offset _aes_ccm_init_key
		dd offset _aes_ccm_cipher
		dd 0
		dd offset dword_148
		dd 2 dup(0)
		dd offset _aes_ccm_ctrl
		align 10h
_aesni_256_ccm	dd offset word_386	; DATA XREF: _EVP_aes_256_ccm+Ao
					; .rdata:_aesni_128_ecbo ...
byte_1A4	db 1			; DATA XREF: .rdata:_aesni_128_ofbo
					; .rdata:_aes_128_ofbo
byte_1A5	db 0			; DATA XREF: .rdata:_aesni_128_cfbo
					; .rdata:_aes_128_cfbo
byte_1A6	db 0			; DATA XREF: .rdata:_aesni_192_ecbo
					; .rdata:_aes_192_ecbo
off_1A7		dd offset loc_2000	; DATA XREF: .rdata:_aesni_192_cbco
					; .rdata:_aes_192_cbco	...
off_1AB		dd offset dword_C00	; DATA XREF: .rdata:_aesni_256_cbco
					; .rdata:_aes_256_cbco	...
		align 10h
		dd 101477h
		dd offset _aesni_ccm_init_key
		dd offset _aes_ccm_cipher
		align 10h
		dd offset dword_148
		dd 2 dup(0)
		dd offset _aes_ccm_ctrl
		dd 0
_aes_256_ccm	dd offset word_386	; DATA XREF: _EVP_aes_256_ccm+Fo
		dd 1, 20h, 0Ch,	101477h
		dd offset _aes_ccm_init_key
		dd offset _aes_ccm_cipher
		dd 0
		dd offset dword_148
		align 10h
		dd offset _aes_ccm_ctrl
		align 8
_aes_128_wrap	dd offset byte_314	; DATA XREF: .rdata:00000020o
					; .rdata:00000054o ...
		dd 8, 10h, 8, 111032h
		dd offset _aes_wrap_init_key
		dd offset _aes_wrap_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aes_192_wrap	dd offset byte_315	; DATA XREF: _EVP_aes_192_wrapo
		dd 8, 18h, 8, 111032h
		dd offset _aes_wrap_init_key
		dd offset _aes_wrap_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aes_256_wrap	dd offset word_316	; DATA XREF: _EVP_aes_256_wrapo
		dd 8, 20h, 8, 111032h
		dd offset _aes_wrap_init_key
		dd offset _aes_wrap_cipher ; DATA XREF:	.rdata:_aesni_128_cfb1o
					; .rdata:_aes_128_cfb1o ...
byte_28C	db 0			; DATA XREF: .rdata:_aesni_256_cfb1o
					; .rdata:_aes_256_cfb1o
byte_28D	db 0			; DATA XREF: .rdata:_aesni_128_cfb8o
					; .rdata:_aes_128_cfb8o
byte_28E	db 0			; DATA XREF: .rdata:_aesni_192_cfb8o
					; .rdata:_aes_192_cfb8o
byte_28F	db 0			; DATA XREF: .rdata:_aesni_256_cfb8o
					; .rdata:_aes_256_cfb8o
off_290		dd offset dword_100	; DATA XREF: .rdata:00000B4Co
					; .rdata:00000B80o ...
		dd 4 dup(0)
_aesni_128_cbc	dd offset _aesni_256_ccm+3 ; DATA XREF:	_EVP_aes_128_cbc+Ao
		dd 3 dup(10h), 1002h
		dd offset _aesni_init_key
		dd offset _aesni_cbc_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aes_128_cbc	dd offset _aesni_256_ccm+3 ; DATA XREF:	_EVP_aes_128_cbc+Fo
		dd 3 dup(10h), 1002h
		dd offset _aes_init_key
		dd offset _aes_cbc_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aesni_128_ecb	dd offset _aesni_256_ccm+2 ; DATA XREF:	_EVP_aes_128_ecb+Ao
		dd 10h
byte_314	db 10h			; DATA XREF: .rdata:_aes_128_wrapo
byte_315	db 0			; DATA XREF: .rdata:_aes_192_wrapo
word_316	dw 0			; DATA XREF: .rdata:_aes_256_wrapo
		dd 0
		dd offset loc_FFE+3
		dd offset _aesni_init_key
		dd offset _aesni_ecb_cipher
		dd 0
		dd offset dword_100
		align 20h
_aes_128_ecb	dd offset _aesni_256_ccm+2 ; DATA XREF:	_EVP_aes_128_ecb+Fo
		dd 2 dup(10h), 0
		dd offset loc_FFE+3
		dd offset _aes_init_key
		dd offset _aes_ecb_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aesni_128_ofb	dd offset byte_1A4	; DATA XREF: _EVP_aes_128_ofb+Ao
		dd 1
		db 10h,	2 dup(0)
byte_37F	db 0			; DATA XREF: .rdata:_aesni_128_gcmo
					; .rdata:_aes_128_gcmo
byte_380	db 10h,	0		; DATA XREF: .rdata:_aesni_128_ccmo
					; .rdata:_aes_128_ccmo
byte_382	db 0			; DATA XREF: .rdata:_aesni_192_gcmo
					; .rdata:_aes_192_gcmo
byte_383	db 0			; DATA XREF: .rdata:_aesni_192_ccmo
					; .rdata:_aes_192_ccmo
		db 4
byte_385	db 10h			; DATA XREF: .rdata:_aesni_256_gcmo
					; .rdata:_aes_256_gcmo
word_386	dw 0			; DATA XREF: .rdata:_aesni_256_ccmo
					; .rdata:_aes_256_ccmo
off_388		dd offset _aesni_init_key ; DATA XREF: .rdata:_aesni_128_ctro
					; .rdata:_aes_128_ctro	...
		dd offset _aes_ofb_cipher
		db 0
byte_391	db 0			; DATA XREF: .rdata:_aesni_128_xtso
					; .rdata:_aes_128_xtso
word_392	dw 0			; DATA XREF: .rdata:_aesni_256_xtso
					; .rdata:_aes_256_xtso
		dd offset dword_100
		dd 4 dup(0)
_aes_128_ofb	dd offset byte_1A4	; DATA XREF: _EVP_aes_128_ofb+Fo
		dd 1, 2	dup(10h), 1004h
		dd offset _aes_init_key
		dd offset _aes_ofb_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aesni_128_cfb	dd offset byte_1A5	; DATA XREF: _EVP_aes_128_cfb128+Ao
		dd 1, 2	dup(10h), 1003h
		dd offset _aesni_init_key
		dd offset _aes_cfb_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aes_128_cfb	dd offset byte_1A5	; DATA XREF: _EVP_aes_128_cfb128+Fo
		dd 1, 2	dup(10h), 1003h
		dd offset _aes_init_key
		dd offset _aes_cfb_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aesni_128_cfb1	dd offset off_288+2	; DATA XREF: _EVP_aes_128_cfb1+Ao
		dd 1, 2	dup(10h), 3
		dd offset _aesni_init_key
		dd offset _aes_cfb1_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aes_128_cfb1	dd offset off_288+2	; DATA XREF: _EVP_aes_128_cfb1+Fo
		dd 1, 2	dup(10h), 3
		dd offset _aes_init_key
		dd offset _aes_cfb1_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aesni_128_cfb8	dd offset byte_28D	; DATA XREF: _EVP_aes_128_cfb8+Ao
		dd 1, 2	dup(10h), 3
		dd offset _aesni_init_key
		dd offset _aes_cfb8_cipher
		dd 0
		dd offset dword_100
		align 20h
_aes_128_cfb8	dd offset byte_28D	; DATA XREF: _EVP_aes_128_cfb8+Fo
		dd 1, 2	dup(10h), 3
		dd offset _aes_init_key
		dd offset _aes_cfb8_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aesni_128_ctr	dd offset off_388	; DATA XREF: _EVP_aes_128_ctr+Ao
		dd 1, 2	dup(10h), 5
		dd offset _aesni_init_key
		dd offset _aes_ctr_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aes_128_ctr	dd offset off_388	; DATA XREF: _EVP_aes_128_ctr+Fo
		dd 1, 2	dup(10h), 5
		dd offset _aes_init_key
		dd offset _aes_ctr_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aesni_192_cbc	dd offset off_1A7	; DATA XREF: _EVP_aes_192_cbc+Ao
		dd 10h,	18h, 10h, 1002h
		dd offset _aesni_init_key
		dd offset _aesni_cbc_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aes_192_cbc	dd offset off_1A7	; DATA XREF: _EVP_aes_192_cbc+Fo
		dd 10h,	18h, 10h, 1002h
		dd offset _aes_init_key
		dd offset _aes_cbc_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aesni_192_ecb	dd offset byte_1A6	; DATA XREF: _EVP_aes_192_ecb+Ao
		dd 10h,	18h, 0
		dd offset loc_FFE+3
		dd offset _aesni_init_key
		dd offset _aesni_ecb_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aes_192_ecb	dd offset byte_1A6	; DATA XREF: _EVP_aes_192_ecb+Fo
		dd 10h,	18h, 0
		dd offset loc_FFE+3
		dd offset _aes_init_key
		dd offset _aes_ecb_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aesni_192_ofb	dd offset off_1A7+1	; DATA XREF: _EVP_aes_192_ofb+Ao
		dd 1, 18h, 10h,	1004h
		dd offset _aesni_init_key
		dd offset _aes_ofb_cipher
		dd 0
		dd offset dword_100
		align 20h
_aes_192_ofb	dd offset off_1A7+1	; DATA XREF: _EVP_aes_192_ofb+Fo
		dd 1, 18h, 10h,	1004h
		dd offset _aes_init_key
		dd offset _aes_ofb_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aesni_192_cfb	dd offset off_1A7+2	; DATA XREF: _EVP_aes_192_cfb128+Ao
		dd 1, 18h, 10h,	1003h
		dd offset _aesni_init_key
		dd offset _aes_cfb_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aes_192_cfb	dd offset off_1A7+2	; DATA XREF: _EVP_aes_192_cfb128+Fo
		dd 1, 18h, 10h,	1003h
		dd offset _aes_init_key
		dd offset _aes_cfb_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aesni_192_cfb1	dd offset off_288+3	; DATA XREF: _EVP_aes_192_cfb1+Ao
		dd 1, 18h, 10h,	3
		dd offset _aesni_init_key
		dd offset _aes_cfb1_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aes_192_cfb1	dd offset off_288+3	; DATA XREF: _EVP_aes_192_cfb1+Fo
		dd 1, 18h, 10h,	3
		dd offset _aes_init_key
		dd offset _aes_cfb1_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aesni_192_cfb8	dd offset byte_28E	; DATA XREF: _EVP_aes_192_cfb8+Ao
		dd 1, 18h, 10h,	3
		dd offset _aesni_init_key
		dd offset _aes_cfb8_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aes_192_cfb8	dd offset byte_28E	; DATA XREF: _EVP_aes_192_cfb8+Fo
		dd 1, 18h, 10h,	3
		dd offset _aes_init_key
		dd offset _aes_cfb8_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aesni_192_ctr	dd offset off_388+1	; DATA XREF: _EVP_aes_192_ctr+Ao
		dd 1, 18h, 10h,	5
		dd offset _aesni_init_key
		dd offset _aes_ctr_cipher
		dd 0
		dd offset dword_100
		align 20h
_aes_192_ctr	dd offset off_388+1	; DATA XREF: _EVP_aes_192_ctr+Fo
		dd 1, 18h, 10h,	5
		dd offset _aes_init_key
		dd offset _aes_ctr_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aesni_256_cbc	dd offset off_1AB	; DATA XREF: _EVP_aes_256_cbc+Ao
		dd 10h,	20h, 10h, 1002h
		dd offset _aesni_init_key
		dd offset _aesni_cbc_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aes_256_cbc	dd offset off_1AB	; DATA XREF: _EVP_aes_256_cbc+Fo
		dd 10h,	20h, 10h, 1002h
		dd offset _aes_init_key
		dd offset _aes_cbc_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aesni_256_ecb	dd offset off_1A7+3	; DATA XREF: _EVP_aes_256_ecb+Ao
		dd 10h,	20h, 0
		dd offset loc_FFE+3
		dd offset _aesni_init_key
		dd offset _aesni_ecb_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aes_256_ecb	dd offset off_1A7+3	; DATA XREF: _EVP_aes_256_ecb+Fo
		dd 10h,	20h, 0
		dd offset loc_FFE+3
		dd offset _aes_init_key
		dd offset _aes_ecb_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aesni_256_ofb	dd offset off_1AB+1	; DATA XREF: _EVP_aes_256_ofb+Ao
		dd 1, 20h, 10h,	1004h
		dd offset _aesni_init_key
		dd offset _aes_ofb_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aes_256_ofb	dd offset off_1AB+1	; DATA XREF: _EVP_aes_256_ofb+Fo
		dd 1, 20h, 10h,	1004h
		dd offset _aes_init_key
		dd offset _aes_ofb_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aesni_256_cfb	dd offset off_1AB+2	; DATA XREF: _EVP_aes_256_cfb128+Ao
		dd 1, 20h, 10h,	1003h
		dd offset _aesni_init_key
		dd offset _aes_cfb_cipher
		dd 0
		dd offset dword_100
		align 20h
_aes_256_cfb	dd offset off_1AB+2	; DATA XREF: _EVP_aes_256_cfb128+Fo
		dd 1, 20h, 10h,	1003h
		dd offset _aes_init_key
		dd offset _aes_cfb_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aesni_256_cfb1	dd offset byte_28C	; DATA XREF: _EVP_aes_256_cfb1+Ao
		dd 1, 20h, 10h,	3
		dd offset _aesni_init_key
		dd offset _aes_cfb1_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aes_256_cfb1	dd offset byte_28C	; DATA XREF: _EVP_aes_256_cfb1+Fo
		dd 1, 20h, 10h,	3
		dd offset _aes_init_key
		dd offset _aes_cfb1_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aesni_256_cfb8	dd offset byte_28F	; DATA XREF: _EVP_aes_256_cfb8+Ao
		dd 1, 20h, 10h,	3
		dd offset _aesni_init_key
		dd offset _aes_cfb8_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aes_256_cfb8	dd offset byte_28F	; DATA XREF: _EVP_aes_256_cfb8+Fo
		dd 1, 20h, 10h,	3
		dd offset _aes_init_key
		dd offset _aes_cfb8_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aesni_256_ctr	dd offset off_388+2	; DATA XREF: _EVP_aes_256_ctr+Ao
		dd 1, 20h, 10h,	5
		dd offset _aesni_init_key
		dd offset _aes_ctr_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aes_256_ctr	dd offset off_388+2	; DATA XREF: _EVP_aes_256_ctr+Fo
		dd 1, 20h, 10h,	5
		dd offset _aes_init_key
		dd offset _aes_ctr_cipher
		dd 0
		dd offset dword_100
		dd 4 dup(0)
_aesni_128_gcm	dd offset byte_37F	; DATA XREF: _EVP_aes_128_gcm+Ao
		dd 1, 10h, 0Ch,	301476h
		dd offset _aesni_gcm_init_key
		dd offset _aes_gcm_cipher
		dd offset _aes_gcm_cleanup
		dd offset off_290
		dd 2 dup(0)
		dd offset _aes_gcm_ctrl
		align 10h
_aes_128_gcm	dd offset byte_37F	; DATA XREF: _EVP_aes_128_gcm+Fo
		dd 1, 10h, 0Ch,	301476h
		dd offset _aes_gcm_init_key
		dd offset _aes_gcm_cipher
		dd offset _aes_gcm_cleanup
		dd offset off_290
		dd 2 dup(0)
		dd offset _aes_gcm_ctrl
		dd 0
_aesni_192_gcm	dd offset byte_382	; DATA XREF: _EVP_aes_192_gcm+Ao
		dd 1, 18h, 0Ch,	301476h
		dd offset _aesni_gcm_init_key
		dd offset _aes_gcm_cipher
		dd offset _aes_gcm_cleanup
		dd offset off_290
		align 10h
		dd offset _aes_gcm_ctrl
		align 8
_aes_192_gcm	dd offset byte_382	; DATA XREF: _EVP_aes_192_gcm+Fo
		dd 1, 18h, 0Ch,	301476h
		dd offset _aes_gcm_init_key
		dd offset _aes_gcm_cipher
		dd offset _aes_gcm_cleanup
		dd offset off_290
		dd 2 dup(0)
		dd offset _aes_gcm_ctrl
		dd 0
_aesni_256_gcm	dd offset byte_385	; DATA XREF: _EVP_aes_256_gcm+Ao
dword_C00	dd 1, 20h, 0Ch,	301476h	; DATA XREF: .rdata:off_1ABo
		dd offset _aesni_gcm_init_key
		dd offset _aes_gcm_cipher
		dd offset _aes_gcm_cleanup
		dd offset off_290
		dd 2 dup(0)
		dd offset _aes_gcm_ctrl
		align 10h
_aes_256_gcm	dd offset byte_385	; DATA XREF: _EVP_aes_256_gcm+Fo
		dd 1, 20h, 0Ch,	301476h
		dd offset _aes_gcm_init_key
		dd offset _aes_gcm_cipher
		dd offset _aes_gcm_cleanup
		dd offset off_290
		dd 2 dup(0)
		dd offset _aes_gcm_ctrl
		dd 0
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C64h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl aes_ccm_ctrl(int,	int, size_t Size, void *Src)
_aes_ccm_ctrl	proc near		; DATA XREF: .rdata:000000FCo
					; .rdata:00000130o ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
Size		= dword	ptr  0Ch
Src		= dword	ptr  10h

		mov	ecx, [esp+arg_0]
		mov	eax, [esp+arg_4]
		push	esi
		mov	esi, [ecx+60h]
		cmp	eax, 14h	; switch 21 cases
		ja	$LN21		; jumptable 00000C80 default case
		movzx	eax, ds:$LN23[eax]
		jmp	ds:$LN27_0[eax*4] ; switch jump
; ---------------------------------------------------------------------------

$LN4_0:					; CODE XREF: _aes_ccm_ctrl+1Cj
					; DATA XREF: .text$mn:$LN27_0o
		mov	dword ptr [esi+0F8h], 0	; jumptable 00000C80 case 0
		mov	eax, 1
		mov	dword ptr [esi+0FCh], 0
		mov	dword ptr [esi+108h], 8
		mov	dword ptr [esi+10Ch], 0Ch
		mov	dword ptr [esi+100h], 0
		mov	dword ptr [esi+104h], 0
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN5_0:					; CODE XREF: _aes_ccm_ctrl+1Cj
					; DATA XREF: .text$mn:$LN27_0o
		mov	ecx, 0Fh	; jumptable 00000C80 case 9
		sub	ecx, [esp+4+Size]
		jmp	short loc_CD9
; ---------------------------------------------------------------------------

$LN24:					; CODE XREF: _aes_ccm_ctrl+1Cj
					; DATA XREF: .text$mn:$LN27_0o
		mov	ecx, [esp+4+Size] ; jumptable 00000C80 case 20

loc_CD9:				; CODE XREF: _aes_ccm_ctrl+6Fj
		lea	eax, [ecx-2]
		cmp	eax, 6
		ja	short loc_CEE
		mov	[esi+108h], ecx
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_CEE:				; CODE XREF: _aes_ccm_ctrl+7Bj
					; _aes_ccm_ctrl+E4j ...
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN9:					; CODE XREF: _aes_ccm_ctrl+1Cj
					; DATA XREF: .text$mn:$LN27_0o
		push	ebx		; jumptable 00000C80 case 17
		mov	ebx, [esp+8+Size]
		test	bl, 1
		jnz	short loc_D11
		lea	eax, [ebx-4]
		cmp	eax, 0Ch
		ja	short loc_D11
		cmp	dword ptr [ecx+8], 0
		jz	short loc_D16
		cmp	[esp+8+Src], 0
		jz	short loc_D36

loc_D11:				; CODE XREF: _aes_ccm_ctrl+96j
					; _aes_ccm_ctrl+9Ej
		pop	ebx
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_D16:				; CODE XREF: _aes_ccm_ctrl+A4j
		mov	eax, [esp+8+Src]
		test	eax, eax
		jz	short loc_D36
		push	ebx		; Size
		push	eax		; Src
		lea	eax, [ecx+30h]
		mov	dword ptr [esi+100h], 1
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_D36:				; CODE XREF: _aes_ccm_ctrl+ABj
					; _aes_ccm_ctrl+B8j
		mov	[esi+10Ch], ebx
		mov	eax, 1
		pop	ebx
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN14:					; CODE XREF: _aes_ccm_ctrl+1Cj
					; DATA XREF: .text$mn:$LN27_0o
		cmp	dword ptr [ecx+8], 0 ; jumptable 00000C80 case 16
		jz	short loc_CEE
		cmp	dword ptr [esi+100h], 0
		jz	short loc_CEE
		push	[esp+4+Size]
		lea	eax, [esi+110h]
		push	[esp+8+Src]
		push	eax
		call	_CRYPTO_ccm128_tag
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_CEE
		mov	dword ptr [esi+100h], 0
		mov	eax, 1
		mov	dword ptr [esi+0FCh], 0
		mov	dword ptr [esi+104h], 0
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN18:					; CODE XREF: _aes_ccm_ctrl+1Cj
					; DATA XREF: .text$mn:$LN27_0o
		mov	eax, [esp+4+Src] ; jumptable 00000C80 case 8
		mov	ecx, [esi+13Ch]
		mov	eax, [eax+60h]
		test	ecx, ecx
		jz	short loc_DB2
		cmp	ecx, esi
		jnz	loc_CEE
		mov	[eax+13Ch], eax

loc_DB2:				; CODE XREF: _aes_ccm_ctrl+13Ej
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN21:					; CODE XREF: _aes_ccm_ctrl+Fj
					; _aes_ccm_ctrl+1Cj
					; DATA XREF: ...
		or	eax, 0FFFFFFFFh	; jumptable 00000C80 default case
		pop	esi
		retn
_aes_ccm_ctrl	endp

; ---------------------------------------------------------------------------
		align 10h
$LN27_0		dd offset $LN4_0	; DATA XREF: _aes_ccm_ctrl+1Cr
		dd offset $LN18		; jump table for switch	statement
		dd offset $LN5_0
		dd offset $LN14
		dd offset $LN9
		dd offset $LN24
		dd offset $LN21
$LN23		db	0,     6,     6,     6 ; DATA XREF: _aes_ccm_ctrl+15r
		db	6,     6,     6,     6 ; indirect table	for switch statement
		db	1,     2,     6,     6
		db	6,     6,     6,     6
		db	3,     4,     6,     6
		db	5
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0DF4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl aes_ccm_init_key(int, int, void *Src)
_aes_ccm_init_key proc near		; DATA XREF: .rdata:00000118o
					; .rdata:00000180o ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
Src		= dword	ptr  0Ch

		mov	ecx, [esp+arg_4]
		push	ebx
		mov	ebx, [esp+4+Src]
		push	esi
		push	edi
		mov	edi, [esp+0Ch+arg_0]
		mov	esi, [edi+60h]
		test	ebx, ebx
		jnz	short loc_E15
		test	ecx, ecx
		jnz	short loc_E19
		pop	edi
		pop	esi
		lea	eax, [ebx+1]
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_E15:				; CODE XREF: _aes_ccm_init_key+14j
		test	ecx, ecx
		jz	short loc_E74

loc_E19:				; CODE XREF: _aes_ccm_init_key+18j
		mov	eax, [edi+58h]
		push	esi
		shl	eax, 3
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 200h
		push	eax
		push	ecx
		jz	short loc_E3A
		call	_vpaes_set_encrypt_key
		push	offset _vpaes_encrypt
		jmp	short loc_E44
; ---------------------------------------------------------------------------

loc_E3A:				; CODE XREF: _aes_ccm_init_key+38j
		call	_AES_set_encrypt_key
		push	offset _AES_encrypt

loc_E44:				; CODE XREF: _aes_ccm_init_key+44j
		push	esi
		push	dword ptr [esi+108h]
		lea	eax, [esi+110h]
		push	dword ptr [esi+10Ch]
		push	eax
		call	_CRYPTO_ccm128_init
		mov	dword ptr [esi+0F8h], 1
		add	esp, 20h
		mov	dword ptr [esi+140h], 0

loc_E74:				; CODE XREF: _aes_ccm_init_key+23j
		test	ebx, ebx
		jz	short loc_E9B
		mov	eax, 0Fh
		sub	eax, [esi+108h]
		push	eax		; Size
		lea	eax, [edi+20h]
		push	ebx		; Src
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	dword ptr [esi+0FCh], 1

loc_E9B:				; CODE XREF: _aes_ccm_init_key+82j
		pop	edi
		pop	esi
		mov	eax, 1
		pop	ebx
		retn
_aes_ccm_init_key endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0EA4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_aesni_init_key	proc near		; DATA XREF: .rdata:000002B8o
					; .rdata:00000320o ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_C		= dword	ptr  10h

		mov	ecx, [esp+arg_0]
		push	esi
		push	edi
		mov	eax, [ecx]
		mov	edi, [ecx+60h]
		mov	esi, [eax+10h]
		and	esi, 0F0007h
		cmp	esi, 1
		jz	short loc_EC2
		cmp	esi, 2
		jnz	short loc_EFE

loc_EC2:				; CODE XREF: _aesni_init_key+17j
		cmp	[esp+8+arg_C], 0
		jnz	short loc_EFE
		mov	eax, [ecx+58h]
		push	edi
		shl	eax, 3
		push	eax
		push	[esp+10h+arg_4]
		call	_aesni_set_decrypt_key
		xor	ecx, ecx
		mov	dword ptr [edi+0F8h], offset _aesni_decrypt
		add	esp, 0Ch
		mov	edx, eax
		cmp	esi, 2
		mov	eax, offset _aesni_cbc_encrypt
		cmovz	ecx, eax
		mov	[edi+0FCh], ecx
		jmp	short loc_F42
; ---------------------------------------------------------------------------

loc_EFE:				; CODE XREF: _aesni_init_key+1Cj
					; _aesni_init_key+23j
		mov	eax, [ecx+58h]
		push	edi
		shl	eax, 3
		push	eax
		push	[esp+10h+arg_4]
		call	_aesni_set_encrypt_key
		add	esp, 0Ch
		mov	dword ptr [edi+0F8h], offset _aesni_encrypt
		mov	edx, eax
		cmp	esi, 2
		jnz	short loc_F2F
		mov	dword ptr [edi+0FCh], offset _aesni_cbc_encrypt
		jmp	short loc_F42
; ---------------------------------------------------------------------------

loc_F2F:				; CODE XREF: _aesni_init_key+7Dj
		xor	eax, eax
		mov	ecx, offset _aesni_ctr32_encrypt_blocks
		cmp	esi, 5
		cmovz	eax, ecx
		mov	[edi+0FCh], eax

loc_F42:				; CODE XREF: _aesni_init_key+58j
					; _aesni_init_key+89j
		pop	edi
		pop	esi
		test	edx, edx
		jns	short loc_F69
		push	126h
		push	offset ??_C@_0BF@PJIDMOFK@?4?2crypto?2evp?2e_aes?4c?$AA@ ; ".\\crypto\\evp\\e_aes.c"
		push	8Fh ; 'è'
		push	0A5h ; '•'
		push	6
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_F69:				; CODE XREF: _aesni_init_key+A2j
		mov	eax, 1
		retn
_aesni_init_key	endp ; sp-analysis failed

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F70h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_aesni_cbc_cipher proc near		; DATA XREF: .rdata:000002BCo
					; .rdata:00000594o ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	ecx, [esp+arg_0]
		push	dword ptr [ecx+8]
		lea	eax, [ecx+20h]
		push	eax
		push	dword ptr [ecx+60h]
		push	[esp+0Ch+arg_C]
		push	[esp+10h+arg_4]
		push	[esp+14h+arg_8]
		call	_aesni_cbc_encrypt
		add	esp, 18h
		mov	eax, 1
		retn
_aesni_cbc_cipher endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F98h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_aesni_ecb_cipher proc near		; DATA XREF: .rdata:00000324o
					; .rdata:000005FCo ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	ecx, [esp+arg_0]
		mov	edx, [esp+arg_C]
		mov	eax, [ecx]
		cmp	edx, [eax+4]
		jb	short loc_FBE
		push	dword ptr [ecx+8]
		push	dword ptr [ecx+60h]
		push	edx
		push	[esp+0Ch+arg_4]
		push	[esp+10h+arg_8]
		call	_aesni_ecb_encrypt
		add	esp, 14h

loc_FBE:				; CODE XREF: _aesni_ecb_cipher+Dj
		mov	eax, 1
		retn
_aesni_ecb_cipher endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0FC4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_aes_ofb_cipher	proc near		; DATA XREF: .rdata:0000038Co
					; .rdata:000003C0o ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	ecx, [esp+arg_0]
		mov	edx, [ecx+60h]
		lea	eax, [ecx+50h]
		push	dword ptr [edx+0F8h]
		push	eax
		lea	eax, [ecx+20h]
		push	eax
		push	edx
		push	[esp+10h+arg_C]
		push	[esp+14h+arg_4]
		push	[esp+18h+arg_8]
		call	_CRYPTO_ofb128_encrypt
		add	esp, 1Ch
		mov	eax, 1
		retn
_aes_ofb_cipher	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0FF4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_aes_cfb_cipher	proc near		; DATA XREF: .rdata:000003F4o
					; .rdata:00000428o ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	ecx, [esp+arg_0]
		mov	edx, [ecx+60h]
		lea	eax, [ecx+50h]

loc_FFE:				; DATA XREF: .rdata:0000031Co
					; .rdata:00000350o ...
		push	dword ptr [edx+0F8h]
		push	dword ptr [ecx+8]
		push	eax
		lea	eax, [ecx+20h]
		push	eax
		push	edx
		push	[esp+14h+arg_C]
		push	[esp+18h+arg_4]
		push	[esp+1Ch+arg_8]
		call	_CRYPTO_cfb128_encrypt
		add	esp, 20h
		mov	eax, 1
		retn
_aes_cfb_cipher	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1028h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_aes_wrap_init_key proc	near		; DATA XREF: .rdata:0000021Co
					; .rdata:00000250o ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_4]
		push	ebx
		mov	ebx, [esp+4+arg_8]
		push	esi
		mov	esi, [esp+8+arg_0]
		push	edi
		mov	edi, [esi+60h]
		test	ebx, ebx
		jnz	short loc_1049
		test	ecx, ecx
		jnz	short loc_104D
		pop	edi
		pop	esi
		lea	eax, [ebx+1]
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1049:				; CODE XREF: _aes_wrap_init_key+14j
		test	ecx, ecx
		jz	short loc_107C

loc_104D:				; CODE XREF: _aes_wrap_init_key+18j
		mov	eax, [esi+58h]
		push	edi
		shl	eax, 3
		cmp	dword ptr [esi+8], 0
		push	eax
		push	ecx
		jz	short loc_1063
		call	_AES_set_encrypt_key
		jmp	short loc_1068
; ---------------------------------------------------------------------------

loc_1063:				; CODE XREF: _aes_wrap_init_key+32j
		call	_AES_set_decrypt_key

loc_1068:				; CODE XREF: _aes_wrap_init_key+39j
		add	esp, 0Ch
		test	ebx, ebx
		jnz	short loc_107C
		mov	[edi+0F8h], ebx
		lea	eax, [ebx+1]
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_107C:				; CODE XREF: _aes_wrap_init_key+23j
					; _aes_wrap_init_key+45j
		mov	eax, [ebx]
		lea	ecx, [esi+20h]
		mov	[ecx], eax
		mov	eax, [ebx+4]
		mov	[ecx+4], eax
		mov	eax, 1
		mov	[edi+0F8h], ecx
		pop	edi
		pop	esi
		pop	ebx
		retn
_aes_wrap_init_key endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1098h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_aes_cfb8_cipher proc near		; DATA XREF: .rdata:000004C4o
					; .rdata:000004F8o ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	ecx, [esp+arg_0]
		mov	edx, [ecx+60h]
		lea	eax, [ecx+50h]
		push	dword ptr [edx+0F8h]
		push	dword ptr [ecx+8]
		push	eax
		lea	eax, [ecx+20h]
		push	eax
		push	edx
		push	[esp+14h+arg_C]
		push	[esp+18h+arg_4]
		push	[esp+1Ch+arg_8]
		call	_CRYPTO_cfb128_8_encrypt
		add	esp, 20h
		mov	eax, 1
		retn
_aes_cfb8_cipher endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 10CCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_aes_cfb1_cipher proc near		; DATA XREF: .rdata:0000045Co
					; .rdata:00000490o ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	ebx
		push	esi
		mov	esi, [esp+8+arg_0]
		test	dword ptr [esi+5Ch], 2000h
		mov	ebx, [esi+60h]
		jz	short loc_110C
		push	dword ptr [ebx+0F8h]
		lea	eax, [esi+50h]
		push	dword ptr [esi+8]
		push	eax
		lea	eax, [esi+20h]
		push	eax
		push	ebx
		push	[esp+1Ch+arg_C]
		push	[esp+20h+arg_4]
		push	[esp+24h+arg_8]
		call	_CRYPTO_cfb128_1_encrypt
		add	esp, 20h
		mov	eax, 1
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_110C:				; CODE XREF: _aes_cfb1_cipher+10j
		mov	ecx, [esp+8+arg_8]
		mov	edx, [esp+8+arg_4]
		push	edi
		mov	edi, [esp+0Ch+arg_C]
		cmp	edi, 10000000h
		jb	short loc_1161
		push	ebp
		mov	ebp, edi
		lea	eax, [esi+50h]
		shr	ebp, 1Ch
		xchg	ax, ax

loc_112C:				; CODE XREF: _aes_cfb1_cipher+92j
		push	dword ptr [ebx+0F8h]
		push	dword ptr [esi+8]
		push	eax
		lea	eax, [esi+20h]
		push	eax
		push	ebx
		push	80000000h
		push	edx
		push	ecx
		call	_CRYPTO_cfb128_1_encrypt
		mov	ecx, [esp+30h+arg_8]
		lea	eax, [esi+50h]
		mov	edx, [esp+30h+arg_4]
		add	esp, 20h
		sub	edi, 10000000h
		sub	ebp, 1
		jnz	short loc_112C
		pop	ebp

loc_1161:				; CODE XREF: _aes_cfb1_cipher+53j
		test	edi, edi
		jz	short loc_1189
		push	dword ptr [ebx+0F8h]
		lea	eax, [esi+50h]
		push	dword ptr [esi+8]
		push	eax
		lea	eax, [esi+20h]
		push	eax
		push	ebx
		lea	eax, ds:0[edi*8]
		push	eax
		push	edx
		push	ecx
		call	_CRYPTO_cfb128_1_encrypt
		add	esp, 20h

loc_1189:				; CODE XREF: _aes_cfb1_cipher+97j
		pop	edi
		pop	esi
		mov	eax, 1
		pop	ebx
		retn
_aes_cfb1_cipher endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1194h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_aes_wrap_cipher proc near		; DATA XREF: .rdata:00000220o
					; .rdata:00000254o ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	ecx, [esp+arg_0]
		push	esi
		mov	esi, [esp+4+arg_8]
		mov	edx, [ecx+60h]
		test	esi, esi
		jnz	short loc_11A8
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_11A8:				; CODE XREF: _aes_wrap_cipher+Ej
		mov	eax, [esp+4+arg_C]
		test	al, 7
		jz	short loc_11B5

loc_11B0:				; CODE XREF: _aes_wrap_cipher+2Bj
					; _aes_wrap_cipher+34j
		or	eax, 0FFFFFFFFh
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_11B5:				; CODE XREF: _aes_wrap_cipher+1Aj
		mov	ecx, [ecx+8]
		test	ecx, ecx
		jz	short loc_11C5
		cmp	eax, 8
		jb	short loc_11B0
		test	ecx, ecx
		jnz	short loc_11CA

loc_11C5:				; CODE XREF: _aes_wrap_cipher+26j
		cmp	eax, 10h
		jb	short loc_11B0

loc_11CA:				; CODE XREF: _aes_wrap_cipher+2Fj
		push	edi
		mov	edi, [esp+8+arg_4]
		test	edi, edi
		jnz	short loc_11E3
		test	ecx, ecx
		jz	short loc_11DD
		pop	edi
		add	eax, 8
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_11DD:				; CODE XREF: _aes_wrap_cipher+41j
		pop	edi
		add	eax, 0FFFFFFF8h
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_11E3:				; CODE XREF: _aes_wrap_cipher+3Dj
		test	ecx, ecx
		jz	short loc_120B
		push	offset _AES_encrypt
		push	eax
		push	esi
		push	edi
		push	dword ptr [edx+0F8h]
		push	edx
		call	_CRYPTO_128_wrap
		add	esp, 18h
		mov	ecx, eax
		or	eax, 0FFFFFFFFh
		test	ecx, ecx
		cmovnz	eax, ecx
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_120B:				; CODE XREF: _aes_wrap_cipher+51j
		push	offset _AES_decrypt
		push	eax
		push	esi
		push	edi
		push	dword ptr [edx+0F8h]
		push	edx
		call	_CRYPTO_128_unwrap
		add	esp, 18h
		mov	ecx, eax
		or	eax, 0FFFFFFFFh
		test	ecx, ecx
		cmovnz	eax, ecx
		pop	edi
		pop	esi
		retn
_aes_wrap_cipher endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1230h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_aes_ctr_cipher	proc near		; DATA XREF: .rdata:0000052Co
					; .rdata:00000560o ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	ecx, [esi+60h]
		mov	eax, [esi+50h]
		mov	[esp+4+arg_0], eax
		mov	eax, [ecx+0FCh]
		test	eax, eax
		jz	short loc_127A
		push	eax
		lea	eax, [esp+8+arg_0]
		push	eax
		lea	eax, [esi+30h]
		push	eax
		lea	eax, [esi+20h]
		push	eax
		push	ecx
		push	[esp+18h+arg_C]
		push	[esp+1Ch+arg_4]
		push	[esp+20h+arg_8]
		call	_CRYPTO_ctr128_encrypt_ctr32
		mov	eax, [esp+24h+arg_0]
		add	esp, 20h
		mov	[esi+50h], eax
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_127A:				; CODE XREF: _aes_ctr_cipher+17j
		push	dword ptr [ecx+0F8h]
		lea	eax, [esp+8+arg_0]
		push	eax
		lea	eax, [esi+30h]
		push	eax
		lea	eax, [esi+20h]
		push	eax
		push	ecx
		push	[esp+18h+arg_C]
		push	[esp+1Ch+arg_4]
		push	[esp+20h+arg_8]
		call	_CRYPTO_ctr128_encrypt
		mov	eax, [esp+24h+arg_0]
		add	esp, 20h
		mov	[esi+50h], eax
		mov	eax, 1
		pop	esi
		retn
_aes_ctr_cipher	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 12B0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl aesni_gcm_init_key(int, int, void	*Src)
_aesni_gcm_init_key proc near		; DATA XREF: .rdata:00000B40o
					; .rdata:00000BA8o ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
Src		= dword	ptr  0Ch

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		push	esi
		push	edi
		mov	edi, [esp+8+Src]
		mov	esi, [eax+60h]
		test	edi, edi
		jnz	short loc_12CF
		test	ecx, ecx
		jnz	short loc_12D3
		lea	eax, [edi+1]
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_12CF:				; CODE XREF: _aesni_gcm_init_key+13j
		test	ecx, ecx
		jz	short loc_1344

loc_12D3:				; CODE XREF: _aesni_gcm_init_key+17j
		mov	eax, [eax+58h]
		push	ebx
		push	esi
		shl	eax, 3
		push	eax
		push	ecx
		call	_aesni_set_encrypt_key
		push	offset _aesni_encrypt
		lea	ebx, [esi+100h]
		push	esi
		push	ebx
		call	_CRYPTO_gcm128_init
		add	esp, 18h
		mov	dword ptr [esi+28Ch], offset _aesni_ctr32_encrypt_blocks
		test	edi, edi
		jnz	short loc_1317
		cmp	[esi+0FCh], edi
		jz	short loc_1331
		mov	edi, [esi+278h]
		test	edi, edi
		jz	short loc_1331

loc_1317:				; CODE XREF: _aesni_gcm_init_key+53j
		push	dword ptr [esi+27Ch]
		push	edi
		push	ebx
		call	_CRYPTO_gcm128_setiv
		add	esp, 0Ch
		mov	dword ptr [esi+0FCh], 1

loc_1331:				; CODE XREF: _aesni_gcm_init_key+5Bj
					; _aesni_gcm_init_key+65j
		pop	ebx
		pop	edi
		mov	dword ptr [esi+0F8h], 1
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1344:				; CODE XREF: _aesni_gcm_init_key+21j
		cmp	dword ptr [esi+0F8h], 0
		push	dword ptr [esi+27Ch] ; Size
		push	edi		; Src
		jz	short loc_1362
		lea	eax, [esi+100h]
		push	eax
		call	_CRYPTO_gcm128_setiv
		jmp	short loc_136D
; ---------------------------------------------------------------------------

loc_1362:				; CODE XREF: _aesni_gcm_init_key+A2j
		push	dword ptr [esi+278h] ; Dst
		call	_memcpy

loc_136D:				; CODE XREF: _aesni_gcm_init_key+B0j
		add	esp, 0Ch
		mov	dword ptr [esi+0FCh], 1
		mov	dword ptr [esi+284h], 0
		mov	eax, 1
		pop	edi
		pop	esi
		retn
_aesni_gcm_init_key endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 138Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_aes_gcm_cipher	proc near		; DATA XREF: .rdata:00000B44o
					; .rdata:00000B78o ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, [esp+arg_0]
		push	esi
		mov	esi, [eax+60h]
		cmp	dword ptr [esi+0F8h], 0
		jnz	short loc_13A2

loc_139D:				; CODE XREF: _aes_gcm_cipher+30j
					; _aes_gcm_cipher+DCj
		or	eax, 0FFFFFFFFh
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_13A2:				; CODE XREF: _aes_gcm_cipher+Fj
		cmp	dword ptr [esi+288h], 0
		jl	short loc_13B5
		pop	esi
		mov	[esp+arg_0], eax
		jmp	_aes_gcm_tls_cipher
; ---------------------------------------------------------------------------

loc_13B5:				; CODE XREF: _aes_gcm_cipher+1Dj
		cmp	dword ptr [esi+0FCh], 0
		jz	short loc_139D
		mov	ecx, [esp+4+arg_8]
		test	ecx, ecx
		jz	loc_145A
		mov	edx, [esp+4+arg_4]
		push	edi
		mov	edi, [esp+8+arg_C]
		test	edx, edx
		jnz	short loc_13EA
		push	edi
		push	ecx
		lea	eax, [esi+100h]
		push	eax
		call	_CRYPTO_gcm128_aad
		add	esp, 0Ch
		jmp	short loc_1421
; ---------------------------------------------------------------------------

loc_13EA:				; CODE XREF: _aes_gcm_cipher+49j
		cmp	dword ptr [eax+8], 0
		mov	eax, [esi+28Ch]
		jz	short loc_142B
		test	eax, eax
		jz	short loc_140F
		push	eax
		push	edi
		push	edx
		push	ecx
		lea	eax, [esi+100h]
		push	eax
		call	_CRYPTO_gcm128_encrypt_ctr32
		add	esp, 14h
		jmp	short loc_1421
; ---------------------------------------------------------------------------

loc_140F:				; CODE XREF: _aes_gcm_cipher+6Cj
		push	edi
		push	edx
		push	ecx
		lea	eax, [esi+100h]
		push	eax
		call	_CRYPTO_gcm128_encrypt

loc_141E:				; CODE XREF: _aes_gcm_cipher+C7j
		add	esp, 10h

loc_1421:				; CODE XREF: _aes_gcm_cipher+5Cj
					; _aes_gcm_cipher+81j ...
		test	eax, eax
		jz	short loc_1455
		pop	edi
		or	eax, 0FFFFFFFFh
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_142B:				; CODE XREF: _aes_gcm_cipher+68j
		test	eax, eax
		jz	short loc_1444
		push	eax
		push	edi
		push	edx
		push	ecx
		lea	eax, [esi+100h]
		push	eax
		call	_CRYPTO_gcm128_decrypt_ctr32
		add	esp, 14h
		jmp	short loc_1421
; ---------------------------------------------------------------------------

loc_1444:				; CODE XREF: _aes_gcm_cipher+A1j
		push	edi
		push	edx
		push	ecx
		lea	eax, [esi+100h]
		push	eax
		call	_CRYPTO_gcm128_decrypt
		jmp	short loc_141E
; ---------------------------------------------------------------------------

loc_1455:				; CODE XREF: _aes_gcm_cipher+97j
		mov	eax, edi
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_145A:				; CODE XREF: _aes_gcm_cipher+38j
		cmp	dword ptr [eax+8], 0
		jnz	short loc_148B
		mov	ecx, [esi+280h]
		test	ecx, ecx
		js	loc_139D
		push	ecx
		add	eax, 30h ; '0'
		push	eax
		lea	eax, [esi+100h]
		push	eax
		call	_CRYPTO_gcm128_finish
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_14AA
		or	eax, 0FFFFFFFFh
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_148B:				; CODE XREF: _aes_gcm_cipher+D2j
		add	eax, 30h ; '0'
		push	10h
		push	eax
		lea	eax, [esi+100h]
		push	eax
		call	_CRYPTO_gcm128_tag
		add	esp, 0Ch
		mov	dword ptr [esi+280h], 10h

loc_14AA:				; CODE XREF: _aes_gcm_cipher+F8j
		mov	dword ptr [esi+0FCh], 0
		xor	eax, eax
		pop	esi
		retn
_aes_gcm_cipher	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 14B8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_aesni_xts_init_key proc near		; DATA XREF: .rdata:00000014o
					; .rdata:0000007Co

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	ebp
		mov	ebp, [esp+8+arg_8]
		push	esi
		mov	esi, [ebx+60h]
		push	edi
		mov	edi, [esp+10h+arg_4]
		test	ebp, ebp
		jnz	short loc_14DB
		test	edi, edi
		jnz	short loc_14DF
		pop	edi
		pop	esi
		lea	eax, [ebp+1]
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_14DB:				; CODE XREF: _aesni_xts_init_key+15j
		test	edi, edi
		jz	short loc_1558

loc_14DF:				; CODE XREF: _aesni_xts_init_key+19j
		mov	eax, [ebx+58h]
		push	esi
		shl	eax, 2
		cmp	[esp+14h+arg_C], 0
		push	eax
		push	edi
		jz	short loc_150A
		call	_aesni_set_encrypt_key
		mov	dword ptr [esi+1F8h], offset _aesni_encrypt
		mov	dword ptr [esi+200h], offset _aesni_xts_encrypt
		jmp	short loc_1523
; ---------------------------------------------------------------------------

loc_150A:				; CODE XREF: _aesni_xts_init_key+35j
		call	_aesni_set_decrypt_key
		mov	dword ptr [esi+1F8h], offset _aesni_decrypt
		mov	dword ptr [esi+200h], offset _aesni_xts_decrypt

loc_1523:				; CODE XREF: _aesni_xts_init_key+50j
		mov	eax, [ebx+58h]
		lea	ecx, [esi+0F8h]
		add	esp, 0Ch
		push	ecx
		lea	ecx, ds:0[eax*4]
		cdq
		sub	eax, edx
		sar	eax, 1
		push	ecx
		add	eax, edi
		push	eax
		call	_aesni_set_encrypt_key
		add	esp, 0Ch
		mov	dword ptr [esi+1FCh], offset _aesni_encrypt
		mov	[esi+1F0h], esi

loc_1558:				; CODE XREF: _aesni_xts_init_key+25j
		test	ebp, ebp
		jz	short loc_1570
		lea	eax, [esi+0F8h]
		mov	[esi+1F4h], eax
		movups	xmm0, xmmword ptr [ebp+0]
		movups	xmmword	ptr [ebx+20h], xmm0

loc_1570:				; CODE XREF: _aesni_xts_init_key+A2j
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, 1
		pop	ebx
		retn
_aesni_xts_init_key endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 157Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_aes_xts_cipher	proc near		; DATA XREF: .rdata:00000018o
					; .rdata:0000004Co ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, 4
		call	__chkstk
		mov	eax, [esp+4+arg_0]
		push	ebx
		push	ebp
		mov	ecx, [eax+60h]
		mov	ebp, [ecx+1F0h]
		lea	ebx, [ecx+1F0h]
		test	ebp, ebp
		jz	loc_1623
		cmp	dword ptr [ecx+1F4h], 0
		jz	short loc_1623
		mov	edx, [esp+0Ch+arg_4]
		push	esi
		push	edi
		test	edx, edx
		jz	short loc_161B
		mov	esi, [esp+14h+arg_8]
		test	esi, esi
		jz	short loc_161B
		mov	edi, [esp+14h+arg_C]
		cmp	edi, 10h
		jb	short loc_161B
		mov	eax, [ecx+200h]
		test	eax, eax
		mov	[esp+14h+var_4], eax
		mov	eax, [esp+14h+arg_0]
		jz	short loc_15F9
		add	eax, 20h ; ' '
		push	eax
		push	dword ptr [ecx+1F4h]
		push	ebp
		push	edi
		push	edx
		push	esi
		call	[esp+2Ch+var_4]
		add	esp, 18h
		mov	eax, 1
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_15F9:				; CODE XREF: _aes_xts_cipher+5Bj
		push	dword ptr [eax+8]
		add	eax, 20h ; ' '
		push	edi
		push	edx
		push	esi
		push	eax
		push	ebx
		call	_CRYPTO_xts128_encrypt
		add	esp, 18h
		test	eax, eax
		jnz	short loc_161B
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, 1
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_161B:				; CODE XREF: _aes_xts_cipher+38j
					; _aes_xts_cipher+40j ...
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_1623:				; CODE XREF: _aes_xts_cipher+21j
					; _aes_xts_cipher+2Ej
		pop	ebp
		xor	eax, eax
		pop	ebx
		pop	ecx
		retn
_aes_xts_cipher	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 162Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl aesni_ccm_init_key(int, int, void	*Src, int)
_aesni_ccm_init_key proc near		; DATA XREF: .rdata:000000E4o
					; .rdata:0000014Co ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
Src		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	ecx, [esp+arg_4]
		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	esi
		push	edi
		mov	edi, [esp+0Ch+Src]
		mov	esi, [ebx+60h]
		test	edi, edi
		jnz	short loc_164D
		test	ecx, ecx
		jnz	short loc_1651
		lea	eax, [edi+1]
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_164D:				; CODE XREF: _aesni_ccm_init_key+14j
		test	ecx, ecx
		jz	short loc_16A2

loc_1651:				; CODE XREF: _aesni_ccm_init_key+18j
		mov	eax, [ebx+58h]
		push	esi
		shl	eax, 3
		push	eax
		push	ecx
		call	_aesni_set_encrypt_key
		push	offset _aesni_encrypt
		push	esi
		push	dword ptr [esi+108h]
		lea	eax, [esi+110h]
		push	dword ptr [esi+10Ch]
		push	eax
		call	_CRYPTO_ccm128_init
		add	esp, 20h
		mov	dword ptr [esi+0F8h], 1
		cmp	[esp+0Ch+arg_C], 0
		mov	eax, offset _aesni_ccm64_decrypt_blocks
		mov	ecx, offset _aesni_ccm64_encrypt_blocks
		cmovnz	eax, ecx
		mov	[esi+140h], eax

loc_16A2:				; CODE XREF: _aesni_ccm_init_key+23j
		test	edi, edi
		jz	short loc_16C9
		mov	eax, 0Fh
		sub	eax, [esi+108h]
		push	eax		; Size
		lea	eax, [ebx+20h]
		push	edi		; Src
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	dword ptr [esi+0FCh], 1

loc_16C9:				; CODE XREF: _aesni_ccm_init_key+78j
		pop	edi
		pop	esi
		mov	eax, 1
		pop	ebx
		retn
_aesni_ccm_init_key endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 16D4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_aes_ccm_cipher	proc near		; DATA XREF: .rdata:000000E8o
					; .rdata:0000011Co ...

var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= byte ptr -14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, 1Ch
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+1Ch+var_4], eax
		mov	ecx, [esp+1Ch+arg_0]
		mov	eax, [esp+1Ch+arg_4]
		push	ebx
		mov	ebx, [esp+20h+arg_8]
		push	ebp
		push	esi
		mov	esi, [ecx+60h]
		mov	[esp+28h+var_1C], ecx
		mov	[esp+28h+var_18], eax
		cmp	dword ptr [esi+0FCh], 0
		lea	ebp, [esi+110h]
		jnz	short loc_1730
		cmp	dword ptr [esi+0F8h], 0
		jnz	short loc_1730

loc_171B:				; CODE XREF: _aes_ccm_cipher+69j
		pop	esi
		pop	ebp
		or	eax, 0FFFFFFFFh
		pop	ebx
		mov	ecx, [esp+1Ch+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_1730:				; CODE XREF: _aes_ccm_cipher+3Cj
					; _aes_ccm_cipher+45j
		cmp	dword ptr [ecx+8], 0
		jnz	short loc_173F
		cmp	dword ptr [esi+100h], 0
		jz	short loc_171B

loc_173F:				; CODE XREF: _aes_ccm_cipher+60j
		push	edi
		test	eax, eax
		jnz	short loc_17C2
		test	ebx, ebx
		jnz	short loc_178D
		mov	edi, [esp+2Ch+arg_C]
		mov	eax, 0Fh
		sub	eax, [esi+108h]
		push	edi
		push	eax
		lea	eax, [ecx+20h]
		push	eax
		push	ebp
		call	_CRYPTO_ccm128_setiv
		add	esp, 10h
		test	eax, eax
		jnz	loc_1847
		mov	eax, edi
		mov	dword ptr [esi+104h], 1
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+1Ch+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_178D:				; CODE XREF: _aes_ccm_cipher+72j
		cmp	dword ptr [esi+104h], 0
		mov	esi, [esp+2Ch+arg_C]
		jnz	short loc_17A2
		test	esi, esi
		jnz	loc_1847

loc_17A2:				; CODE XREF: _aes_ccm_cipher+C4j
		push	esi
		push	ebx
		push	ebp
		call	_CRYPTO_ccm128_aad
		add	esp, 0Ch
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+1Ch+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_17C2:				; CODE XREF: _aes_ccm_cipher+6Ej
		test	ebx, ebx
		jnz	short loc_17DB
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		mov	ecx, [esp+1Ch+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_17DB:				; CODE XREF: _aes_ccm_cipher+F0j
		cmp	dword ptr [esi+104h], 0
		mov	edi, [esp+2Ch+arg_C]
		jnz	short loc_1818
		push	edi
		mov	eax, 0Fh
		sub	eax, [esi+108h]
		push	eax
		lea	eax, [ecx+20h]
		push	eax
		push	ebp
		call	_CRYPTO_ccm128_setiv
		add	esp, 10h
		test	eax, eax
		jnz	short loc_1847
		mov	ecx, [esp+2Ch+var_1C]
		mov	eax, [esp+2Ch+var_18]
		mov	dword ptr [esi+104h], 1

loc_1818:				; CODE XREF: _aes_ccm_cipher+112j
		cmp	dword ptr [ecx+8], 0
		mov	ecx, [esi+140h]
		jz	short loc_187C
		test	ecx, ecx
		jz	short loc_1837
		push	ecx
		push	edi
		push	eax
		push	ebx
		push	ebp
		call	_CRYPTO_ccm128_encrypt_ccm64
		add	esp, 14h
		jmp	short loc_1843
; ---------------------------------------------------------------------------

loc_1837:				; CODE XREF: _aes_ccm_cipher+152j
		push	edi
		push	eax
		push	ebx
		push	ebp
		call	_CRYPTO_ccm128_encrypt
		add	esp, 10h

loc_1843:				; CODE XREF: _aes_ccm_cipher+161j
		test	eax, eax
		jz	short loc_185D

loc_1847:				; CODE XREF: _aes_ccm_cipher+94j
					; _aes_ccm_cipher+C8j ...
		pop	edi
		pop	esi
		pop	ebp
		or	eax, 0FFFFFFFFh
		pop	ebx
		mov	ecx, [esp+1Ch+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_185D:				; CODE XREF: _aes_ccm_cipher+171j
		mov	eax, edi
		mov	dword ptr [esi+100h], 1
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+1Ch+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_187C:				; CODE XREF: _aes_ccm_cipher+14Ej
		test	ecx, ecx
		jz	short loc_188F
		push	ecx
		push	edi
		push	eax
		push	ebx
		push	ebp
		call	_CRYPTO_ccm128_decrypt_ccm64
		add	esp, 14h
		jmp	short loc_189B
; ---------------------------------------------------------------------------

loc_188F:				; CODE XREF: _aes_ccm_cipher+1AAj
		push	edi
		push	eax
		push	ebx
		push	ebp
		call	_CRYPTO_ccm128_decrypt
		add	esp, 10h

loc_189B:				; CODE XREF: _aes_ccm_cipher+1B9j
		neg	eax
		sbb	eax, eax
		inc	eax
		test	eax, eax
		jz	short loc_18E4
		push	dword ptr [esi+10Ch]
		lea	eax, [esp+30h+var_14]
		push	eax
		push	ebp
		call	_CRYPTO_ccm128_tag
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_18E4
		push	dword ptr [esi+10Ch]
		mov	eax, [esp+30h+var_1C]
		add	eax, 30h ; '0'
		push	eax
		lea	eax, [esp+34h+var_14]
		push	eax
		call	_CRYPTO_memcmp
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_18E4
		mov	ebx, edi
		cmp	edi, 0FFFFFFFFh
		jnz	short loc_18F4
		jmp	short loc_18E7
; ---------------------------------------------------------------------------

loc_18E4:				; CODE XREF: _aes_ccm_cipher+1CEj
					; _aes_ccm_cipher+1E6j	...
		or	ebx, 0FFFFFFFFh

loc_18E7:				; CODE XREF: _aes_ccm_cipher+20Ej
		push	edi
		push	[esp+30h+var_18]
		call	_OPENSSL_cleanse
		add	esp, 8

loc_18F4:				; CODE XREF: _aes_ccm_cipher+20Cj
		mov	ecx, [esp+2Ch+var_4]
		mov	eax, ebx
		pop	edi
		mov	dword ptr [esi+0FCh], 0
		mov	dword ptr [esi+100h], 0
		mov	dword ptr [esi+104h], 0
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1Ch
		retn
_aes_ccm_cipher	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1928h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_aes_init_key	proc near		; DATA XREF: .rdata:000002ECo
					; .rdata:00000354o ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_C		= dword	ptr  10h

		mov	ecx, [esp+arg_0]
		push	esi
		push	edi
		mov	eax, [ecx]
		mov	edi, [ecx+60h]
		mov	esi, [eax+10h]
		and	esi, 0F0007h
		cmp	esi, 1
		jz	short loc_1946
		cmp	esi, 2
		jnz	short loc_199F

loc_1946:				; CODE XREF: _aes_init_key+17j
		cmp	[esp+8+arg_C], 0
		jnz	short loc_199F
		mov	eax, [ecx+58h]
		push	edi
		shl	eax, 3
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 200h
		push	eax
		push	[esp+10h+arg_4]
		jz	short loc_198E
		call	_vpaes_set_decrypt_key
		xor	ecx, ecx
		mov	dword ptr [edi+0F8h], offset _vpaes_decrypt
		add	esp, 0Ch
		mov	edx, eax
		cmp	esi, 2
		mov	eax, offset _vpaes_cbc_encrypt
		cmovz	ecx, eax
		mov	[edi+0FCh], ecx
		jmp	short loc_19F4
; ---------------------------------------------------------------------------

loc_198E:				; CODE XREF: _aes_init_key+3Bj
		call	_AES_set_decrypt_key
		mov	dword ptr [edi+0F8h], offset _AES_decrypt
		jmp	short loc_19DC
; ---------------------------------------------------------------------------

loc_199F:				; CODE XREF: _aes_init_key+1Cj
					; _aes_init_key+23j
		mov	eax, [ecx+58h]
		push	edi
		shl	eax, 3
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 200h
		push	eax
		push	[esp+10h+arg_4]
		jz	short loc_19CD
		call	_vpaes_set_encrypt_key
		mov	dword ptr [edi+0F8h], offset _vpaes_encrypt
		mov	ecx, offset _vpaes_cbc_encrypt
		jmp	short loc_19E1
; ---------------------------------------------------------------------------

loc_19CD:				; CODE XREF: _aes_init_key+8Dj
		call	_AES_set_encrypt_key
		mov	dword ptr [edi+0F8h], offset _AES_encrypt

loc_19DC:				; CODE XREF: _aes_init_key+75j
		mov	ecx, offset _AES_cbc_encrypt

loc_19E1:				; CODE XREF: _aes_init_key+A3j
		mov	edx, eax
		add	esp, 0Ch
		xor	eax, eax
		cmp	esi, 2
		cmovz	eax, ecx
		mov	[edi+0FCh], eax

loc_19F4:				; CODE XREF: _aes_init_key+64j
		pop	edi
		pop	esi
		test	edx, edx
		jns	short loc_1A1B
		push	3F1h
		push	offset ??_C@_0BF@PJIDMOFK@?4?2crypto?2evp?2e_aes?4c?$AA@ ; ".\\crypto\\evp\\e_aes.c"
		push	8Fh ; 'è'
		push	85h ; 'Ö'
		push	6
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1A1B:				; CODE XREF: _aes_init_key+D0j
		mov	eax, 1
		retn
_aes_init_key	endp ; sp-analysis failed

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1A24h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_aes_cbc_cipher	proc near		; DATA XREF: .rdata:000002F0o
					; .rdata:000005C8o ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, [esp+arg_0]
		mov	ecx, [eax+60h]
		mov	edx, [ecx+0FCh]
		test	edx, edx
		jz	short loc_1A54
		push	dword ptr [eax+8]
		add	eax, 20h ; ' '
		push	eax
		push	ecx
		push	[esp+0Ch+arg_C]
		push	[esp+10h+arg_4]
		push	[esp+14h+arg_8]
		call	edx
		add	esp, 18h
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_1A54:				; CODE XREF: _aes_cbc_cipher+Fj
		cmp	dword ptr [eax+8], 0
		push	dword ptr [ecx+0F8h]
		jz	short loc_1A7F
		add	eax, 20h ; ' '
		push	eax
		push	ecx
		push	[esp+0Ch+arg_C]
		push	[esp+10h+arg_4]
		push	[esp+14h+arg_8]
		call	_CRYPTO_cbc128_encrypt
		add	esp, 18h
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_1A7F:				; CODE XREF: _aes_cbc_cipher+3Aj
		add	eax, 20h ; ' '
		push	eax
		push	ecx
		push	[esp+0Ch+arg_C]
		push	[esp+10h+arg_4]
		push	[esp+14h+arg_8]
		call	_CRYPTO_cbc128_decrypt
		add	esp, 18h
		mov	eax, 1
		retn
_aes_cbc_cipher	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1AA0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_aes_ecb_cipher	proc near		; DATA XREF: .rdata:00000358o
					; .rdata:00000630o ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	ecx, [esp+arg_0]
		push	ebp
		mov	ebp, [esp+4+arg_C]
		push	edi
		mov	eax, [ecx]
		mov	ecx, [ecx+60h]
		mov	[esp+8+arg_0], ecx
		mov	edi, [eax+4]
		cmp	ebp, edi
		jb	short loc_1AF2
		mov	eax, [esp+8+arg_4]
		sub	ebp, edi
		push	ebx
		push	esi
		mov	esi, [esp+10h+arg_8]
		xor	ebx, ebx
		sub	eax, esi
		mov	[esp+10h+arg_4], eax
		xchg	ax, ax

loc_1AD0:				; CODE XREF: _aes_ecb_cipher+4Ej
		push	ecx
		add	eax, esi
		push	eax
		mov	eax, [ecx+0F8h]
		push	esi
		call	eax
		mov	ecx, [esp+1Ch+arg_0]
		add	ebx, edi
		mov	eax, [esp+1Ch+arg_4]
		add	esp, 0Ch
		add	esi, edi
		cmp	ebx, ebp
		jbe	short loc_1AD0
		pop	esi
		pop	ebx

loc_1AF2:				; CODE XREF: _aes_ecb_cipher+18j
		pop	edi
		mov	eax, 1
		pop	ebp
		retn
_aes_ecb_cipher	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1AFCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_aes_gcm_cleanup proc near		; DATA XREF: .rdata:00000B48o
					; .rdata:00000B7Co ...

arg_0		= dword	ptr  4

		push	esi
		push	edi
		mov	edi, [esp+8+arg_0]
		push	178h
		mov	esi, [edi+60h]
		lea	eax, [esi+100h]
		push	eax
		call	_OPENSSL_cleanse
		mov	ecx, [esi+278h]
		lea	eax, [edi+20h]
		add	esp, 8
		pop	edi
		pop	esi
		cmp	ecx, eax
		jz	short loc_1B31
		push	ecx
		call	_CRYPTO_free
		add	esp, 4

loc_1B31:				; CODE XREF: _aes_gcm_cleanup+2Aj
		mov	eax, 1
		retn
_aes_gcm_cleanup endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1B38h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl aes_gcm_ctrl(int,	int, size_t Size, void *Src)
_aes_gcm_ctrl	proc near		; DATA XREF: .rdata:00000B58o
					; .rdata:00000B8Co ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
Size		= dword	ptr  0Ch
Src		= dword	ptr  10h

		mov	eax, [esp+arg_4]
		push	ebx
		push	esi
		push	edi
		mov	edi, [esp+0Ch+arg_0]
		mov	esi, [edi+60h]
		cmp	eax, 18h	; switch 25 cases
		ja	$LN39		; jumptable 00001B56 default case
		movzx	eax, ds:$LN51[eax]
		jmp	ds:$LN54[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN4:					; CODE XREF: _aes_gcm_ctrl+1Ej
					; DATA XREF: .text$mn:$LN54o
		mov	dword ptr [esi+0F8h], 0	; jumptable 00001B56 case 0
		mov	dword ptr [esi+0FCh], 0
		mov	eax, [edi]
		mov	eax, [eax+0Ch]
		mov	[esi+27Ch], eax
		lea	eax, [edi+20h]
		pop	edi
		mov	[esi+278h], eax
		mov	eax, 1
		mov	dword ptr [esi+280h], 0FFFFFFFFh
		mov	dword ptr [esi+284h], 0
		mov	dword ptr [esi+288h], 0FFFFFFFFh
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN5:					; CODE XREF: _aes_gcm_ctrl+1Ej
					; DATA XREF: .text$mn:$LN54o
		mov	ebx, [esp+0Ch+Size] ; jumptable	00001B56 case 9
		test	ebx, ebx
		jg	short loc_1BBA

loc_1BB4:				; CODE XREF: _aes_gcm_ctrl+C0j
					; _aes_gcm_ctrl+DBj ...
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1BBA:				; CODE XREF: _aes_gcm_ctrl+7Aj
		cmp	ebx, 10h
		jle	short loc_1BFA
		cmp	ebx, [esi+27Ch]
		jle	short loc_1BFA
		mov	ecx, [esi+278h]
		lea	eax, [edi+20h]
		cmp	ecx, eax
		jz	short loc_1BDD
		push	ecx
		call	_CRYPTO_free
		add	esp, 4

loc_1BDD:				; CODE XREF: _aes_gcm_ctrl+9Aj
		push	48Eh
		push	offset ??_C@_0BF@PJIDMOFK@?4?2crypto?2evp?2e_aes?4c?$AA@ ; ".\\crypto\\evp\\e_aes.c"
		push	ebx
		call	_CRYPTO_malloc
		add	esp, 0Ch
		mov	[esi+278h], eax
		test	eax, eax
		jz	short loc_1BB4

loc_1BFA:				; CODE XREF: _aes_gcm_ctrl+85j
					; _aes_gcm_ctrl+8Dj
		pop	edi
		mov	[esi+27Ch], ebx
		mov	eax, 1
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN10:					; CODE XREF: _aes_gcm_ctrl+1Ej
					; DATA XREF: .text$mn:$LN54o
		mov	ebx, [esp+0Ch+Size] ; jumptable	00001B56 case 17
		lea	eax, [ebx-1]
		cmp	eax, 0Fh
		ja	short loc_1BB4
		cmp	dword ptr [edi+8], 0
		jnz	short loc_1BB4
		push	ebx		; Size
		push	[esp+10h+Src]	; Src
		lea	eax, [edi+30h]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	[esi+280h], ebx
		mov	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN13:					; CODE XREF: _aes_gcm_ctrl+1Ej
					; DATA XREF: .text$mn:$LN54o
		mov	ecx, [esp+0Ch+Size] ; jumptable	00001B56 case 16
		lea	eax, [ecx-1]
		cmp	eax, 0Fh
		ja	loc_1BB4
		cmp	dword ptr [edi+8], 0
		jz	loc_1BB4
		cmp	dword ptr [esi+280h], 0
		jl	loc_1BB4
		push	ecx		; Size
		lea	eax, [edi+30h]
		push	eax		; Src
		push	[esp+14h+Src]	; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN16:					; CODE XREF: _aes_gcm_ctrl+1Ej
					; DATA XREF: .text$mn:$LN54o
		mov	ebx, [esp+0Ch+Size] ; jumptable	00001B56 case 18
		cmp	ebx, 0FFFFFFFFh
		jnz	short loc_1CB0
		push	dword ptr [esi+27Ch] ; Size
		push	[esp+10h+Src]	; Src
		push	dword ptr [esi+278h] ; Dst
		call	_memcpy
		add	esp, 0Ch

loc_1C9D:				; CODE XREF: _aes_gcm_ctrl+1A9j
					; _aes_gcm_ctrl+1C7j
		pop	edi
		mov	dword ptr [esi+284h], 1
		mov	eax, 1
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1CB0:				; CODE XREF: _aes_gcm_ctrl+14Bj
		cmp	ebx, 4
		jl	loc_1BB4
		mov	eax, [esi+27Ch]
		sub	eax, ebx
		cmp	eax, 8
		jl	loc_1BB4
		push	ebx		; Size
		push	[esp+10h+Src]	; Src
		push	dword ptr [esi+278h] ; Dst
		call	_memcpy
		add	esp, 0Ch
		cmp	dword ptr [edi+8], 0
		jz	short loc_1C9D
		mov	eax, [esi+27Ch]
		sub	eax, ebx
		push	eax
		mov	eax, [esi+278h]
		add	eax, ebx
		push	eax
		call	_RAND_bytes
		add	esp, 8
		test	eax, eax
		jg	short loc_1C9D
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN22:					; CODE XREF: _aes_gcm_ctrl+1Ej
					; DATA XREF: .text$mn:$LN54o
		cmp	dword ptr [esi+284h], 0	; jumptable 00001B56 case 19
		jz	loc_1BB4
		cmp	dword ptr [esi+0F8h], 0
		jz	loc_1BB4
		push	dword ptr [esi+27Ch]
		lea	eax, [esi+100h]
		push	dword ptr [esi+278h]
		push	eax
		call	_CRYPTO_gcm128_setiv
		mov	ecx, [esp+18h+Size]
		add	esp, 0Ch
		test	ecx, ecx
		jle	short loc_1D4E
		mov	eax, [esi+27Ch]
		cmp	ecx, eax
		jle	short loc_1D56

loc_1D4E:				; CODE XREF: _aes_gcm_ctrl+20Aj
		mov	eax, [esi+27Ch]
		mov	ecx, eax

loc_1D56:				; CODE XREF: _aes_gcm_ctrl+214j
		sub	eax, ecx
		add	eax, [esi+278h]
		push	ecx		; Size
		push	eax		; Src
		push	[esp+14h+Src]	; Dst
		call	_memcpy
		mov	edx, [esi+27Ch]
		add	esp, 0Ch
		add	edx, [esi+278h]
		mov	ecx, 8

loc_1D7D:				; CODE XREF: _aes_gcm_ctrl+24Fj
		dec	ecx
		add	byte ptr [ecx+edx-8], 1
		jnz	short loc_1D89
		test	ecx, ecx
		jnz	short loc_1D7D

loc_1D89:				; CODE XREF: _aes_gcm_ctrl+24Bj
		pop	edi
		mov	dword ptr [esi+0FCh], 1
		mov	eax, 1
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN27:					; CODE XREF: _aes_gcm_ctrl+1Ej
					; DATA XREF: .text$mn:$LN54o
		cmp	dword ptr [esi+284h], 0	; jumptable 00001B56 case 24
		jz	loc_1BB4
		cmp	dword ptr [esi+0F8h], 0
		jz	loc_1BB4
		cmp	dword ptr [edi+8], 0
		jnz	loc_1BB4
		mov	ecx, [esp+0Ch+Size]
		mov	eax, [esi+27Ch]
		push	ecx		; Size
		push	[esp+10h+Src]	; Src
		sub	eax, ecx
		add	eax, [esi+278h]
		push	eax		; Dst
		call	_memcpy
		push	dword ptr [esi+27Ch]
		lea	eax, [esi+100h]
		push	dword ptr [esi+278h]
		push	eax
		call	_CRYPTO_gcm128_setiv
		add	esp, 18h
		mov	dword ptr [esi+0FCh], 1
		mov	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN30:					; CODE XREF: _aes_gcm_ctrl+1Ej
					; DATA XREF: .text$mn:$LN54o
		cmp	[esp+0Ch+Size],	0Dh ; jumptable	00001B56 case 22
		jnz	loc_1BB4
		mov	ecx, [esp+0Ch+Src]
		movq	xmm0, qword ptr	[ecx]
		movq	qword ptr [edi+30h], xmm0
		mov	eax, [ecx+8]
		mov	[edi+38h], eax
		mov	al, [ecx+0Ch]
		mov	[edi+3Ch], al
		mov	dword ptr [esi+288h], 0Dh
		movzx	ecx, byte ptr [edi+3Bh]
		movzx	eax, byte ptr [edi+3Ch]
		shl	ecx, 8
		or	ecx, eax
		sub	ecx, 8
		cmp	dword ptr [edi+8], 0
		jnz	short loc_1E52
		sub	ecx, 10h

loc_1E52:				; CODE XREF: _aes_gcm_ctrl+315j
		mov	eax, ecx
		mov	[edi+3Ch], cl
		shr	eax, 8
		mov	[edi+3Bh], al
		mov	eax, 10h
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN33:					; CODE XREF: _aes_gcm_ctrl+1Ej
					; DATA XREF: .text$mn:$LN54o
		mov	ecx, [esp+0Ch+Src] ; jumptable 00001B56	case 8
		mov	eax, [esi+274h]
		mov	ebx, [ecx+60h]
		test	eax, eax
		jz	short loc_1E85
		cmp	eax, esi
		jnz	loc_1BB4
		mov	[ebx+274h], ebx

loc_1E85:				; CODE XREF: _aes_gcm_ctrl+33Dj
		lea	eax, [edi+20h]
		cmp	[esi+278h], eax
		jnz	short loc_1EA2
		pop	edi
		lea	eax, [ecx+20h]
		mov	[ebx+278h], eax
		mov	eax, 1
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1EA2:				; CODE XREF: _aes_gcm_ctrl+356j
		push	4ECh
		push	offset ??_C@_0BF@PJIDMOFK@?4?2crypto?2evp?2e_aes?4c?$AA@ ; ".\\crypto\\evp\\e_aes.c"
		push	dword ptr [esi+27Ch]
		call	_CRYPTO_malloc
		add	esp, 0Ch
		mov	[ebx+278h], eax
		test	eax, eax
		jz	loc_1BB4
		push	dword ptr [esi+27Ch] ; Size
		push	dword ptr [esi+278h] ; Src
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN39:					; CODE XREF: _aes_gcm_ctrl+11j
					; _aes_gcm_ctrl+1Ej
					; DATA XREF: ...
		pop	edi		; jumptable 00001B56 default case
		pop	esi
		or	eax, 0FFFFFFFFh
		pop	ebx
		retn
_aes_gcm_ctrl	endp

; ---------------------------------------------------------------------------
		align 10h
$LN54		dd offset $LN4		; DATA XREF: _aes_gcm_ctrl+1Er
		dd offset $LN33		; jump table for switch	statement
		dd offset $LN5
		dd offset $LN13
		dd offset $LN10
		dd offset $LN16
		dd offset $LN22
		dd offset $LN30
		dd offset $LN27
		dd offset $LN39
$LN51		db	0,     9,     9,     9 ; DATA XREF: _aes_gcm_ctrl+17r
		db	9,     9,     9,     9 ; indirect table	for switch statement
		db	1,     2,     9,     9
		db	9,     9,     9,     9
		db	3,     4,     5,     6
		db	9,     9,     7,     9
		db	8
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1F34h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl aes_gcm_init_key(int, int, void *Src)
_aes_gcm_init_key proc near		; DATA XREF: .rdata:00000B74o
					; .rdata:00000BDCo ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
Src		= dword	ptr  0Ch

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		push	esi
		push	edi
		mov	edi, [esp+8+Src]
		mov	esi, [eax+60h]
		test	edi, edi
		jnz	short loc_1F53
		test	ecx, ecx
		jnz	short loc_1F5B
		lea	eax, [edi+1]
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1F53:				; CODE XREF: _aes_gcm_init_key+13j
		test	ecx, ecx
		jz	loc_1FE4

loc_1F5B:				; CODE XREF: _aes_gcm_init_key+17j
		mov	eax, [eax+58h]
		push	ebx
		push	esi
		shl	eax, 3
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 200h
		push	eax
		push	ecx
		jz	short loc_1F7D
		call	_vpaes_set_encrypt_key
		push	offset _vpaes_encrypt
		jmp	short loc_1F87
; ---------------------------------------------------------------------------

loc_1F7D:				; CODE XREF: _aes_gcm_init_key+3Bj
		call	_AES_set_encrypt_key
		push	offset _AES_encrypt

loc_1F87:				; CODE XREF: _aes_gcm_init_key+47j
		push	esi
		lea	ebx, [esi+100h]
		push	ebx
		call	_CRYPTO_gcm128_init
		add	esp, 18h
		mov	dword ptr [esi+28Ch], 0
		test	edi, edi
		jnz	short loc_1FB7
		cmp	[esi+0FCh], edi
		jz	short loc_1FD1
		mov	edi, [esi+278h]
		test	edi, edi
		jz	short loc_1FD1

loc_1FB7:				; CODE XREF: _aes_gcm_init_key+6Fj
		push	dword ptr [esi+27Ch]
		push	edi
		push	ebx
		call	_CRYPTO_gcm128_setiv
		add	esp, 0Ch
		mov	dword ptr [esi+0FCh], 1

loc_1FD1:				; CODE XREF: _aes_gcm_init_key+77j
					; _aes_gcm_init_key+81j
		pop	ebx
		pop	edi
		mov	dword ptr [esi+0F8h], 1
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1FE4:				; CODE XREF: _aes_gcm_init_key+21j
		cmp	dword ptr [esi+0F8h], 0
		push	dword ptr [esi+27Ch] ; Size
		push	edi		; Src
		jz	short loc_2002
		lea	eax, [esi+100h]
		push	eax
		call	_CRYPTO_gcm128_setiv

loc_2000:				; DATA XREF: .rdata:off_1A7o
		jmp	short loc_200D
; ---------------------------------------------------------------------------

loc_2002:				; CODE XREF: _aes_gcm_init_key+BEj
		push	dword ptr [esi+278h] ; Dst
		call	_memcpy

loc_200D:				; CODE XREF: _aes_gcm_init_key:loc_2000j
		add	esp, 0Ch
		mov	dword ptr [esi+0FCh], 1
		mov	dword ptr [esi+284h], 0
		mov	eax, 1
		pop	edi
		pop	esi
		retn
_aes_gcm_init_key endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 202Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_aes_xts_ctrl	proc near		; DATA XREF: .rdata:0000002Co
					; .rdata:00000060o ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_C		= dword	ptr  10h

		mov	eax, [esp+arg_0]
		mov	ecx, [eax+60h]
		mov	eax, [esp+arg_4]
		cmp	eax, 8
		jnz	short loc_2083
		mov	eax, [esp+arg_C]
		mov	edx, [eax+60h]
		mov	eax, [ecx+1F0h]
		test	eax, eax
		jz	short loc_205A
		cmp	eax, ecx
		jz	short loc_2054

loc_2051:				; CODE XREF: _aes_xts_ctrl+43j
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_2054:				; CODE XREF: _aes_xts_ctrl+23j
		mov	[edx+1F0h], edx

loc_205A:				; CODE XREF: _aes_xts_ctrl+1Fj
		cmp	dword ptr [ecx+1F4h], 0
		jz	short loc_209F
		lea	eax, [ecx+0F8h]
		cmp	[ecx+1F4h], eax
		jnz	short loc_2051
		lea	eax, [edx+0F8h]
		mov	[edx+1F4h], eax
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_2083:				; CODE XREF: _aes_xts_ctrl+Ej
		test	eax, eax
		jz	short loc_208B
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_208B:				; CODE XREF: _aes_xts_ctrl+59j
		mov	dword ptr [ecx+1F0h], 0
		mov	dword ptr [ecx+1F4h], 0

loc_209F:				; CODE XREF: _aes_xts_ctrl+35j
		mov	eax, 1
		retn
_aes_xts_ctrl	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 20A8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_aes_xts_init_key proc near		; DATA XREF: .rdata:00000048o
					; .rdata:000000B0o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	ebp
		mov	ebp, [esp+8+arg_8]
		push	esi
		mov	esi, [ebx+60h]
		push	edi
		mov	edi, [esp+10h+arg_4]
		test	ebp, ebp
		jnz	short loc_20CB
		test	edi, edi
		jnz	short loc_20D3
		pop	edi
		pop	esi
		lea	eax, [ebp+1]
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_20CB:				; CODE XREF: _aes_xts_init_key+15j
		test	edi, edi
		jz	loc_21A3

loc_20D3:				; CODE XREF: _aes_xts_init_key+19j
		mov	dword ptr [esi+200h], 0
		mov	eax, [ebx+58h]
		push	esi
		shl	eax, 2
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 200h
		push	eax
		push	edi
		jz	short loc_2147
		cmp	[esp+1Ch+arg_C], 0
		jz	short loc_210A
		call	_vpaes_set_encrypt_key
		mov	dword ptr [esi+1F8h], offset _vpaes_encrypt
		jmp	short loc_2119
; ---------------------------------------------------------------------------

loc_210A:				; CODE XREF: _aes_xts_init_key+4Fj
		call	_vpaes_set_decrypt_key
		mov	dword ptr [esi+1F8h], offset _vpaes_decrypt

loc_2119:				; CODE XREF: _aes_xts_init_key+60j
		mov	eax, [ebx+58h]
		lea	ecx, [esi+0F8h]
		add	esp, 0Ch
		push	ecx
		lea	ecx, ds:0[eax*4]
		cdq
		sub	eax, edx
		sar	eax, 1
		push	ecx
		add	eax, edi
		push	eax
		call	_vpaes_set_encrypt_key
		mov	dword ptr [esi+1FCh], offset _vpaes_encrypt
		jmp	short loc_219A
; ---------------------------------------------------------------------------

loc_2147:				; CODE XREF: _aes_xts_init_key+48j
		cmp	[esp+1Ch+arg_C], 0
		jz	short loc_215F
		call	_AES_set_encrypt_key
		mov	dword ptr [esi+1F8h], offset _AES_encrypt
		jmp	short loc_216E
; ---------------------------------------------------------------------------

loc_215F:				; CODE XREF: _aes_xts_init_key+A4j
		call	_AES_set_decrypt_key
		mov	dword ptr [esi+1F8h], offset _AES_decrypt

loc_216E:				; CODE XREF: _aes_xts_init_key+B5j
		mov	eax, [ebx+58h]
		lea	ecx, [esi+0F8h]
		add	esp, 0Ch
		push	ecx
		lea	ecx, ds:0[eax*4]
		cdq
		sub	eax, edx
		sar	eax, 1
		push	ecx
		add	eax, edi
		push	eax
		call	_AES_set_encrypt_key
		mov	dword ptr [esi+1FCh], offset _AES_encrypt

loc_219A:				; CODE XREF: _aes_xts_init_key+9Dj
		mov	[esi+1F0h], esi
		add	esp, 0Ch

loc_21A3:				; CODE XREF: _aes_xts_init_key+25j
		test	ebp, ebp
		jz	short loc_21BB
		lea	eax, [esi+0F8h]
		mov	[esi+1F4h], eax
		movups	xmm0, xmmword ptr [ebp+0]
		movups	xmmword	ptr [ebx+20h], xmm0

loc_21BB:				; CODE XREF: _aes_xts_init_key+FDj
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, 1
		pop	ebx
		retn
_aes_xts_init_key endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 21C8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_128_cbc
_EVP_aes_128_cbc proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_128_cbc
		mov	ecx, offset _aes_128_cbc
		cmovz	eax, ecx
		retn
_EVP_aes_128_cbc endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 21E0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_128_ccm
_EVP_aes_128_ccm proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_128_ccm
		mov	ecx, offset _aes_128_ccm
		cmovz	eax, ecx
		retn
_EVP_aes_128_ccm endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 21F8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_128_cfb1
_EVP_aes_128_cfb1 proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_128_cfb1
		mov	ecx, offset _aes_128_cfb1
		cmovz	eax, ecx
		retn
_EVP_aes_128_cfb1 endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2210h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_128_cfb128
_EVP_aes_128_cfb128 proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_128_cfb
		mov	ecx, offset _aes_128_cfb
		cmovz	eax, ecx
		retn
_EVP_aes_128_cfb128 endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2228h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_128_cfb8
_EVP_aes_128_cfb8 proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_128_cfb8
		mov	ecx, offset _aes_128_cfb8
		cmovz	eax, ecx
		retn
_EVP_aes_128_cfb8 endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2240h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_128_ctr
_EVP_aes_128_ctr proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_128_ctr
		mov	ecx, offset _aes_128_ctr
		cmovz	eax, ecx
		retn
_EVP_aes_128_ctr endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2258h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_128_ecb
_EVP_aes_128_ecb proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_128_ecb
		mov	ecx, offset _aes_128_ecb
		cmovz	eax, ecx
		retn
_EVP_aes_128_ecb endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2270h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_128_gcm
_EVP_aes_128_gcm proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_128_gcm
		mov	ecx, offset _aes_128_gcm
		cmovz	eax, ecx
		retn
_EVP_aes_128_gcm endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2288h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_128_ofb
_EVP_aes_128_ofb proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_128_ofb
		mov	ecx, offset _aes_128_ofb
		cmovz	eax, ecx
		retn
_EVP_aes_128_ofb endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 22A0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_128_wrap
_EVP_aes_128_wrap proc near
		mov	eax, offset _aes_128_wrap
		retn
_EVP_aes_128_wrap endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 22A8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_128_xts
_EVP_aes_128_xts proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_128_xts
		mov	ecx, offset _aes_128_xts
		cmovz	eax, ecx
		retn
_EVP_aes_128_xts endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 22C0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_192_cbc
_EVP_aes_192_cbc proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_192_cbc
		mov	ecx, offset _aes_192_cbc
		cmovz	eax, ecx
		retn
_EVP_aes_192_cbc endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 22D8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_192_ccm
_EVP_aes_192_ccm proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_192_ccm
		mov	ecx, offset _aes_192_ccm
		cmovz	eax, ecx
		retn
_EVP_aes_192_ccm endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 22F0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_192_cfb1
_EVP_aes_192_cfb1 proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_192_cfb1
		mov	ecx, offset _aes_192_cfb1
		cmovz	eax, ecx
		retn
_EVP_aes_192_cfb1 endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2308h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_192_cfb128
_EVP_aes_192_cfb128 proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_192_cfb
		mov	ecx, offset _aes_192_cfb
		cmovz	eax, ecx
		retn
_EVP_aes_192_cfb128 endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2320h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_192_cfb8
_EVP_aes_192_cfb8 proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_192_cfb8
		mov	ecx, offset _aes_192_cfb8
		cmovz	eax, ecx
		retn
_EVP_aes_192_cfb8 endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2338h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_192_ctr
_EVP_aes_192_ctr proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_192_ctr
		mov	ecx, offset _aes_192_ctr
		cmovz	eax, ecx
		retn
_EVP_aes_192_ctr endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2350h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_192_ecb
_EVP_aes_192_ecb proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_192_ecb
		mov	ecx, offset _aes_192_ecb
		cmovz	eax, ecx
		retn
_EVP_aes_192_ecb endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2368h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_192_gcm
_EVP_aes_192_gcm proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_192_gcm
		mov	ecx, offset _aes_192_gcm
		cmovz	eax, ecx
		retn
_EVP_aes_192_gcm endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2380h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_192_ofb
_EVP_aes_192_ofb proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_192_ofb
		mov	ecx, offset _aes_192_ofb
		cmovz	eax, ecx
		retn
_EVP_aes_192_ofb endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2398h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_192_wrap
_EVP_aes_192_wrap proc near
		mov	eax, offset _aes_192_wrap
		retn
_EVP_aes_192_wrap endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 23A0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_256_cbc
_EVP_aes_256_cbc proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_256_cbc
		mov	ecx, offset _aes_256_cbc
		cmovz	eax, ecx
		retn
_EVP_aes_256_cbc endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 23B8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_256_ccm
_EVP_aes_256_ccm proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_256_ccm
		mov	ecx, offset _aes_256_ccm
		cmovz	eax, ecx
		retn
_EVP_aes_256_ccm endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 23D0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_256_cfb1
_EVP_aes_256_cfb1 proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_256_cfb1
		mov	ecx, offset _aes_256_cfb1
		cmovz	eax, ecx
		retn
_EVP_aes_256_cfb1 endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 23E8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_256_cfb128
_EVP_aes_256_cfb128 proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_256_cfb
		mov	ecx, offset _aes_256_cfb
		cmovz	eax, ecx
		retn
_EVP_aes_256_cfb128 endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2400h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_256_cfb8
_EVP_aes_256_cfb8 proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_256_cfb8
		mov	ecx, offset _aes_256_cfb8
		cmovz	eax, ecx
		retn
_EVP_aes_256_cfb8 endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2418h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_256_ctr
_EVP_aes_256_ctr proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_256_ctr
		mov	ecx, offset _aes_256_ctr
		cmovz	eax, ecx
		retn
_EVP_aes_256_ctr endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2430h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_256_ecb
_EVP_aes_256_ecb proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_256_ecb
		mov	ecx, offset _aes_256_ecb
		cmovz	eax, ecx
		retn
_EVP_aes_256_ecb endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2448h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_256_gcm
_EVP_aes_256_gcm proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_256_gcm
		mov	ecx, offset _aes_256_gcm
		cmovz	eax, ecx
		retn
_EVP_aes_256_gcm endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2460h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_256_ofb
_EVP_aes_256_ofb proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_256_ofb
		mov	ecx, offset _aes_256_ofb
		cmovz	eax, ecx
		retn
_EVP_aes_256_ofb endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2478h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_256_wrap
_EVP_aes_256_wrap proc near
		mov	eax, offset _aes_256_wrap
		retn
_EVP_aes_256_wrap endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2480h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_aes_256_xts
_EVP_aes_256_xts proc near
		test	dword ptr ds:_OPENSSL_ia32cap_P+4, 2000000h
		mov	eax, offset _aesni_256_xts
		mov	ecx, offset _aes_256_xts
		cmovz	eax, ecx
		retn
_EVP_aes_256_xts endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2498h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_aes_gcm_tls_cipher proc near		; CODE XREF: _aes_gcm_cipher+24j

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	ecx, [esp+arg_0]
		push	ebx
		mov	ebx, [esp+4+arg_8]
		push	ebp
		mov	ebp, [ecx+60h]
		push	esi
		push	edi
		mov	edi, [esp+10h+arg_4]
		cmp	edi, ebx
		jnz	loc_25EC
		mov	esi, [esp+10h+arg_C]
		cmp	esi, 18h
		jb	loc_25EC
		cmp	dword ptr [ecx+8], 0
		mov	edx, 13h
		push	edi
		mov	eax, 18h
		push	8
		cmovnz	eax, edx
		push	eax
		push	ecx
		call	_EVP_CIPHER_CTX_ctrl
		add	esp, 10h
		test	eax, eax
		jle	loc_25CC
		push	dword ptr [ebp+288h]
		mov	ecx, [esp+14h+arg_0]
		lea	eax, [ebp+100h]
		add	ecx, 30h ; '0'
		push	ecx
		push	eax
		mov	[esp+1Ch+arg_4], ecx
		call	_CRYPTO_gcm128_aad
		add	esp, 0Ch
		test	eax, eax
		jnz	loc_25CC
		mov	eax, [esp+10h+arg_0]
		add	ebx, 8
		add	edi, 8
		sub	esi, 18h
		cmp	dword ptr [eax+8], 0
		mov	eax, [ebp+28Ch]
		jz	short loc_256B
		test	eax, eax
		jz	short loc_2541
		push	eax
		push	esi
		push	edi
		push	ebx
		lea	ebx, [ebp+100h]
		push	ebx
		call	_CRYPTO_gcm128_encrypt_ctr32
		add	esp, 14h
		jmp	short loc_2553
; ---------------------------------------------------------------------------

loc_2541:				; CODE XREF: _aes_gcm_tls_cipher+92j
		push	esi
		push	edi
		push	ebx
		lea	ebx, [ebp+100h]
		push	ebx
		call	_CRYPTO_gcm128_encrypt
		add	esp, 10h

loc_2553:				; CODE XREF: _aes_gcm_tls_cipher+A7j
		test	eax, eax
		jnz	short loc_25CC
		push	10h
		lea	eax, [edi+esi]
		push	eax
		push	ebx
		call	_CRYPTO_gcm128_tag
		add	esp, 0Ch
		lea	eax, [esi+18h]
		jmp	short $err$30
; ---------------------------------------------------------------------------

loc_256B:				; CODE XREF: _aes_gcm_tls_cipher+8Ej
		test	eax, eax
		jz	short loc_2584
		push	eax
		push	esi
		push	edi
		lea	eax, [ebp+100h]
		push	ebx
		push	eax
		call	_CRYPTO_gcm128_decrypt_ctr32
		add	esp, 14h
		jmp	short loc_2596
; ---------------------------------------------------------------------------

loc_2584:				; CODE XREF: _aes_gcm_tls_cipher+D5j
		push	esi
		push	edi
		lea	eax, [ebp+100h]
		push	ebx
		push	eax
		call	_CRYPTO_gcm128_decrypt
		add	esp, 10h

loc_2596:				; CODE XREF: _aes_gcm_tls_cipher+EAj
		test	eax, eax
		jnz	short loc_25CC
		push	10h
		push	[esp+14h+arg_4]
		lea	eax, [ebp+100h]
		push	eax
		call	_CRYPTO_gcm128_tag
		push	10h
		lea	eax, [ebx+esi]
		push	eax
		push	[esp+24h+arg_4]
		call	_CRYPTO_memcmp
		add	esp, 18h
		test	eax, eax
		jz	short loc_25E8
		push	esi
		push	edi
		call	_OPENSSL_cleanse
		add	esp, 8

loc_25CC:				; CODE XREF: _aes_gcm_tls_cipher+48j
					; _aes_gcm_tls_cipher+71j ...
		or	eax, 0FFFFFFFFh

$err$30:				; CODE XREF: _aes_gcm_tls_cipher+D1j
					; _aes_gcm_tls_cipher+152j
		pop	edi
		pop	esi
		mov	dword ptr [ebp+0FCh], 0
		mov	dword ptr [ebp+288h], 0FFFFFFFFh
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_25E8:				; CODE XREF: _aes_gcm_tls_cipher+128j
		mov	eax, esi
		jmp	short $err$30
; ---------------------------------------------------------------------------

loc_25EC:				; CODE XREF: _aes_gcm_tls_cipher+15j
					; _aes_gcm_tls_cipher+22j
		pop	edi
		pop	esi
		pop	ebp
		or	eax, 0FFFFFFFFh
		pop	ebx
		retn
_aes_gcm_tls_cipher endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 25F4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ctr64_inc	proc near

arg_0		= dword	ptr  4

		mov	edx, [esp+arg_0]
		mov	eax, 8
		nop	dword ptr [eax+00000000h]

loc_2604:				; CODE XREF: _ctr64_inc+19j
		dec	eax
		add	byte ptr [eax+edx], 1
		jnz	short locret_260F
		test	eax, eax
		jnz	short loc_2604

locret_260F:				; CODE XREF: _ctr64_inc+15j
		retn
_ctr64_inc	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2610h
; COMDAT (pick any)
		public ??_C@_0BF@PJIDMOFK@?4?2crypto?2evp?2e_aes?4c?$AA@
; `string'
??_C@_0BF@PJIDMOFK@?4?2crypto?2evp?2e_aes?4c?$AA@ db '.\crypto\evp\e_aes.c',0
					; DATA XREF: _aesni_init_key+A9o
					; _aes_init_key+D7o ...
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _CRYPTO_malloc:near ; CODE XREF: _aes_gcm_ctrl+B0p
					; _aes_gcm_ctrl+37Ap
		extrn _CRYPTO_free:near	; CODE XREF: _aes_gcm_cleanup+2Dp
					; _aes_gcm_ctrl+9Dp
		extrn _OPENSSL_cleanse:near ; CODE XREF: _aes_ccm_cipher+218p
					; _aes_gcm_cleanup+15p	...
		extrn _CRYPTO_memcmp:near ; CODE XREF: _aes_ccm_cipher+1FBp
					; _aes_gcm_tls_cipher+11Ep
		extrn _EVP_CIPHER_CTX_ctrl:near	; CODE XREF: _aes_gcm_tls_cipher+3Ep
		extrn _ERR_put_error:near ; CODE XREF: _aesni_init_key+BAp
					; _aes_init_key+E8p
		extrn _AES_set_encrypt_key:near	; CODE XREF: _aes_ccm_init_key:loc_E3Ap
					; _aes_wrap_init_key+34p ...
		extrn _AES_set_decrypt_key:near	; CODE XREF: _aes_wrap_init_key:loc_1063p
					; _aes_init_key:loc_198Ep ...
		extrn _AES_encrypt:near	; DATA XREF: _aes_ccm_init_key+4Bo
					; _aes_wrap_cipher+53o	...
		extrn _AES_decrypt:near	; DATA XREF: _aes_wrap_cipher:loc_120Bo
					; _aes_init_key+6Bo ...
		extrn _AES_cbc_encrypt:near ; DATA XREF: _aes_init_key:loc_19DCo
		extrn _CRYPTO_cbc128_encrypt:near ; CODE XREF: _aes_cbc_cipher+4Dp
		extrn _CRYPTO_cbc128_decrypt:near ; CODE XREF: _aes_cbc_cipher+6Cp
		extrn _CRYPTO_ctr128_encrypt:near ; CODE XREF: _aes_ctr_cipher+6Ap
		extrn _CRYPTO_ctr128_encrypt_ctr32:near	; CODE XREF: _aes_ctr_cipher+34p
		extrn _CRYPTO_ofb128_encrypt:near ; CODE XREF: _aes_ofb_cipher+22p
		extrn _CRYPTO_cfb128_encrypt:near ; CODE XREF: _aes_cfb_cipher+25p
		extrn _CRYPTO_cfb128_8_encrypt:near ; CODE XREF: _aes_cfb8_cipher+25p
		extrn _CRYPTO_cfb128_1_encrypt:near ; CODE XREF: _aes_cfb1_cipher+30p
					; _aes_cfb1_cipher+76p	...
		extrn _CRYPTO_gcm128_init:near ; CODE XREF: _aesni_gcm_init_key+3Fp
					; _aes_gcm_init_key+5Bp
		extrn _CRYPTO_gcm128_setiv:near	; CODE XREF: _aesni_gcm_init_key+6Fp
					; _aesni_gcm_init_key+ABp ...
		extrn _CRYPTO_gcm128_aad:near ;	CODE XREF: _aes_gcm_cipher+54p
					; _aes_gcm_tls_cipher+67p
		extrn _CRYPTO_gcm128_encrypt:near ; CODE XREF: _aes_gcm_cipher+8Dp
					; _aes_gcm_tls_cipher+B3p
		extrn _CRYPTO_gcm128_decrypt:near ; CODE XREF: _aes_gcm_cipher+C2p
					; _aes_gcm_tls_cipher+F6p
		extrn _CRYPTO_gcm128_encrypt_ctr32:near	; CODE XREF: _aes_gcm_cipher+79p
					; _aes_gcm_tls_cipher+9Fp
		extrn _CRYPTO_gcm128_decrypt_ctr32:near	; CODE XREF: _aes_gcm_cipher+AEp
					; _aes_gcm_tls_cipher+E2p
		extrn _CRYPTO_gcm128_finish:near ; CODE	XREF: _aes_gcm_cipher+EEp
		extrn _CRYPTO_gcm128_tag:near ;	CODE XREF: _aes_gcm_cipher+10Cp
					; _aes_gcm_tls_cipher+C6p ...
		extrn _CRYPTO_ccm128_init:near ; CODE XREF: _aes_ccm_init_key+64p
					; _aesni_ccm_init_key+4Cp
		extrn _CRYPTO_ccm128_setiv:near	; CODE XREF: _aes_ccm_cipher+8Ap
					; _aes_ccm_cipher+126p
		extrn _CRYPTO_ccm128_aad:near ;	CODE XREF: _aes_ccm_cipher+D1p
		extrn _CRYPTO_ccm128_encrypt:near ; CODE XREF: _aes_ccm_cipher+167p
		extrn _CRYPTO_ccm128_decrypt:near ; CODE XREF: _aes_ccm_cipher+1BFp
		extrn _CRYPTO_ccm128_encrypt_ccm64:near	; CODE XREF: _aes_ccm_cipher+159p
		extrn _CRYPTO_ccm128_decrypt_ccm64:near	; CODE XREF: _aes_ccm_cipher+1B1p
		extrn _CRYPTO_ccm128_tag:near ;	CODE XREF: _aes_ccm_ctrl+FEp
					; _aes_ccm_cipher+1DCp
		extrn _CRYPTO_xts128_encrypt:near ; CODE XREF: _aes_xts_cipher+88p
		extrn _CRYPTO_128_wrap:near ; CODE XREF: _aes_wrap_cipher+62p
		extrn _CRYPTO_128_unwrap:near ;	CODE XREF: _aes_wrap_cipher+86p
		extrn _RAND_bytes:near	; CODE XREF: _aes_gcm_ctrl+1BDp
		extrn _vpaes_set_encrypt_key:near ; CODE XREF: _aes_ccm_init_key+3Ap
					; _aes_init_key+8Fp ...
		extrn _vpaes_set_decrypt_key:near ; CODE XREF: _aes_init_key+3Dp
					; _aes_xts_init_key:loc_210Ap
		extrn _vpaes_encrypt:near ; DATA XREF: _aes_ccm_init_key+3Fo
					; _aes_init_key+94o ...
		extrn _vpaes_decrypt:near ; DATA XREF: _aes_init_key+44o
					; _aes_xts_init_key+67o
		extrn _vpaes_cbc_encrypt:near ;	DATA XREF: _aes_init_key+56o
					; _aes_init_key+9Eo
		extrn _aesni_set_encrypt_key:near ; CODE XREF: _aesni_init_key+66p
					; _aesni_gcm_init_key+2Dp ...
		extrn _aesni_set_decrypt_key:near ; CODE XREF: _aesni_init_key+31p
					; _aesni_xts_init_key:loc_150Ap
		extrn _aesni_encrypt:near ; DATA XREF: _aesni_init_key+6Eo
					; _aesni_gcm_init_key+32o ...
		extrn _aesni_decrypt:near ; DATA XREF: _aesni_init_key+38o
					; _aesni_xts_init_key+57o
		extrn _aesni_ecb_encrypt:near ;	CODE XREF: _aesni_ecb_cipher+1Ep
		extrn _aesni_cbc_encrypt:near ;	CODE XREF: _aesni_cbc_cipher+1Ap
					; DATA XREF: _aesni_init_key+4Ao ...
		extrn _aesni_ctr32_encrypt_blocks:near ; DATA XREF: _aesni_init_key+8Do
					; _aesni_gcm_init_key+47o
		extrn _aesni_xts_encrypt:near ;	DATA XREF: _aesni_xts_init_key+46o
		extrn _aesni_xts_decrypt:near ;	DATA XREF: _aesni_xts_init_key+61o
		extrn _aesni_ccm64_encrypt_blocks:near ; DATA XREF: _aesni_ccm_init_key+68o
		extrn _aesni_ccm64_decrypt_blocks:near ; DATA XREF: _aesni_ccm_init_key+63o
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _aes_ccm_cipher+53p
					; _aes_ccm_cipher+B0p ...
		extrn __chkstk:near	; CODE XREF: _aes_xts_cipher+5p
					; _aes_ccm_cipher+5p
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _aes_ccm_ctrl+CAp
					; _aes_ccm_init_key+95p ...
		extrn _OPENSSL_ia32cap_P:near ;	DATA XREF: _aes_ccm_init_key+2Cr
					; _aes_init_key+2Cr ...
		extrn ___security_cookie:near ;	DATA XREF: _aes_ccm_cipher+Ar


		end
