;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	EF5F75016961E3E945615BAA4A2AB3B8
; Input	CRC32 :	D9169A1E

; File Name   :	C:\compspace\Diff\openssl\obj\v3_purp.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_check_purpose_ssl_client proc near	; DATA XREF: .data:0000029Co

arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_4]
		mov	eax, [esi+28h]
		test	al, 4
		jz	short loc_12
		test	byte ptr [esi+30h], 2
		jz	short loc_31

loc_12:					; CODE XREF: _check_purpose_ssl_client+Aj
		cmp	[esp+4+arg_8], 0
		jz	short loc_35
		push	esi
		call	_check_ca
		add	esp, 4
		test	eax, eax
		jz	short loc_31
		cmp	eax, 5
		jnz	short loc_4E
		test	byte ptr [esi+34h], 4
		jnz	short loc_4E

loc_31:					; CODE XREF: _check_purpose_ssl_client+10j
					; _check_purpose_ssl_client+24j ...
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_35:					; CODE XREF: _check_purpose_ssl_client+17j
		test	al, 2
		jz	short loc_3F
		test	byte ptr [esi+2Ch], 88h
		jz	short loc_31

loc_3F:					; CODE XREF: _check_purpose_ssl_client+37j
		test	al, 8
		jz	short loc_49
		test	byte ptr [esi+34h], 80h

loc_47:					; DATA XREF: .rdata:`X509_supported_extension'::`2'::supported_nidso
		jz	short loc_31

loc_49:					; CODE XREF: _check_purpose_ssl_client+41j
		mov	eax, 1

loc_4E:					; CODE XREF: _check_purpose_ssl_client+29j
					; _check_purpose_ssl_client+2Fj
		pop	esi
		retn
_check_purpose_ssl_client endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 50h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_check_purpose_ssl_server proc near	; DATA XREF: .data:000002B8o

arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi

loc_51:					; DATA XREF: .rdata:00000484o
		mov	esi, [esp+4+arg_4]

loc_55:					; DATA XREF: .rdata:00000488o
					; .rdata:0000048Co
		mov	eax, [esi+28h]

loc_58:					; DATA XREF: .rdata:00000490o
		test	al, 4
		jz	short loc_62
		test	byte ptr [esi+30h], 11h
		jz	short loc_81

loc_62:					; CODE XREF: _check_purpose_ssl_server+Aj
		cmp	[esp+4+arg_8], 0
		jz	short loc_85
		push	esi
		call	_check_ca
		add	esp, 4
		test	eax, eax
		jz	short loc_81
		cmp	eax, 5
		jnz	short loc_9E

loc_7B:					; DATA XREF: .rdata:00000494o
		test	byte ptr [esi+34h], 4
		jnz	short loc_9E

loc_81:					; CODE XREF: _check_purpose_ssl_server+10j
					; _check_purpose_ssl_server+24j ...
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_85:					; CODE XREF: _check_purpose_ssl_server+17j
		test	al, 8
		jz	short loc_8F
		test	byte ptr [esi+34h], 40h
		jz	short loc_81

loc_8F:					; CODE XREF: _check_purpose_ssl_server+37j
		test	al, 2
		jz	short loc_99
		test	byte ptr [esi+2Ch], 0A8h
		jz	short loc_81

loc_99:					; CODE XREF: _check_purpose_ssl_server+41j
		mov	eax, 1

loc_9E:					; CODE XREF: _check_purpose_ssl_server+29j
					; _check_purpose_ssl_server+2Fj
		pop	esi
		retn
_check_purpose_ssl_server endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_check_purpose_ns_ssl_server proc near	; DATA XREF: .data:000002D4o

arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_4]
		mov	eax, [esi+28h]
		test	al, 4
		jz	short loc_B2
		test	byte ptr [esi+30h], 11h
		jz	short loc_F4

loc_B2:					; CODE XREF: _check_purpose_ns_ssl_server+Aj
		cmp	[esp+4+arg_8], 0
		jz	short loc_D5
		push	esi
		call	_check_ca
		add	esp, 4
		test	eax, eax
		jz	short loc_F4
		cmp	eax, 5
		jnz	short loc_FD
		test	byte ptr [esi+34h], 4
		jnz	short loc_FD
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_D5:					; CODE XREF: _check_purpose_ns_ssl_server+17j
		test	al, 8
		jz	short loc_DF
		test	byte ptr [esi+34h], 40h
		jz	short loc_F4

loc_DF:					; CODE XREF: _check_purpose_ns_ssl_server+37j
		and	eax, 2
		jz	short loc_EA
		test	byte ptr [esi+2Ch], 0A8h
		jz	short loc_F4

loc_EA:					; CODE XREF: _check_purpose_ns_ssl_server+42j
		test	eax, eax
		jz	short loc_F8
		test	byte ptr [esi+2Ch], 20h
		jnz	short loc_F8

loc_F4:					; CODE XREF: _check_purpose_ns_ssl_server+10j
					; _check_purpose_ns_ssl_server+24j ...
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_F8:					; CODE XREF: _check_purpose_ns_ssl_server+4Cj
					; _check_purpose_ns_ssl_server+52j
		mov	eax, 1

loc_FD:					; CODE XREF: _check_purpose_ns_ssl_server+29j
					; _check_purpose_ns_ssl_server+2Fj
		pop	esi
		retn
_check_purpose_ns_ssl_server endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 100h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_check_purpose_smime_sign proc near	; DATA XREF: .data:000002F0o

arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_4]
		mov	eax, [esi+28h]
		test	al, 4
		jz	short loc_112
		test	byte ptr [esi+30h], 4
		jz	short loc_15B

loc_112:				; CODE XREF: _check_purpose_smime_sign+Aj
		cmp	[esp+4+arg_8], 0
		jz	short loc_135
		push	esi
		call	_check_ca
		add	esp, 4
		test	eax, eax
		jz	short loc_15B
		cmp	eax, 5
		jnz	short loc_161
		test	byte ptr [esi+34h], 2
		jnz	short loc_161
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_135:				; CODE XREF: _check_purpose_smime_sign+17j
		test	al, 8
		jz	short loc_14C
		mov	ecx, [esi+34h]
		test	cl, 20h
		jnz	short loc_14C
		test	cl, cl
		jns	short loc_15B
		mov	ecx, 2
		jmp	short loc_151
; ---------------------------------------------------------------------------

loc_14C:				; CODE XREF: _check_purpose_smime_sign+37j
					; _check_purpose_smime_sign+3Fj
		mov	ecx, 1

loc_151:				; CODE XREF: _check_purpose_smime_sign+4Aj
		test	al, 2
		jz	short loc_15F
		test	byte ptr [esi+2Ch], 0C0h
		jnz	short loc_15F

loc_15B:				; CODE XREF: _check_purpose_smime_sign+10j
					; _check_purpose_smime_sign+24j ...
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_15F:				; CODE XREF: _check_purpose_smime_sign+53j
					; _check_purpose_smime_sign+59j
		mov	eax, ecx

loc_161:				; CODE XREF: _check_purpose_smime_sign+29j
					; _check_purpose_smime_sign+2Fj
		pop	esi
		retn
_check_purpose_smime_sign endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 164h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_check_purpose_smime_encrypt proc near	; DATA XREF: .data:0000030Co

arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_4]
		mov	eax, [esi+28h]
		test	al, 4
		jz	short loc_176
		test	byte ptr [esi+30h], 4
		jz	short loc_1BF

loc_176:				; CODE XREF: _check_purpose_smime_encrypt+Aj
		cmp	[esp+4+arg_8], 0
		jz	short loc_199
		push	esi
		call	_check_ca
		add	esp, 4
		test	eax, eax
		jz	short loc_1BF
		cmp	eax, 5
		jnz	short loc_1C5

loc_18F:				; DATA XREF: .rdata:00000498o
		test	byte ptr [esi+34h], 2
		jnz	short loc_1C5
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_199:				; CODE XREF: _check_purpose_smime_encrypt+17j
		test	al, 8
		jz	short loc_1B0
		mov	ecx, [esi+34h]
		test	cl, 20h
		jnz	short loc_1B0
		test	cl, cl
		jns	short loc_1BF
		mov	ecx, 2
		jmp	short loc_1B5
; ---------------------------------------------------------------------------

loc_1B0:				; CODE XREF: _check_purpose_smime_encrypt+37j
					; _check_purpose_smime_encrypt+3Fj
		mov	ecx, 1

loc_1B5:				; CODE XREF: _check_purpose_smime_encrypt+4Aj
		test	al, 2
		jz	short loc_1C3
		test	byte ptr [esi+2Ch], 20h
		jnz	short loc_1C3

loc_1BF:				; CODE XREF: _check_purpose_smime_encrypt+10j
					; _check_purpose_smime_encrypt+24j ...
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1C3:				; CODE XREF: _check_purpose_smime_encrypt+53j
					; _check_purpose_smime_encrypt+59j
		mov	eax, ecx

loc_1C5:				; CODE XREF: _check_purpose_smime_encrypt+29j
					; _check_purpose_smime_encrypt+2Fj
		pop	esi
		retn
_check_purpose_smime_encrypt endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1C8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_check_purpose_crl_sign	proc near	; DATA XREF: .data:00000328o

arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		cmp	[esp+arg_8], 0
		jz	short loc_1E6
		push	[esp+arg_4]
		call	_check_ca
		xor	ecx, ecx
		add	esp, 4
		cmp	eax, 2
		cmovnz	ecx, eax
		mov	eax, ecx
		retn
; ---------------------------------------------------------------------------

loc_1E6:				; CODE XREF: _check_purpose_crl_sign+5j
		mov	eax, [esp+arg_4]
		test	byte ptr [eax+28h], 2
		jz	short loc_1F9
		test	byte ptr [eax+2Ch], 2
		jnz	short loc_1F9
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1F9:				; CODE XREF: _check_purpose_crl_sign+26j
					; _check_purpose_crl_sign+2Cj
		mov	eax, 1
		retn
_check_purpose_crl_sign	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 200h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_check_purpose_timestamp_sign proc near	; DATA XREF: .data:0000037Co

arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		cmp	[esp+arg_8], 0
		jz	short loc_214
		push	[esp+arg_4]
		call	_check_ca
		add	esp, 4
		retn
; ---------------------------------------------------------------------------

loc_214:				; CODE XREF: _check_purpose_timestamp_sign+5j
		push	esi
		mov	esi, [esp+4+arg_4]
		mov	eax, [esi+28h]
		test	al, 2
		jz	short loc_230
		mov	ecx, [esi+2Ch]
		test	ecx, 0FFFFFF3Fh
		jnz	short loc_266
		test	cl, 0C0h
		jz	short loc_266

loc_230:				; CODE XREF: _check_purpose_timestamp_sign+1Ej
		test	al, 4
		jz	short loc_266
		cmp	dword ptr [esi+30h], 40h ; '@'
		jnz	short loc_266
		push	0FFFFFFFFh
		push	7Eh ; '~'
		push	esi
		call	_X509_get_ext_by_NID
		add	esp, 0Ch
		test	eax, eax
		js	short loc_25F
		push	eax
		push	esi
		call	_X509_get_ext
		push	eax
		call	_X509_EXTENSION_get_critical
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_266

loc_25F:				; CODE XREF: _check_purpose_timestamp_sign+49j
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_266:				; CODE XREF: _check_purpose_timestamp_sign+29j
					; _check_purpose_timestamp_sign+2Ej ...
		xor	eax, eax
		pop	esi
		retn
_check_purpose_timestamp_sign endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 26Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_no_check	proc near		; DATA XREF: .data:00000344o
		mov	eax, 1
		retn
_no_check	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 274h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ocsp_helper	proc near		; DATA XREF: .data:00000360o

arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		cmp	[esp+arg_8], 0
		jz	short loc_288
		push	[esp+arg_4]
		call	_check_ca
		add	esp, 4
		retn
; ---------------------------------------------------------------------------

loc_288:				; CODE XREF: _ocsp_helper+5j
		mov	eax, 1
		retn
_ocsp_helper	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data		segment	para public 'DATA' use32
		assume cs:_data
		;org 290h
_xstandard	dd 1, 2			; DATA XREF: _X509_PURPOSE_add+9Do
					; _X509_PURPOSE_get0+19o ...
dword_298	dd 0			; DATA XREF: _X509_PURPOSE_cleanup+15o
					; .rdata:000004A0o
		dd offset _check_purpose_ssl_client
		dd offset ??_C@_0L@LCHPILLE@SSL?5client?$AA@ ; "SSL client"
		dd offset ??_C@_09BLMJDCHK@sslclient?$AA@ ; "sslclient"
		dd 0
		dd 2, 3, 0
		dd offset _check_purpose_ssl_server
		dd offset ??_C@_0L@PNDNFADH@SSL?5server?$AA@ ; "SSL server"
		dd offset ??_C@_09FEILOJPJ@sslserver?$AA@ ; "sslserver"
		align 8
		dd 2 dup(3), 0
		dd offset _check_purpose_ns_ssl_server
		dd offset ??_C@_0BE@BPEJPGJG@Netscape?5SSL?5server?$AA@	; "Netscape SSL	server"
		dd offset ??_C@_0M@GKHHMMAE@nssslserver?$AA@ ; "nssslserver"
		dd 0
dword_2E4	dd 2 dup(4), 0		; DATA XREF: .rdata:000004A4o
					; .rdata:000004A8o
		dd offset _check_purpose_smime_sign
		dd offset ??_C@_0P@LNDEBCCO@S?1MIME?5signing?$AA@ ; "S/MIME signing"
		dd offset ??_C@_09JPGBHOKH@smimesign?$AA@ ; "smimesign"
		align 10h
		dd 5, 4, 0
		dd offset _check_purpose_smime_encrypt
		dd offset ??_C@_0BC@DOGNOPGC@S?1MIME?5encryption?$AA@ ;	"S/MIME	encryption"
		dd offset ??_C@_0N@BPFJELMP@smimeencrypt?$AA@ ;	"smimeencrypt"
		dd 0
		dd 6, 1, 0
		dd offset _check_purpose_crl_sign
		dd offset ??_C@_0M@MEKLJHLA@CRL?5signing?$AA@ ;	"CRL signing"
		dd offset ??_C@_07IOMCDAPH@crlsign?$AA@	; "crlsign"
		align 8
		dd 7, 0FFFFFFFFh, 0
		dd offset _no_check
		dd offset ??_C@_0M@NMNFLNDB@Any?5Purpose?$AA@ ;	"Any Purpose"
		dd offset ??_C@_03OBJFJEBA@any?$AA@ ; "any"
		dd 0
		dd 8, 1, 0
		dd offset _ocsp_helper
		dd offset ??_C@_0M@NEPIMEJA@OCSP?5helper?$AA@ ;	"OCSP helper"
		dd offset ??_C@_0L@IMHCEJBK@ocsphelper?$AA@ ; "ocsphelper"
		align 10h
		dd 9, 8, 0
		dd offset _check_purpose_timestamp_sign
		dd offset ??_C@_0BD@HLGKGIIB@Time?5Stamp?5signing?$AA@ ; "Time Stamp signing"
		dd offset ??_C@_0O@MABGKINF@timestampsign?$AA@ ; "timestampsign"
		dd 0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 38Ch
; COMDAT (pick any)
		public ??_C@_0L@LCHPILLE@SSL?5client?$AA@
; `string'
??_C@_0L@LCHPILLE@SSL?5client?$AA@ db 'SSL client',0 ; DATA XREF: .data:000002A0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 398h
; COMDAT (pick any)
		public ??_C@_09BLMJDCHK@sslclient?$AA@
; `string'
??_C@_09BLMJDCHK@sslclient?$AA@	db 'sslclient',0 ; DATA XREF: .data:000002A4o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3A4h
; COMDAT (pick any)
		public ??_C@_0L@PNDNFADH@SSL?5server?$AA@
; `string'
??_C@_0L@PNDNFADH@SSL?5server?$AA@ db 'SSL server',0 ; DATA XREF: .data:000002BCo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3B0h
; COMDAT (pick any)
		public ??_C@_09FEILOJPJ@sslserver?$AA@
; `string'
??_C@_09FEILOJPJ@sslserver?$AA@	db 'sslserver',0 ; DATA XREF: .data:000002C0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3BCh
; COMDAT (pick any)
		public ??_C@_0BE@BPEJPGJG@Netscape?5SSL?5server?$AA@
; `string'
??_C@_0BE@BPEJPGJG@Netscape?5SSL?5server?$AA@ db 'Netscape SSL server',0
					; DATA XREF: .data:000002D8o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3D0h
; COMDAT (pick any)
		public ??_C@_0M@GKHHMMAE@nssslserver?$AA@
; `string'
??_C@_0M@GKHHMMAE@nssslserver?$AA@ db 'nssslserver',0 ; DATA XREF: .data:000002DCo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3DCh
; COMDAT (pick any)
		public ??_C@_0P@LNDEBCCO@S?1MIME?5signing?$AA@
; `string'
??_C@_0P@LNDEBCCO@S?1MIME?5signing?$AA@	db 'S/MIME signing',0 ; DATA XREF: .data:000002F4o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3ECh
; COMDAT (pick any)
		public ??_C@_09JPGBHOKH@smimesign?$AA@
; `string'
??_C@_09JPGBHOKH@smimesign?$AA@	db 'smimesign',0 ; DATA XREF: .data:000002F8o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3F8h
; COMDAT (pick any)
		public ??_C@_0BC@DOGNOPGC@S?1MIME?5encryption?$AA@
; `string'
??_C@_0BC@DOGNOPGC@S?1MIME?5encryption?$AA@ db 'S/MIME encryption',0
					; DATA XREF: .data:00000310o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40Ch
; COMDAT (pick any)
		public ??_C@_0N@BPFJELMP@smimeencrypt?$AA@
; `string'
??_C@_0N@BPFJELMP@smimeencrypt?$AA@ db 'smimeencrypt',0 ; DATA XREF: .data:00000314o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 41Ch
; COMDAT (pick any)
		public ??_C@_0M@MEKLJHLA@CRL?5signing?$AA@
; `string'
??_C@_0M@MEKLJHLA@CRL?5signing?$AA@ db 'CRL signing',0 ; DATA XREF: .data:0000032Co
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 428h
; COMDAT (pick any)
		public ??_C@_07IOMCDAPH@crlsign?$AA@
; `string'
??_C@_07IOMCDAPH@crlsign?$AA@ db 'crlsign',0 ; DATA XREF: .data:00000330o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 430h
; COMDAT (pick any)
		public ??_C@_0M@NMNFLNDB@Any?5Purpose?$AA@
; `string'
??_C@_0M@NMNFLNDB@Any?5Purpose?$AA@ db 'Any Purpose',0 ; DATA XREF: .data:00000348o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 43Ch
; COMDAT (pick any)
		public ??_C@_03OBJFJEBA@any?$AA@
; `string'
??_C@_03OBJFJEBA@any?$AA@ db 'any',0    ; DATA XREF: .data:0000034Co
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 440h
; COMDAT (pick any)
		public ??_C@_0M@NEPIMEJA@OCSP?5helper?$AA@
; `string'
??_C@_0M@NEPIMEJA@OCSP?5helper?$AA@ db 'OCSP helper',0 ; DATA XREF: .data:00000364o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44Ch
; COMDAT (pick any)
		public ??_C@_0L@IMHCEJBK@ocsphelper?$AA@
; `string'
??_C@_0L@IMHCEJBK@ocsphelper?$AA@ db 'ocsphelper',0 ; DATA XREF: .data:00000368o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 458h
; COMDAT (pick any)
		public ??_C@_0BD@HLGKGIIB@Time?5Stamp?5signing?$AA@
; `string'
??_C@_0BD@HLGKGIIB@Time?5Stamp?5signing?$AA@ db	'Time Stamp signing',0
					; DATA XREF: .data:00000380o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 46Ch
; COMDAT (pick any)
		public ??_C@_0O@MABGKINF@timestampsign?$AA@
; `string'
??_C@_0O@MABGKINF@timestampsign?$AA@ db	'timestampsign',0 ; DATA XREF: .data:00000384o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 47Ch
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
_xptable	dd ?			; DATA XREF: _X509_PURPOSE_add:loc_4F1r
					; _X509_PURPOSE_add+AAr ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 480h
; `X509_supported_extension'::`2'::supported_nids
?supported_nids@?1??X509_supported_extension@@9@9 dd offset loc_47
					; DATA XREF: _X509_supported_extension+32o
					; _x509v3_cache_extensions+397o
		dd offset loc_51+2
		dd offset loc_55
		dd offset loc_55+2
		dd offset loc_58+1
		dd offset loc_7B+3
		dd offset loc_18F+2
		dd offset _xstandard+7
		dd offset dword_298+2
		dd offset dword_2E4+7
		dd offset dword_2E4+8
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4ACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_OBJ_bsearch_nid proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	offset _nid_cmp_BSEARCH_CMP_FN
		push	4
		push	[esp+8+arg_8]
		push	[esp+0Ch+arg_4]
		push	[esp+10h+arg_0]
		call	_OBJ_bsearch_
		add	esp, 14h
		retn
_OBJ_bsearch_nid endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4C8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509_PURPOSE_add
_X509_PURPOSE_add proc near

var_1C		= dword	ptr -1Ch
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h
arg_18		= dword	ptr  1Ch

		mov	eax, 1Ch
		call	__chkstk
		push	ebx
		mov	ebx, [esp+20h+arg_8]
		push	ebp
		mov	ebp, [esp+24h+arg_0]
		and	ebx, 0FFFFFFFEh
		push	esi
		or	ebx, 2
		push	edi
		lea	eax, [ebp-1]
		cmp	eax, 8
		ja	short loc_4F1
		lea	edi, [ebp-1]
		jmp	short loc_51D
; ---------------------------------------------------------------------------

loc_4F1:				; CODE XREF: _X509_PURPOSE_add+22j
		mov	eax, ds:_xptable
		mov	[esp+2Ch+var_1C], ebp
		test	eax, eax
		jnz	short loc_503
		or	edi, 0FFFFFFFFh
		jmp	short loc_522
; ---------------------------------------------------------------------------

loc_503:				; CODE XREF: _X509_PURPOSE_add+34j
		lea	ecx, [esp+2Ch+var_1C]
		push	ecx
		push	eax
		call	_sk_find
		add	esp, 8
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_51A
		or	edi, eax
		jmp	short loc_522
; ---------------------------------------------------------------------------

loc_51A:				; CODE XREF: _X509_PURPOSE_add+4Cj
		lea	edi, [eax+9]

loc_51D:				; CODE XREF: _X509_PURPOSE_add+27j
		cmp	edi, 0FFFFFFFFh
		jnz	short loc_54F

loc_522:				; CODE XREF: _X509_PURPOSE_add+39j
					; _X509_PURPOSE_add+50j
		push	0D6h ; '÷'
		push	offset ??_C@_0BK@COINEMNE@?4?2crypto?2x509v3?2v3_purp?4c?$AA@ ;	".\\crypto\\x509v3\\v3_purp.c"
		push	1Ch
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jnz	short loc_546
		push	0D7h ; '◊'
		jmp	loc_634
; ---------------------------------------------------------------------------

loc_546:				; CODE XREF: _X509_PURPOSE_add+72j
		mov	dword ptr [esi+8], 1
		jmp	short loc_582
; ---------------------------------------------------------------------------

loc_54F:				; CODE XREF: _X509_PURPOSE_add+58j
		test	edi, edi
		jns	short loc_557
		xor	esi, esi
		jmp	short loc_582
; ---------------------------------------------------------------------------

loc_557:				; CODE XREF: _X509_PURPOSE_add+89j
		cmp	edi, 9
		jge	short loc_56E
		lea	eax, ds:0[edi*8]
		sub	eax, edi
		lea	esi, _xstandard[eax*4]
		jmp	short loc_582
; ---------------------------------------------------------------------------

loc_56E:				; CODE XREF: _X509_PURPOSE_add+92j
		lea	eax, [edi-9]
		push	eax
		push	ds:_xptable
		call	_sk_value
		add	esp, 8
		mov	esi, eax

loc_582:				; CODE XREF: _X509_PURPOSE_add+85j
					; _X509_PURPOSE_add+8Dj ...
		test	byte ptr [esi+8], 2
		jz	short loc_59B
		push	dword ptr [esi+10h]
		call	_CRYPTO_free
		push	dword ptr [esi+14h]
		call	_CRYPTO_free
		add	esp, 8

loc_59B:				; CODE XREF: _X509_PURPOSE_add+BEj
		push	[esp+2Ch+arg_10]
		call	_BUF_strdup
		push	[esp+30h+arg_14]
		mov	[esi+10h], eax
		call	_BUF_strdup
		add	esp, 8
		mov	[esi+14h], eax
		cmp	dword ptr [esi+10h], 0
		jz	short loc_62F
		test	eax, eax
		jz	short loc_62F
		mov	eax, [esi+8]
		and	eax, 1
		mov	[esi], ebp
		or	eax, ebx
		mov	[esi+8], eax
		mov	eax, [esp+2Ch+arg_4]
		mov	[esi+4], eax
		mov	eax, [esp+2Ch+arg_C]
		mov	[esi+0Ch], eax
		mov	eax, [esp+2Ch+arg_18]
		mov	[esi+18h], eax
		cmp	edi, 0FFFFFFFFh
		jnz	short loc_622
		mov	eax, ds:_xptable
		test	eax, eax
		jnz	short loc_60D
		push	offset _xp_cmp
		call	_sk_new
		add	esp, 4
		mov	ds:_xptable, eax
		test	eax, eax
		jnz	short loc_60D
		push	0F7h ; '˜'
		jmp	short loc_634
; ---------------------------------------------------------------------------

loc_60D:				; CODE XREF: _X509_PURPOSE_add+126j
					; _X509_PURPOSE_add+13Cj
		push	esi
		push	eax
		call	_sk_push
		add	esp, 8
		test	eax, eax
		jnz	short loc_622
		push	0FBh ; '˚'
		jmp	short loc_634
; ---------------------------------------------------------------------------

loc_622:				; CODE XREF: _X509_PURPOSE_add+11Dj
					; _X509_PURPOSE_add+151j
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, 1
		pop	ebx
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_62F:				; CODE XREF: _X509_PURPOSE_add+F2j
					; _X509_PURPOSE_add+F6j
		push	0E7h ; 'Á'

loc_634:				; CODE XREF: _X509_PURPOSE_add+79j
					; _X509_PURPOSE_add+143j ...
		push	offset ??_C@_0BK@COINEMNE@?4?2crypto?2x509v3?2v3_purp?4c?$AA@ ;	".\\crypto\\x509v3\\v3_purp.c"
		push	41h ; 'A'
		push	89h ; 'â'
		push	22h ; '"'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 1Ch
		retn
_X509_PURPOSE_add endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 654h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509_PURPOSE_cleanup
_X509_PURPOSE_cleanup proc near
		push	esi
		push	edi
		push	offset _xptable_free
		push	ds:_xptable
		call	_sk_pop_free
		add	esp, 8
		mov	esi, offset dword_298
		mov	edi, 9
		nop

loc_674:				; CODE XREF: _X509_PURPOSE_cleanup+56j
		lea	eax, [esi-8]
		test	eax, eax
		jz	short loc_6A4
		mov	eax, [esi]
		test	al, 1
		jz	short loc_6A4
		test	al, 2
		jz	short loc_698
		push	dword ptr [esi+8]
		call	_CRYPTO_free
		push	dword ptr [esi+0Ch]
		call	_CRYPTO_free
		add	esp, 8

loc_698:				; CODE XREF: _X509_PURPOSE_cleanup+2Fj
		lea	eax, [esi-8]
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_6A4:				; CODE XREF: _X509_PURPOSE_cleanup+25j
					; _X509_PURPOSE_cleanup+2Bj
		add	esi, 1Ch
		sub	edi, 1
		jnz	short loc_674
		mov	ds:_xptable, edi
		pop	edi
		pop	esi
		retn
_X509_PURPOSE_cleanup endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6B8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509_PURPOSE_get0
_X509_PURPOSE_get0 proc	near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jns	short loc_6C3
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_6C3:				; CODE XREF: _X509_PURPOSE_get0+6j
		cmp	ecx, 9
		jge	short loc_6D9
		lea	eax, ds:0[ecx*8]
		sub	eax, ecx
		lea	eax, _xstandard[eax*4]
		retn
; ---------------------------------------------------------------------------

loc_6D9:				; CODE XREF: _X509_PURPOSE_get0+Ej
		lea	eax, [ecx-9]
		push	eax
		push	ds:_xptable
		call	_sk_value
		add	esp, 8
		retn
_X509_PURPOSE_get0 endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6ECh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509_PURPOSE_get0_name
_X509_PURPOSE_get0_name	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+10h]
		retn
_X509_PURPOSE_get0_name	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6F4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509_PURPOSE_get0_sname
_X509_PURPOSE_get0_sname proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+14h]
		retn
_X509_PURPOSE_get0_sname endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6FCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509_PURPOSE_get_by_id
_X509_PURPOSE_get_by_id	proc near

var_1C		= dword	ptr -1Ch
arg_0		= dword	ptr  4

		mov	eax, 1Ch
		call	__chkstk
		mov	ecx, [esp+1Ch+arg_0]
		lea	eax, [ecx-1]
		cmp	eax, 8
		ja	short loc_719
		lea	eax, [ecx-1]
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_719:				; CODE XREF: _X509_PURPOSE_get_by_id+14j
		mov	eax, ds:_xptable
		mov	[esp+1Ch+var_1C], ecx
		test	eax, eax
		jnz	short loc_72C

loc_725:				; CODE XREF: _X509_PURPOSE_get_by_id+40j
		or	eax, 0FFFFFFFFh
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_72C:				; CODE XREF: _X509_PURPOSE_get_by_id+27j
		lea	ecx, [esp+1Ch+var_1C]
		push	ecx
		push	eax
		call	_sk_find
		add	esp, 8
		cmp	eax, 0FFFFFFFFh
		jz	short loc_725
		add	eax, 9
		add	esp, 1Ch
		retn
_X509_PURPOSE_get_by_id	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 748h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509_PURPOSE_get_by_sname
_X509_PURPOSE_get_by_sname proc	near

arg_0		= dword	ptr  4

		push	ebx
		push	ebp
		mov	ebp, [esp+8+arg_0]
		mov	ebx, offset _xstandard
		push	esi
		push	edi
		mov	edi, ds:_xptable
		xor	esi, esi

loc_75D:				; CODE XREF: _X509_PURPOSE_get_by_sname+8Dj
		test	edi, edi
		jnz	short loc_766
		lea	eax, [edi+9]
		jmp	short loc_778
; ---------------------------------------------------------------------------

loc_766:				; CODE XREF: _X509_PURPOSE_get_by_sname+17j
		push	edi
		call	_sk_num
		mov	edi, ds:_xptable
		add	esp, 4
		add	eax, 9

loc_778:				; CODE XREF: _X509_PURPOSE_get_by_sname+1Cj
		cmp	esi, eax
		jge	short loc_7DE
		test	esi, esi
		jns	short loc_784
		xor	ecx, ecx
		jmp	short loc_7A2
; ---------------------------------------------------------------------------

loc_784:				; CODE XREF: _X509_PURPOSE_get_by_sname+36j
		cmp	esi, 9
		jge	short loc_78D
		mov	ecx, ebx
		jmp	short loc_7A2
; ---------------------------------------------------------------------------

loc_78D:				; CODE XREF: _X509_PURPOSE_get_by_sname+3Fj
		lea	eax, [esi-9]
		push	eax
		push	edi
		call	_sk_value
		mov	edi, ds:_xptable
		add	esp, 8
		mov	ecx, eax

loc_7A2:				; CODE XREF: _X509_PURPOSE_get_by_sname+3Aj
					; _X509_PURPOSE_get_by_sname+43j
		mov	ecx, [ecx+14h]
		mov	eax, ebp
		nop

loc_7A8:				; CODE XREF: _X509_PURPOSE_get_by_sname+7Aj
		mov	dl, [ecx]
		cmp	dl, [eax]
		jnz	short loc_7C8
		test	dl, dl
		jz	short loc_7C4
		mov	dl, [ecx+1]
		cmp	dl, [eax+1]
		jnz	short loc_7C8
		add	ecx, 2
		add	eax, 2
		test	dl, dl
		jnz	short loc_7A8

loc_7C4:				; CODE XREF: _X509_PURPOSE_get_by_sname+68j
		xor	eax, eax
		jmp	short loc_7CD
; ---------------------------------------------------------------------------

loc_7C8:				; CODE XREF: _X509_PURPOSE_get_by_sname+64j
					; _X509_PURPOSE_get_by_sname+70j
		sbb	eax, eax
		or	eax, 1

loc_7CD:				; CODE XREF: _X509_PURPOSE_get_by_sname+7Ej
		test	eax, eax
		jz	short loc_7D7
		inc	esi
		add	ebx, 1Ch
		jmp	short loc_75D
; ---------------------------------------------------------------------------

loc_7D7:				; CODE XREF: _X509_PURPOSE_get_by_sname+87j
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_7DE:				; CODE XREF: _X509_PURPOSE_get_by_sname+32j
		pop	edi
		pop	esi
		pop	ebp
		or	eax, 0FFFFFFFFh
		pop	ebx
		retn
_X509_PURPOSE_get_by_sname endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7E8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509_PURPOSE_get_count
_X509_PURPOSE_get_count	proc near
		mov	eax, ds:_xptable
		test	eax, eax
		jnz	short loc_7F7
		mov	eax, 9
		retn
; ---------------------------------------------------------------------------

loc_7F7:				; CODE XREF: _X509_PURPOSE_get_count+7j
		push	eax
		call	_sk_num
		add	esp, 4
		add	eax, 9
		retn
_X509_PURPOSE_get_count	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 804h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509_PURPOSE_get_id
_X509_PURPOSE_get_id proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax]
		retn
_X509_PURPOSE_get_id endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 80Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509_PURPOSE_get_trust
_X509_PURPOSE_get_trust	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+4]
		retn
_X509_PURPOSE_get_trust	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 814h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509_PURPOSE_set
_X509_PURPOSE_set proc near

var_1C		= dword	ptr -1Ch
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 1Ch
		call	__chkstk
		push	esi
		mov	esi, [esp+20h+arg_4]
		lea	eax, [esi-1]
		cmp	eax, 8
		ja	short loc_830
		lea	eax, [esi-1]
		jmp	short loc_853
; ---------------------------------------------------------------------------

loc_830:				; CODE XREF: _X509_PURPOSE_set+15j
		mov	eax, ds:_xptable
		mov	[esp+20h+var_1C], esi
		test	eax, eax
		jz	short loc_868
		lea	ecx, [esp+20h+var_1C]
		push	ecx
		push	eax
		call	_sk_find
		add	esp, 8
		cmp	eax, 0FFFFFFFFh
		jz	short loc_868
		add	eax, 9

loc_853:				; CODE XREF: _X509_PURPOSE_set+1Aj
		cmp	eax, 0FFFFFFFFh
		jz	short loc_868
		mov	eax, [esp+20h+arg_0]
		mov	[eax], esi
		mov	eax, 1
		pop	esi
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_868:				; CODE XREF: _X509_PURPOSE_set+27j
					; _X509_PURPOSE_set+3Aj ...
		push	94h ; 'î'
		push	offset ??_C@_0BK@COINEMNE@?4?2crypto?2x509v3?2v3_purp?4c?$AA@ ;	".\\crypto\\x509v3\\v3_purp.c"
		push	92h ; 'í'
		push	8Dh ; 'ç'
		push	22h ; '"'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		add	esp, 1Ch
		retn
_X509_PURPOSE_set endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 890h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509_check_akid
_X509_check_akid proc near		; CODE XREF: _X509_check_issued+4Ap
					; _x509v3_cache_extensions+2BEp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	edi
		mov	edi, [esp+4+arg_4]
		test	edi, edi
		jnz	short loc_89D
		xor	eax, eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_89D:				; CODE XREF: _X509_check_akid+7j
		mov	eax, [edi]
		push	ebx
		mov	ebx, [esp+8+arg_0]
		test	eax, eax
		jz	short loc_8C5
		mov	ecx, [ebx+38h]
		test	ecx, ecx
		jz	short loc_8C5
		push	ecx
		push	eax
		call	_ASN1_OCTET_STRING_cmp
		add	esp, 8
		test	eax, eax
		jz	short loc_8C5
		pop	ebx
		mov	eax, 1Eh
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_8C5:				; CODE XREF: _X509_check_akid+16j
					; _X509_check_akid+1Dj	...
		mov	eax, [edi+8]
		test	eax, eax
		jz	short loc_8EB
		push	eax
		push	ebx
		call	_X509_get_serialNumber
		add	esp, 4
		push	eax
		call	_ASN1_INTEGER_cmp
		add	esp, 8
		test	eax, eax
		jz	short loc_8EB
		pop	ebx
		mov	eax, 1Fh
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_8EB:				; CODE XREF: _X509_check_akid+3Aj
					; _X509_check_akid+51j
		mov	edi, [edi+4]
		push	esi
		test	edi, edi
		jz	short loc_91F
		push	edi
		xor	esi, esi
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jle	short loc_91F

loc_902:				; CODE XREF: _X509_check_akid+8Dj
		push	esi
		push	edi
		call	_sk_value
		add	esp, 8
		cmp	dword ptr [eax], 4
		jz	short loc_925
		push	edi
		inc	esi
		call	_sk_num
		add	esp, 4
		cmp	esi, eax
		jl	short loc_902

loc_91F:				; CODE XREF: _X509_check_akid+61j
					; _X509_check_akid+70j	...
		pop	esi
		pop	ebx
		xor	eax, eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_925:				; CODE XREF: _X509_check_akid+7Fj
		mov	esi, [eax+4]
		test	esi, esi
		jz	short loc_91F
		push	ebx
		call	_X509_get_issuer_name
		push	eax
		push	esi
		call	_X509_NAME_cmp
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_91F
		pop	esi
		pop	ebx
		mov	eax, 1Fh
		pop	edi
		retn
_X509_check_akid endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 94Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509_check_ca
_X509_check_ca	proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	dword ptr [esi+28h], 100h
		jnz	short loc_989
		push	245h
		push	offset ??_C@_0BK@COINEMNE@?4?2crypto?2x509v3?2v3_purp?4c?$AA@ ;	".\\crypto\\x509v3\\v3_purp.c"
		push	3
		push	9
		call	_CRYPTO_lock
		push	esi
		call	_x509v3_cache_extensions
		push	247h
		push	offset ??_C@_0BK@COINEMNE@?4?2crypto?2x509v3?2v3_purp?4c?$AA@ ;	".\\crypto\\x509v3\\v3_purp.c"
		push	3
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 24h

loc_989:				; CODE XREF: _X509_check_ca+Cj
		push	esi
		call	_check_ca
		add	esp, 4
		pop	esi
		retn
_X509_check_ca	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 994h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509_check_issued
_X509_check_issued proc	near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		push	edi
		mov	edi, [esp+8+arg_4]
		push	edi
		call	_X509_get_issuer_name
		mov	esi, [esp+0Ch+arg_0]
		add	esp, 4
		push	eax
		push	esi
		call	_X509_get_subject_name
		add	esp, 4
		push	eax
		call	_X509_NAME_cmp
		add	esp, 8
		test	eax, eax
		jz	short loc_9C6
		pop	edi
		mov	eax, 1Dh
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_9C6:				; CODE XREF: _X509_check_issued+28j
		push	esi
		call	_x509v3_cache_extensions
		push	edi
		call	_x509v3_cache_extensions
		mov	eax, [edi+3Ch]
		add	esp, 8
		test	eax, eax
		jz	short loc_9EA
		push	eax
		push	esi
		call	_X509_check_akid
		add	esp, 8
		test	eax, eax
		jnz	short loc_A1D

loc_9EA:				; CODE XREF: _X509_check_issued+46j
		test	dword ptr [edi+28h], 400h
		jz	short loc_A07
		test	byte ptr [esi+28h], 2
		jz	short loc_A1B
		test	byte ptr [esi+2Ch], 80h
		jnz	short loc_A1B
		pop	edi
		mov	eax, 27h ; '''
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_A07:				; CODE XREF: _X509_check_issued+5Dj
		test	byte ptr [esi+28h], 2
		jz	short loc_A1B
		test	byte ptr [esi+2Ch], 4
		jnz	short loc_A1B
		pop	edi
		mov	eax, 20h ; ' '
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_A1B:				; CODE XREF: _X509_check_issued+63j
					; _X509_check_issued+69j ...
		xor	eax, eax

loc_A1D:				; CODE XREF: _X509_check_issued+54j
		pop	edi
		pop	esi
		retn
_X509_check_issued endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A20h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509_check_purpose
_X509_check_purpose proc near

var_1C		= dword	ptr -1Ch
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 1Ch
		call	__chkstk
		push	esi
		mov	esi, [esp+20h+arg_0]
		test	dword ptr [esi+28h], 100h
		jnz	short loc_A67
		push	84h ; 'Ñ'
		push	offset ??_C@_0BK@COINEMNE@?4?2crypto?2x509v3?2v3_purp?4c?$AA@ ;	".\\crypto\\x509v3\\v3_purp.c"
		push	3
		push	9
		call	_CRYPTO_lock
		push	esi
		call	_x509v3_cache_extensions
		push	86h ; 'Ü'
		push	offset ??_C@_0BK@COINEMNE@?4?2crypto?2x509v3?2v3_purp?4c?$AA@ ;	".\\crypto\\x509v3\\v3_purp.c"
		push	3
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 24h

loc_A67:				; CODE XREF: _X509_check_purpose+16j
		mov	ecx, [esp+20h+arg_4]
		cmp	ecx, 0FFFFFFFFh
		jnz	short loc_A78
		lea	eax, [ecx+2]
		pop	esi
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_A78:				; CODE XREF: _X509_check_purpose+4Ej
		lea	eax, [ecx-1]
		cmp	eax, 8
		ja	short loc_A83
		dec	ecx
		jmp	short loc_AAA
; ---------------------------------------------------------------------------

loc_A83:				; CODE XREF: _X509_check_purpose+5Ej
		mov	eax, ds:_xptable
		mov	[esp+20h+var_1C], ecx
		test	eax, eax
		jz	loc_B15
		lea	ecx, [esp+20h+var_1C]
		push	ecx
		push	eax
		call	_sk_find
		add	esp, 8
		cmp	eax, 0FFFFFFFFh
		jz	short loc_B15
		lea	ecx, [eax+9]

loc_AAA:				; CODE XREF: _X509_check_purpose+61j
		cmp	ecx, 0FFFFFFFFh
		jz	short loc_B15
		test	ecx, ecx
		jns	short loc_AC8
		push	[esp+20h+arg_8]
		xor	eax, eax
		push	esi
		push	eax
		mov	eax, [eax+0Ch]
		call	eax
		add	esp, 0Ch
		pop	esi
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_AC8:				; CODE XREF: _X509_check_purpose+91j
		cmp	ecx, 9
		jge	short loc_AF0
		push	[esp+20h+arg_8]
		lea	eax, ds:0[ecx*8]
		sub	eax, ecx
		push	esi
		lea	eax, _xstandard[eax*4]
		push	eax
		mov	eax, [eax+0Ch]
		call	eax
		add	esp, 0Ch
		pop	esi
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_AF0:				; CODE XREF: _X509_check_purpose+ABj
		lea	eax, [ecx-9]
		push	eax
		push	ds:_xptable
		call	_sk_value
		add	esp, 8
		push	[esp+20h+arg_8]
		push	esi
		push	eax
		mov	eax, [eax+0Ch]
		call	eax
		add	esp, 0Ch
		pop	esi
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_B15:				; CODE XREF: _X509_check_purpose+6Ej
					; _X509_check_purpose+85j ...
		or	eax, 0FFFFFFFFh
		pop	esi
		add	esp, 1Ch
		retn
_X509_check_purpose endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B20h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509_supported_extension
_X509_supported_extension proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 4
		call	__chkstk
		push	[esp+4+arg_0]
		call	_X509_EXTENSION_get_object
		push	eax
		call	_OBJ_obj2nid
		add	esp, 8
		mov	[esp+4+var_4], eax
		test	eax, eax
		jnz	short loc_B45
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_B45:				; CODE XREF: _X509_supported_extension+21j
		push	offset _nid_cmp_BSEARCH_CMP_FN
		push	4
		push	0Bh
		lea	eax, [esp+10h+var_4]
		push	offset ?supported_nids@?1??X509_supported_extension@@9@9 ; `X509_supported_extension'::`2'::supported_nids
		push	eax
		call	_OBJ_bsearch_
		add	esp, 14h
		neg	eax
		sbb	eax, eax
		neg	eax
		pop	ecx
		retn
_X509_supported_extension endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B68h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_check_ca	proc near		; CODE XREF: _check_purpose_ssl_client+1Ap
					; _check_purpose_ssl_server+1Ap ...

arg_0		= dword	ptr  4

		mov	edx, [esp+arg_0]
		push	esi
		mov	ecx, [edx+28h]
		mov	esi, ecx
		and	esi, 2
		jz	short loc_B7D
		test	byte ptr [edx+2Ch], 4
		jz	short loc_BBF

loc_B7D:				; CODE XREF: _check_ca+Dj
		test	cl, 1
		jz	short loc_B8D
		movzx	eax, cl
		shr	eax, 4
		and	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_B8D:				; CODE XREF: _check_ca+18j
		mov	eax, ecx
		and	eax, 2040h
		cmp	eax, 2040h
		jnz	short loc_BA2
		mov	eax, 3
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_BA2:				; CODE XREF: _check_ca+31j
		test	esi, esi
		jz	short loc_BAD
		mov	eax, 4
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_BAD:				; CODE XREF: _check_ca+3Cj
		test	cl, 8
		jz	short loc_BBF
		test	byte ptr [edx+34h], 7
		jz	short loc_BBF
		mov	eax, 5
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_BBF:				; CODE XREF: _check_ca+13j
					; _check_ca+48j ...
		xor	eax, eax
		pop	esi
		retn
_check_ca	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0BC4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_check_ssl_ca	proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		push	esi
		call	_check_ca
		add	esp, 4
		test	eax, eax
		jz	short loc_BE1
		cmp	eax, 5
		jnz	short loc_BE3
		test	byte ptr [esi+34h], 4
		jnz	short loc_BE3

loc_BE1:				; CODE XREF: _check_ssl_ca+10j
		xor	eax, eax

loc_BE3:				; CODE XREF: _check_ssl_ca+15j
					; _check_ssl_ca+1Bj
		pop	esi
		retn
_check_ssl_ca	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0BE8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_nid_cmp	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	eax, [eax]
		sub	eax, [ecx]
		retn
_nid_cmp	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0BF8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_nid_cmp_BSEARCH_CMP_FN	proc near	; DATA XREF: _OBJ_bsearch_nido
					; _X509_supported_extension:loc_B45o ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	eax, [eax]
		sub	eax, [ecx]
		retn
_nid_cmp_BSEARCH_CMP_FN	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C08h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_purpose_smime	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, [esi+28h]
		test	al, 4
		jz	short loc_C1A
		test	byte ptr [esi+30h], 4
		jz	short loc_C39

loc_C1A:				; CODE XREF: _purpose_smime+Aj
		cmp	[esp+4+arg_4], 0
		jz	short loc_C3D
		push	esi
		call	_check_ca
		add	esp, 4
		test	eax, eax
		jz	short loc_C39
		cmp	eax, 5
		jnz	short loc_C58
		test	byte ptr [esi+34h], 2
		jnz	short loc_C58

loc_C39:				; CODE XREF: _purpose_smime+10j
					; _purpose_smime+24j
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_C3D:				; CODE XREF: _purpose_smime+17j
		test	al, 8
		jz	short loc_C53
		mov	eax, [esi+34h]
		test	al, 20h
		jnz	short loc_C53
		movzx	eax, al
		shr	eax, 6
		and	eax, 2
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_C53:				; CODE XREF: _purpose_smime+37j
					; _purpose_smime+3Ej
		mov	eax, 1

loc_C58:				; CODE XREF: _purpose_smime+29j
					; _purpose_smime+2Fj
		pop	esi
		retn
_purpose_smime	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C5Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_setup_crldp	proc near		; CODE XREF: _x509v3_cache_extensions+319p

arg_0		= dword	ptr  4

		push	ebx
		push	ebp
		mov	ebp, [esp+8+arg_0]
		push	0
		push	0
		push	67h ; 'g'
		push	ebp
		call	_X509_get_ext_d2i
		push	eax
		mov	[ebp+44h], eax
		xor	ebx, ebx
		call	_sk_num
		add	esp, 14h
		test	eax, eax
		jle	loc_D41
		push	esi
		push	edi
		nop	word ptr [eax+eax+00h]

loc_C8C:				; CODE XREF: _setup_crldp+DDj
		push	ebx
		push	dword ptr [ebp+44h]
		call	_sk_value
		mov	esi, eax
		add	esp, 8
		mov	ecx, [esi+4]
		test	ecx, ecx
		jz	short loc_CCA
		cmp	dword ptr [ecx], 0
		jle	short loc_CAF
		mov	eax, [ecx+8]
		movzx	eax, byte ptr [eax]
		mov	[esi+0Ch], eax

loc_CAF:				; CODE XREF: _setup_crldp+48j
		cmp	dword ptr [ecx], 1
		jle	short loc_CC1
		mov	eax, [ecx+8]
		movzx	eax, byte ptr [eax+1]
		shl	eax, 8
		or	[esi+0Ch], eax

loc_CC1:				; CODE XREF: _setup_crldp+56j
		and	dword ptr [esi+0Ch], 807Fh
		jmp	short loc_CD1
; ---------------------------------------------------------------------------

loc_CCA:				; CODE XREF: _setup_crldp+43j
		mov	dword ptr [esi+0Ch], 807Fh

loc_CD1:				; CODE XREF: _setup_crldp+6Cj
		mov	eax, [esi]
		test	eax, eax
		jz	short loc_D2B
		cmp	dword ptr [eax], 1
		jnz	short loc_D2B
		push	dword ptr [esi+8]
		xor	edi, edi
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jle	short loc_D17

loc_CED:				; CODE XREF: _setup_crldp+B0j
		push	edi
		push	dword ptr [esi+8]
		call	_sk_value
		add	esp, 8
		cmp	dword ptr [eax], 4
		jz	short loc_D10
		push	dword ptr [esi+8]
		inc	edi
		call	_sk_num
		add	esp, 4
		cmp	edi, eax
		jl	short loc_CED
		jmp	short loc_D17
; ---------------------------------------------------------------------------

loc_D10:				; CODE XREF: _setup_crldp+A0j
		mov	eax, [eax+4]
		test	eax, eax
		jnz	short loc_D20

loc_D17:				; CODE XREF: _setup_crldp+8Fj
					; _setup_crldp+B2j
		push	ebp
		call	_X509_get_issuer_name
		add	esp, 4

loc_D20:				; CODE XREF: _setup_crldp+B9j
		push	eax
		push	dword ptr [esi]
		call	_DIST_POINT_set_dpname
		add	esp, 8

loc_D2B:				; CODE XREF: _setup_crldp+79j
					; _setup_crldp+7Ej
		push	dword ptr [ebp+44h]
		inc	ebx
		call	_sk_num
		add	esp, 4
		cmp	ebx, eax
		jl	loc_C8C
		pop	edi
		pop	esi

loc_D41:				; CODE XREF: _setup_crldp+22j
		pop	ebp
		pop	ebx
		retn
_setup_crldp	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D44h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_setup_dp	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_4]
		mov	ecx, [esi+4]
		test	ecx, ecx
		jz	short loc_D79
		cmp	dword ptr [ecx], 0
		jle	short loc_D5E
		mov	eax, [ecx+8]
		movzx	eax, byte ptr [eax]
		mov	[esi+0Ch], eax

loc_D5E:				; CODE XREF: _setup_dp+Fj
		cmp	dword ptr [ecx], 1
		jle	short loc_D70
		mov	eax, [ecx+8]
		movzx	eax, byte ptr [eax+1]
		shl	eax, 8
		or	[esi+0Ch], eax

loc_D70:				; CODE XREF: _setup_dp+1Dj
		and	dword ptr [esi+0Ch], 807Fh
		jmp	short loc_D80
; ---------------------------------------------------------------------------

loc_D79:				; CODE XREF: _setup_dp+Aj
		mov	dword ptr [esi+0Ch], 807Fh

loc_D80:				; CODE XREF: _setup_dp+33j
		mov	eax, [esi]
		test	eax, eax
		jz	short loc_DE6
		cmp	dword ptr [eax], 1
		jnz	short loc_DE6
		push	edi
		push	dword ptr [esi+8]
		xor	edi, edi
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jle	short loc_DCE
		nop	dword ptr [eax+00000000h]

loc_DA4:				; CODE XREF: _setup_dp+7Fj
		push	edi
		push	dword ptr [esi+8]
		call	_sk_value
		add	esp, 8
		cmp	dword ptr [eax], 4
		jz	short loc_DC7
		push	dword ptr [esi+8]
		inc	edi
		call	_sk_num
		add	esp, 4
		cmp	edi, eax
		jl	short loc_DA4
		jmp	short loc_DCE
; ---------------------------------------------------------------------------

loc_DC7:				; CODE XREF: _setup_dp+6Fj
		mov	eax, [eax+4]
		test	eax, eax
		jnz	short loc_DDA

loc_DCE:				; CODE XREF: _setup_dp+57j
					; _setup_dp+81j
		push	[esp+8+arg_0]
		call	_X509_get_issuer_name
		add	esp, 4

loc_DDA:				; CODE XREF: _setup_dp+88j
		push	eax
		push	dword ptr [esi]
		call	_DIST_POINT_set_dpname
		add	esp, 8
		pop	edi

loc_DE6:				; CODE XREF: _setup_dp+40j
					; _setup_dp+45j
		pop	esi
		retn
_setup_dp	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0DE8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_x509v3_cache_extensions proc near	; CODE XREF: _X509_check_ca+22p
					; _X509_check_issued+33p ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 4
		call	__chkstk
		push	esi
		mov	esi, [esp+8+arg_0]
		test	dword ptr [esi+28h], 100h
		jnz	loc_11C0
		lea	eax, [esi+50h]
		push	0
		push	eax
		call	_EVP_sha1
		push	eax
		push	esi
		call	_X509_digest
		mov	eax, [esi]
		push	dword ptr [eax]
		call	_ASN1_INTEGER_get
		add	esp, 14h
		test	eax, eax
		jnz	short loc_E2A
		or	dword ptr [esi+28h], 40h

loc_E2A:				; CODE XREF: _x509v3_cache_extensions+3Cj
		push	edi
		push	0
		push	0
		push	57h ; 'W'
		push	esi
		call	_X509_get_ext_d2i
		mov	edi, eax
		add	esp, 10h
		test	edi, edi
		jz	short loc_E90
		cmp	dword ptr [edi], 0
		jz	short loc_E49
		or	dword ptr [esi+28h], 10h

loc_E49:				; CODE XREF: _x509v3_cache_extensions+5Bj
		mov	eax, [edi+4]
		test	eax, eax
		jz	short loc_E7C
		cmp	dword ptr [eax+4], 102h
		jz	short loc_E6C
		cmp	dword ptr [edi], 0
		jz	short loc_E6C
		push	eax
		call	_ASN1_INTEGER_get
		add	esp, 4
		mov	[esi+20h], eax
		jmp	short loc_E83
; ---------------------------------------------------------------------------

loc_E6C:				; CODE XREF: _x509v3_cache_extensions+6Fj
					; _x509v3_cache_extensions+74j
		or	dword ptr [esi+28h], 80h
		mov	dword ptr [esi+20h], 0
		jmp	short loc_E83
; ---------------------------------------------------------------------------

loc_E7C:				; CODE XREF: _x509v3_cache_extensions+66j
		mov	dword ptr [esi+20h], 0FFFFFFFFh

loc_E83:				; CODE XREF: _x509v3_cache_extensions+82j
					; _x509v3_cache_extensions+92j
		push	edi
		call	_BASIC_CONSTRAINTS_free
		add	esp, 4
		or	dword ptr [esi+28h], 1

loc_E90:				; CODE XREF: _x509v3_cache_extensions+56j
		push	0
		push	0
		push	297h
		push	esi
		call	_X509_get_ext_d2i
		mov	edi, eax
		add	esp, 10h
		test	edi, edi
		jz	short loc_F02
		test	byte ptr [esi+28h], 10h
		jnz	short loc_ED0
		push	0FFFFFFFFh
		push	55h ; 'U'
		push	esi
		call	_X509_get_ext_by_NID
		add	esp, 0Ch
		test	eax, eax
		jns	short loc_ED0
		push	0FFFFFFFFh
		push	56h ; 'V'
		push	esi
		call	_X509_get_ext_by_NID
		add	esp, 0Ch
		test	eax, eax
		js	short loc_ED7

loc_ED0:				; CODE XREF: _x509v3_cache_extensions+C4j
					; _x509v3_cache_extensions+D5j
		or	dword ptr [esi+28h], 80h

loc_ED7:				; CODE XREF: _x509v3_cache_extensions+E6j
		mov	eax, [edi]
		test	eax, eax
		jz	short loc_EEB
		push	eax
		call	_ASN1_INTEGER_get
		add	esp, 4
		mov	[esi+24h], eax
		jmp	short loc_EF2
; ---------------------------------------------------------------------------

loc_EEB:				; CODE XREF: _x509v3_cache_extensions+F3j
		mov	dword ptr [esi+24h], 0FFFFFFFFh

loc_EF2:				; CODE XREF: _x509v3_cache_extensions+101j
		push	edi
		call	_PROXY_CERT_INFO_EXTENSION_free
		add	esp, 4
		or	dword ptr [esi+28h], 400h

loc_F02:				; CODE XREF: _x509v3_cache_extensions+BEj
		push	0
		push	0
		push	53h ; 'S'
		push	esi
		call	_X509_get_ext_d2i
		mov	edx, eax
		add	esp, 10h
		test	edx, edx
		jz	short loc_F4F
		cmp	dword ptr [edx], 0
		jle	short loc_F3B
		mov	ecx, [edx+8]
		movzx	ecx, byte ptr [ecx]
		mov	[esi+2Ch], ecx
		cmp	dword ptr [edx], 1
		jle	short loc_F42
		mov	eax, [edx+8]
		movzx	eax, byte ptr [eax+1]
		shl	eax, 8
		or	eax, ecx
		mov	[esi+2Ch], eax
		jmp	short loc_F42
; ---------------------------------------------------------------------------

loc_F3B:				; CODE XREF: _x509v3_cache_extensions+132j
		mov	dword ptr [esi+2Ch], 0

loc_F42:				; CODE XREF: _x509v3_cache_extensions+140j
					; _x509v3_cache_extensions+151j
		or	dword ptr [esi+28h], 2
		push	edx
		call	_ASN1_BIT_STRING_free
		add	esp, 4

loc_F4F:				; CODE XREF: _x509v3_cache_extensions+12Dj
		push	0
		push	0
		push	7Eh ; '~'
		push	esi
		mov	dword ptr [esi+30h], 0
		call	_X509_get_ext_d2i
		mov	edi, eax
		add	esp, 10h
		test	edi, edi
		jz	loc_1029
		or	dword ptr [esi+28h], 4
		push	edi
		mov	[esp+10h+arg_0], 0
		call	_sk_num
		mov	ecx, [esp+10h+arg_0]
		add	esp, 4
		cmp	ecx, eax
		jge	loc_101B

loc_F90:				; CODE XREF: _x509v3_cache_extensions+22Dj
		push	ecx
		push	edi
		call	_sk_value
		push	eax
		call	_OBJ_obj2nid
		add	esp, 0Ch
		cmp	eax, 0B4h ; '¥'
		jg	short loc_FE4
		jz	short loc_FDE
		sub	eax, 81h	; switch 11 cases
		cmp	eax, 0Ah
		ja	short $LN2	; jumptable 00000FB3 default case
		jmp	ds:$LN68[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN29:					; CODE XREF: _x509v3_cache_extensions+1CBj
					; DATA XREF: .text$mn:$LN68o
		or	dword ptr [esi+30h], 1 ; jumptable 00000FB3 case 129
		jmp	short $LN2	; jumptable 00000FB3 default case
; ---------------------------------------------------------------------------

$LN30:					; CODE XREF: _x509v3_cache_extensions+1CBj
					; DATA XREF: .text$mn:$LN68o
		or	dword ptr [esi+30h], 2 ; jumptable 00000FB3 case 130
		jmp	short $LN2	; jumptable 00000FB3 default case
; ---------------------------------------------------------------------------

$LN31:					; CODE XREF: _x509v3_cache_extensions+1CBj
					; DATA XREF: .text$mn:$LN68o
		or	dword ptr [esi+30h], 4 ; jumptable 00000FB3 case 132
		jmp	short $LN2	; jumptable 00000FB3 default case
; ---------------------------------------------------------------------------

$LN32:					; CODE XREF: _x509v3_cache_extensions+1CBj
					; DATA XREF: .text$mn:$LN68o
		or	dword ptr [esi+30h], 8 ; jumptable 00000FB3 case 131
		jmp	short $LN2	; jumptable 00000FB3 default case
; ---------------------------------------------------------------------------

$LN33:					; CODE XREF: _x509v3_cache_extensions+1CBj
					; DATA XREF: .text$mn:$LN68o
		or	dword ptr [esi+30h], 10h ; jumptable 00000FB3 cases 137,139
		jmp	short $LN2	; jumptable 00000FB3 default case
; ---------------------------------------------------------------------------

$LN35:					; CODE XREF: _x509v3_cache_extensions+1CBj
					; DATA XREF: .text$mn:$LN68o
		or	dword ptr [esi+30h], 40h ; jumptable 00000FB3 case 133
		jmp	short $LN2	; jumptable 00000FB3 default case
; ---------------------------------------------------------------------------

loc_FDE:				; CODE XREF: _x509v3_cache_extensions+1BFj
		or	dword ptr [esi+30h], 20h
		jmp	short $LN2	; jumptable 00000FB3 default case
; ---------------------------------------------------------------------------

loc_FE4:				; CODE XREF: _x509v3_cache_extensions+1BDj
		cmp	eax, 129h
		jz	short loc_FFB
		cmp	eax, 38Eh
		jnz	short $LN2	; jumptable 00000FB3 default case
		or	dword ptr [esi+30h], 100h
		jmp	short $LN2	; jumptable 00000FB3 default case
; ---------------------------------------------------------------------------

loc_FFB:				; CODE XREF: _x509v3_cache_extensions+201j
		or	dword ptr [esi+30h], 80h

$LN2:					; CODE XREF: _x509v3_cache_extensions+1C9j
					; _x509v3_cache_extensions+1CBj ...
		inc	[esp+0Ch+arg_0]	; jumptable 00000FB3 default case
		push	edi
		call	_sk_num
		mov	ecx, [esp+10h+arg_0]
		add	esp, 4
		cmp	ecx, eax
		jl	loc_F90

loc_101B:				; CODE XREF: _x509v3_cache_extensions+1A2j
		push	offset _ASN1_OBJECT_free
		push	edi
		call	_sk_pop_free
		add	esp, 8

loc_1029:				; CODE XREF: _x509v3_cache_extensions+181j
		push	0
		push	0
		push	47h ; 'G'
		push	esi
		call	_X509_get_ext_d2i
		add	esp, 10h
		test	eax, eax
		jz	short loc_1060
		cmp	dword ptr [eax], 0
		jle	short loc_104C
		mov	ecx, [eax+8]
		movzx	ecx, byte ptr [ecx]
		mov	[esi+34h], ecx
		jmp	short loc_1053
; ---------------------------------------------------------------------------

loc_104C:				; CODE XREF: _x509v3_cache_extensions+257j
		mov	dword ptr [esi+34h], 0

loc_1053:				; CODE XREF: _x509v3_cache_extensions+262j
		or	dword ptr [esi+28h], 8
		push	eax
		call	_ASN1_BIT_STRING_free
		add	esp, 4

loc_1060:				; CODE XREF: _x509v3_cache_extensions+252j
		push	0
		push	0
		push	52h ; 'R'
		push	esi
		call	_X509_get_ext_d2i
		push	0
		push	0
		push	5Ah ; 'Z'
		push	esi
		mov	[esi+38h], eax
		call	_X509_get_ext_d2i
		push	esi
		mov	[esi+3Ch], eax
		call	_X509_get_issuer_name
		add	esp, 24h
		push	eax
		push	esi
		call	_X509_get_subject_name
		add	esp, 4
		push	eax
		call	_X509_NAME_cmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_10C7
		push	dword ptr [esi+3Ch]
		or	dword ptr [esi+28h], 20h
		push	esi
		call	_X509_check_akid
		add	esp, 8
		test	eax, eax
		jnz	short loc_10C7
		mov	eax, [esi+28h]
		test	al, 2
		jz	short loc_10BF
		test	byte ptr [esi+2Ch], 4
		jz	short loc_10C7

loc_10BF:				; CODE XREF: _x509v3_cache_extensions+2CFj
		or	eax, 2000h
		mov	[esi+28h], eax

loc_10C7:				; CODE XREF: _x509v3_cache_extensions+2B4j
					; _x509v3_cache_extensions+2C8j ...
		push	0
		push	0
		push	55h ; 'U'
		push	esi
		call	_X509_get_ext_d2i
		mov	[esi+48h], eax
		lea	eax, [esp+1Ch+arg_0]
		push	0
		push	eax
		push	29Ah
		push	esi
		call	_X509_get_ext_d2i
		add	esp, 20h
		mov	[esi+4Ch], eax
		test	eax, eax
		jnz	short loc_1100
		cmp	[esp+0Ch+arg_0], 0FFFFFFFFh
		jz	short loc_1100
		or	dword ptr [esi+28h], 80h

loc_1100:				; CODE XREF: _x509v3_cache_extensions+308j
					; _x509v3_cache_extensions+30Fj
		push	esi
		call	_setup_crldp
		push	esi
		mov	[esp+14h+arg_0], 0
		call	_X509_get_ext_count
		mov	ecx, [esp+14h+arg_0]
		add	esp, 8
		cmp	ecx, eax
		jge	loc_11B8
		nop	dword ptr [eax+eax+00h]

loc_1128:				; CODE XREF: _x509v3_cache_extensions+3BCj
		push	ecx
		push	esi
		call	_X509_get_ext
		mov	edi, eax
		push	edi
		call	_X509_EXTENSION_get_object
		push	eax
		call	_OBJ_obj2nid
		add	esp, 10h
		cmp	eax, 359h
		jnz	short loc_114E
		or	dword ptr [esi+28h], 1000h

loc_114E:				; CODE XREF: _x509v3_cache_extensions+35Dj
		push	edi
		call	_X509_EXTENSION_get_critical
		add	esp, 4
		test	eax, eax
		jz	short loc_1191
		push	edi
		call	_X509_EXTENSION_get_object
		push	eax
		call	_OBJ_obj2nid
		add	esp, 8
		mov	[esp+0Ch+var_4], eax
		test	eax, eax
		jz	short loc_11B1
		push	offset _nid_cmp_BSEARCH_CMP_FN
		push	4
		push	0Bh
		lea	eax, [esp+18h+var_4]
		push	offset ?supported_nids@?1??X509_supported_extension@@9@9 ; `X509_supported_extension'::`2'::supported_nids
		push	eax
		call	_OBJ_bsearch_
		add	esp, 14h
		test	eax, eax
		jz	short loc_11B1

loc_1191:				; CODE XREF: _x509v3_cache_extensions+371j
		inc	[esp+0Ch+arg_0]
		push	esi
		call	_X509_get_ext_count
		mov	ecx, [esp+10h+arg_0]
		add	esp, 4
		cmp	ecx, eax
		jl	short loc_1128
		or	dword ptr [esi+28h], 100h
		pop	edi
		pop	esi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_11B1:				; CODE XREF: _x509v3_cache_extensions+388j
					; _x509v3_cache_extensions+3A7j
		or	dword ptr [esi+28h], 200h

loc_11B8:				; CODE XREF: _x509v3_cache_extensions+335j
		or	dword ptr [esi+28h], 100h
		pop	edi

loc_11C0:				; CODE XREF: _x509v3_cache_extensions+16j
		pop	esi
		pop	ecx
		retn
_x509v3_cache_extensions endp

; ---------------------------------------------------------------------------
		align 4
$LN68		dd offset $LN29		; DATA XREF: _x509v3_cache_extensions+1CBr
		dd offset $LN30		; jump table for switch	statement
		dd offset $LN32
		dd offset $LN31
		dd offset $LN35
		dd offset $LN2
		dd offset $LN2
		dd offset $LN2
		dd offset $LN33
		dd offset $LN2
		dd offset $LN33
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 11F0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_xp_cmp		proc near		; DATA XREF: _X509_PURPOSE_add+128o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	edx, [eax]
		mov	eax, [esp+arg_4]
		mov	ecx, [eax]
		mov	eax, [edx]
		sub	eax, [ecx]
		retn
_xp_cmp		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1204h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_xptable_free	proc near		; DATA XREF: _X509_PURPOSE_cleanup+2o

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	short loc_1234
		mov	eax, [esi+8]
		test	al, 1
		jz	short loc_1234
		test	al, 2
		jz	short loc_122B
		push	dword ptr [esi+10h]
		call	_CRYPTO_free
		push	dword ptr [esi+14h]
		call	_CRYPTO_free
		add	esp, 8

loc_122B:				; CODE XREF: _xptable_free+12j
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_1234:				; CODE XREF: _xptable_free+7j
					; _xptable_free+Ej
		pop	esi
		retn
_xptable_free	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1238h
; COMDAT (pick any)
		public ??_C@_0BK@COINEMNE@?4?2crypto?2x509v3?2v3_purp?4c?$AA@
; `string'
??_C@_0BK@COINEMNE@?4?2crypto?2x509v3?2v3_purp?4c?$AA@ db '.\crypto\x509v3\v3_purp.c',0
					; DATA XREF: _X509_PURPOSE_add+5Fo
					; _X509_PURPOSE_add:loc_634o ...
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _sk_num:near	; CODE XREF: _X509_PURPOSE_get_by_sname+1Fp
					; _X509_PURPOSE_get_count+10p ...
		extrn _sk_value:near	; CODE XREF: _X509_PURPOSE_add+B0p
					; _X509_PURPOSE_get0+2Bp ...
		extrn _sk_new:near	; CODE XREF: _X509_PURPOSE_add+12Dp
		extrn _sk_pop_free:near	; CODE XREF: _X509_PURPOSE_cleanup+Dp
					; _x509v3_cache_extensions+239p
		extrn _sk_find:near	; CODE XREF: _X509_PURPOSE_add+41p
					; _X509_PURPOSE_get_by_id+35p ...
		extrn _sk_push:near	; CODE XREF: _X509_PURPOSE_add+147p
		extrn _CRYPTO_lock:near	; CODE XREF: _X509_check_ca+1Cp
					; _X509_check_ca+35p ...
		extrn _CRYPTO_malloc:near ; CODE XREF: _X509_PURPOSE_add+66p
		extrn _CRYPTO_free:near	; CODE XREF: _X509_PURPOSE_add+C3p
					; _X509_PURPOSE_add+CBp ...
		extrn _BUF_strdup:near	; CODE XREF: _X509_PURPOSE_add+D7p
					; _X509_PURPOSE_add+E3p
		extrn _ERR_put_error:near ; CODE XREF: _X509_PURPOSE_add+17Ap
					; _X509_PURPOSE_set+6Ap
		extrn _ASN1_OBJECT_free:near ; DATA XREF: _x509v3_cache_extensions:loc_101Bo
		extrn _ASN1_BIT_STRING_free:near ; CODE	XREF: _x509v3_cache_extensions+15Fp
					; _x509v3_cache_extensions+270p
		extrn _ASN1_INTEGER_cmp:near ; CODE XREF: _X509_check_akid+47p
		extrn _ASN1_OCTET_STRING_cmp:near ; CODE XREF: _X509_check_akid+21p
		extrn _ASN1_INTEGER_get:near ; CODE XREF: _x509v3_cache_extensions+32p
					; _x509v3_cache_extensions+77p	...
		extrn _OBJ_obj2nid:near	; CODE XREF: _X509_supported_extension+14p
					; _x509v3_cache_extensions+1B0p ...
		extrn _OBJ_bsearch_:near ; CODE	XREF: _OBJ_bsearch_nid+13p
					; _X509_supported_extension+38p ...
		extrn _EVP_sha1:near	; CODE XREF: _x509v3_cache_extensions+22p
		extrn _X509_digest:near	; CODE XREF: _x509v3_cache_extensions+29p
		extrn _X509_get_serialNumber:near ; CODE XREF: _X509_check_akid+3Ep
		extrn _X509_get_issuer_name:near ; CODE	XREF: _X509_check_akid+9Dp
					; _X509_check_issued+7p ...
		extrn _X509_get_subject_name:near ; CODE XREF: _X509_check_issued+15p
					; _x509v3_cache_extensions+2A1p
		extrn _X509_NAME_cmp:near ; CODE XREF: _X509_check_akid+A4p
					; _X509_check_issued+1Ep ...
		extrn _X509_get_ext_count:near ; CODE XREF: _x509v3_cache_extensions+327p
					; _x509v3_cache_extensions+3AEp
		extrn _X509_get_ext_by_NID:near
					; CODE XREF: _check_purpose_timestamp_sign+3Fp
					; _x509v3_cache_extensions+CBp	...
		extrn _X509_get_ext:near ; CODE	XREF: _check_purpose_timestamp_sign+4Dp
					; _x509v3_cache_extensions+342p
		extrn _X509_get_ext_d2i:near ; CODE XREF: _setup_crldp+Dp
					; _x509v3_cache_extensions+4Ap	...
		extrn _X509_EXTENSION_get_object:near
					; CODE XREF: _X509_supported_extension+Ep
					; _x509v3_cache_extensions+34Ap ...
		extrn _X509_EXTENSION_get_critical:near
					; CODE XREF: _check_purpose_timestamp_sign+53p
					; _x509v3_cache_extensions+367p
		extrn _PROXY_CERT_INFO_EXTENSION_free:near
					; CODE XREF: _x509v3_cache_extensions+10Bp
		extrn _BASIC_CONSTRAINTS_free:near ; CODE XREF:	_x509v3_cache_extensions+9Cp
		extrn _DIST_POINT_set_dpname:near ; CODE XREF: _setup_crldp+C7p
					; _setup_dp+99p
		extrn __chkstk:near	; CODE XREF: _X509_PURPOSE_add+5p
					; _X509_PURPOSE_get_by_id+5p ...


		end
