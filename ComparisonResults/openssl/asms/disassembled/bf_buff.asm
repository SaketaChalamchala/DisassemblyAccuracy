;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	57207891391FC55570549695445CE64F
; Input	CRC32 :	F187EC77

; File Name   :	C:\compspace\Diff\openssl\obj\bf_buff.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl buffer_write(int,	void *Src, size_t Size)
_buffer_write	proc near		; CODE XREF: _buffer_puts+1Fp
					; DATA XREF: .data:000008C0o

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
Src		= dword	ptr  8
Size		= dword	ptr  0Ch

		mov	eax, 4
		call	__chkstk
		cmp	[esp+4+Src], 0
		push	ebx
		mov	[esp+8+var_4], 0
		jz	loc_180
		mov	ebx, [esp+8+Size]
		test	ebx, ebx
		jle	loc_180
		push	ebp
		mov	ebp, [esp+0Ch+arg_0]
		push	esi
		mov	esi, [ebp+20h]
		test	esi, esi
		jz	loc_179
		cmp	dword ptr [ebp+24h], 0
		jz	loc_179
		push	edi
		push	0Fh
		push	ebp
		call	_BIO_clear_flags
		mov	edi, [esi+4]
		add	esp, 8
		sub	edi, [esi+1Ch]
		sub	edi, [esi+18h]
		cmp	edi, ebx
		jge	loc_130

$start$52:				; CODE XREF: _buffer_write+12Aj
		mov	ecx, [esi+18h]
		test	ecx, ecx
		jz	short loc_CA
		test	edi, edi
		jle	short loc_90
		mov	eax, [esi+14h]
		add	eax, [esi+1Ch]
		push	edi		; Size
		push	[esp+18h+Src]	; Src
		add	eax, ecx
		push	eax		; Dst
		call	_memcpy
		add	[esp+20h+Src], edi
		add	esp, 0Ch
		add	[esp+14h+var_4], edi
		sub	ebx, edi
		add	[esi+18h], edi

loc_90:					; CODE XREF: _buffer_write+6Bj
					; _buffer_write+C8j
		push	dword ptr [esi+18h]
		mov	eax, [esi+1Ch]
		add	eax, [esi+14h]
		push	eax
		push	dword ptr [ebp+24h]
		call	_BIO_write
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jg	short loc_C2
		push	ebp
		call	_BIO_copy_next_retry
		add	esp, 4
		test	edi, edi
		js	loc_160
		jz	loc_156

loc_C2:					; CODE XREF: _buffer_write+A9j
		add	[esi+1Ch], edi
		sub	[esi+18h], edi
		jnz	short loc_90

loc_CA:					; CODE XREF: _buffer_write+67j
		mov	dword ptr [esi+1Ch], 0
		cmp	ebx, [esi+4]
		jl	short loc_11F
		mov	eax, [esp+14h+Src]
		nop	word ptr [eax+eax+00h]

loc_E0:					; CODE XREF: _buffer_write+11Dj
		push	ebx
		push	eax
		push	dword ptr [ebp+24h]
		call	_BIO_write
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jg	short loc_102
		push	ebp
		call	_BIO_copy_next_retry
		add	esp, 4
		test	edi, edi
		js	short loc_160
		jz	short loc_156

loc_102:				; CODE XREF: _buffer_write+F1j
		mov	ecx, [esp+14h+var_4]
		mov	eax, [esp+14h+Src]
		add	ecx, edi
		add	eax, edi
		mov	[esp+14h+var_4], ecx
		mov	[esp+14h+Src], eax
		sub	ebx, edi
		jz	short loc_171
		cmp	ebx, [esi+4]
		jge	short loc_E0

loc_11F:				; CODE XREF: _buffer_write+D4j
		mov	edi, [esi+4]
		sub	edi, [esi+1Ch]
		sub	edi, [esi+18h]
		cmp	edi, ebx
		jl	$start$52

loc_130:				; CODE XREF: _buffer_write+5Cj
		mov	eax, [esi+14h]
		add	eax, [esi+1Ch]
		add	eax, [esi+18h]
		push	ebx		; Size
		push	[esp+18h+Src]	; Src
		push	eax		; Dst
		call	_memcpy
		add	[esi+18h], ebx
		add	esp, 0Ch
		mov	eax, [esp+14h+var_4]
		add	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_156:				; CODE XREF: _buffer_write+BCj
					; _buffer_write+100j
		mov	eax, [esp+14h+var_4]
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_160:				; CODE XREF: _buffer_write+B6j
					; _buffer_write+FEj
		mov	eax, [esp+14h+var_4]
		test	eax, eax
		cmovg	edi, eax
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_171:				; CODE XREF: _buffer_write+118j
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, ecx
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_179:				; CODE XREF: _buffer_write+35j
					; _buffer_write+3Fj
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_180:				; CODE XREF: _buffer_write+18j
					; _buffer_write+24j
		xor	eax, eax
		pop	ebx
		pop	ecx
		retn
_buffer_write	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 188h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl buffer_read(int, void *Dst, size_t Size)
_buffer_read	proc near		; DATA XREF: .data:000008C4o

arg_0		= dword	ptr  4
Dst		= dword	ptr  8
Size		= dword	ptr  0Ch

		push	ebp
		mov	ebp, [esp+4+Dst]
		test	ebp, ebp
		jnz	short loc_195
		xor	eax, eax
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_195:				; CODE XREF: _buffer_read+7j
		mov	ecx, [esp+4+arg_0]
		push	esi
		mov	esi, [ecx+20h]
		test	esi, esi
		jz	loc_299
		cmp	dword ptr [ecx+24h], 0
		jz	loc_299
		push	edi
		xor	eax, eax
		push	0Fh
		push	ecx
		mov	[esp+14h+Dst], eax
		call	_BIO_clear_flags
		mov	edi, [esp+14h+Size]
		add	esp, 8
		push	ebx
		xchg	ax, ax

$start$43:				; CODE XREF: _buffer_read+B0j
		mov	ebx, [esi+0Ch]
		test	ebx, ebx
		jz	short loc_1FD
		mov	eax, [esi+8]
		cmp	ebx, edi
		cmovg	ebx, edi
		add	eax, [esi+10h]
		push	ebx		; Size
		push	eax		; Src
		push	ebp		; Dst
		call	_memcpy
		mov	eax, [esp+1Ch+Dst]
		add	esp, 0Ch
		add	[esi+10h], ebx
		add	eax, ebx
		sub	[esi+0Ch], ebx
		mov	[esp+10h+Dst], eax
		cmp	edi, ebx
		jz	short loc_23E
		sub	edi, ebx
		add	ebp, ebx

loc_1FD:				; CODE XREF: _buffer_read+45j
		mov	eax, [esi]
		cmp	edi, eax
		jg	short loc_253
		push	eax
		mov	eax, [esp+14h+arg_0]

loc_208:				; DATA XREF: .data:_methods_buffero
		push	dword ptr [esi+8]
		push	dword ptr [eax+24h]
		call	_BIO_read
		mov	ebx, eax
		add	esp, 0Ch
		test	ebx, ebx
		jg	short loc_22E
		push	[esp+10h+arg_0]
		call	_BIO_copy_next_retry
		add	esp, 4
		test	ebx, ebx
		js	short loc_243
		jz	short loc_23A

loc_22E:				; CODE XREF: _buffer_read+92j
		mov	dword ptr [esi+10h], 0
		mov	[esi+0Ch], ebx
		jmp	short $start$43
; ---------------------------------------------------------------------------

loc_23A:				; CODE XREF: _buffer_read+A4j
		mov	eax, [esp+10h+Dst]

loc_23E:				; CODE XREF: _buffer_read+6Fj
		pop	ebx
		pop	edi
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_243:				; CODE XREF: _buffer_read+A2j
		mov	eax, [esp+10h+Dst]
		test	eax, eax
		cmovg	ebx, eax

loc_24C:				; CODE XREF: _buffer_read+F7j
					; _buffer_read+FDj
		mov	eax, ebx
		pop	ebx
		pop	edi
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_253:				; CODE XREF: _buffer_read+79j
		mov	ebx, [esp+10h+Dst]
		nop

loc_258:				; CODE XREF: _buffer_read+103j
		mov	eax, [esp+10h+arg_0]
		push	edi
		push	ebp
		push	dword ptr [eax+24h]
		call	_BIO_read
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jg	short loc_281
		push	[esp+10h+arg_0]
		call	_BIO_copy_next_retry
		add	esp, 4
		test	esi, esi
		js	short loc_28D
		jz	short loc_24C

loc_281:				; CODE XREF: _buffer_read+E5j
		add	ebx, esi
		cmp	edi, esi
		jz	short loc_24C
		add	ebp, esi
		sub	edi, esi
		jmp	short loc_258
; ---------------------------------------------------------------------------

loc_28D:				; CODE XREF: _buffer_read+F5j
		test	ebx, ebx
		cmovg	esi, ebx
		pop	ebx
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_299:				; CODE XREF: _buffer_read+17j
					; _buffer_read+21j
		pop	esi
		xor	eax, eax
		pop	ebp
		retn
_buffer_read	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2A0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl buffer_puts(int, void *Src)
_buffer_puts	proc near		; DATA XREF: .data:000008C8o

arg_0		= dword	ptr  4
Src		= dword	ptr  8

		mov	edx, [esp+Src]
		mov	eax, edx
		push	esi
		lea	esi, [eax+1]
		nop	word ptr [eax+eax+00h]

loc_2B0:				; CODE XREF: _buffer_puts+15j
		mov	cl, [eax]
		inc	eax
		test	cl, cl
		jnz	short loc_2B0
		sub	eax, esi
		push	eax		; Size
		push	edx		; Src
		push	[esp+0Ch+arg_0]	; int
		call	_buffer_write
		add	esp, 0Ch
		pop	esi
		retn
_buffer_puts	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2CCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_buffer_gets	proc near		; DATA XREF: .data:000008CCo

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 4
		call	__chkstk
		mov	eax, [esp+4+arg_0]
		push	ebx
		push	ebp
		mov	ebp, [esp+0Ch+arg_8]
		push	esi
		mov	esi, [eax+20h]
		dec	ebp
		push	edi
		push	0Fh
		xor	edi, edi
		push	eax
		mov	[esp+1Ch+var_4], edi
		call	_BIO_clear_flags
		mov	ebx, [esp+1Ch+arg_4]
		add	esp, 8
		nop

loc_2FC:				; CODE XREF: _buffer_gets+8Aj
					; _buffer_gets+D4j
		mov	ecx, [esi+0Ch]
		test	ecx, ecx
		jle	short loc_363
		mov	edx, [esi+8]
		xor	eax, eax
		add	edx, [esi+10h]
		mov	[esp+14h+arg_8], 0
		test	ecx, ecx
		jle	short loc_340
		nop	dword ptr [eax+eax+00h]

loc_31C:				; CODE XREF: _buffer_gets+64j
		cmp	eax, ebp
		jge	short loc_332
		mov	cl, [eax+edx]
		mov	[ebx], cl
		inc	ebx
		cmp	byte ptr [eax+edx], 0Ah
		jz	short loc_338
		inc	eax
		cmp	eax, [esi+0Ch]
		jl	short loc_31C

loc_332:				; CODE XREF: _buffer_gets+52j
		mov	ecx, [esp+14h+arg_8]
		jmp	short loc_342
; ---------------------------------------------------------------------------

loc_338:				; CODE XREF: _buffer_gets+5Ej
		mov	ecx, 1
		inc	eax
		jmp	short loc_342
; ---------------------------------------------------------------------------

loc_340:				; CODE XREF: _buffer_gets+49j
		xor	ecx, ecx

loc_342:				; CODE XREF: _buffer_gets+6Aj
					; _buffer_gets+72j
		sub	[esi+0Ch], eax
		add	edi, eax
		add	[esi+10h], eax
		sub	ebp, eax
		mov	[esp+14h+var_4], edi
		test	ecx, ecx
		jnz	short loc_358
		test	ebp, ebp
		jnz	short loc_2FC

loc_358:				; CODE XREF: _buffer_gets+86j
		mov	eax, edi
		mov	byte ptr [ebx],	0
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_363:				; CODE XREF: _buffer_gets+35j
		push	dword ptr [esi]
		mov	eax, [esp+18h+arg_0]
		push	dword ptr [esi+8]
		push	dword ptr [eax+24h]
		call	_BIO_read
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jg	short loc_392
		push	[esp+14h+arg_0]
		call	_BIO_copy_next_retry
		add	esp, 4
		mov	byte ptr [ebx],	0
		test	edi, edi
		js	short loc_3AF
		jz	short loc_3A5

loc_392:				; CODE XREF: _buffer_gets+AFj
		mov	[esi+0Ch], edi
		mov	edi, [esp+14h+var_4]
		mov	dword ptr [esi+10h], 0
		jmp	loc_2FC
; ---------------------------------------------------------------------------

loc_3A5:				; CODE XREF: _buffer_gets+C4j
		mov	eax, [esp+14h+var_4]
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_3AF:				; CODE XREF: _buffer_gets+C2j
		mov	eax, [esp+14h+var_4]
		test	eax, eax
		cmovg	edi, eax
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
_buffer_gets	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3C0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl buffer_ctrl(int, int, size_t Size, void *Src)
_buffer_ctrl	proc near		; DATA XREF: .data:000008D0o

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
Size		= dword	ptr  0Ch
Src		= dword	ptr  10h

		mov	eax, 4
		call	__chkstk
		push	ebx
		mov	ebx, [esp+8+arg_0]
		push	ebp
		mov	ebp, [esp+0Ch+arg_4]
		push	esi
		mov	esi, [ebx+20h]
		push	edi
		lea	eax, [ebp-1]	; switch 122 cases
		mov	edi, 1
		cmp	eax, 79h ; 'y'
		ja	short $LN48	; jumptable 000003ED default case
		movzx	eax, ds:$LN59[eax]
		jmp	ds:$LN69[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN10:					; CODE XREF: _buffer_ctrl+2Dj
					; DATA XREF: .text$mn:$LN69o
		mov	dword ptr [esi+10h], 0 ; jumptable 000003ED case 1
		mov	dword ptr [esi+0Ch], 0
		mov	dword ptr [esi+1Ch], 0
		mov	dword ptr [esi+18h], 0
		jmp	short $LN48	; jumptable 000003ED default case
; ---------------------------------------------------------------------------

$LN12:					; CODE XREF: _buffer_ctrl+2Dj
					; DATA XREF: .text$mn:$LN69o
		mov	edi, [esi+18h]	; jumptable 000003ED case 3
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$LN13:					; CODE XREF: _buffer_ctrl+2Dj
					; DATA XREF: .text$mn:$LN69o
		mov	edx, [esi+0Ch]	; jumptable 000003ED case 116
		xor	edi, edi
		mov	ebx, [esi+8]
		xor	ecx, ecx
		test	edx, edx
		jle	short loc_46A
		mov	eax, [esi+10h]
		add	eax, ebx

loc_430:				; CODE XREF: _buffer_ctrl+7Aj
		cmp	byte ptr [eax+ecx], 0Ah
		jnz	short loc_437
		inc	edi

loc_437:				; CODE XREF: _buffer_ctrl+74j
		inc	ecx
		cmp	ecx, edx
		jl	short loc_430
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$LN15:					; CODE XREF: _buffer_ctrl+2Dj
					; DATA XREF: .text$mn:$LN69o
		mov	edi, [esi+18h]	; jumptable 000003ED case 13

loc_447:				; CODE XREF: _buffer_ctrl+B5j
		test	edi, edi
		jnz	short loc_46A

$LN48:					; CODE XREF: _buffer_ctrl+24j
					; _buffer_ctrl+2Dj ...
		mov	eax, [ebx+24h]	; jumptable 000003ED default case
		test	eax, eax
		jz	loc_586

loc_456:				; CODE XREF: _buffer_ctrl+26Ej
		push	[esp+14h+Src]
		push	[esp+18h+Size]
		push	ebp
		push	eax
		call	_BIO_ctrl
		mov	edi, eax
		add	esp, 10h

loc_46A:				; CODE XREF: _buffer_ctrl+69j
					; _buffer_ctrl+89j ...
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$LN18:					; CODE XREF: _buffer_ctrl+2Dj
					; DATA XREF: .text$mn:$LN69o
		mov	edi, [esi+0Ch]	; jumptable 000003ED case 10
		jmp	short loc_447
; ---------------------------------------------------------------------------

$LN21:					; CODE XREF: _buffer_ctrl+2Dj
					; DATA XREF: .text$mn:$LN69o
		mov	edi, [esp+14h+Size] ; jumptable	000003ED case 122
		cmp	edi, [esi]
		jle	short loc_4AF
		push	153h
		push	offset ??_C@_0BH@HEBHEJFA@?4?2crypto?2bio?2bf_buff?4c?$AA@ ; ".\\crypto\\bio\\bf_buff.c"
		push	edi
		call	_CRYPTO_malloc
		mov	ebx, eax
		add	esp, 0Ch
		test	ebx, ebx
		jz	$malloc_error$70
		mov	eax, [esi+8]
		test	eax, eax
		jz	short loc_4AC
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_4AC:				; CODE XREF: _buffer_ctrl+E1j
		mov	[esi+8], ebx

loc_4AF:				; CODE XREF: _buffer_ctrl+BDj
		push	edi		; Size
		push	[esp+18h+Src]	; Src
		mov	dword ptr [esi+10h], 0
		push	dword ptr [esi+8] ; Dst
		mov	[esi+0Ch], edi
		call	_memcpy
		add	esp, 0Ch
		mov	edi, 1
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$LN25:					; CODE XREF: _buffer_ctrl+2Dj
					; DATA XREF: .text$mn:$LN69o
		mov	eax, [esp+14h+Src] ; jumptable 000003ED	case 117
		mov	ebx, [esp+14h+Size]
		test	eax, eax
		jz	short loc_4FE
		cmp	dword ptr [eax], 0
		jnz	short loc_4F6
		mov	eax, [esi+4]
		mov	ecx, ebx
		mov	[esp+14h+arg_4], ecx
		mov	[esp+14h+arg_0], eax
		jmp	short loc_508
; ---------------------------------------------------------------------------

loc_4F6:				; CODE XREF: _buffer_ctrl+125j
		mov	ecx, [esi]
		mov	[esp+14h+arg_4], ecx
		jmp	short loc_504
; ---------------------------------------------------------------------------

loc_4FE:				; CODE XREF: _buffer_ctrl+120j
		mov	ecx, ebx
		mov	[esp+14h+arg_4], ebx

loc_504:				; CODE XREF: _buffer_ctrl+13Cj
		mov	[esp+14h+arg_0], ebx

loc_508:				; CODE XREF: _buffer_ctrl+134j
		mov	eax, [esi+14h]
		mov	ebp, [esi+8]
		mov	[esp+14h+var_4], eax
		cmp	ecx, 1000h
		jle	short loc_537
		cmp	ecx, [esi]
		jz	short loc_537
		push	171h
		push	offset ??_C@_0BH@HEBHEJFA@?4?2crypto?2bio?2bf_buff?4c?$AA@ ; ".\\crypto\\bio\\bf_buff.c"
		push	ebx
		call	_CRYPTO_malloc
		mov	ebp, eax
		add	esp, 0Ch
		test	ebp, ebp
		jz	short $malloc_error$70

loc_537:				; CODE XREF: _buffer_ctrl+158j
					; _buffer_ctrl+15Cj
		mov	eax, [esp+14h+arg_0]
		cmp	eax, 1000h
		jle	short loc_58E
		cmp	eax, [esi+4]
		jz	short loc_58E
		push	176h
		push	offset ??_C@_0BH@HEBHEJFA@?4?2crypto?2bio?2bf_buff?4c?$AA@ ; ".\\crypto\\bio\\bf_buff.c"
		push	ebx
		call	_CRYPTO_malloc
		mov	ebx, eax
		add	esp, 0Ch
		test	ebx, ebx
		jnz	short loc_592
		cmp	ebp, [esi+8]
		jz	short $malloc_error$70
		push	ebp
		call	_CRYPTO_free
		add	esp, 4

$malloc_error$70:			; CODE XREF: _buffer_ctrl+D6j
					; _buffer_ctrl+175j ...
		push	1C1h
		push	offset ??_C@_0BH@HEBHEJFA@?4?2crypto?2bio?2bf_buff?4c?$AA@ ; ".\\crypto\\bio\\bf_buff.c"
		push	41h ; 'A'
		push	72h ; 'r'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 14h

loc_586:				; CODE XREF: _buffer_ctrl+90j
					; _buffer_ctrl+231j ...
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_58E:				; CODE XREF: _buffer_ctrl+180j
					; _buffer_ctrl+185j
		mov	ebx, [esp+14h+var_4]

loc_592:				; CODE XREF: _buffer_ctrl+19Ej
		mov	eax, [esi+8]
		cmp	eax, ebp
		jz	short loc_5B9
		push	eax
		call	_CRYPTO_free
		mov	eax, [esp+18h+arg_4]
		add	esp, 4
		mov	[esi+8], ebp
		mov	dword ptr [esi+10h], 0
		mov	dword ptr [esi+0Ch], 0
		mov	[esi], eax

loc_5B9:				; CODE XREF: _buffer_ctrl+1D7j
		mov	eax, [esi+14h]
		cmp	eax, ebx
		jz	loc_46A
		push	eax
		call	_CRYPTO_free
		mov	eax, [esp+18h+arg_0]
		add	esp, 4
		mov	[esi+4], eax
		mov	eax, edi
		mov	[esi+14h], ebx
		mov	dword ptr [esi+1Ch], 0
		pop	edi
		mov	dword ptr [esi+18h], 0
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$LN37:					; CODE XREF: _buffer_ctrl+2Dj
					; DATA XREF: .text$mn:$LN69o
		cmp	dword ptr [ebx+24h], 0 ; jumptable 000003ED case 101
		jz	short loc_586
		push	0Fh
		push	ebx
		call	_BIO_clear_flags
		push	[esp+1Ch+Src]
		push	[esp+20h+Size]
		push	ebp
		push	dword ptr [ebx+24h]
		call	_BIO_ctrl
		push	ebx
		mov	edi, eax
		call	_BIO_copy_next_retry
		add	esp, 1Ch
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$LN39:					; CODE XREF: _buffer_ctrl+2Dj
					; DATA XREF: .text$mn:$LN69o
		mov	eax, [ebx+24h]	; jumptable 000003ED case 11
		test	eax, eax
		jz	loc_586
		cmp	dword ptr [esi+18h], 0
		jle	loc_456
		push	0Fh
		push	ebx
		call	_BIO_clear_flags
		add	esp, 8
		cmp	dword ptr [esi+18h], 0
		jle	short loc_681

loc_645:				; CODE XREF: _buffer_ctrl+2BFj
		push	dword ptr [esi+18h]
		mov	eax, [esi+14h]
		add	eax, [esi+1Ch]
		push	eax
		push	dword ptr [ebx+24h]
		call	_BIO_write
		push	ebx
		mov	edi, eax
		call	_BIO_copy_next_retry
		add	esp, 10h
		test	edi, edi
		jle	loc_46A
		add	[esi+1Ch], edi
		sub	[esi+18h], edi
		push	0Fh
		push	ebx
		call	_BIO_clear_flags
		add	esp, 8
		cmp	dword ptr [esi+18h], 0
		jg	short loc_645

loc_681:				; CODE XREF: _buffer_ctrl+283j
		push	[esp+14h+Src]
		mov	dword ptr [esi+18h], 0
		push	[esp+18h+Size]
		mov	dword ptr [esi+1Ch], 0
		push	ebp
		push	dword ptr [ebx+24h]
		call	_BIO_ctrl
		add	esp, 10h
		mov	edi, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$LN45:					; CODE XREF: _buffer_ctrl+2Dj
					; DATA XREF: .text$mn:$LN69o
		mov	ebx, [esp+14h+Src] ; jumptable 000003ED	case 12
		push	0
		push	dword ptr [esi]
		push	75h ; 'u'
		push	ebx
		call	_BIO_int_ctrl
		add	esp, 10h
		test	eax, eax
		jz	short loc_6DA
		push	1
		push	dword ptr [esi+4]
		push	75h ; 'u'
		push	ebx
		call	_BIO_int_ctrl
		add	esp, 10h
		test	eax, eax
		jnz	loc_46A

loc_6DA:				; CODE XREF: _buffer_ctrl+300j
		xor	edi, edi
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
_buffer_ctrl	endp

; ---------------------------------------------------------------------------
$LN69		dd offset $LN10, offset	$LN12, offset $LN18, offset $LN39
					; DATA XREF: _buffer_ctrl+2Dr
		dd offset $LN45, offset	$LN15, offset $LN37, offset $LN13 ; jump table for switch statement
		dd offset $LN25, offset	$LN21, offset $LN48
$LN59		db	0,   0Ah,     1,   0Ah ; DATA XREF: _buffer_ctrl+26r
		db    0Ah,   0Ah,   0Ah,   0Ah ; indirect table	for switch statement
		db    0Ah,     2,     3,     4
		db	5,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db	6,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,   0Ah
		db    0Ah,   0Ah,   0Ah,     7
		db	8,   0Ah,   0Ah,   0Ah
		db    0Ah,     9
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 78Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_buffer_new	proc near		; DATA XREF: .data:000008D4o

arg_0		= dword	ptr  4

		push	esi
		push	60h ; '`'
		push	offset ??_C@_0BH@HEBHEJFA@?4?2crypto?2bio?2bf_buff?4c?$AA@ ; ".\\crypto\\bio\\bf_buff.c"
		push	20h ; ' '
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jz	short loc_7C8
		push	63h ; 'c'
		push	offset ??_C@_0BH@HEBHEJFA@?4?2crypto?2bio?2bf_buff?4c?$AA@ ; ".\\crypto\\bio\\bf_buff.c"
		push	1000h
		call	_CRYPTO_malloc
		add	esp, 0Ch
		mov	[esi+8], eax
		test	eax, eax
		jnz	short loc_7CC
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_7C8:				; CODE XREF: _buffer_new+16j
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_7CC:				; CODE XREF: _buffer_new+31j
		push	68h ; 'h'
		push	offset ??_C@_0BH@HEBHEJFA@?4?2crypto?2bio?2bf_buff?4c?$AA@ ; ".\\crypto\\bio\\bf_buff.c"
		push	1000h
		call	_CRYPTO_malloc
		add	esp, 0Ch
		mov	[esi+14h], eax
		test	eax, eax
		jnz	short loc_7FC
		push	dword ptr [esi+8]
		call	_CRYPTO_free
		push	esi
		call	_CRYPTO_free
		add	esp, 8
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_7FC:				; CODE XREF: _buffer_new+59j
		mov	eax, [esp+4+arg_0]
		mov	dword ptr [esi], 1000h
		mov	dword ptr [esi+4], 1000h
		mov	dword ptr [esi+0Ch], 0
		mov	dword ptr [esi+10h], 0
		mov	dword ptr [esi+18h], 0
		mov	dword ptr [esi+1Ch], 0
		mov	[eax+20h], esi
		mov	dword ptr [eax+0Ch], 1
		mov	dword ptr [eax+14h], 0
		mov	eax, 1
		pop	esi
		retn
_buffer_new	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 844h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_buffer_free	proc near		; DATA XREF: .data:000008D8o

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jnz	short loc_851
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_851:				; CODE XREF: _buffer_free+7j
		push	edi
		mov	edi, [esi+20h]
		mov	eax, [edi+8]
		test	eax, eax
		jz	short loc_865
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_865:				; CODE XREF: _buffer_free+16j
		mov	eax, [edi+14h]
		pop	edi
		test	eax, eax
		jz	short loc_876
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_876:				; CODE XREF: _buffer_free+27j
		push	dword ptr [esi+20h]
		call	_CRYPTO_free
		add	esp, 4
		mov	dword ptr [esi+20h], 0
		mov	dword ptr [esi+0Ch], 0
		mov	eax, 1
		mov	dword ptr [esi+14h], 0
		pop	esi
		retn
_buffer_free	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8A0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_buffer_callback_ctrl proc near		; DATA XREF: .data:000008DCo

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+24h]
		test	eax, eax
		jnz	short loc_8AC
		retn
; ---------------------------------------------------------------------------

loc_8AC:				; CODE XREF: _buffer_callback_ctrl+9j
		mov	[esp+arg_0], eax
		jmp	_BIO_callback_ctrl
_buffer_callback_ctrl endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 8B8h
_methods_buffer	dd offset loc_208+1	; DATA XREF: _BIO_f_buffero
		dd offset ??_C@_06HOHPNJLC@buffer?$AA@ ; "buffer"
		dd offset _buffer_write
		dd offset _buffer_read
		dd offset _buffer_puts
		dd offset _buffer_gets
		dd offset _buffer_ctrl
		dd offset _buffer_new
		dd offset _buffer_free
		dd offset _buffer_callback_ctrl
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8E0h
; COMDAT (pick any)
		public ??_C@_06HOHPNJLC@buffer?$AA@
; `string'
??_C@_06HOHPNJLC@buffer?$AA@ db	'buffer',0 ; DATA XREF: .data:000008BCo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8E8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_f_buffer
_BIO_f_buffer	proc near
		mov	eax, offset _methods_buffer
		retn
_BIO_f_buffer	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8F0h
; COMDAT (pick any)
		public ??_C@_0BH@HEBHEJFA@?4?2crypto?2bio?2bf_buff?4c?$AA@
; `string'
??_C@_0BH@HEBHEJFA@?4?2crypto?2bio?2bf_buff?4c?$AA@ db '.\crypto\bio\bf_buff.c',0
					; DATA XREF: _buffer_ctrl+C4o
					; _buffer_ctrl+163o ...
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _CRYPTO_malloc:near ; CODE XREF: _buffer_ctrl+CAp
					; _buffer_ctrl+169p ...
		extrn _CRYPTO_free:near	; CODE XREF: _buffer_ctrl+E4p
					; _buffer_ctrl+1A6p ...
		extrn _BIO_clear_flags:near ; CODE XREF: _buffer_write+49p
					; _buffer_read+31p ...
		extrn _BIO_read:near	; CODE XREF: _buffer_read+86p
					; _buffer_read+D9p ...
		extrn _BIO_write:near	; CODE XREF: _buffer_write+9Dp
					; _buffer_write+E5p ...
		extrn _BIO_ctrl:near	; CODE XREF: _buffer_ctrl+A0p
					; _buffer_ctrl+247p ...
		extrn _BIO_callback_ctrl:near ;	CODE XREF: _buffer_callback_ctrl+10j
		extrn _BIO_int_ctrl:near ; CODE	XREF: _buffer_ctrl+2F6p
					; _buffer_ctrl+30Ap
		extrn _BIO_copy_next_retry:near	; CODE XREF: _buffer_write+ACp
					; _buffer_write+F4p ...
		extrn _ERR_put_error:near ; CODE XREF: _buffer_ctrl+1BEp
		extrn __chkstk:near	; CODE XREF: _buffer_write+5p
					; _buffer_gets+5p ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _buffer_write+7Bp
					; _buffer_write+13Fp ...


		end
