;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	32CCE9D69FF890321212051A88C53EF8
; Input	CRC32 :	FFFA7C16

; File Name   :	C:\compspace\Diff\openssl\obj\evp_enc.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		public _EVP_version
_EVP_version	db 'EVP part of OpenSSL 1.0.2h  3 May 2016',0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 28h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl EVP_CIPHER_CTX_cleanup(void *Dst)
		public _EVP_CIPHER_CTX_cleanup
_EVP_CIPHER_CTX_cleanup	proc near	; CODE XREF: _EVP_CIPHER_CTX_copy+51p
					; _EVP_CIPHER_CTX_free+Ap ...

Dst		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+Dst]
		mov	eax, [esi]
		test	eax, eax
		jz	short loc_5B
		mov	eax, [eax+1Ch]
		test	eax, eax
		jz	short loc_46
		push	esi
		call	eax
		add	esp, 4
		test	eax, eax
		jnz	short loc_46
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_46:					; CODE XREF: _EVP_CIPHER_CTX_cleanup+10j
					; _EVP_CIPHER_CTX_cleanup+1Aj
		mov	ecx, [esi+60h]
		test	ecx, ecx
		jz	short loc_5B
		mov	eax, [esi]
		push	dword ptr [eax+20h]
		push	ecx
		call	_OPENSSL_cleanse
		add	esp, 8

loc_5B:					; CODE XREF: _EVP_CIPHER_CTX_cleanup+9j
					; _EVP_CIPHER_CTX_cleanup+23j
		mov	eax, [esi+60h]
		test	eax, eax
		jz	short loc_6B
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_6B:					; CODE XREF: _EVP_CIPHER_CTX_cleanup+38j
		mov	eax, [esi+4]
		test	eax, eax
		jz	short loc_7B
		push	eax
		call	_ENGINE_finish
		add	esp, 4

loc_7B:					; CODE XREF: _EVP_CIPHER_CTX_cleanup+48j
		push	8Ch ; 'Œ'       ; Size
		push	0		; Val
		push	esi		; Dst
		call	_memset
		add	esp, 0Ch
		mov	eax, 1
		pop	esi
		retn
_EVP_CIPHER_CTX_cleanup	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 94h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl EVP_CIPHER_CTX_copy(void *Dst, int)
		public _EVP_CIPHER_CTX_copy
_EVP_CIPHER_CTX_copy proc near

Dst		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		mov	ebx, [esp+4+arg_4]
		test	ebx, ebx
		jz	loc_17E
		cmp	dword ptr [ebx], 0
		jz	loc_17E
		mov	eax, [ebx+4]
		test	eax, eax
		jz	short loc_DD
		push	eax
		call	_ENGINE_init
		add	esp, 4
		test	eax, eax
		jnz	short loc_DD
		push	286h
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		push	26h ; '&'
		push	0A3h ; '£'
		push	6
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_DD:					; CODE XREF: _EVP_CIPHER_CTX_copy+1Bj
					; _EVP_CIPHER_CTX_copy+28j
		push	ebp
		mov	ebp, [esp+8+Dst]
		push	esi
		push	edi
		push	ebp		; Dst
		call	_EVP_CIPHER_CTX_cleanup
		mov	ecx, 23h ; '#'
		mov	esi, ebx
		mov	edi, ebp
		add	esp, 4
		rep movsd
		cmp	dword ptr [ebx+60h], 0
		jz	short loc_156
		mov	eax, [ebx]
		mov	eax, [eax+20h]
		test	eax, eax
		jz	short loc_156
		push	28Fh
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		push	eax
		call	_CRYPTO_malloc
		mov	ecx, eax
		add	esp, 0Ch
		mov	[ebp+60h], ecx
		test	ecx, ecx
		jnz	short loc_145
		push	291h
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		push	41h ; 'A'
		push	0A3h ; '£'
		push	6
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_145:				; CODE XREF: _EVP_CIPHER_CTX_copy+8Dj
		mov	eax, [ebx]
		push	dword ptr [eax+20h] ; Size
		push	dword ptr [ebx+60h] ; Src
		push	ecx		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_156:				; CODE XREF: _EVP_CIPHER_CTX_copy+68j
					; _EVP_CIPHER_CTX_copy+71j
		mov	eax, [ebx]
		test	dword ptr [eax+10h], 400h
		jz	short loc_174
		mov	eax, [eax+2Ch]
		push	ebp
		push	0
		push	8
		push	ebx
		call	eax
		add	esp, 10h
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_174:				; CODE XREF: _EVP_CIPHER_CTX_copy+CBj
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, 1
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_17E:				; CODE XREF: _EVP_CIPHER_CTX_copy+7j
					; _EVP_CIPHER_CTX_copy+10j
		push	280h
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		push	6Fh ; 'o'
		push	0A3h ; '£'
		push	6
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	ebx
		retn
_EVP_CIPHER_CTX_copy endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1A0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_CIPHER_CTX_ctrl
_EVP_CIPHER_CTX_ctrl proc near		; CODE XREF: _EVP_CIPHER_CTX_rand_key+18p
					; _EVP_CIPHER_CTX_set_key_length+16p ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		test	eax, eax
		jnz	short loc_1C8
		push	262h
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		push	83h ; 'ƒ'
		push	7Ch ; '|'
		push	6
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1C8:				; CODE XREF: _EVP_CIPHER_CTX_ctrl+8j
		mov	eax, [eax+2Ch]
		test	eax, eax
		jnz	short loc_1ED
		push	267h
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		push	84h ; '„'
		push	7Ch ; '|'
		push	6
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1ED:				; CODE XREF: _EVP_CIPHER_CTX_ctrl+2Dj
		push	[esp+arg_C]
		push	[esp+4+arg_8]
		push	[esp+8+arg_4]
		push	ecx
		call	eax
		add	esp, 10h
		cmp	eax, 0FFFFFFFFh
		jnz	short locret_221
		push	26Eh
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		push	85h ; '…'
		push	7Ch ; '|'
		push	6
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax

locret_221:				; CODE XREF: _EVP_CIPHER_CTX_ctrl+62j
		retn
_EVP_CIPHER_CTX_ctrl endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 224h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl EVP_CIPHER_CTX_free(void *Dst)
		public _EVP_CIPHER_CTX_free
_EVP_CIPHER_CTX_free proc near

Dst		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+Dst]
		test	esi, esi
		jz	short loc_23C
		push	esi		; Dst
		call	_EVP_CIPHER_CTX_cleanup
		push	esi
		call	_CRYPTO_free
		add	esp, 8

loc_23C:				; CODE XREF: _EVP_CIPHER_CTX_free+7j
		pop	esi
		retn
_EVP_CIPHER_CTX_free endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 240h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl EVP_CIPHER_CTX_init(void *Dst)
		public _EVP_CIPHER_CTX_init
_EVP_CIPHER_CTX_init proc near

Dst		= dword	ptr  4

		push	8Ch ; 'Œ'       ; Size
		push	0		; Val
		push	[esp+8+Dst]	; Dst
		call	_memset
		add	esp, 0Ch
		retn
_EVP_CIPHER_CTX_init endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 254h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_CIPHER_CTX_new
_EVP_CIPHER_CTX_new proc near
		push	esi
		push	58h ; 'X'
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		push	8Ch ; 'Œ'
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jz	short loc_281
		push	8Ch ; 'Œ'       ; Size
		push	0		; Val
		push	esi		; Dst
		call	_memset
		add	esp, 0Ch
		mov	eax, esi

loc_281:				; CODE XREF: _EVP_CIPHER_CTX_new+19j
		pop	esi
		retn
_EVP_CIPHER_CTX_new endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 284h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_CIPHER_CTX_rand_key
_EVP_CIPHER_CTX_rand_key proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		test	dword ptr [eax+10h], 200h
		jz	short loc_2A5
		push	[esp+arg_4]
		push	0
		push	6
		push	ecx
		call	_EVP_CIPHER_CTX_ctrl
		add	esp, 10h
		retn
; ---------------------------------------------------------------------------

loc_2A5:				; CODE XREF: _EVP_CIPHER_CTX_rand_key+Dj
		push	dword ptr [ecx+58h]
		push	[esp+4+arg_4]
		call	_RAND_bytes
		xor	ecx, ecx
		add	esp, 8
		test	eax, eax
		setnle	cl
		mov	eax, ecx
		retn
_EVP_CIPHER_CTX_rand_key endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2C0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_CIPHER_CTX_set_key_length
_EVP_CIPHER_CTX_set_key_length proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	edx, [eax+10h]
		test	dl, dl
		jns	short loc_2DF
		push	0
		push	[esp+4+arg_4]
		push	1
		push	ecx
		call	_EVP_CIPHER_CTX_ctrl
		add	esp, 10h
		retn
; ---------------------------------------------------------------------------

loc_2DF:				; CODE XREF: _EVP_CIPHER_CTX_set_key_length+Bj
		mov	eax, [esp+arg_4]
		cmp	[ecx+58h], eax
		jz	short loc_2F4
		test	eax, eax
		jle	short loc_2FA
		test	dl, 8
		jz	short loc_2FA
		mov	[ecx+58h], eax

loc_2F4:				; CODE XREF: _EVP_CIPHER_CTX_set_key_length+26j
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_2FA:				; CODE XREF: _EVP_CIPHER_CTX_set_key_length+2Aj
					; _EVP_CIPHER_CTX_set_key_length+2Fj
		push	251h
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		push	82h ; '‚'
		push	7Ah ; 'z'
		push	6
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
_EVP_CIPHER_CTX_set_key_length endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 318h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_CIPHER_CTX_set_padding
_EVP_CIPHER_CTX_set_padding proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		cmp	[esp+arg_4], 0
		mov	eax, [esp+arg_0]
		jz	short loc_330
		and	dword ptr [eax+5Ch], 0FFFFFEFFh
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_330:				; CODE XREF: _EVP_CIPHER_CTX_set_padding+9j
		or	dword ptr [eax+5Ch], 100h
		mov	eax, 1
		retn
_EVP_CIPHER_CTX_set_padding endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 340h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_CipherFinal
_EVP_CipherFinal proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		cmp	dword ptr [eax+8], 0
		jz	short loc_353
		mov	[esp+arg_0], eax
		jmp	_EVP_EncryptFinal_ex
; ---------------------------------------------------------------------------

loc_353:				; CODE XREF: _EVP_CipherFinal+8j
		mov	[esp+arg_0], eax
		jmp	_EVP_DecryptFinal_ex
_EVP_CipherFinal endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 35Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_CipherFinal_ex
_EVP_CipherFinal_ex proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		cmp	dword ptr [eax+8], 0
		jz	short loc_36F
		mov	[esp+arg_0], eax
		jmp	_EVP_EncryptFinal_ex
; ---------------------------------------------------------------------------

loc_36F:				; CODE XREF: _EVP_CipherFinal_ex+8j
		mov	[esp+arg_0], eax
		jmp	_EVP_DecryptFinal_ex
_EVP_CipherFinal_ex endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 378h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl EVP_CipherInit(void *Dst,	int, int, void *Src, int)
		public _EVP_CipherInit
_EVP_CipherInit	proc near

Dst		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
Src		= dword	ptr  10h
arg_10		= dword	ptr  14h

		cmp	[esp+arg_4], 0
		jz	short loc_392
		push	8Ch ; 'Œ'       ; Size
		push	0		; Val
		push	[esp+8+Dst]	; Dst
		call	_memset
		add	esp, 0Ch

loc_392:				; CODE XREF: _EVP_CipherInit+5j
		push	[esp+arg_10]	; int
		push	[esp+4+Src]	; Src
		push	[esp+8+arg_8]	; int
		push	0		; int
		push	[esp+10h+arg_4]	; int
		push	[esp+14h+Dst]	; Dst
		call	_EVP_CipherInit_ex
		add	esp, 18h
		retn
_EVP_CipherInit	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3B4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl EVP_CipherInit_ex(void *Dst, int,	int, int, void *Src, int)
		public _EVP_CipherInit_ex
_EVP_CipherInit_ex proc	near		; CODE XREF: _EVP_CipherInit+30p
					; _EVP_DecryptInit+2Ep	...

Dst		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
Src		= dword	ptr  14h
arg_14		= dword	ptr  18h

		push	ebx
		push	ebp
		mov	ebp, [esp+8+arg_14]
		mov	eax, 1
		push	esi
		push	edi
		mov	edi, [esp+10h+Dst]
		cmp	ebp, 0FFFFFFFFh
		jnz	short loc_3CF
		mov	ebp, [edi+8]
		jmp	short loc_3D7
; ---------------------------------------------------------------------------

loc_3CF:				; CODE XREF: _EVP_CipherInit_ex+14j
		test	ebp, ebp
		cmovnz	ebp, eax
		mov	[edi+8], ebp

loc_3D7:				; CODE XREF: _EVP_CipherInit_ex+19j
		cmp	dword ptr [edi+4], 0
		mov	ebx, [esp+10h+arg_4]
		jz	short loc_3F9
		mov	ecx, [edi]
		test	ecx, ecx
		jz	short loc_3F9
		test	ebx, ebx
		jz	$skip_to_init$46
		mov	eax, [ebx]
		cmp	eax, [ecx]
		jz	$skip_to_init$46

loc_3F9:				; CODE XREF: _EVP_CipherInit_ex+2Bj
					; _EVP_CipherInit_ex+31j
		test	ebx, ebx
		jz	loc_4FB
		cmp	dword ptr [edi], 0
		jz	short loc_418
		mov	esi, [edi+5Ch]
		push	edi		; Dst
		call	_EVP_CIPHER_CTX_cleanup
		add	esp, 4
		mov	[edi+8], ebp
		mov	[edi+5Ch], esi

loc_418:				; CODE XREF: _EVP_CipherInit_ex+50j
		mov	esi, [esp+10h+arg_8]
		test	esi, esi
		jz	short loc_44F
		push	esi
		call	_ENGINE_init
		add	esp, 4
		test	eax, eax
		jnz	short loc_45B
		push	8Eh ; 'Ž'

loc_432:				; CODE XREF: _EVP_CipherInit_ex+C1j
					; _EVP_CipherInit_ex+142j
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		push	86h ; '†'
		push	7Bh ; '{'
		push	6
		call	_ERR_put_error
		add	esp, 14h

loc_448:				; CODE XREF: _EVP_CipherInit_ex+1FCj
					; _EVP_CipherInit_ex+299j
		pop	edi		; jumptable 000005B6 default case
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_44F:				; CODE XREF: _EVP_CipherInit_ex+6Aj
		push	dword ptr [ebx]
		call	_ENGINE_get_cipher_engine
		add	esp, 4
		mov	esi, eax

loc_45B:				; CODE XREF: _EVP_CipherInit_ex+77j
		test	esi, esi
		jz	short loc_47C
		push	dword ptr [ebx]
		push	esi
		call	_ENGINE_get_cipher
		mov	ebx, eax
		add	esp, 8
		test	ebx, ebx
		jnz	short loc_477
		push	9Dh ; ''
		jmp	short loc_432
; ---------------------------------------------------------------------------

loc_477:				; CODE XREF: _EVP_CipherInit_ex+BAj
		mov	[edi+4], esi
		jmp	short loc_483
; ---------------------------------------------------------------------------

loc_47C:				; CODE XREF: _EVP_CipherInit_ex+A9j
		mov	dword ptr [edi+4], 0

loc_483:				; CODE XREF: _EVP_CipherInit_ex+C6j
		mov	[edi], ebx
		mov	eax, [ebx+20h]
		test	eax, eax
		jz	short loc_4C5
		push	0B7h ; '·'
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		push	eax
		call	_CRYPTO_malloc
		add	esp, 0Ch
		mov	[edi+60h], eax
		test	eax, eax
		jnz	short loc_4CC
		push	0B9h ; '¹'
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		push	41h ; 'A'
		push	7Bh ; '{'
		push	6
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_4C5:				; CODE XREF: _EVP_CipherInit_ex+D6j
		mov	dword ptr [edi+60h], 0

loc_4CC:				; CODE XREF: _EVP_CipherInit_ex+F0j
		mov	eax, [ebx+8]
		and	dword ptr [edi+5Ch], 1
		mov	[edi+58h], eax
		mov	eax, [edi]
		test	byte ptr [eax+10h], 40h
		jz	short $skip_to_init$46
		push	0
		push	0
		push	0
		push	edi
		call	_EVP_CIPHER_CTX_ctrl
		add	esp, 10h
		test	eax, eax
		jnz	short $skip_to_init$46
		push	0C4h ; 'Ä'
		jmp	loc_432
; ---------------------------------------------------------------------------

loc_4FB:				; CODE XREF: _EVP_CipherInit_ex+47j
		cmp	dword ptr [edi], 0
		jnz	short $skip_to_init$46
		push	0C9h ; 'É'
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		push	83h ; 'ƒ'
		push	7Bh ; '{'
		push	6
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$skip_to_init$46:			; CODE XREF: _EVP_CipherInit_ex+35j
					; _EVP_CipherInit_ex+3Fj ...
		mov	eax, [edi]
		mov	eax, [eax+4]
		cmp	eax, 1
		jz	short loc_54D
		cmp	eax, 8
		jz	short loc_54D
		cmp	eax, 10h
		jz	short loc_54D
		push	offset ??_C@_0FO@KIBMBINE@ctx?9?$DOcipher?9?$DOblock_size?5?$DN?$DN?51?5?$HM?$HM?5@ ; "ctx->cipher->block_size == 1 || ctx->ci"...
		push	0D6h ; 'Ö'
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_54D:				; CODE XREF: _EVP_CipherInit_ex+176j
					; _EVP_CipherInit_ex+17Bj ...
		test	byte ptr [edi+5Ch], 1
		jnz	short loc_58A
		push	edi
		call	_EVP_CIPHER_CTX_flags
		and	eax, 0F0007h
		add	esp, 4
		cmp	eax, 10002h
		jnz	short loc_58A
		push	0DAh ; 'Ú'
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		push	0AAh ; 'ª'
		push	7Bh ; '{'
		push	6
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_58A:				; CODE XREF: _EVP_CipherInit_ex+19Dj
					; _EVP_CipherInit_ex+1B2j
		push	edi
		call	_EVP_CIPHER_CTX_flags
		mov	esi, [esp+14h+Src]
		add	esp, 4
		test	al, 10h
		jnz	$LN2		; jumptable 000005B6 cases 0,1
		push	edi
		call	_EVP_CIPHER_CTX_flags
		and	eax, 0F0007h
		add	esp, 4
		cmp	eax, 5		; switch 6 cases
		ja	loc_448		; jumptable 000005B6 default case
		jmp	ds:$LN45[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN27:					; CODE XREF: _EVP_CipherInit_ex+202j
					; DATA XREF: .text$mn:$LN45o
		mov	dword ptr [edi+50h], 0 ; jumptable 000005B6 cases 3,4

$LN28:					; CODE XREF: _EVP_CipherInit_ex+202j
					; DATA XREF: .text$mn:$LN45o
		push	edi		; jumptable 000005B6 case 2
		call	_EVP_CIPHER_CTX_iv_length
		add	esp, 4
		cmp	eax, 10h
		jle	short loc_5E9
		push	offset ??_C@_0DG@IKOHIL@EVP_CIPHER_CTX_iv_length?$CIctx?$CJ?5?$DM?$DN@ ; "EVP_CIPHER_CTX_iv_length(ctx)	<= (int)s"...
		push	0EEh ; 'î'
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_5E9:				; CODE XREF: _EVP_CipherInit_ex+21Cj
		test	esi, esi
		jz	short loc_601
		push	edi
		call	_EVP_CIPHER_CTX_iv_length
		push	eax		; Size
		lea	eax, [edi+10h]
		push	esi		; Src
		push	eax		; Dst
		call	_memcpy
		add	esp, 10h

loc_601:				; CODE XREF: _EVP_CipherInit_ex+237j
		push	edi
		call	_EVP_CIPHER_CTX_iv_length
		push	eax
		lea	eax, [edi+10h]
		push	eax
		jmp	short loc_621
; ---------------------------------------------------------------------------

$LN30:					; CODE XREF: _EVP_CipherInit_ex+202j
					; DATA XREF: .text$mn:$LN45o
		mov	dword ptr [edi+50h], 0 ; jumptable 000005B6 case 5
		test	esi, esi
		jz	short $LN2	; jumptable 000005B6 cases 0,1
		push	edi
		call	_EVP_CIPHER_CTX_iv_length
		push	eax		; Size
		push	esi		; Src

loc_621:				; CODE XREF: _EVP_CipherInit_ex+258j
		lea	eax, [edi+20h]
		push	eax		; Dst
		call	_memcpy
		add	esp, 10h

$LN2:					; CODE XREF: _EVP_CipherInit_ex+1E5j
					; _EVP_CipherInit_ex+202j ...
		mov	ecx, [esp+10h+arg_C] ; jumptable 000005B6 cases	0,1
		test	ecx, ecx
		jnz	short loc_63D
		mov	eax, [edi]
		test	byte ptr [eax+10h], 20h
		jz	short loc_653

loc_63D:				; CODE XREF: _EVP_CipherInit_ex+27Fj
		mov	eax, [edi]
		push	ebp
		push	esi
		push	ecx
		mov	eax, [eax+14h]
		push	edi
		call	eax
		add	esp, 10h
		test	eax, eax
		jz	loc_448		; jumptable 000005B6 default case

loc_653:				; CODE XREF: _EVP_CipherInit_ex+287j
		mov	ecx, [edi]
		mov	eax, 1
		mov	dword ptr [edi+0Ch], 0
		mov	dword ptr [edi+64h], 0
		mov	ecx, [ecx+4]
		dec	ecx
		mov	[edi+68h], ecx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_EVP_CipherInit_ex endp

; ---------------------------------------------------------------------------
$LN45		dd offset $LN2		; DATA XREF: _EVP_CipherInit_ex+202r
		dd offset $LN2		; jump table for switch	statement
		dd offset $LN28
		dd offset $LN27
		dd offset $LN27
		dd offset $LN30
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 68Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_CipherUpdate
_EVP_CipherUpdate proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		cmp	dword ptr [eax+8], 0
		jz	short loc_69F
		mov	[esp+arg_0], eax ; int
		jmp	_EVP_EncryptUpdate
; ---------------------------------------------------------------------------

loc_69F:				; CODE XREF: _EVP_CipherUpdate+8j
		mov	[esp+arg_0], eax ; int
		jmp	_EVP_DecryptUpdate
_EVP_CipherUpdate endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6A8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_DecryptFinal
_EVP_DecryptFinal proc near
		jmp	_EVP_DecryptFinal_ex
_EVP_DecryptFinal endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6B0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_DecryptFinal_ex
_EVP_DecryptFinal_ex proc near		; CODE XREF: _EVP_CipherFinal+17j
					; _EVP_CipherFinal_ex+17j ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		mov	ebx, [esp+4+arg_8]
		push	esi
		push	edi
		mov	edi, [esp+0Ch+arg_0]
		mov	dword ptr [ebx], 0
		mov	esi, [edi]
		test	dword ptr [esi+10h], 100000h
		jz	short loc_6F0
		mov	eax, [esi+18h]
		push	0
		push	0
		push	[esp+14h+arg_4]
		push	edi
		call	eax
		add	esp, 10h
		test	eax, eax
		js	loc_7F5
		pop	edi
		mov	[ebx], eax
		mov	eax, 1
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_6F0:				; CODE XREF: _EVP_DecryptFinal_ex+1Aj
		test	dword ptr [edi+5Ch], 100h
		mov	esi, [esi+4]
		jz	short loc_727
		cmp	dword ptr [edi+0Ch], 0
		jz	loc_7FB
		push	1FEh
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		push	8Ah ; 'Š'
		push	65h ; 'e'
		push	6
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_727:				; CODE XREF: _EVP_DecryptFinal_ex+4Aj
		cmp	esi, 1
		jbe	loc_7FB
		cmp	dword ptr [edi+0Ch], 0
		jnz	loc_7DD
		cmp	dword ptr [edi+64h], 0
		jz	loc_7DD
		cmp	esi, 20h ; ' '
		jbe	short loc_760
		push	offset ??_C@_0BH@JPOFFCDO@b?5?$DM?$DN?5sizeof?5ctx?9?$DOfinal?$AA@ ; "b	<= sizeof ctx->final"
		push	209h
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_760:				; CODE XREF: _EVP_DecryptFinal_ex+97j
		movzx	edx, byte ptr [esi+edi+6Bh]
		test	edx, edx
		jz	short loc_7BF
		cmp	edx, esi
		jg	short loc_7BF
		xor	ecx, ecx
		test	edx, edx
		jle	short loc_790
		add	esi, 6Ch ; 'l'
		add	esi, edi
		nop	dword ptr [eax+eax+00000000h]

loc_780:				; CODE XREF: _EVP_DecryptFinal_ex+DEj
		movzx	eax, byte ptr [esi-1]
		lea	esi, [esi-1]
		cmp	eax, edx
		jnz	short loc_7B8
		inc	ecx
		cmp	ecx, edx
		jl	short loc_780

loc_790:				; CODE XREF: _EVP_DecryptFinal_ex+C1j
		mov	eax, [edi]
		xor	ecx, ecx
		mov	esi, [eax+4]
		sub	esi, edx
		test	esi, esi
		jle	short loc_7AD
		mov	edx, [esp+0Ch+arg_4]

loc_7A1:				; CODE XREF: _EVP_DecryptFinal_ex+FBj
		mov	al, [edi+ecx+6Ch]
		mov	[ecx+edx], al
		inc	ecx
		cmp	ecx, esi
		jl	short loc_7A1

loc_7AD:				; CODE XREF: _EVP_DecryptFinal_ex+EBj
		pop	edi
		mov	[ebx], esi
		mov	eax, 1
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_7B8:				; CODE XREF: _EVP_DecryptFinal_ex+D9j
		push	216h
		jmp	short loc_7C4
; ---------------------------------------------------------------------------

loc_7BF:				; CODE XREF: _EVP_DecryptFinal_ex+B7j
					; _EVP_DecryptFinal_ex+BBj
		push	211h

loc_7C4:				; CODE XREF: _EVP_DecryptFinal_ex+10Dj
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		push	64h ; 'd'
		push	65h ; 'e'
		push	6
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_7DD:				; CODE XREF: _EVP_DecryptFinal_ex+84j
					; _EVP_DecryptFinal_ex+8Ej
		push	206h
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		push	6Dh ; 'm'
		push	65h ; 'e'
		push	6
		call	_ERR_put_error
		add	esp, 14h

loc_7F5:				; CODE XREF: _EVP_DecryptFinal_ex+2Fj
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_7FB:				; CODE XREF: _EVP_DecryptFinal_ex+50j
					; _EVP_DecryptFinal_ex+7Aj
		pop	edi
		pop	esi
		mov	dword ptr [ebx], 0
		mov	eax, 1
		pop	ebx
		retn
_EVP_DecryptFinal_ex endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 80Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl EVP_DecryptInit(void *Dst, int, int, void	*Src)
		public _EVP_DecryptInit
_EVP_DecryptInit proc near

Dst		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
Src		= dword	ptr  10h

		cmp	[esp+arg_4], 0
		jz	short loc_826
		push	8Ch ; 'Œ'       ; Size
		push	0		; Val
		push	[esp+8+Dst]	; Dst
		call	_memset
		add	esp, 0Ch

loc_826:				; CODE XREF: _EVP_DecryptInit+5j
		push	0		; int
		push	[esp+4+Src]	; Src
		push	[esp+8+arg_8]	; int
		push	0		; int
		push	[esp+10h+arg_4]	; int
		push	[esp+14h+Dst]	; Dst
		call	_EVP_CipherInit_ex
		add	esp, 18h
		retn
_EVP_DecryptInit endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 844h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl EVP_DecryptInit_ex(void *Dst, int, int, int, void	*Src)
		public _EVP_DecryptInit_ex
_EVP_DecryptInit_ex proc near

Dst		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
Src		= dword	ptr  14h

		push	0		; int
		push	[esp+4+Src]	; Src
		push	[esp+8+arg_C]	; int
		push	[esp+0Ch+arg_8]	; int
		push	[esp+10h+arg_4]	; int
		push	[esp+14h+Dst]	; Dst
		call	_EVP_CipherInit_ex
		add	esp, 18h
		retn
_EVP_DecryptInit_ex endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 864h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl EVP_DecryptUpdate(int, void *Dst,	int, void *Src,	size_t Size)
		public _EVP_DecryptUpdate
_EVP_DecryptUpdate proc	near		; CODE XREF: _EVP_CipherUpdate+17j

arg_0		= dword	ptr  4
Dst		= dword	ptr  8
arg_8		= dword	ptr  0Ch
Src		= dword	ptr  10h
Size		= dword	ptr  14h

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		mov	edi, [esi]
		test	dword ptr [edi+10h], 100000h
		jz	short loc_8A9
		push	[esp+8+Size]
		mov	eax, [edi+18h]
		push	[esp+0Ch+Src]
		push	[esp+10h+Dst]
		push	esi
		call	eax
		mov	ecx, eax
		add	esp, 10h
		mov	eax, [esp+8+arg_8]
		test	ecx, ecx
		jns	short loc_89F
		pop	edi
		mov	dword ptr [eax], 0
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_89F:				; CODE XREF: _EVP_DecryptUpdate+2Ej
		pop	edi
		mov	[eax], ecx
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_8A9:				; CODE XREF: _EVP_DecryptUpdate+Fj
		push	ebx
		mov	ebx, [esp+0Ch+Size]
		test	ebx, ebx
		jg	short loc_8C7
		mov	eax, [esp+0Ch+arg_8]
		mov	dword ptr [eax], 0
		xor	eax, eax
		test	ebx, ebx
		pop	ebx
		pop	edi
		setz	al
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_8C7:				; CODE XREF: _EVP_DecryptUpdate+4Cj
		test	dword ptr [esi+5Ch], 100h
		jz	short loc_8EA
		push	ebx		; Size
		push	[esp+10h+Src]	; Src
		push	[esp+14h+arg_8]	; int
		push	[esp+18h+Dst]	; int
		push	esi		; int
		call	_EVP_EncryptUpdate
		add	esp, 14h
		pop	ebx
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_8EA:				; CODE XREF: _EVP_DecryptUpdate+6Aj
		mov	edi, [edi+4]
		cmp	edi, 20h ; ' '
		jbe	short loc_909
		push	offset ??_C@_0BH@JPOFFCDO@b?5?$DM?$DN?5sizeof?5ctx?9?$DOfinal?$AA@ ; "b	<= sizeof ctx->final"
		push	1C7h
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_909:				; CODE XREF: _EVP_DecryptUpdate+8Cj
		cmp	dword ptr [esi+64h], 0
		push	ebp
		mov	ebp, [esp+10h+Dst]
		jz	short loc_92E
		push	edi		; Size
		lea	eax, [esi+6Ch]
		push	eax		; Src
		push	ebp		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	[esp+10h+arg_0], 1
		add	ebp, edi
		jmp	short loc_936
; ---------------------------------------------------------------------------

loc_92E:				; CODE XREF: _EVP_DecryptUpdate+AEj
		mov	[esp+10h+arg_0], 0

loc_936:				; CODE XREF: _EVP_DecryptUpdate+C8j
		push	ebx		; Size
		push	[esp+14h+Src]	; Src
		mov	ebx, [esp+18h+arg_8]
		push	ebx		; int
		push	ebp		; int
		push	esi		; int
		call	_EVP_EncryptUpdate
		add	esp, 14h
		test	eax, eax
		jnz	short loc_953
		pop	ebp
		pop	ebx
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_953:				; CODE XREF: _EVP_DecryptUpdate+E8j
		cmp	edi, 1
		jbe	short loc_97B
		cmp	dword ptr [esi+0Ch], 0
		jnz	short loc_97B
		sub	[ebx], edi
		mov	dword ptr [esi+64h], 1
		mov	eax, [ebx]
		add	eax, ebp
		push	edi		; Size
		push	eax		; Src
		lea	eax, [esi+6Ch]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		jmp	short loc_982
; ---------------------------------------------------------------------------

loc_97B:				; CODE XREF: _EVP_DecryptUpdate+F2j
					; _EVP_DecryptUpdate+F8j
		mov	dword ptr [esi+64h], 0

loc_982:				; CODE XREF: _EVP_DecryptUpdate+115j
		cmp	[esp+10h+arg_0], 0
		jz	short loc_98B
		add	[ebx], edi

loc_98B:				; CODE XREF: _EVP_DecryptUpdate+123j
		pop	ebp
		pop	ebx
		pop	edi
		mov	eax, 1
		pop	esi
		retn
_EVP_DecryptUpdate endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 998h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_EncryptFinal
_EVP_EncryptFinal proc near
		jmp	_EVP_EncryptFinal_ex
_EVP_EncryptFinal endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 9A0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EVP_EncryptFinal_ex
_EVP_EncryptFinal_ex proc near		; CODE XREF: _EVP_CipherFinal+Ej
					; _EVP_CipherFinal_ex+Ej ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	ebp
		mov	ebp, [ebx]
		test	dword ptr [ebp+10h], 100000h
		jz	short loc_9D6
		mov	eax, [ebp+18h]
		push	0
		push	0
		push	[esp+10h+arg_4]
		push	ebx
		call	eax
		mov	ecx, eax
		add	esp, 10h
		test	ecx, ecx
		js	short loc_A37
		mov	eax, [esp+8+arg_8]
		pop	ebp
		pop	ebx
		mov	[eax], ecx
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_9D6:				; CODE XREF: _EVP_EncryptFinal_ex+Fj
		mov	ebp, [ebp+4]
		cmp	ebp, 20h ; ' '
		jbe	short loc_9F5
		push	offset ??_C@_0BF@NLHGELBH@b?5?$DM?$DN?5sizeof?5ctx?9?$DObuf?$AA@ ; "b <= sizeof	ctx->buf"
		push	193h
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_9F5:				; CODE XREF: _EVP_EncryptFinal_ex+3Cj
		cmp	ebp, 1
		jnz	short loc_A0C

loc_9FA:				; CODE XREF: _EVP_EncryptFinal_ex+7Aj
		mov	eax, [esp+8+arg_8]
		pop	ebp
		pop	ebx
		mov	dword ptr [eax], 0
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_A0C:				; CODE XREF: _EVP_EncryptFinal_ex+58j
		test	dword ptr [ebx+5Ch], 100h
		mov	eax, [ebx+0Ch]
		jz	short loc_A3C
		test	eax, eax
		jz	short loc_9FA
		push	19Ch
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		push	8Ah ; 'Š'
		push	7Fh ; ''
		push	6
		call	_ERR_put_error
		add	esp, 14h

loc_A37:				; CODE XREF: _EVP_EncryptFinal_ex+26j
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_A3C:				; CODE XREF: _EVP_EncryptFinal_ex+76j
		mov	edx, ebp
		sub	edx, eax
		cmp	eax, ebp
		jnb	short loc_A68
		push	esi
		push	edi
		lea	edi, [ebx+30h]
		mov	ecx, edx
		add	edi, eax
		mov	esi, ecx
		mov	al, dl
		shr	ecx, 2
		movzx	eax, al
		imul	eax, 1010101h
		rep stosd
		mov	ecx, esi
		and	ecx, 3
		rep stosb
		pop	edi
		pop	esi

loc_A68:				; CODE XREF: _EVP_EncryptFinal_ex+A2j
		mov	ecx, [ebx]
		lea	eax, [ebx+30h]
		push	ebp
		push	eax
		push	[esp+10h+arg_4]
		mov	eax, [ecx+18h]
		push	ebx
		call	eax
		add	esp, 10h
		test	eax, eax
		jz	short loc_A86
		mov	ecx, [esp+8+arg_8]
		mov	[ecx], ebp

loc_A86:				; CODE XREF: _EVP_EncryptFinal_ex+DEj
		pop	ebp
		pop	ebx
		retn
_EVP_EncryptFinal_ex endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A8Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl EVP_EncryptInit(void *Dst, int, int, void	*Src)
		public _EVP_EncryptInit
_EVP_EncryptInit proc near

Dst		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
Src		= dword	ptr  10h

		cmp	[esp+arg_4], 0
		jz	short loc_AA6
		push	8Ch ; 'Œ'       ; Size
		push	0		; Val
		push	[esp+8+Dst]	; Dst
		call	_memset
		add	esp, 0Ch

loc_AA6:				; CODE XREF: _EVP_EncryptInit+5j
		push	1		; int
		push	[esp+4+Src]	; Src
		push	[esp+8+arg_8]	; int
		push	0		; int
		push	[esp+10h+arg_4]	; int
		push	[esp+14h+Dst]	; Dst
		call	_EVP_CipherInit_ex
		add	esp, 18h
		retn
_EVP_EncryptInit endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0AC4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl EVP_EncryptInit_ex(void *Dst, int, int, int, void	*Src)
		public _EVP_EncryptInit_ex
_EVP_EncryptInit_ex proc near

Dst		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
Src		= dword	ptr  14h

		push	1		; int
		push	[esp+4+Src]	; Src
		push	[esp+8+arg_C]	; int
		push	[esp+0Ch+arg_8]	; int
		push	[esp+10h+arg_4]	; int
		push	[esp+14h+Dst]	; Dst
		call	_EVP_CipherInit_ex
		add	esp, 18h
		retn
_EVP_EncryptInit_ex endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0AE4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl EVP_EncryptUpdate(int, int, int, void *Src, size_t Size)
		public _EVP_EncryptUpdate
_EVP_EncryptUpdate proc	near		; CODE XREF: _EVP_CipherUpdate+Ej
					; _EVP_DecryptUpdate+7Ap ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
Src		= dword	ptr  10h
Size		= dword	ptr  14h

		push	ebp
		push	edi
		mov	edi, [esp+8+arg_0]
		mov	ebp, [edi]
		test	dword ptr [ebp+10h], 100000h
		jz	short loc_B23
		push	[esp+8+Size]
		mov	eax, [ebp+18h]
		push	[esp+0Ch+Src]
		push	[esp+10h+arg_4]
		push	edi
		call	eax
		mov	ecx, eax
		add	esp, 10h
		test	ecx, ecx
		jns	short loc_B15
		pop	edi
		xor	eax, eax
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_B15:				; CODE XREF: _EVP_EncryptUpdate+2Aj
		mov	eax, [esp+8+arg_8]
		pop	edi
		pop	ebp
		mov	[eax], ecx
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_B23:				; CODE XREF: _EVP_EncryptUpdate+Fj
		push	esi
		mov	esi, [esp+0Ch+Size]
		test	esi, esi
		jg	short loc_B41
		mov	eax, [esp+0Ch+arg_8]
		mov	dword ptr [eax], 0
		xor	eax, eax
		test	esi, esi
		pop	esi
		pop	edi
		setz	al
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_B41:				; CODE XREF: _EVP_EncryptUpdate+46j
		mov	eax, [edi+0Ch]
		mov	[esp+0Ch+arg_0], eax
		test	eax, eax
		jnz	short loc_B82
		test	[edi+68h], esi
		jnz	short loc_B82
		mov	eax, [ebp+18h]
		push	esi
		push	[esp+10h+Src]
		push	[esp+14h+arg_4]
		push	edi
		call	eax
		add	esp, 10h
		test	eax, eax
		mov	eax, [esp+0Ch+arg_8]
		jz	short loc_B76
		mov	[eax], esi
		mov	eax, 1
		pop	esi
		pop	edi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_B76:				; CODE XREF: _EVP_EncryptUpdate+85j
		pop	esi
		pop	edi
		mov	dword ptr [eax], 0
		xor	eax, eax
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_B82:				; CODE XREF: _EVP_EncryptUpdate+66j
					; _EVP_EncryptUpdate+6Bj
		mov	ebp, [ebp+4]
		cmp	ebp, 20h ; ' '
		jle	short loc_BA5
		push	offset ??_C@_0BM@NOPGEACO@bl?5?$DM?$DN?5?$CIint?$CJsizeof?$CIctx?9?$DObuf?$CJ?$AA@ ; "bl <= (int)sizeof(ctx->buf)"
		push	15Ch
		push	offset ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ ; ".\\crypto\\evp\\evp_enc.c"
		call	_OpenSSLDie
		mov	eax, [esp+18h+arg_0]
		add	esp, 0Ch

loc_BA5:				; CODE XREF: _EVP_EncryptUpdate+A4j
		push	ebx
		test	eax, eax
		jz	short loc_C16
		mov	ebx, ebp
		sub	ebx, eax
		add	eax, 30h ; '0'
		add	eax, edi
		cmp	ebx, esi
		jle	short loc_BDC
		push	esi		; Size
		push	[esp+14h+Src]	; Src
		push	eax		; Dst
		call	_memcpy
		mov	eax, [esp+1Ch+arg_8]
		add	esp, 0Ch
		add	[edi+0Ch], esi
		pop	ebx
		pop	esi
		pop	edi
		mov	dword ptr [eax], 0
		mov	eax, 1
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_BDC:				; CODE XREF: _EVP_EncryptUpdate+D1j
		mov	ecx, [esp+10h+Src]
		push	ebx		; Size
		push	ecx		; Src
		push	eax		; Dst
		call	_memcpy
		mov	ecx, [edi]
		lea	eax, [edi+30h]
		push	ebp
		push	eax
		push	[esp+24h+arg_4]
		mov	eax, [ecx+18h]
		push	edi
		call	eax
		add	esp, 1Ch
		test	eax, eax
		jz	short loc_C49
		mov	eax, [esp+10h+arg_8]
		sub	esi, ebx
		mov	ecx, [esp+10h+Src]
		mov	edx, [esp+10h+arg_4]
		add	ecx, ebx
		add	edx, ebp
		mov	[eax], ebp
		jmp	short loc_C28
; ---------------------------------------------------------------------------

loc_C16:				; CODE XREF: _EVP_EncryptUpdate+C4j
		mov	eax, [esp+10h+arg_8]
		mov	ecx, [esp+10h+Src]
		mov	edx, [esp+10h+arg_4]
		mov	dword ptr [eax], 0

loc_C28:				; CODE XREF: _EVP_EncryptUpdate+130j
		lea	ebx, [ebp-1]
		mov	[esp+10h+arg_0], ecx
		and	ebx, esi
		sub	esi, ebx
		test	esi, esi
		jle	short loc_C56
		mov	eax, [edi]
		push	esi
		push	ecx
		push	edx
		mov	eax, [eax+18h]
		push	edi
		call	eax
		add	esp, 10h
		test	eax, eax
		jnz	short loc_C50

loc_C49:				; CODE XREF: _EVP_EncryptUpdate+11Aj
		pop	ebx
		pop	esi
		pop	edi
		xor	eax, eax
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_C50:				; CODE XREF: _EVP_EncryptUpdate+163j
		mov	eax, [esp+10h+arg_8]
		add	[eax], esi

loc_C56:				; CODE XREF: _EVP_EncryptUpdate+151j
		test	ebx, ebx
		jz	short loc_C6E
		mov	eax, [esp+10h+arg_0]
		add	eax, esi
		push	ebx		; Size
		push	eax		; Src
		lea	eax, [edi+30h]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_C6E:				; CODE XREF: _EVP_EncryptUpdate+174j
		mov	[edi+0Ch], ebx
		mov	eax, 1
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
_EVP_EncryptUpdate endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C7Ch
; COMDAT (pick any)
		public ??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@
; `string'
??_C@_0BH@FPKHLGPK@?4?2crypto?2evp?2evp_enc?4c?$AA@ db '.\crypto\evp\evp_enc.c',0
					; DATA XREF: _EVP_CIPHER_CTX_copy+2Fo
					; _EVP_CIPHER_CTX_copy+78o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0C94h
; COMDAT (pick any)
		public ??_C@_0FO@KIBMBINE@ctx?9?$DOcipher?9?$DOblock_size?5?$DN?$DN?51?5?$HM?$HM?5@
; `string'
??_C@_0FO@KIBMBINE@ctx?9?$DOcipher?9?$DOblock_size?5?$DN?$DN?51?5?$HM?$HM?5@ db	'ctx->cipher->block_size == 1 || ctx->cipher->block_size == 8 || c'
					; DATA XREF: _EVP_CipherInit_ex+182o
		db 'tx->cipher->block_size == 16',0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CF4h
; COMDAT (pick any)
		public ??_C@_0DG@IKOHIL@EVP_CIPHER_CTX_iv_length?$CIctx?$CJ?5?$DM?$DN@
; `string'
??_C@_0DG@IKOHIL@EVP_CIPHER_CTX_iv_length?$CIctx?$CJ?5?$DM?$DN@	db 'EVP_CIPHER_CTX_iv_length(ctx) <= (int)sizeof(ctx->iv)',0
					; DATA XREF: _EVP_CipherInit_ex+21Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D2Ch
; COMDAT (pick any)
		public ??_C@_0BM@NOPGEACO@bl?5?$DM?$DN?5?$CIint?$CJsizeof?$CIctx?9?$DObuf?$CJ?$AA@
; `string'
??_C@_0BM@NOPGEACO@bl?5?$DM?$DN?5?$CIint?$CJsizeof?$CIctx?9?$DObuf?$CJ?$AA@ db 'bl <= (int)sizeof(ctx->buf)',0
					; DATA XREF: _EVP_EncryptUpdate+A6o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D48h
; COMDAT (pick any)
		public ??_C@_0BF@NLHGELBH@b?5?$DM?$DN?5sizeof?5ctx?9?$DObuf?$AA@
; `string'
??_C@_0BF@NLHGELBH@b?5?$DM?$DN?5sizeof?5ctx?9?$DObuf?$AA@ db 'b <= sizeof ctx->buf',0
					; DATA XREF: _EVP_EncryptFinal_ex+3Eo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D60h
; COMDAT (pick any)
		public ??_C@_0BH@JPOFFCDO@b?5?$DM?$DN?5sizeof?5ctx?9?$DOfinal?$AA@
; `string'
??_C@_0BH@JPOFFCDO@b?5?$DM?$DN?5sizeof?5ctx?9?$DOfinal?$AA@ db 'b <= sizeof ctx->final',0
					; DATA XREF: _EVP_DecryptFinal_ex+99o
					; _EVP_DecryptUpdate+8Eo
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _CRYPTO_malloc:near ; CODE XREF: _EVP_CIPHER_CTX_copy+7Ep
					; _EVP_CIPHER_CTX_new+Dp ...
		extrn _CRYPTO_free:near	; CODE XREF: _EVP_CIPHER_CTX_cleanup+3Bp
					; _EVP_CIPHER_CTX_free+10p
		extrn _OPENSSL_cleanse:near ; CODE XREF: _EVP_CIPHER_CTX_cleanup+2Bp
		extrn _OpenSSLDie:near	; CODE XREF: _EVP_CipherInit_ex+191p
					; _EVP_CipherInit_ex+22Dp ...
		extrn _ERR_put_error:near ; CODE XREF: _EVP_CIPHER_CTX_copy+3Dp
					; _EVP_CIPHER_CTX_copy+A2p ...
		extrn _EVP_CIPHER_CTX_iv_length:near ; CODE XREF: _EVP_CipherInit_ex+211p
					; _EVP_CipherInit_ex+23Ap ...
		extrn _EVP_CIPHER_CTX_flags:near ; CODE	XREF: _EVP_CipherInit_ex+1A0p
					; _EVP_CipherInit_ex+1D7p ...
		extrn _RAND_bytes:near	; CODE XREF: _EVP_CIPHER_CTX_rand_key+28p
		extrn _ENGINE_get_cipher:near ;	CODE XREF: _EVP_CipherInit_ex+AEp
		extrn _ENGINE_init:near	; CODE XREF: _EVP_CIPHER_CTX_copy+1Ep
					; _EVP_CipherInit_ex+6Dp
		extrn _ENGINE_finish:near ; CODE XREF: _EVP_CIPHER_CTX_cleanup+4Bp
		extrn _ENGINE_get_cipher_engine:near ; CODE XREF: _EVP_CipherInit_ex+9Dp
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _EVP_CIPHER_CTX_copy+BAp
					; _EVP_CipherInit_ex+245p ...
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _EVP_CIPHER_CTX_cleanup+5Bp
					; _EVP_CIPHER_CTX_init+Bp ...


		end
