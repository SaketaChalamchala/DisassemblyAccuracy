;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	2A842D9570FEB060EC7BF5353BACB163
; Input	CRC32 :	4C378C9F

; File Name   :	C:\compspace\Diff\openssl\obj\ui_lib.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
_default_UI_meth dd ?			; DATA XREF: _UI_get_default_methodr
					; _UI_get_default_method+Ew ...
_bss		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_add_error_string
_UI_add_error_string proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	edi
		mov	edi, [esp+4+arg_4]
		test	edi, edi
		jnz	short loc_2A
		push	8Fh ; 'è'
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	43h ; 'C'
		push	6Dh ; 'm'
		push	28h ; '('
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_2A:					; CODE XREF: _UI_add_error_string+7j
		push	esi
		push	93h ; 'ì'
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	20h ; ' '
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jz	short loc_82
		mov	[esi+4], edi
		mov	edi, [esp+8+arg_0]
		mov	dword ptr [esi+1Ch], 0
		mov	dword ptr [esi+8], 0
		mov	dword ptr [esi], 5
		mov	dword ptr [esi+0Ch], 0
		cmp	dword ptr [edi+4], 0
		jnz	short loc_88
		call	_sk_new_null
		mov	[edi+4], eax
		test	eax, eax
		jnz	short loc_88
		push	esi
		call	_free_string
		add	esp, 4

loc_82:					; CODE XREF: _UI_add_error_string+3Fj
		or	eax, 0FFFFFFFFh

loc_85:					; CODE XREF: _UI_add_error_string+A7j
		pop	esi
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_88:					; CODE XREF: _UI_add_error_string+67j
					; _UI_add_error_string+73j
		mov	dword ptr [esi+10h], 0
		mov	dword ptr [esi+14h], 0
		mov	dword ptr [esi+18h], 0
		push	esi
		push	dword ptr [edi+4]
		call	_sk_push
		add	esp, 8
		test	eax, eax
		jg	short loc_85
		pop	esi
		dec	eax
		pop	edi
		retn
_UI_add_error_string endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_add_info_string
_UI_add_info_string proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	edi
		mov	edi, [esp+4+arg_4]
		test	edi, edi
		jnz	short loc_DA
		push	8Fh ; 'è'
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	43h ; 'C'
		push	6Dh ; 'm'
		push	28h ; '('
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_DA:					; CODE XREF: _UI_add_info_string+7j
		push	esi
		push	93h ; 'ì'
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	20h ; ' '
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jz	short loc_132
		mov	[esi+4], edi
		mov	edi, [esp+8+arg_0]
		mov	dword ptr [esi+1Ch], 0
		mov	dword ptr [esi+8], 0
		mov	dword ptr [esi], 4
		mov	dword ptr [esi+0Ch], 0
		cmp	dword ptr [edi+4], 0
		jnz	short loc_138
		call	_sk_new_null
		mov	[edi+4], eax
		test	eax, eax
		jnz	short loc_138
		push	esi
		call	_free_string
		add	esp, 4

loc_132:				; CODE XREF: _UI_add_info_string+3Fj
		or	eax, 0FFFFFFFFh

loc_135:				; CODE XREF: _UI_add_info_string+A7j
		pop	esi
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_138:				; CODE XREF: _UI_add_info_string+67j
					; _UI_add_info_string+73j
		mov	dword ptr [esi+10h], 0
		mov	dword ptr [esi+14h], 0
		mov	dword ptr [esi+18h], 0
		push	esi
		push	dword ptr [edi+4]
		call	_sk_push
		add	esp, 8
		test	eax, eax
		jg	short loc_135
		pop	esi
		dec	eax
		pop	edi
		retn
_UI_add_info_string endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 164h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl UI_add_input_boolean(int,	int, int, int, char *Str, int, int)
		public _UI_add_input_boolean
_UI_add_input_boolean proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
Str		= dword	ptr  14h
arg_14		= dword	ptr  18h
arg_18		= dword	ptr  1Ch

		push	[esp+arg_18]	; int
		push	[esp+4+arg_14]	; int
		push	3		; int
		push	0		; int
		push	[esp+10h+Str]	; Str
		push	[esp+14h+arg_C]	; int
		push	[esp+18h+arg_8]	; int
		push	[esp+1Ch+arg_4]	; int
		push	[esp+20h+arg_0]	; int
		call	_general_allocate_boolean
		add	esp, 24h
		retn
_UI_add_input_boolean endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 190h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_add_input_string
_UI_add_input_string proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		push	0
		push	[esp+4+arg_14]
		push	[esp+8+arg_10]
		push	[esp+0Ch+arg_C]
		push	[esp+10h+arg_8]
		push	1
		push	0
		push	[esp+1Ch+arg_4]
		push	[esp+20h+arg_0]
		call	_general_allocate_string
		add	esp, 24h
		retn
_UI_add_input_string endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1B8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_add_user_data
_UI_add_user_data proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	eax, [edx+8]
		mov	[edx+8], ecx
		retn
_UI_add_user_data endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1C8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_add_verify_string
_UI_add_verify_string proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h
arg_18		= dword	ptr  1Ch

		push	[esp+arg_18]
		push	[esp+4+arg_14]
		push	[esp+8+arg_10]
		push	[esp+0Ch+arg_C]
		push	[esp+10h+arg_8]
		push	2
		push	0
		push	[esp+1Ch+arg_4]
		push	[esp+20h+arg_0]
		call	_general_allocate_string
		add	esp, 24h
		retn
_UI_add_verify_string endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1F4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_construct_prompt
_UI_construct_prompt proc near

var_18		= word ptr -18h
var_14		= dword	ptr -14h
var_10		= word ptr -10h
var_E		= byte ptr -0Eh
var_C		= dword	ptr -0Ch
var_8		= word ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 18h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+18h+var_4], eax
		mov	ecx, [esp+18h+arg_0]
		push	ebx
		mov	ebx, [esp+1Ch+arg_8]
		push	ebp
		mov	eax, [ecx]
		mov	ebp, [esp+20h+arg_4]
		push	esi
		mov	eax, [eax+18h]
		test	eax, eax
		jz	short loc_23D
		push	ebx
		push	ebp
		push	ecx
		call	eax
		add	esp, 0Ch
		mov	esi, eax
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+18h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 18h
		retn
; ---------------------------------------------------------------------------

loc_23D:				; CODE XREF: _UI_construct_prompt+2Bj
		mov	eax, ds:??_C@_06IEAFMNNH@Enter?5?$AA@ ;	`string'
		mov	[esp+24h+var_14], eax
		movzx	eax, ds:word_111C
		mov	[esp+24h+var_10], ax
		mov	al, ds:byte_111E
		mov	[esp+24h+var_E], al
		mov	eax, ds:??_C@_05POFHKGEO@?5for?5?$AA@ ;	`string'
		mov	[esp+24h+var_C], eax
		movzx	eax, ds:word_1124
		mov	[esp+24h+var_8], ax
		mov	eax, 3Ah ; ':'
		mov	[esp+24h+var_18], ax
		test	ebp, ebp
		jnz	short loc_292
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		mov	ecx, [esp+18h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 18h
		retn
; ---------------------------------------------------------------------------

loc_292:				; CODE XREF: _UI_construct_prompt+88j
		mov	ecx, ebp
		lea	edx, [ecx+1]

loc_297:				; CODE XREF: _UI_construct_prompt+A8j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_297
		sub	ecx, edx
		push	edi
		lea	edi, [ecx+6]
		test	ebx, ebx
		jz	short loc_2C2
		mov	ecx, ebx
		lea	edx, [ecx+1]
		nop	dword ptr [eax+00000000h]

loc_2B4:				; CODE XREF: _UI_construct_prompt+C5j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_2B4
		sub	ecx, edx
		add	edi, 5
		add	edi, ecx

loc_2C2:				; CODE XREF: _UI_construct_prompt+B2j
		push	19Fh
		add	edi, 2
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	edi
		call	_CRYPTO_malloc
		mov	esi, eax
		lea	eax, [esp+34h+var_14]
		push	edi
		push	eax
		push	esi
		call	_BUF_strlcpy
		push	edi
		push	ebp
		push	esi
		call	_BUF_strlcat
		add	esp, 24h
		test	ebx, ebx
		jz	short loc_309
		push	edi
		lea	eax, [esp+2Ch+var_C]
		push	eax
		push	esi
		call	_BUF_strlcat
		push	edi
		push	ebx
		push	esi
		call	_BUF_strlcat
		add	esp, 18h

loc_309:				; CODE XREF: _UI_construct_prompt+FCj
		push	edi
		lea	eax, [esp+2Ch+var_18]
		push	eax
		push	esi
		call	_BUF_strlcat
		mov	ecx, [esp+34h+var_4]
		add	esp, 0Ch
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 18h
		retn
_UI_construct_prompt endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 330h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_create_method
_UI_create_method proc near

arg_0		= dword	ptr  4

		push	esi
		push	24Eh
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	1Ch
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jz	short loc_36D
		push	[esp+4+arg_0]
		xorps	xmm0, xmm0
		movups	xmmword	ptr [esi], xmm0
		movq	qword ptr [esi+10h], xmm0
		mov	dword ptr [esi+18h], 0
		call	_BUF_strdup
		mov	[esi], eax
		add	esp, 4
		mov	eax, esi

loc_36D:				; CODE XREF: _UI_create_method+19j
		pop	esi
		retn
_UI_create_method endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 370h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_ctrl
_UI_ctrl	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jnz	short loc_394
		push	20Dh
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	43h ; 'C'
		push	6Fh ; 'o'
		push	28h ; '('
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_394:				; CODE XREF: _UI_ctrl+6j
		mov	eax, [esp+arg_4]
		sub	eax, 1
		jz	short loc_3C5
		sub	eax, 1
		jz	short loc_3BE
		push	21Fh
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	6Ah ; 'j'
		push	6Fh ; 'o'
		push	28h ; '('
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_3BE:				; CODE XREF: _UI_ctrl+30j
		mov	eax, [ecx+14h]
		and	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_3C5:				; CODE XREF: _UI_ctrl+2Bj
		mov	eax, [ecx+14h]
		mov	edx, eax
		shr	edx, 8
		and	edx, 1
		cmp	[esp+arg_8], 0
		jz	short loc_3E2
		or	eax, 100h
		mov	[ecx+14h], eax
		mov	eax, edx
		retn
; ---------------------------------------------------------------------------

loc_3E2:				; CODE XREF: _UI_ctrl+65j
		and	eax, 0FFFFFEFFh
		mov	[ecx+14h], eax
		mov	eax, edx
		retn
_UI_ctrl	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3F0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_destroy_method
_UI_destroy_method proc	near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		push	dword ptr [esi]
		call	_CRYPTO_free
		push	esi
		mov	dword ptr [esi], 0
		call	_CRYPTO_free
		add	esp, 8
		pop	esi
		retn
_UI_destroy_method endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 410h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_dup_error_string
_UI_dup_error_string proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_4]
		push	ebx
		xor	ebx, ebx
		test	eax, eax
		jz	short loc_447
		push	eax
		call	_BUF_strdup
		mov	ebx, eax
		add	esp, 4
		test	ebx, ebx
		jnz	short loc_447
		push	183h
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	41h ; 'A'
		push	65h ; 'e'
		push	28h ; '('
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_447:				; CODE XREF: _UI_dup_error_string+9j
					; _UI_dup_error_string+18j
		push	edi
		or	edi, 0FFFFFFFFh
		test	ebx, ebx
		jnz	short loc_46C
		push	8Fh ; 'è'
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	43h ; 'C'
		push	6Dh ; 'm'
		push	28h ; '('
		call	_ERR_put_error
		add	esp, 14h
		mov	eax, edi
		pop	edi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_46C:				; CODE XREF: _UI_dup_error_string+3Dj
		push	esi
		push	93h ; 'ì'
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	20h ; ' '
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jz	short loc_4F2
		mov	[esi+4], ebx
		mov	ebx, [esp+0Ch+arg_0]
		mov	dword ptr [esi+1Ch], 1
		mov	dword ptr [esi+8], 0
		mov	dword ptr [esi], 5
		mov	dword ptr [esi+0Ch], 0
		cmp	dword ptr [ebx+4], 0
		jnz	short loc_4CA
		call	_sk_new_null
		mov	[ebx+4], eax
		test	eax, eax
		jnz	short loc_4CA
		push	esi
		call	_free_string
		add	esp, 4
		mov	eax, edi
		pop	esi
		pop	edi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_4CA:				; CODE XREF: _UI_dup_error_string+9Dj
					; _UI_dup_error_string+A9j
		mov	dword ptr [esi+10h], 0
		mov	dword ptr [esi+14h], 0
		mov	dword ptr [esi+18h], 0
		push	esi
		push	dword ptr [ebx+4]
		call	_sk_push
		mov	edi, eax
		add	esp, 8
		test	edi, edi
		jg	short loc_4F2
		dec	edi

loc_4F2:				; CODE XREF: _UI_dup_error_string+75j
					; _UI_dup_error_string+DFj
		pop	esi
		mov	eax, edi
		pop	edi
		pop	ebx
		retn
_UI_dup_error_string endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4F8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_dup_info_string
_UI_dup_info_string proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_4]
		push	ebx
		xor	ebx, ebx
		test	eax, eax
		jz	short loc_52F
		push	eax
		call	_BUF_strdup
		mov	ebx, eax
		add	esp, 4
		test	ebx, ebx
		jnz	short loc_52F
		push	16Dh
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	41h ; 'A'
		push	66h ; 'f'
		push	28h ; '('
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_52F:				; CODE XREF: _UI_dup_info_string+9j
					; _UI_dup_info_string+18j
		push	edi
		or	edi, 0FFFFFFFFh
		test	ebx, ebx
		jnz	short loc_554
		push	8Fh ; 'è'
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	43h ; 'C'
		push	6Dh ; 'm'
		push	28h ; '('
		call	_ERR_put_error
		add	esp, 14h
		mov	eax, edi
		pop	edi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_554:				; CODE XREF: _UI_dup_info_string+3Dj
		push	esi
		push	93h ; 'ì'
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	20h ; ' '
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jz	short loc_5DA
		mov	[esi+4], ebx
		mov	ebx, [esp+0Ch+arg_0]
		mov	dword ptr [esi+1Ch], 1
		mov	dword ptr [esi+8], 0
		mov	dword ptr [esi], 4
		mov	dword ptr [esi+0Ch], 0
		cmp	dword ptr [ebx+4], 0
		jnz	short loc_5B2
		call	_sk_new_null
		mov	[ebx+4], eax
		test	eax, eax
		jnz	short loc_5B2
		push	esi
		call	_free_string
		add	esp, 4
		mov	eax, edi
		pop	esi
		pop	edi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_5B2:				; CODE XREF: _UI_dup_info_string+9Dj
					; _UI_dup_info_string+A9j
		mov	dword ptr [esi+10h], 0
		mov	dword ptr [esi+14h], 0
		mov	dword ptr [esi+18h], 0
		push	esi
		push	dword ptr [ebx+4]
		call	_sk_push
		mov	edi, eax
		add	esp, 8
		test	edi, edi
		jg	short loc_5DA
		dec	edi

loc_5DA:				; CODE XREF: _UI_dup_info_string+75j
					; _UI_dup_info_string+DFj
		pop	esi
		mov	eax, edi
		pop	edi
		pop	ebx
		retn
_UI_dup_info_string endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5E0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_dup_input_boolean
_UI_dup_input_boolean proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h
arg_18		= dword	ptr  1Ch

		mov	eax, [esp+arg_4]
		push	ebx
		push	ebp
		push	esi
		push	edi
		xor	ebx, ebx
		xor	edi, edi
		xor	esi, esi
		xor	ebp, ebp
		test	eax, eax
		jz	short loc_623
		push	eax
		call	_BUF_strdup
		mov	ebx, eax
		add	esp, 4
		test	ebx, ebx
		jnz	short loc_623
		push	134h
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	41h ; 'A'
		push	6Eh ; 'n'
		push	28h ; '('
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_623:				; CODE XREF: _UI_dup_input_boolean+12j
					; _UI_dup_input_boolean+21j
		mov	eax, [esp+10h+arg_8]
		test	eax, eax
		jz	short loc_641
		push	eax
		call	_BUF_strdup
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jnz	short loc_641
		push	13Ch
		jmp	short loc_67B
; ---------------------------------------------------------------------------

loc_641:				; CODE XREF: _UI_dup_input_boolean+49j
					; _UI_dup_input_boolean+58j
		mov	eax, [esp+10h+arg_C]
		test	eax, eax
		jz	short loc_65F
		push	eax
		call	_BUF_strdup
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jnz	short loc_65F
		push	144h
		jmp	short loc_67B
; ---------------------------------------------------------------------------

loc_65F:				; CODE XREF: _UI_dup_input_boolean+67j
					; _UI_dup_input_boolean+76j
		mov	eax, [esp+10h+arg_10]
		test	eax, eax
		jz	short loc_6BD
		push	eax
		call	_BUF_strdup
		mov	ebp, eax
		add	esp, 4
		test	ebp, ebp
		jnz	short loc_6BD
		push	14Ch

loc_67B:				; CODE XREF: _UI_dup_input_boolean+5Fj
					; _UI_dup_input_boolean+7Dj
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	41h ; 'A'
		push	6Eh ; 'n'
		push	28h ; '('
		call	_ERR_put_error
		add	esp, 14h

$err$17:
		test	ebx, ebx
		jz	short loc_69B
		push	ebx
		call	_CRYPTO_free
		add	esp, 4

loc_69B:				; CODE XREF: _UI_dup_input_boolean+B0j
		test	edi, edi
		jz	short loc_6A8
		push	edi
		call	_CRYPTO_free
		add	esp, 4

loc_6A8:				; CODE XREF: _UI_dup_input_boolean+BDj
		test	esi, esi
		jz	short loc_6B5
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_6B5:				; CODE XREF: _UI_dup_input_boolean+CAj
		pop	edi
		pop	esi
		pop	ebp
		or	eax, 0FFFFFFFFh
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_6BD:				; CODE XREF: _UI_dup_input_boolean+85j
					; _UI_dup_input_boolean+94j
		push	[esp+10h+arg_18] ; int
		push	[esp+14h+arg_14] ; int
		push	3		; int
		push	1		; int
		push	ebp		; Str
		push	esi		; int
		push	edi		; int
		push	ebx		; int
		push	[esp+30h+arg_0]	; int
		call	_general_allocate_boolean
		add	esp, 24h
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_UI_dup_input_boolean endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6E0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_dup_input_string
_UI_dup_input_string proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	ecx, [esp+arg_4]
		xor	eax, eax
		test	ecx, ecx
		jz	short loc_712
		push	ecx
		call	_BUF_strdup
		add	esp, 4
		test	eax, eax
		jnz	short loc_712
		push	0F9h ; '˘'
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	41h ; 'A'
		push	67h ; 'g'
		push	28h ; '('
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_712:				; CODE XREF: _UI_dup_input_string+8j
					; _UI_dup_input_string+15j
		push	0
		push	[esp+4+arg_14]
		push	[esp+8+arg_10]
		push	[esp+0Ch+arg_C]
		push	[esp+10h+arg_8]
		push	1
		push	1
		push	eax
		push	[esp+20h+arg_0]
		call	_general_allocate_string
		add	esp, 24h
		retn
_UI_dup_input_string endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 738h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_dup_verify_string
_UI_dup_verify_string proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h
arg_18		= dword	ptr  1Ch

		mov	ecx, [esp+arg_4]
		xor	eax, eax
		test	ecx, ecx
		jz	short loc_76B
		push	ecx
		call	_BUF_strdup
		add	esp, 4
		test	eax, eax
		jnz	short loc_76B
		push	115h
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	41h ; 'A'
		push	6Ah ; 'j'
		push	28h ; '('
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_76B:				; CODE XREF: _UI_dup_verify_string+8j
					; _UI_dup_verify_string+15j
		push	[esp+arg_18]
		push	[esp+4+arg_14]
		push	[esp+8+arg_10]
		push	[esp+0Ch+arg_C]
		push	[esp+10h+arg_8]
		push	2
		push	1
		push	eax
		push	[esp+20h+arg_0]
		call	_general_allocate_string
		add	esp, 24h
		retn
_UI_dup_verify_string endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 794h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_free
_UI_free	proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	short loc_7BF
		push	offset _free_string
		push	dword ptr [esi+4]
		call	_sk_pop_free
		lea	eax, [esi+0Ch]
		push	eax
		push	esi
		push	0Bh
		call	_CRYPTO_free_ex_data
		push	esi
		call	_CRYPTO_free
		add	esp, 18h

loc_7BF:				; CODE XREF: _UI_free+7j
		pop	esi
		retn
_UI_free	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7C4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_get0_action_string
_UI_get0_action_string proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jnz	short loc_7CF

loc_7CC:				; CODE XREF: _UI_get0_action_string+15j
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_7CF:				; CODE XREF: _UI_get0_action_string+6j
		mov	eax, [ecx]
		sub	eax, 1
		jz	short loc_7DB
		sub	eax, 2
		jnz	short loc_7CC

loc_7DB:				; CODE XREF: _UI_get0_action_string+10j
		mov	eax, [ecx+10h]
		retn
_UI_get0_action_string endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7E0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_get0_output_string
_UI_get0_output_string proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jnz	short loc_7E9
		retn
; ---------------------------------------------------------------------------

loc_7E9:				; CODE XREF: _UI_get0_output_string+6j
		mov	eax, [eax+4]
		retn
_UI_get0_output_string endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7F0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_get0_result
_UI_get0_result	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_4]
		test	esi, esi
		jns	short loc_815
		push	1BAh
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	67h ; 'g'
		push	6Bh ; 'k'
		push	28h ; '('
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_815:				; CODE XREF: _UI_get0_result+7j
		push	edi
		mov	edi, [esp+8+arg_0]
		push	dword ptr [edi+4]
		call	_sk_num
		add	esp, 4
		cmp	esi, eax
		jl	short loc_846
		push	1BEh
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	66h ; 'f'
		push	6Bh ; 'k'
		push	28h ; '('
		call	_ERR_put_error
		add	esp, 14h

loc_841:				; CODE XREF: _UI_get0_result+66j
					; _UI_get0_result+6Ej
		pop	edi
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_846:				; CODE XREF: _UI_get0_result+37j
		push	esi
		push	dword ptr [edi+4]
		call	_sk_value
		mov	ecx, eax
		add	esp, 8
		test	ecx, ecx
		jz	short loc_841
		mov	eax, [ecx]
		dec	eax
		cmp	eax, 1
		ja	short loc_841
		mov	eax, [ecx+0Ch]
		pop	edi
		pop	esi
		retn
_UI_get0_result	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 868h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_get0_result_string
_UI_get0_result_string proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short loc_87C
		mov	ecx, [eax]
		dec	ecx
		cmp	ecx, 1
		ja	short loc_87C
		mov	eax, [eax+0Ch]
		retn
; ---------------------------------------------------------------------------

loc_87C:				; CODE XREF: _UI_get0_result_string+6j
					; _UI_get0_result_string+Ej
		xor	eax, eax
		retn
_UI_get0_result_string endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 880h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_get0_test_string
_UI_get0_test_string proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jnz	short loc_88B

loc_888:				; CODE XREF: _UI_get0_test_string+10j
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_88B:				; CODE XREF: _UI_get0_test_string+6j
		mov	eax, [ecx]
		sub	eax, 2
		jnz	short loc_888
		mov	eax, [ecx+18h]
		retn
_UI_get0_test_string endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 898h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_get0_user_data
_UI_get0_user_data proc	near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+8]
		retn
_UI_get0_user_data endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8A0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_get_default_method
_UI_get_default_method proc near
		mov	eax, ds:_default_UI_meth
		test	eax, eax
		jnz	short locret_8B3
		call	_UI_OpenSSL
		mov	ds:_default_UI_meth, eax

locret_8B3:				; CODE XREF: _UI_get_default_method+7j
		retn
_UI_get_default_method endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8B4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_get_ex_data
_UI_get_ex_data	proc near

arg_0		= dword	ptr  4

		add	[esp+arg_0], 0Ch
		jmp	_CRYPTO_get_ex_data
_UI_get_ex_data	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8C0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_get_ex_new_index
_UI_get_ex_new_index proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		push	[esp+arg_10]
		push	[esp+4+arg_C]
		push	[esp+8+arg_8]
		push	[esp+0Ch+arg_4]
		push	[esp+10h+arg_0]
		push	0Bh
		call	_CRYPTO_get_ex_new_index
		add	esp, 18h
		retn
_UI_get_ex_new_index endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8E0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_get_input_flags
_UI_get_input_flags proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jnz	short loc_8E9
		retn
; ---------------------------------------------------------------------------

loc_8E9:				; CODE XREF: _UI_get_input_flags+6j
		mov	eax, [eax+8]
		retn
_UI_get_input_flags endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8F0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_get_method
_UI_get_method	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax]
		retn
_UI_get_method	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8F8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_get_result_maxsize
_UI_get_result_maxsize proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short loc_90C
		mov	ecx, [eax]
		dec	ecx
		cmp	ecx, 1
		ja	short loc_90C
		mov	eax, [eax+14h]
		retn
; ---------------------------------------------------------------------------

loc_90C:				; CODE XREF: _UI_get_result_maxsize+6j
					; _UI_get_result_maxsize+Ej
		or	eax, 0FFFFFFFFh
		retn
_UI_get_result_maxsize endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 910h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_get_result_minsize
_UI_get_result_minsize proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short loc_924
		mov	ecx, [eax]
		dec	ecx
		cmp	ecx, 1
		ja	short loc_924
		mov	eax, [eax+10h]
		retn
; ---------------------------------------------------------------------------

loc_924:				; CODE XREF: _UI_get_result_minsize+6j
					; _UI_get_result_minsize+Ej
		or	eax, 0FFFFFFFFh
		retn
_UI_get_result_minsize endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 928h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_get_string_type
_UI_get_string_type proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jnz	short loc_931
		retn
; ---------------------------------------------------------------------------

loc_931:				; CODE XREF: _UI_get_string_type+6j
		mov	eax, [eax]
		retn
_UI_get_string_type endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 934h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_method_get_closer
_UI_method_get_closer proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short loc_940
		mov	eax, [eax+14h]
		retn
; ---------------------------------------------------------------------------

loc_940:				; CODE XREF: _UI_method_get_closer+6j
		xor	eax, eax
		retn
_UI_method_get_closer endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 944h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_method_get_flusher
_UI_method_get_flusher proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short loc_950
		mov	eax, [eax+0Ch]
		retn
; ---------------------------------------------------------------------------

loc_950:				; CODE XREF: _UI_method_get_flusher+6j
		xor	eax, eax
		retn
_UI_method_get_flusher endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 954h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_method_get_opener
_UI_method_get_opener proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short loc_960
		mov	eax, [eax+4]
		retn
; ---------------------------------------------------------------------------

loc_960:				; CODE XREF: _UI_method_get_opener+6j
		xor	eax, eax
		retn
_UI_method_get_opener endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 964h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_method_get_prompt_constructor
_UI_method_get_prompt_constructor proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short loc_970
		mov	eax, [eax+18h]
		retn
; ---------------------------------------------------------------------------

loc_970:				; CODE XREF: _UI_method_get_prompt_constructor+6j
		xor	eax, eax
		retn
_UI_method_get_prompt_constructor endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 974h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_method_get_reader
_UI_method_get_reader proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short loc_980
		mov	eax, [eax+10h]
		retn
; ---------------------------------------------------------------------------

loc_980:				; CODE XREF: _UI_method_get_reader+6j
		xor	eax, eax
		retn
_UI_method_get_reader endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 984h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_method_get_writer
_UI_method_get_writer proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short loc_990
		mov	eax, [eax+8]
		retn
; ---------------------------------------------------------------------------

loc_990:				; CODE XREF: _UI_method_get_writer+6j
		xor	eax, eax
		retn
_UI_method_get_writer endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 994h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_method_set_closer
_UI_method_set_closer proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jz	short loc_9A6
		mov	eax, [esp+arg_4]
		mov	[ecx+14h], eax
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_9A6:				; CODE XREF: _UI_method_set_closer+6j
		or	eax, 0FFFFFFFFh
		retn
_UI_method_set_closer endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 9ACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_method_set_flusher
_UI_method_set_flusher proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jz	short loc_9BE
		mov	eax, [esp+arg_4]
		mov	[ecx+0Ch], eax
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_9BE:				; CODE XREF: _UI_method_set_flusher+6j
		or	eax, 0FFFFFFFFh
		retn
_UI_method_set_flusher endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 9C4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_method_set_opener
_UI_method_set_opener proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jz	short loc_9D6
		mov	eax, [esp+arg_4]
		mov	[ecx+4], eax
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_9D6:				; CODE XREF: _UI_method_set_opener+6j
		or	eax, 0FFFFFFFFh
		retn
_UI_method_set_opener endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 9DCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_method_set_prompt_constructor
_UI_method_set_prompt_constructor proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jz	short loc_9EE
		mov	eax, [esp+arg_4]
		mov	[ecx+18h], eax
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_9EE:				; CODE XREF: _UI_method_set_prompt_constructor+6j
		or	eax, 0FFFFFFFFh
		retn
_UI_method_set_prompt_constructor endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 9F4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_method_set_reader
_UI_method_set_reader proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jz	short loc_A06
		mov	eax, [esp+arg_4]
		mov	[ecx+10h], eax
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_A06:				; CODE XREF: _UI_method_set_reader+6j
		or	eax, 0FFFFFFFFh
		retn
_UI_method_set_reader endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A0Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_method_set_writer
_UI_method_set_writer proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jz	short loc_A1E
		mov	eax, [esp+arg_4]
		mov	[ecx+8], eax
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_A1E:				; CODE XREF: _UI_method_set_writer+6j
		or	eax, 0FFFFFFFFh
		retn
_UI_method_set_writer endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A24h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_new
_UI_new		proc near
		push	esi
		push	51h ; 'Q'
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	18h
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jnz	short loc_A55
		push	53h ; 'S'
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	41h ; 'A'
		push	68h ; 'h'
		push	28h ; '('
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_A55:				; CODE XREF: _UI_new+16j
		mov	eax, ds:_default_UI_meth
		test	eax, eax
		jnz	short loc_A68
		call	_UI_OpenSSL
		mov	ds:_default_UI_meth, eax

loc_A68:				; CODE XREF: _UI_new+38j
		lea	ecx, [esi+0Ch]
		mov	[esi], eax
		push	ecx
		push	esi
		push	0Bh
		mov	dword ptr [esi+4], 0
		mov	dword ptr [esi+8], 0
		mov	dword ptr [esi+14h], 0
		call	_CRYPTO_new_ex_data
		add	esp, 0Ch
		mov	eax, esi
		pop	esi
		retn
_UI_new		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A94h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_new_method
_UI_new_method	proc near

arg_0		= dword	ptr  4

		push	esi
		push	51h ; 'Q'
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	18h
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jnz	short loc_AC5
		push	53h ; 'S'
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	41h ; 'A'
		push	68h ; 'h'
		push	28h ; '('
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_AC5:				; CODE XREF: _UI_new_method+16j
		mov	eax, [esp+4+arg_0]
		test	eax, eax
		jnz	short loc_AE0
		mov	eax, ds:_default_UI_meth
		test	eax, eax
		jnz	short loc_AE0
		call	_UI_OpenSSL
		mov	ds:_default_UI_meth, eax

loc_AE0:				; CODE XREF: _UI_new_method+37j
					; _UI_new_method+40j
		mov	[esi], eax
		lea	eax, [esi+0Ch]
		push	eax
		push	esi
		push	0Bh
		mov	dword ptr [esi+4], 0
		mov	dword ptr [esi+8], 0
		mov	dword ptr [esi+14h], 0
		call	_CRYPTO_new_ex_data
		add	esp, 0Ch
		mov	eax, esi
		pop	esi
		retn
_UI_new_method	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B0Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_process
_UI_process	proc near

arg_0		= dword	ptr  4

		push	ebx
		push	esi
		mov	esi, [esp+8+arg_0]
		xor	ebx, ebx
		mov	eax, [esi]
		mov	eax, [eax+4]
		test	eax, eax
		jz	short loc_B2D
		push	esi
		call	eax
		add	esp, 4
		test	eax, eax
		jnz	short loc_B2D

loc_B27:				; CODE XREF: _UI_process+105j
		pop	esi
		or	eax, 0FFFFFFFFh
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_B2D:				; CODE XREF: _UI_process+Fj
					; _UI_process+19j
		test	dword ptr [esi+14h], 100h
		jz	short loc_B44
		push	esi
		push	offset _print_error
		call	_ERR_print_errors_cb
		add	esp, 8

loc_B44:				; CODE XREF: _UI_process+28j
		push	ebp
		push	edi
		push	dword ptr [esi+4]
		xor	edi, edi
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jle	short loc_B8A
		nop	dword ptr [eax+eax+00h]

loc_B5C:				; CODE XREF: _UI_process+7Cj
		mov	ebp, [esi]
		cmp	[ebp+8], ebx
		jz	short loc_B7A
		push	edi
		push	dword ptr [esi+4]
		call	_sk_value
		push	eax
		mov	eax, [ebp+8]
		push	esi
		call	eax
		add	esp, 10h
		test	eax, eax
		jz	short loc_BF4

loc_B7A:				; CODE XREF: _UI_process+55j
		push	dword ptr [esi+4]
		inc	edi
		call	_sk_num
		add	esp, 4
		cmp	edi, eax
		jl	short loc_B5C

loc_B8A:				; CODE XREF: _UI_process+49j
		mov	eax, [esi]
		mov	eax, [eax+0Ch]
		test	eax, eax
		jz	short loc_BA4
		push	esi
		call	eax
		add	esp, 4
		cmp	eax, 0FFFFFFFFh
		jz	short loc_BF9
		test	eax, eax
		jz	short loc_BF4
		xor	ebx, ebx

loc_BA4:				; CODE XREF: _UI_process+85j
		push	dword ptr [esi+4]
		xor	edi, edi
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jle	short $err$38
		nop	dword ptr [eax+00000000h]

loc_BBC:				; CODE XREF: _UI_process+E4j
		mov	ebp, [esi]
		cmp	dword ptr [ebp+10h], 0
		jz	short loc_BE2
		push	edi
		push	dword ptr [esi+4]
		call	_sk_value
		push	eax
		mov	eax, [ebp+10h]
		push	esi
		call	eax
		add	esp, 10h
		cmp	eax, 0FFFFFFFFh
		jz	short loc_BF9
		test	eax, eax
		jz	short loc_BF4
		xor	ebx, ebx

loc_BE2:				; CODE XREF: _UI_process+B6j
		push	dword ptr [esi+4]
		inc	edi
		call	_sk_num
		add	esp, 4
		cmp	edi, eax
		jl	short loc_BBC
		jmp	short $err$38
; ---------------------------------------------------------------------------

loc_BF4:				; CODE XREF: _UI_process+6Cj
					; _UI_process+94j ...
		or	ebx, 0FFFFFFFFh
		jmp	short $err$38
; ---------------------------------------------------------------------------

loc_BF9:				; CODE XREF: _UI_process+90j
					; _UI_process+CEj
		mov	ebx, 0FFFFFFFEh

$err$38:				; CODE XREF: _UI_process+A7j
					; _UI_process+E6j ...
		mov	eax, [esi]
		pop	edi
		pop	ebp
		mov	eax, [eax+14h]
		test	eax, eax
		jz	short loc_C17
		push	esi
		call	eax
		add	esp, 4
		test	eax, eax
		jz	loc_B27

loc_C17:				; CODE XREF: _UI_process+FBj
		pop	esi
		mov	eax, ebx
		pop	ebx
		retn
_UI_process	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C1Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_set_default_method
_UI_set_default_method proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	ds:_default_UI_meth, eax
		retn
_UI_set_default_method endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C28h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_set_ex_data
_UI_set_ex_data	proc near

arg_0		= dword	ptr  4

		add	[esp+arg_0], 0Ch
		jmp	_CRYPTO_set_ex_data
_UI_set_ex_data	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C34h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_set_method
_UI_set_method	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		mov	eax, [esp+arg_4]
		mov	[ecx], eax
		retn
_UI_set_method	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C40h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _UI_set_result
_UI_set_result	proc near

var_24		= byte ptr -24h
var_14		= byte ptr -14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 24h ; '$'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+24h+var_4], eax
		push	ebx
		push	ebp
		mov	ebp, [esp+2Ch+arg_0]
		push	esi
		mov	esi, [esp+30h+arg_8]
		mov	ebx, esi
		push	edi
		mov	edi, [esp+34h+arg_4]
		lea	ecx, [ebx+1]
		nop	word ptr [eax+eax+00h]

loc_C70:				; CODE XREF: _UI_set_result+35j
		mov	al, [ebx]
		inc	ebx
		test	al, al
		jnz	short loc_C70
		and	dword ptr [ebp+14h], 0FFFFFFFEh
		sub	ebx, ecx
		test	edi, edi
		jz	loc_DA6
		mov	eax, [edi]
		test	eax, eax
		jle	loc_DFE
		cmp	eax, 2
		jle	loc_D3A
		cmp	eax, 3
		jnz	loc_DFE
		mov	eax, [edi+0Ch]
		test	eax, eax
		jnz	short loc_CB2
		push	352h
		jmp	loc_DDD
; ---------------------------------------------------------------------------

loc_CB2:				; CODE XREF: _UI_set_result+66j
		mov	byte ptr [eax],	0
		cmp	byte ptr [esi],	0
		jz	loc_DFE
		mov	ebx, dword ptr ds:__imp__strchr

loc_CC4:				; CODE XREF: _UI_set_result+A7j
		movsx	eax, byte ptr [esi]
		push	eax		; Val
		push	dword ptr [edi+14h] ; Str
		call	ebx ; __imp__strchr
		add	esp, 8
		test	eax, eax
		jnz	short loc_D1B
		movsx	eax, byte ptr [esi]
		push	eax		; Val
		push	dword ptr [edi+18h] ; Str
		call	ebx ; __imp__strchr
		add	esp, 8
		test	eax, eax
		jnz	short loc_CFC
		inc	esi
		cmp	[esi], al
		jnz	short loc_CC4
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+24h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 24h
		retn
; ---------------------------------------------------------------------------

loc_CFC:				; CODE XREF: _UI_set_result+A2j
		mov	eax, [edi+18h]
		mov	ecx, [edi+0Ch]
		pop	edi
		pop	esi
		mov	al, [eax]
		pop	ebp
		mov	[ecx], al
		xor	eax, eax
		pop	ebx
		mov	ecx, [esp+24h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 24h
		retn
; ---------------------------------------------------------------------------

loc_D1B:				; CODE XREF: _UI_set_result+92j
		mov	eax, [edi+14h]
		mov	ecx, [edi+0Ch]
		pop	edi
		pop	esi
		mov	al, [eax]
		pop	ebp
		mov	[ecx], al
		xor	eax, eax
		pop	ebx
		mov	ecx, [esp+24h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 24h
		retn
; ---------------------------------------------------------------------------

loc_D3A:				; CODE XREF: _UI_set_result+52j
		push	dword ptr [edi+10h]
		lea	eax, [esp+38h+var_14]
		push	offset ??_C@_02DPKJAMEF@?$CFd?$AA@ ; `string'
		push	0Dh
		push	eax
		call	_BIO_snprintf
		push	dword ptr [edi+14h]
		lea	eax, [esp+48h+var_24]
		push	offset ??_C@_02DPKJAMEF@?$CFd?$AA@ ; `string'
		push	0Dh
		push	eax
		call	_BIO_snprintf
		add	esp, 20h
		cmp	ebx, [edi+10h]
		jge	short loc_DBC
		push	337h
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	65h ; 'e'

loc_D76:				; CODE XREF: _UI_set_result+18Fj
		or	dword ptr [ebp+14h], 1
		push	69h ; 'i'
		push	28h ; '('
		call	_ERR_put_error
		push	offset ??_C@_0M@MCBMLIEP@?5characters?$AA@ ; " characters"
		lea	eax, [esp+4Ch+var_24]
		push	eax
		push	offset ??_C@_04MKEOLIJC@?5to?5?$AA@ ; "	to "
		lea	eax, [esp+54h+var_14]
		push	eax
		push	offset ??_C@_0BC@FIPJHCII@You?5must?5type?5in?5?$AA@ ; "You must type in "
		push	5
		call	_ERR_add_error_data
		add	esp, 2Ch

loc_DA6:				; CODE XREF: _UI_set_result+3Fj
					; _UI_set_result+1B0j
		pop	edi
		pop	esi
		pop	ebp
		or	eax, 0FFFFFFFFh
		pop	ebx
		mov	ecx, [esp+24h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 24h
		retn
; ---------------------------------------------------------------------------

loc_DBC:				; CODE XREF: _UI_set_result+128j
		mov	eax, [edi+14h]
		cmp	ebx, eax
		jle	short loc_DD1
		push	33Eh
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	64h ; 'd'
		jmp	short loc_D76
; ---------------------------------------------------------------------------

loc_DD1:				; CODE XREF: _UI_set_result+181j
		mov	ecx, [edi+0Ch]
		test	ecx, ecx
		jnz	short loc_DF2
		push	346h

loc_DDD:				; CODE XREF: _UI_set_result+6Dj
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	69h ; 'i'
		push	69h ; 'i'
		push	28h ; '('
		call	_ERR_put_error
		add	esp, 14h
		jmp	short loc_DA6
; ---------------------------------------------------------------------------

loc_DF2:				; CODE XREF: _UI_set_result+196j
		inc	eax
		push	eax
		push	esi
		push	ecx
		call	_BUF_strlcpy
		add	esp, 0Ch

loc_DFE:				; CODE XREF: _UI_set_result+49j
					; _UI_set_result+5Bj ...
		mov	ecx, [esp+34h+var_4]
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 24h
		retn
_UI_set_result	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E14h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_allocate_string_stack proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		cmp	dword ptr [esi+4], 0
		jnz	short loc_E30
		call	_sk_new_null
		mov	[esi+4], eax
		test	eax, eax
		jnz	short loc_E30
		or	eax, 0FFFFFFFFh
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_E30:				; CODE XREF: _allocate_string_stack+9j
					; _allocate_string_stack+15j
		xor	eax, eax
		pop	esi
		retn
_allocate_string_stack endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E34h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_free_string	proc near		; CODE XREF: _UI_add_error_string+76p
					; _UI_add_info_string+76p ...

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	byte ptr [esi+1Ch], 1
		jz	short loc_E6A
		push	dword ptr [esi+4]
		call	_CRYPTO_free
		add	esp, 4
		cmp	dword ptr [esi], 3
		jnz	short loc_E6A
		push	dword ptr [esi+10h]
		call	_CRYPTO_free
		push	dword ptr [esi+14h]
		call	_CRYPTO_free
		push	dword ptr [esi+18h]
		call	_CRYPTO_free
		add	esp, 0Ch

loc_E6A:				; CODE XREF: _free_string+9j
					; _free_string+19j
		push	esi
		call	_CRYPTO_free
		add	esp, 4
		pop	esi
		retn
_free_string	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E78h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl general_allocate_boolean(int, int, int, int, char	*Str, int, int,	int, int)
_general_allocate_boolean proc near	; CODE XREF: _UI_add_input_boolean+20p
					; _UI_dup_input_boolean+F1p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
Str		= dword	ptr  14h
arg_14		= dword	ptr  18h
arg_18		= dword	ptr  1Ch
arg_1C		= dword	ptr  20h
arg_20		= dword	ptr  24h

		push	ebx
		mov	ebx, [esp+4+arg_C]
		test	ebx, ebx
		jnz	short loc_E9E
		push	0C4h ; 'ƒ'
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	43h ; 'C'
		push	6Ch ; 'l'
		push	28h ; '('
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_E9E:				; CODE XREF: _general_allocate_boolean+7j
		push	edi
		mov	edi, [esp+8+Str]
		test	edi, edi
		jnz	short loc_EC5
		push	0C6h ; '∆'
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	43h ; 'C'
		push	6Ch ; 'l'
		push	28h ; '('
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		pop	edi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_EC5:				; CODE XREF: _general_allocate_boolean+2Dj
		cmp	byte ptr [ebx],	0
		push	ebp
		push	esi
		mov	esi, ebx
		jz	short loc_F04
		mov	ebp, dword ptr ds:__imp__strchr
		nop	dword ptr [eax+00h]

loc_ED8:				; CODE XREF: _general_allocate_boolean+8Aj
		movsx	eax, byte ptr [esi]
		push	eax		; Val
		push	edi		; Str
		call	ebp ; __imp__strchr
		add	esp, 8
		test	eax, eax
		jz	short loc_EFE
		push	0CBh ; 'À'
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	68h ; 'h'
		push	6Ch ; 'l'
		push	28h ; '('
		call	_ERR_put_error
		add	esp, 14h

loc_EFE:				; CODE XREF: _general_allocate_boolean+6Cj
		inc	esi
		cmp	byte ptr [esi],	0
		jnz	short loc_ED8

loc_F04:				; CODE XREF: _general_allocate_boolean+54j
		push	[esp+10h+arg_20]
		mov	ebp, [esp+14h+arg_0]
		push	[esp+14h+arg_1C]
		push	[esp+18h+arg_18]
		push	[esp+1Ch+arg_14]
		push	[esp+20h+arg_4]
		push	ebp
		call	_general_allocate_prompt
		mov	esi, eax
		add	esp, 18h
		test	esi, esi
		jz	short loc_F77
		cmp	dword ptr [ebp+4], 0
		jnz	short loc_F7F
		call	_sk_new_null
		mov	[ebp+4], eax
		test	eax, eax
		jnz	short loc_F7F
		test	byte ptr [esi+1Ch], 1
		jz	short loc_F6E
		push	dword ptr [esi+4]
		call	_CRYPTO_free
		add	esp, 4
		cmp	dword ptr [esi], 3
		jnz	short loc_F6E
		push	dword ptr [esi+10h]
		call	_CRYPTO_free
		push	dword ptr [esi+14h]
		call	_CRYPTO_free
		push	dword ptr [esi+18h]
		call	_CRYPTO_free
		add	esp, 0Ch

loc_F6E:				; CODE XREF: _general_allocate_boolean+C9j
					; _general_allocate_boolean+D9j
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_F77:				; CODE XREF: _general_allocate_boolean+B1j
		or	eax, 0FFFFFFFFh

loc_F7A:				; CODE XREF: _general_allocate_boolean+122j
		pop	esi
		pop	ebp
		pop	edi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_F7F:				; CODE XREF: _general_allocate_boolean+B7j
					; _general_allocate_boolean+C3j
		mov	eax, [esp+10h+arg_8]
		mov	[esi+10h], eax
		mov	[esi+14h], ebx
		mov	[esi+18h], edi
		push	esi
		push	dword ptr [ebp+4]
		call	_sk_push
		add	esp, 8
		test	eax, eax
		jg	short loc_F7A
		pop	esi
		pop	ebp
		pop	edi
		dec	eax
		pop	ebx
		retn
_general_allocate_boolean endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0FA4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_general_allocate_prompt proc near	; CODE XREF: _general_allocate_boolean+A5p
					; _general_allocate_string+1Bp

arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		push	edi
		mov	edi, [esp+4+arg_4]
		test	edi, edi
		jnz	short loc_FC9
		push	8Fh ; 'è'
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	43h ; 'C'
		push	6Dh ; 'm'
		push	28h ; '('
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_FC9:				; CODE XREF: _general_allocate_prompt+7j
		push	ebx
		mov	ebx, [esp+8+arg_14]
		push	esi
		mov	esi, [esp+0Ch+arg_C]
		cmp	esi, 1
		jz	short loc_FE2
		cmp	esi, 2
		jz	short loc_FE2
		cmp	esi, 3
		jnz	short loc_1004

loc_FE2:				; CODE XREF: _general_allocate_prompt+32j
					; _general_allocate_prompt+37j
		test	ebx, ebx
		jnz	short loc_1004
		push	92h ; 'í'
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	69h ; 'i'
		push	6Dh ; 'm'
		push	28h ; '('
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		pop	ebx
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_1004:				; CODE XREF: _general_allocate_prompt+3Cj
					; _general_allocate_prompt+40j
		push	93h ; 'ì'
		push	offset ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ ; ".\\crypto\\ui\\ui_lib.c"
		push	20h ; ' '
		call	_CRYPTO_malloc
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_1037
		xor	ecx, ecx
		mov	[eax+4], edi
		cmp	[esp+0Ch+arg_8], ecx
		mov	[eax], esi
		setnz	cl
		mov	[eax+0Ch], ebx
		mov	[eax+1Ch], ecx
		mov	ecx, [esp+0Ch+arg_10]
		mov	[eax+8], ecx

loc_1037:				; CODE XREF: _general_allocate_prompt+76j
		pop	esi
		pop	ebx
		pop	edi
		retn
_general_allocate_prompt endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 103Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_general_allocate_string proc near	; CODE XREF: _UI_add_input_string+1Ep
					; _UI_add_verify_string+20p ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h
arg_18		= dword	ptr  1Ch
arg_1C		= dword	ptr  20h
arg_20		= dword	ptr  24h

		push	esi
		push	edi
		push	[esp+8+arg_14]
		mov	edi, [esp+0Ch+arg_0]
		push	[esp+0Ch+arg_10]
		push	[esp+10h+arg_C]
		push	[esp+14h+arg_8]
		push	[esp+18h+arg_4]
		push	edi
		call	_general_allocate_prompt
		mov	esi, eax
		add	esp, 18h
		test	esi, esi
		jz	short loc_1080
		cmp	dword ptr [edi+4], 0
		jnz	short loc_1086
		call	_sk_new_null
		mov	[edi+4], eax
		test	eax, eax
		jnz	short loc_1086
		push	esi
		call	_free_string
		add	esp, 4

loc_1080:				; CODE XREF: _general_allocate_string+27j
		or	eax, 0FFFFFFFFh

loc_1083:				; CODE XREF: _general_allocate_string+6Dj
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1086:				; CODE XREF: _general_allocate_string+2Dj
					; _general_allocate_string+39j
		mov	eax, [esp+8+arg_18]
		mov	[esi+10h], eax
		mov	eax, [esp+8+arg_1C]
		mov	[esi+14h], eax
		mov	eax, [esp+8+arg_20]
		mov	[esi+18h], eax
		push	esi
		push	dword ptr [edi+4]
		call	_sk_push
		add	esp, 8
		test	eax, eax
		jg	short loc_1083
		pop	edi
		dec	eax
		pop	esi
		retn
_general_allocate_string endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 10B0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_print_error	proc near		; DATA XREF: _UI_process+2Bo

var_20		= xmmword ptr -20h
var_10		= xmmword ptr -10h
arg_0		= dword	ptr  4
arg_8		= dword	ptr  0Ch

		mov	eax, 20h ; ' '
		call	__chkstk
		mov	ecx, [esp+20h+arg_8]
		xorps	xmm0, xmm0
		mov	eax, [esp+20h+arg_0]
		movups	[esp+20h+var_20], xmm0
		mov	dword ptr [esp+20h+var_20+4], eax
		mov	eax, [ecx]
		movups	[esp+20h+var_10], xmm0
		mov	dword ptr [esp+20h+var_20], 5
		mov	eax, [eax+8]
		test	eax, eax
		jz	short loc_10F7
		lea	edx, [esp+20h+var_20]
		push	edx
		push	ecx
		call	eax
		add	esp, 8
		test	eax, eax
		jnz	short loc_10F7
		or	eax, 0FFFFFFFFh
		add	esp, 20h
		retn
; ---------------------------------------------------------------------------

loc_10F7:				; CODE XREF: _print_error+30j
					; _print_error+3Ej
		xor	eax, eax
		add	esp, 20h
		retn
_print_error	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1100h
; COMDAT (pick any)
		public ??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@
; `string'
??_C@_0BF@HFMCBPGH@?4?2crypto?2ui?2ui_lib?4c?$AA@ db '.\crypto\ui\ui_lib.c',0
					; DATA XREF: _UI_add_error_string+Eo
					; _UI_add_error_string+2Co ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1118h
; COMDAT (pick any)
		public ??_C@_06IEAFMNNH@Enter?5?$AA@
; `string'
??_C@_06IEAFMNNH@Enter?5?$AA@ dd 65746E45h ; DATA XREF:	_UI_construct_prompt:loc_23Dr
word_111C	dw 2072h		; DATA XREF: _UI_construct_prompt+52r
byte_111E	db 0			; DATA XREF: _UI_construct_prompt+5Er
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1120h
; COMDAT (pick any)
		public ??_C@_05POFHKGEO@?5for?5?$AA@
; `string'
??_C@_05POFHKGEO@?5for?5?$AA@ dd 726F6620h ; DATA XREF:	_UI_construct_prompt+67r
word_1124	dw 20h			; DATA XREF: _UI_construct_prompt+70r
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1128h
; COMDAT (pick any)
		public ??_C@_02DPKJAMEF@?$CFd?$AA@
; `string'
??_C@_02DPKJAMEF@?$CFd?$AA@ db 25h, 64h, 0 ; DATA XREF:	_UI_set_result+101o
					; _UI_set_result+115o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 112Ch
; COMDAT (pick any)
		public ??_C@_0M@MCBMLIEP@?5characters?$AA@
; `string'
??_C@_0M@MCBMLIEP@?5characters?$AA@ db ' characters',0 ; DATA XREF: _UI_set_result+143o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1138h
; COMDAT (pick any)
		public ??_C@_04MKEOLIJC@?5to?5?$AA@
; `string'
??_C@_04MKEOLIJC@?5to?5?$AA@ db	' to ',0 ; DATA XREF: _UI_set_result+14Do
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1140h
; COMDAT (pick any)
		public ??_C@_0BC@FIPJHCII@You?5must?5type?5in?5?$AA@
; `string'
??_C@_0BC@FIPJHCII@You?5must?5type?5in?5?$AA@ db 'You must type in ',0
					; DATA XREF: _UI_set_result+157o
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; char *__cdecl	_strchr(const char *Str, int Val)
		extrn __imp__strchr:near ; CODE	XREF: _UI_set_result+8Bp
					; _UI_set_result+9Bp ...
		extrn _sk_num:near	; CODE XREF: _UI_get0_result+2Dp
					; _UI_process+3Fp ...
		extrn _sk_value:near	; CODE XREF: _UI_get0_result+5Ap
					; _UI_process+5Bp ...
		extrn _sk_new_null:near	; CODE XREF: _UI_add_error_string+69p
					; _UI_add_info_string+69p ...
		extrn _sk_pop_free:near	; CODE XREF: _UI_free+11p
		extrn _sk_push:near	; CODE XREF: _UI_add_error_string+9Dp
					; _UI_add_info_string+9Dp ...
		extrn _CRYPTO_get_ex_new_index:near ; CODE XREF: _UI_get_ex_new_index+16p
		extrn _CRYPTO_new_ex_data:near ; CODE XREF: _UI_new+62p
					; _UI_new_method+6Ap
		extrn _CRYPTO_free_ex_data:near	; CODE XREF: _UI_free+1Dp
		extrn _CRYPTO_set_ex_data:near ; CODE XREF: _UI_set_ex_data+5j
		extrn _CRYPTO_get_ex_data:near ; CODE XREF: _UI_get_ex_data+5j
		extrn _CRYPTO_malloc:near ; CODE XREF: _UI_add_error_string+33p
					; _UI_add_info_string+33p ...
		extrn _CRYPTO_free:near	; CODE XREF: _UI_destroy_method+7p
					; _UI_destroy_method+13p ...
		extrn _BUF_strdup:near	; CODE XREF: _UI_create_method+31p
					; _UI_dup_error_string+Cp ...
		extrn _BUF_strlcpy:near	; CODE XREF: _UI_construct_prompt+EAp
					; _UI_set_result+1B6p
		extrn _BUF_strlcat:near	; CODE XREF: _UI_construct_prompt+F2p
					; _UI_construct_prompt+105p ...
		extrn _BIO_snprintf:near ; CODE	XREF: _UI_set_result+109p
					; _UI_set_result+11Dp
		extrn _ERR_put_error:near ; CODE XREF: _UI_add_error_string+19p
					; _UI_add_info_string+19p ...
		extrn _ERR_print_errors_cb:near	; CODE XREF: _UI_process+30p
		extrn _ERR_add_error_data:near ; CODE XREF: _UI_set_result+15Ep
		extrn _UI_OpenSSL:near	; CODE XREF: _UI_get_default_method+9p
					; _UI_new+3Ap ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _UI_construct_prompt+40p
					; _UI_construct_prompt+95p ...
		extrn __chkstk:near	; CODE XREF: _UI_construct_prompt+5p
					; _UI_set_result+5p ...
		extrn ___security_cookie:near ;	DATA XREF: _UI_construct_prompt+Ar
					; _UI_set_result+Ar


		end
