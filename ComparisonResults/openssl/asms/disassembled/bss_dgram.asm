;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	D9D1332EFAD222C3FEA6D64044CC8F45
; Input	CRC32 :	5A1B1544

; File Name   :	C:\compspace\Diff\openssl\obj\bss_dgram.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl dgram_write(int, char *buf, int len)
_dgram_write	proc near		; CODE XREF: _dgram_puts+1Fp
					; DATA XREF: .data:000006A8o

arg_0		= dword	ptr  4
buf		= dword	ptr  8
len		= dword	ptr  0Ch

		push	ebx
		push	esi
		push	edi
		mov	edi, [esp+0Ch+arg_0]
		push	0		; iError
		mov	ebx, [edi+20h]
		call	dword ptr ds:__imp__WSASetLastError@4 ;	WSASetLastError(x)
		cmp	dword ptr [ebx+1Ch], 0
		jz	short loc_2D
		push	0		; flags
		push	[esp+10h+len]	; len
		push	[esp+14h+buf]	; buf
		push	dword ptr [edi+1Ch] ; s
		call	dword ptr ds:__imp__send@16 ; send(x,x,x,x)
		jmp	short loc_5C
; ---------------------------------------------------------------------------

loc_2D:					; CODE XREF: _dgram_write+16j
		movzx	ecx, word ptr [ebx]
		mov	eax, 1Ch
		cmp	ecx, 2
		jnz	short loc_3F
		lea	eax, [ecx+0Eh]
		jmp	short loc_47
; ---------------------------------------------------------------------------

loc_3F:					; CODE XREF: _dgram_write+38j
		cmp	ecx, 17h
		mov	edx, eax
		cmovz	eax, edx

loc_47:					; CODE XREF: _dgram_write+3Dj
		push	eax		; tolen
		push	ebx		; to
		push	0		; flags
		push	[esp+18h+len]	; len
		push	[esp+1Ch+buf]	; buf
		push	dword ptr [edi+1Ch] ; s
		call	dword ptr ds:__imp__sendto@24 ;	sendto(x,x,x,x,x,x)

loc_5C:					; CODE XREF: _dgram_write+2Bj
		push	0Fh
		push	edi
		mov	esi, eax
		call	_BIO_clear_flags
		add	esp, 8
		test	esi, esi
		jg	short loc_BD
		jz	short loc_74
		cmp	esi, 0FFFFFFFFh
		jnz	short loc_BD

loc_74:					; CODE XREF: _dgram_write+6Dj
		call	dword ptr ds:__imp__WSAGetLastError@0 ;	WSAGetLastError()
		cmp	eax, 70h ; 'p'
		jg	short loc_96
		jz	short loc_A9
		cmp	eax, 4
		jz	short loc_A9
		cmp	eax, 0Bh
		jz	short loc_A9
		cmp	eax, 67h ; 'g'
		jz	short loc_A9
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_96:					; CODE XREF: _dgram_write+7Dj
		sub	eax, 86h ; '†'
		jz	short loc_A9
		sub	eax, 6
		jz	short loc_A9
		sub	eax, 26A7h
		jnz	short loc_BD

loc_A9:					; CODE XREF: _dgram_write+7Fj
					; _dgram_write+84j ...
		push	0Ah
		push	edi
		call	_BIO_set_flags
		add	esp, 8
		call	dword ptr ds:__imp__WSAGetLastError@0 ;	WSAGetLastError()
		mov	[ebx+20h], eax

loc_BD:					; CODE XREF: _dgram_write+6Bj
					; _dgram_write+72j ...
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebx
		retn
_dgram_write	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl dgram_read(char optval, char *buf, int len)
_dgram_read	proc near		; DATA XREF: .data:000006ACo

fromlen		= dword	ptr -24h
from		= sockaddr ptr -20h
var_10		= qword	ptr -10h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
optval		= byte ptr  4
buf		= dword	ptr  8
len		= dword	ptr  0Ch

		mov	eax, 24h ; '$'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+24h+var_4], eax
		push	ebx
		push	esi
		mov	esi, dword ptr [esp+2Ch+optval]
		push	edi
		mov	edi, [esp+30h+buf]
		mov	[esp+30h+fromlen], 1Ch
		mov	ebx, [esi+20h]
		test	edi, edi
		jz	loc_1A3
		push	0		; iError
		call	dword ptr ds:__imp__WSASetLastError@4 ;	WSASetLastError(x)
		xorps	xmm0, xmm0
		mov	[esp+30h+var_8], 0
		push	esi
		movups	xmmword	ptr [esp+34h+from.sa_family], xmm0
		movq	[esp+34h+var_10], xmm0
		call	_dgram_adjust_rcv_timeout
		add	esp, 4
		lea	eax, [esp+30h+fromlen]
		push	eax		; fromlen
		lea	eax, [esp+34h+from]
		push	eax		; from
		push	0		; flags
		push	[esp+3Ch+len]	; len
		push	edi		; buf
		push	dword ptr [esi+1Ch] ; s
		call	dword ptr ds:__imp__recvfrom@24	; recvfrom(x,x,x,x,x,x)
		cmp	dword ptr [ebx+1Ch], 0
		mov	edi, eax
		jnz	short loc_156
		test	edi, edi
		js	short loc_156
		lea	eax, [esp+30h+from]
		push	eax
		push	0
		push	2Ch ; ','
		push	esi
		call	_BIO_ctrl
		add	esp, 10h

loc_156:				; CODE XREF: _dgram_read+7Aj
					; _dgram_read+7Ej
		push	0Fh
		push	esi
		call	_BIO_clear_flags
		add	esp, 8
		test	edi, edi
		jns	short loc_186
		push	edi
		call	_BIO_dgram_should_retry
		add	esp, 4
		test	eax, eax
		jz	short loc_186
		push	9
		push	esi
		call	_BIO_set_flags
		add	esp, 8
		call	dword ptr ds:__imp__WSAGetLastError@0 ;	WSAGetLastError()
		mov	[ebx+20h], eax

loc_186:				; CODE XREF: _dgram_read+9Fj
					; _dgram_read+ACj
		push	esi		; optval
		call	_dgram_reset_rcv_timeout
		add	esp, 4
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [esp+24h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 24h
		retn
; ---------------------------------------------------------------------------

loc_1A3:				; CODE XREF: _dgram_read+2Dj
		mov	ecx, [esp+30h+var_4]
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 24h
		retn
_dgram_read	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1B8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl dgram_puts(int, char *buf)
_dgram_puts	proc near		; DATA XREF: .data:000006B0o

arg_0		= dword	ptr  4
buf		= dword	ptr  8

		mov	edx, [esp+buf]
		mov	eax, edx
		push	esi
		lea	esi, [eax+1]
		nop	word ptr [eax+eax+00h]

loc_1C8:				; CODE XREF: _dgram_puts+15j
		mov	cl, [eax]
		inc	eax
		test	cl, cl
		jnz	short loc_1C8
		sub	eax, esi
		push	eax		; len
		push	edx		; buf
		push	[esp+0Ch+arg_0]	; int
		call	_dgram_write
		add	esp, 0Ch
		pop	esi
		retn
_dgram_puts	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1E4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl dgram_ctrl(char optval, char, size_t Size, void *Dst)
_dgram_ctrl	proc near		; DATA XREF: .data:000006B8o

var_4		= byte ptr -4
optval		= byte ptr  4
arg_4		= byte ptr  8
Size		= dword	ptr  0Ch
Dst		= dword	ptr  10h

		mov	eax, 4
		call	__chkstk
		mov	eax, dword ptr [esp+4+arg_4]
		push	ebx
		mov	ebx, dword ptr [esp+8+optval]
		dec	eax
		mov	dword ptr [esp+8+var_4], 0
		push	esi
		push	edi
		mov	edx, [ebx+20h]
		mov	edi, 1
		cmp	eax, 68h ; 'h'  ; switch 105 cases
		ja	$LN79		; jumptable 0000021A default case
		movzx	eax, ds:$LN81[eax]
		jmp	ds:$LN91[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN18:					; CODE XREF: _dgram_ctrl+36j
					; DATA XREF: .text$mn:$LN91o
		push	ebx		; jumptable 0000021A case 103
		call	_dgram_clear
		mov	eax, [esp+14h+Dst]
		add	esp, 4
		mov	eax, [eax]
		mov	[ebx+1Ch], eax
		mov	eax, [esp+10h+Size]
		mov	[ebx+10h], eax
		mov	eax, edi
		mov	[ebx+0Ch], edi
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$LN19:					; CODE XREF: _dgram_ctrl+36j
					; DATA XREF: .text$mn:$LN91o
		cmp	dword ptr [ebx+0Ch], 0 ; jumptable 0000021A case 104
		jz	loc_3CF
		mov	ecx, [esp+10h+Dst]
		test	ecx, ecx
		jz	short loc_25B
		mov	eax, [ebx+1Ch]
		mov	[ecx], eax

loc_25B:				; CODE XREF: _dgram_ctrl+70j
		mov	edi, [ebx+1Ch]
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$LN23:					; CODE XREF: _dgram_ctrl+36j
					; DATA XREF: .text$mn:$LN91o
		mov	edi, [ebx+10h]	; jumptable 0000021A case 7
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$LN24:					; CODE XREF: _dgram_ctrl+36j
					; DATA XREF: .text$mn:$LN91o
		mov	eax, [esp+10h+Size] ; jumptable	0000021A case 8
		mov	[ebx+10h], eax
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$LN33:					; CODE XREF: _dgram_ctrl+36j
					; DATA XREF: .text$mn:$LN91o
		push	edx		; jumptable 0000021A case 46
		call	_dgram_get_mtu_overhead
		mov	edi, eax
		add	esp, 4
		movzx	eax, word ptr [edx]
		neg	edi
		sub	eax, 2
		jz	short loc_2A4
		sub	eax, 15h
		jnz	short loc_2A4
		add	edi, 500h
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_2A4:				; CODE XREF: _dgram_ctrl+ACj
					; _dgram_ctrl+B1j
		add	edi, 240h
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$LN37:					; CODE XREF: _dgram_ctrl+36j
					; DATA XREF: .text$mn:$LN91o
		mov	eax, [edx+24h]	; jumptable 0000021A case 40
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$LN38:					; CODE XREF: _dgram_ctrl+36j
					; DATA XREF: .text$mn:$LN91o
		mov	edi, [esp+10h+Size] ; jumptable	0000021A case 41
		mov	eax, edi
		mov	[edx+24h], edi
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$LN39:					; CODE XREF: _dgram_ctrl+36j
					; DATA XREF: .text$mn:$LN91o
		mov	eax, [esp+10h+Dst] ; jumptable 0000021A	case 31
		test	eax, eax
		jz	short loc_304
		mov	[edx+1Ch], edi

loc_2D2:				; CODE XREF: _dgram_ctrl+17Ej
		movzx	ecx, word ptr [eax]
		movups	xmm0, xmmword ptr [eax]
		movups	xmmword	ptr [edx], xmm0
		sub	ecx, 2
		jz	$LN2		; jumptable 0000021A cases 10,11,38
		sub	ecx, 15h
		jnz	$LN2		; jumptable 0000021A cases 10,11,38
		movq	xmm0, qword ptr	[eax+10h]
		movq	qword ptr [edx+10h], xmm0
		mov	eax, [eax+18h]
		mov	[edx+18h], eax
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_304:				; CODE XREF: _dgram_ctrl+E9j
		mov	dword ptr [edx+1Ch], 0
		xorps	xmm0, xmm0
		mov	eax, edi
		pop	edi
		movups	xmmword	ptr [edx], xmm0
		pop	esi
		movq	qword ptr [edx+10h], xmm0
		mov	dword ptr [edx+18h], 0
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$LN45:					; CODE XREF: _dgram_ctrl+36j
					; DATA XREF: .text$mn:$LN91o
		movzx	eax, word ptr [edx] ; jumptable	0000021A case 45
		sub	eax, 2
		jz	short loc_336
		sub	eax, 15h
		mov	eax, 1Ch
		jz	short loc_33B

loc_336:				; CODE XREF: _dgram_ctrl+146j
		mov	eax, 10h

loc_33B:				; CODE XREF: _dgram_ctrl+150j
		mov	edi, [esp+10h+Size]
		test	edi, edi
		jz	short loc_347
		cmp	edi, eax
		jle	short loc_349

loc_347:				; CODE XREF: _dgram_ctrl+15Dj
		mov	edi, eax

loc_349:				; CODE XREF: _dgram_ctrl+161j
		push	edi		; Size
		push	edx		; Src
		push	[esp+18h+Dst]	; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$LN51:					; CODE XREF: _dgram_ctrl+36j
					; DATA XREF: .text$mn:$LN91o
		mov	eax, [esp+10h+Dst] ; jumptable 0000021A	cases 30,43
		jmp	loc_2D2
; ---------------------------------------------------------------------------

$LN55:					; CODE XREF: _dgram_ctrl+36j
					; DATA XREF: .text$mn:$LN91o
		mov	ecx, [esp+10h+Dst] ; jumptable 0000021A	case 44
		mov	eax, [ecx]
		mov	[edx+28h], eax
		mov	eax, [ecx+4]
		mov	[edx+2Ch], eax
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$LN56:					; CODE XREF: _dgram_ctrl+36j
					; DATA XREF: .text$mn:$LN91o
		mov	esi, [esp+10h+Dst] ; jumptable 0000021A	case 32
		mov	eax, 10624DD3h
		push	4		; optlen
		imul	dword ptr [esi+4]
		imul	eax, [esi], 3E8h
		sar	edx, 6
		mov	ecx, edx
		shr	ecx, 1Fh
		add	ecx, edx
		add	ecx, eax
		lea	eax, [esp+14h+optval]
		push	eax		; optval
		push	1006h		; optname

loc_3A7:				; CODE XREF: _dgram_ctrl+298j
		push	0FFFFh		; level
		push	dword ptr [ebx+1Ch] ; s
		mov	dword ptr [esp+24h+optval], ecx
		call	dword ptr ds:__imp__setsockopt@20 ; setsockopt(x,x,x,x,x)
		test	eax, eax

loc_3BB:				; CODE XREF: _dgram_ctrl+316j
					; _dgram_ctrl+333j
		jns	$LN2		; jumptable 0000021A cases 10,11,38
		push	offset ??_C@_0L@CKHNIFCM@setsockopt?$AA@ ; "setsockopt"
		call	dword ptr ds:__imp__perror
		add	esp, 4

loc_3CF:				; CODE XREF: _dgram_ctrl+64j
					; _dgram_ctrl+2F8j
		or	edi, 0FFFFFFFFh
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$LN58:					; CODE XREF: _dgram_ctrl+36j
					; DATA XREF: .text$mn:$LN91o
		lea	eax, [esp+10h+optval] ;	jumptable 0000021A case	33
		push	eax		; optlen
		lea	eax, [esp+14h+arg_4]
		push	eax		; optval
		push	1006h		; optname

loc_3E8:				; CODE XREF: _dgram_ctrl+2ACj
		push	0FFFFh		; level
		push	dword ptr [ebx+1Ch] ; s
		mov	dword ptr [esp+24h+optval], 4
		call	dword ptr ds:__imp__getsockopt@20 ; getsockopt(x,x,x,x,x)
		test	eax, eax
		jns	short loc_41A
		push	offset ??_C@_0L@DEFCDCGF@getsockopt?$AA@ ; "getsockopt"
		call	dword ptr ds:__imp__perror
		add	esp, 4
		or	edi, 0FFFFFFFFh
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_41A:				; CODE XREF: _dgram_ctrl+21Cj
		mov	esi, dword ptr [esp+10h+arg_4]
		mov	eax, 10624DD3h
		mov	ecx, [esp+10h+Dst]
		mov	edi, 8
		imul	esi
		sar	edx, 6
		mov	eax, edx
		shr	eax, 1Fh
		add	eax, edx
		mov	[ecx], eax
		imul	eax, 3E8h
		sub	esi, eax
		imul	eax, esi, 3E8h
		mov	[ecx+4], eax
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$LN61:					; CODE XREF: _dgram_ctrl+36j
					; DATA XREF: .text$mn:$LN91o
		mov	esi, [esp+10h+Dst] ; jumptable 0000021A	case 34
		mov	eax, 10624DD3h
		push	4
		imul	dword ptr [esi+4]
		imul	eax, [esi], 3E8h
		sar	edx, 6
		mov	ecx, edx
		shr	ecx, 1Fh
		add	ecx, edx
		add	ecx, eax
		lea	eax, [esp+14h+optval]
		push	eax
		push	1005h
		jmp	loc_3A7
; ---------------------------------------------------------------------------

$LN63:					; CODE XREF: _dgram_ctrl+36j
					; DATA XREF: .text$mn:$LN91o
		lea	eax, [esp+10h+optval] ;	jumptable 0000021A case	35
		push	eax
		lea	eax, [esp+14h+arg_4]
		push	eax
		push	1005h
		jmp	loc_3E8
; ---------------------------------------------------------------------------

$LN66:					; CODE XREF: _dgram_ctrl+36j
					; DATA XREF: .text$mn:$LN91o
		cmp	dword ptr [edx+20h], 274Ch ; jumptable 0000021A	cases 36,37
		jnz	$LN79		; jumptable 0000021A default case
		mov	eax, edi
		mov	dword ptr [edx+20h], 0
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$LN69:					; CODE XREF: _dgram_ctrl+36j
					; DATA XREF: .text$mn:$LN91o
		cmp	dword ptr [edx+20h], 73h ; 's' ; jumptable 0000021A case 42
		jnz	short $LN79	; jumptable 0000021A default case
		mov	eax, edi
		mov	dword ptr [edx+20h], 0
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$LN72:					; CODE XREF: _dgram_ctrl+36j
					; DATA XREF: .text$mn:$LN91o
		xor	eax, eax	; jumptable 0000021A case 47
		cmp	[esp+10h+Size],	eax
		setnz	al
		mov	dword ptr [esp+10h+var_4], eax
		movzx	eax, word ptr [edx]
		sub	eax, 2
		jz	short loc_4FF
		sub	eax, 15h
		jnz	loc_3CF
		push	4		; optlen
		lea	eax, [esp+14h+var_4]
		push	eax		; optval
		push	0Eh		; optname
		push	29h ; ')'       ; level
		push	dword ptr [ebx+1Ch] ; s
		call	dword ptr ds:__imp__setsockopt@20 ; setsockopt(x,x,x,x,x)
		mov	edi, eax
		test	edi, edi
		jmp	loc_3BB
; ---------------------------------------------------------------------------

loc_4FF:				; CODE XREF: _dgram_ctrl+2F3j
		push	4		; optlen
		lea	eax, [esp+14h+var_4]
		push	eax		; optval
		push	0Eh		; optname
		push	0		; level
		push	dword ptr [ebx+1Ch] ; s
		call	dword ptr ds:__imp__setsockopt@20 ; setsockopt(x,x,x,x,x)
		mov	edi, eax

loc_515:				; DATA XREF: .data:_methods_dgrampo
		test	edi, edi
		jmp	loc_3BB
; ---------------------------------------------------------------------------

$LN78:					; CODE XREF: _dgram_ctrl+36j
					; DATA XREF: .text$mn:$LN91o
		push	edx		; jumptable 0000021A case 48
		call	_dgram_get_mtu_overhead
		add	esp, 4
		mov	edi, eax
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

$LN79:					; CODE XREF: _dgram_ctrl+29j
					; _dgram_ctrl+36j ...
		xor	edi, edi	; jumptable 0000021A default case

$LN2:					; CODE XREF: _dgram_ctrl+36j
					; _dgram_ctrl+FAj ...
		mov	eax, edi	; jumptable 0000021A cases 10,11,38
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
_dgram_ctrl	endp

; ---------------------------------------------------------------------------
		align 4
$LN91		dd offset $LN79, offset	$LN23, offset $LN24, offset $LN2
					; DATA XREF: _dgram_ctrl+36r
		dd offset $LN51, offset	$LN39, offset $LN56, offset $LN58 ; jump table for switch statement
		dd offset $LN61, offset	$LN63, offset $LN66, offset $LN37
		dd offset $LN38, offset	$LN69, offset $LN55, offset $LN45
		dd offset $LN33, offset	$LN72, offset $LN78, offset $LN18
		dd offset $LN19, offset	$LN79
$LN81		db	0,   15h,     0,   15h ; DATA XREF: _dgram_ctrl+2Fr
		db    15h,   15h,   15h,     1 ; indirect table	for switch statement
		db	2,     0,     3,     3
		db	0,   15h,   15h,   15h
		db    15h,   15h,   15h,   15h
		db    15h,   15h,   15h,   15h
		db    15h,   15h,   15h,   15h
		db    15h,   15h,     4,     5
		db	6,     7,     8,     9
		db    0Ah,   0Ah,     3,     0
		db    0Bh,   0Ch,   0Dh,     4
		db    0Eh,   0Fh,   10h,   11h
		db    12h,   15h,   15h,   15h
		db    15h,   15h,   15h,   15h
		db    15h,   15h,   15h,   15h
		db    15h,   15h,   15h,   15h
		db    15h,   15h,   15h,   15h
		db    15h,   15h,   15h,   15h
		db    15h,   15h,   15h,   15h
		db    15h,   15h,   15h,   15h
		db    15h,   15h,   15h,   15h
		db    15h,   15h,   15h,   15h
		db    15h,   15h,   15h,   15h
		db    15h,   15h,   15h,   15h
		db    15h,   15h,   15h,   15h
		db    15h,   15h,   15h,   13h
		db    14h
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5FCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_dgram_new	proc near		; DATA XREF: .data:000006BCo

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		push	0E1h ; 'á'
		push	offset ??_C@_0BJ@CIFLONIM@?4?2crypto?2bio?2bss_dgram?4c?$AA@ ; ".\\crypto\\bio\\bss_dgram.c"
		push	38h ; '8'
		mov	dword ptr [esi+0Ch], 0
		mov	dword ptr [esi+1Ch], 0
		call	_CRYPTO_malloc
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jnz	short loc_62D
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_62D:				; CODE XREF: _dgram_new+2Cj
		push	38h ; '8'       ; Size
		push	0		; Val
		push	edi		; Dst
		call	_memset
		add	esp, 0Ch
		mov	[esi+20h], edi
		mov	dword ptr [esi+14h], 0
		mov	eax, 1
		pop	edi
		pop	esi
		retn
_dgram_new	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 64Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_dgram_free	proc near		; DATA XREF: .data:000006C0o

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jnz	short loc_659
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_659:				; CODE XREF: _dgram_free+7j
		cmp	dword ptr [esi+10h], 0
		jz	short loc_687
		cmp	dword ptr [esi+0Ch], 0
		jz	short loc_679
		push	2		; how
		push	dword ptr [esi+1Ch] ; s
		call	dword ptr ds:__imp__shutdown@8 ; shutdown(x,x)
		push	dword ptr [esi+1Ch] ; s
		call	dword ptr ds:__imp__closesocket@4 ; closesocket(x)

loc_679:				; CODE XREF: _dgram_free+17j
		mov	dword ptr [esi+0Ch], 0
		mov	dword ptr [esi+14h], 0

loc_687:				; CODE XREF: _dgram_free+11j
		mov	eax, [esi+20h]
		test	eax, eax
		jz	short loc_697
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_697:				; CODE XREF: _dgram_free+40j
		mov	eax, 1
		pop	esi
		retn
_dgram_free	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 6A0h
_methods_dgramp	dd offset loc_515	; DATA XREF: _BIO_new_dgram+1o
					; _BIO_s_datagramo
		dd offset ??_C@_0BA@KGHEGOOF@datagram?5socket?$AA@ ; "datagram socket"
		dd offset _dgram_write
		dd offset _dgram_read
		dd offset _dgram_puts
		align 8
		dd offset _dgram_ctrl
		dd offset _dgram_new
		dd offset _dgram_free
		align 8
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 6C8h
; COMDAT (pick any)
		public ??_C@_0BA@KGHEGOOF@datagram?5socket?$AA@
; `string'
??_C@_0BA@KGHEGOOF@datagram?5socket?$AA@ db 'datagram socket',0 ; DATA XREF: .data:000006A4o
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6D8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_dgram_non_fatal_error
_BIO_dgram_non_fatal_error proc	near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		cmp	eax, 70h ; 'p'
		jg	short loc_6F2
		jz	short loc_708
		cmp	eax, 4
		jz	short loc_708
		cmp	eax, 0Bh
		jz	short loc_708
		cmp	eax, 67h ; 'g'
		jmp	short loc_703
; ---------------------------------------------------------------------------

loc_6F2:				; CODE XREF: _BIO_dgram_non_fatal_error+7j
		sub	eax, 86h ; '†'
		jz	short loc_708
		sub	eax, 6
		jz	short loc_708
		sub	eax, 26A7h

loc_703:				; CODE XREF: _BIO_dgram_non_fatal_error+18j
		jz	short loc_708
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_708:				; CODE XREF: _BIO_dgram_non_fatal_error+9j
					; _BIO_dgram_non_fatal_error+Ej ...
		mov	eax, 1
		retn
_BIO_dgram_non_fatal_error endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 710h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_BIO_dgram_should_retry	proc near	; CODE XREF: _dgram_read+A2p

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short loc_720
		cmp	eax, 0FFFFFFFFh
		jz	short loc_720

loc_71D:				; CODE XREF: _BIO_dgram_should_retry:loc_74Dj
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_720:				; CODE XREF: _BIO_dgram_should_retry+6j
					; _BIO_dgram_should_retry+Bj
		call	dword ptr ds:__imp__WSAGetLastError@0 ;	WSAGetLastError()
		cmp	eax, 70h ; 'p'
		jg	short loc_73C
		jz	short loc_74F
		cmp	eax, 4
		jz	short loc_74F
		cmp	eax, 0Bh
		jz	short loc_74F
		cmp	eax, 67h ; 'g'
		jmp	short loc_74D
; ---------------------------------------------------------------------------

loc_73C:				; CODE XREF: _BIO_dgram_should_retry+19j
		sub	eax, 86h ; '†'
		jz	short loc_74F
		sub	eax, 6
		jz	short loc_74F
		sub	eax, 26A7h

loc_74D:				; CODE XREF: _BIO_dgram_should_retry+2Aj
		jnz	short loc_71D

loc_74F:				; CODE XREF: _BIO_dgram_should_retry+1Bj
					; _BIO_dgram_should_retry+20j ...
		mov	eax, 1
		retn
_BIO_dgram_should_retry	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 758h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_new_dgram
_BIO_new_dgram	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		push	offset _methods_dgramp
		call	_BIO_new
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jnz	short loc_76E
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_76E:				; CODE XREF: _BIO_new_dgram+12j
		push	[esp+4+arg_0]
		push	[esp+8+arg_4]
		push	68h ; 'h'
		push	esi
		call	_BIO_int_ctrl
		add	esp, 10h
		mov	eax, esi
		pop	esi
		retn
_BIO_new_dgram	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 788h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_s_datagram
_BIO_s_datagram	proc near
		mov	eax, offset _methods_dgramp
		retn
_BIO_s_datagram	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 790h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_dgram_adjust_rcv_timeout proc near	; CODE XREF: _dgram_read+52p

optval		= byte ptr -24h
optlen		= dword	ptr -20h
FileTime	= _FILETIME ptr	-1Ch
SystemTime	= _SYSTEMTIME ptr -14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 24h ; '$'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+24h+var_4], eax
		push	ebx
		mov	ebx, [esp+28h+arg_0]
		push	edi
		mov	[esp+2Ch+optlen], 0
		mov	edi, [ebx+20h]
		cmp	dword ptr [edi+28h], 0
		jg	short loc_7C6
		cmp	dword ptr [edi+2Ch], 0
		jle	loc_90C

loc_7C6:				; CODE XREF: _dgram_adjust_rcv_timeout+2Aj
		lea	eax, [esp+2Ch+optlen]
		mov	[esp+2Ch+optlen], 4
		push	eax		; optlen
		lea	eax, [esp+30h+optval]
		push	eax		; optval
		push	1006h		; optname
		push	0FFFFh		; level
		push	dword ptr [ebx+1Ch] ; s
		call	dword ptr ds:__imp__getsockopt@20 ; getsockopt(x,x,x,x,x)
		test	eax, eax
		jns	short loc_7FF
		push	offset ??_C@_0L@DEFCDCGF@getsockopt?$AA@ ; "getsockopt"
		call	dword ptr ds:__imp__perror
		add	esp, 4
		jmp	short loc_828
; ---------------------------------------------------------------------------

loc_7FF:				; CODE XREF: _dgram_adjust_rcv_timeout+5Dj
		mov	ecx, dword ptr [esp+2Ch+optval]
		mov	eax, 10624DD3h
		imul	ecx
		sar	edx, 6
		mov	eax, edx
		shr	eax, 1Fh
		add	eax, edx
		mov	[edi+30h], eax
		imul	eax, 3E8h
		sub	ecx, eax
		imul	eax, ecx, 3E8h
		mov	[edi+34h], eax

loc_828:				; CODE XREF: _dgram_adjust_rcv_timeout+6Dj
		push	esi
		lea	eax, [esp+30h+SystemTime]
		push	eax		; lpSystemTime
		call	dword ptr ds:__imp__GetSystemTime@4 ; GetSystemTime(x)
		lea	eax, [esp+30h+FileTime]
		push	eax		; lpFileTime
		lea	eax, [esp+34h+SystemTime]
		push	eax		; lpSystemTime
		call	dword ptr ds:__imp__SystemTimeToFileTime@8 ; SystemTimeToFileTime(x,x)
		mov	esi, [esp+30h+FileTime.dwLowDateTime]
		mov	eax, [esp+30h+FileTime.dwHighDateTime]
		add	esi, 2AC18000h
		push	0
		push	989680h
		adc	eax, 0FE624E21h
		push	eax
		push	esi
		call	__aulldiv
		mov	ecx, [edi+28h]
		mov	dword ptr [esp+30h+optval], eax
		imul	eax, 989680h
		sub	esi, eax
		mov	eax, 66666667h
		imul	esi
		sar	edx, 2
		mov	esi, edx
		shr	esi, 1Fh
		add	esi, edx
		mov	edx, [edi+2Ch]
		cmp	edx, esi
		jge	short loc_898
		mov	eax, 0F4240h
		sub	eax, esi
		add	edx, eax
		dec	ecx
		jmp	short loc_89A
; ---------------------------------------------------------------------------

loc_898:				; CODE XREF: _dgram_adjust_rcv_timeout+FAj
		sub	edx, esi

loc_89A:				; CODE XREF: _dgram_adjust_rcv_timeout+106j
		mov	eax, dword ptr [esp+30h+optval]
		cmp	ecx, eax
		jge	short loc_8A9
		xor	ecx, ecx
		lea	edx, [ecx+1]
		jmp	short loc_8AB
; ---------------------------------------------------------------------------

loc_8A9:				; CODE XREF: _dgram_adjust_rcv_timeout+110j
		sub	ecx, eax

loc_8AB:				; CODE XREF: _dgram_adjust_rcv_timeout+117j
		mov	esi, [edi+30h]
		test	esi, esi
		jnz	short loc_8B7
		cmp	[edi+34h], esi
		jz	short loc_8C2

loc_8B7:				; CODE XREF: _dgram_adjust_rcv_timeout+120j
		cmp	esi, ecx
		jg	short loc_8C2
		jnz	short loc_90B
		cmp	[edi+34h], edx
		jl	short loc_90B

loc_8C2:				; CODE XREF: _dgram_adjust_rcv_timeout+125j
					; _dgram_adjust_rcv_timeout+129j
		mov	eax, 10624DD3h
		imul	ecx, 3E8h
		imul	edx
		push	4		; optlen
		sar	edx, 6
		mov	eax, edx
		add	ecx, edx
		shr	eax, 1Fh
		add	eax, ecx
		mov	dword ptr [esp+34h+optval], eax
		lea	eax, [esp+34h+optval]
		push	eax		; optval
		push	1006h		; optname
		push	0FFFFh		; level
		push	dword ptr [ebx+1Ch] ; s
		call	dword ptr ds:__imp__setsockopt@20 ; setsockopt(x,x,x,x,x)
		test	eax, eax
		jns	short loc_90B
		push	offset ??_C@_0L@CKHNIFCM@setsockopt?$AA@ ; "setsockopt"
		call	dword ptr ds:__imp__perror
		add	esp, 4

loc_90B:				; CODE XREF: _dgram_adjust_rcv_timeout+12Bj
					; _dgram_adjust_rcv_timeout+130j ...
		pop	esi

loc_90C:				; CODE XREF: _dgram_adjust_rcv_timeout+30j
		mov	ecx, [esp+2Ch+var_4]
		pop	edi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 24h
		retn
_dgram_adjust_rcv_timeout endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 920h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_dgram_clear	proc near		; CODE XREF: _dgram_ctrl+3Ep

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jnz	short loc_92D
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_92D:				; CODE XREF: _dgram_clear+7j
		cmp	dword ptr [esi+10h], 0
		jz	short loc_95B
		cmp	dword ptr [esi+0Ch], 0
		jz	short loc_94D
		push	2		; how
		push	dword ptr [esi+1Ch] ; s
		call	dword ptr ds:__imp__shutdown@8 ; shutdown(x,x)
		push	dword ptr [esi+1Ch] ; s
		call	dword ptr ds:__imp__closesocket@4 ; closesocket(x)

loc_94D:				; CODE XREF: _dgram_clear+17j
		mov	dword ptr [esi+0Ch], 0
		mov	dword ptr [esi+14h], 0

loc_95B:				; CODE XREF: _dgram_clear+11j
		mov	eax, 1
		pop	esi
		retn
_dgram_clear	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 964h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_dgram_get_mtu_overhead	proc near	; CODE XREF: _dgram_ctrl+9Ap
					; _dgram_ctrl+339p

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		movzx	eax, word ptr [eax]
		sub	eax, 2
		jz	short loc_97A
		sub	eax, 15h
		mov	eax, 30h ; '0'
		jz	short locret_97F

loc_97A:				; CODE XREF: _dgram_get_mtu_overhead+Aj
		mov	eax, 1Ch

locret_97F:				; CODE XREF: _dgram_get_mtu_overhead+14j
		retn
_dgram_get_mtu_overhead	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 980h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl dgram_reset_rcv_timeout(char optval)
_dgram_reset_rcv_timeout proc near	; CODE XREF: _dgram_read+C3p

optval		= byte ptr  4

		push	esi
		push	edi
		mov	edi, dword ptr [esp+8+optval]
		mov	esi, [edi+20h]
		cmp	dword ptr [esi+28h], 0
		jg	short loc_995
		cmp	dword ptr [esi+2Ch], 0
		jle	short loc_9E0

loc_995:				; CODE XREF: _dgram_reset_rcv_timeout+Dj
		mov	eax, 10624DD3h
		imul	dword ptr [esi+34h]
		imul	eax, [esi+30h],	3E8h
		push	4		; optlen
		sar	edx, 6
		mov	ecx, edx
		shr	ecx, 1Fh
		add	ecx, edx
		add	ecx, eax
		lea	eax, [esp+0Ch+optval]
		push	eax		; optval
		push	1006h		; optname
		push	0FFFFh		; level
		push	dword ptr [edi+1Ch] ; s
		mov	dword ptr [esp+1Ch+optval], ecx
		call	dword ptr ds:__imp__setsockopt@20 ; setsockopt(x,x,x,x,x)
		test	eax, eax
		jns	short loc_9E0
		push	offset ??_C@_0L@CKHNIFCM@setsockopt?$AA@ ; "setsockopt"
		call	dword ptr ds:__imp__perror
		add	esp, 4

loc_9E0:				; CODE XREF: _dgram_reset_rcv_timeout+13j
					; _dgram_reset_rcv_timeout+50j
		pop	edi
		pop	esi
		retn
_dgram_reset_rcv_timeout endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 9E4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_get_current_time proc near

FileTime	= _FILETIME ptr	-1Ch
SystemTime	= _SYSTEMTIME ptr -14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 1Ch
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+1Ch+var_4], eax
		push	esi
		push	edi
		mov	edi, [esp+24h+arg_0]
		lea	eax, [esp+24h+SystemTime]
		push	eax		; lpSystemTime
		call	dword ptr ds:__imp__GetSystemTime@4 ; GetSystemTime(x)
		lea	eax, [esp+24h+FileTime]
		push	eax		; lpFileTime
		lea	eax, [esp+28h+SystemTime]
		push	eax		; lpSystemTime
		call	dword ptr ds:__imp__SystemTimeToFileTime@8 ; SystemTimeToFileTime(x,x)
		mov	esi, [esp+24h+FileTime.dwLowDateTime]
		mov	eax, [esp+24h+FileTime.dwHighDateTime]
		add	esi, 2AC18000h
		push	0
		push	989680h
		adc	eax, 0FE624E21h
		push	eax
		push	esi
		call	__aulldiv
		mov	[edi], eax
		imul	eax, 989680h
		mov	ecx, [esp+24h+var_4]
		sub	esi, eax
		mov	eax, 66666667h
		imul	esi
		sar	edx, 2
		mov	eax, edx
		shr	eax, 1Fh
		add	eax, edx
		mov	[edi+4], eax
		pop	edi
		pop	esi
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 1Ch
		retn
_get_current_time endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A6Ch
; COMDAT (pick any)
		public ??_C@_0BJ@CIFLONIM@?4?2crypto?2bio?2bss_dgram?4c?$AA@
; `string'
??_C@_0BJ@CIFLONIM@?4?2crypto?2bio?2bss_dgram?4c?$AA@ db '.\crypto\bio\bss_dgram.c',0
					; DATA XREF: _dgram_new+Bo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A88h
; COMDAT (pick any)
		public ??_C@_0L@DEFCDCGF@getsockopt?$AA@
; char `string'[]
??_C@_0L@DEFCDCGF@getsockopt?$AA@ db 'getsockopt',0 ; DATA XREF: _dgram_ctrl+21Eo
					; _dgram_adjust_rcv_timeout+5Fo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A94h
; COMDAT (pick any)
		public ??_C@_0L@CKHNIFCM@setsockopt?$AA@
; char `string'[]
??_C@_0L@CKHNIFCM@setsockopt?$AA@ db 'setsockopt',0 ; DATA XREF: _dgram_ctrl+1DDo
					; _dgram_adjust_rcv_timeout+16Do ...
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; void __cdecl _perror(const char *ErrMsg)
		extrn __imp__perror:near ; CODE	XREF: _dgram_ctrl+1E2p
					; _dgram_ctrl+223p ...
; void __stdcall GetSystemTime(LPSYSTEMTIME lpSystemTime)
		extrn __imp__GetSystemTime@4:near ; CODE XREF: _dgram_adjust_rcv_timeout+9Ep
					; _get_current_time+20p
					; DATA XREF: ...
; BOOL __stdcall SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime)
		extrn __imp__SystemTimeToFileTime@8:near
					; CODE XREF: _dgram_adjust_rcv_timeout+AEp
					; _get_current_time+30p
					; DATA XREF: ...
; int __stdcall	closesocket(SOCKET s)
		extrn __imp__closesocket@4:near	; CODE XREF: _dgram_free+27p
					; _dgram_clear+27p
					; DATA XREF: ...
; int __stdcall	getsockopt(SOCKET s, int level,	int optname, char *optval, int *optlen)
		extrn __imp__getsockopt@20:near	; CODE XREF: _dgram_ctrl+214p
					; _dgram_adjust_rcv_timeout+55p
					; DATA XREF: ...
; int __stdcall	recvfrom(SOCKET	s, char	*buf, int len, int flags, struct sockaddr *from, int *fromlen)
		extrn __imp__recvfrom@24:near ;	CODE XREF: _dgram_read+6Ep
					; DATA XREF: _dgram_read+6Er
; int __stdcall	send(SOCKET s, const char *buf,	int len, int flags)
		extrn __imp__send@16:near ; CODE XREF: _dgram_write+25p
					; DATA XREF: _dgram_write+25r
; int __stdcall	sendto(SOCKET s, const char *buf, int len, int flags, const struct sockaddr *to, int tolen)
		extrn __imp__sendto@24:near ; CODE XREF: _dgram_write+56p
					; DATA XREF: _dgram_write+56r
; int __stdcall	setsockopt(SOCKET s, int level,	int optname, const char	*optval, int optlen)
		extrn __imp__setsockopt@20:near	; CODE XREF: _dgram_ctrl+1CFp
					; _dgram_ctrl+30Cp ...
; int __stdcall	shutdown(SOCKET	s, int how)
		extrn __imp__shutdown@8:near ; CODE XREF: _dgram_free+1Ep
					; _dgram_clear+1Ep
					; DATA XREF: ...
; void __stdcall WSASetLastError(int iError)
		extrn __imp__WSASetLastError@4:near ; CODE XREF: _dgram_write+Cp
					; _dgram_read+35p
					; DATA XREF: ...
; int __stdcall	WSAGetLastError()
		extrn __imp__WSAGetLastError@0:near ; CODE XREF: _dgram_write:loc_74p
					; _dgram_write+B4p ...
		extrn _CRYPTO_malloc:near ; CODE XREF: _dgram_new+20p
		extrn _CRYPTO_free:near	; CODE XREF: _dgram_free+43p
		extrn _BIO_set_flags:near ; CODE XREF: _dgram_write+ACp
					; _dgram_read+B1p
		extrn _BIO_clear_flags:near ; CODE XREF: _dgram_write+61p
					; _dgram_read+95p
		extrn _BIO_new:near	; CODE XREF: _BIO_new_dgram+6p
		extrn _BIO_ctrl:near	; CODE XREF: _dgram_read+8Ap
		extrn _BIO_int_ctrl:near ; CODE	XREF: _BIO_new_dgram+21p
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _dgram_read+D6p
					; _dgram_read+EAp ...
		extrn __aulldiv:near	; CODE XREF: _dgram_adjust_rcv_timeout+D0p
					; _get_current_time+52p
		extrn __chkstk:near	; CODE XREF: _dgram_read+5p
					; _dgram_ctrl+5p ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _dgram_ctrl+16Bp
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _dgram_new+36p
		extrn ___security_cookie:near ;	DATA XREF: _dgram_read+Ar
					; _dgram_adjust_rcv_timeout+Ar	...


		end
