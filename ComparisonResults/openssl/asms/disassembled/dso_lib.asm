;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	B0A762F2250B434F272C309311549A7E
; Input	CRC32 :	06BFD6E1

; File Name   :	C:\compspace\Diff\openssl\obj\dso_lib.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
_default_DSO_meth dd ?			; DATA XREF: _DSO_get_default_methodr
					; _DSO_global_lookupr ...
_bss		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _DSO_bind_func
_DSO_bind_func	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jz	short loc_5E
		mov	edx, [esp+arg_4]
		test	edx, edx
		jz	short loc_5E
		mov	eax, [ecx]
		mov	eax, [eax+10h]
		test	eax, eax
		jnz	short loc_38
		push	111h
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	6Ch ; 'l'
		push	6Ch ; 'l'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_38:					; CODE XREF: _DSO_bind_func+17j
		push	edx
		push	ecx
		call	eax
		add	esp, 8
		test	eax, eax
		jnz	short locret_78
		push	115h
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	6Ah ; 'j'
		push	6Ch ; 'l'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_5E:					; CODE XREF: _DSO_bind_func+6j
					; _DSO_bind_func+Ej
		push	10Dh
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	43h ; 'C'
		push	6Ch ; 'l'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax

locret_78:				; CODE XREF: _DSO_bind_func+3Dj
		retn
_DSO_bind_func	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _DSO_bind_var
_DSO_bind_var	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jz	short loc_D6
		mov	edx, [esp+arg_4]
		test	edx, edx
		jz	short loc_D6
		mov	eax, [ecx]
		mov	eax, [eax+0Ch]
		test	eax, eax
		jnz	short loc_B0
		push	0FDh ; '˝'
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	6Ch ; 'l'
		push	6Dh ; 'm'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_B0:					; CODE XREF: _DSO_bind_var+17j
		push	edx
		push	ecx
		call	eax
		add	esp, 8
		test	eax, eax
		jnz	short locret_F0
		push	101h
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	6Ah ; 'j'
		push	6Dh ; 'm'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_D6:					; CODE XREF: _DSO_bind_var+6j
					; _DSO_bind_var+Ej
		push	0F9h ; '˘'
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	43h ; 'C'
		push	6Dh ; 'm'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax

locret_F0:				; CODE XREF: _DSO_bind_var+3Dj
		retn
_DSO_bind_var	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _DSO_convert_filename
_DSO_convert_filename proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jnz	short loc_117
		push	187h
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	43h ; 'C'
		push	7Eh ; '~'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_117:				; CODE XREF: _DSO_convert_filename+6j
		push	esi
		mov	esi, [esp+4+arg_4]
		test	esi, esi
		jnz	short loc_143
		mov	esi, [ecx+20h]
		test	esi, esi
		jnz	short loc_143
		push	18Dh
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	6Fh ; 'o'
		push	7Eh ; '~'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_143:				; CODE XREF: _DSO_convert_filename+2Aj
					; _DSO_convert_filename+31j
		test	byte ptr [ecx+0Ch], 1
		push	edi
		jnz	short loc_167
		mov	eax, [ecx+18h]
		test	eax, eax
		jnz	short loc_15A
		mov	eax, [ecx]
		mov	eax, [eax+18h]
		test	eax, eax
		jz	short loc_167

loc_15A:				; CODE XREF: _DSO_convert_filename+5Bj
		push	esi
		push	ecx
		call	eax
		mov	edi, eax
		add	esp, 8
		test	edi, edi
		jnz	short loc_1CB

loc_167:				; CODE XREF: _DSO_convert_filename+54j
					; _DSO_convert_filename+64j
		mov	ecx, esi
		lea	edx, [ecx+1]

loc_16C:				; CODE XREF: _DSO_convert_filename+7Dj
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_16C
		sub	ecx, edx
		push	197h
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		lea	eax, [ecx+1]
		push	eax
		call	_CRYPTO_malloc
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jnz	short loc_1AE
		push	199h
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	41h ; 'A'
		push	7Eh ; '~'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1AE:				; CODE XREF: _DSO_convert_filename+9Bj
		mov	ecx, esi
		lea	edx, [ecx+1]
		nop

loc_1B4:				; CODE XREF: _DSO_convert_filename+C5j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_1B4
		sub	ecx, edx
		lea	eax, [ecx+1]
		push	eax
		push	esi
		push	edi
		call	_BUF_strlcpy
		add	esp, 0Ch

loc_1CB:				; CODE XREF: _DSO_convert_filename+71j
		mov	eax, edi
		pop	edi
		pop	esi
		retn
_DSO_convert_filename endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1D0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _DSO_ctrl
_DSO_ctrl	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jnz	short loc_1F4
		push	128h
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	43h ; 'C'
		push	6Eh ; 'n'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_1F4:				; CODE XREF: _DSO_ctrl+6j
		mov	edx, [esp+arg_4]
		mov	eax, edx
		sub	eax, 1
		jz	short loc_250
		sub	eax, 1
		jz	short loc_246
		sub	eax, 1
		jz	short loc_23C
		mov	eax, [ecx]
		test	eax, eax
		jz	short loc_220
		mov	eax, [eax+14h]
		test	eax, eax
		jz	short loc_220
		mov	[esp+arg_4], edx
		mov	[esp+arg_0], ecx
		jmp	eax
; ---------------------------------------------------------------------------

loc_220:				; CODE XREF: _DSO_ctrl+3Dj
					; _DSO_ctrl+44j
		push	13Ch
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	6Ch ; 'l'
		push	6Eh ; 'n'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_23C:				; CODE XREF: _DSO_ctrl+37j
		mov	eax, [esp+arg_8]
		or	[ecx+0Ch], eax
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_246:				; CODE XREF: _DSO_ctrl+32j
		mov	eax, [esp+arg_8]
		mov	[ecx+0Ch], eax
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_250:				; CODE XREF: _DSO_ctrl+2Dj
		mov	eax, [ecx+0Ch]
		retn
_DSO_ctrl	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 254h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _DSO_flags
_DSO_flags	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jnz	short loc_25D
		retn
; ---------------------------------------------------------------------------

loc_25D:				; CODE XREF: _DSO_flags+6j
		mov	eax, [eax+0Ch]
		retn
_DSO_flags	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 264h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _DSO_free
_DSO_free	proc near		; CODE XREF: _DSO_load+D1p

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jnz	short loc_289
		push	89h ; 'â'
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	43h ; 'C'
		push	6Fh ; 'o'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_289:				; CODE XREF: _DSO_free+7j
		push	8Dh ; 'ç'
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	1Ch
		lea	eax, [esi+8]
		push	0FFFFFFFFh
		push	eax
		call	_CRYPTO_add_lock
		add	esp, 14h
		test	eax, eax
		jg	loc_33D
		mov	eax, [esi]
		mov	eax, [eax+8]
		test	eax, eax
		jz	short loc_2DA
		push	esi
		call	eax
		add	esp, 4
		test	eax, eax
		jnz	short loc_2DA
		push	9Bh ; 'õ'
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	6Bh ; 'k'
		push	6Fh ; 'o'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_2DA:				; CODE XREF: _DSO_free+4Ej
					; _DSO_free+58j
		mov	eax, [esi]
		mov	eax, [eax+24h]
		test	eax, eax
		jz	short loc_309
		push	esi
		call	eax
		add	esp, 4
		test	eax, eax
		jnz	short loc_309
		push	0A0h ; '†'
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	66h ; 'f'
		push	6Fh ; 'o'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_309:				; CODE XREF: _DSO_free+7Dj
					; _DSO_free+87j
		push	dword ptr [esi+4]
		call	_sk_free
		mov	eax, [esi+20h]
		add	esp, 4
		test	eax, eax
		jz	short loc_324
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_324:				; CODE XREF: _DSO_free+B5j
		mov	eax, [esi+24h]
		test	eax, eax
		jz	short loc_334
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_334:				; CODE XREF: _DSO_free+C5j
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_33D:				; CODE XREF: _DSO_free+41j
		mov	eax, 1
		pop	esi
		retn
_DSO_free	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 344h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _DSO_get_default_method
_DSO_get_default_method	proc near
		mov	eax, ds:_default_DSO_meth
		retn
_DSO_get_default_method	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 34Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _DSO_get_filename
_DSO_get_filename proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jnz	short loc_36F
		push	152h
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	43h ; 'C'
		push	7Fh ; ''
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_36F:				; CODE XREF: _DSO_get_filename+6j
		mov	eax, [eax+20h]
		retn
_DSO_get_filename endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 374h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _DSO_get_loaded_filename
_DSO_get_loaded_filename proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jnz	short loc_39A
		push	1A4h
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	43h ; 'C'
		push	80h ; 'Ä'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_39A:				; CODE XREF: _DSO_get_loaded_filename+6j
		mov	eax, [eax+24h]
		retn
_DSO_get_loaded_filename endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3A0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _DSO_get_method
_DSO_get_method	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax]
		retn
_DSO_get_method	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3A8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _DSO_global_lookup
_DSO_global_lookup proc	near
		mov	eax, ds:_default_DSO_meth
		test	eax, eax
		jnz	short loc_3B6
		call	_DSO_METHOD_openssl

loc_3B6:				; CODE XREF: _DSO_global_lookup+7j
		mov	eax, [eax+2Ch]
		test	eax, eax
		jnz	short loc_3DB
		push	1BCh
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	6Ch ; 'l'
		push	8Bh ; 'ã'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_3DB:				; CODE XREF: _DSO_global_lookup+13j
		jmp	eax
_DSO_global_lookup endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3E0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _DSO_load
_DSO_load	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		xor	edi, edi
		test	esi, esi
		jnz	short loc_427
		push	[esp+8+arg_8]
		call	_DSO_new_method
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jnz	short loc_41B
		push	0C6h ; '∆'
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	41h ; 'A'
		push	70h ; 'p'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_41B:				; CODE XREF: _DSO_load+1Cj
		mov	eax, [esp+8+arg_C]
		mov	edi, 1
		mov	[esi+0Ch], eax

loc_427:				; CODE XREF: _DSO_load+Aj
		cmp	dword ptr [esi+20h], 0
		jz	short loc_43B
		push	0D3h ; '”'
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	6Eh ; 'n'
		jmp	short loc_4A0
; ---------------------------------------------------------------------------

loc_43B:				; CODE XREF: _DSO_load+4Bj
		mov	eax, [esp+8+arg_4]
		test	eax, eax
		jz	short loc_45F
		push	eax
		push	esi
		call	_DSO_set_filename
		add	esp, 8
		test	eax, eax
		jnz	short loc_45F
		push	0DCh ; '‹'
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	70h ; 'p'
		jmp	short loc_4A0
; ---------------------------------------------------------------------------

loc_45F:				; CODE XREF: _DSO_load+61j
					; _DSO_load+6Fj
		cmp	dword ptr [esi+20h], 0
		jnz	short loc_473
		push	0E1h ; '·'
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	6Fh ; 'o'
		jmp	short loc_4A0
; ---------------------------------------------------------------------------

loc_473:				; CODE XREF: _DSO_load+83j
		mov	eax, [esi]
		mov	eax, [eax+4]
		test	eax, eax
		jnz	short loc_48A
		push	0E5h ; 'Â'
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	6Ch ; 'l'
		jmp	short loc_4A0
; ---------------------------------------------------------------------------

loc_48A:				; CODE XREF: _DSO_load+9Aj
		push	esi
		call	eax
		add	esp, 4
		test	eax, eax
		jnz	short loc_4BE
		push	0E9h ; 'È'
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	67h ; 'g'

loc_4A0:				; CODE XREF: _DSO_load+59j
					; _DSO_load+7Dj ...
		push	70h ; 'p'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h

$err$27:
		test	edi, edi
		jz	short loc_4B9
		push	esi
		call	_DSO_free
		add	esp, 4

loc_4B9:				; CODE XREF: _DSO_load+CEj
		pop	edi
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_4BE:				; CODE XREF: _DSO_load+B2j
		pop	edi
		mov	eax, esi
		pop	esi
		retn
_DSO_load	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4C4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _DSO_merge
_DSO_merge	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		xor	edx, edx
		push	esi
		test	ecx, ecx
		jz	short loc_4FE
		mov	esi, [esp+4+arg_4]
		test	esi, esi
		jz	short loc_4FE
		test	byte ptr [ecx+0Ch], 1
		jnz	short loc_4FA
		mov	eax, [ecx+1Ch]
		test	eax, eax
		jnz	short loc_4ED
		mov	eax, [ecx]
		mov	eax, [eax+1Ch]
		test	eax, eax
		jz	short loc_4FA

loc_4ED:				; CODE XREF: _DSO_merge+1Ej
		push	[esp+4+arg_8]
		push	esi
		push	ecx
		call	eax
		mov	edx, eax
		add	esp, 0Ch

loc_4FA:				; CODE XREF: _DSO_merge+17j
					; _DSO_merge+27j
		mov	eax, edx
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_4FE:				; CODE XREF: _DSO_merge+9j
					; _DSO_merge+11j
		push	176h
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	43h ; 'C'
		push	84h ; 'Ñ'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
_DSO_merge	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 520h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _DSO_new
_DSO_new	proc near
		push	0
		call	_DSO_new_method
		add	esp, 4
		retn
_DSO_new	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 52Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _DSO_new_method
_DSO_new_method	proc near		; CODE XREF: _DSO_load+10p _DSO_new+2p

arg_0		= dword	ptr  4

		cmp	ds:_default_DSO_meth, 0
		jnz	short loc_53F
		call	_DSO_METHOD_openssl
		mov	ds:_default_DSO_meth, eax

loc_53F:				; CODE XREF: _DSO_new_method+7j
		push	esi
		push	6Ah ; 'j'
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	28h ; '('
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jnz	short loc_570
		push	6Ch ; 'l'
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	41h ; 'A'
		push	71h ; 'q'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_570:				; CODE XREF: _DSO_new_method+29j
		xorps	xmm0, xmm0
		movups	xmmword	ptr [esi], xmm0
		movups	xmmword	ptr [esi+10h], xmm0
		movq	qword ptr [esi+20h], xmm0
		call	_sk_new_null
		mov	[esi+4], eax
		test	eax, eax
		jnz	short loc_5AA
		push	73h ; 's'
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	41h ; 'A'
		push	71h ; 'q'
		push	25h ; '%'
		call	_ERR_put_error
		push	esi
		call	_CRYPTO_free
		add	esp, 18h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_5AA:				; CODE XREF: _DSO_new_method+5Dj
		mov	eax, [esp+4+arg_0]
		test	eax, eax
		mov	dword ptr [esi+8], 1
		cmovz	eax, ds:_default_DSO_meth
		mov	[esi], eax
		mov	eax, [eax+20h]
		test	eax, eax
		jz	short loc_5E4
		push	esi
		call	eax
		add	esp, 4
		test	eax, eax
		jnz	short loc_5E4
		push	dword ptr [esi+4]
		call	_sk_free
		push	esi
		call	_CRYPTO_free
		add	esp, 8
		xor	esi, esi

loc_5E4:				; CODE XREF: _DSO_new_method+99j
					; _DSO_new_method+A3j
		mov	eax, esi
		pop	esi
		retn
_DSO_new_method	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5E8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _DSO_pathbyaddr
_DSO_pathbyaddr	proc near
		mov	eax, ds:_default_DSO_meth
		test	eax, eax
		jnz	short loc_5F6
		call	_DSO_METHOD_openssl

loc_5F6:				; CODE XREF: _DSO_pathbyaddr+7j
		mov	eax, [eax+28h]
		test	eax, eax
		jnz	short loc_61C
		push	1B0h
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	6Ch ; 'l'
		push	8Ch ; 'å'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_61C:				; CODE XREF: _DSO_pathbyaddr+13j
		jmp	eax
_DSO_pathbyaddr	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 620h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _DSO_set_default_method
_DSO_set_default_method	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	ds:_default_DSO_meth, eax
		retn
_DSO_set_default_method	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 62Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _DSO_set_filename
_DSO_set_filename proc near		; CODE XREF: _DSO_load+65p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		test	esi, esi
		jz	loc_6F0
		mov	edi, [esp+8+arg_4]
		test	edi, edi
		jz	loc_6F0
		cmp	dword ptr [esi+24h], 0
		jz	short loc_66C
		push	161h
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	6Eh ; 'n'
		push	81h ; 'Å'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_66C:				; CODE XREF: _DSO_set_filename+1Ej
		mov	ecx, edi
		lea	edx, [ecx+1]

loc_671:				; CODE XREF: _DSO_set_filename+4Aj
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_671
		push	ebx
		sub	ecx, edx
		push	165h
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		lea	eax, [ecx+1]
		push	eax
		call	_CRYPTO_malloc
		mov	ebx, eax
		add	esp, 0Ch
		test	ebx, ebx
		jnz	short loc_6B8
		push	167h
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	41h ; 'A'
		push	81h ; 'Å'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	ebx
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_6B8:				; CODE XREF: _DSO_set_filename+69j
		mov	ecx, edi
		lea	edx, [ecx+1]

loc_6BD:				; CODE XREF: _DSO_set_filename+96j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_6BD
		sub	ecx, edx
		lea	eax, [ecx+1]
		push	eax
		push	edi
		push	ebx
		call	_BUF_strlcpy
		mov	eax, [esi+20h]
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_6E4
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_6E4:				; CODE XREF: _DSO_set_filename+ADj
		mov	[esi+20h], ebx
		mov	eax, 1
		pop	ebx
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_6F0:				; CODE XREF: _DSO_set_filename+8j
					; _DSO_set_filename+14j
		push	15Dh
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	43h ; 'C'
		push	81h ; 'Å'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
_DSO_set_filename endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 710h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _DSO_set_method
_DSO_set_method	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	eax, [edx]
		mov	[edx], ecx
		retn
_DSO_set_method	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 720h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _DSO_set_name_converter
_DSO_set_name_converter	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jnz	short loc_743
		push	146h
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	43h ; 'C'
		push	7Ah ; 'z'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_743:				; CODE XREF: _DSO_set_name_converter+6j
		mov	edx, [esp+arg_8]
		test	edx, edx
		jz	short loc_750
		mov	eax, [ecx+18h]
		mov	[edx], eax

loc_750:				; CODE XREF: _DSO_set_name_converter+29j
		mov	eax, [esp+arg_4]
		mov	[ecx+18h], eax
		mov	eax, 1
		retn
_DSO_set_name_converter	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 760h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _DSO_up_ref
_DSO_up_ref	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jnz	short loc_783
		push	0B6h ; '∂'
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	43h ; 'C'
		push	72h ; 'r'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_783:				; CODE XREF: _DSO_up_ref+6j
		push	0BAh ; '∫'
		push	offset ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ ; ".\\crypto\\dso\\dso_lib.c"
		push	1Ch
		add	eax, 8
		push	1
		push	eax
		call	_CRYPTO_add_lock
		add	esp, 14h
		mov	eax, 1
		retn
_DSO_up_ref	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 7A4h
; COMDAT (pick any)
		public ??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@
; `string'
??_C@_0BH@IMFGHBFJ@?4?2crypto?2dso?2dso_lib?4c?$AA@ db '.\crypto\dso\dso_lib.c',0
					; DATA XREF: _DSO_bind_func+1Eo
					; _DSO_bind_func+44o ...
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _sk_new_null:near	; CODE XREF: _DSO_new_method+53p
		extrn _sk_free:near	; CODE XREF: _DSO_free+A8p
					; _DSO_new_method+A8p
		extrn _CRYPTO_add_lock:near ; CODE XREF: _DSO_free+37p
					; _DSO_up_ref+35p
		extrn _CRYPTO_malloc:near ; CODE XREF: _DSO_convert_filename+8Fp
					; _DSO_new_method+1Dp ...
		extrn _CRYPTO_free:near	; CODE XREF: _DSO_free+B8p
					; _DSO_free+C8p ...
		extrn _BUF_strlcpy:near	; CODE XREF: _DSO_convert_filename+CFp
					; _DSO_set_filename+A0p
		extrn _ERR_put_error:near ; CODE XREF: _DSO_bind_func+29p
					; _DSO_bind_func+4Fp ...
		extrn _DSO_METHOD_openssl:near ; CODE XREF: _DSO_global_lookup+9p
					; _DSO_new_method+9p ...


		end
