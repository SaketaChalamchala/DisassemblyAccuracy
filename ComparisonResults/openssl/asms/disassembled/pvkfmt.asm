;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	4D91EEE6570DFD4C9871BB2824E3D062
; Input	CRC32 :	E8BCD951

; File Name   :	C:\compspace\Diff\openssl\obj\pvkfmt.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _b2i_PVK_bio
_b2i_PVK_bio	proc near

var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= byte ptr -1Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 30h ; '0'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+30h+var_4], eax
		mov	eax, [esp+30h+arg_4]
		push	ebx
		push	ebp
		mov	ebp, [esp+38h+arg_0]
		xor	ebx, ebx
		mov	[esp+38h+var_20], eax
		mov	eax, [esp+38h+arg_8]
		mov	[esp+38h+var_24], eax
		lea	eax, [esp+38h+var_1C]
		push	18h
		push	eax
		push	ebp
		call	_BIO_read
		add	esp, 0Ch
		cmp	eax, 18h
		jz	short loc_70
		push	2FBh
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	7Ch ; '|'
		push	80h ; 'Ä'
		push	9
		call	_ERR_put_error
		add	esp, 14h

loc_5D:					; CODE XREF: _b2i_PVK_bio+95j
		pop	ebp
		xor	eax, eax
		pop	ebx
		mov	ecx, [esp+30h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 30h
		retn
; ---------------------------------------------------------------------------

loc_70:					; CODE XREF: _b2i_PVK_bio+40j
		lea	eax, [esp+38h+var_1C]
		mov	[esp+38h+var_30], eax
		lea	eax, [esp+38h+var_2C]
		push	eax
		lea	eax, [esp+3Ch+var_28]
		push	eax
		push	0
		lea	eax, [esp+44h+var_30]
		push	18h
		push	eax
		call	_do_PVK_header
		add	esp, 14h
		test	eax, eax
		jz	short loc_5D
		push	esi
		push	edi
		mov	edi, [esp+40h+var_28]
		add	edi, [esp+40h+var_2C]
		push	303h
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	edi
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jnz	short loc_EA
		push	305h
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	41h ; 'A'
		push	80h ; 'Ä'
		push	9
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+30h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 30h
		retn
; ---------------------------------------------------------------------------

loc_EA:					; CODE XREF: _b2i_PVK_bio+B8j
		push	edi
		push	esi
		push	ebp
		mov	[esp+4Ch+var_30], esi
		call	_BIO_read
		add	esp, 0Ch
		cmp	eax, edi
		jz	short loc_117
		push	30Ah
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	7Ch ; '|'
		push	80h ; 'Ä'
		push	9
		call	_ERR_put_error
		jmp	short loc_133
; ---------------------------------------------------------------------------

loc_117:				; CODE XREF: _b2i_PVK_bio+FBj
		push	[esp+40h+var_24]
		lea	eax, [esp+44h+var_30]
		push	[esp+44h+var_20]
		push	[esp+48h+var_2C]
		push	[esp+4Ch+var_28]
		push	eax
		call	_do_PVK_body
		mov	ebx, eax

loc_133:				; CODE XREF: _b2i_PVK_bio+115j
		add	esp, 14h

$err$13:
		push	edi
		push	esi
		call	_OPENSSL_cleanse
		push	esi
		call	_CRYPTO_free
		mov	ecx, [esp+4Ch+var_4]
		add	esp, 0Ch
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 30h
		retn
_b2i_PVK_bio	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 15Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _b2i_PrivateKey
_b2i_PrivateKey	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	0
		push	[esp+4+arg_4]
		push	[esp+8+arg_0]
		call	_do_b2i
		add	esp, 0Ch
		retn
_b2i_PrivateKey	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 170h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _b2i_PrivateKey_bio
_b2i_PrivateKey_bio proc near

arg_0		= dword	ptr  4

		push	0
		push	[esp+4+arg_0]
		call	_do_b2i_bio
		add	esp, 8
		retn
_b2i_PrivateKey_bio endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 180h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _b2i_PublicKey
_b2i_PublicKey	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	1
		push	[esp+4+arg_4]
		push	[esp+8+arg_0]
		call	_do_b2i
		add	esp, 0Ch
		retn
_b2i_PublicKey	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 194h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _b2i_PublicKey_bio
_b2i_PublicKey_bio proc	near

arg_0		= dword	ptr  4

		push	1
		push	[esp+4+arg_0]
		call	_do_b2i_bio
		add	esp, 8
		retn
_b2i_PublicKey_bio endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1A4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_b2i_dss	proc near		; CODE XREF: _do_b2i+DDp
					; _do_b2i_bio+13Bp

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, 4
		call	__chkstk
		mov	eax, [esp+4+arg_0]
		push	ebx
		push	ebp
		mov	ebp, [esp+0Ch+arg_8]
		mov	eax, [eax]
		push	esi
		push	edi
		lea	ebp, [ebp+7]
		mov	[esp+14h+var_4], eax
		xor	edi, edi
		shr	ebp, 3
		call	_DSA_new
		mov	esi, eax
		call	_EVP_PKEY_new
		mov	ebx, eax
		test	esi, esi
		jz	short $memerr$19
		test	ebx, ebx
		jz	short $memerr$19
		lea	eax, [esi+0Ch]
		push	eax
		lea	eax, [esp+18h+var_4]
		push	ebp
		push	eax
		call	_read_lebn
		add	esp, 0Ch
		test	eax, eax
		jz	short $memerr$19
		lea	eax, [esi+10h]
		push	eax
		lea	eax, [esp+18h+var_4]
		push	14h
		push	eax
		call	_read_lebn
		add	esp, 0Ch
		test	eax, eax
		jz	short $memerr$19
		lea	eax, [esi+14h]
		push	eax
		lea	eax, [esp+18h+var_4]
		push	ebp
		push	eax
		call	_read_lebn
		add	esp, 0Ch
		test	eax, eax
		jz	short $memerr$19
		cmp	[esp+14h+arg_C], edi
		jz	short loc_288
		lea	eax, [esi+18h]
		push	eax
		lea	eax, [esp+18h+var_4]
		push	ebp
		push	eax
		call	_read_lebn
		add	esp, 0Ch
		test	eax, eax
		jnz	loc_2DC

$memerr$19:				; CODE XREF: _b2i_dss+34j _b2i_dss+38j ...
		push	155h
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	41h ; 'A'
		push	7Fh ; ''
		push	9
		call	_ERR_put_error
		add	esp, 14h
		test	esi, esi
		jz	short loc_266
		push	esi
		call	_DSA_free
		add	esp, 4

loc_266:				; CODE XREF: _b2i_dss+B7j
		test	ebx, ebx
		jz	short loc_273
		push	ebx
		call	_EVP_PKEY_free
		add	esp, 4

loc_273:				; CODE XREF: _b2i_dss+C4j
		test	edi, edi
		jz	short loc_280
		push	edi
		call	_BN_CTX_free
		add	esp, 4

loc_280:				; CODE XREF: _b2i_dss+D1j
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_288:				; CODE XREF: _b2i_dss+81j
		lea	ebp, [esi+1Ch]
		push	ebp
		lea	eax, [esp+18h+var_4]
		push	14h
		push	eax
		call	_read_lebn
		add	esp, 0Ch
		test	eax, eax
		jz	short $memerr$19
		call	_BN_new
		mov	[esi+18h], eax
		test	eax, eax
		jz	short $memerr$19
		call	_BN_CTX_new
		mov	edi, eax
		test	edi, edi
		jz	short $memerr$19
		push	edi
		push	dword ptr [esi+0Ch]
		push	dword ptr [ebp+0]
		push	dword ptr [esi+14h]
		push	dword ptr [esi+18h]
		call	_BN_mod_exp
		add	esp, 14h
		test	eax, eax
		jz	$memerr$19
		push	edi
		call	_BN_CTX_free
		add	esp, 4

loc_2DC:				; CODE XREF: _b2i_dss+97j
		push	esi
		push	ebx
		call	_EVP_PKEY_set1_DSA
		push	esi
		call	_DSA_free
		mov	ecx, [esp+20h+arg_0]
		add	esp, 0Ch
		mov	eax, [esp+14h+var_4]
		pop	edi
		pop	esi
		mov	[ecx], eax
		mov	eax, ebx
		pop	ebp
		pop	ebx
		pop	ecx
		retn
_b2i_dss	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 300h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_b2i_rsa	proc near		; CODE XREF: _do_b2i:loc_CC7p
					; _do_b2i_bio:loc_E1Ap

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, 0Ch
		call	__chkstk
		mov	eax, [esp+0Ch+arg_0]
		push	ebx
		push	ebp
		push	esi
		mov	esi, [eax]
		mov	eax, [esp+18h+arg_8]
		push	edi
		mov	[esp+1Ch+var_C], esi
		lea	ecx, [eax+7]
		shr	ecx, 3
		lea	ebx, [eax+0Fh]
		mov	[esp+1Ch+var_4], ecx
		shr	ebx, 4
		call	_RSA_new
		mov	edi, eax
		call	_EVP_PKEY_new
		mov	ebp, eax
		test	edi, edi
		jz	$memerr$20
		test	ebp, ebp
		jz	$memerr$20
		call	_BN_new
		mov	[esp+1Ch+var_8], eax
		mov	[edi+14h], eax
		test	eax, eax
		jz	$memerr$20
		mov	edx, [esp+1Ch+var_C]
		movzx	esi, byte ptr [esi]
		movzx	ecx, byte ptr [edx+1]
		movzx	eax, byte ptr [edx+2]
		shl	eax, 10h
		shl	ecx, 8
		or	esi, ecx
		or	esi, eax
		movzx	eax, byte ptr [edx+3]
		shl	eax, 18h
		or	esi, eax
		lea	eax, [edx+4]
		push	esi
		push	[esp+20h+var_8]
		mov	[esp+24h+arg_8], eax
		call	_BN_set_word
		add	esp, 8
		test	eax, eax
		jz	$memerr$20
		mov	esi, [esp+1Ch+var_4]
		lea	eax, [edi+10h]
		push	eax
		lea	eax, [esp+20h+arg_8]
		push	esi
		push	eax
		call	_read_lebn
		add	esp, 0Ch
		test	eax, eax
		jz	$memerr$20
		cmp	[esp+1Ch+arg_C], 0
		jnz	loc_44D
		lea	eax, [edi+1Ch]
		push	eax
		lea	eax, [esp+20h+arg_8]
		push	ebx
		push	eax
		call	_read_lebn
		add	esp, 0Ch
		test	eax, eax
		jz	$memerr$20
		lea	eax, [edi+20h]
		push	eax
		lea	eax, [esp+20h+arg_8]
		push	ebx
		push	eax
		call	_read_lebn
		add	esp, 0Ch
		test	eax, eax
		jz	short $memerr$20
		lea	eax, [edi+24h]
		push	eax
		lea	eax, [esp+20h+arg_8]
		push	ebx
		push	eax
		call	_read_lebn
		add	esp, 0Ch
		test	eax, eax
		jz	short $memerr$20
		lea	eax, [edi+28h]
		push	eax
		lea	eax, [esp+20h+arg_8]
		push	ebx
		push	eax
		call	_read_lebn
		add	esp, 0Ch
		test	eax, eax
		jz	short $memerr$20
		lea	eax, [edi+2Ch]
		push	eax
		lea	eax, [esp+20h+arg_8]
		push	ebx
		push	eax
		call	_read_lebn
		add	esp, 0Ch
		test	eax, eax
		jz	short $memerr$20
		lea	eax, [edi+18h]
		push	eax
		lea	eax, [esp+20h+arg_8]
		push	esi
		push	eax
		call	_read_lebn
		add	esp, 0Ch
		test	eax, eax
		jz	short $memerr$20

loc_44D:				; CODE XREF: _b2i_rsa+BFj
		push	edi
		push	ebp
		call	_EVP_PKEY_set1_RSA
		push	edi
		call	_RSA_free
		mov	ecx, [esp+28h+arg_0]
		add	esp, 0Ch
		mov	eax, [esp+1Ch+arg_8]
		pop	edi
		pop	esi
		mov	[ecx], eax
		mov	eax, ebp
		pop	ebp
		pop	ebx
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

$memerr$20:				; CODE XREF: _b2i_rsa+3Cj _b2i_rsa+44j ...
		push	187h
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	41h ; 'A'
		push	81h ; 'Å'
		push	9
		call	_ERR_put_error
		add	esp, 14h
		test	edi, edi
		jz	short loc_499
		push	edi
		call	_RSA_free
		add	esp, 4

loc_499:				; CODE XREF: _b2i_rsa+18Ej
		test	ebp, ebp
		jz	short loc_4A6
		push	ebp
		call	_EVP_PKEY_free
		add	esp, 4

loc_4A6:				; CODE XREF: _b2i_rsa+19Bj
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		add	esp, 0Ch
		retn
_b2i_rsa	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4B0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_blob_length	proc near		; CODE XREF: _do_b2i_bio+A5p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, [esp+arg_0]
		lea	ecx, [eax+7]
		shr	ecx, 3
		cmp	[esp+arg_4], 0
		jz	short loc_4D7
		cmp	[esp+arg_8], 0
		jz	short loc_4CF
		lea	eax, [ecx+16h]
		lea	eax, [ecx+eax*2]
		retn
; ---------------------------------------------------------------------------

loc_4CF:				; CODE XREF: _blob_length+16j
		lea	eax, ds:40h[ecx*2]
		retn
; ---------------------------------------------------------------------------

loc_4D7:				; CODE XREF: _blob_length+Fj
		cmp	[esp+arg_8], 0
		jz	short loc_4E2
		lea	eax, [ecx+4]
		retn
; ---------------------------------------------------------------------------

loc_4E2:				; CODE XREF: _blob_length+2Cj
		add	eax, 0Fh
		shr	eax, 4
		lea	eax, [eax+eax*4]
		lea	eax, [eax+ecx*2]
		add	eax, 4
		retn
_blob_length	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4F4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_check_bitlen_dsa proc near		; CODE XREF: _do_i2b+34p _i2b_PVK+7Dp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		push	esi
		mov	esi, [esp+8+arg_0]
		push	dword ptr [esi+0Ch]
		call	_BN_num_bits
		mov	ebx, eax
		add	esp, 4
		test	bl, 7
		jnz	short $badkey$10
		push	dword ptr [esi+10h]
		call	_BN_num_bits
		add	esp, 4
		cmp	eax, 0A0h ; '†'
		jnz	short $badkey$10
		push	dword ptr [esi+14h]
		call	_BN_num_bits
		add	esp, 4
		cmp	eax, ebx
		jg	short $badkey$10
		cmp	[esp+8+arg_4], 0
		jz	short loc_552
		push	dword ptr [esi+18h]
		call	_BN_num_bits
		add	esp, 4
		cmp	eax, ebx
		jg	short $badkey$10
		mov	eax, [esp+8+arg_8]
		pop	esi
		mov	dword ptr [eax], 31535344h
		mov	eax, ebx
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_552:				; CODE XREF: _check_bitlen_dsa+3Ej
		push	dword ptr [esi+1Ch]
		call	_BN_num_bits
		add	esp, 4
		cmp	eax, 0A0h ; '†'
		jg	short $badkey$10
		mov	eax, [esp+8+arg_8]
		pop	esi
		mov	dword ptr [eax], 32535344h
		mov	eax, ebx
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$badkey$10:				; CODE XREF: _check_bitlen_dsa+16j
					; _check_bitlen_dsa+28j ...
		push	21Bh
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	7Eh ; '~'
		push	82h ; 'Ç'
		push	9
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		pop	ebx
		retn
_check_bitlen_dsa endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 594h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_check_bitlen_rsa proc near		; CODE XREF: _do_i2b+52p _i2b_PVK+9Cp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		push	ebp
		push	esi
		mov	esi, [esp+0Ch+arg_0]
		push	edi
		push	dword ptr [esi+14h]
		call	_BN_num_bits
		add	esp, 4
		cmp	eax, 20h ; ' '
		jg	$badkey$11
		push	dword ptr [esi+10h]
		call	_BN_num_bits
		push	dword ptr [esi+10h]
		mov	ebx, eax
		call	_BN_num_bits
		push	dword ptr [esi+10h]
		add	eax, 7
		cdq
		and	edx, 7
		lea	ebp, [edx+eax]
		sar	ebp, 3
		call	_BN_num_bits
		add	esp, 0Ch
		lea	edi, [eax+0Fh]
		mov	eax, [esp+10h+arg_8]
		sar	edi, 4
		cmp	[esp+10h+arg_4], 0
		jz	short loc_5F8
		mov	dword ptr [eax], 31415352h

loc_5F1:				; CODE XREF: _check_bitlen_rsa+10Ej
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, ebx
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_5F8:				; CODE XREF: _check_bitlen_rsa+55j
		mov	dword ptr [eax], 32415352h
		push	dword ptr [esi+18h]
		call	_BN_num_bits
		add	eax, 7
		add	esp, 4
		cdq
		and	edx, 7
		add	eax, edx
		sar	eax, 3
		cmp	eax, ebp
		jg	$badkey$11
		push	dword ptr [esi+2Ch]
		call	_BN_num_bits
		add	eax, 7
		add	esp, 4
		cdq
		and	edx, 7
		add	eax, edx
		sar	eax, 3
		cmp	eax, edi
		jg	short $badkey$11
		push	dword ptr [esi+1Ch]
		call	_BN_num_bits
		add	eax, 7
		add	esp, 4
		cdq
		and	edx, 7
		add	eax, edx
		sar	eax, 3
		cmp	eax, edi
		jg	short $badkey$11
		push	dword ptr [esi+20h]
		call	_BN_num_bits
		add	eax, 7
		add	esp, 4
		cdq
		and	edx, 7
		add	eax, edx
		sar	eax, 3
		cmp	eax, edi
		jg	short $badkey$11
		push	dword ptr [esi+24h]
		call	_BN_num_bits
		add	eax, 7
		add	esp, 4
		cdq
		and	edx, 7
		add	eax, edx
		sar	eax, 3
		cmp	eax, edi
		jg	short $badkey$11
		push	dword ptr [esi+28h]
		call	_BN_num_bits
		add	eax, 7
		add	esp, 4
		cdq
		and	edx, 7
		add	eax, edx
		sar	eax, 3
		cmp	eax, edi
		jle	loc_5F1

$badkey$11:				; CODE XREF: _check_bitlen_rsa+16j
					; _check_bitlen_rsa+83j ...
		push	23Ah
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	7Eh ; '~'
		push	83h ; 'É'
		push	9
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_check_bitlen_rsa endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6CCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_derive_pvk_key	proc near		; CODE XREF: _do_PVK_body+119p
					; _i2b_PVK+28Dp

var_18		= byte ptr -18h
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	eax, 18h
		call	__chkstk
		push	esi
		lea	eax, [esp+1Ch+var_18]
		mov	esi, 1
		push	eax
		call	_EVP_MD_CTX_init
		add	esp, 4
		push	0
		call	_EVP_sha1
		push	eax
		lea	eax, [esp+24h+var_18]
		push	eax
		call	_EVP_DigestInit_ex
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_74B
		push	[esp+1Ch+arg_8]
		lea	eax, [esp+20h+var_18]
		push	[esp+20h+arg_4]
		push	eax
		call	_EVP_DigestUpdate
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_74B
		push	[esp+1Ch+arg_10]
		lea	eax, [esp+20h+var_18]
		push	[esp+20h+arg_C]
		push	eax
		call	_EVP_DigestUpdate
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_74B
		push	0
		push	[esp+20h+arg_0]
		lea	eax, [esp+24h+var_18]
		push	eax
		call	_EVP_DigestFinal_ex
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_74D

loc_74B:				; CODE XREF: _derive_pvk_key+34j
					; _derive_pvk_key+4Dj ...
		xor	esi, esi

loc_74D:				; CODE XREF: _derive_pvk_key+7Dj
		lea	eax, [esp+1Ch+var_18]
		push	eax
		call	_EVP_MD_CTX_cleanup
		add	esp, 4
		mov	eax, esi
		pop	esi
		add	esp, 18h
		retn
_derive_pvk_key	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 764h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_do_PVK_body	proc near		; CODE XREF: _b2i_PVK_bio+12Cp

var_4B8		= dword	ptr -4B8h
var_4B4		= dword	ptr -4B4h
var_4B0		= dword	ptr -4B0h
var_4AC		= dword	ptr -4ACh
var_4A8		= dword	ptr -4A8h
var_4A4		= byte ptr -4A4h
var_418		= byte ptr -418h
var_413		= qword	ptr -413h
var_40B		= word ptr -40Bh
var_409		= byte ptr -409h
var_404		= byte ptr -404h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	eax, 4B8h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+4B8h+var_4], eax
		mov	eax, [esp+4B8h+arg_0]
		mov	ecx, [esp+4B8h+arg_8]
		push	ebx
		push	ebp
		mov	ebp, [esp+4C0h+arg_4]
		xor	ebx, ebx
		push	esi
		mov	esi, [eax]
		lea	eax, [esp+4C4h+var_4A4]
		mov	[esp+4C4h+var_4A8], ecx
		mov	ecx, [esp+4C4h+arg_C]
		push	edi
		mov	[esp+4C8h+var_4B4], ecx
		xor	edi, edi
		mov	ecx, [esp+4C8h+arg_10]
		push	eax
		mov	[esp+4CCh+var_4B8], ebp
		mov	[esp+4CCh+var_4B0], ecx
		mov	[esp+4CCh+var_4AC], esi
		call	_EVP_CIPHER_CTX_init
		add	esp, 4
		test	ebp, ebp
		jz	loc_A3F
		push	[esp+4C8h+var_4B0]
		mov	eax, [esp+4CCh+var_4B4]
		push	edi
		push	400h
		test	eax, eax
		jz	short loc_7F0
		lea	ecx, [esp+4D4h+var_404]
		push	ecx
		call	eax
		jmp	short loc_7FD
; ---------------------------------------------------------------------------

loc_7F0:				; CODE XREF: _do_PVK_body+7Ej
		lea	eax, [esp+4D4h+var_404]
		push	eax
		call	_PEM_def_callback

loc_7FD:				; CODE XREF: _do_PVK_body+8Aj
		mov	ebp, eax
		add	esp, 10h
		test	ebp, ebp
		jg	short loc_826
		push	2BBh
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	68h ; 'h'
		push	87h ; 'á'
		push	9
		call	_ERR_put_error
		add	esp, 14h
		jmp	loc_A55
; ---------------------------------------------------------------------------

loc_826:				; CODE XREF: _do_PVK_body+A0j
		mov	eax, [esp+4C8h+var_4A8]
		push	2BEh
		add	eax, 8
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	eax
		call	_CRYPTO_malloc
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jnz	short loc_866
		push	2C0h
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	41h ; 'A'
		push	87h ; 'á'
		push	9
		call	_ERR_put_error
		add	esp, 14h
		jmp	loc_A55
; ---------------------------------------------------------------------------

loc_866:				; CODE XREF: _do_PVK_body+E0j
		push	ebp
		mov	ebp, [esp+4CCh+var_4B8]
		lea	eax, [esp+4CCh+var_404]
		push	eax
		push	ebp
		lea	eax, [esp+4D4h+var_418]
		push	esi
		push	eax
		call	_derive_pvk_key
		add	esp, 14h
		test	eax, eax
		jz	$err$32
		mov	eax, [esi+ebp]
		add	esi, ebp
		mov	[edi], eax
		mov	eax, [esi+4]
		add	esi, 8
		mov	[edi+4], eax
		mov	eax, [esp+4C8h+var_4A8]
		cmp	eax, 8
		jnb	short loc_8C6
		push	2CBh
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	7Dh ; '}'
		push	87h ; 'á'
		push	9
		call	_ERR_put_error
		add	esp, 14h
		jmp	$err$32
; ---------------------------------------------------------------------------

loc_8C6:				; CODE XREF: _do_PVK_body+140j
		add	eax, 0FFFFFFF8h
		lea	ebp, [edi+8]
		mov	[esp+4C8h+var_4AC], eax
		lea	eax, [esp+4C8h+var_418]
		push	0
		push	eax
		push	0
		mov	[esp+4D4h+var_4B0], ebp
		call	_EVP_rc4
		push	eax
		lea	eax, [esp+4D8h+var_4A4]
		push	eax
		call	_EVP_DecryptInit_ex
		add	esp, 14h
		test	eax, eax
		jz	loc_A55
		push	[esp+4C8h+var_4AC]
		lea	eax, [esp+4CCh+var_4B4]
		push	esi
		push	eax
		lea	eax, [esp+4D4h+var_4A4]
		push	ebp
		push	eax
		call	_EVP_DecryptUpdate
		add	esp, 14h
		test	eax, eax
		jz	loc_A55
		lea	eax, [esp+4C8h+var_4B4]
		push	eax
		mov	eax, [esp+4CCh+var_4B4]
		add	eax, ebp
		push	eax
		lea	eax, [esp+4D0h+var_4A4]
		push	eax
		call	_EVP_DecryptFinal_ex
		add	esp, 0Ch
		test	eax, eax
		jz	loc_A55
		lea	eax, [esp+4C8h+var_4B0]
		push	eax
		call	_read_ledword
		add	esp, 4
		cmp	eax, 32415352h
		jz	loc_A29
		cmp	eax, 32535344h
		jz	loc_A29
		push	0
		lea	eax, [esp+4CCh+var_418]
		mov	[esp+4CCh+var_4B0], ebp
		push	eax
		xorps	xmm0, xmm0
		mov	[esp+4D0h+var_40B], bx
		push	0
		movq	[esp+4D4h+var_413], xmm0
		mov	[esp+4D4h+var_409], bl
		call	_EVP_rc4
		push	eax
		lea	eax, [esp+4D8h+var_4A4]
		push	eax
		call	_EVP_DecryptInit_ex
		add	esp, 14h
		test	eax, eax
		jz	loc_A55
		lea	eax, [esp+4C8h+var_418]
		push	14h
		push	eax
		call	_OPENSSL_cleanse
		push	[esp+4D0h+var_4AC]
		lea	eax, [esp+4D4h+var_4B4]
		push	esi
		push	eax
		lea	eax, [esp+4DCh+var_4A4]
		push	ebp
		push	eax
		call	_EVP_DecryptUpdate
		add	esp, 1Ch
		test	eax, eax
		jz	loc_A55
		lea	eax, [esp+4C8h+var_4B4]
		push	eax
		mov	eax, [esp+4CCh+var_4B4]
		add	eax, ebp
		push	eax
		lea	eax, [esp+4D0h+var_4A4]
		push	eax
		call	_EVP_DecryptFinal_ex
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_A55
		lea	eax, [esp+4C8h+var_4B0]
		push	eax
		call	_read_ledword
		add	esp, 4
		cmp	eax, 32415352h
		jz	short loc_A3B
		cmp	eax, 32535344h
		jz	short loc_A3B
		push	2E3h
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	65h ; 'e'
		push	87h ; 'á'
		push	9
		call	_ERR_put_error
		add	esp, 14h
		jmp	short loc_A55
; ---------------------------------------------------------------------------

loc_A29:				; CODE XREF: _do_PVK_body+1EAj
					; _do_PVK_body+1F5j
		lea	eax, [esp+4C8h+var_418]
		push	14h
		push	eax
		call	_OPENSSL_cleanse
		add	esp, 8

loc_A3B:				; CODE XREF: _do_PVK_body+29Fj
					; _do_PVK_body+2A6j
		mov	[esp+4C8h+var_4AC], edi

loc_A3F:				; CODE XREF: _do_PVK_body+68j
		mov	eax, [esp+4C8h+var_4A8]
		push	0
		push	eax
		lea	eax, [esp+4D0h+var_4AC]
		push	eax
		call	_do_b2i
		add	esp, 0Ch
		mov	ebx, eax

loc_A55:				; CODE XREF: _do_PVK_body+BDj
					; _do_PVK_body+FDj ...
		mov	ebp, [esp+4C8h+var_4B8]

$err$32:				; CODE XREF: _do_PVK_body+123j
					; _do_PVK_body+15Dj
		lea	eax, [esp+4C8h+var_4A4]
		push	eax
		call	_EVP_CIPHER_CTX_cleanup
		add	esp, 4
		test	edi, edi
		jz	short loc_A77
		test	ebp, ebp
		jz	short loc_A77
		push	edi
		call	_CRYPTO_free
		add	esp, 4

loc_A77:				; CODE XREF: _do_PVK_body+304j
					; _do_PVK_body+308j
		mov	ecx, [esp+4C8h+var_4]
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 4B8h
		retn
_do_PVK_body	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A94h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_do_PVK_header	proc near		; CODE XREF: _b2i_PVK_bio+8Bp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		cmp	[esp+arg_8], 0
		push	esi
		push	edi
		mov	edi, [esp+8+arg_0]
		mov	esi, [edi]
		jz	short loc_ACA
		cmp	[esp+8+arg_4], 14h
		jnb	short loc_B23
		push	274h

loc_AAF:				; CODE XREF: _do_PVK_header+42j
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	7Dh ; '}'
		push	88h ; 'à'
		push	9
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_ACA:				; CODE XREF: _do_PVK_header+Dj
		cmp	[esp+8+arg_4], 18h
		jnb	short loc_AD8
		push	279h
		jmp	short loc_AAF
; ---------------------------------------------------------------------------

loc_AD8:				; CODE XREF: _do_PVK_header+3Bj
		movzx	eax, byte ptr [esi+1]
		lea	ecx, [esi+1]
		movzx	edx, byte ptr [esi]
		lea	esi, [ecx+3]
		shl	eax, 8
		or	edx, eax
		movzx	eax, byte ptr [ecx+1]
		shl	eax, 10h
		or	edx, eax
		movzx	eax, byte ptr [ecx+2]
		shl	eax, 18h
		or	eax, edx
		cmp	eax, 0B0B5F11Eh
		jz	short loc_B23
		push	27Eh
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	74h ; 't'
		push	88h ; 'à'
		push	9
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_B23:				; CODE XREF: _do_PVK_header+14j
					; _do_PVK_header+6Dj
		movzx	eax, byte ptr [esi+9]
		lea	edx, [esi+8]
		movzx	ecx, byte ptr [edx]
		movzx	esi, byte ptr [edx+3]
		shl	eax, 8
		or	ecx, eax
		shl	esi, 18h
		movzx	eax, byte ptr [edx+2]
		shl	eax, 10h
		or	ecx, eax
		movzx	eax, byte ptr [edx+5]
		shl	eax, 8
		or	esi, ecx
		movzx	ecx, byte ptr [edx+4]
		or	ecx, eax
		movzx	eax, byte ptr [edx+6]
		shl	eax, 10h
		or	ecx, eax
		movzx	eax, byte ptr [edx+7]
		shl	eax, 18h
		or	eax, ecx
		lea	ecx, [edx+8]
		push	ebx
		mov	ebx, [esp+0Ch+arg_C]
		push	ebp
		lea	ebp, [ecx+4]
		mov	[ebx], eax
		movzx	eax, byte ptr [ecx+1]
		movzx	edx, byte ptr [ecx]
		shl	eax, 8
		or	edx, eax
		movzx	eax, byte ptr [ecx+2]
		movzx	ecx, byte ptr [ecx+3]
		shl	eax, 10h
		or	edx, eax
		shl	ecx, 18h
		mov	eax, [esp+10h+arg_10]
		or	ecx, edx
		mov	[eax], ecx
		cmp	ecx, 19000h
		ja	short loc_BC9
		mov	eax, [ebx]
		cmp	eax, 2800h
		ja	short loc_BC9
		test	esi, esi
		jz	short loc_BD0
		test	eax, eax
		jnz	short loc_BD0
		push	28Fh
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	79h ; 'y'
		push	88h ; 'à'
		push	9
		call	_ERR_put_error
		add	esp, 14h

loc_BC9:				; CODE XREF: _do_PVK_header+107j
					; _do_PVK_header+110j
		pop	ebp
		pop	ebx
		pop	edi
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_BD0:				; CODE XREF: _do_PVK_header+114j
					; _do_PVK_header+118j
		mov	[edi], ebp
		mov	eax, 1
		pop	ebp
		pop	ebx
		pop	edi
		pop	esi
		retn
_do_PVK_header	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0BDCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_do_b2i		proc near		; CODE XREF: _b2i_PrivateKey+Ap
					; _b2i_PublicKey+Ap ...

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= byte ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 0Ch
		call	__chkstk
		mov	eax, [esp+0Ch+arg_0]
		push	esi
		mov	esi, [esp+10h+arg_4]
		mov	eax, [eax]
		mov	[esp+10h+arg_0], eax
		lea	eax, [esp+10h+arg_8]
		push	eax
		lea	eax, [esp+14h+var_C]
		push	eax
		lea	eax, [esp+18h+var_8]
		push	eax
		lea	eax, [esp+1Ch+var_4]
		push	eax
		lea	eax, [esp+20h+arg_0]
		push	esi
		push	eax
		call	_do_blob_header
		add	esp, 18h
		test	eax, eax
		jg	short loc_C3D
		push	0F5h ; 'ı'
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	7Ah ; 'z'
		push	84h ; 'Ñ'
		push	9
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_C3D:				; CODE XREF: _do_b2i+3Dj
		mov	edx, [esp+10h+arg_8]
		sub	esi, 10h
		push	edi
		mov	edi, [esp+14h+var_8]
		lea	ecx, [edi+7]
		shr	ecx, 3
		cmp	[esp+14h+var_C], 0
		jz	short loc_C6B
		test	edx, edx
		jz	short loc_C62
		lea	ecx, [ecx+ecx*2]
		add	ecx, 2Ch ; ','
		jmp	short loc_C83
; ---------------------------------------------------------------------------

loc_C62:				; CODE XREF: _do_b2i+7Cj
		lea	ecx, ds:40h[ecx*2]
		jmp	short loc_C83
; ---------------------------------------------------------------------------

loc_C6B:				; CODE XREF: _do_b2i+78j
		test	edx, edx
		jz	short loc_C74
		add	ecx, 4
		jmp	short loc_C83
; ---------------------------------------------------------------------------

loc_C74:				; CODE XREF: _do_b2i+91j
		lea	eax, [edi+0Fh]
		shr	eax, 4
		add	ecx, 2
		lea	eax, [eax+eax*4]
		lea	ecx, [eax+ecx*2]

loc_C83:				; CODE XREF: _do_b2i+84j _do_b2i+8Dj ...
		cmp	esi, ecx
		jnb	short loc_CAA
		push	0FAh ; '˙'
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	7Bh ; '{'
		push	84h ; 'Ñ'
		push	9
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_CAA:				; CODE XREF: _do_b2i+A9j
		cmp	[esp+14h+var_C], 0
		lea	eax, [esp+14h+arg_0]
		push	edx
		push	edi
		push	esi
		push	eax
		jz	short loc_CC7
		call	_b2i_dss
		add	esp, 10h
		pop	edi
		pop	esi
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_CC7:				; CODE XREF: _do_b2i+DBj
		call	_b2i_rsa
		add	esp, 10h
		pop	edi
		pop	esi
		add	esp, 0Ch
		retn
_do_b2i		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0CD8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_do_b2i_bio	proc near		; CODE XREF: _b2i_PrivateKey_bio+6p
					; _b2i_PublicKey_bio+6p

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= byte ptr -18h
var_14		= byte ptr -14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 28h ; '('
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+28h+var_4], eax
		mov	eax, [esp+28h+arg_4]
		push	ebp
		mov	ebp, [esp+2Ch+arg_0]
		push	edi
		mov	[esp+30h+var_28], eax
		xor	edi, edi
		push	10h
		lea	eax, [esp+34h+var_14]
		push	eax
		push	ebp
		call	_BIO_read
		add	esp, 0Ch
		cmp	eax, 10h
		jz	short loc_D40
		push	10Bh
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	7Bh ; '{'
		push	85h ; 'Ö'
		push	9
		call	_ERR_put_error
		add	esp, 14h

loc_D2D:				; CODE XREF: _do_b2i_bio+95j
		pop	edi
		xor	eax, eax
		pop	ebp
		mov	ecx, [esp+28h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 28h
		retn
; ---------------------------------------------------------------------------

loc_D40:				; CODE XREF: _do_b2i_bio+38j
		lea	eax, [esp+30h+var_14]
		mov	[esp+30h+var_24], eax
		lea	eax, [esp+30h+var_28]
		push	eax
		lea	eax, [esp+34h+var_1C]
		push	eax
		lea	eax, [esp+38h+var_20]
		push	eax
		lea	eax, [esp+3Ch+var_18]
		push	eax
		lea	eax, [esp+40h+var_24]
		push	10h
		push	eax
		call	_do_blob_header
		add	esp, 18h
		test	eax, eax
		jle	short loc_D2D
		push	ebx
		push	esi
		push	[esp+38h+var_28]
		push	[esp+3Ch+var_1C]
		push	[esp+40h+var_20]
		call	_blob_length
		push	113h
		mov	esi, eax
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	esi
		call	_CRYPTO_malloc
		mov	ebx, eax
		add	esp, 18h
		test	ebx, ebx
		jnz	short loc_DCD
		push	115h
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	41h ; 'A'
		push	85h ; 'Ö'
		push	9
		call	_ERR_put_error
		add	esp, 14h
		mov	eax, edi
		pop	esi
		pop	ebx
		pop	edi
		pop	ebp
		mov	ecx, [esp+28h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 28h
		retn
; ---------------------------------------------------------------------------

loc_DCD:				; CODE XREF: _do_b2i_bio+C3j
		push	esi
		push	ebx
		push	ebp
		mov	[esp+44h+var_24], ebx
		call	_BIO_read
		add	esp, 0Ch
		cmp	eax, esi
		jz	short loc_DFD
		push	11Ah
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	7Bh ; '{'
		push	85h ; 'Ö'
		push	9
		call	_ERR_put_error
		add	esp, 14h
		jmp	short $err$13_0
; ---------------------------------------------------------------------------

loc_DFD:				; CODE XREF: _do_b2i_bio+106j
		mov	eax, [esp+38h+var_28]
		push	eax
		mov	eax, [esp+3Ch+var_20]
		push	eax
		lea	eax, [esp+40h+var_24]
		push	esi
		push	eax
		cmp	[esp+48h+var_1C], edi
		jz	short loc_E1A
		call	_b2i_dss
		jmp	short loc_E1F
; ---------------------------------------------------------------------------

loc_E1A:				; CODE XREF: _do_b2i_bio+139j
		call	_b2i_rsa

loc_E1F:				; CODE XREF: _do_b2i_bio+140j
		mov	edi, eax
		add	esp, 10h

$err$13_0:				; CODE XREF: _do_b2i_bio+123j
		push	ebx
		call	_CRYPTO_free
		mov	ecx, [esp+3Ch+var_4]
		add	esp, 4
		mov	eax, edi
		pop	esi
		pop	ebx
		pop	edi
		pop	ebp
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 28h
		retn
_do_b2i_bio	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E44h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_do_blob_header	proc near		; CODE XREF: _do_b2i+33p
					; _do_b2i_bio+8Bp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		cmp	[esp+arg_4], 10h
		push	ebx
		mov	ebx, [esp+4+arg_0]
		mov	edx, [ebx]
		jnb	short loc_E56
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_E56:				; CODE XREF: _do_blob_header+Cj
		mov	al, [edx]
		push	edi
		cmp	al, 6
		jnz	short loc_E7C
		mov	edi, [esp+8+arg_14]
		cmp	dword ptr [edi], 0
		jnz	short loc_E74
		push	9Ah ; 'ö'
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	77h ; 'w'
		jmp	short loc_EAF
; ---------------------------------------------------------------------------

loc_E74:				; CODE XREF: _do_blob_header+20j
		mov	dword ptr [edi], 1
		jmp	short loc_E9D
; ---------------------------------------------------------------------------

loc_E7C:				; CODE XREF: _do_blob_header+17j
		cmp	al, 7
		jnz	short loc_EBE
		mov	edi, [esp+8+arg_14]
		cmp	dword ptr [edi], 1
		jnz	short loc_E97
		push	0A0h ; '†'
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	78h ; 'x'
		jmp	short loc_EAF
; ---------------------------------------------------------------------------

loc_E97:				; CODE XREF: _do_blob_header+43j
		mov	dword ptr [edi], 0

loc_E9D:				; CODE XREF: _do_blob_header+36j
		cmp	byte ptr [edx+1], 2
		jz	short loc_EC3
		push	0A9h ; '©'
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	75h ; 'u'

loc_EAF:				; CODE XREF: _do_blob_header+2Ej
					; _do_blob_header+51j
		push	86h ; 'Ü'
		push	9
		call	_ERR_put_error
		add	esp, 14h

loc_EBE:				; CODE XREF: _do_blob_header+3Aj
		pop	edi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_EC3:				; CODE XREF: _do_blob_header+5Dj
		movzx	eax, byte ptr [edx+9]
		movzx	ecx, byte ptr [edx+8]
		shl	eax, 8
		or	ecx, eax
		movzx	eax, byte ptr [edx+0Ah]
		shl	eax, 10h
		or	ecx, eax
		movzx	eax, byte ptr [edx+0Bh]
		shl	eax, 18h
		or	eax, ecx
		lea	ecx, [edx+0Ch]
		push	ebp
		push	esi
		mov	esi, [esp+10h+arg_8]
		lea	ebp, [ecx+4]
		mov	[esi], eax
		movzx	eax, byte ptr [ecx+1]
		movzx	edx, byte ptr [ecx]
		shl	eax, 8
		or	edx, eax
		movzx	eax, byte ptr [ecx+2]
		movzx	ecx, byte ptr [ecx+3]
		shl	eax, 10h
		or	edx, eax
		shl	ecx, 18h
		mov	eax, [esp+10h+arg_C]
		or	ecx, edx
		mov	[eax], ecx
		mov	ecx, [esp+10h+arg_10]
		mov	dword ptr [ecx], 0
		mov	eax, [esi]
		cmp	eax, 32415352h
		ja	short loc_F50
		jz	short loc_F80
		cmp	eax, 31415352h
		jz	short loc_F3D
		cmp	eax, 31535344h
		jnz	short loc_F57
		mov	dword ptr [ecx], 1

loc_F3D:				; CODE XREF: _do_blob_header+EAj
		cmp	dword ptr [edi], 0
		jnz	short loc_FA7
		push	0B7h ; '∑'
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	77h ; 'w'
		jmp	short loc_F91
; ---------------------------------------------------------------------------

loc_F50:				; CODE XREF: _do_blob_header+E1j
		cmp	eax, 32535344h
		jz	short loc_F7A

loc_F57:				; CODE XREF: _do_blob_header+F1j
		push	0C6h ; '∆'
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	74h ; 't'
		push	86h ; 'Ü'
		push	9
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		pop	esi
		pop	ebp
		pop	edi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_F7A:				; CODE XREF: _do_blob_header+111j
		mov	dword ptr [ecx], 1

loc_F80:				; CODE XREF: _do_blob_header+E3j
		cmp	dword ptr [edi], 1
		jnz	short loc_FA7
		push	0C0h ; '¿'
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	78h ; 'x'

loc_F91:				; CODE XREF: _do_blob_header+10Aj
		push	86h ; 'Ü'
		push	9
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		pop	ebp
		pop	edi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_FA7:				; CODE XREF: _do_blob_header+FCj
					; _do_blob_header+13Fj
		pop	esi
		mov	[ebx], ebp
		mov	eax, 1
		pop	ebp
		pop	edi
		pop	ebx
		retn
_do_blob_header	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0FB4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_do_i2b		proc near		; CODE XREF: _do_i2b_bio+20p
					; _i2b_PVK+1E7p ...

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 0Ch
		call	__chkstk
		push	ebx
		mov	ebx, [esp+10h+arg_4]
		push	esi
		mov	[esp+14h+var_C], 0
		mov	[esp+14h+var_4], 0
		mov	eax, [ebx]
		cmp	eax, 74h ; 't'
		jnz	short loc_FF4
		mov	esi, [esp+14h+arg_8]
		lea	eax, [esp+14h+var_C]
		push	eax
		push	esi
		push	dword ptr [ebx+14h]
		call	_check_bitlen_dsa
		mov	edx, 2200h
		jmp	short loc_1010
; ---------------------------------------------------------------------------

loc_FF4:				; CODE XREF: _do_i2b+25j
		cmp	eax, 6
		jnz	short loc_101F
		mov	esi, [esp+14h+arg_8]
		lea	eax, [esp+14h+var_C]
		push	eax
		push	esi
		push	dword ptr [ebx+14h]
		call	_check_bitlen_rsa
		mov	edx, 0A400h

loc_1010:				; CODE XREF: _do_i2b+3Ej
		add	esp, 0Ch
		mov	[esp+14h+arg_4], edx
		mov	[esp+14h+var_8], eax
		test	eax, eax
		jnz	short loc_1028

loc_101F:				; CODE XREF: _do_i2b+43j
		pop	esi
		or	eax, 0FFFFFFFFh
		pop	ebx
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_1028:				; CODE XREF: _do_i2b+69j
		lea	ecx, [eax+7]
		shr	ecx, 3
		push	ebp
		cmp	edx, 2200h
		jnz	short loc_104C
		test	esi, esi
		jz	short loc_1043
		lea	ebp, [ecx+16h]
		lea	ebp, [ecx+ebp*2]
		jmp	short loc_1064
; ---------------------------------------------------------------------------

loc_1043:				; CODE XREF: _do_i2b+85j
		lea	ebp, ds:40h[ecx*2]
		jmp	short loc_1064
; ---------------------------------------------------------------------------

loc_104C:				; CODE XREF: _do_i2b+81j
		test	esi, esi
		jz	short loc_1055
		lea	ebp, [ecx+4]
		jmp	short loc_1064
; ---------------------------------------------------------------------------

loc_1055:				; CODE XREF: _do_i2b+9Aj
		add	eax, 0Fh
		lea	ebp, [ecx+2]
		shr	eax, 4
		lea	eax, [eax+eax*4]
		lea	ebp, [eax+ebp*2]

loc_1064:				; CODE XREF: _do_i2b+8Dj _do_i2b+96j ...
		push	edi
		mov	edi, [esp+1Ch+arg_0]
		add	ebp, 10h
		test	edi, edi
		jz	loc_114E
		mov	eax, [edi]
		test	eax, eax
		jnz	short loc_10AA
		push	1E1h
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	ebp
		call	_CRYPTO_malloc
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_109C
		pop	edi
		pop	ebp
		pop	esi
		or	eax, 0FFFFFFFFh
		pop	ebx
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_109C:				; CODE XREF: _do_i2b+DBj
		mov	edx, [esp+1Ch+arg_4]
		mov	[edi], eax
		mov	[esp+1Ch+var_4], 1

loc_10AA:				; CODE XREF: _do_i2b+C4j
		test	esi, esi
		jz	short loc_10B3
		mov	byte ptr [eax],	6
		jmp	short loc_10B6
; ---------------------------------------------------------------------------

loc_10B3:				; CODE XREF: _do_i2b+F8j
		mov	byte ptr [eax],	7

loc_10B6:				; CODE XREF: _do_i2b+FDj
		mov	word ptr [eax+1], 2
		inc	eax
		lea	ecx, [eax+3]
		push	esi
		mov	byte ptr [eax+2], 0
		mov	eax, edx
		mov	[ecx], dl
		shr	eax, 8
		mov	[ecx+1], al
		mov	eax, edx
		shr	eax, 10h
		mov	[ecx+2], al
		mov	eax, edx
		shr	eax, 18h
		lea	edx, [ecx+4]
		mov	[ecx+3], al
		mov	ecx, [esp+20h+var_C]
		mov	eax, ecx
		mov	[edx], cl
		shr	eax, 8
		mov	[edx+1], al
		mov	eax, ecx
		shr	eax, 10h
		mov	[edx+2], al
		shr	ecx, 18h
		mov	[edx+3], cl
		lea	ecx, [edx+4]
		mov	edx, [esp+20h+var_8]
		mov	eax, edx
		shr	eax, 8
		mov	[ecx], dl
		mov	[ecx+1], al
		mov	eax, edx
		shr	eax, 10h
		mov	[ecx+2], al
		lea	eax, [ecx+4]
		shr	edx, 18h
		cmp	[esp+20h+arg_4], 2200h
		mov	[ecx+3], dl
		push	dword ptr [ebx+14h]
		mov	[esp+24h+var_8], eax
		lea	eax, [esp+24h+var_8]
		push	eax
		jnz	short loc_113D
		call	_write_dsa
		jmp	short loc_1142
; ---------------------------------------------------------------------------

loc_113D:				; CODE XREF: _do_i2b+180j
		call	_write_rsa

loc_1142:				; CODE XREF: _do_i2b+187j
		add	esp, 0Ch
		cmp	[esp+1Ch+var_4], 0
		jnz	short loc_114E
		add	[edi], ebp

loc_114E:				; CODE XREF: _do_i2b+BAj _do_i2b+196j
		pop	edi
		mov	eax, ebp
		pop	ebp
		pop	esi
		pop	ebx
		add	esp, 0Ch
		retn
_do_i2b		endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1158h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_do_i2b_bio	proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 4
		call	__chkstk
		push	ebx
		push	[esp+8+arg_8]
		lea	eax, [esp+0Ch+var_4]
		mov	[esp+0Ch+var_4], 0
		push	[esp+0Ch+arg_4]
		push	eax
		call	_do_i2b
		mov	ebx, eax
		add	esp, 0Ch
		test	ebx, ebx
		jns	short loc_118C
		or	eax, 0FFFFFFFFh
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_118C:				; CODE XREF: _do_i2b_bio+2Cj
		push	esi
		push	ebx
		push	[esp+10h+var_4]
		push	[esp+14h+arg_0]
		call	_BIO_write
		push	[esp+18h+var_4]
		mov	esi, eax
		call	_CRYPTO_free
		add	esp, 10h
		or	eax, 0FFFFFFFFh
		cmp	esi, ebx
		cmovz	eax, ebx
		pop	esi
		pop	ebx
		pop	ecx
		retn
_do_i2b_bio	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 11B8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_i2b_PVK	proc near		; CODE XREF: _i2b_PVK_bio+28p

var_4B4		= dword	ptr -4B4h
var_4B0		= dword	ptr -4B0h
var_4AC		= dword	ptr -4ACh
var_4A8		= dword	ptr -4A8h
var_4A4		= byte ptr -4A4h
var_418		= byte ptr -418h
var_413		= qword	ptr -413h
var_40B		= word ptr -40Bh
var_409		= byte ptr -409h
var_404		= byte ptr -404h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	eax, 4B4h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+4B4h+var_4], eax
		mov	eax, [esp+4B4h+arg_C]
		push	ebx
		push	ebp
		mov	ebp, [esp+4BCh+arg_4]
		mov	[esp+4BCh+var_4A8], eax
		mov	eax, [esp+4BCh+arg_10]
		push	esi
		mov	[esp+4C0h+var_4B0], eax
		mov	esi, 18h
		push	edi
		mov	edi, [esp+4C4h+arg_0]
		lea	eax, [esp+4C4h+var_4A4]
		push	eax
		mov	[esp+4C8h+var_4AC], 0
		call	_EVP_CIPHER_CTX_init
		mov	ebx, [esp+4C8h+arg_8]
		add	esp, 4
		test	ebx, ebx
		mov	eax, 28h ; '('
		cmovnz	esi, eax
		mov	eax, [ebp+0]
		cmp	eax, 74h ; 't'
		jnz	short loc_1241
		lea	eax, [esp+4C4h+var_4B4]
		push	eax
		push	0
		push	dword ptr [ebp+14h]
		call	_check_bitlen_dsa
		mov	edx, 2200h
		jmp	short loc_125E
; ---------------------------------------------------------------------------

loc_1241:				; CODE XREF: _i2b_PVK+71j
		cmp	eax, 6
		jnz	loc_1411
		lea	eax, [esp+4C4h+var_4B4]
		push	eax
		push	0
		push	dword ptr [ebp+14h]
		call	_check_bitlen_rsa
		mov	edx, 0A400h

loc_125E:				; CODE XREF: _i2b_PVK+87j
		add	esp, 0Ch
		test	eax, eax
		jz	loc_1411
		lea	ecx, [eax+7]
		shr	ecx, 3
		cmp	edx, 2200h
		jnz	short loc_1280
		lea	eax, ds:40h[ecx*2]
		jmp	short loc_128F
; ---------------------------------------------------------------------------

loc_1280:				; CODE XREF: _i2b_PVK+BDj
		add	eax, 0Fh
		shr	eax, 4
		lea	eax, [eax+eax*4]
		lea	eax, [eax+ecx*2]
		add	eax, 4

loc_128F:				; CODE XREF: _i2b_PVK+C6j
		mov	[esp+4C4h+var_4B4], eax
		add	eax, 10h
		js	loc_1411
		add	esi, eax
		test	edi, edi
		jz	loc_14FB
		mov	eax, [edi]
		test	eax, eax
		jnz	short loc_12E5
		push	329h
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	esi
		call	_CRYPTO_malloc
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_12E3
		push	32Bh
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	41h ; 'A'
		push	89h ; 'â'
		push	9
		call	_ERR_put_error
		add	esp, 14h
		jmp	loc_1411
; ---------------------------------------------------------------------------

loc_12E3:				; CODE XREF: _i2b_PVK+109j
		mov	[edi], eax

loc_12E5:				; CODE XREF: _i2b_PVK+F2j
		mov	dword ptr [eax], 0B0B5F11Eh
		lea	edx, [eax+0Ch]
		mov	dword ptr [eax+4], 0
		cmp	dword ptr [ebp+0], 74h ; 't'
		jnz	short loc_1304
		mov	dword ptr [eax+8], 2
		jmp	short loc_130B
; ---------------------------------------------------------------------------

loc_1304:				; CODE XREF: _i2b_PVK+141j
		mov	dword ptr [eax+8], 1

loc_130B:				; CODE XREF: _i2b_PVK+14Aj
		xor	ecx, ecx
		lea	edi, [edx+0Ch]
		test	ebx, ebx
		setnz	cl
		mov	[edx], cl
		mov	eax, ecx
		shr	eax, 8
		mov	[edx+1], al
		mov	eax, ecx
		shr	eax, 10h
		mov	[edx+2], al
		shr	ecx, 18h
		neg	ebx
		mov	[edx+3], cl
		sbb	ebx, ebx
		and	ebx, 10h
		mov	[edx+4], bl
		mov	eax, ebx
		shr	eax, 8
		mov	[edx+5], al
		mov	eax, ebx
		shr	eax, 10h
		mov	[edx+6], al
		shr	ebx, 18h
		mov	[edx+7], bl
		mov	ebx, [esp+4C4h+var_4B4]
		add	ebx, 10h
		mov	[esp+4C4h+var_4B4], edi
		mov	eax, ebx
		mov	[edx+8], bl
		shr	eax, 8
		mov	[edx+9], al
		mov	eax, ebx
		shr	eax, 10h
		mov	[edx+0Ah], al
		mov	eax, ebx
		shr	eax, 18h
		cmp	[esp+4C4h+arg_8], 0
		mov	[edx+0Bh], al
		jz	short loc_1397
		push	10h
		push	edi
		call	_RAND_bytes
		add	esp, 8
		test	eax, eax
		jle	short $error$73
		mov	[esp+4C4h+var_4AC], edi
		add	edi, 10h
		mov	[esp+4C4h+var_4B4], edi

loc_1397:				; CODE XREF: _i2b_PVK+1C3j
		push	0
		lea	eax, [esp+4C8h+var_4B4]
		push	ebp
		push	eax
		call	_do_i2b
		mov	ebp, [esp+4D0h+arg_8]
		add	esp, 0Ch
		test	ebp, ebp
		jz	loc_14FB
		push	[esp+4C4h+var_4B0]
		mov	eax, [esp+4C8h+var_4A8]
		push	1
		push	400h
		test	eax, eax
		jz	short loc_13D5
		lea	ecx, [esp+4D0h+var_404]
		push	ecx
		call	eax
		jmp	short loc_13E2
; ---------------------------------------------------------------------------

loc_13D5:				; CODE XREF: _i2b_PVK+20Fj
		lea	eax, [esp+4D0h+var_404]
		push	eax
		call	_PEM_def_callback

loc_13E2:				; CODE XREF: _i2b_PVK+21Bj
		add	esp, 10h
		test	eax, eax
		jg	short loc_142D
		push	34Ch
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	68h ; 'h'
		push	89h ; 'â'
		push	9
		call	_ERR_put_error
		add	esp, 14h

$error$73:				; CODE XREF: _i2b_PVK+1D2j
					; _i2b_PVK+297j ...
		lea	eax, [esp+4C4h+var_4A4]
		push	eax
		call	_EVP_CIPHER_CTX_cleanup
		add	esp, 4

loc_1411:				; CODE XREF: _i2b_PVK+8Cj _i2b_PVK+ABj ...
		or	eax, 0FFFFFFFFh

loc_1414:				; CODE XREF: _i2b_PVK+345j
		mov	ecx, [esp+4C4h+var_4]
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 4B4h
		retn
; ---------------------------------------------------------------------------

loc_142D:				; CODE XREF: _i2b_PVK+22Fj
		mov	edi, [esp+4C4h+var_4AC]
		push	eax
		lea	eax, [esp+4C8h+var_404]
		push	eax
		push	10h
		lea	eax, [esp+4D0h+var_418]
		push	edi
		push	eax
		call	_derive_pvk_key
		add	esp, 14h
		test	eax, eax
		jz	short $error$73
		cmp	ebp, 1
		jnz	short loc_1474
		xorps	xmm0, xmm0
		mov	[esp+4C4h+var_40B], 0
		movq	[esp+4C4h+var_413], xmm0
		mov	[esp+4C4h+var_409], 0

loc_1474:				; CODE XREF: _i2b_PVK+29Cj
		push	0
		lea	eax, [esp+4C8h+var_418]
		add	edi, 18h
		push	eax
		push	0
		call	_EVP_rc4
		push	eax
		lea	eax, [esp+4D4h+var_4A4]
		push	eax
		call	_EVP_EncryptInit_ex
		add	esp, 14h
		test	eax, eax
		jz	$error$73
		lea	eax, [esp+4C4h+var_418]
		push	14h
		push	eax
		call	_OPENSSL_cleanse
		lea	eax, [ebx-8]
		push	eax
		push	edi
		lea	eax, [esp+4D4h+var_4B0]
		push	eax
		lea	eax, [esp+4D8h+var_4A4]
		push	edi
		push	eax
		call	_EVP_DecryptUpdate
		add	esp, 1Ch
		test	eax, eax
		jz	$error$73
		lea	eax, [esp+4C4h+var_4B0]
		push	eax
		mov	eax, [esp+4C8h+var_4B0]
		add	eax, edi
		push	eax
		lea	eax, [esp+4CCh+var_4A4]
		push	eax
		call	_EVP_DecryptFinal_ex
		add	esp, 0Ch
		test	eax, eax
		jz	$error$73
		lea	eax, [esp+4C4h+var_4A4]
		push	eax
		call	_EVP_CIPHER_CTX_cleanup
		add	esp, 4

loc_14FB:				; CODE XREF: _i2b_PVK+E8j
					; _i2b_PVK+1F8j
		mov	eax, esi
		jmp	loc_1414
_i2b_PVK	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1504h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _i2b_PVK_bio
_i2b_PVK_bio	proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	eax, 4
		call	__chkstk
		push	ebx
		push	[esp+8+arg_10]
		lea	eax, [esp+0Ch+var_4]
		mov	[esp+0Ch+var_4], 0
		push	[esp+0Ch+arg_C]
		push	[esp+10h+arg_8]
		push	[esp+14h+arg_4]
		push	eax
		call	_i2b_PVK
		mov	ebx, eax
		add	esp, 14h
		test	ebx, ebx
		js	short loc_157C
		push	esi
		push	ebx
		push	[esp+10h+var_4]
		push	[esp+14h+arg_0]
		call	_BIO_write
		push	[esp+18h+var_4]
		mov	esi, eax
		call	_CRYPTO_free
		add	esp, 10h
		cmp	esi, ebx
		pop	esi
		jnz	short loc_157C
		push	370h
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	76h ; 'v'
		push	8Ah ; 'ä'
		push	9
		call	_ERR_put_error
		add	esp, 14h
		mov	eax, ebx
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_157C:				; CODE XREF: _i2b_PVK_bio+34j
					; _i2b_PVK_bio+56j
		or	eax, 0FFFFFFFFh
		pop	ebx
		pop	ecx
		retn
_i2b_PVK_bio	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1584h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _i2b_PrivateKey_bio
_i2b_PrivateKey_bio proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 4
		call	__chkstk
		push	ebx
		push	0
		push	[esp+0Ch+arg_4]
		lea	eax, [esp+10h+var_4]
		mov	[esp+10h+var_4], 0
		push	eax
		call	_do_i2b
		mov	ebx, eax
		add	esp, 0Ch
		test	ebx, ebx
		jns	short loc_15B6
		or	eax, 0FFFFFFFFh
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_15B6:				; CODE XREF: _i2b_PrivateKey_bio+2Aj
		push	esi
		push	ebx
		push	[esp+10h+var_4]
		push	[esp+14h+arg_0]
		call	_BIO_write
		push	[esp+18h+var_4]
		mov	esi, eax
		call	_CRYPTO_free
		add	esp, 10h
		or	eax, 0FFFFFFFFh
		cmp	esi, ebx
		cmovz	eax, ebx
		pop	esi
		pop	ebx
		pop	ecx
		retn
_i2b_PrivateKey_bio endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 15E0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _i2b_PublicKey_bio
_i2b_PublicKey_bio proc	near

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 4
		call	__chkstk
		push	ebx
		push	1
		push	[esp+0Ch+arg_4]
		lea	eax, [esp+10h+var_4]
		mov	[esp+10h+var_4], 0
		push	eax
		call	_do_i2b
		mov	ebx, eax
		add	esp, 0Ch
		test	ebx, ebx
		jns	short loc_1612
		or	eax, 0FFFFFFFFh
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_1612:				; CODE XREF: _i2b_PublicKey_bio+2Aj
		push	esi
		push	ebx
		push	[esp+10h+var_4]
		push	[esp+14h+arg_0]
		call	_BIO_write
		push	[esp+18h+var_4]
		mov	esi, eax
		call	_CRYPTO_free
		add	esp, 10h
		or	eax, 0FFFFFFFFh
		cmp	esi, ebx
		cmovz	eax, ebx
		pop	esi
		pop	ebx
		pop	ecx
		retn
_i2b_PublicKey_bio endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 163Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_read_lebn	proc near		; CODE XREF: _b2i_dss+44p _b2i_dss+5Bp ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		push	ebp
		mov	ebp, [esp+8+arg_0]
		push	esi
		push	edi
		mov	edi, [esp+10h+arg_4]
		push	64h ; 'd'
		push	offset ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ ; ".\\crypto\\pem\\pvkfmt.c"
		push	edi
		lea	esi, [edi-1]
		add	esi, [ebp+0]
		call	_CRYPTO_malloc
		mov	ebx, eax
		add	esp, 0Ch
		test	ebx, ebx
		jz	short loc_16A6
		mov	ecx, ebx
		test	edi, edi
		jz	short loc_167C
		mov	edx, edi

loc_166C:				; CODE XREF: _read_lebn+3Ej
		mov	al, [esi]
		lea	ecx, [ecx+1]
		mov	[ecx-1], al
		lea	esi, [esi-1]
		sub	edx, 1
		jnz	short loc_166C

loc_167C:				; CODE XREF: _read_lebn+2Cj
		push	0
		push	edi
		push	ebx
		call	_BN_bin2bn
		mov	esi, [esp+1Ch+arg_8]
		push	ebx
		mov	[esi], eax
		call	_CRYPTO_free
		add	esp, 10h
		cmp	dword ptr [esi], 0
		jz	short loc_16A6
		add	[ebp+0], edi
		mov	eax, 1
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_16A6:				; CODE XREF: _read_lebn+26j
					; _read_lebn+5Bj
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
_read_lebn	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 16B0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_read_ledword	proc near		; CODE XREF: _do_PVK_body+1DDp
					; _do_PVK_body+292p

arg_0		= dword	ptr  4

		push	esi
		push	edi
		mov	edi, [esp+8+arg_0]
		mov	edx, [edi]
		movzx	eax, byte ptr [edx+1]
		movzx	esi, byte ptr [edx]
		movzx	ecx, byte ptr [edx+2]
		shl	eax, 8
		shl	ecx, 10h
		or	eax, esi
		or	eax, ecx
		movzx	ecx, byte ptr [edx+3]
		shl	ecx, 18h
		or	eax, ecx
		lea	ecx, [edx+4]
		mov	[edi], ecx
		pop	edi
		pop	esi
		retn
_read_ledword	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 16E0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_write_dsa	proc near		; CODE XREF: _do_i2b+182p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		push	esi
		push	edi
		mov	edi, [esp+0Ch+arg_4]
		push	dword ptr [edi+0Ch]
		call	_BN_num_bits
		mov	esi, [esp+10h+arg_0]
		add	eax, 7
		cdq
		and	edx, 7
		lea	ebx, [edx+eax]
		sar	ebx, 3
		push	ebx
		push	dword ptr [edi+0Ch]
		push	esi
		call	_write_lebn
		push	14h
		push	dword ptr [edi+10h]
		push	esi
		call	_write_lebn
		push	ebx
		push	dword ptr [edi+14h]
		push	esi
		call	_write_lebn
		add	esp, 28h
		cmp	[esp+0Ch+arg_8], 0
		jz	short loc_172F
		push	ebx
		push	dword ptr [edi+18h]
		jmp	short loc_1734
; ---------------------------------------------------------------------------

loc_172F:				; CODE XREF: _write_dsa+47j
		push	14h
		push	dword ptr [edi+1Ch]

loc_1734:				; CODE XREF: _write_dsa+4Dj
		push	esi
		call	_write_lebn
		mov	eax, [esi]
		add	esp, 0Ch
		movaps	xmm0, ds:__xmm@ffffffffffffffffffffffffffffffff
		movups	xmmword	ptr [eax], xmm0
		pop	edi
		movq	qword ptr [eax+10h], xmm0
		add	dword ptr [esi], 18h
		pop	esi
		pop	ebx
		retn
_write_dsa	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1758h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_write_lebn	proc near		; CODE XREF: _write_dsa+25p
					; _write_dsa+30p ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	ebp
		push	esi
		push	edi
		mov	edi, [esp+10h+arg_4]
		mov	esi, [ebx]
		push	edi
		call	_BN_num_bits
		add	eax, 7
		cdq
		and	edx, 7
		push	esi
		push	edi
		lea	ebp, [edx+eax]
		sar	ebp, 3
		call	_BN_bn2bin
		mov	eax, ebp
		lea	edi, [esi-1]
		cdq
		add	esp, 0Ch
		sub	eax, edx
		add	edi, ebp
		mov	edx, eax
		sar	edx, 1
		test	edx, edx
		jle	short loc_17AE
		nop	dword ptr [eax]

loc_1798:				; CODE XREF: _write_lebn+54j
		mov	al, [edi]
		lea	esi, [esi+1]
		mov	cl, [esi-1]
		lea	edi, [edi-1]
		mov	[esi-1], al
		mov	[edi+1], cl
		sub	edx, 1
		jnz	short loc_1798

loc_17AE:				; CODE XREF: _write_lebn+3Bj
		add	[ebx], ebp
		mov	esi, [esp+10h+arg_8]
		test	esi, esi
		jle	short loc_17CD
		sub	esi, ebp
		test	esi, esi
		jle	short loc_17CD
		push	esi		; Size
		push	0		; Val
		push	dword ptr [ebx]	; Dst
		call	_memset
		add	esp, 0Ch
		add	[ebx], esi

loc_17CD:				; CODE XREF: _write_lebn+5Ej
					; _write_lebn+64j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_write_lebn	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 17D4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_write_ledword	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_4]
		mov	eax, ecx
		push	esi
		mov	esi, [esp+4+arg_0]
		shr	eax, 8
		mov	edx, [esi]
		mov	[edx], cl
		mov	[edx+1], al
		mov	eax, ecx
		shr	eax, 10h
		mov	[edx+2], al
		lea	eax, [edx+4]
		shr	ecx, 18h
		mov	[edx+3], cl
		mov	[esi], eax
		pop	esi
		retn
_write_ledword	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1800h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_write_rsa	proc near		; CODE XREF: _do_i2b:loc_113Dp

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 8
		call	__chkstk
		push	ebx
		push	ebp
		mov	ebp, [esp+10h+arg_4]
		push	esi
		push	edi
		push	dword ptr [ebp+10h]
		call	_BN_num_bits
		push	dword ptr [ebp+10h]
		add	eax, 7
		cdq
		and	edx, 7
		add	eax, edx
		sar	eax, 3
		mov	[esp+20h+var_4], eax
		call	_BN_num_bits
		mov	ebx, [esp+20h+arg_0]
		add	eax, 0Fh
		push	4
		push	dword ptr [ebp+14h]
		sar	eax, 4
		push	ebx
		mov	[esp+2Ch+var_8], eax
		call	_write_lebn
		mov	edi, [ebp+10h]
		mov	esi, [ebx]
		push	edi
		call	_BN_num_bits
		add	eax, 7
		cdq
		and	edx, 7
		add	eax, edx
		sar	eax, 3
		push	esi
		push	edi
		mov	[esp+38h+arg_4], eax
		call	_BN_bn2bin
		mov	eax, [esp+38h+arg_4]
		add	esp, 20h
		lea	edi, [eax-1]
		cdq
		sub	eax, edx
		add	edi, esi
		mov	edx, eax
		sar	edx, 1
		test	edx, edx
		jle	short loc_189A

loc_1884:				; CODE XREF: _write_rsa+98j
		mov	al, [edi]
		lea	esi, [esi+1]
		mov	cl, [esi-1]
		lea	edi, [edi-1]
		mov	[esi-1], al
		mov	[edi+1], cl
		sub	edx, 1
		jnz	short loc_1884

loc_189A:				; CODE XREF: _write_rsa+82j
		mov	eax, [esp+18h+arg_4]
		add	[ebx], eax
		cmp	[esp+18h+arg_8], 0
		jnz	short loc_18ED
		mov	esi, [esp+18h+var_8]
		push	esi
		push	dword ptr [ebp+1Ch]
		push	ebx
		call	_write_lebn
		push	esi
		push	dword ptr [ebp+20h]
		push	ebx
		call	_write_lebn
		push	esi
		push	dword ptr [ebp+24h]
		push	ebx
		call	_write_lebn
		push	esi
		push	dword ptr [ebp+28h]
		push	ebx
		call	_write_lebn
		push	esi
		push	dword ptr [ebp+2Ch]
		push	ebx
		call	_write_lebn
		push	[esp+54h+var_4]
		push	dword ptr [ebp+18h]
		push	ebx
		call	_write_lebn
		add	esp, 48h

loc_18ED:				; CODE XREF: _write_rsa+A5j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 8
		retn
_write_rsa	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 18F8h
; COMDAT (pick any)
		public ??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@
; `string'
??_C@_0BG@FDPDCLFM@?4?2crypto?2pem?2pvkfmt?4c?$AA@ db '.\crypto\pem\pvkfmt.c',0
					; DATA XREF: _b2i_PVK_bio+47o
					; _b2i_PVK_bio+A6o ...
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 1910h
; COMDAT (pick any)
		public __xmm@ffffffffffffffffffffffffffffffff
__xmm@ffffffffffffffffffffffffffffffff xmmword 0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFh
					; DATA XREF: _write_dsa+5Fr
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _CRYPTO_malloc:near ; CODE XREF: _b2i_PVK_bio+ACp
					; _do_PVK_body+D4p ...
		extrn _CRYPTO_free:near	; CODE XREF: _b2i_PVK_bio+13Ep
					; _do_PVK_body+30Bp ...
		extrn _OPENSSL_cleanse:near ; CODE XREF: _b2i_PVK_bio+138p
					; _do_PVK_body+24Bp ...
		extrn _BIO_read:near	; CODE XREF: _b2i_PVK_bio+35p
					; _b2i_PVK_bio+F1p ...
		extrn _BIO_write:near	; CODE XREF: _do_i2b_bio+3Ep
					; _i2b_PVK_bio+40p ...
		extrn _ERR_put_error:near ; CODE XREF: _b2i_PVK_bio+55p
					; _b2i_PVK_bio+CDp ...
		extrn _BN_CTX_new:near	; CODE XREF: _b2i_dss+107p
		extrn _BN_CTX_free:near	; CODE XREF: _b2i_dss+D4p
					; _b2i_dss+130p
		extrn _BN_num_bits:near	; CODE XREF: _check_bitlen_dsa+9p
					; _check_bitlen_dsa+1Bp ...
		extrn _BN_new:near	; CODE XREF: _b2i_dss+FBp _b2i_rsa+4Ap
		extrn _BN_bin2bn:near	; CODE XREF: _read_lebn+44p
		extrn _BN_bn2bin:near	; CODE XREF: _write_lebn+23p
					; _write_rsa+68p
		extrn _BN_set_word:near	; CODE XREF: _b2i_rsa+8Cp
		extrn _BN_mod_exp:near	; CODE XREF: _b2i_dss+11Fp
		extrn _EVP_MD_CTX_init:near ; CODE XREF: _derive_pvk_key+15p
		extrn _EVP_MD_CTX_cleanup:near ; CODE XREF: _derive_pvk_key+86p
		extrn _EVP_DigestInit_ex:near ;	CODE XREF: _derive_pvk_key+2Ap
		extrn _EVP_DigestUpdate:near ; CODE XREF: _derive_pvk_key+43p
					; _derive_pvk_key+5Cp
		extrn _EVP_DigestFinal_ex:near ; CODE XREF: _derive_pvk_key+73p
		extrn _EVP_EncryptInit_ex:near ; CODE XREF: _i2b_PVK+2D6p
		extrn _EVP_DecryptInit_ex:near ; CODE XREF: _do_PVK_body+187p
					; _do_PVK_body+231p
		extrn _EVP_DecryptUpdate:near ;	CODE XREF: _do_PVK_body+1A7p
					; _do_PVK_body+260p ...
		extrn _EVP_DecryptFinal_ex:near	; CODE XREF: _do_PVK_body+1C8p
					; _do_PVK_body+281p ...
		extrn _EVP_CIPHER_CTX_init:near	; CODE XREF: _do_PVK_body+5Ep
					; _i2b_PVK+52p
		extrn _EVP_CIPHER_CTX_cleanup:near ; CODE XREF:	_do_PVK_body+2FAp
					; _i2b_PVK+251p ...
		extrn _EVP_sha1:near	; CODE XREF: _derive_pvk_key+1Fp
		extrn _EVP_rc4:near	; CODE XREF: _do_PVK_body+17Cp
					; _do_PVK_body+226p ...
		extrn _EVP_PKEY_set1_RSA:near ;	CODE XREF: _b2i_rsa+14Fp
		extrn _EVP_PKEY_set1_DSA:near ;	CODE XREF: _b2i_dss+13Ap
		extrn _EVP_PKEY_new:near ; CODE	XREF: _b2i_dss+2Bp
					; _b2i_rsa+33p
		extrn _EVP_PKEY_free:near ; CODE XREF: _b2i_dss+C7p
					; _b2i_rsa+19Ep
		extrn _RSA_new:near	; CODE XREF: _b2i_rsa+2Cp
		extrn _RSA_free:near	; CODE XREF: _b2i_rsa+155p
					; _b2i_rsa+191p
		extrn _DSA_new:near	; CODE XREF: _b2i_dss+24p
		extrn _DSA_free:near	; CODE XREF: _b2i_dss+BAp
					; _b2i_dss+140p
		extrn _PEM_def_callback:near ; CODE XREF: _do_PVK_body+94p
					; _i2b_PVK+225p
		extrn _RAND_bytes:near	; CODE XREF: _i2b_PVK+1C8p
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _b2i_PVK_bio+67p
					; _b2i_PVK_bio+E1p ...
		extrn __chkstk:near	; CODE XREF: _b2i_PVK_bio+5p
					; _b2i_dss+5p ...
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _write_lebn+6Bp
		extrn ___security_cookie:near ;	DATA XREF: _b2i_PVK_bio+Ar
					; _do_PVK_body+Ar ...


		end
