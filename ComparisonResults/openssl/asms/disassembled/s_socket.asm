;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	DB877A6F3E0043C9D377F9BE035A46CD
; Input	CRC32 :	A02E4676

; File Name   :	C:\compspace\Diff\openssl\obj\s_socket.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_bss		segment	para public 'BSS' use32
		assume cs:_bss
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
_ghbn_hits	dd ?			; DATA XREF: _GetHostByName+B1r
					; _GetHostByName:loc_4D1r ...
_ghbn_miss	dd ?			; DATA XREF: _GetHostByName+60w
					; _GetHostByName+B6r ...
_wsa_init_done	dd ?			; DATA XREF: _ssl_sock_cleanupr
					; _ssl_sock_cleanup+9w	...
		align 10h
; struct WSAData wsa_state
_wsa_state	WSAData	<?>		; DATA XREF: _ssl_sock_init+1Do
					; _ssl_sock_init+34o
; struct sockaddr `do_accept'::`2'::from
?from@?1??do_accept@@9@9 sockaddr <?>	; DATA XREF: _do_accept+23o
					; _do_accept+2Fw ...
_ghbn_cache	dd 20h dup(?)		; DATA XREF: _GetHostByName+99o
xmmword_230	xmmword	?		; DATA XREF: _GetHostByName+BCw
					; _GetHostByName+F5o
dword_240	dd ?			; DATA XREF: _GetHostByName+1Do
					; _GetHostByName+C3w ...
		dd 6Eh dup(?)
		db 3 dup(?)
byte_3FF	db ?			; DATA XREF: _GetHostByName+53o
_bss		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 400h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl GetHostByName(char *Str1)
_GetHostByName	proc near		; CODE XREF: _do_accept+116p
					; _host_ip+8Fp

var_4		= dword	ptr -4
Str1		= dword	ptr  4

		mov	eax, 4
		call	__chkstk
		push	ebx
		push	ebp
		push	esi
		mov	esi, [esp+10h+Str1]
		xor	eax, eax
		push	edi
		or	ebp, 0FFFFFFFFh
		mov	[esp+14h+var_4], eax
		xor	ebx, ebx
		mov	edi, offset dword_240

loc_422:				; CODE XREF: _GetHostByName+59j
		mov	eax, [edi]
		cmp	ebp, eax
		jbe	short loc_42E
		mov	ebp, eax
		mov	[esp+14h+var_4], ebx

loc_42E:				; CODE XREF: _GetHostByName+26j
		test	eax, eax
		jz	short loc_44C
		push	80h ; '€'       ; MaxCount
		lea	eax, [edi-90h]
		push	eax		; Str2
		push	esi		; Str1
		call	dword ptr ds:__imp__strncmp
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_45B

loc_44C:				; CODE XREF: _GetHostByName+30j
		add	edi, 94h ; '”'
		inc	ebx
		cmp	edi, (offset byte_3FF+91h)
		jl	short loc_422

loc_45B:				; CODE XREF: _GetHostByName+4Aj
		cmp	ebx, 4
		jnz	short loc_4D1
		inc	ds:_ghbn_miss
		push	esi		; name
		call	dword ptr ds:__imp__gethostbyname@4 ; gethostbyname(x)
		mov	edx, eax
		test	edx, edx
		jnz	short loc_479
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_479:				; CODE XREF: _GetHostByName+71j
		mov	ecx, esi
		lea	edi, [ecx+1]
		xchg	ax, ax

loc_480:				; CODE XREF: _GetHostByName+85j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_480
		sub	ecx, edi
		cmp	ecx, 80h ; '€'
		jnb	short loc_4C9
		imul	edi, [esp+14h+var_4], 94h
		lea	ecx, _ghbn_cache[edi]
		sub	ecx, esi

loc_4A1:				; CODE XREF: _GetHostByName+ACj
		mov	al, [esi]
		lea	esi, [esi+1]
		mov	[ecx+esi-1], al
		test	al, al
		jnz	short loc_4A1
		movups	xmm0, xmmword ptr [edx]
		mov	eax, ds:_ghbn_hits
		add	eax, ds:_ghbn_miss
		movups	ds:xmmword_230[edi], xmm0
		mov	ds:dword_240[edi], eax

loc_4C9:				; CODE XREF: _GetHostByName+8Fj
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, edx
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_4D1:				; CODE XREF: _GetHostByName+5Ej
		mov	edx, ds:_ghbn_hits
		mov	eax, ds:_ghbn_miss
		inc	edx
		imul	ecx, ebx, 94h
		add	eax, edx
		pop	edi
		pop	esi
		pop	ebp
		mov	ds:_ghbn_hits, edx
		pop	ebx
		mov	ds:dword_240[ecx], eax
		lea	eax, xmmword_230[ecx]
		pop	ecx
		retn
_GetHostByName	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 500h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public ___local_stdio_scanf_options
___local_stdio_scanf_options proc near	; CODE XREF: __vsscanf_l+12p
					; _sscanf+11p
		mov	eax, offset ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
		retn
___local_stdio_scanf_options endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 508h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public __vsscanf_l
__vsscanf_l	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	[esp+arg_C]
		push	[esp+4+arg_8]
		push	[esp+8+arg_4]
		push	0FFFFFFFFh
		push	[esp+10h+arg_0]
		call	___local_stdio_scanf_options
		push	dword ptr [eax+4]
		push	dword ptr [eax]
		call	dword ptr ds:__imp____stdio_common_vsscanf
		add	esp, 1Ch
		retn
__vsscanf_l	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 530h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl do_accept(SOCKET s, int, int)
_do_accept	proc near		; CODE XREF: _do_server+60p

addrlen		= dword	ptr -4
s		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 4
		call	__chkstk
		call	_ssl_sock_init
		test	eax, eax
		jnz	short loc_545
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_545:				; CODE XREF: _do_accept+11j
		push	esi
		lea	eax, [esp+8+addrlen]
		mov	[esp+8+addrlen], 10h
		push	eax		; addrlen
		push	offset ?from@?1??do_accept@@9@9	; addr
		push	[esp+10h+s]	; s
		xorps	xmm0, xmm0
		movups	xmmword	ptr ds:?from@?1??do_accept@@9@9.sa_family, xmm0	; `do_accept'::`2'::from
		call	dword ptr ds:__imp__accept@12 ;	accept(x,x,x)
		mov	esi, eax
		cmp	esi, 0FFFFFFFFh
		jnz	short loc_592
		call	dword ptr ds:__imp__WSAGetLastError@0 ;	WSAGetLastError()
		push	eax
		push	offset ??_C@_0BB@ENCFPFEO@accept?5error?5?$CFd?6?$AA@ ;	"accept	error %d\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 0Ch
		xor	eax, eax
		pop	esi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_592:				; CODE XREF: _do_accept+41j
		push	ebx
		push	edi
		mov	edi, [esp+10h+arg_8]
		test	edi, edi
		jz	short $end$19
		push	2		; type
		push	4		; len
		push	(offset	?from@?1??do_accept@@9@9.sa_data+2) ; addr
		call	dword ptr ds:__imp__gethostbyaddr@12 ; gethostbyaddr(x,x,x)
		mov	ebx, eax
		test	ebx, ebx
		jnz	short loc_5D6
		push	offset ??_C@_0BD@IODBLNBJ@bad?5gethostbyaddr?6?$AA@ ; "bad gethostbyaddr\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 8
		mov	[edi], ebx

$end$19:				; CODE XREF: _do_accept+6Aj
					; _do_accept+12Fj
		mov	eax, [esp+10h+arg_4]
		pop	edi
		pop	ebx
		mov	[eax], esi
		mov	eax, 1
		pop	esi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_5D6:				; CODE XREF: _do_accept+7Fj
		mov	ecx, [ebx]
		lea	edx, [ecx+1]
		nop	dword ptr [eax+eax+00h]

loc_5E0:				; CODE XREF: _do_accept+B5j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_5E0
		sub	ecx, edx
		push	1C8h
		push	offset ??_C@_0BC@LIAOONEC@?4?2apps?2s_socket?4c?$AA@ ; ".\\apps\\s_socket.c"
		lea	eax, [ecx+1]
		push	eax
		call	_CRYPTO_malloc
		mov	edx, eax
		add	esp, 0Ch
		mov	[edi], edx
		test	edx, edx
		jnz	short loc_623
		push	offset ??_C@_0P@OGNLMJHA@OPENSSL_malloc?$AA@ ; "OPENSSL_malloc"
		call	dword ptr ds:__imp__perror
		add	esp, 4
		push	esi		; s
		call	dword ptr ds:__imp__closesocket@4 ; closesocket(x)
		pop	edi
		pop	ebx
		xor	eax, eax
		pop	esi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_623:				; CODE XREF: _do_accept+D5j
		mov	ebx, [ebx]
		mov	ecx, ebx
		push	ebp
		lea	ebp, [ecx+1]
		nop	dword ptr [eax+eax+00h]

loc_630:				; CODE XREF: _do_accept+105j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_630
		sub	ecx, ebp
		lea	eax, [ecx+1]
		push	eax
		push	ebx
		push	edx
		call	_BUF_strlcpy
		push	dword ptr [edi]	; Str1
		call	_GetHostByName
		add	esp, 10h
		pop	ebp
		test	eax, eax
		jnz	short loc_65A
		push	offset ??_C@_0BH@PFCDHECA@gethostbyname?5failure?6?$AA@	; "gethostbyname failure\n"
		jmp	short loc_66A
; ---------------------------------------------------------------------------

loc_65A:				; CODE XREF: _do_accept+121j
		cmp	word ptr [eax+8], 2
		jz	$end$19
		push	offset ??_C@_0CD@LJHAJJJN@gethostbyname?5addr?5is?5not?5AF_INE@	; "gethostbyname addr is not AF_INET\n"

loc_66A:				; CODE XREF: _do_accept+128j
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 8
		push	esi		; s
		call	dword ptr ds:__imp__closesocket@4 ; closesocket(x)
		pop	edi
		pop	ebx
		xor	eax, eax
		pop	esi
		pop	ecx
		retn
_do_accept	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 688h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl do_server(u_short	hostshort, int,	int, int, int, int)
		public _do_server
_do_server	proc near

s		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
hostshort	= word ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	eax, 0Ch
		call	__chkstk
		push	ebp
		push	esi
		mov	esi, [esp+14h+arg_4]
		lea	eax, [esp+14h+s]
		xor	ebp, ebp
		push	esi		; int
		push	ebp		; int
		push	dword ptr [esp+1Ch+hostshort] ;	hostshort
		mov	[esp+20h+var_8], ebp
		push	eax		; int
		mov	[esp+24h+s], ebp
		call	_init_server_long
		add	esp, 10h
		test	eax, eax
		jnz	short loc_6BF
		pop	esi
		pop	ebp
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_6BF:				; CODE XREF: _do_server+2Fj
		mov	eax, [esp+14h+arg_8]
		push	edi
		mov	edi, [esp+18h+s]
		test	eax, eax
		jz	short loc_6CE
		mov	[eax], edi

loc_6CE:				; CODE XREF: _do_server+42j
		push	ebx
		mov	ebx, [esp+1Ch+arg_14]
		nop	dword ptr [eax+eax+00h]

loc_6D8:				; CODE XREF: _do_server+CBj
		cmp	esi, 1
		jnz	short loc_6FE
		lea	eax, [esp+1Ch+var_8]
		push	eax		; int
		lea	eax, [esp+20h+s]
		push	eax		; int
		push	edi		; s
		call	_do_accept
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_755
		mov	ebp, [esp+1Ch+var_8]
		mov	esi, [esp+1Ch+s]
		jmp	short loc_704
; ---------------------------------------------------------------------------

loc_6FE:				; CODE XREF: _do_server+53j
		mov	esi, edi
		mov	[esp+1Ch+s], esi

loc_704:				; CODE XREF: _do_server+74j
		push	[esp+1Ch+arg_10]
		push	[esp+20h+arg_4]
		push	esi
		push	ebp
		call	[esp+2Ch+arg_C]
		add	esp, 10h
		mov	[esp+1Ch+var_4], eax
		test	ebp, ebp
		jz	short loc_726
		push	ebp
		call	_CRYPTO_free
		add	esp, 4

loc_726:				; CODE XREF: _do_server+93j
		cmp	[esp+1Ch+arg_4], 1
		jnz	short loc_73D
		push	2		; how
		push	esi		; s
		call	dword ptr ds:__imp__shutdown@8 ; shutdown(x,x)
		push	esi		; s
		call	dword ptr ds:__imp__closesocket@4 ; closesocket(x)

loc_73D:				; CODE XREF: _do_server+A3j
		cmp	ebx, 0FFFFFFFFh
		jz	short loc_743
		dec	ebx

loc_743:				; CODE XREF: _do_server+B8j
		mov	esi, [esp+1Ch+var_4]
		test	esi, esi
		js	short loc_76F
		test	ebx, ebx
		jz	short loc_76F
		mov	esi, [esp+1Ch+arg_4]
		jmp	short loc_6D8
; ---------------------------------------------------------------------------

loc_755:				; CODE XREF: _do_server+6Aj
		push	0		; how
		push	edi		; s
		call	dword ptr ds:__imp__shutdown@8 ; shutdown(x,x)
		push	edi		; s
		call	dword ptr ds:__imp__closesocket@4 ; closesocket(x)
		pop	ebx
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebp
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_76F:				; CODE XREF: _do_server+C1j
					; _do_server+C5j
		push	2		; how
		push	edi		; s
		call	dword ptr ds:__imp__shutdown@8 ; shutdown(x,x)
		push	edi		; s
		call	dword ptr ds:__imp__closesocket@4 ; closesocket(x)
		pop	ebx
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebp
		add	esp, 0Ch
		retn
_do_server	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 78Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl extract_host_port(char *Str, int,	int, int)
		public _extract_host_port
_extract_host_port proc	near

Str		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	esi
		push	edi
		mov	edi, [esp+8+Str]
		push	3Ah ; ':'       ; Val
		push	edi		; Str
		call	dword ptr ds:__imp__strchr
		mov	esi, eax
		add	esp, 8
		test	esi, esi
		jnz	short loc_7BC
		push	offset ??_C@_0BB@PAFGOIEM@no?5port?5defined?6?$AA@ ; "no port defined\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 8

$err$8:					; CODE XREF: _extract_host_port+48j
					; _extract_host_port+63j
		pop	edi
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_7BC:				; CODE XREF: _extract_host_port+16j
		mov	eax, [esp+8+arg_8]
		mov	byte ptr [esi],	0
		inc	esi
		test	eax, eax
		jz	short loc_7D6
		push	eax		; int
		push	edi		; Src
		call	_host_ip
		add	esp, 8
		test	eax, eax
		jz	short $err$8

loc_7D6:				; CODE XREF: _extract_host_port+3Aj
		mov	eax, [esp+8+arg_4]
		test	eax, eax
		jz	short loc_7E0
		mov	[eax], edi

loc_7E0:				; CODE XREF: _extract_host_port+50j
		push	[esp+8+arg_C]	; int
		push	esi		; Str
		call	_extract_port
		add	esp, 8
		test	eax, eax
		jz	short $err$8
		pop	edi
		mov	eax, 1
		pop	esi
		retn
_extract_host_port endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7FCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl extract_port(char	*Str, int)
		public _extract_port
_extract_port	proc near		; CODE XREF: _extract_host_port+59p

Str		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+Str]
		push	esi		; Str
		call	dword ptr ds:__imp__atoi
		add	esp, 4
		test	eax, eax
		jnz	short loc_842
		push	offset ??_C@_03FPEIBLKH@tcp?$AA@ ; "tcp"
		push	esi		; name
		call	dword ptr ds:__imp__getservbyname@8 ; getservbyname(x,x)
		test	eax, eax
		jnz	short loc_837
		push	esi
		push	offset ??_C@_0BO@LLFMNAII@getservbyname?5failure?5for?5?$CFs?6?$AA@ ; "getservbyname failure for %s\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 0Ch
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_837:				; CODE XREF: _extract_port+21j
		movzx	eax, word ptr [eax+8]
		push	eax		; netshort
		call	dword ptr ds:__imp__ntohs@4 ; ntohs(x)

loc_842:				; CODE XREF: _extract_port+11j
		mov	ecx, [esp+4+arg_4]
		pop	esi
		mov	[ecx], ax
		mov	eax, 1
		retn
_extract_port	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 850h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl host_ip(char *Src, int)
_host_ip	proc near		; CODE XREF: _extract_host_port+3Ep
					; _init_client+19p

var_14		= dword	ptr -14h
var_10		= byte ptr -10h
var_C		= byte ptr -0Ch
var_8		= byte ptr -8
var_4		= dword	ptr -4
Src		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 14h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+14h+var_4], eax
		push	esi
		mov	esi, [esp+18h+arg_4]
		lea	eax, [esp+18h+var_8]
		push	edi
		mov	edi, [esp+1Ch+Src]
		push	eax
		lea	eax, [esp+20h+var_C]
		push	eax
		lea	eax, [esp+24h+var_10]
		push	eax
		lea	eax, [esp+28h+var_14]
		push	eax
		push	offset ??_C@_0M@CDHNGIPM@?$CFu?4?$CFu?4?$CFu?4?$CFu?$AA@ ; "%u.%u.%u.%u"
		push	edi		; Src
		call	_sscanf
		add	esp, 18h
		cmp	eax, 4
		jnz	short loc_8D5
		xor	eax, eax
		nop	dword ptr [eax+eax+00000000h]

loc_8A0:				; CODE XREF: _host_ip+5Ej
		cmp	[esp+eax*4+1Ch+var_14],	0FFh
		ja	short loc_8CE
		inc	eax
		cmp	eax, 4
		jl	short loc_8A0
		movzx	eax, byte ptr [esp+1Ch+var_14]
		mov	[esi], al
		movzx	eax, [esp+1Ch+var_10]
		mov	[esi+1], al
		movzx	eax, [esp+1Ch+var_C]
		mov	[esi+2], al
		movzx	eax, [esp+1Ch+var_8]
		jmp	short loc_94C
; ---------------------------------------------------------------------------

loc_8CE:				; CODE XREF: _host_ip+58j
		push	offset ??_C@_0BE@FPJHGDHG@invalid?5IP?5address?6?$AA@ ;	"invalid IP address\n"
		jmp	short loc_900
; ---------------------------------------------------------------------------

loc_8D5:				; CODE XREF: _host_ip+44j
		call	_ssl_sock_init
		test	eax, eax
		jz	short $err$31
		push	edi		; Str1
		call	_GetHostByName
		mov	ecx, eax
		add	esp, 4
		test	ecx, ecx
		jnz	short loc_8F4
		push	offset ??_C@_0BH@PFCDHECA@gethostbyname?5failure?6?$AA@	; "gethostbyname failure\n"
		jmp	short loc_900
; ---------------------------------------------------------------------------

loc_8F4:				; CODE XREF: _host_ip+9Bj
		cmp	word ptr [ecx+8], 2
		jz	short loc_921
		push	offset ??_C@_0CD@LJHAJJJN@gethostbyname?5addr?5is?5not?5AF_INE@	; "gethostbyname addr is not AF_INET\n"

loc_900:				; CODE XREF: _host_ip+83j _host_ip+A2j
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 8

$err$31:				; CODE XREF: _host_ip+8Cj
		pop	edi
		xor	eax, eax
		pop	esi
		mov	ecx, [esp+14h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_921:				; CODE XREF: _host_ip+A9j
		mov	eax, [ecx+0Ch]
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		mov	[esi], al
		mov	eax, [ecx+0Ch]
		mov	eax, [eax]
		movzx	eax, byte ptr [eax+1]
		mov	[esi+1], al
		mov	eax, [ecx+0Ch]
		mov	eax, [eax]
		movzx	eax, byte ptr [eax+2]
		mov	[esi+2], al
		mov	eax, [ecx+0Ch]
		mov	eax, [eax]
		movzx	eax, byte ptr [eax+3]

loc_94C:				; CODE XREF: _host_ip+7Cj
		mov	ecx, [esp+1Ch+var_4]
		mov	[esi+3], al
		mov	eax, 1
		pop	edi
		pop	esi
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
_host_ip	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 968h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl init_client(int, char *Src, u_short hostshort, int)
		public _init_client
_init_client	proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
Src		= dword	ptr  8
hostshort	= word ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, 4
		call	__chkstk
		lea	eax, [esp+4+var_4]
		mov	[esp+4+var_4], 0
		push	eax		; int
		push	[esp+8+Src]	; Src
		call	_host_ip
		add	esp, 8
		test	eax, eax
		jnz	short loc_98F
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_98F:				; CODE XREF: _init_client+23j
		push	[esp+4+arg_C]	; int
		lea	eax, [esp+8+var_4]
		push	dword ptr [esp+8+hostshort] ; hostshort
		push	eax		; int
		push	[esp+10h+arg_0]	; int
		call	_init_client_ip
		add	esp, 10h
		pop	ecx
		retn
_init_client	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 9ACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl init_client_ip(int, int, u_short hostshort, int)
_init_client_ip	proc near		; CODE XREF: _init_client+38p

optval		= byte ptr -18h
name		= sockaddr ptr -14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
hostshort	= word ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, 18h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+18h+var_4], eax
		push	esi
		mov	esi, [esp+1Ch+arg_4]
		push	edi
		mov	edi, [esp+20h+arg_0]
		call	_ssl_sock_init
		test	eax, eax
		jz	short loc_A4C
		push	dword ptr [esp+20h+hostshort] ;	hostshort
		xorps	xmm0, xmm0
		mov	eax, 2
		movups	xmmword	ptr [esp+24h+name.sa_family], xmm0
		mov	[esp+24h+name.sa_family], ax
		call	dword ptr ds:__imp__htons@4 ; htons(x)
		movzx	ecx, byte ptr [esi]
		shl	ecx, 8
		mov	word ptr [esp+20h+name.sa_data], ax
		movzx	eax, byte ptr [esi+1]
		or	ecx, eax
		movzx	eax, byte ptr [esi+2]
		shl	ecx, 8
		or	ecx, eax
		movzx	eax, byte ptr [esi+3]
		shl	ecx, 8
		or	ecx, eax
		push	ecx		; hostlong
		call	dword ptr ds:__imp__htonl@4 ; htonl(x)
		cmp	[esp+20h+arg_C], 1
		mov	dword ptr [esp+20h+name.sa_data+2], eax
		jnz	short loc_A2B
		push	6
		push	1
		jmp	short loc_A2F
; ---------------------------------------------------------------------------

loc_A2B:				; CODE XREF: _init_client_ip+77j
		push	11h		; protocol
		push	2		; type

loc_A2F:				; CODE XREF: _init_client_ip+7Dj
		push	2		; af
		call	dword ptr ds:__imp__socket@12 ;	socket(x,x,x)
		mov	esi, eax
		cmp	esi, 0FFFFFFFFh
		jnz	short loc_A5F
		push	offset ??_C@_06HBELJPBO@socket?$AA@ ; "socket"
		call	dword ptr ds:__imp__perror
		add	esp, 4

loc_A4C:				; CODE XREF: _init_client_ip+26j
		pop	edi
		xor	eax, eax
		pop	esi
		mov	ecx, [esp+18h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 18h
		retn
; ---------------------------------------------------------------------------

loc_A5F:				; CODE XREF: _init_client_ip+90j
		cmp	[esp+20h+arg_C], 1
		jnz	short loc_AB3
		push	4		; optlen
		lea	eax, [esp+24h+optval]
		mov	dword ptr [esp+24h+optval], 0
		push	eax		; optval
		push	8		; optname
		push	0FFFFh		; level
		push	esi		; s
		call	dword ptr ds:__imp__setsockopt@20 ; setsockopt(x,x,x,x,x)
		mov	dword ptr [esp+20h+optval], eax
		test	eax, eax
		jns	short loc_AB3
		push	esi		; s
		call	dword ptr ds:__imp__closesocket@4 ; closesocket(x)
		push	offset ??_C@_09MGFHKHCL@keepalive?$AA@ ; "keepalive"
		call	dword ptr ds:__imp__perror
		add	esp, 4
		xor	eax, eax
		pop	edi
		pop	esi
		mov	ecx, [esp+18h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 18h
		retn
; ---------------------------------------------------------------------------

loc_AB3:				; CODE XREF: _init_client_ip+B8j
					; _init_client_ip+DDj
		push	10h		; namelen
		lea	eax, [esp+24h+name]
		push	eax		; name
		push	esi		; s
		call	dword ptr ds:__imp__connect@12 ; connect(x,x,x)
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_AEE
		push	esi		; s
		call	dword ptr ds:__imp__closesocket@4 ; closesocket(x)
		push	offset ??_C@_07KAIBNCHO@connect?$AA@ ; "connect"
		call	dword ptr ds:__imp__perror
		add	esp, 4
		xor	eax, eax
		pop	edi
		pop	esi
		mov	ecx, [esp+18h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 18h
		retn
; ---------------------------------------------------------------------------

loc_AEE:				; CODE XREF: _init_client_ip+118j
		mov	ecx, [esp+20h+var_4]
		mov	eax, 1
		mov	[edi], esi
		pop	edi
		pop	esi
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 18h
		retn
_init_client_ip	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B08h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl init_server(int, u_short hostshort, int)
_init_server	proc near

arg_0		= dword	ptr  4
hostshort	= word ptr  8
arg_8		= dword	ptr  0Ch

		push	[esp+arg_8]	; int
		push	0		; int
		push	dword ptr [esp+8+hostshort] ; hostshort
		push	[esp+0Ch+arg_0]	; int
		call	_init_server_long
		add	esp, 10h
		retn
_init_server	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B20h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl init_server_long(int, u_short hostshort, int, int)
_init_server_long proc near		; CODE XREF: _do_server+25p
					; _init_server+Ep

optval		= byte ptr -18h
name		= sockaddr ptr -14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
hostshort	= word ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, 18h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+18h+var_4], eax
		push	ebx
		push	ebp
		mov	ebp, [esp+20h+arg_0]
		xor	ebx, ebx
		push	esi
		mov	esi, [esp+24h+arg_8]
		call	_ssl_sock_init
		test	eax, eax
		jnz	short loc_B5D
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+18h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 18h
		retn
; ---------------------------------------------------------------------------

loc_B5D:				; CODE XREF: _init_server_long+29j
		push	dword ptr [esp+24h+hostshort] ;	hostshort
		xorps	xmm0, xmm0
		mov	eax, 2
		movups	xmmword	ptr [esp+28h+name.sa_family], xmm0
		mov	[esp+28h+name.sa_family], ax
		call	dword ptr ds:__imp__htons@4 ; htons(x)
		mov	word ptr [esp+24h+name.sa_data], ax
		test	esi, esi
		jnz	short loc_B88
		mov	dword ptr [esp+24h+name.sa_data+2], ebx
		jmp	short loc_B8E
; ---------------------------------------------------------------------------

loc_B88:				; CODE XREF: _init_server_long+60j
		mov	eax, [esi]
		mov	dword ptr [esp+24h+name.sa_data+2], eax

loc_B8E:				; CODE XREF: _init_server_long+66j
		cmp	[esp+24h+arg_C], 1
		jnz	short loc_B9B
		push	6
		push	1
		jmp	short loc_B9F
; ---------------------------------------------------------------------------

loc_B9B:				; CODE XREF: _init_server_long+73j
		push	11h		; protocol
		push	2		; type

loc_B9F:				; CODE XREF: _init_server_long+79j
		push	2		; af
		call	dword ptr ds:__imp__socket@12 ;	socket(x,x,x)
		mov	esi, eax
		cmp	esi, 0FFFFFFFFh
		jz	short loc_C12
		push	4		; optlen
		lea	eax, [esp+28h+optval]
		mov	dword ptr [esp+28h+optval], 1
		push	eax		; optval
		push	4		; optname
		push	0FFFFh		; level
		push	esi		; s
		call	dword ptr ds:__imp__setsockopt@20 ; setsockopt(x,x,x,x,x)
		push	10h		; namelen
		lea	eax, [esp+28h+name]
		push	eax		; name
		push	esi		; s
		call	dword ptr ds:__imp__bind@12 ; bind(x,x,x)
		cmp	eax, 0FFFFFFFFh
		jz	short loc_C12
		cmp	[esp+24h+arg_C], 1
		jnz	short loc_BF6
		push	80h ; '€'       ; backlog
		push	esi		; s
		call	dword ptr ds:__imp__listen@8 ; listen(x,x)
		cmp	eax, 0FFFFFFFFh
		jz	short loc_C12

loc_BF6:				; CODE XREF: _init_server_long+C3j
		mov	[ebp+0], esi
		mov	ebx, 1
		pop	esi
		pop	ebp
		mov	eax, ebx
		pop	ebx
		mov	ecx, [esp+18h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 18h
		retn
; ---------------------------------------------------------------------------

loc_C12:				; CODE XREF: _init_server_long+8Cj
					; _init_server_long+BCj ...
		cmp	esi, 0FFFFFFFFh
		jz	short loc_C27
		push	0		; how
		push	esi		; s
		call	dword ptr ds:__imp__shutdown@8 ; shutdown(x,x)
		push	esi		; s
		call	dword ptr ds:__imp__closesocket@4 ; closesocket(x)

loc_C27:				; CODE XREF: _init_server_long+F5j
		mov	ecx, [esp+24h+var_4]
		mov	eax, ebx
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 18h
		retn
_init_server_long endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C3Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int sscanf(const char	*Src, const char *Format, ...)
		public _sscanf
_sscanf		proc near		; CODE XREF: _host_ip+39p

Src		= dword	ptr  4
Format		= dword	ptr  8
arg_8		= byte ptr  0Ch

		lea	eax, [esp+arg_8]
		push	eax
		push	0
		push	[esp+8+Format]
		push	0FFFFFFFFh
		push	[esp+10h+Src]
		call	___local_stdio_scanf_options
		push	dword ptr [eax+4]
		push	dword ptr [eax]
		call	dword ptr ds:__imp____stdio_common_vsscanf
		add	esp, 1Ch
		retn
_sscanf		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C64h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssl_sock_cleanup proc near		; DATA XREF: _ssl_sock_init+9o
		cmp	ds:_wsa_init_done, 0
		jz	short locret_C83
		mov	ds:_wsa_init_done, 0
		call	dword ptr ds:__imp__WSACancelBlockingCall@0 ; WSACancelBlockingCall()
		jmp	dword ptr ds:__imp__WSACleanup@0 ; WSACleanup()
; ---------------------------------------------------------------------------

locret_C83:				; CODE XREF: _ssl_sock_cleanup+7j
		retn
_ssl_sock_cleanup endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C84h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssl_sock_init	proc near		; CODE XREF: _do_accept+Ap
					; _host_ip:loc_8D5p ...
		cmp	ds:_wsa_init_done, 0
		jnz	short loc_CE9
		push	offset _ssl_sock_cleanup
		push	2
		call	dword ptr ds:__imp__signal
		push	190h		; Size
		push	0		; Val
		push	offset _wsa_state ; Dst
		mov	ds:_wsa_init_done, 1
		call	_memset
		add	esp, 14h
		push	offset _wsa_state ; lpWSAData
		push	101h		; wVersionRequested
		call	dword ptr ds:__imp__WSAStartup@8 ; WSAStartup(x,x)
		test	eax, eax
		jz	short loc_CE9
		call	dword ptr ds:__imp__WSAGetLastError@0 ;	WSAGetLastError()
		push	eax
		push	offset ??_C@_0CI@CMJAJOMD@unable?5to?5start?5WINSOCK?0?5error?5c@ ; "unable to start WINSOCK, error code=%d\"...
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 0Ch
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_CE9:				; CODE XREF: _ssl_sock_init+7j
					; _ssl_sock_init+46j
		mov	eax, 1
		retn
_ssl_sock_init	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CF0h
; COMDAT (pick any)
		public ??_C@_0CI@CMJAJOMD@unable?5to?5start?5WINSOCK?0?5error?5c@
; `string'
??_C@_0CI@CMJAJOMD@unable?5to?5start?5WINSOCK?0?5error?5c@ db 'unable to start WINSOCK, error code=%d',0Ah,0
					; DATA XREF: _ssl_sock_init+4Fo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D18h
; COMDAT (pick any)
		public ??_C@_06HBELJPBO@socket?$AA@
; char `string'[]
??_C@_06HBELJPBO@socket?$AA@ db	'socket',0 ; DATA XREF: _init_client_ip+92o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D20h
; COMDAT (pick any)
		public ??_C@_09MGFHKHCL@keepalive?$AA@
; char `string'[]
??_C@_09MGFHKHCL@keepalive?$AA@	db 'keepalive',0 ; DATA XREF: _init_client_ip+E6o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D2Ch
; COMDAT (pick any)
		public ??_C@_07KAIBNCHO@connect?$AA@
; char `string'[]
??_C@_07KAIBNCHO@connect?$AA@ db 'connect',0 ; DATA XREF: _init_client_ip+121o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D34h
; COMDAT (pick any)
		public ??_C@_0BB@ENCFPFEO@accept?5error?5?$CFd?6?$AA@
; `string'
??_C@_0BB@ENCFPFEO@accept?5error?5?$CFd?6?$AA@ db 'accept error %d',0Ah,0
					; DATA XREF: _do_accept+4Ao
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D48h
; COMDAT (pick any)
		public ??_C@_0BD@IODBLNBJ@bad?5gethostbyaddr?6?$AA@
; `string'
??_C@_0BD@IODBLNBJ@bad?5gethostbyaddr?6?$AA@ db	'bad gethostbyaddr',0Ah,0
					; DATA XREF: _do_accept+81o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D5Ch
; COMDAT (pick any)
		public ??_C@_0BC@LIAOONEC@?4?2apps?2s_socket?4c?$AA@
; `string'
??_C@_0BC@LIAOONEC@?4?2apps?2s_socket?4c?$AA@ db '.\apps\s_socket.c',0
					; DATA XREF: _do_accept+BEo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D70h
; COMDAT (pick any)
		public ??_C@_0P@OGNLMJHA@OPENSSL_malloc?$AA@
; char `string'[]
??_C@_0P@OGNLMJHA@OPENSSL_malloc?$AA@ db 'OPENSSL_malloc',0 ; DATA XREF: _do_accept+D7o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D80h
; COMDAT (pick any)
		public ??_C@_0BH@PFCDHECA@gethostbyname?5failure?6?$AA@
; `string'
??_C@_0BH@PFCDHECA@gethostbyname?5failure?6?$AA@ db 'gethostbyname failure',0Ah,0
					; DATA XREF: _do_accept+123o
					; _host_ip+9Do
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D98h
; COMDAT (pick any)
		public ??_C@_0CD@LJHAJJJN@gethostbyname?5addr?5is?5not?5AF_INE@
; `string'
??_C@_0CD@LJHAJJJN@gethostbyname?5addr?5is?5not?5AF_INE@ db 'gethostbyname addr is not AF_INET',0Ah,0
					; DATA XREF: _do_accept+135o
					; _host_ip+ABo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DBCh
; COMDAT (pick any)
		public ??_C@_0BB@PAFGOIEM@no?5port?5defined?6?$AA@
; `string'
??_C@_0BB@PAFGOIEM@no?5port?5defined?6?$AA@ db 'no port defined',0Ah,0
					; DATA XREF: _extract_host_port+18o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DD0h
; COMDAT (pick any)
		public ??_C@_0M@CDHNGIPM@?$CFu?4?$CFu?4?$CFu?4?$CFu?$AA@
; char `string'[]
??_C@_0M@CDHNGIPM@?$CFu?4?$CFu?4?$CFu?4?$CFu?$AA@ db '%u.%u.%u.%u',0
					; DATA XREF: _host_ip+33o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DDCh
; COMDAT (pick any)
		public ??_C@_0BE@FPJHGDHG@invalid?5IP?5address?6?$AA@
; `string'
??_C@_0BE@FPJHGDHG@invalid?5IP?5address?6?$AA@ db 'invalid IP address',0Ah,0
					; DATA XREF: _host_ip:loc_8CEo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DF0h
; COMDAT (pick any)
		public ??_C@_03FPEIBLKH@tcp?$AA@
; char `string'[]
??_C@_03FPEIBLKH@tcp?$AA@ db 'tcp',0    ; DATA XREF: _extract_port+13o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DF4h
; COMDAT (pick any)
		public ??_C@_0BO@LLFMNAII@getservbyname?5failure?5for?5?$CFs?6?$AA@
; `string'
??_C@_0BO@LLFMNAII@getservbyname?5failure?5for?5?$CFs?6?$AA@ db	'getservbyname failure for %s',0Ah,0
					; DATA XREF: _extract_port+24o
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; void __cdecl _perror(const char *ErrMsg)
		extrn __imp__perror:near ; CODE	XREF: _do_accept+DCp
					; _init_client_ip+97p ...
		extrn __imp____stdio_common_vsscanf:near ; CODE	XREF: __vsscanf_l+1Cp
					; _sscanf+1Bp
					; DATA XREF: ...
; int __cdecl _atoi(const char *Str)
		extrn __imp__atoi:near	; CODE XREF: _extract_port+6p
					; DATA XREF: _extract_port+6r
; char *__cdecl	_strchr(const char *Str, int Val)
		extrn __imp__strchr:near ; CODE	XREF: _extract_host_port+9p
					; DATA XREF: _extract_host_port+9r
; int __cdecl _strncmp(const char *Str1, const char *Str2, size_t MaxCount)
		extrn __imp__strncmp:near ; CODE XREF: _GetHostByName+3Fp
					; DATA XREF: _GetHostByName+3Fr
		extrn __imp__signal:near ; CODE	XREF: _ssl_sock_init+10p
					; DATA XREF: _ssl_sock_init+10r
; SOCKET __stdcall accept(SOCKET s, struct sockaddr *addr, int *addrlen)
		extrn __imp__accept@12:near ; CODE XREF: _do_accept+36p
					; DATA XREF: _do_accept+36r
; int __stdcall	bind(SOCKET s, const struct sockaddr *name, int	namelen)
		extrn __imp__bind@12:near ; CODE XREF: _init_server_long+B3p
					; DATA XREF: _init_server_long+B3r
; int __stdcall	closesocket(SOCKET s)
		extrn __imp__closesocket@4:near	; CODE XREF: _do_accept+E6p
					; _do_accept+149p ...
; int __stdcall	connect(SOCKET s, const	struct sockaddr	*name, int namelen)
		extrn __imp__connect@12:near ; CODE XREF: _init_client_ip+10Fp
					; DATA XREF: _init_client_ip+10Fr
; u_long __stdcall htonl(u_long	hostlong)
		extrn __imp__htonl@4:near ; CODE XREF: _init_client_ip+68p
					; DATA XREF: _init_client_ip+68r
; u_short __stdcall htons(u_short hostshort)
		extrn __imp__htons@4:near ; CODE XREF: _init_client_ip+3Ep
					; _init_server_long+53p
					; DATA XREF: ...
; int __stdcall	listen(SOCKET s, int backlog)
		extrn __imp__listen@8:near ; CODE XREF:	_init_server_long+CBp
					; DATA XREF: _init_server_long+CBr
; u_short __stdcall ntohs(u_short netshort)
		extrn __imp__ntohs@4:near ; CODE XREF: _extract_port+40p
					; DATA XREF: _extract_port+40r
; int __stdcall	setsockopt(SOCKET s, int level,	int optname, const char	*optval, int optlen)
		extrn __imp__setsockopt@20:near	; CODE XREF: _init_client_ip+D1p
					; _init_server_long+A5p
					; DATA XREF: ...
; int __stdcall	shutdown(SOCKET	s, int how)
		extrn __imp__shutdown@8:near ; CODE XREF: _do_server+A8p
					; _do_server+D0p ...
; SOCKET __stdcall socket(int af, int type, int	protocol)
		extrn __imp__socket@12:near ; CODE XREF: _init_client_ip+85p
					; _init_server_long+81p
					; DATA XREF: ...
; struct hostent *__stdcall gethostbyaddr(const	char *addr, int	len, int type)
		extrn __imp__gethostbyaddr@12:near ; CODE XREF:	_do_accept+75p
					; DATA XREF: _do_accept+75r
; struct hostent *__stdcall gethostbyname(const	char *name)
		extrn __imp__gethostbyname@4:near ; CODE XREF: _GetHostByName+67p
					; DATA XREF: _GetHostByName+67r
; struct servent *__stdcall getservbyname(const	char *name, const char *proto)
		extrn __imp__getservbyname@8:near ; CODE XREF: _extract_port+19p
					; DATA XREF: _extract_port+19r
; int __stdcall	WSAStartup(WORD	wVersionRequested, LPWSADATA lpWSAData)
		extrn __imp__WSAStartup@8:near ; CODE XREF: _ssl_sock_init+3Ep
					; DATA XREF: _ssl_sock_init+3Er
; int __stdcall	WSACleanup()
		extrn __imp__WSACleanup@0:near ; DATA XREF: _ssl_sock_cleanup+19r
; int __stdcall	WSAGetLastError()
		extrn __imp__WSAGetLastError@0:near ; CODE XREF: _do_accept+43p
					; _ssl_sock_init+48p
					; DATA XREF: ...
; int __stdcall	WSACancelBlockingCall()
		extrn __imp__WSACancelBlockingCall@0:near ; CODE XREF: _ssl_sock_cleanup+13p
					; DATA XREF: _ssl_sock_cleanup+13r
		extrn _CRYPTO_malloc:near ; CODE XREF: _do_accept+C7p
		extrn _CRYPTO_free:near	; CODE XREF: _do_server+96p
		extrn _BIO_printf:near	; CODE XREF: _do_accept+55p
					; _do_accept+8Cp ...
		extrn _BUF_strlcpy:near	; CODE XREF: _do_accept+10Fp
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _host_ip+C8p
					; _host_ip+10Cp ...
		extrn __chkstk:near	; CODE XREF: _GetHostByName+5p
					; _do_accept+5p ...
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _ssl_sock_init+2Cp
; `__local_stdio_scanf_options'::`2'::_OptionsStorage
		extrn ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:near
					; DATA XREF: ___local_stdio_scanf_optionso
		extrn _bio_err:near	; DATA XREF: _do_accept+4Fr
					; _do_accept+86r ...
		extrn ___security_cookie:near ;	DATA XREF: _host_ip+Ar
					; _init_client_ip+Ar ...


		end
