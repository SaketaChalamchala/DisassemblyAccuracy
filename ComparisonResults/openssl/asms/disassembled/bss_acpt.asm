;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	B1E6B5D31F0D3E433E2DA15860D96953
; Input	CRC32 :	EE1C5B0A

; File Name   :	C:\compspace\Diff\openssl\obj\bss_acpt.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_acpt_write	proc near		; CODE XREF: _acpt_puts+1Fp
					; DATA XREF: .data:00000754o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	edi, [esp+10h+arg_0]
		push	0Fh
		push	edi
		call	_BIO_clear_flags
		mov	esi, [edi+20h]
		add	esp, 8
		cmp	dword ptr [edi+24h], 0
		jnz	loc_16D

$again$54:				; CODE XREF: _acpt_write+48j
					; _acpt_write+56j ...
		mov	eax, [esi]
		sub	eax, 1
		jz	loc_11C
		sub	eax, 1
		jz	short loc_4A
		sub	eax, 1
		jnz	loc_1B4
		cmp	[edi+24h], eax
		jnz	loc_16D
		mov	dword ptr [esi], 2
		jmp	short $again$54
; ---------------------------------------------------------------------------

loc_4A:					; CODE XREF: _acpt_write+2Ej
		cmp	dword ptr [edi+24h], 0
		jz	short loc_58
		mov	dword ptr [esi], 3
		jmp	short $again$54
; ---------------------------------------------------------------------------

loc_58:					; CODE XREF: _acpt_write+4Ej
		push	0Fh
		push	edi
		call	_BIO_clear_flags
		lea	eax, [esi+10h]
		mov	dword ptr [edi+18h], 0
		push	eax
		push	dword ptr [esi+8]
		call	_BIO_accept
		mov	ebx, eax
		add	esp, 10h
		cmp	ebx, 0FFFFFFFEh
		jz	loc_1BD
		test	ebx, ebx
		js	loc_209
		push	1
		push	ebx
		call	_BIO_new_socket
		mov	ebp, eax
		add	esp, 8
		test	ebp, ebp
		jz	loc_1B4
		push	edi
		call	_BIO_get_callback
		push	eax
		push	ebp
		call	_BIO_set_callback
		push	edi
		call	_BIO_get_callback_arg
		push	eax
		push	ebp
		call	_BIO_set_callback_arg
		add	esp, 18h
		cmp	dword ptr [esi+14h], 0
		jz	short loc_D4
		push	1
		push	ebx
		call	_BIO_socket_nbio
		add	esp, 8
		test	eax, eax
		jz	loc_18F

loc_D4:					; CODE XREF: _acpt_write+BFj
		mov	eax, [esi+1Ch]
		test	eax, eax
		jz	short loc_102
		push	eax
		call	_BIO_dup_chain
		mov	ebx, eax
		add	esp, 4
		test	ebx, ebx
		jz	$err$55
		push	ebp
		push	ebx
		call	_BIO_push
		add	esp, 8
		test	eax, eax
		jz	$err$55
		mov	ebp, ebx

loc_102:				; CODE XREF: _acpt_write+D9j
		push	ebp
		push	edi
		call	_BIO_push
		add	esp, 8
		test	eax, eax
		jz	$err$55
		mov	dword ptr [esi], 3
		jmp	short loc_163
; ---------------------------------------------------------------------------

loc_11C:				; CODE XREF: _acpt_write+25j
		mov	eax, [esi+4]
		test	eax, eax
		jz	loc_1EE
		push	dword ptr [esi+18h]
		push	eax
		call	_BIO_get_accept_socket
		mov	ebx, eax
		add	esp, 8
		cmp	ebx, 0FFFFFFFFh
		jz	loc_206
		cmp	dword ptr [esi+0Ch], 0
		jz	short loc_157
		push	1
		push	ebx
		call	_BIO_socket_nbio
		add	esp, 8
		test	eax, eax
		jz	loc_1D9

loc_157:				; CODE XREF: _acpt_write+142j
		mov	[esi+8], ebx
		mov	[edi+1Ch], ebx
		mov	dword ptr [esi], 2

loc_163:				; CODE XREF: _acpt_write+11Aj
		cmp	dword ptr [edi+24h], 0
		jz	$again$54

loc_16D:				; CODE XREF: _acpt_write+1Aj
					; _acpt_write+3Cj
		push	[esp+10h+arg_8]
		push	[esp+14h+arg_4]
		push	dword ptr [edi+24h]
		call	_BIO_write
		push	edi
		mov	esi, eax
		call	_BIO_copy_next_retry
		add	esp, 10h
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_18F:				; CODE XREF: _acpt_write+CEj
		push	103h
		push	offset ??_C@_0BI@GOELLJHH@?4?2crypto?2bio?2bss_acpt?4c?$AA@ ; ".\\crypto\\bio\\bss_acpt.c"
		push	69h ; 'i'
		push	64h ; 'd'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 14h

$err$55:				; CODE XREF: _acpt_write+E8j
					; _acpt_write+FAj ...
		test	ebp, ebp
		jz	short loc_1B4
		push	ebp
		call	_BIO_free
		add	esp, 4

loc_1B4:				; CODE XREF: _acpt_write+33j
					; _acpt_write+98j ...
		pop	edi
		pop	esi
		xor	ebx, ebx
		pop	ebp
		mov	eax, ebx
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1BD:				; CODE XREF: _acpt_write+7Bj
		push	0Ch
		push	edi
		call	_BIO_set_flags
		add	esp, 8
		mov	dword ptr [edi+18h], 3
		or	ebx, 0FFFFFFFFh
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1D9:				; CODE XREF: _acpt_write+151j
		push	ebx		; s
		call	dword ptr ds:__imp__closesocket@4 ; closesocket(x)
		push	0DDh ; 'Ý'
		push	offset ??_C@_0BI@GOELLJHH@?4?2crypto?2bio?2bss_acpt?4c?$AA@ ; ".\\crypto\\bio\\bss_acpt.c"
		push	6Ah ; 'j'
		jmp	short loc_1FA
; ---------------------------------------------------------------------------

loc_1EE:				; CODE XREF: _acpt_write+121j
		push	0D2h ; 'Ò'
		push	offset ??_C@_0BI@GOELLJHH@?4?2crypto?2bio?2bss_acpt?4c?$AA@ ; ".\\crypto\\bio\\bss_acpt.c"
		push	6Fh ; 'o'

loc_1FA:				; CODE XREF: _acpt_write+1ECj
		push	64h ; 'd'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 14h

loc_206:				; CODE XREF: _acpt_write+138j
		or	ebx, 0FFFFFFFFh

loc_209:				; CODE XREF: _acpt_write+83j
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, ebx
		pop	ebx
		retn
_acpt_write	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 210h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_acpt_read	proc near		; DATA XREF: .data:00000758o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	edi, [esp+10h+arg_0]
		push	0Fh
		push	edi
		call	_BIO_clear_flags
		mov	esi, [edi+20h]
		add	esp, 8
		cmp	dword ptr [edi+24h], 0
		jnz	loc_37D

$again$54_0:				; CODE XREF: _acpt_read+48j
					; _acpt_read+56j ...
		mov	eax, [esi]
		sub	eax, 1
		jz	loc_32C
		sub	eax, 1
		jz	short loc_25A
		sub	eax, 1
		jnz	loc_3C4
		cmp	[edi+24h], eax
		jnz	loc_37D
		mov	dword ptr [esi], 2
		jmp	short $again$54_0
; ---------------------------------------------------------------------------

loc_25A:				; CODE XREF: _acpt_read+2Ej
		cmp	dword ptr [edi+24h], 0
		jz	short loc_268
		mov	dword ptr [esi], 3
		jmp	short $again$54_0
; ---------------------------------------------------------------------------

loc_268:				; CODE XREF: _acpt_read+4Ej
		push	0Fh
		push	edi
		call	_BIO_clear_flags
		lea	eax, [esi+10h]
		mov	dword ptr [edi+18h], 0
		push	eax
		push	dword ptr [esi+8]
		call	_BIO_accept
		mov	ebx, eax
		add	esp, 10h
		cmp	ebx, 0FFFFFFFEh
		jz	loc_3CD
		test	ebx, ebx
		js	loc_419
		push	1
		push	ebx
		call	_BIO_new_socket
		mov	ebp, eax
		add	esp, 8
		test	ebp, ebp
		jz	loc_3C4
		push	edi
		call	_BIO_get_callback
		push	eax
		push	ebp
		call	_BIO_set_callback
		push	edi
		call	_BIO_get_callback_arg
		push	eax
		push	ebp
		call	_BIO_set_callback_arg
		add	esp, 18h
		cmp	dword ptr [esi+14h], 0
		jz	short loc_2E4
		push	1
		push	ebx
		call	_BIO_socket_nbio
		add	esp, 8
		test	eax, eax
		jz	loc_39F

loc_2E4:				; CODE XREF: _acpt_read+BFj
		mov	eax, [esi+1Ch]
		test	eax, eax
		jz	short loc_312
		push	eax
		call	_BIO_dup_chain
		mov	ebx, eax
		add	esp, 4
		test	ebx, ebx
		jz	$err$55_0
		push	ebp
		push	ebx
		call	_BIO_push
		add	esp, 8
		test	eax, eax
		jz	$err$55_0
		mov	ebp, ebx

loc_312:				; CODE XREF: _acpt_read+D9j
		push	ebp
		push	edi
		call	_BIO_push
		add	esp, 8
		test	eax, eax
		jz	$err$55_0
		mov	dword ptr [esi], 3
		jmp	short loc_373
; ---------------------------------------------------------------------------

loc_32C:				; CODE XREF: _acpt_read+25j
		mov	eax, [esi+4]
		test	eax, eax
		jz	loc_3FE
		push	dword ptr [esi+18h]
		push	eax
		call	_BIO_get_accept_socket
		mov	ebx, eax
		add	esp, 8
		cmp	ebx, 0FFFFFFFFh
		jz	loc_416
		cmp	dword ptr [esi+0Ch], 0
		jz	short loc_367
		push	1
		push	ebx
		call	_BIO_socket_nbio
		add	esp, 8
		test	eax, eax
		jz	loc_3E9

loc_367:				; CODE XREF: _acpt_read+142j
		mov	[esi+8], ebx
		mov	[edi+1Ch], ebx
		mov	dword ptr [esi], 2

loc_373:				; CODE XREF: _acpt_read+11Aj
		cmp	dword ptr [edi+24h], 0
		jz	$again$54_0

loc_37D:				; CODE XREF: _acpt_read+1Aj
					; _acpt_read+3Cj
		push	[esp+10h+arg_8]
		push	[esp+14h+arg_4]
		push	dword ptr [edi+24h]
		call	_BIO_read
		push	edi
		mov	esi, eax
		call	_BIO_copy_next_retry
		add	esp, 10h
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_39F:				; CODE XREF: _acpt_read+CEj
		push	103h
		push	offset ??_C@_0BI@GOELLJHH@?4?2crypto?2bio?2bss_acpt?4c?$AA@ ; ".\\crypto\\bio\\bss_acpt.c"
		push	69h ; 'i'
		push	64h ; 'd'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 14h

$err$55_0:				; CODE XREF: _acpt_read+E8j
					; _acpt_read+FAj ...
		test	ebp, ebp
		jz	short loc_3C4
		push	ebp
		call	_BIO_free
		add	esp, 4

loc_3C4:				; CODE XREF: _acpt_read+33j
					; _acpt_read+98j ...
		pop	edi
		pop	esi
		xor	ebx, ebx
		pop	ebp
		mov	eax, ebx
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_3CD:				; CODE XREF: _acpt_read+7Bj
		push	0Ch
		push	edi
		call	_BIO_set_flags
		add	esp, 8
		mov	dword ptr [edi+18h], 3
		or	ebx, 0FFFFFFFFh
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_3E9:				; CODE XREF: _acpt_read+151j
		push	ebx		; s
		call	dword ptr ds:__imp__closesocket@4 ; closesocket(x)
		push	0DDh ; 'Ý'
		push	offset ??_C@_0BI@GOELLJHH@?4?2crypto?2bio?2bss_acpt?4c?$AA@ ; ".\\crypto\\bio\\bss_acpt.c"
		push	6Ah ; 'j'
		jmp	short loc_40A
; ---------------------------------------------------------------------------

loc_3FE:				; CODE XREF: _acpt_read+121j
		push	0D2h ; 'Ò'
		push	offset ??_C@_0BI@GOELLJHH@?4?2crypto?2bio?2bss_acpt?4c?$AA@ ; ".\\crypto\\bio\\bss_acpt.c"
		push	6Fh ; 'o'

loc_40A:				; CODE XREF: _acpt_read+1ECj
		push	64h ; 'd'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 14h

loc_416:				; CODE XREF: _acpt_read+138j
		or	ebx, 0FFFFFFFFh

loc_419:				; CODE XREF: _acpt_read+83j
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, ebx
		pop	ebx
		retn
_acpt_read	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 420h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_acpt_puts	proc near		; DATA XREF: .data:0000075Co

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		mov	eax, edx
		push	esi
		lea	esi, [eax+1]
		nop	word ptr [eax+eax+00h]

loc_430:				; CODE XREF: _acpt_puts+15j
		mov	cl, [eax]
		inc	eax
		test	cl, cl
		jnz	short loc_430
		sub	eax, esi
		push	eax
		push	edx
		push	[esp+0Ch+arg_0]
		call	_acpt_write
		add	esp, 0Ch
		pop	esi
		retn
_acpt_puts	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 44Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_acpt_ctrl	proc near		; DATA XREF: .data:00000764o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, [esp+arg_4]
		push	ebx
		mov	ebx, [esp+4+arg_0]
		dec	eax
		push	ebp
		push	esi
		push	edi
		mov	esi, [ebx+20h]
		mov	edi, 1
		cmp	eax, 83h ; ''  ; switch 132 cases
		ja	$LN33		; jumptable 00000473 default case
		movzx	eax, ds:$LN35[eax]
		jmp	ds:$LN38[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN4:					; CODE XREF: _acpt_ctrl+27j
					; DATA XREF: .text$mn:$LN38o
		push	ebx		; jumptable 00000473 case 0
		xor	edi, edi
		mov	dword ptr [esi], 1
		call	_acpt_close_socket
		add	esp, 4
		mov	[ebx+14h], edi
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN5:					; CODE XREF: _acpt_ctrl+27j
					; DATA XREF: .text$mn:$LN38o
		push	esi		; jumptable 00000473 case 100
		push	ebx
		call	_acpt_state
		add	esp, 8
		mov	edi, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN6:					; CODE XREF: _acpt_ctrl+27j
					; DATA XREF: .text$mn:$LN38o
		mov	ebp, [esp+10h+arg_C] ; jumptable 00000473 case 117
		test	ebp, ebp
		jz	$LN2		; jumptable 00000473 cases 10,11
		mov	eax, [esp+10h+arg_8]
		test	eax, eax
		jnz	short loc_4E0
		mov	[ebx+0Ch], edi
		mov	eax, [esi+4]
		test	eax, eax
		jz	short loc_4CD
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_4CD:				; CODE XREF: _acpt_ctrl+76j
		push	ebp
		call	_BUF_strdup
		add	esp, 4
		mov	[esi+4], eax
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_4E0:				; CODE XREF: _acpt_ctrl+6Cj
		cmp	eax, 1
		jnz	short loc_4EF
		mov	[esi+0Ch], edi
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_4EF:				; CODE XREF: _acpt_ctrl+97j
		cmp	eax, 2
		jnz	$LN2		; jumptable 00000473 cases 10,11
		mov	eax, [esi+1Ch]
		test	eax, eax
		jz	short loc_508
		push	eax
		call	_BIO_free
		add	esp, 4

loc_508:				; CODE XREF: _acpt_ctrl+B1j
		mov	eax, edi
		mov	[esi+1Ch], ebp

loc_50D:				; DATA XREF: .data:_methods_acceptpo
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN15:					; CODE XREF: _acpt_ctrl+27j
					; DATA XREF: .text$mn:$LN38o
		mov	eax, [esp+10h+arg_8] ; jumptable 00000473 case 101
		mov	[esi+14h], eax
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN16:					; CODE XREF: _acpt_ctrl+27j
					; DATA XREF: .text$mn:$LN38o
		mov	eax, [esp+10h+arg_C] ; jumptable 00000473 case 103
		mov	[ebx+0Ch], edi
		mov	eax, [eax]
		mov	[ebx+1Ch], eax
		mov	[esi+8], eax
		mov	eax, [esp+10h+arg_8]
		mov	dword ptr [esi], 2
		mov	[ebx+10h], eax
		mov	eax, edi
		mov	[ebx+0Ch], edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN17:					; CODE XREF: _acpt_ctrl+27j
					; DATA XREF: .text$mn:$LN38o
		cmp	dword ptr [ebx+0Ch], 0 ; jumptable 00000473 case 104
		jz	short loc_563
		mov	ecx, [esp+10h+arg_C]
		test	ecx, ecx
		jz	short loc_559
		mov	eax, [esi+8]
		mov	[ecx], eax

loc_559:				; CODE XREF: _acpt_ctrl+106j
		mov	edi, [esi+8]
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_563:				; CODE XREF: _acpt_ctrl+FEj
					; _acpt_ctrl+125j ...
		or	edi, 0FFFFFFFFh
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN21:					; CODE XREF: _acpt_ctrl+27j
					; DATA XREF: .text$mn:$LN38o
		cmp	dword ptr [ebx+0Ch], 0 ; jumptable 00000473 case 123
		jz	short loc_563
		mov	ecx, [esp+10h+arg_C]
		test	ecx, ecx
		jz	short loc_563
		mov	eax, [esi+4]
		mov	[ecx], eax
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN26:					; CODE XREF: _acpt_ctrl+27j
					; DATA XREF: .text$mn:$LN38o
		mov	edi, [ebx+10h]	; jumptable 00000473 case 7
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN27:					; CODE XREF: _acpt_ctrl+27j
					; DATA XREF: .text$mn:$LN38o
		mov	eax, [esp+10h+arg_8] ; jumptable 00000473 case 8
		mov	[ebx+10h], eax
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN30:					; CODE XREF: _acpt_ctrl+27j
					; DATA XREF: .text$mn:$LN38o
		mov	eax, [esp+10h+arg_8] ; jumptable 00000473 case 130
		mov	[esi+18h], eax
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN31:					; CODE XREF: _acpt_ctrl+27j
					; DATA XREF: .text$mn:$LN38o
		mov	edi, [esi+18h]	; jumptable 00000473 case 131
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN33:					; CODE XREF: _acpt_ctrl+1Aj
					; _acpt_ctrl+27j
					; DATA XREF: ...
		xor	edi, edi	; jumptable 00000473 default case

$LN2:					; CODE XREF: _acpt_ctrl+27j
					; _acpt_ctrl+60j ...
		mov	eax, edi	; jumptable 00000473 cases 10,11
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_acpt_ctrl	endp

; ---------------------------------------------------------------------------
$LN38		dd offset $LN4,	offset $LN26, offset $LN27, offset $LN33
					; DATA XREF: _acpt_ctrl+27r
		dd offset $LN2,	offset $LN5, offset $LN15, offset $LN16	; jump table for switch	statement
		dd offset $LN17, offset	$LN6, offset $LN21, offset $LN30
		dd offset $LN31, offset	$LN33
$LN35		db	0,   0Dh,   0Dh,   0Dh ; DATA XREF: _acpt_ctrl+20r
		db    0Dh,   0Dh,   0Dh,     1 ; indirect table	for switch statement
		db	2,     3,     4,     4
		db	3,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db	5,     6,   0Dh,     7
		db	8,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,     9,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Dh,   0Ah
		db    0Dh,   0Dh,   0Dh,   0Dh
		db    0Dh,   0Dh,   0Bh,   0Ch
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 67Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_acpt_new	proc near		; DATA XREF: .data:00000768o

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		push	92h ; ''
		push	offset ??_C@_0BI@GOELLJHH@?4?2crypto?2bio?2bss_acpt?4c?$AA@ ; ".\\crypto\\bio\\bss_acpt.c"
		push	20h ; ' '
		mov	dword ptr [esi+0Ch], 0
		mov	dword ptr [esi+1Ch], 0FFFFFFFFh
		mov	dword ptr [esi+14h], 0
		call	_CRYPTO_malloc
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_6DD
		xorps	xmm0, xmm0
		movups	xmmword	ptr [eax], xmm0
		movups	xmmword	ptr [eax+10h], xmm0
		mov	dword ptr [eax+8], 0FFFFFFFFh
		mov	dword ptr [eax+18h], 0
		mov	[esi+20h], eax
		mov	dword ptr [eax], 1
		mov	eax, 1
		mov	dword ptr [esi+10h], 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_6DD:				; CODE XREF: _acpt_new+30j
		xor	eax, eax
		pop	esi
		retn
_acpt_new	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6E4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_acpt_free	proc near		; DATA XREF: .data:0000076Co

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jnz	short loc_6F1
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_6F1:				; CODE XREF: _acpt_free+7j
		cmp	dword ptr [esi+10h], 0
		push	edi
		mov	edi, [esi+20h]
		jz	short loc_741
		mov	eax, [edi+8]
		cmp	eax, 0FFFFFFFFh
		jz	short loc_723
		push	2		; how
		push	eax		; s
		call	dword ptr ds:__imp__shutdown@8 ; shutdown(x,x)
		push	dword ptr [edi+8] ; s
		call	dword ptr ds:__imp__closesocket@4 ; closesocket(x)
		mov	dword ptr [edi+8], 0FFFFFFFFh
		mov	dword ptr [esi+1Ch], 0FFFFFFFFh

loc_723:				; CODE XREF: _acpt_free+1Dj
		push	edi
		call	_BIO_ACCEPT_free
		add	esp, 4
		mov	dword ptr [esi+20h], 0
		mov	dword ptr [esi+14h], 0
		mov	dword ptr [esi+0Ch], 0

loc_741:				; CODE XREF: _acpt_free+15j
		pop	edi
		mov	eax, 1
		pop	esi
		retn
_acpt_free	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 74Ch
_methods_acceptp dd offset loc_50D	; DATA XREF: _BIO_new_accept+1o
					; _BIO_s_accepto
		dd offset ??_C@_0O@LAGOGLFJ@socket?5accept?$AA@	; "socket accept"
		dd offset _acpt_write
		dd offset _acpt_read
		dd offset _acpt_puts
		dd 0
		dd offset _acpt_ctrl
		dd offset _acpt_new
		dd offset _acpt_free
		dd 0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 774h
; COMDAT (pick any)
		public ??_C@_0O@LAGOGLFJ@socket?5accept?$AA@
; `string'
??_C@_0O@LAGOGLFJ@socket?5accept?$AA@ db 'socket accept',0 ; DATA XREF: .data:00000750o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 784h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_BIO_ACCEPT_free proc near		; CODE XREF: _acpt_free+40p

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	short loc_7C6
		mov	eax, [esi+4]
		test	eax, eax
		jz	short loc_79D
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_79D:				; CODE XREF: _BIO_ACCEPT_free+Ej
		mov	eax, [esi+10h]
		test	eax, eax
		jz	short loc_7AD
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_7AD:				; CODE XREF: _BIO_ACCEPT_free+1Ej
		mov	eax, [esi+1Ch]
		test	eax, eax
		jz	short loc_7BD
		push	eax
		call	_BIO_free
		add	esp, 4

loc_7BD:				; CODE XREF: _BIO_ACCEPT_free+2Ej
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_7C6:				; CODE XREF: _BIO_ACCEPT_free+7j
		pop	esi
		retn
_BIO_ACCEPT_free endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7C8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_BIO_ACCEPT_new	proc near
		push	92h ; ''
		push	offset ??_C@_0BI@GOELLJHH@?4?2crypto?2bio?2bss_acpt?4c?$AA@ ; ".\\crypto\\bio\\bss_acpt.c"
		push	20h ; ' '
		call	_CRYPTO_malloc
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_7E1
		retn
; ---------------------------------------------------------------------------

loc_7E1:				; CODE XREF: _BIO_ACCEPT_new+16j
		xorps	xmm0, xmm0
		movups	xmmword	ptr [eax], xmm0
		movups	xmmword	ptr [eax+10h], xmm0
		mov	dword ptr [eax+8], 0FFFFFFFFh
		mov	dword ptr [eax+18h], 0
		retn
_BIO_ACCEPT_new	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7FCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_new_accept
_BIO_new_accept	proc near

arg_0		= dword	ptr  4

		push	esi
		push	offset _methods_acceptp
		call	_BIO_new
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jz	short loc_832
		push	[esp+4+arg_0]
		push	0
		push	76h ; 'v'
		push	esi
		call	_BIO_ctrl
		add	esp, 10h
		test	eax, eax
		jz	short loc_829
		mov	eax, esi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_829:				; CODE XREF: _BIO_new_accept+27j
		push	esi
		call	_BIO_free
		add	esp, 4

loc_832:				; CODE XREF: _BIO_new_accept+12j
		xor	eax, eax
		pop	esi
		retn
_BIO_new_accept	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 838h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_s_accept
_BIO_s_accept	proc near
		mov	eax, offset _methods_acceptp
		retn
_BIO_s_accept	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 840h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_acpt_close_socket proc	near		; CODE XREF: _acpt_ctrl+37p

arg_0		= dword	ptr  4

		push	esi
		push	edi
		mov	edi, [esp+8+arg_0]
		mov	esi, [edi+20h]
		mov	eax, [esi+8]
		cmp	eax, 0FFFFFFFFh
		jz	short loc_871
		push	2		; how
		push	eax		; s
		call	dword ptr ds:__imp__shutdown@8 ; shutdown(x,x)
		push	dword ptr [esi+8] ; s
		call	dword ptr ds:__imp__closesocket@4 ; closesocket(x)
		mov	dword ptr [esi+8], 0FFFFFFFFh
		mov	dword ptr [edi+1Ch], 0FFFFFFFFh

loc_871:				; CODE XREF: _acpt_close_socket+Fj
		pop	edi
		pop	esi
		retn
_acpt_close_socket endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 874h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_acpt_state	proc near		; CODE XREF: _acpt_ctrl+4Bp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		push	esi
		mov	esi, [esp+8+arg_4]
		push	edi
		mov	edi, [esp+0Ch+arg_0]
		nop	dword ptr [eax+eax+00h]

$again$35:				; CODE XREF: _acpt_state+34j
					; _acpt_state+42j
		mov	eax, [esi]
		sub	eax, 1
		jz	loc_9BB
		sub	eax, 1
		jz	short loc_8AA
		sub	eax, 1
		jnz	short loc_8B8
		cmp	[edi+24h], eax
		jnz	loc_A3B
		mov	dword ptr [esi], 2
		jmp	short $again$35
; ---------------------------------------------------------------------------

loc_8AA:				; CODE XREF: _acpt_state+1Ej
		cmp	dword ptr [edi+24h], 0
		jz	short loc_8BE
		mov	dword ptr [esi], 3
		jmp	short $again$35
; ---------------------------------------------------------------------------

loc_8B8:				; CODE XREF: _acpt_state+23j
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_8BE:				; CODE XREF: _acpt_state+3Aj
		push	ebp
		push	0Fh
		push	edi
		call	_BIO_clear_flags
		lea	eax, [esi+10h]
		mov	dword ptr [edi+18h], 0
		push	eax
		push	dword ptr [esi+8]
		call	_BIO_accept
		mov	ebp, eax
		add	esp, 10h
		cmp	ebp, 0FFFFFFFEh
		jnz	short loc_8FE
		push	0Ch
		push	edi
		call	_BIO_set_flags
		add	esp, 8
		mov	dword ptr [edi+18h], 3
		or	eax, 0FFFFFFFFh

loc_8F9:				; CODE XREF: _acpt_state+8Cj
		pop	ebp
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_8FE:				; CODE XREF: _acpt_state+6Ej
		test	ebp, ebp
		js	short loc_8F9
		push	1
		push	ebp
		call	_BIO_new_socket
		mov	ebx, eax
		add	esp, 8
		test	ebx, ebx
		jz	loc_9A4
		push	edi
		call	_BIO_get_callback
		push	eax
		push	ebx
		call	_BIO_set_callback
		push	edi
		call	_BIO_get_callback_arg
		push	eax
		push	ebx
		call	_BIO_set_callback_arg
		add	esp, 18h
		cmp	dword ptr [esi+14h], 0
		jz	short loc_963
		push	1
		push	ebp
		call	_BIO_socket_nbio
		add	esp, 8
		test	eax, eax
		jnz	short loc_963
		push	103h
		push	offset ??_C@_0BI@GOELLJHH@?4?2crypto?2bio?2bss_acpt?4c?$AA@ ; ".\\crypto\\bio\\bss_acpt.c"
		push	69h ; 'i'
		push	64h ; 'd'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 14h
		jmp	short $err$36
; ---------------------------------------------------------------------------

loc_963:				; CODE XREF: _acpt_state+C4j
					; _acpt_state+D3j
		mov	eax, [esi+1Ch]
		test	eax, eax
		jz	short loc_989
		push	eax
		call	_BIO_dup_chain
		mov	ebp, eax
		add	esp, 4
		test	ebp, ebp
		jz	short $err$36
		push	ebx
		push	ebp
		call	_BIO_push
		add	esp, 8
		test	eax, eax
		jz	short $err$36
		mov	ebx, ebp

loc_989:				; CODE XREF: _acpt_state+F4j
		push	ebx
		push	edi
		call	_BIO_push
		add	esp, 8
		test	eax, eax
		jnz	short loc_9AB

$err$36:				; CODE XREF: _acpt_state+EDj
					; _acpt_state+103j ...
		test	ebx, ebx
		jz	short loc_9A4
		push	ebx
		call	_BIO_free
		add	esp, 4

loc_9A4:				; CODE XREF: _acpt_state+9Dj
					; _acpt_state+125j
		pop	ebp
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_9AB:				; CODE XREF: _acpt_state+121j
		pop	ebp
		pop	edi
		mov	dword ptr [esi], 3
		mov	eax, 1
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_9BB:				; CODE XREF: _acpt_state+15j
		mov	eax, [esi+4]
		test	eax, eax
		jnz	short loc_9E1
		push	0D2h ; 'Ò'
		push	offset ??_C@_0BI@GOELLJHH@?4?2crypto?2bio?2bss_acpt?4c?$AA@ ; ".\\crypto\\bio\\bss_acpt.c"
		push	6Fh ; 'o'
		push	64h ; 'd'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 14h

loc_9DA:				; CODE XREF: _acpt_state+17Ej
		pop	edi
		pop	esi
		or	eax, 0FFFFFFFFh
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_9E1:				; CODE XREF: _acpt_state+14Cj
		push	dword ptr [esi+18h]
		push	eax
		call	_BIO_get_accept_socket
		mov	ebx, eax
		add	esp, 8
		cmp	ebx, 0FFFFFFFFh
		jz	short loc_9DA
		cmp	dword ptr [esi+0Ch], 0
		jz	short loc_A2F
		push	1
		push	ebx
		call	_BIO_socket_nbio
		add	esp, 8
		test	eax, eax
		jnz	short loc_A2F
		push	ebx		; s
		call	dword ptr ds:__imp__closesocket@4 ; closesocket(x)
		push	0DDh ; 'Ý'
		push	offset ??_C@_0BI@GOELLJHH@?4?2crypto?2bio?2bss_acpt?4c?$AA@ ; ".\\crypto\\bio\\bss_acpt.c"
		push	6Ah ; 'j'
		push	64h ; 'd'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_A2F:				; CODE XREF: _acpt_state+184j
					; _acpt_state+193j
		mov	[esi+8], ebx
		mov	[edi+1Ch], ebx
		mov	dword ptr [esi], 2

loc_A3B:				; CODE XREF: _acpt_state+28j
		pop	edi
		pop	esi
		mov	eax, 1
		pop	ebx
		retn
_acpt_state	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A44h
; COMDAT (pick any)
		public ??_C@_0BI@GOELLJHH@?4?2crypto?2bio?2bss_acpt?4c?$AA@
; `string'
??_C@_0BI@GOELLJHH@?4?2crypto?2bio?2bss_acpt?4c?$AA@ db	'.\crypto\bio\bss_acpt.c',0
					; DATA XREF: _acpt_write+194o
					; _acpt_write+1E5o ...
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; int __stdcall	closesocket(SOCKET s)
		extrn __imp__closesocket@4:near	; CODE XREF: _acpt_write+1DAp
					; _acpt_read+1DAp ...
; int __stdcall	shutdown(SOCKET	s, int how)
		extrn __imp__shutdown@8:near ; CODE XREF: _acpt_free+22p
					; _acpt_close_socket+14p
					; DATA XREF: ...
		extrn _CRYPTO_malloc:near ; CODE XREF: _acpt_new+26p
					; _BIO_ACCEPT_new+Cp
		extrn _CRYPTO_free:near	; CODE XREF: _acpt_ctrl+79p
					; _BIO_ACCEPT_free+11p	...
		extrn _BUF_strdup:near	; CODE XREF: _acpt_ctrl+82p
		extrn _BIO_set_flags:near ; CODE XREF: _acpt_write+1C0p
					; _acpt_read+1C0p ...
		extrn _BIO_clear_flags:near ; CODE XREF: _acpt_write+Bp
					; _acpt_write+5Bp ...
		extrn _BIO_get_callback:near ; CODE XREF: _acpt_write+9Fp
					; _acpt_read+9Fp ...
		extrn _BIO_set_callback:near ; CODE XREF: _acpt_write+A6p
					; _acpt_read+A6p ...
		extrn _BIO_get_callback_arg:near ; CODE	XREF: _acpt_write+ACp
					; _acpt_read+ACp ...
		extrn _BIO_set_callback_arg:near ; CODE	XREF: _acpt_write+B3p
					; _acpt_read+B3p ...
		extrn _BIO_new:near	; CODE XREF: _BIO_new_accept+6p
		extrn _BIO_free:near	; CODE XREF: _acpt_write+1ACp
					; _acpt_read+1ACp ...
		extrn _BIO_read:near	; CODE XREF: _acpt_read+178p
		extrn _BIO_write:near	; CODE XREF: _acpt_write+178p
		extrn _BIO_ctrl:near	; CODE XREF: _BIO_new_accept+1Dp
		extrn _BIO_push:near	; CODE XREF: _acpt_write+F0p
					; _acpt_write+104p ...
		extrn _BIO_dup_chain:near ; CODE XREF: _acpt_write+DCp
					; _acpt_read+DCp ...
		extrn _BIO_socket_nbio:near ; CODE XREF: _acpt_write+C4p
					; _acpt_write+147p ...
		extrn _BIO_get_accept_socket:near ; CODE XREF: _acpt_write+12Bp
					; _acpt_read+12Bp ...
		extrn _BIO_accept:near	; CODE XREF: _acpt_write+6Ep
					; _acpt_read+6Ep ...
		extrn _BIO_new_socket:near ; CODE XREF:	_acpt_write+8Cp
					; _acpt_read+8Cp ...
		extrn _BIO_copy_next_retry:near	; CODE XREF: _acpt_write+180p
					; _acpt_read+180p
		extrn _ERR_put_error:near ; CODE XREF: _acpt_write+19Fp
					; _acpt_write+1FEp ...


		end
