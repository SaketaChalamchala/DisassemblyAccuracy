;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	0B7B17A992AE4FD1BBBFAFDDF51E6980
; Input	CRC32 :	C7C9DEF3

; File Name   :	C:\compspace\Diff\openssl\obj\bss_conn.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl conn_write(int, char *buf, int len)
_conn_write	proc near		; CODE XREF: _conn_puts+1Fp
					; DATA XREF: .data:00000668o

arg_0		= dword	ptr  4
buf		= dword	ptr  8
len		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, [esi+20h]
		cmp	dword ptr [eax], 6
		jz	short loc_1B
		push	eax		; optval
		push	esi		; int
		call	_conn_state
		add	esp, 8
		test	eax, eax
		jle	short loc_63

loc_1B:					; CODE XREF: _conn_write+Bj
		push	edi
		push	0		; iError
		call	dword ptr ds:__imp__WSASetLastError@4 ;	WSASetLastError(x)
		push	0		; flags
		push	[esp+0Ch+len]	; len
		push	[esp+10h+buf]	; buf
		push	dword ptr [esi+1Ch] ; s
		call	dword ptr ds:__imp__send@16 ; send(x,x,x,x)
		push	0Fh
		push	esi
		mov	edi, eax
		call	_BIO_clear_flags
		add	esp, 8
		test	edi, edi
		jg	short loc_60
		push	edi
		call	_BIO_sock_should_retry
		add	esp, 4
		test	eax, eax
		jz	short loc_60
		push	0Ah
		push	esi
		call	_BIO_set_flags
		add	esp, 8

loc_60:					; CODE XREF: _conn_write+46j
					; _conn_write+53j
		mov	eax, edi
		pop	edi

loc_63:					; CODE XREF: _conn_write+19j
		pop	esi
		retn
_conn_write	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 68h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl conn_read(int, char *buf,	int len)
_conn_read	proc near		; DATA XREF: .data:0000066Co

arg_0		= dword	ptr  4
buf		= dword	ptr  8
len		= dword	ptr  0Ch

		push	esi
		push	edi
		mov	edi, [esp+8+arg_0]
		xor	esi, esi
		mov	eax, [edi+20h]
		cmp	dword ptr [eax], 6
		jz	short loc_88
		push	eax		; optval
		push	edi		; int
		call	_conn_state
		mov	esi, eax
		add	esp, 8
		test	esi, esi
		jle	short loc_D5

loc_88:					; CODE XREF: _conn_read+Ej
		cmp	[esp+8+buf], 0
		jz	short loc_D3
		push	0		; iError
		call	dword ptr ds:__imp__WSASetLastError@4 ;	WSASetLastError(x)
		push	0		; flags
		push	[esp+0Ch+len]	; len
		push	[esp+10h+buf]	; buf
		push	dword ptr [edi+1Ch] ; s
		call	dword ptr ds:__imp__recv@16 ; recv(x,x,x,x)
		push	0Fh
		push	edi
		mov	esi, eax
		call	_BIO_clear_flags
		add	esp, 8
		test	esi, esi
		jg	short loc_D3
		push	esi
		call	_BIO_sock_should_retry
		add	esp, 4
		test	eax, eax
		jz	short loc_D3
		push	9
		push	edi
		call	_BIO_set_flags
		add	esp, 8

loc_D3:					; CODE XREF: _conn_read+25j
					; _conn_read+51j ...
		mov	eax, esi

loc_D5:					; CODE XREF: _conn_read+1Ej
		pop	edi
		pop	esi
		retn
_conn_read	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl conn_puts(int, char *buf)
_conn_puts	proc near		; DATA XREF: .data:00000670o

arg_0		= dword	ptr  4
buf		= dword	ptr  8

		mov	edx, [esp+buf]
		mov	eax, edx
		push	esi
		lea	esi, [eax+1]
		nop	word ptr [eax+eax+00h]

loc_E8:					; CODE XREF: _conn_puts+15j
		mov	cl, [eax]
		inc	eax
		test	cl, cl
		jnz	short loc_E8
		sub	eax, esi
		push	eax		; len
		push	edx		; buf
		push	[esp+0Ch+arg_0]	; int
		call	_conn_write
		add	esp, 0Ch
		pop	esi
		retn
_conn_puts	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 104h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_conn_ctrl	proc near		; DATA XREF: .data:00000678o

var_14		= byte ptr -14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, 14h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+14h+var_4], eax
		mov	eax, [esp+14h+arg_4]
		xor	ecx, ecx
		push	ebx
		mov	ebx, [esp+18h+arg_C]
		dec	eax
		push	ebp
		mov	ebp, [esp+1Ch+arg_0]
		push	esi
		push	edi
		lea	edi, [ecx+1]
		mov	esi, [ebp+20h]
		cmp	eax, 7Ah ; 'z'  ; switch 123 cases
		ja	$LN48		; jumptable 00000142 default case
		movzx	eax, ds:$LN50[eax]
		jmp	ds:$LN53[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN4:					; CODE XREF: _conn_ctrl+3Ej
					; DATA XREF: .text$mn:$LN53o
		push	ebp		; jumptable 00000142 case 0
		xor	edi, edi
		mov	dword ptr [esi], 1
		call	_conn_close_socket
		add	esp, 4
		mov	[ebp+14h], edi
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+14h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

$LN5:					; CODE XREF: _conn_ctrl+3Ej
					; DATA XREF: .text$mn:$LN53o
		cmp	dword ptr [esi], 6 ; jumptable 00000142	case 100
		jz	$LN2		; jumptable 00000142 case 10
		push	esi		; optval
		push	ebp		; int
		call	_conn_state
		add	esp, 8
		mov	edi, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+14h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

$LN8:					; CODE XREF: _conn_ctrl+3Ej
					; DATA XREF: .text$mn:$LN53o
		test	ebx, ebx	; jumptable 00000142 case 122
		cmovnz	ecx, ebx
		cmp	dword ptr [ebp+0Ch], 0
		jz	loc_22D
		mov	eax, [esp+24h+arg_8]
		test	ecx, ecx
		jz	short loc_20F
		test	eax, eax
		jnz	short loc_1CF
		mov	eax, [esi+4]
		mov	[ecx], eax
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+14h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_1CF:				; CODE XREF: _conn_ctrl+AFj
		cmp	eax, 1
		jnz	short loc_1EE
		mov	eax, [esi+8]
		mov	[ecx], eax
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+14h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_1EE:				; CODE XREF: _conn_ctrl+CEj
		cmp	eax, 2
		jnz	short loc_20D
		lea	eax, [esi+10h]
		mov	[ecx], eax
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+14h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_20D:				; CODE XREF: _conn_ctrl+EDj
		xor	edi, edi

loc_20F:				; CODE XREF: _conn_ctrl+ABj
		cmp	eax, 3
		jnz	short $LN2	; jumptable 00000142 case 10
		movzx	edi, word ptr [esi+14h]
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+14h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_22D:				; CODE XREF: _conn_ctrl+9Fj
		test	ecx, ecx
		jz	short $LN48	; jumptable 00000142 default case
		mov	dword ptr [ecx], offset	??_C@_0BA@CJBGKJNL@not?5initialized?$AA@ ; "not	initialized"

$LN48:					; CODE XREF: _conn_ctrl+31j
					; _conn_ctrl+3Ej ...
		xor	edi, edi	; jumptable 00000142 default case

$LN2:					; CODE XREF: _conn_ctrl+3Ej
					; _conn_ctrl+71j ...
		mov	eax, edi	; jumptable 00000142 case 10
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+14h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

$LN21:					; CODE XREF: _conn_ctrl+3Ej
					; DATA XREF: .text$mn:$LN53o
		test	ebx, ebx	; jumptable 00000142 case 99
		jz	short $LN2	; jumptable 00000142 case 10
		mov	eax, [esp+24h+arg_8]
		mov	[ebp+0Ch], edi
		test	eax, eax
		jnz	short loc_28E
		mov	eax, [esi+4]
		test	eax, eax
		jz	short loc_26D
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_26D:				; CODE XREF: _conn_ctrl+15Ej
		push	ebx
		call	_BUF_strdup
		add	esp, 4
		mov	[esi+4], eax
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+14h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_28E:				; CODE XREF: _conn_ctrl+157j
		cmp	eax, 1
		jnz	short loc_2C4
		mov	eax, [esi+8]
		test	eax, eax
		jz	short loc_2A3
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_2A3:				; CODE XREF: _conn_ctrl+194j
		push	ebx
		call	_BUF_strdup
		add	esp, 4
		mov	[esi+8], eax
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+14h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_2C4:				; CODE XREF: _conn_ctrl+18Dj
		cmp	eax, 2
		jnz	short loc_32A
		movzx	eax, byte ptr [ebx+3]
		push	eax
		movzx	eax, byte ptr [ebx+2]
		push	eax
		movzx	eax, byte ptr [ebx+1]
		push	eax
		movzx	eax, byte ptr [ebx]
		push	eax
		push	offset ??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@ ; "%d.%d.%d.%d"
		lea	eax, [esp+38h+var_14]
		push	10h
		push	eax
		call	_BIO_snprintf
		mov	eax, [esi+4]
		add	esp, 1Ch
		test	eax, eax
		jz	short loc_300
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_300:				; CODE XREF: _conn_ctrl+1F1j
		lea	eax, [esp+24h+var_14]
		push	eax
		call	_BUF_strdup
		add	esp, 4
		mov	[esi+4], eax
		mov	eax, [ebx]
		mov	[esi+10h], eax
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+14h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_32A:				; CODE XREF: _conn_ctrl+1C3j
		cmp	eax, 3
		jnz	$LN2		; jumptable 00000142 case 10
		push	dword ptr [ebx]
		lea	eax, [esp+28h+var_14]
		push	offset ??_C@_02DPKJAMEF@?$CFd?$AA@ ; "%d"
		push	0Dh
		push	eax
		call	_BIO_snprintf
		mov	eax, [esi+8]
		add	esp, 10h
		test	eax, eax
		jz	short loc_359
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_359:				; CODE XREF: _conn_ctrl+24Aj
		lea	eax, [esp+24h+var_14]
		push	eax
		call	_BUF_strdup
		add	esp, 4
		mov	[esi+8], eax
		mov	ax, [ebx]
		mov	[esi+14h], ax
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+14h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

$LN34:					; CODE XREF: _conn_ctrl+3Ej
					; DATA XREF: .text$mn:$LN53o
		mov	eax, [esp+24h+arg_8] ; jumptable 00000142 case 101
		mov	[esi+0Ch], eax
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+14h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

$LN35:					; CODE XREF: _conn_ctrl+3Ej
					; DATA XREF: .text$mn:$LN53o
		cmp	[ebp+0Ch], ecx	; jumptable 00000142 case 104
		jz	short loc_3C7
		test	ebx, ebx
		jz	short loc_3AF
		mov	eax, [ebp+1Ch]
		mov	[ebx], eax

loc_3AF:				; CODE XREF: _conn_ctrl+2A4j
		mov	edi, [ebp+1Ch]
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+14h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_3C7:				; CODE XREF: _conn_ctrl+2A0j
		or	edi, 0FFFFFFFFh
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+14h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

$LN39:					; CODE XREF: _conn_ctrl+3Ej
					; DATA XREF: .text$mn:$LN53o
		mov	edi, [ebp+10h]	; jumptable 00000142 case 7
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+14h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

$LN40:					; CODE XREF: _conn_ctrl+3Ej
					; DATA XREF: .text$mn:$LN53o
		mov	eax, [esp+24h+arg_8] ; jumptable 00000142 case 8
		mov	[ebp+10h], eax
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+14h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

$LN43:					; CODE XREF: _conn_ctrl+3Ej
					; DATA XREF: .text$mn:$LN53o
		mov	eax, [esi+8]	; jumptable 00000142 case 11
		test	eax, eax
		jz	short loc_428
		push	eax
		push	1
		push	64h ; 'd'
		push	ebx
		call	_BIO_ctrl
		add	esp, 10h

loc_428:				; CODE XREF: _conn_ctrl+314j
		mov	eax, [esi+4]
		test	eax, eax
		jz	short loc_43D
		push	eax
		push	0
		push	64h ; 'd'
		push	ebx
		call	_BIO_ctrl
		add	esp, 10h

loc_43D:				; CODE XREF: _conn_ctrl+329j
		push	0
		push	dword ptr [esi+0Ch]
		push	66h ; 'f'
		push	ebx
		call	_BIO_ctrl
		push	dword ptr [esi+28h]
		push	0Eh
		push	ebx
		call	_BIO_callback_ctrl
		add	esp, 1Ch
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+14h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

$LN47:					; CODE XREF: _conn_ctrl+3Ej
					; DATA XREF: .text$mn:$LN53o
		mov	eax, [esi+28h]	; jumptable 00000142 case 14
		mov	ecx, [esp+24h+var_4]
		mov	[ebx], eax
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
_conn_ctrl	endp

; ---------------------------------------------------------------------------
		align 4
$LN53		dd offset $LN4,	offset $LN39, offset $LN40, offset $LN48
					; DATA XREF: _conn_ctrl+3Er
		dd offset $LN2,	offset $LN43, offset $LN47, offset $LN21 ; jump	table for switch statement
		dd offset $LN5,	offset $LN34, offset $LN35, offset $LN8
		dd offset $LN48
$LN50		db	0,   0Ch,   0Ch,   0Ch ; DATA XREF: _conn_ctrl+37r
		db    0Ch,   0Ch,   0Ch,     1 ; indirect table	for switch statement
		db	2,     3,     4,     5
		db	3,     3,     6,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,     7
		db	8,     9,   0Ch,   0Ch
		db    0Ah,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Ch,   0Ch
		db    0Ch,   0Ch,   0Bh
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 538h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_conn_new	proc near		; DATA XREF: .data:0000067Co

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		push	128h
		push	offset ??_C@_0BI@GOGCPGDN@?4?2crypto?2bio?2bss_conn?4c?$AA@ ; ".\\crypto\\bio\\bss_conn.c"
		push	2Ch ; ','
		mov	dword ptr [esi+0Ch], 0
		mov	dword ptr [esi+1Ch], 0FFFFFFFFh
		mov	dword ptr [esi+14h], 0
		call	_CRYPTO_malloc
		mov	ecx, eax
		add	esp, 0Ch
		test	ecx, ecx
		jnz	short loc_576
		test	ecx, ecx
		mov	[esi+20h], ecx
		pop	esi
		setnz	al
		retn
; ---------------------------------------------------------------------------

loc_576:				; CODE XREF: _conn_new+32j
		mov	dword ptr [ecx], 1
		xor	eax, eax
		mov	dword ptr [ecx+4], 0
		xorps	xmm0, xmm0
		mov	dword ptr [ecx+8], 0
		test	ecx, ecx
		mov	dword ptr [ecx+28h], 0
		mov	dword ptr [ecx+0Ch], 0
		setnz	al
		mov	word ptr [ecx+10h], 0
		mov	dword ptr [ecx+12h], 0
		movups	xmmword	ptr [ecx+18h], xmm0
		mov	[esi+20h], ecx
		pop	esi
		retn
_conn_new	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5B8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_conn_free	proc near		; DATA XREF: .data:00000680o

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jnz	short loc_5C5
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_5C5:				; CODE XREF: _conn_free+7j
		cmp	dword ptr [esi+10h], 0
		push	edi
		mov	edi, [esi+20h]
		jz	short loc_637
		mov	eax, [esi+1Ch]
		cmp	eax, 0FFFFFFFFh
		jz	short loc_5F5
		cmp	dword ptr [edi], 6
		jnz	short loc_5E5
		push	2		; how
		push	eax		; s
		call	dword ptr ds:__imp__shutdown@8 ; shutdown(x,x)

loc_5E5:				; CODE XREF: _conn_free+22j
		push	dword ptr [esi+1Ch] ; s
		call	dword ptr ds:__imp__closesocket@4 ; closesocket(x)
		mov	dword ptr [esi+1Ch], 0FFFFFFFFh

loc_5F5:				; CODE XREF: _conn_free+1Dj
		test	edi, edi
		jz	short loc_622
		mov	eax, [edi+4]
		test	eax, eax
		jz	short loc_609
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_609:				; CODE XREF: _conn_free+46j
		mov	eax, [edi+8]
		test	eax, eax
		jz	short loc_619
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_619:				; CODE XREF: _conn_free+56j
		push	edi
		call	_CRYPTO_free
		add	esp, 4

loc_622:				; CODE XREF: _conn_free+3Fj
		mov	dword ptr [esi+20h], 0
		mov	dword ptr [esi+14h], 0
		mov	dword ptr [esi+0Ch], 0

loc_637:				; CODE XREF: _conn_free+15j
		pop	edi
		mov	eax, 1
		pop	esi
		retn
_conn_free	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 640h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_conn_callback_ctrl proc near		; DATA XREF: .data:00000684o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		cmp	[esp+arg_4], 0Eh
		jz	short loc_64A
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_64A:				; CODE XREF: _conn_callback_ctrl+5j
		mov	ecx, [esp+arg_0]
		mov	eax, 1
		mov	edx, [ecx+20h]
		mov	ecx, [esp+arg_8]
		mov	[edx+28h], ecx
		retn
_conn_callback_ctrl endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 660h
_methods_connectp dd offset $LN50+50h	; DATA XREF: _BIO_new_connect+1o
					; _BIO_s_connecto
		dd offset ??_C@_0P@GJDBGGFH@socket?5connect?$AA@ ; "socket connect"
		dd offset _conn_write
		dd offset _conn_read
		dd offset _conn_puts
		align 8
		dd offset _conn_ctrl
		dd offset _conn_new
		dd offset _conn_free
		dd offset _conn_callback_ctrl
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 688h
; COMDAT (pick any)
		public ??_C@_0P@GJDBGGFH@socket?5connect?$AA@
; `string'
??_C@_0P@GJDBGGFH@socket?5connect?$AA@ db 'socket connect',0 ; DATA XREF: .data:00000664o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 698h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_CONNECT_free
_BIO_CONNECT_free proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	short loc_6CA
		mov	eax, [esi+4]
		test	eax, eax
		jz	short loc_6B1
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_6B1:				; CODE XREF: _BIO_CONNECT_free+Ej
		mov	eax, [esi+8]
		test	eax, eax
		jz	short loc_6C1
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_6C1:				; CODE XREF: _BIO_CONNECT_free+1Ej
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_6CA:				; CODE XREF: _BIO_CONNECT_free+7j
		pop	esi
		retn
_BIO_CONNECT_free endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6CCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_CONNECT_new
_BIO_CONNECT_new proc near
		push	128h
		push	offset ??_C@_0BI@GOGCPGDN@?4?2crypto?2bio?2bss_conn?4c?$AA@ ; ".\\crypto\\bio\\bss_conn.c"
		push	2Ch ; ','
		call	_CRYPTO_malloc
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_6E5
		retn
; ---------------------------------------------------------------------------

loc_6E5:				; CODE XREF: _BIO_CONNECT_new+16j
		mov	dword ptr [eax], 1
		xorps	xmm0, xmm0
		mov	dword ptr [eax+4], 0
		mov	dword ptr [eax+8], 0
		mov	dword ptr [eax+28h], 0
		mov	dword ptr [eax+0Ch], 0
		mov	word ptr [eax+10h], 0
		mov	dword ptr [eax+12h], 0
		movups	xmmword	ptr [eax+18h], xmm0
		retn
_BIO_CONNECT_new endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 71Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_new_connect
_BIO_new_connect proc near

arg_0		= dword	ptr  4

		push	esi
		push	offset _methods_connectp
		call	_BIO_new
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jz	short loc_752
		push	[esp+4+arg_0]
		push	0
		push	64h ; 'd'
		push	esi
		call	_BIO_ctrl
		add	esp, 10h
		test	eax, eax
		jz	short loc_749
		mov	eax, esi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_749:				; CODE XREF: _BIO_new_connect+27j
		push	esi
		call	_BIO_free
		add	esp, 4

loc_752:				; CODE XREF: _BIO_new_connect+12j
		xor	eax, eax
		pop	esi
		retn
_BIO_new_connect endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 758h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_s_connect
_BIO_s_connect	proc near
		mov	eax, offset _methods_connectp
		retn
_BIO_s_connect	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 760h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_conn_close_socket proc	near		; CODE XREF: _conn_ctrl+4Ep

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	ecx, [esi+1Ch]
		cmp	ecx, 0FFFFFFFFh
		jz	short loc_78E
		mov	eax, [esi+20h]
		cmp	dword ptr [eax], 6
		jnz	short loc_77E
		push	2		; how
		push	ecx		; s
		call	dword ptr ds:__imp__shutdown@8 ; shutdown(x,x)

loc_77E:				; CODE XREF: _conn_close_socket+13j
		push	dword ptr [esi+1Ch] ; s
		call	dword ptr ds:__imp__closesocket@4 ; closesocket(x)
		mov	dword ptr [esi+1Ch], 0FFFFFFFFh

loc_78E:				; CODE XREF: _conn_close_socket+Bj
		pop	esi
		retn
_conn_close_socket endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 790h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl conn_state(int, char optval)
_conn_state	proc near		; CODE XREF: _conn_write+Fp
					; _conn_read+12p ...

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
optval		= byte ptr  8

		mov	eax, 4
		call	__chkstk
		push	ebx
		push	ebp
		mov	ebp, [esp+0Ch+arg_0]
		or	ebx, 0FFFFFFFFh
		push	esi
		push	edi
		mov	edi, dword ptr [esp+14h+optval]
		xor	esi, esi
		mov	eax, [edi+28h]
		test	eax, eax
		cmovnz	esi, eax
		mov	[esp+14h+var_4], esi

loc_7B7:				; CODE XREF: _conn_state+291j
					; _conn_state+2A4j
		mov	eax, [edi]
		dec	eax
		cmp	eax, 7		; switch 8 cases
		ja	$exit_loop$82	; jumptable 000007C8 default case
		mov	ecx, 2
		jmp	ds:$LN81[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN14:					; CODE XREF: _conn_state+38j
					; DATA XREF: .text$mn:$LN81o
		mov	esi, [edi+4]	; jumptable 000007C8 case 0
		test	esi, esi
		jz	loc_A72
		cmp	byte ptr [esi],	0
		jz	short loc_7F0
		nop

loc_7E0:				; CODE XREF: _conn_state+5Ej
		mov	al, [esi]
		cmp	al, 3Ah	; ':'
		jz	short loc_7F0
		cmp	al, 2Fh	; '/'
		jz	short loc_7F0
		inc	esi
		cmp	byte ptr [esi],	0
		jnz	short loc_7E0

loc_7F0:				; CODE XREF: _conn_state+4Dj
					; _conn_state+54j ...
		movsx	eax, byte ptr [esi]
		mov	dword ptr [esp+14h+optval], eax
		cmp	eax, 3Ah ; ':'
		jz	short loc_801
		cmp	eax, 2Fh ; '/'
		jnz	short loc_83F

loc_801:				; CODE XREF: _conn_state+6Aj
		mov	byte ptr [esi],	0
		inc	esi
		cmp	dword ptr [esp+14h+optval], 3Ah	; ':'
		jnz	short loc_83F
		cmp	byte ptr [esi],	0
		mov	eax, esi
		jz	short loc_823

loc_813:				; CODE XREF: _conn_state+8Cj
		cmp	byte ptr [eax],	2Fh ; '/'
		jz	short loc_820
		inc	eax
		cmp	byte ptr [eax],	0
		jnz	short loc_813
		jmp	short loc_823
; ---------------------------------------------------------------------------

loc_820:				; CODE XREF: _conn_state+86j
		mov	byte ptr [eax],	0

loc_823:				; CODE XREF: _conn_state+81j
					; _conn_state+8Ej
		mov	eax, [edi+8]
		test	eax, eax
		jz	short loc_833
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_833:				; CODE XREF: _conn_state+98j
		push	esi
		call	_BUF_strdup
		add	esp, 4
		mov	[edi+8], eax

loc_83F:				; CODE XREF: _conn_state+6Fj
					; _conn_state+7Aj
		cmp	dword ptr [edi+8], 0
		jz	loc_A42
		mov	esi, [esp+14h+var_4]
		mov	dword ptr [edi], 2
		jmp	loc_A1F
; ---------------------------------------------------------------------------

$LN24:					; CODE XREF: _conn_state+38j
					; DATA XREF: .text$mn:$LN81o
		lea	eax, [edi+10h]	; jumptable 000007C8 case 1
		push	eax
		push	dword ptr [edi+4]
		call	_BIO_get_host_ip
		add	esp, 8
		test	eax, eax
		jle	$exit_loop$82	; jumptable 000007C8 default case
		mov	dword ptr [edi], 3
		jmp	loc_A1F
; ---------------------------------------------------------------------------

$LN26:					; CODE XREF: _conn_state+38j
					; DATA XREF: .text$mn:$LN81o
		mov	ecx, [edi+8]	; jumptable 000007C8 case 2
		test	ecx, ecx
		jz	$exit_loop$82	; jumptable 000007C8 default case
		lea	eax, [edi+14h]
		push	eax
		push	ecx
		call	_BIO_get_port
		add	esp, 8
		test	eax, eax
		jle	$exit_loop$82	; jumptable 000007C8 default case
		mov	dword ptr [edi], 4
		jmp	loc_A1F
; ---------------------------------------------------------------------------

$LN30:					; CODE XREF: _conn_state+38j
					; DATA XREF: .text$mn:$LN81o
		xorps	xmm0, xmm0	; jumptable 000007C8 case 3
		movups	xmmword	ptr [edi+18h], xmm0
		movzx	eax, word ptr [edi+14h]
		push	eax		; hostshort
		mov	[edi+18h], cx
		call	dword ptr ds:__imp__htons@4 ; htons(x)
		mov	[edi+1Ah], ax
		movzx	ecx, byte ptr [edi+10h]
		movzx	eax, byte ptr [edi+11h]
		shl	ecx, 8
		or	ecx, eax
		movzx	eax, byte ptr [edi+12h]
		shl	ecx, 8
		or	ecx, eax
		movzx	eax, byte ptr [edi+13h]
		shl	ecx, 8
		or	ecx, eax
		push	ecx		; hostlong
		call	dword ptr ds:__imp__htonl@4 ; htonl(x)
		push	6		; protocol
		push	1		; type
		push	2		; af
		mov	[edi+1Ch], eax
		mov	dword ptr [edi], 4
		call	dword ptr ds:__imp__socket@12 ;	socket(x,x,x)
		mov	ebx, eax
		cmp	ebx, 0FFFFFFFFh
		jz	loc_A93
		mov	[ebp+1Ch], ebx
		mov	dword ptr [edi], 8
		jmp	loc_A1F
; ---------------------------------------------------------------------------

$LN32:					; CODE XREF: _conn_state+38j
					; DATA XREF: .text$mn:$LN81o
		cmp	dword ptr [edi+0Ch], 0 ; jumptable 000007C8 case 7
		jz	short loc_92E
		push	1
		push	dword ptr [ebp+1Ch]
		call	_BIO_socket_nbio
		add	esp, 8
		test	eax, eax
		jz	loc_AE1

loc_92E:				; CODE XREF: _conn_state+187j
		push	4		; optlen
		lea	eax, [esp+18h+optval]
		mov	dword ptr [edi], 5
		push	eax		; optval
		push	8		; optname
		push	0FFFFh		; level
		push	dword ptr [ebp+1Ch] ; s
		mov	dword ptr [esp+28h+optval], 1
		call	dword ptr ds:__imp__setsockopt@20 ; setsockopt(x,x,x,x,x)
		mov	dword ptr [esp+14h+optval], eax
		test	eax, eax
		jns	loc_A1F
		push	0E2h ; 'â'
		push	offset ??_C@_0BI@GOGCPGDN@?4?2crypto?2bio?2bss_conn?4c?$AA@ ; ".\\crypto\\bio\\bss_conn.c"
		call	dword ptr ds:__imp__WSAGetLastError@0 ;	WSAGetLastError()
		push	eax
		push	4
		push	2
		call	_ERR_put_error
		push	dword ptr [edi+8]
		push	offset ??_C@_01JLIPDDHJ@?3?$AA@	; `string'
		push	dword ptr [edi+4]
		push	offset ??_C@_05PBGCLELH@host?$DN?$AA@ ;	"host="
		push	4
		call	_ERR_add_error_data
		push	0E5h ; 'å'
		push	offset ??_C@_0BI@GOGCPGDN@?4?2crypto?2bio?2bss_conn?4c?$AA@ ; ".\\crypto\\bio\\bss_conn.c"
		push	6Dh ; 'm'
		push	73h ; 's'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 3Ch
		jmp	$exit_loop$82	; jumptable 000007C8 default case
; ---------------------------------------------------------------------------

$LN36:					; CODE XREF: _conn_state+38j
					; DATA XREF: .text$mn:$LN81o
		push	0Fh		; jumptable 000007C8 case 4
		push	ebp
		call	_BIO_clear_flags
		add	esp, 8
		lea	eax, [edi+18h]
		push	10h		; namelen
		push	eax		; name
		push	dword ptr [ebp+1Ch] ; s
		call	dword ptr ds:__imp__connect@12 ; connect(x,x,x)
		mov	ebx, eax
		mov	dword ptr [ebp+18h], 0
		test	ebx, ebx
		jns	short loc_A19
		push	ebx
		call	_BIO_sock_should_retry
		add	esp, 4
		test	eax, eax
		jz	loc_B15
		push	0Ch
		push	ebp
		call	_BIO_set_flags
		mov	dword ptr [edi], 7
		add	esp, 8
		mov	dword ptr [ebp+18h], 2
		jmp	$exit_loop$82	; jumptable 000007C8 default case
; ---------------------------------------------------------------------------

$LN41:					; CODE XREF: _conn_state+38j
					; DATA XREF: .text$mn:$LN81o
		push	dword ptr [ebp+1Ch] ; jumptable	000007C8 case 6
		call	_BIO_sock_error
		add	esp, 4
		mov	dword ptr [esp+14h+optval], eax
		test	eax, eax
		jnz	loc_B60

loc_A19:				; CODE XREF: _conn_state+242j
		mov	dword ptr [edi], 6

loc_A1F:				; CODE XREF: _conn_state+C3j
					; _conn_state+E5j ...
		test	esi, esi
		jz	loc_7B7
		push	ebx
		push	dword ptr [edi]
		push	ebp
		call	esi
		mov	ebx, eax
		add	esp, 0Ch
		test	ebx, ebx
		jnz	loc_7B7

loc_A3A:				; CODE XREF: _conn_state+429j
		mov	eax, ebx

$end$83:
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_A42:				; CODE XREF: _conn_state+B3j
		push	0A4h ; '¤'
		push	offset ??_C@_0BI@GOGCPGDN@?4?2crypto?2bio?2bss_conn?4c?$AA@ ; ".\\crypto\\bio\\bss_conn.c"
		push	72h ; 'r'
		push	73h ; 's'
		push	20h ; ' '
		call	_ERR_put_error
		push	dword ptr [edi+4]
		push	offset ??_C@_05PBGCLELH@host?$DN?$AA@ ;	"host="
		push	2
		call	_ERR_add_error_data
		mov	esi, [esp+34h+var_4]
		add	esp, 20h
		jmp	$exit_loop$82	; jumptable 000007C8 default case
; ---------------------------------------------------------------------------

loc_A72:				; CODE XREF: _conn_state+44j
		push	8Bh ; '‹'
		push	offset ??_C@_0BI@GOGCPGDN@?4?2crypto?2bio?2bss_conn?4c?$AA@ ; ".\\crypto\\bio\\bss_conn.c"
		push	70h ; 'p'
		push	73h ; 's'
		push	20h ; ' '
		call	_ERR_put_error
		mov	esi, [esp+28h+var_4]
		add	esp, 14h
		jmp	$exit_loop$82	; jumptable 000007C8 default case
; ---------------------------------------------------------------------------

loc_A93:				; CODE XREF: _conn_state+16Fj
		push	0C8h ; 'È'
		push	offset ??_C@_0BI@GOGCPGDN@?4?2crypto?2bio?2bss_conn?4c?$AA@ ; ".\\crypto\\bio\\bss_conn.c"
		call	dword ptr ds:__imp__WSAGetLastError@0 ;	WSAGetLastError()
		push	eax
		push	4
		push	2
		call	_ERR_put_error
		push	dword ptr [edi+8]
		push	offset ??_C@_01JLIPDDHJ@?3?$AA@	; `string'
		push	dword ptr [edi+4]
		push	offset ??_C@_05PBGCLELH@host?$DN?$AA@ ;	"host="
		push	4
		call	_ERR_add_error_data
		push	0CBh ; 'Ë'
		push	offset ??_C@_0BI@GOGCPGDN@?4?2crypto?2bio?2bss_conn?4c?$AA@ ; ".\\crypto\\bio\\bss_conn.c"
		push	76h ; 'v'
		push	73h ; 's'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 3Ch
		jmp	$exit_loop$82	; jumptable 000007C8 default case
; ---------------------------------------------------------------------------

loc_AE1:				; CODE XREF: _conn_state+198j
		push	0D5h ; 'Õ'
		push	offset ??_C@_0BI@GOGCPGDN@?4?2crypto?2bio?2bss_conn?4c?$AA@ ; ".\\crypto\\bio\\bss_conn.c"
		push	68h ; 'h'
		push	73h ; 's'
		push	20h ; ' '
		call	_ERR_put_error
		push	dword ptr [edi+8]
		push	offset ??_C@_01JLIPDDHJ@?3?$AA@	; `string'
		push	dword ptr [edi+4]
		push	offset ??_C@_05PBGCLELH@host?$DN?$AA@ ;	"host="
		push	4
		call	_ERR_add_error_data
		add	esp, 28h
		jmp	$exit_loop$82	; jumptable 000007C8 default case
; ---------------------------------------------------------------------------

loc_B15:				; CODE XREF: _conn_state+24Fj
		push	0F6h ; 'ö'
		push	offset ??_C@_0BI@GOGCPGDN@?4?2crypto?2bio?2bss_conn?4c?$AA@ ; ".\\crypto\\bio\\bss_conn.c"
		call	dword ptr ds:__imp__WSAGetLastError@0 ;	WSAGetLastError()
		push	eax
		push	2
		push	2
		call	_ERR_put_error
		push	dword ptr [edi+8]
		push	offset ??_C@_01JLIPDDHJ@?3?$AA@	; `string'
		push	dword ptr [edi+4]
		push	offset ??_C@_05PBGCLELH@host?$DN?$AA@ ;	"host="
		push	4
		call	_ERR_add_error_data
		push	0F9h ; 'ù'
		push	offset ??_C@_0BI@GOGCPGDN@?4?2crypto?2bio?2bss_conn?4c?$AA@ ; ".\\crypto\\bio\\bss_conn.c"
		push	67h ; 'g'
		push	73h ; 's'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 3Ch
		jmp	short $exit_loop$82 ; jumptable	000007C8 default case
; ---------------------------------------------------------------------------

loc_B60:				; CODE XREF: _conn_state+283j
		push	0Fh
		push	ebp
		call	_BIO_clear_flags
		push	104h
		push	offset ??_C@_0BI@GOGCPGDN@?4?2crypto?2bio?2bss_conn?4c?$AA@ ; ".\\crypto\\bio\\bss_conn.c"
		push	dword ptr [esp+24h+optval]
		push	2
		push	2
		call	_ERR_put_error
		push	dword ptr [edi+8]
		push	offset ??_C@_01JLIPDDHJ@?3?$AA@	; `string'
		push	dword ptr [edi+4]
		push	offset ??_C@_05PBGCLELH@host?$DN?$AA@ ;	"host="
		push	4
		call	_ERR_add_error_data
		push	107h
		push	offset ??_C@_0BI@GOGCPGDN@?4?2crypto?2bio?2bss_conn?4c?$AA@ ; ".\\crypto\\bio\\bss_conn.c"
		push	6Eh ; 'n'
		push	73h ; 's'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 44h
		xor	ebx, ebx
		jmp	short $exit_loop$82 ; jumptable	000007C8 default case
; ---------------------------------------------------------------------------

$LN44:					; CODE XREF: _conn_state+38j
					; DATA XREF: .text$mn:$LN81o
		mov	ebx, 1		; jumptable 000007C8 case 5

$exit_loop$82:				; CODE XREF: _conn_state+2Dj
					; _conn_state+D9j ...
		test	esi, esi	; jumptable 000007C8 default case
		jz	loc_A3A
		push	ebx
		push	dword ptr [edi]
		push	ebp
		call	esi
		add	esp, 0Ch
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
_conn_state	endp

; ---------------------------------------------------------------------------
		align 10h
$LN81		dd offset $LN14		; DATA XREF: _conn_state+38r
		dd offset $LN24		; jump table for switch	statement
		dd offset $LN26
		dd offset $LN30
		dd offset $LN36
		dd offset $LN44
		dd offset $LN41
		dd offset $LN32
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BF0h
; COMDAT (pick any)
		public ??_C@_0BI@GOGCPGDN@?4?2crypto?2bio?2bss_conn?4c?$AA@
; `string'
??_C@_0BI@GOGCPGDN@?4?2crypto?2bio?2bss_conn?4c?$AA@ db	'.\crypto\bio\bss_conn.c',0
					; DATA XREF: _conn_new+Ao
					; _BIO_CONNECT_new+5o ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C08h
; COMDAT (pick any)
		public ??_C@_05PBGCLELH@host?$DN?$AA@
; `string'
??_C@_05PBGCLELH@host?$DN?$AA@ db 'host=',0 ; DATA XREF: _conn_state+1F4o
					; _conn_state+2CAo ...
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C10h
; COMDAT (pick any)
		public ??_C@_01JLIPDDHJ@?3?$AA@
; `string'
??_C@_01JLIPDDHJ@?3?$AA@ db 3Ah, 0	; DATA XREF: _conn_state+1ECo
					; _conn_state+320o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C14h
; COMDAT (pick any)
		public ??_C@_0BA@CJBGKJNL@not?5initialized?$AA@
; `string'
??_C@_0BA@CJBGKJNL@not?5initialized?$AA@ db 'not initialized',0 ; DATA XREF: _conn_ctrl+12Do
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C24h
; COMDAT (pick any)
		public ??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@
; `string'
??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@ db '%d.%d.%d.%d',0
					; DATA XREF: _conn_ctrl+1D8o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C30h
; COMDAT (pick any)
		public ??_C@_02DPKJAMEF@?$CFd?$AA@
; `string'
??_C@_02DPKJAMEF@?$CFd?$AA@ db '%d',0   ; DATA XREF: _conn_ctrl+235o
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; int __stdcall	closesocket(SOCKET s)
		extrn __imp__closesocket@4:near	; CODE XREF: _conn_free+30p
					; _conn_close_socket+21p
					; DATA XREF: ...
; int __stdcall	connect(SOCKET s, const	struct sockaddr	*name, int namelen)
		extrn __imp__connect@12:near ; CODE XREF: _conn_state+231p
					; DATA XREF: _conn_state+231r
; u_long __stdcall htonl(u_long	hostlong)
		extrn __imp__htonl@4:near ; CODE XREF: _conn_state+14Fp
					; DATA XREF: _conn_state+14Fr
; u_short __stdcall htons(u_short hostshort)
		extrn __imp__htons@4:near ; CODE XREF: _conn_state+125p
					; DATA XREF: _conn_state+125r
; int __stdcall	recv(SOCKET s, char *buf, int len, int flags)
		extrn __imp__recv@16:near ; CODE XREF: _conn_read+3Cp
					; DATA XREF: _conn_read+3Cr
; int __stdcall	send(SOCKET s, const char *buf,	int len, int flags)
		extrn __imp__send@16:near ; CODE XREF: _conn_write+31p
					; DATA XREF: _conn_write+31r
; int __stdcall	setsockopt(SOCKET s, int level,	int optname, const char	*optval, int optlen)
		extrn __imp__setsockopt@20:near	; CODE XREF: _conn_state+1BDp
					; DATA XREF: _conn_state+1BDr
; int __stdcall	shutdown(SOCKET	s, int how)
		extrn __imp__shutdown@8:near ; CODE XREF: _conn_free+27p
					; _conn_close_socket+18p
					; DATA XREF: ...
; SOCKET __stdcall socket(int af, int type, int	protocol)
		extrn __imp__socket@12:near ; CODE XREF: _conn_state+164p
					; DATA XREF: _conn_state+164r
; void __stdcall WSASetLastError(int iError)
		extrn __imp__WSASetLastError@4:near ; CODE XREF: _conn_write+1Ep
					; _conn_read+29p
					; DATA XREF: ...
; int __stdcall	WSAGetLastError()
		extrn __imp__WSAGetLastError@0:near ; CODE XREF: _conn_state+1D9p
					; _conn_state+30Dp ...
		extrn _CRYPTO_malloc:near ; CODE XREF: _conn_new+26p
					; _BIO_CONNECT_new+Cp
		extrn _CRYPTO_free:near	; CODE XREF: _conn_ctrl+161p
					; _conn_ctrl+197p ...
		extrn _BUF_strdup:near	; CODE XREF: _conn_ctrl+16Ap
					; _conn_ctrl+1A0p ...
		extrn _BIO_set_flags:near ; CODE XREF: _conn_write+58p
					; _conn_read+63p ...
		extrn _BIO_clear_flags:near ; CODE XREF: _conn_write+3Cp
					; _conn_read+47p ...
		extrn _BIO_new:near	; CODE XREF: _BIO_new_connect+6p
		extrn _BIO_free:near	; CODE XREF: _BIO_new_connect+2Ep
		extrn _BIO_ctrl:near	; CODE XREF: _conn_ctrl+31Cp
					; _conn_ctrl+331p ...
		extrn _BIO_callback_ctrl:near ;	CODE XREF: _conn_ctrl+34Cp
		extrn _BIO_sock_should_retry:near ; CODE XREF: _conn_write+49p
					; _conn_read+54p ...
		extrn _BIO_sock_error:near ; CODE XREF:	_conn_state+275p
		extrn _BIO_socket_nbio:near ; CODE XREF: _conn_state+18Ep
		extrn _BIO_get_port:near ; CODE	XREF: _conn_state+FAp
		extrn _BIO_get_host_ip:near ; CODE XREF: _conn_state+CFp
		extrn _BIO_snprintf:near ; CODE	XREF: _conn_ctrl+1E4p
					; _conn_ctrl+23Dp
		extrn _ERR_put_error:near ; CODE XREF: _conn_state+1E4p
					; _conn_state+210p ...
		extrn _ERR_add_error_data:near ; CODE XREF: _conn_state+1FBp
					; _conn_state+2D1p ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _conn_ctrl+65p
					; _conn_ctrl+8Dp ...
		extrn __chkstk:near	; CODE XREF: _conn_ctrl+5p
					; _conn_state+5p
		extrn ___security_cookie:near ;	DATA XREF: _conn_ctrl+Ar


		end
