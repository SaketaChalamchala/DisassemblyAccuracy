;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	03156D9DC3D2157F91102DDD6AA93A0D
; Input	CRC32 :	9E390717

; File Name   :	C:\compspace\Diff\openssl\obj\cts128.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl CRYPTO_cts128_decrypt(int, void *, int, int, int,	int)
		public _CRYPTO_cts128_decrypt
_CRYPTO_cts128_decrypt proc near

var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
Dst		= xmmword ptr -24h
var_14		= xmmword ptr -14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	eax, 30h ; '0'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+30h+var_4], eax
		mov	ecx, [esp+30h+arg_C]
		mov	eax, [esp+30h+arg_10]
		mov	edx, [esp+30h+arg_14]
		push	ebx
		mov	ebx, [esp+34h+arg_0]
		push	ebp
		mov	ebp, [esp+38h+arg_4]
		push	esi
		mov	esi, [esp+3Ch+arg_8]
		mov	[esp+3Ch+var_2C], ecx
		mov	[esp+3Ch+var_30], eax
		mov	[esp+3Ch+var_28], edx
		cmp	esi, 10h
		ja	short loc_55
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		mov	ecx, [esp+30h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 30h
		retn
; ---------------------------------------------------------------------------

loc_55:					; CODE XREF: _CRYPTO_cts128_decrypt+3Fj
		push	edi
		mov	edi, esi
		mov	eax, 10h
		and	edi, 0Fh
		cmovz	edi, eax
		mov	eax, 0FFFFFFF0h
		sub	eax, edi
		add	esi, eax
		jz	short loc_89
		push	0
		push	[esp+44h+var_30]
		push	ecx
		push	esi
		push	ebp
		push	ebx
		call	edx
		mov	ecx, [esp+58h+var_2C]
		add	esp, 18h
		mov	edx, [esp+40h+var_28]
		add	ebx, esi
		add	ebp, esi

loc_89:					; CODE XREF: _CRYPTO_cts128_decrypt+6Cj
		push	0
		lea	eax, [esp+44h+var_14]
		xorps	xmm0, xmm0
		push	eax
		push	ecx
		push	10h
		lea	eax, [esp+50h+Dst]
		push	eax
		push	ebx
		movups	[esp+58h+Dst], xmm0
		movups	[esp+58h+var_14], xmm0
		call	edx
		push	edi		; Size
		lea	eax, [ebx+10h]
		push	eax		; Src
		lea	eax, [esp+60h+Dst]
		push	eax		; Dst
		call	_memcpy
		push	0
		push	[esp+68h+var_30]
		lea	eax, [esp+6Ch+Dst]
		push	[esp+6Ch+var_2C]
		push	20h ; ' '
		push	eax
		push	eax
		call	[esp+7Ch+var_28]
		lea	eax, [edi+10h]
		push	eax		; Size
		lea	eax, [esp+80h+Dst]
		push	eax		; Src
		push	ebp		; Dst
		call	_memcpy
		mov	ecx, [esp+88h+var_4]
		lea	eax, [edi+10h]
		add	esp, 48h
		add	eax, esi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 30h
		retn
_CRYPTO_cts128_decrypt endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0FCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_cts128_decrypt_block
_CRYPTO_cts128_decrypt_block proc near

var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_25		= byte ptr -25h
Dst		= xmmword ptr -24h
var_14		= xmmword ptr -14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	eax, 44h ; 'D'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+44h+var_4], eax
		mov	ecx, [esp+44h+arg_8]
		mov	edx, [esp+44h+arg_C]
		mov	eax, [esp+44h+arg_14]
		mov	[esp+44h+var_44], edx
		mov	[esp+44h+var_40], eax
		push	ebp
		mov	ebp, [esp+48h+arg_4]
		mov	[esp+48h+var_30], ebp
		push	esi
		mov	esi, [esp+4Ch+arg_10]
		push	edi
		mov	edi, [esp+50h+arg_0]
		mov	[esp+50h+var_34], edi
		cmp	ecx, 10h
		ja	short loc_154
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebp
		mov	ecx, [esp+44h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 44h
		retn
; ---------------------------------------------------------------------------

loc_154:				; CODE XREF: _CRYPTO_cts128_decrypt_block+42j
		push	ebx
		mov	ebx, ecx
		mov	eax, 10h
		and	ebx, 0Fh
		cmovz	ebx, eax
		mov	eax, 0FFFFFFF0h
		sub	eax, ebx
		mov	[esp+54h+var_38], ebx
		add	ecx, eax
		mov	[esp+54h+var_2C], ecx
		jz	short loc_19A
		push	[esp+54h+var_40]
		push	esi
		push	edx
		push	ecx
		push	ebp
		push	edi
		call	_CRYPTO_cbc128_decrypt
		add	edi, [esp+6Ch+var_2C]
		add	esp, 18h
		add	ebp, [esp+54h+var_2C]
		mov	edx, [esp+54h+var_44]
		mov	[esp+54h+var_34], edi
		mov	[esp+54h+var_30], ebp

loc_19A:				; CODE XREF: _CRYPTO_cts128_decrypt_block+77j
		push	edx
		lea	eax, [esp+58h+var_14]
		push	eax
		push	edi
		call	[esp+60h+var_40]
		movups	xmm0, [esp+60h+var_14]
		push	ebx		; Size
		lea	eax, [edi+10h]
		push	eax		; Src
		lea	eax, [esp+68h+Dst]
		push	eax		; Dst
		movups	[esp+6Ch+Dst], xmm0
		call	_memcpy
		push	[esp+6Ch+var_44]
		lea	eax, [esp+70h+Dst]
		push	eax
		push	eax
		call	[esp+78h+var_40]
		lea	ecx, [esp+78h+Dst+0Fh]
		add	esp, 24h
		xor	eax, eax
		lea	edx, [esi+0Fh]
		cmp	esi, ecx
		ja	short loc_1E4
		lea	ecx, [esp+54h+Dst]
		cmp	edx, ecx
		jnb	short loc_219

loc_1E4:				; CODE XREF: _CRYPTO_cts128_decrypt_block+DEj
		lea	ecx, [ebp+0Fh]
		cmp	esi, ecx
		ja	short loc_1EF
		cmp	edx, ebp
		jnb	short loc_219

loc_1EF:				; CODE XREF: _CRYPTO_cts128_decrypt_block+EDj
		lea	ebx, [edi+0Fh]
		cmp	esi, ebx
		mov	ebx, [esp+54h+var_38]
		ja	short loc_1FE
		cmp	edx, edi
		jnb	short loc_219

loc_1FE:				; CODE XREF: _CRYPTO_cts128_decrypt_block+FCj
		lea	edx, [esp+54h+Dst+0Fh]
		cmp	ebp, edx
		ja	short loc_20E
		lea	edx, [esp+54h+Dst]
		cmp	ecx, edx
		jnb	short loc_219

loc_20E:				; CODE XREF: _CRYPTO_cts128_decrypt_block+108j
		lea	edx, [edi+0Fh]
		cmp	ebp, edx
		ja	short loc_27C
		cmp	ecx, edi
		jb	short loc_27C

loc_219:				; CODE XREF: _CRYPTO_cts128_decrypt_block+E6j
					; _CRYPTO_cts128_decrypt_block+F1j ...
		lea	ecx, [esp+54h+Dst]
		mov	[esp+54h+var_44], edi
		sub	edi, ecx
		lea	edx, [esp+54h+Dst]
		mov	ecx, ebp
		mov	ebp, esi
		sub	ecx, edx
		mov	[esp+54h+var_44], ecx
		mov	ecx, edx
		sub	ebp, ecx
		nop	dword ptr [eax+00000000h]

loc_23C:				; CODE XREF: _CRYPTO_cts128_decrypt_block+166j
		mov	dl, byte ptr [esp+eax+54h+Dst]
		lea	ecx, [edi+eax]
		mov	bl, byte ptr [esp+ecx+54h+Dst]
		lea	esi, [esp+54h+Dst]
		lea	ecx, [eax+ebp]
		add	esi, ecx
		mov	ecx, [esp+54h+var_44]
		add	ecx, eax
		inc	eax
		xor	dl, [esi]
		mov	byte ptr [esp+ecx+54h+Dst], dl
		mov	[esi], bl
		cmp	eax, 10h
		jb	short loc_23C
		mov	edi, [esp+54h+var_34]
		mov	ebp, [esp+54h+var_30]
		mov	ebx, [esp+54h+var_38]
		jmp	short loc_297
; ---------------------------------------------------------------------------
		db 2 dup(66h), 0Fh, 1Fh, 84h, 5	dup(0)
; ---------------------------------------------------------------------------

loc_27C:				; CODE XREF: _CRYPTO_cts128_decrypt_block+117j
					; _CRYPTO_cts128_decrypt_block+11Bj
		movups	xmm1, xmmword ptr [esi]
		mov	eax, 10h
		movups	xmm0, [esp+54h+Dst]
		movups	xmm2, xmmword ptr [edi]
		pxor	xmm1, xmm0
		movups	xmmword	ptr [ebp+0], xmm1
		movups	xmmword	ptr [esi], xmm2

loc_297:				; CODE XREF: _CRYPTO_cts128_decrypt_block+174j
		add	ebx, 10h
		mov	esi, ebx
		mov	[esp+54h+var_38], ebx
		sub	esi, eax
		cmp	eax, ebx
		jnb	loc_386
		cmp	esi, 20h ; ' '
		jb	loc_367
		lea	edx, [eax+ebp]
		lea	ecx, [esp+ebx+54h+var_25]
		mov	[esp+54h+var_3C], edx
		cmp	edx, ecx
		ja	short loc_2D5
		lea	ecx, [ebp-1]
		lea	edx, [esp+54h+Dst]
		add	ecx, ebx
		add	edx, eax
		cmp	ecx, edx
		jnb	loc_367

loc_2D5:				; CODE XREF: _CRYPTO_cts128_decrypt_block+1C4j
		lea	ecx, [edi-1]
		add	ecx, ebx
		lea	edx, [edi+eax]
		cmp	[esp+54h+var_3C], ecx
		ja	short loc_2EC
		lea	ecx, [ebp-1]
		add	ecx, ebx
		cmp	ecx, edx
		jnb	short loc_367

loc_2EC:				; CODE XREF: _CRYPTO_cts128_decrypt_block+1E5j
		and	esi, 1Fh
		mov	ecx, ebx
		sub	ecx, esi
		mov	esi, ebp
		mov	[esp+54h+var_3C], ecx
		sub	esi, edi
		lea	ecx, [ebp+10h]
		mov	[esp+54h+var_44], esi
		mov	esi, [esp+54h+var_3C]
		lea	ebp, [esp+54h+Dst]
		sub	ebp, edi
		add	ecx, eax
		mov	[esp+54h+var_40], ebp
		lea	ebp, [esp+54h+var_14]
		sub	ebp, edi
		mov	edi, [esp+54h+var_40]
		mov	[esp+2Ch], ebp
		mov	ebp, [esp+54h+var_44]
		mov	ebx, [esp+2Ch]
		nop	dword ptr [eax+00h]

loc_32C:				; CODE XREF: _CRYPTO_cts128_decrypt_block+25Dj
		movups	xmm0, xmmword ptr [edx]
		add	eax, 20h ; ' '
		lea	edx, [edx+20h]
		lea	ecx, [ecx+20h]
		movups	xmm1, xmmword ptr [edi+edx-20h]
		pxor	xmm1, xmm0
		movups	xmmword	ptr [edx+ebp-20h], xmm1
		movups	xmm1, xmmword ptr [ebx+edx-20h]
		movups	xmm0, xmmword ptr [edx-10h]
		pxor	xmm1, xmm0
		movups	xmmword	ptr [ecx-20h], xmm1
		cmp	eax, esi
		jb	short loc_32C
		mov	edi, [esp+54h+var_34]
		mov	ebp, [esp+54h+var_30]
		mov	ebx, [esp+54h+var_38]

loc_367:				; CODE XREF: _CRYPTO_cts128_decrypt_block+1B1j
					; _CRYPTO_cts128_decrypt_block+1D3j ...
		cmp	eax, ebx
		jnb	short loc_386
		lea	ecx, [esp+54h+Dst]
		sub	edi, ecx
		sub	ebp, ecx

loc_373:				; CODE XREF: _CRYPTO_cts128_decrypt_block+288j
		lea	edx, [esp+54h+Dst]
		add	edx, eax
		inc	eax
		mov	cl, [edi+edx]
		xor	cl, [edx]
		mov	[edx+ebp], cl
		cmp	eax, ebx
		jb	short loc_373

loc_386:				; CODE XREF: _CRYPTO_cts128_decrypt_block+1A8j
					; _CRYPTO_cts128_decrypt_block+26Dj
		mov	eax, [esp+54h+var_2C]
		mov	ecx, [esp+54h+var_4]
		add	eax, 10h
		add	eax, ebx
		pop	ebx
		pop	edi
		pop	esi
		pop	ebp
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 44h
		retn
_CRYPTO_cts128_decrypt_block endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3A4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_cts128_encrypt
_CRYPTO_cts128_encrypt proc near

Size		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
Dst		= xmmword ptr -14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	eax, 24h ; '$'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+24h+var_4], eax
		mov	eax, [esp+24h+arg_C]
		mov	ecx, [esp+24h+arg_10]
		mov	edx, [esp+24h+arg_14]
		push	ebx
		mov	ebx, [esp+28h+arg_8]
		mov	[esp+28h+var_1C], eax
		mov	[esp+28h+var_20], ecx
		mov	[esp+28h+var_18], edx
		push	ebp
		mov	ebp, [esp+2Ch+arg_4]
		push	esi
		mov	esi, [esp+30h+arg_0]
		cmp	ebx, 10h
		ja	short loc_3F9
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		mov	ecx, [esp+24h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 24h
		retn
; ---------------------------------------------------------------------------

loc_3F9:				; CODE XREF: _CRYPTO_cts128_encrypt+3Fj
		push	edi
		mov	edi, ebx
		mov	[esp+34h+Size],	10h
		push	1
		push	ecx
		and	edi, 0Fh
		push	eax
		cmovz	edi, [esp+40h+Size]
		sub	ebx, edi
		push	ebx
		push	ebp
		push	esi
		call	edx
		push	edi		; Size
		lea	eax, [ebx+esi]
		xorps	xmm0, xmm0
		push	eax		; Src
		lea	eax, [esp+54h+Dst]
		add	ebp, ebx
		push	eax		; Dst
		movups	[esp+58h+Dst], xmm0
		call	_memcpy
		push	edi		; Size
		lea	esi, [ebp-10h]
		push	esi		; Src
		push	ebp		; Dst
		call	_memcpy
		push	1
		push	[esp+68h+var_20]
		lea	eax, [esp+6Ch+Dst]
		push	[esp+6Ch+var_1C]
		push	10h
		push	esi
		push	eax
		call	[esp+7Ch+var_18]
		mov	ecx, [esp+7Ch+var_4]
		lea	eax, [ebx+edi]
		add	esp, 48h
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 24h
		retn
_CRYPTO_cts128_encrypt endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 46Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl CRYPTO_cts128_encrypt_block(int, void *Dst, int, int, int, int)
		public _CRYPTO_cts128_encrypt_block
_CRYPTO_cts128_encrypt_block proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
Dst		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	eax, 4
		call	__chkstk
		push	ebp
		mov	ebp, [esp+8+arg_8]
		cmp	ebp, 10h
		ja	short loc_485
		xor	eax, eax
		pop	ebp
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_485:				; CODE XREF: _CRYPTO_cts128_encrypt_block+12j
		push	ebx
		mov	ebx, [esp+0Ch+arg_10]
		mov	eax, 10h
		push	esi
		mov	esi, [esp+10h+arg_0]
		push	edi
		push	[esp+14h+arg_14]
		mov	edi, ebp
		push	ebx
		push	[esp+1Ch+arg_C]
		and	edi, 0Fh
		cmovz	edi, eax
		sub	ebp, edi
		push	ebp
		push	[esp+24h+Dst]
		mov	[esp+28h+arg_8], ebp
		push	esi
		call	_CRYPTO_cbc128_encrypt
		add	[esp+2Ch+Dst], ebp
		add	esp, 18h
		add	esi, ebp
		xor	ecx, ecx
		test	edi, edi
		jz	loc_54A
		cmp	edi, 20h ; ' '
		jb	short loc_52B
		lea	eax, [edi-1]
		lea	edx, [ebx-1]
		add	eax, esi
		add	edx, edi
		cmp	ebx, eax
		ja	short loc_4E1
		cmp	edx, esi
		jnb	short loc_52B

loc_4E1:				; CODE XREF: _CRYPTO_cts128_encrypt_block+6Fj
		mov	eax, edi
		mov	edx, edi
		and	eax, 1Fh
		mov	ebp, esi
		sub	edx, eax
		sub	ebp, ebx
		mov	[esp+14h+var_4], ebp
		mov	eax, ebx
		mov	ebp, [esp+14h+arg_8]
		mov	ebx, [esp+14h+var_4]

loc_4FC:				; CODE XREF: _CRYPTO_cts128_encrypt_block+B9j
		movups	xmm0, xmmword ptr [eax]
		lea	eax, [eax+20h]
		movups	xmm1, xmmword ptr [ebx+eax-20h]
		pxor	xmm1, xmm0
		movups	xmmword	ptr [eax-20h], xmm1
		movups	xmm1, xmmword ptr [esi+ecx+10h]
		add	ecx, 20h ; ' '
		movups	xmm0, xmmword ptr [eax-10h]
		pxor	xmm1, xmm0
		movups	xmmword	ptr [eax-10h], xmm1
		cmp	ecx, edx
		jb	short loc_4FC
		mov	ebx, [esp+14h+arg_10]

loc_52B:				; CODE XREF: _CRYPTO_cts128_encrypt_block+61j
					; _CRYPTO_cts128_encrypt_block+73j
		cmp	ecx, edi
		jnb	short loc_54A
		mov	edx, edi
		lea	eax, [ecx+ebx]
		sub	esi, ebx
		sub	edx, ecx
		nop	dword ptr [eax+00h]

loc_53C:				; CODE XREF: _CRYPTO_cts128_encrypt_block+DCj
		mov	cl, [eax+esi]
		lea	eax, [eax+1]
		xor	[eax-1], cl
		sub	edx, 1
		jnz	short loc_53C

loc_54A:				; CODE XREF: _CRYPTO_cts128_encrypt_block+58j
					; _CRYPTO_cts128_encrypt_block+C1j
		push	[esp+14h+arg_C]
		push	ebx
		push	ebx
		call	[esp+20h+arg_14]
		mov	eax, [esp+20h+Dst]
		push	edi		; Size
		lea	esi, [eax-10h]
		push	esi		; Src
		push	eax		; Dst
		call	_memcpy
		movups	xmm0, xmmword ptr [ebx]
		add	esp, 18h
		lea	eax, [edi+ebp]
		movups	xmmword	ptr [esi], xmm0
		pop	edi
		pop	esi
		pop	ebx
		pop	ebp
		pop	ecx
		retn
_CRYPTO_cts128_encrypt_block endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 578h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl CRYPTO_nistcts128_decrypt(void *Src, void	*, int,	int, int, int)
		public _CRYPTO_nistcts128_decrypt
_CRYPTO_nistcts128_decrypt proc	near

var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
Dst		= xmmword ptr -24h
var_14		= xmmword ptr -14h
var_4		= dword	ptr -4
Src		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	eax, 30h ; '0'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+30h+var_4], eax
		mov	ecx, [esp+30h+arg_C]
		mov	eax, [esp+30h+arg_10]
		mov	edx, [esp+30h+arg_14]
		push	ebx
		mov	ebx, [esp+34h+arg_4]
		push	esi
		mov	esi, [esp+38h+arg_8]
		mov	[esp+38h+var_2C], ecx
		mov	[esp+38h+var_30], eax
		mov	[esp+38h+var_28], edx
		push	edi
		mov	edi, [esp+3Ch+Src]
		cmp	esi, 10h
		jnb	short loc_5CD
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebx
		mov	ecx, [esp+30h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 30h
		retn
; ---------------------------------------------------------------------------

loc_5CD:				; CODE XREF: _CRYPTO_nistcts128_decrypt+3Fj
		push	ebp
		mov	ebp, esi
		and	ebp, 0Fh
		jnz	short loc_5F5
		push	ebp
		push	eax
		push	ecx
		push	esi
		push	ebx
		push	edi
		call	edx
		add	esp, 18h
		mov	eax, esi
		pop	ebp
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [esp+30h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 30h
		retn
; ---------------------------------------------------------------------------

loc_5F5:				; CODE XREF: _CRYPTO_nistcts128_decrypt+5Bj
		mov	eax, 0FFFFFFF0h
		sub	eax, ebp
		add	esi, eax
		jz	short loc_61B
		push	0
		push	[esp+44h+var_30]
		push	ecx
		push	esi
		push	ebx
		push	edi
		call	edx
		mov	ecx, [esp+58h+var_2C]
		add	esp, 18h
		mov	edx, [esp+40h+var_28]
		add	edi, esi
		add	ebx, esi

loc_61B:				; CODE XREF: _CRYPTO_nistcts128_decrypt+86j
		push	0
		lea	eax, [esp+44h+var_14]
		xorps	xmm0, xmm0
		push	eax
		push	ecx
		push	10h
		lea	eax, [esp+50h+Dst]
		push	eax
		lea	eax, [edi+ebp]
		push	eax
		movups	[esp+58h+Dst], xmm0
		movups	[esp+58h+var_14], xmm0
		call	edx
		push	ebp		; Size
		lea	eax, [esp+5Ch+Dst]
		push	edi		; Src
		push	eax		; Dst
		call	_memcpy
		push	0
		push	[esp+68h+var_30]
		lea	eax, [esp+6Ch+Dst]
		push	[esp+6Ch+var_2C]
		push	20h ; ' '
		push	eax
		push	eax
		call	[esp+7Ch+var_28]
		lea	eax, [ebp+10h]
		push	eax		; Size
		lea	eax, [esp+80h+Dst]
		push	eax		; Src
		push	ebx		; Dst
		call	_memcpy
		mov	ecx, [esp+88h+var_4]
		lea	eax, [ebp+10h]
		add	esp, 48h
		add	eax, esi
		pop	ebp
		pop	edi
		pop	esi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 30h
		retn
_CRYPTO_nistcts128_decrypt endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 68Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_nistcts128_decrypt_block
_CRYPTO_nistcts128_decrypt_block proc near

Src		= dword	ptr -5Ch
var_58		= dword	ptr -58h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_4C		= dword	ptr -4Ch
var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
Dst		= xmmword ptr -24h
var_14		= xmmword ptr -14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	eax, 5Ch ; '\'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+5Ch+var_4], eax
		mov	ecx, [esp+5Ch+arg_0]
		mov	edx, [esp+5Ch+arg_C]
		mov	eax, [esp+5Ch+arg_14]
		push	ebx
		mov	ebx, [esp+60h+arg_8]
		mov	[esp+60h+Src], ecx
		mov	[esp+60h+var_54], edx
		mov	[esp+60h+var_58], eax
		push	ebp
		mov	ebp, [esp+64h+arg_4]
		mov	[esp+64h+var_50], ebp
		push	esi
		mov	esi, [esp+68h+arg_10]
		cmp	ebx, 10h
		jnb	short loc_6E5
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		mov	ecx, [esp+5Ch+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 5Ch
		retn
; ---------------------------------------------------------------------------

loc_6E5:				; CODE XREF: _CRYPTO_nistcts128_decrypt_block+43j
		push	edi
		mov	edi, ebx
		and	edi, 0Fh
		mov	[esp+6Ch+var_30], edi
		jnz	short loc_714
		push	eax
		push	esi
		push	edx
		push	ebx
		push	ebp
		push	ecx
		call	_CRYPTO_cbc128_decrypt
		add	esp, 18h
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+5Ch+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 5Ch
		retn
; ---------------------------------------------------------------------------

loc_714:				; CODE XREF: _CRYPTO_nistcts128_decrypt_block+63j
		mov	eax, 0FFFFFFF0h
		sub	eax, edi
		add	ebx, eax
		mov	[esp+6Ch+var_28], ebx
		jz	short loc_748
		push	[esp+6Ch+var_58]
		push	esi
		push	edx
		push	ebx
		push	ebp
		push	ecx
		call	_CRYPTO_cbc128_decrypt
		mov	ecx, [esp+84h+Src]
		add	esp, 18h
		mov	edx, [esp+6Ch+var_54]
		add	ecx, ebx
		add	ebp, ebx
		mov	[esp+6Ch+Src], ecx
		mov	[esp+6Ch+var_50], ebp

loc_748:				; CODE XREF: _CRYPTO_nistcts128_decrypt_block+95j
		push	edx
		lea	eax, [esp+70h+var_14]
		push	eax
		lea	eax, [ecx+edi]
		push	eax
		call	[esp+78h+var_58]
		movups	xmm0, [esp+78h+var_14]
		mov	ebx, [esp+78h+Src]
		lea	eax, [esp+78h+Dst]
		push	edi		; Size
		push	ebx		; Src
		push	eax		; Dst
		movups	[esp+84h+Dst], xmm0
		call	_memcpy
		push	[esp+84h+var_54]
		lea	eax, [esp+88h+Dst]
		push	eax
		push	eax
		call	[esp+90h+var_58]
		lea	ecx, [ebx+1]
		mov	edx, ebp
		mov	[esp+90h+var_4C], ecx
		sub	edx, esi
		mov	ecx, ebx
		mov	[esp+90h+var_2C], edx
		sub	ecx, ebp
		add	esp, 24h
		mov	[esp+6Ch+Src], ecx
		xor	eax, eax
		lea	ecx, [esp+6Ch+Dst]
		sub	ecx, esi
		mov	[esp+6Ch+var_54], ecx
		lea	ecx, [esp+6Ch+Dst+1]
		sub	ecx, esi
		mov	[esp+6Ch+var_58], ecx
		lea	ecx, [esp+6Ch+Dst+2]
		sub	ecx, esi
		mov	[esp+6Ch+var_44], ecx
		lea	ecx, [esp+6Ch+Dst+3]
		sub	ecx, esi
		mov	[esp+6Ch+var_38], ecx
		mov	ecx, ebp
		sub	ecx, ebx
		mov	[esp+6Ch+var_48], ecx
		lea	ecx, [edi+1]
		mov	[esp+6Ch+var_3C], ecx
		lea	ecx, [edi+2]
		mov	[esp+6Ch+var_34], ecx
		lea	ecx, [ebp+3]
		mov	ebp, [esp+6Ch+var_4C]
		mov	[esp+6Ch+var_40], ecx
		mov	ecx, [esp+6Ch+Src]
		nop	dword ptr [eax+eax+00h]

loc_7EC:				; CODE XREF: _CRYPTO_nistcts128_decrypt_block+201j
		add	edx, esi
		lea	ebp, [ebp+4]
		mov	bl, [edx+ecx]
		mov	ecx, [esp+6Ch+var_54]
		movzx	ecx, byte ptr [ecx+esi]
		xor	cl, [esi]
		mov	[edx], cl
		movzx	ecx, byte ptr [edi+ebp-5]
		mov	[esi], cl
		mov	ecx, [esp+6Ch+var_54]
		mov	dl, [ebp-4]
		mov	[ecx+esi], bl
		mov	ebx, [esp+6Ch+var_58]
		movzx	ecx, byte ptr [ebx+esi]
		xor	cl, [esi+1]
		mov	ebx, [esp+6Ch+var_48]
		mov	[ebx+ebp-4], cl
		movzx	ecx, byte ptr [edi+ebp-4]
		mov	ebx, [esp+6Ch+var_58]
		mov	edi, [esp+6Ch+var_40]
		mov	[esi+1], cl
		movzx	ecx, byte ptr [esi+2]
		mov	[ebx+esi], dl
		mov	ebx, [esp+6Ch+var_44]
		mov	dl, [ebp-3]
		xor	cl, [ebx+esi]
		mov	[edi+eax-1], cl
		mov	ecx, [esp+6Ch+var_3C]
		mov	[ebx+esi], dl
		mov	ebx, [esp+6Ch+var_38]
		movzx	ecx, byte ptr [ecx+ebp-4]
		mov	[esi+2], cl
		movzx	ecx, byte ptr [esi+3]
		xor	cl, [esi+ebx]
		mov	dl, [ebp-2]
		mov	[edi+eax], cl
		add	eax, 4
		mov	ecx, [esp+6Ch+var_34]
		mov	edi, [esp+6Ch+var_30]
		mov	[esi+ebx], dl
		mov	edx, [esp+6Ch+var_2C]
		movzx	ecx, byte ptr [ecx+ebp-4]
		mov	[esi+3], cl
		add	esi, 4
		mov	ecx, [esp+6Ch+Src]
		cmp	eax, 10h
		jb	loc_7EC
		mov	ebp, [esp+6Ch+var_50]
		add	edi, 10h
		mov	ebx, edi
		sub	ebx, eax
		cmp	eax, edi
		jnb	short loc_913
		cmp	ebx, 20h ; ' '
		jb	short loc_8F6
		lea	esi, [esp+6Ch+Dst]
		lea	edx, [esp+edi+6Ch+var_28+3]
		add	esi, eax
		lea	ecx, [eax+ebp]
		cmp	ecx, edx
		ja	short loc_8C4
		lea	ecx, [ebp-1]
		add	ecx, edi
		lea	edx, [esi-10h]
		cmp	ecx, edx
		jnb	short loc_8F6

loc_8C4:				; CODE XREF: _CRYPTO_nistcts128_decrypt_block+22Aj
		and	ebx, 1Fh
		mov	ecx, edi
		sub	ecx, ebx
		nop

loc_8CC:				; CODE XREF: _CRYPTO_nistcts128_decrypt_block+268j
		movups	xmm0, xmmword ptr [esi]
		lea	esi, [esi+20h]
		movups	xmm1, xmmword ptr [esi-30h]
		pxor	xmm1, xmm0
		movups	xmm0, xmmword ptr [esi-20h]
		movups	xmmword	ptr [eax+ebp], xmm1
		movups	xmm1, xmmword ptr [esi-10h]
		pxor	xmm1, xmm0
		movups	xmmword	ptr [eax+ebp+10h], xmm1
		add	eax, 20h ; ' '
		cmp	eax, ecx
		jb	short loc_8CC

loc_8F6:				; CODE XREF: _CRYPTO_nistcts128_decrypt_block+219j
					; _CRYPTO_nistcts128_decrypt_block+236j
		cmp	eax, edi
		jnb	short loc_913
		lea	ecx, [esp+6Ch+Dst]
		sub	ebp, ecx

loc_900:				; CODE XREF: _CRYPTO_nistcts128_decrypt_block+285j
		lea	edx, [esp+6Ch+Dst]
		add	edx, eax
		inc	eax
		mov	cl, [edx-10h]
		xor	cl, [edx]
		mov	[edx+ebp], cl
		cmp	eax, edi
		jb	short loc_900

loc_913:				; CODE XREF: _CRYPTO_nistcts128_decrypt_block+214j
					; _CRYPTO_nistcts128_decrypt_block+26Cj
		mov	eax, [esp+6Ch+var_28]
		mov	ecx, [esp+6Ch+var_4]
		add	eax, 10h
		add	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 5Ch
		retn
_CRYPTO_nistcts128_decrypt_block endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 930h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_nistcts128_encrypt
_CRYPTO_nistcts128_encrypt proc	near

var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
Dst		= xmmword ptr -14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	eax, 20h ; ' '
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+20h+var_4], eax
		mov	eax, [esp+20h+arg_C]
		mov	ecx, [esp+20h+arg_10]
		mov	edx, [esp+20h+arg_14]
		push	ebx
		mov	ebx, [esp+24h+arg_0]
		push	ebp
		mov	ebp, [esp+28h+arg_4]
		push	esi
		mov	esi, [esp+2Ch+arg_8]
		mov	[esp+2Ch+var_1C], eax
		mov	[esp+2Ch+var_20], ecx
		mov	[esp+2Ch+var_18], edx
		cmp	esi, 10h
		jnb	short loc_985
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		mov	ecx, [esp+20h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 20h
		retn
; ---------------------------------------------------------------------------

loc_985:				; CODE XREF: _CRYPTO_nistcts128_encrypt+3Fj
		push	edi
		push	1
		push	ecx
		mov	edi, esi
		push	eax
		and	edi, 0Fh
		sub	esi, edi
		push	esi
		push	ebp
		push	ebx
		call	edx
		add	esp, 18h
		test	edi, edi
		jnz	short loc_9B2
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+20h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 20h
		retn
; ---------------------------------------------------------------------------

loc_9B2:				; CODE XREF: _CRYPTO_nistcts128_encrypt+6Bj
		push	edi		; Size
		lea	eax, [esi+ebx]
		xorps	xmm0, xmm0
		push	eax		; Src
		lea	eax, [esp+38h+Dst]
		push	eax		; Dst
		movups	[esp+3Ch+Dst], xmm0
		call	_memcpy
		push	1
		push	[esp+40h+var_20]
		lea	eax, [ebp-10h]
		push	[esp+44h+var_1C]
		add	eax, esi
		add	eax, edi
		push	10h
		push	eax
		lea	eax, [esp+50h+Dst]
		push	eax
		call	[esp+54h+var_18]
		mov	ecx, [esp+54h+var_4]
		lea	eax, [esi+edi]
		add	esp, 24h
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 20h
		retn
_CRYPTO_nistcts128_encrypt endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A00h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_nistcts128_encrypt_block
_CRYPTO_nistcts128_encrypt_block proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	eax, 4
		call	__chkstk
		push	ebx
		mov	ebx, [esp+8+arg_8]
		cmp	ebx, 10h
		jnb	short loc_A19
		xor	eax, eax
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_A19:				; CODE XREF: _CRYPTO_nistcts128_encrypt_block+12j
		mov	eax, [esp+8+arg_4]
		push	ebp
		mov	ebp, [esp+0Ch+arg_10]
		push	esi
		push	edi
		push	[esp+14h+arg_14]
		mov	edi, [esp+18h+arg_0]
		mov	esi, ebx
		push	ebp
		push	[esp+1Ch+arg_C]
		and	esi, 0Fh
		sub	ebx, esi
		push	ebx
		push	eax
		push	edi
		mov	[esp+2Ch+arg_8], ebx
		call	_CRYPTO_cbc128_encrypt
		add	esp, 18h
		test	esi, esi
		jnz	short loc_A53
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, ebx
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_A53:				; CODE XREF: _CRYPTO_nistcts128_encrypt_block+49j
		add	[esp+14h+arg_4], ebx
		add	edi, ebx
		xor	ecx, ecx
		test	esi, esi
		jz	short loc_ADE
		cmp	esi, 20h ; ' '
		jb	short loc_AC0
		lea	eax, [esi-1]
		lea	edx, [ebp-1]
		add	eax, edi
		add	edx, esi
		cmp	ebp, eax
		ja	short loc_A76
		cmp	edx, edi
		jnb	short loc_AC0

loc_A76:				; CODE XREF: _CRYPTO_nistcts128_encrypt_block+70j
		mov	eax, esi
		mov	edx, esi
		and	eax, 1Fh
		mov	ebx, edi
		sub	edx, eax
		sub	ebx, ebp
		mov	[esp+14h+var_4], ebx
		mov	eax, ebp
		mov	ebx, [esp+14h+arg_8]
		mov	ebp, [esp+14h+var_4]

loc_A91:				; CODE XREF: _CRYPTO_nistcts128_encrypt_block+BAj
		movups	xmm0, xmmword ptr [eax]
		lea	eax, [eax+20h]
		movups	xmm1, xmmword ptr [eax+ebp-20h]
		pxor	xmm1, xmm0
		movups	xmmword	ptr [eax-20h], xmm1
		movups	xmm1, xmmword ptr [edi+ecx+10h]
		add	ecx, 20h ; ' '
		movups	xmm0, xmmword ptr [eax-10h]
		pxor	xmm1, xmm0
		movups	xmmword	ptr [eax-10h], xmm1
		cmp	ecx, edx
		jb	short loc_A91
		mov	ebp, [esp+14h+arg_10]

loc_AC0:				; CODE XREF: _CRYPTO_nistcts128_encrypt_block+62j
					; _CRYPTO_nistcts128_encrypt_block+74j
		cmp	ecx, esi
		jnb	short loc_ADE
		mov	edx, esi
		lea	eax, [ecx+ebp]
		sub	edi, ebp
		sub	edx, ecx
		nop	dword ptr [eax]

loc_AD0:				; CODE XREF: _CRYPTO_nistcts128_encrypt_block+DCj
		mov	cl, [eax+edi]
		lea	eax, [eax+1]
		xor	[eax-1], cl
		sub	edx, 1
		jnz	short loc_AD0

loc_ADE:				; CODE XREF: _CRYPTO_nistcts128_encrypt_block+5Dj
					; _CRYPTO_nistcts128_encrypt_block+C2j
		push	[esp+14h+arg_C]
		push	ebp
		push	ebp
		call	[esp+20h+arg_14]
		mov	eax, [esp+20h+arg_4]
		add	esp, 0Ch
		movups	xmm0, xmmword ptr [ebp+0]
		pop	edi
		movups	xmmword	ptr [esi+eax-10h], xmm0
		lea	eax, [esi+ebx]
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
_CRYPTO_nistcts128_encrypt_block endp

_text$mn	ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _CRYPTO_cbc128_encrypt:near
					; CODE XREF: _CRYPTO_cts128_encrypt_block+46p
					; _CRYPTO_nistcts128_encrypt_block+3Fp
		extrn _CRYPTO_cbc128_decrypt:near
					; CODE XREF: _CRYPTO_cts128_decrypt_block+82p
					; _CRYPTO_nistcts128_decrypt_block+6Bp	...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: _CRYPTO_cts128_decrypt+4Cp
					; _CRYPTO_cts128_decrypt+F1p ...
		extrn __chkstk:near	; CODE XREF: _CRYPTO_cts128_decrypt+5p
					; _CRYPTO_cts128_decrypt_block+5p ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _CRYPTO_cts128_decrypt+B2p
					; _CRYPTO_cts128_decrypt+D7p ...
		extrn ___security_cookie:near ;	DATA XREF: _CRYPTO_cts128_decrypt+Ar
					; _CRYPTO_cts128_decrypt_block+Ar ...


		end
