;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	88730B8483A4B818589227CB340CA2AD
; Input	CRC32 :	22084C04

; File Name   :	C:\compspace\Diff\openssl\obj\dso_win32.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_win32_load	proc near		; DATA XREF: .data:00000930o

arg_0		= dword	ptr  4

		push	ebx
		push	ebp
		mov	ebp, [esp+8+arg_0]
		push	esi
		push	edi
		xor	esi, esi
		push	esi
		push	ebp
		call	_DSO_convert_filename
		mov	edi, eax
		add	esp, 8
		test	edi, edi
		jnz	short loc_39
		push	0AEh ; 'Æ'
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	6Fh ; 'o'
		push	78h ; 'x'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_39:					; CODE XREF: _win32_load+18j
		push	edi		; lpLibFileName
		call	dword ptr ds:__imp__LoadLibraryA@4 ; LoadLibraryA(x)
		mov	ebx, eax
		test	ebx, ebx
		jnz	short loc_72
		push	0B3h ; '≥'
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	67h ; 'g'
		push	78h ; 'x'
		push	25h ; '%'
		call	_ERR_put_error
		push	offset ??_C@_01PKGAHCOL@?$CJ?$AA@ ; `string'
		push	edi
		push	offset ??_C@_09CCCHLKJP@filename?$CI?$AA@ ; "filename("
		push	3
		call	_ERR_add_error_data
		add	esp, 24h
		jmp	short $err$12
; ---------------------------------------------------------------------------

loc_72:					; CODE XREF: _win32_load+44j
		push	0B7h ; '∑'
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	4
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jnz	short loc_9A
		push	0B9h ; 'π'
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	41h ; 'A'
		jmp	short loc_B8
; ---------------------------------------------------------------------------

loc_9A:					; CODE XREF: _win32_load+8Aj
		mov	[esi], ebx
		push	esi
		push	dword ptr [ebp+4]
		call	_sk_push
		add	esp, 8
		test	eax, eax
		jnz	short loc_EC
		push	0BEh ; 'æ'
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	69h ; 'i'

loc_B8:					; CODE XREF: _win32_load+98j
		push	78h ; 'x'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h

$err$12:				; CODE XREF: _win32_load+70j
		push	edi
		call	_CRYPTO_free
		add	esp, 4
		test	esi, esi
		jz	short loc_DA
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_DA:					; CODE XREF: _win32_load+CFj
		test	ebx, ebx
		jz	short loc_E5
		push	ebx		; hLibModule
		call	dword ptr ds:__imp__FreeLibrary@4 ; FreeLibrary(x)

loc_E5:					; CODE XREF: _win32_load+DCj
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_EC:					; CODE XREF: _win32_load+AAj
		mov	[ebp+24h], edi
		mov	eax, 1
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_win32_load	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0FCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_win32_unload	proc near		; DATA XREF: .data:00000934o

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jnz	short loc_121
		push	0D3h ; '”'
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	43h ; 'C'
		push	79h ; 'y'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_121:				; CODE XREF: _win32_unload+7j
		push	dword ptr [esi+4]
		call	_sk_num
		add	esp, 4
		cmp	eax, 1
		jge	short loc_138
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_138:				; CODE XREF: _win32_unload+33j
		push	edi
		push	dword ptr [esi+4]
		call	_sk_pop
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jnz	short loc_167
		push	0DAh ; '⁄'
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	68h ; 'h'
		push	79h ; 'y'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_167:				; CODE XREF: _win32_unload+4Cj
		push	dword ptr [edi]	; hLibModule
		call	dword ptr ds:__imp__FreeLibrary@4 ; FreeLibrary(x)
		test	eax, eax
		jnz	short loc_199
		push	0DEh ; 'ﬁ'
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	6Bh ; 'k'
		push	79h ; 'y'
		push	25h ; '%'
		call	_ERR_put_error
		push	edi
		push	dword ptr [esi+4]
		call	_sk_push
		add	esp, 1Ch
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_199:				; CODE XREF: _win32_unload+75j
		push	edi
		call	_CRYPTO_free
		add	esp, 4
		mov	eax, 1
		pop	edi
		pop	esi
		retn
_win32_unload	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1ACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl win32_bind_var(int, LPCSTR lpProcName)
_win32_bind_var	proc near		; DATA XREF: .data:00000938o

arg_0		= dword	ptr  4
lpProcName	= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		test	esi, esi
		jz	loc_265
		mov	edi, [esp+8+lpProcName]
		test	edi, edi
		jz	loc_265
		push	dword ptr [esi+4]
		call	_sk_num
		add	esp, 4
		cmp	eax, 1
		jge	short loc_1F3
		push	0F8h ; '¯'
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	69h ; 'i'
		push	77h ; 'w'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1F3:				; CODE XREF: _win32_bind_var+28j
		push	dword ptr [esi+4]
		call	_sk_num
		dec	eax
		push	eax
		push	dword ptr [esi+4]
		call	_sk_value
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_229
		push	0FDh ; '˝'
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	68h ; 'h'
		push	77h ; 'w'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_229:				; CODE XREF: _win32_bind_var+5Ej
		push	edi		; lpProcName
		push	dword ptr [eax]	; hModule
		call	dword ptr ds:__imp__GetProcAddress@8 ; GetProcAddress(x,x)
		test	eax, eax
		jnz	short loc_27F
		push	102h
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	6Ah ; 'j'
		push	77h ; 'w'
		push	25h ; '%'
		call	_ERR_put_error
		push	offset ??_C@_01PKGAHCOL@?$CJ?$AA@ ; `string'
		push	edi
		push	offset ??_C@_08MFAHALLH@symname?$CI?$AA@ ; "symname("
		push	3
		call	_ERR_add_error_data
		add	esp, 24h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_265:				; CODE XREF: _win32_bind_var+8j
					; _win32_bind_var+14j
		push	0F4h ; 'Ù'
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	43h ; 'C'
		push	77h ; 'w'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax

loc_27F:				; CODE XREF: _win32_bind_var+88j
		pop	edi
		pop	esi
		retn
_win32_bind_var	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 284h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl win32_bind_func(int, LPCSTR lpProcName)
_win32_bind_func proc near		; DATA XREF: .data:0000093Co

arg_0		= dword	ptr  4
lpProcName	= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		test	esi, esi
		jz	loc_33D
		mov	edi, [esp+8+lpProcName]
		test	edi, edi
		jz	loc_33D
		push	dword ptr [esi+4]
		call	_sk_num
		add	esp, 4
		cmp	eax, 1
		jge	short loc_2CB
		push	113h
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	69h ; 'i'
		push	76h ; 'v'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_2CB:				; CODE XREF: _win32_bind_func+28j
		push	dword ptr [esi+4]
		call	_sk_num
		dec	eax
		push	eax
		push	dword ptr [esi+4]
		call	_sk_value
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_301
		push	118h
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	68h ; 'h'
		push	76h ; 'v'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_301:				; CODE XREF: _win32_bind_func+5Ej
		push	edi		; lpProcName
		push	dword ptr [eax]	; hModule
		call	dword ptr ds:__imp__GetProcAddress@8 ; GetProcAddress(x,x)
		test	eax, eax
		jnz	short loc_357
		push	11Dh
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	6Ah ; 'j'
		push	76h ; 'v'
		push	25h ; '%'
		call	_ERR_put_error
		push	offset ??_C@_01PKGAHCOL@?$CJ?$AA@ ; `string'
		push	edi
		push	offset ??_C@_08MFAHALLH@symname?$CI?$AA@ ; "symname("
		push	3
		call	_ERR_add_error_data
		add	esp, 24h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_33D:				; CODE XREF: _win32_bind_func+8j
					; _win32_bind_func+14j
		push	10Fh
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	43h ; 'C'
		push	76h ; 'v'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax

loc_357:				; CODE XREF: _win32_bind_func+88j
		pop	edi
		pop	esi
		retn
_win32_bind_func endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 35Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl win32_name_converter(int,	char *Str)
_win32_name_converter proc near		; DATA XREF: .data:00000944o

Str		= dword	ptr  8

		push	ebx
		push	esi
		push	edi
		mov	edi, [esp+0Ch+Str]
		mov	esi, edi
		lea	ecx, [esi+1]
		nop	dword ptr [eax+00h]

loc_36C:				; CODE XREF: _win32_name_converter+15j
		mov	al, [esi]
		inc	esi
		test	al, al
		jnz	short loc_36C
		mov	ebx, dword ptr ds:__imp__strstr
		sub	esi, ecx
		push	offset ??_C@_01KMDKNFGN@?1?$AA@	; "/"
		push	edi		; Str
		call	ebx ; __imp__strstr
		add	esp, 8
		test	eax, eax
		jnz	short loc_3B5
		push	offset ??_C@_01KICIPPFI@?2?$AA@	; "\\"
		push	edi		; Str
		call	ebx ; __imp__strstr
		add	esp, 8
		test	eax, eax
		jnz	short loc_3B5
		push	offset ??_C@_01JLIPDDHJ@?3?$AA@	; ":"
		push	edi		; Str
		call	ebx ; __imp__strstr
		add	esp, 8
		test	eax, eax
		jnz	short loc_3B5
		lea	ebx, [eax+1]
		push	24Ch
		lea	eax, [esi+5]
		jmp	short loc_3BF
; ---------------------------------------------------------------------------

loc_3B5:				; CODE XREF: _win32_name_converter+2Cj
					; _win32_name_converter+3Bj ...
		xor	ebx, ebx
		lea	eax, [esi+1]
		push	24Fh

loc_3BF:				; CODE XREF: _win32_name_converter+57j
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	eax
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jnz	short loc_3F1
		push	251h
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	6Dh ; 'm'
		push	7Dh ; '}'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_3F1:				; CODE XREF: _win32_name_converter+75j
		push	edi
		test	ebx, ebx
		jz	short loc_40A
		push	offset ??_C@_06DAJAKOAL@?$CFs?4dll?$AA@	; "%s.dll"
		push	esi		; Dest
		call	_sprintf
		add	esp, 0Ch
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_40A:				; CODE XREF: _win32_name_converter+98j
		push	offset ??_C@_02DKCKIIND@?$CFs?$AA@ ; "%s"
		push	esi		; Dest
		call	_sprintf
		add	esp, 0Ch
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebx
		retn
_win32_name_converter endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 420h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_win32_merger	proc near		; DATA XREF: .data:00000948o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		push	ebp
		push	esi
		mov	esi, [esp+0Ch+arg_4]
		xor	ebx, ebx
		push	edi
		xor	edi, edi
		test	esi, esi
		jnz	short loc_4A9
		mov	esi, [esp+10h+arg_8]
		test	esi, esi
		jnz	short loc_45A
		push	208h
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	43h ; 'C'

loc_444:				; CODE XREF: _win32_merger+71j
					; _win32_merger+C7j ...
		push	86h ; 'Ü'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_45A:				; CODE XREF: _win32_merger+16j
		mov	ecx, esi
		lea	edx, [ecx+1]
		nop

loc_460:				; CODE XREF: _win32_merger+45j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_460
		sub	ecx, edx
		push	213h
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		lea	eax, [ecx+1]
		push	eax
		call	_CRYPTO_malloc
		mov	ebp, eax
		add	esp, 0Ch
		test	ebp, ebp
		jnz	short loc_493
		push	215h
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	41h ; 'A'
		jmp	short loc_444
; ---------------------------------------------------------------------------

loc_493:				; CODE XREF: _win32_merger+63j
		mov	ecx, ebp
		sub	ecx, esi

loc_497:				; CODE XREF: _win32_merger+82j
		mov	al, [esi]
		lea	esi, [esi+1]
		mov	[ecx+esi-1], al
		test	al, al
		jnz	short loc_497
		jmp	loc_5CD
; ---------------------------------------------------------------------------

loc_4A9:				; CODE XREF: _win32_merger+Ej
		mov	ebp, [esp+10h+arg_8]
		test	ebp, ebp
		jnz	short loc_502
		mov	ecx, esi
		lea	edx, [ecx+1]

loc_4B6:				; CODE XREF: _win32_merger+9Bj
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_4B6
		sub	ecx, edx
		push	20Ch
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		lea	eax, [ecx+1]
		push	eax
		call	_CRYPTO_malloc
		mov	ebp, eax
		add	esp, 0Ch
		test	ebp, ebp
		jnz	short loc_4EC
		push	20Eh
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	41h ; 'A'
		jmp	loc_444
; ---------------------------------------------------------------------------

loc_4EC:				; CODE XREF: _win32_merger+B9j
		mov	ecx, ebp
		sub	ecx, esi

loc_4F0:				; CODE XREF: _win32_merger+DBj
		mov	al, [esi]
		lea	esi, [esi+1]
		mov	[ecx+esi-1], al
		test	al, al
		jnz	short loc_4F0
		jmp	loc_5CD
; ---------------------------------------------------------------------------

loc_502:				; CODE XREF: _win32_merger+8Fj
		push	0
		push	esi
		mov	esi, [esp+18h+arg_0]
		push	esi
		call	_win32_splitter
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jnz	short loc_529
		push	21Ch
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	41h ; 'A'
		jmp	loc_444
; ---------------------------------------------------------------------------

loc_529:				; CODE XREF: _win32_merger+F6j
		push	1
		push	ebp
		push	esi
		call	_win32_splitter
		mov	ebx, eax
		add	esp, 0Ch
		test	ebx, ebx
		jnz	short loc_563
		push	221h
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	41h ; 'A'
		push	86h ; 'Ü'
		push	25h ; '%'
		call	_ERR_put_error
		push	edi
		call	_CRYPTO_free
		add	esp, 18h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_563:				; CODE XREF: _win32_merger+119j
		cmp	dword ptr [edi], 0
		jnz	short loc_584
		cmp	dword ptr [edi+8], 0
		jnz	short loc_584
		mov	eax, [ebx]
		mov	[edi], eax
		mov	eax, [ebx+4]
		mov	[edi+4], eax
		mov	eax, [ebx+8]
		mov	[edi+8], eax
		mov	eax, [ebx+0Ch]
		mov	[edi+0Ch], eax

loc_584:				; CODE XREF: _win32_merger+146j
					; _win32_merger+14Cj
		mov	eax, [edi+18h]
		test	eax, eax
		jnz	short loc_599
		mov	eax, [ebx+18h]
		mov	[edi+18h], eax
		mov	eax, [ebx+1Ch]
		mov	[edi+1Ch], eax
		jmp	short loc_5AF
; ---------------------------------------------------------------------------

loc_599:				; CODE XREF: _win32_merger+169j
		mov	al, [eax]
		cmp	al, 5Ch	; '\'
		jz	short loc_5AF
		cmp	al, 2Fh	; '/'
		jz	short loc_5AF
		mov	eax, [ebx+18h]
		mov	[edi+10h], eax
		mov	eax, [ebx+1Ch]
		mov	[edi+14h], eax

loc_5AF:				; CODE XREF: _win32_merger+177j
					; _win32_merger+17Dj ...
		cmp	dword ptr [edi+20h], 0
		jnz	short loc_5C1
		mov	eax, [ebx+20h]
		mov	[edi+20h], eax
		mov	eax, [ebx+24h]
		mov	[edi+24h], eax

loc_5C1:				; CODE XREF: _win32_merger+193j
		push	edi
		push	esi
		call	_win32_joiner
		add	esp, 8
		mov	ebp, eax

loc_5CD:				; CODE XREF: _win32_merger+84j
					; _win32_merger+DDj
		push	edi
		call	_CRYPTO_free
		push	ebx
		call	_CRYPTO_free
		add	esp, 8
		mov	eax, ebp
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_win32_merger	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5E4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_win32_pathbyaddr proc near		; DATA XREF: _win32_pathbyaddr+2Eo
					; .data:00000954o

var_234		= dword	ptr -234h
var_230		= dword	ptr -230h
Dst		= dword	ptr -22Ch
var_228		= dword	ptr -228h
var_214		= dword	ptr -214h
var_210		= dword	ptr -210h
Src		= byte ptr -108h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 234h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+234h+var_4], eax
		mov	eax, [esp+234h+arg_4]
		push	esi
		mov	esi, [esp+238h+arg_0]
		test	esi, esi
		push	edi
		mov	[esp+23Ch+Dst],	eax
		mov	eax, offset _win32_pathbyaddr
		push	offset ??_C@_0N@NHGLKGEC@KERNEL32?4DLL?$AA@ ; "KERNEL32.DLL"
		cmovz	esi, eax
		call	dword ptr ds:__imp__LoadLibraryA@4 ; LoadLibraryA(x)
		mov	edi, eax
		test	edi, edi
		jnz	short loc_660
		push	289h
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	6Ch ; 'l'
		push	8Dh ; 'ç'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		pop	edi
		pop	esi
		mov	ecx, [esp+234h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 234h
		retn
; ---------------------------------------------------------------------------

loc_660:				; CODE XREF: _win32_pathbyaddr+45j
		push	ebx
		mov	ebx, dword ptr ds:__imp__GetProcAddress@8 ; GetProcAddress(x,x)
		push	offset ??_C@_0BJ@JEFKDHMD@CreateToolhelp32Snapshot?$AA@	; "CreateToolhelp32Snapshot"
		push	edi		; hModule
		call	ebx ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	[esp+240h+var_234], eax
		test	eax, eax
		jnz	short loc_6B4
		push	edi		; hLibModule
		call	dword ptr ds:__imp__FreeLibrary@4 ; FreeLibrary(x)
		push	291h
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	6Ch ; 'l'
		push	8Dh ; 'ç'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		pop	ebx
		pop	edi
		pop	esi
		mov	ecx, [esp+234h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 234h
		retn
; ---------------------------------------------------------------------------

loc_6B4:				; CODE XREF: _win32_pathbyaddr+91j
		push	ebp
		push	offset ??_C@_0O@CNMFJJGO@Module32First?$AA@ ; "Module32First"
		push	edi		; hModule
		call	ebx ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		push	offset ??_C@_0N@KIGOLBLC@Module32Next?$AA@ ; "Module32Next"
		push	edi		; hModule
		mov	[esp+24Ch+var_230], eax
		call	ebx ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		push	0
		push	8
		mov	ebp, eax
		call	[esp+24Ch+var_234]
		mov	ebx, eax
		cmp	ebx, 0FFFFFFFFh
		jnz	short loc_6EF
		push	edi		; hLibModule
		call	dword ptr ds:__imp__FreeLibrary@4 ; FreeLibrary(x)
		push	2A1h
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	6Ch ; 'l'
		jmp	short loc_71F
; ---------------------------------------------------------------------------

loc_6EF:				; CODE XREF: _win32_pathbyaddr+F4j
		lea	eax, [esp+244h+var_228]
		mov	[esp+244h+var_228], 224h
		push	eax
		push	ebx
		call	[esp+24Ch+var_230]
		test	eax, eax
		jnz	short loc_734
		push	ebx		; hObject
		call	dword ptr ds:__imp__CloseHandle@4 ; CloseHandle(x)
		push	edi		; hLibModule
		call	dword ptr ds:__imp__FreeLibrary@4 ; FreeLibrary(x)
		push	2AAh
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	72h ; 'r'

loc_71F:				; CODE XREF: _win32_pathbyaddr+109j
		push	8Dh ; 'ç'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		jmp	short loc_762
; ---------------------------------------------------------------------------
		align 4

loc_734:				; CODE XREF: _win32_pathbyaddr+11Fj
					; _win32_pathbyaddr+16Cj
		mov	ecx, [esp+244h+var_214]
		cmp	esi, ecx
		jb	short loc_746
		mov	eax, [esp+244h+var_210]
		add	eax, ecx
		cmp	esi, eax
		jb	short loc_77B

loc_746:				; CODE XREF: _win32_pathbyaddr+156j
		lea	eax, [esp+244h+var_228]
		push	eax
		push	ebx
		call	ebp
		test	eax, eax
		jnz	short loc_734
		push	ebx		; hObject
		call	dword ptr ds:__imp__CloseHandle@4 ; CloseHandle(x)
		push	edi		; hLibModule
		call	dword ptr ds:__imp__FreeLibrary@4 ; FreeLibrary(x)
		xor	eax, eax

loc_762:				; CODE XREF: _win32_pathbyaddr+14Dj
					; _win32_pathbyaddr+1E8j
		mov	ecx, [esp+244h+var_4]
		pop	ebp
		pop	ebx
		pop	edi
		pop	esi
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 234h
		retn
; ---------------------------------------------------------------------------

loc_77B:				; CODE XREF: _win32_pathbyaddr+160j
		push	ebx		; hObject
		call	dword ptr ds:__imp__CloseHandle@4 ; CloseHandle(x)
		push	edi		; hLibModule
		call	dword ptr ds:__imp__FreeLibrary@4 ; FreeLibrary(x)
		lea	esi, [esp+244h+Src]
		lea	ecx, [esi+1]
		nop

loc_794:				; CODE XREF: _win32_pathbyaddr+1B5j
		mov	al, [esi]
		inc	esi
		test	al, al
		jnz	short loc_794
		mov	eax, [esp+244h+arg_8]
		sub	esi, ecx
		test	eax, eax
		jle	short loc_7C9
		cmp	esi, eax
		jl	short loc_7AF
		lea	esi, [eax-1]

loc_7AF:				; CODE XREF: _win32_pathbyaddr+1C6j
		mov	edi, [esp+244h+Dst]
		lea	eax, [esp+244h+Src]
		push	esi		; Size
		push	eax		; Src
		push	edi		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	byte ptr [edi+esi], 0

loc_7C9:				; CODE XREF: _win32_pathbyaddr+1C2j
		lea	eax, [esi+1]
		jmp	short loc_762
_win32_pathbyaddr endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7D0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl win32_globallookup(LPCSTR	lpProcName)
_win32_globallookup proc near		; DATA XREF: .data:00000958o

var_234		= dword	ptr -234h
var_230		= dword	ptr -230h
var_22C		= dword	ptr -22Ch
var_228		= dword	ptr -228h
hModule		= dword	ptr -20Ch
var_4		= dword	ptr -4
lpProcName	= dword	ptr  4

		mov	eax, 234h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+234h+var_4], eax
		push	ebx
		mov	ebx, [esp+238h+lpProcName]
		push	esi
		push	offset ??_C@_0N@NHGLKGEC@KERNEL32?4DLL?$AA@ ; "KERNEL32.DLL"
		mov	[esp+240h+var_22C], ebx
		call	dword ptr ds:__imp__LoadLibraryA@4 ; LoadLibraryA(x)
		mov	esi, eax
		test	esi, esi
		jnz	short loc_83A
		push	2E4h
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	6Ch ; 'l'
		push	8Eh ; 'é'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		pop	ebx
		mov	ecx, [esp+234h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 234h
		retn
; ---------------------------------------------------------------------------

loc_83A:				; CODE XREF: _win32_globallookup+34j
		push	ebp
		mov	ebp, dword ptr ds:__imp__GetProcAddress@8 ; GetProcAddress(x,x)
		push	edi
		push	offset ??_C@_0BJ@JEFKDHMD@CreateToolhelp32Snapshot?$AA@	; "CreateToolhelp32Snapshot"
		push	esi		; hModule
		call	ebp ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	edi, eax
		test	edi, edi
		jnz	short loc_85E
		push	esi		; hLibModule
		call	dword ptr ds:__imp__FreeLibrary@4 ; FreeLibrary(x)
		push	2ECh
		jmp	short loc_88F
; ---------------------------------------------------------------------------

loc_85E:				; CODE XREF: _win32_globallookup+7Ej
		push	offset ??_C@_0O@CNMFJJGO@Module32First?$AA@ ; "Module32First"
		push	esi		; hModule
		call	ebp ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		push	offset ??_C@_0N@KIGOLBLC@Module32Next?$AA@ ; "Module32Next"
		push	esi		; hModule
		mov	[esp+24Ch+var_234], eax
		call	ebp ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		push	0
		push	8
		mov	[esp+24Ch+var_230], eax
		call	edi
		mov	edi, eax
		cmp	edi, 0FFFFFFFFh
		jnz	short loc_8A9
		push	esi		; hLibModule
		call	dword ptr ds:__imp__FreeLibrary@4 ; FreeLibrary(x)
		push	2FCh

loc_88F:				; CODE XREF: _win32_globallookup+8Cj
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	6Ch ; 'l'
		push	8Eh ; 'é'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		jmp	short loc_912
; ---------------------------------------------------------------------------

loc_8A9:				; CODE XREF: _win32_globallookup+B1j
		lea	eax, [esp+244h+var_228]
		mov	[esp+244h+var_228], 224h
		push	eax
		push	edi
		call	[esp+24Ch+var_234]
		test	eax, eax
		jnz	short loc_8D1
		push	edi		; hObject
		call	dword ptr ds:__imp__CloseHandle@4 ; CloseHandle(x)
		push	esi		; hLibModule
		call	dword ptr ds:__imp__FreeLibrary@4 ; FreeLibrary(x)
		xor	eax, eax
		jmp	short loc_912
; ---------------------------------------------------------------------------

loc_8D1:				; CODE XREF: _win32_globallookup+EDj
					; _win32_globallookup+11Ej
		push	ebx		; lpProcName
		push	[esp+248h+hModule] ; hModule
		call	ebp ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	ebx, eax
		test	ebx, ebx
		jnz	short loc_902
		lea	eax, [esp+244h+var_228]
		push	eax
		push	edi
		call	[esp+24Ch+var_230]
		mov	ebx, [esp+244h+var_22C]
		test	eax, eax
		jnz	short loc_8D1
		push	edi		; hObject
		call	dword ptr ds:__imp__CloseHandle@4 ; CloseHandle(x)
		push	esi		; hLibModule
		call	dword ptr ds:__imp__FreeLibrary@4 ; FreeLibrary(x)
		xor	eax, eax
		jmp	short loc_912
; ---------------------------------------------------------------------------

loc_902:				; CODE XREF: _win32_globallookup+10Cj
		push	edi		; hObject
		call	dword ptr ds:__imp__CloseHandle@4 ; CloseHandle(x)
		push	esi		; hLibModule
		call	dword ptr ds:__imp__FreeLibrary@4 ; FreeLibrary(x)
		mov	eax, ebx

loc_912:				; CODE XREF: _win32_globallookup+D7j
					; _win32_globallookup+FFj ...
		mov	ecx, [esp+244h+var_4]
		pop	edi
		pop	ebp
		pop	esi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 234h
		retn
_win32_globallookup endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 92Ch
_dso_meth_win32	dd offset ??_C@_0CG@ELPNGFCJ@OpenSSL?5?8win32?8?5shared?5library?5m@
					; DATA XREF: _DSO_METHOD_win32o
					; "OpenSSL 'win32' shared library method"
		dd offset _win32_load
		dd offset _win32_unload
		dd offset _win32_bind_var
		dd offset _win32_bind_func
		dd 0
		dd offset _win32_name_converter
		dd offset _win32_merger
		dd 2 dup(0)
		dd offset _win32_pathbyaddr
		dd offset _win32_globallookup
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 95Ch
; COMDAT (pick any)
		public ??_C@_0CG@ELPNGFCJ@OpenSSL?5?8win32?8?5shared?5library?5m@
; `string'
??_C@_0CG@ELPNGFCJ@OpenSSL?5?8win32?8?5shared?5library?5m@ db 'OpenSSL ',27h,'win32',27h,' shared library method',0
					; DATA XREF: .data:_dso_meth_win32o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 984h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _DSO_METHOD_win32
_DSO_METHOD_win32 proc near
		mov	eax, offset _dso_meth_win32
		retn
_DSO_METHOD_win32 endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 98Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public ___local_stdio_printf_options
___local_stdio_printf_options proc near	; CODE XREF: __vsnprintf_l+14p
					; __vsprintf_l+12p ...
		mov	eax, offset ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
		retn
___local_stdio_printf_options endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 994h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl _vsnprintf_l(char	*DstBuf, size_t	MaxCount, const	char *Format, _locale_t	Locale,	va_list	ArgList)
		public __vsnprintf_l
__vsnprintf_l	proc near

DstBuf		= dword	ptr  4
MaxCount	= dword	ptr  8
Format		= dword	ptr  0Ch
Locale		= dword	ptr  10h
ArgList		= dword	ptr  14h

		push	[esp+ArgList]
		push	[esp+4+Locale]
		push	[esp+8+Format]
		push	[esp+0Ch+MaxCount]
		push	[esp+10h+DstBuf]
		call	___local_stdio_printf_options
		mov	ecx, [eax]
		push	dword ptr [eax+4]
		or	ecx, 1
		push	ecx
		call	dword ptr ds:__imp____stdio_common_vsprintf
		or	ecx, 0FFFFFFFFh
		add	esp, 1Ch
		test	eax, eax
		cmovs	eax, ecx
		retn
__vsnprintf_l	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 9C8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl _vsprintf_l(char *DstBuf,	const char *Format, _locale_t, va_list ArgList)
		public __vsprintf_l
__vsprintf_l	proc near

DstBuf		= dword	ptr  4
Format		= dword	ptr  8
arg_8		= dword	ptr  0Ch
ArgList		= dword	ptr  10h

		push	[esp+ArgList]
		push	[esp+4+arg_8]
		push	[esp+8+Format]
		push	0FFFFFFFFh
		push	[esp+10h+DstBuf]
		call	___local_stdio_printf_options
		mov	ecx, [eax]
		push	dword ptr [eax+4]
		or	ecx, 1
		push	ecx
		call	dword ptr ds:__imp____stdio_common_vsprintf
		or	ecx, 0FFFFFFFFh
		add	esp, 1Ch
		test	eax, eax
		cmovs	eax, ecx
		retn
__vsprintf_l	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 9FCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_openssl_strnchr proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		xor	edx, edx
		push	esi
		mov	esi, [esp+4+arg_8]
		push	edi
		test	esi, esi
		jz	short loc_A23
		mov	edi, [esp+8+arg_4]

loc_A10:				; CODE XREF: _openssl_strnchr+25j
		mov	al, [ecx]
		test	al, al
		jz	short loc_A23
		movsx	eax, al
		cmp	eax, edi
		jz	short loc_A28
		inc	edx
		inc	ecx
		cmp	edx, esi
		jb	short loc_A10

loc_A23:				; CODE XREF: _openssl_strnchr+Ej
					; _openssl_strnchr+18j
		pop	edi
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_A28:				; CODE XREF: _openssl_strnchr+1Fj
		pop	edi
		mov	eax, ecx
		pop	esi
		retn
_openssl_strnchr endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A30h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int sprintf(char *Dest, const	char *Format, ...)
		public _sprintf
_sprintf	proc near		; CODE XREF: _win32_name_converter+A0p
					; _win32_name_converter+B4p

Dest		= dword	ptr  4
Format		= dword	ptr  8
arg_8		= byte ptr  0Ch

		lea	eax, [esp+arg_8]
		push	eax
		push	0
		push	[esp+8+Format]
		push	0FFFFFFFFh
		push	[esp+10h+Dest]
		call	___local_stdio_printf_options
		mov	ecx, [eax]
		push	dword ptr [eax+4]
		or	ecx, 1
		push	ecx
		call	dword ptr ds:__imp____stdio_common_vsprintf
		or	ecx, 0FFFFFFFFh
		add	esp, 1Ch
		test	eax, eax
		cmovs	eax, ecx
		retn
_sprintf	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A64h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_win32_joiner	proc near		; CODE XREF: _win32_merger+1A3p

Source		= dword	ptr -8
var_4		= dword	ptr -4
arg_4		= dword	ptr  8

		mov	eax, 8
		call	__chkstk
		push	ebx
		mov	ebx, [esp+0Ch+arg_4]
		xor	eax, eax
		push	ebp
		xor	ebp, ebp
		test	ebx, ebx
		jnz	short loc_A9F
		push	1A3h
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	43h ; 'C'

loc_A88:				; CODE XREF: _win32_joiner+91j
		push	87h ; 'á'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	ebp
		pop	ebx
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_A9F:				; CODE XREF: _win32_joiner+16j
		cmp	[ebx], eax
		jz	short loc_ABA
		mov	eax, [ebx+4]
		add	eax, 2
		cmp	[ebx+10h], ebp
		jnz	short loc_AC2
		cmp	[ebx+18h], ebp
		jnz	short loc_AC2
		cmp	[ebx+20h], ebp
		jz	short loc_AC3
		jmp	short loc_AC2
; ---------------------------------------------------------------------------

loc_ABA:				; CODE XREF: _win32_joiner+3Dj
		cmp	[ebx+8], eax
		jz	short loc_AC3
		mov	eax, [ebx+0Ch]

loc_AC2:				; CODE XREF: _win32_joiner+48j
					; _win32_joiner+4Dj ...
		inc	eax

loc_AC3:				; CODE XREF: _win32_joiner+52j
					; _win32_joiner+59j
		add	eax, [ebx+14h]
		cmp	[ebx+10h], ebp
		jz	short loc_AD6
		cmp	[ebx+18h], ebp
		jnz	short loc_AD5
		cmp	[ebx+20h], ebp
		jz	short loc_AD6

loc_AD5:				; CODE XREF: _win32_joiner+6Aj
		inc	eax

loc_AD6:				; CODE XREF: _win32_joiner+65j
					; _win32_joiner+6Fj
		add	eax, [ebx+1Ch]
		cmp	[ebx+18h], ebp
		jz	short loc_AE4
		cmp	[ebx+20h], ebp
		jz	short loc_AE4
		inc	eax

loc_AE4:				; CODE XREF: _win32_joiner+78j
					; _win32_joiner+7Dj
		add	eax, [ebx+24h]
		jnz	short loc_AF7
		push	1B8h
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	71h ; 'q'
		jmp	short loc_A88
; ---------------------------------------------------------------------------

loc_AF7:				; CODE XREF: _win32_joiner+83j
		push	esi
		push	1BCh
		inc	eax
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	eax
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		mov	[esp+14h+arg_4], esi
		test	esi, esi
		jnz	short loc_B3A
		push	1BEh
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	41h ; 'A'
		push	87h ; 'á'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_B3A:				; CODE XREF: _win32_joiner+B0j
		mov	ecx, dword ptr ds:__imp__strncpy
		cmp	[ebx], ebp
		jz	short loc_B81
		mov	ax, ds:??_C@_02HDBGODGB@?2?2?$AA@ ; `string'
		mov	[esi], ax
		mov	al, ds:byte_F12
		mov	[esi+2], al
		lea	eax, [esi+2]
		push	dword ptr [ebx+4] ; Count
		push	dword ptr [ebx]	; Source
		push	eax		; Dest
		call	ecx ; __imp__strncpy
		mov	ebp, [ebx+4]
		add	esp, 0Ch
		add	ebp, 2
		cmp	dword ptr [ebx+10h], 0
		jnz	short loc_B7B
		cmp	dword ptr [ebx+18h], 0
		jnz	short loc_B7B
		cmp	dword ptr [ebx+20h], 0
		jz	short loc_B9A

loc_B7B:				; CODE XREF: _win32_joiner+109j
					; _win32_joiner+10Fj
		mov	byte ptr [esi+ebp], 5Ch	; '\'
		jmp	short loc_B99
; ---------------------------------------------------------------------------

loc_B81:				; CODE XREF: _win32_joiner+DEj
		mov	eax, [ebx+8]
		test	eax, eax
		jz	short loc_B9A
		push	dword ptr [ebx+0Ch] ; Count
		push	eax		; Source
		push	esi		; Dest
		call	ecx ; __imp__strncpy
		mov	ebp, [ebx+0Ch]
		add	esp, 0Ch
		mov	byte ptr [esi+ebp], 3Ah	; ':'

loc_B99:				; CODE XREF: _win32_joiner+11Bj
		inc	ebp

loc_B9A:				; CODE XREF: _win32_joiner+115j
					; _win32_joiner+122j
		mov	ecx, [ebx+10h]
		mov	esi, ecx
		mov	edx, [ebx+14h]
		mov	eax, esi
		sub	eax, ecx
		mov	[esp+14h+Source], ecx
		push	edi
		cmp	edx, eax
		jle	short loc_C13
		nop	dword ptr [eax+eax+00h]

loc_BB4:				; CODE XREF: _win32_joiner+1ADj
		add	edx, ecx
		xor	eax, eax
		mov	[esp+18h+var_4], edx
		mov	edi, esi
		sub	edx, esi
		jz	short loc_BD5
		xchg	ax, ax

loc_BC4:				; CODE XREF: _win32_joiner+16Fj
		mov	cl, [edi]
		test	cl, cl
		jz	short loc_BD5
		cmp	cl, 2Fh	; '/'
		jz	short loc_BD9
		inc	eax
		inc	edi
		cmp	eax, edx
		jb	short loc_BC4

loc_BD5:				; CODE XREF: _win32_joiner+15Cj
					; _win32_joiner+164j
		mov	edi, [esp+18h+var_4]

loc_BD9:				; CODE XREF: _win32_joiner+169j
		mov	eax, [esp+18h+Source]
		mov	esi, edi
		sub	esi, eax
		push	esi		; Count
		push	eax		; Source
		mov	eax, [esp+20h+arg_4]
		add	eax, ebp
		push	eax		; Dest
		call	dword ptr ds:__imp__strncpy
		mov	eax, [esp+24h+arg_4]
		add	ebp, esi
		lea	esi, [edi+1]
		add	esp, 0Ch
		mov	[esp+18h+Source], esi
		mov	byte ptr [eax+ebp], 5Ch	; '\'
		mov	eax, esi
		mov	ecx, [ebx+10h]
		inc	ebp
		mov	edx, [ebx+14h]
		sub	eax, ecx
		cmp	edx, eax
		jg	short loc_BB4

loc_C13:				; CODE XREF: _win32_joiner+149j
		mov	ecx, [ebx+18h]
		mov	esi, ecx
		mov	edx, [ebx+1Ch]
		mov	eax, esi
		sub	eax, ecx
		mov	[esp+18h+Source], ecx
		cmp	edx, eax
		jle	short loc_C84

loc_C27:				; CODE XREF: _win32_joiner+21Ej
		add	edx, ecx
		xor	eax, eax
		mov	[esp+18h+var_4], edx
		mov	edi, esi
		sub	edx, esi
		jz	short loc_C46

loc_C35:				; CODE XREF: _win32_joiner+1E0j
		mov	cl, [edi]
		test	cl, cl
		jz	short loc_C46
		cmp	cl, 2Fh	; '/'
		jz	short loc_C4A
		inc	eax
		inc	edi
		cmp	eax, edx
		jb	short loc_C35

loc_C46:				; CODE XREF: _win32_joiner+1CFj
					; _win32_joiner+1D5j
		mov	edi, [esp+18h+var_4]

loc_C4A:				; CODE XREF: _win32_joiner+1DAj
		mov	eax, [esp+18h+Source]
		mov	esi, edi
		sub	esi, eax
		push	esi		; Count
		push	eax		; Source
		mov	eax, [esp+20h+arg_4]
		add	eax, ebp
		push	eax		; Dest
		call	dword ptr ds:__imp__strncpy
		mov	eax, [esp+24h+arg_4]
		add	ebp, esi
		lea	esi, [edi+1]
		add	esp, 0Ch
		mov	[esp+18h+Source], esi
		mov	byte ptr [eax+ebp], 5Ch	; '\'
		mov	eax, esi
		mov	ecx, [ebx+18h]
		inc	ebp
		mov	edx, [ebx+1Ch]
		sub	eax, ecx
		cmp	edx, eax
		jg	short loc_C27

loc_C84:				; CODE XREF: _win32_joiner+1C1j
		push	dword ptr [ebx+24h] ; Count
		mov	esi, [esp+1Ch+arg_4]
		push	dword ptr [ebx+20h] ; Source
		lea	eax, [esi+ebp]
		push	eax		; Dest
		call	dword ptr ds:__imp__strncpy
		mov	eax, [ebx+24h]
		add	esp, 0Ch
		add	eax, esi
		pop	edi
		mov	byte ptr [eax+ebp], 0
		mov	eax, esi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 8
		retn
_win32_joiner	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0CB0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_win32_splitter	proc near		; CODE XREF: _win32_merger+EAp
					; _win32_merger+10Dp

arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		push	esi
		mov	esi, [esp+8+arg_4]
		mov	ebx, esi
		test	esi, esi
		jnz	short loc_CDC
		push	13Ah
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	6Fh ; 'o'
		push	88h ; 'à'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_CDC:				; CODE XREF: _win32_splitter+Aj
		push	edi
		push	141h
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	28h ; '('
		call	_CRYPTO_malloc
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jnz	short loc_D18
		push	143h
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	41h ; 'A'
		push	88h ; 'à'
		push	25h ; '%'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_D18:				; CODE XREF: _win32_splitter+45j
		xorps	xmm0, xmm0
		mov	edx, 1
		movups	xmmword	ptr [edi], xmm0
		movups	xmmword	ptr [edi+10h], xmm0
		movq	qword ptr [edi+20h], xmm0
		mov	al, [esi]
		cmp	al, 5Ch	; '\'
		jnz	short loc_D37
		cmp	[esi+1], al
		jz	short loc_D40

loc_D37:				; CODE XREF: _win32_splitter+80j
		cmp	al, 2Fh	; '/'
		jnz	short loc_D50
		cmp	[esi+1], al
		jnz	short loc_D50

loc_D40:				; CODE XREF: _win32_splitter+85j
		xor	edx, edx
		add	esi, 2
		mov	ebx, esi
		mov	[edi], esi
		nop	dword ptr [eax+00000000h]

loc_D50:				; CODE XREF: _win32_splitter+89j
					; _win32_splitter+8Ej ...
		mov	cl, [esi]
		movsx	eax, cl
		cmp	eax, 5Ch ; '\'  ; switch 4 cases
		ja	$LN26		; jumptable 00000D65 default case
		movzx	eax, ds:$LN40[eax]
		jmp	ds:$LN46[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN12:					; CODE XREF: _win32_splitter+B5j
					; DATA XREF: .text$mn:$LN46o
		cmp	edx, 1		; jumptable 00000D65 case 2
		jnz	loc_E3E
		mov	eax, esi
		mov	[edi+8], ebx
		sub	eax, ebx
		mov	edx, 2
		inc	esi
		mov	[edi+0Ch], eax
		mov	ebx, esi
		mov	[edi+18h], esi
		jmp	short loc_DFD
; ---------------------------------------------------------------------------

$LN14:					; CODE XREF: _win32_splitter+B5j
					; DATA XREF: .text$mn:$LN46o
		test	edx, edx	; jumptable 00000D65 case 1
		jnz	short loc_DA4
		mov	eax, esi
		mov	edx, 2
		sub	eax, ebx
		inc	esi
		mov	[edi+4], eax
		mov	ebx, esi
		mov	[edi+18h], esi
		jmp	short loc_DFD
; ---------------------------------------------------------------------------

loc_DA4:				; CODE XREF: _win32_splitter+DEj
		inc	esi
		mov	eax, esi
		sub	eax, ebx
		cmp	edx, 1
		jnz	short loc_DBD
		mov	[edi+18h], ebx
		mov	edx, 2
		mov	[edi+1Ch], eax
		mov	ebx, esi
		jmp	short loc_DFD
; ---------------------------------------------------------------------------

loc_DBD:				; CODE XREF: _win32_splitter+FCj
		add	[edi+1Ch], eax
		mov	ebx, esi
		jmp	short loc_DFD
; ---------------------------------------------------------------------------

$LN19:					; CODE XREF: _win32_splitter+B5j
					; DATA XREF: .text$mn:$LN46o
		mov	eax, esi	; jumptable 00000D65 case 0
		sub	eax, ebx
		test	edx, edx
		jnz	short loc_DD1
		mov	[edi+4], eax
		jmp	short loc_DFD
; ---------------------------------------------------------------------------

loc_DD1:				; CODE XREF: _win32_splitter+11Aj
		test	eax, eax
		jle	short loc_DFD
		cmp	[esp+0Ch+arg_8], 0
		jz	short loc_DF4
		cmp	edx, 1
		jnz	short loc_DEB
		mov	[edi+18h], ebx
		mov	dword ptr [edi+1Ch], 0

loc_DEB:				; CODE XREF: _win32_splitter+12Fj
		mov	eax, esi
		sub	eax, ebx
		add	[edi+1Ch], eax
		jmp	short loc_DFD
; ---------------------------------------------------------------------------

loc_DF4:				; CODE XREF: _win32_splitter+12Aj
		mov	[edi+20h], ebx
		mov	[edi+24h], eax
		jmp	short loc_DFD
; ---------------------------------------------------------------------------

$LN26:					; CODE XREF: _win32_splitter+A8j
					; _win32_splitter+B5j
					; DATA XREF: ...
		inc	esi		; jumptable 00000D65 default case

loc_DFD:				; CODE XREF: _win32_splitter+DAj
					; _win32_splitter+F2j ...
		test	cl, cl
		jnz	loc_D50
		cmp	dword ptr [edi+4], 0
		jnz	short loc_E11
		mov	dword ptr [edi], 0

loc_E11:				; CODE XREF: _win32_splitter+159j
		cmp	dword ptr [edi+0Ch], 0
		jnz	short loc_E1E
		mov	dword ptr [edi+8], 0

loc_E1E:				; CODE XREF: _win32_splitter+165j
		cmp	dword ptr [edi+1Ch], 0
		jnz	short loc_E2B
		mov	dword ptr [edi+18h], 0

loc_E2B:				; CODE XREF: _win32_splitter+172j
		cmp	dword ptr [edi+24h], 0
		jnz	short loc_E38
		mov	dword ptr [edi+20h], 0

loc_E38:				; CODE XREF: _win32_splitter+17Fj
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_E3E:				; CODE XREF: _win32_splitter+BFj
		push	157h
		push	offset ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ ; ".\\crypto\\dso\\dso_win32.c"
		push	73h ; 's'
		push	88h ; 'à'
		push	25h ; '%'
		call	_ERR_put_error
		push	edi
		call	_CRYPTO_free
		add	esp, 18h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		retn
_win32_splitter	endp

; ---------------------------------------------------------------------------
		align 4
$LN46		dd offset $LN19		; DATA XREF: _win32_splitter+B5r
		dd offset $LN14		; jump table for switch	statement
		dd offset $LN12
		dd offset $LN26
$LN40		db 0			; DATA XREF: _win32_splitter+AEr
		db 3 dup(3)
		dd 0Ah dup(3030303h), 1030303h,	2 dup(3030303h), 3020303h
		dd 8 dup(3030303h)
		db 1
		db 3 dup(?)
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ED8h
; COMDAT (pick any)
		public ??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@
; `string'
??_C@_0BJ@INKKKOJN@?4?2crypto?2dso?2dso_win32?4c?$AA@ db '.\crypto\dso\dso_win32.c',0
					; DATA XREF: _win32_load+1Fo
					; _win32_load+4Bo ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0EF4h
; COMDAT (pick any)
		public ??_C@_01PKGAHCOL@?$CJ?$AA@
; `string'
??_C@_01PKGAHCOL@?$CJ?$AA@ db 29h, 0	; DATA XREF: _win32_load+5Bo
					; _win32_bind_var+9Fo ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0EF8h
; COMDAT (pick any)
		public ??_C@_09CCCHLKJP@filename?$CI?$AA@
; `string'
??_C@_09CCCHLKJP@filename?$CI?$AA@ db 'filename(',0 ; DATA XREF: _win32_load+61o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F04h
; COMDAT (pick any)
		public ??_C@_08MFAHALLH@symname?$CI?$AA@
; `string'
??_C@_08MFAHALLH@symname?$CI?$AA@ db 'symname(',0 ; DATA XREF: _win32_bind_var+A5o
					; _win32_bind_func+A5o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F10h
; COMDAT (pick any)
		public ??_C@_02HDBGODGB@?2?2?$AA@
; `string'
??_C@_02HDBGODGB@?2?2?$AA@ dw 5C5Ch	; DATA XREF: _win32_joiner+E0r
byte_F12	db 0			; DATA XREF: _win32_joiner+E9r
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F14h
; COMDAT (pick any)
		public ??_C@_01KMDKNFGN@?1?$AA@
; char `string'[2]
??_C@_01KMDKNFGN@?1?$AA@ db '/',0       ; DATA XREF: _win32_name_converter+1Fo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F18h
; COMDAT (pick any)
		public ??_C@_01KICIPPFI@?2?$AA@
; char `string'[2]
??_C@_01KICIPPFI@?2?$AA@ db '\',0       ; DATA XREF: _win32_name_converter+2Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F1Ch
; COMDAT (pick any)
		public ??_C@_01JLIPDDHJ@?3?$AA@
; char `string'[2]
??_C@_01JLIPDDHJ@?3?$AA@ db ':',0       ; DATA XREF: _win32_name_converter+3Do
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F20h
; COMDAT (pick any)
		public ??_C@_06DAJAKOAL@?$CFs?4dll?$AA@
; char `string'[]
??_C@_06DAJAKOAL@?$CFs?4dll?$AA@ db '%s.dll',0 ; DATA XREF: _win32_name_converter+9Ao
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F28h
; COMDAT (pick any)
		public ??_C@_02DKCKIIND@?$CFs?$AA@
; char `string'[3]
??_C@_02DKCKIIND@?$CFs?$AA@ db '%s',0   ; DATA XREF: _win32_name_converter:loc_40Ao
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F2Ch
; COMDAT (pick any)
		public ??_C@_0N@NHGLKGEC@KERNEL32?4DLL?$AA@
; CHAR `string'[]
??_C@_0N@NHGLKGEC@KERNEL32?4DLL?$AA@ db	'KERNEL32.DLL',0 ; DATA XREF: _win32_pathbyaddr+33o
					; _win32_globallookup+21o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F3Ch
; COMDAT (pick any)
		public ??_C@_0BJ@JEFKDHMD@CreateToolhelp32Snapshot?$AA@
; CHAR `string'[]
??_C@_0BJ@JEFKDHMD@CreateToolhelp32Snapshot?$AA@ db 'CreateToolhelp32Snapshot',0
					; DATA XREF: _win32_pathbyaddr+83o
					; _win32_globallookup+72o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F58h
; COMDAT (pick any)
		public ??_C@_0O@CNMFJJGO@Module32First?$AA@
; CHAR `string'[]
??_C@_0O@CNMFJJGO@Module32First?$AA@ db	'Module32First',0 ; DATA XREF: _win32_pathbyaddr+D1o
					; _win32_globallookup:loc_85Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F68h
; COMDAT (pick any)
		public ??_C@_0N@KIGOLBLC@Module32Next?$AA@
; CHAR `string'[]
??_C@_0N@KIGOLBLC@Module32Next?$AA@ db 'Module32Next',0 ; DATA XREF: _win32_pathbyaddr+D9o
					; _win32_globallookup+96o
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __imp____stdio_common_vsprintf:near ; CODE XREF: __vsnprintf_l+22p
					; __vsprintf_l+20p ...
; char *__cdecl	_strstr(const char *Str, const char *SubStr)
		extrn __imp__strstr:near ; CODE	XREF: _win32_name_converter+25p
					; _win32_name_converter+34p ...
; char *__cdecl	_strncpy(char *Dest, const char	*Source, size_t	Count)
		extrn __imp__strncpy:near ; CODE XREF: _win32_joiner+FAp
					; _win32_joiner+129p ...
; BOOL __stdcall CloseHandle(HANDLE hObject)
		extrn __imp__CloseHandle@4:near	; CODE XREF: _win32_pathbyaddr+122p
					; _win32_pathbyaddr+16Fp ...
; BOOL __stdcall FreeLibrary(HMODULE hLibModule)
		extrn __imp__FreeLibrary@4:near	; CODE XREF: _win32_load+DFp
					; _win32_unload+6Dp ...
; FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName)
		extrn __imp__GetProcAddress@8:near ; CODE XREF:	_win32_bind_var+80p
					; _win32_bind_func+80p	...
; HMODULE __stdcall LoadLibraryA(LPCSTR	lpLibFileName)
		extrn __imp__LoadLibraryA@4:near ; CODE	XREF: _win32_load+3Ap
					; _win32_pathbyaddr+3Bp ...
		extrn _sk_num:near	; CODE XREF: _win32_unload+28p
					; _win32_bind_var+1Dp ...
		extrn _sk_value:near	; CODE XREF: _win32_bind_var+54p
					; _win32_bind_func+54p
		extrn _sk_push:near	; CODE XREF: _win32_load+A0p
					; _win32_unload+90p
		extrn _sk_pop:near	; CODE XREF: _win32_unload+40p
		extrn _CRYPTO_malloc:near ; CODE XREF: _win32_load+7Ep
					; _win32_name_converter+69p ...
		extrn _CRYPTO_free:near	; CODE XREF: _win32_load+C5p
					; _win32_load+D2p ...
		extrn _ERR_put_error:near ; CODE XREF: _win32_load+2Ap
					; _win32_load+56p ...
		extrn _ERR_add_error_data:near ; CODE XREF: _win32_load+68p
					; _win32_bind_var+ACp ...
		extrn _DSO_convert_filename:near ; CODE	XREF: _win32_load+Cp
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _win32_pathbyaddr+70p
					; _win32_pathbyaddr+C4p ...
		extrn __chkstk:near	; CODE XREF: _win32_pathbyaddr+5p
					; _win32_globallookup+5p ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _win32_pathbyaddr+1D9p
; `__local_stdio_printf_options'::`2'::_OptionsStorage
		extrn ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:near
					; DATA XREF: ___local_stdio_printf_optionso
		extrn ___security_cookie:near ;	DATA XREF: _win32_pathbyaddr+Ar
					; _win32_globallookup+Ar


		end
