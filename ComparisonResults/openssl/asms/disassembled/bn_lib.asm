;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	70E4756ECC0C4CD74142438D90038FC1
; Input	CRC32 :	BBF14684

; File Name   :	C:\compspace\Diff\openssl\obj\bn_lib.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		public _BN_version
_BN_version	db 'Big Number part of OpenSSL 1.0.2h  3 May 2016',0
		align 10h
; `BN_value_one'::`2'::data_one
?data_one@?1??BN_value_one@@9@9	dd 1	; DATA XREF: .rdata:`BN_value_one'::`2'::const_oneo
; `BN_value_one'::`2'::const_one
?const_one@?1??BN_value_one@@9@9 dd offset ?data_one@?1??BN_value_one@@9@9
					; DATA XREF: _BN_value_oneo
					; `BN_value_one'::`2'::data_one
		dd 2 dup(1), 0
		dd 2
; `BN_num_bits_word'::`2'::bits
?bits@?1??BN_num_bits_word@@9@9	db 0	; DATA XREF: _BN_num_bits+28r
					; _BN_num_bits+3Br ...
		db 1, 2	dup(2)
		dd 3030303h, 2 dup(4040404h), 4	dup(5050505h), 8 dup(6060606h)
		dd 10h dup(7070707h), 20h dup(8080808h)
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 148h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
_bn_limit_bits	dd ?			; DATA XREF: _BN_get_params+8r
					; _BN_set_params+1Aw
_bn_limit_bits_low dd ?			; DATA XREF: _BN_get_params+1Er
					; _BN_set_params+52w
_bn_limit_bits_high dd ?		; DATA XREF: _BN_get_params+13r
					; _BN_set_params+36w
_bn_limit_bits_mont dd ?		; DATA XREF: _BN_get_params+29r
					; _BN_set_params+6Cw
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 158h
_bn_limit_num	dd 8			; DATA XREF: _BN_set_params+20w
_bn_limit_num_low dd 8			; DATA XREF: _BN_set_params+58w
_bn_limit_num_high dd 8			; DATA XREF: _BN_set_params+3Cw
_bn_limit_num_mont dd 8			; DATA XREF: _BN_set_params+72w
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 168h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_bin2bn
_BN_bin2bn	proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 4
		call	__chkstk
		push	esi
		mov	esi, [esp+8+arg_8]
		mov	[esp+8+var_4], 0
		test	esi, esi
		jnz	short loc_195
		call	_BN_new
		mov	[esp+8+var_4], eax
		mov	esi, eax
		test	eax, eax
		jnz	short loc_195
		pop	esi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_195:				; CODE XREF: _BN_bin2bn+19j
					; _BN_bin2bn+28j
		push	ebp
		mov	ebp, [esp+0Ch+arg_4]
		push	edi
		xor	edi, edi
		test	ebp, ebp
		jnz	short loc_1AB
		mov	[esi+4], edi
		mov	eax, esi
		pop	edi
		pop	ebp
		pop	esi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_1AB:				; CODE XREF: _BN_bin2bn+37j
		push	ebx
		lea	ebx, [ebp-1]
		mov	eax, ebx
		and	ebx, 3
		shr	eax, 2
		inc	eax
		mov	[esp+14h+arg_8], eax
		cmp	eax, [esi+8]
		jg	short loc_1C5
		mov	ecx, esi
		jmp	short loc_1D5
; ---------------------------------------------------------------------------

loc_1C5:				; CODE XREF: _BN_bin2bn+57j
		push	eax
		push	esi
		call	_bn_expand2
		mov	ecx, eax
		add	esp, 8
		mov	eax, [esp+14h+arg_8]

loc_1D5:				; CODE XREF: _BN_bin2bn+5Bj
		test	ecx, ecx
		jnz	short loc_1F2
		mov	eax, [esp+14h+var_4]
		test	eax, eax
		jz	short loc_1EA
		push	eax
		call	_BN_free
		add	esp, 4

loc_1EA:				; CODE XREF: _BN_bin2bn+77j
		pop	ebx
		pop	edi
		pop	ebp
		xor	eax, eax
		pop	esi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_1F2:				; CODE XREF: _BN_bin2bn+6Fj
		mov	edx, [esp+14h+arg_0]
		lea	ecx, ds:0[eax*4]
		mov	[esi+4], eax
		mov	[esi+0Ch], edi
		nop	dword ptr [eax+eax+00h]

loc_208:				; CODE XREF: _BN_bin2bn+C2j
		movzx	eax, byte ptr [edx]
		lea	edx, [edx+1]
		shl	edi, 8
		dec	ebp
		or	edi, eax
		mov	eax, ebx
		dec	ebx
		test	eax, eax
		jnz	short loc_228
		mov	eax, [esi]
		sub	ecx, 4
		mov	[ecx+eax], edi
		xor	edi, edi
		lea	ebx, [edi+3]

loc_228:				; CODE XREF: _BN_bin2bn+B1j
		test	ebp, ebp
		jnz	short loc_208
		mov	ecx, [esi+4]
		test	ecx, ecx
		jle	short loc_24C
		mov	eax, [esi]
		lea	edx, [ecx-1]
		lea	edx, [eax+edx*4]

loc_23B:				; CODE XREF: _BN_bin2bn+DFj
		mov	eax, [edx]
		lea	edx, [edx-4]
		test	eax, eax
		jnz	short loc_249
		dec	ecx
		test	ecx, ecx
		jg	short loc_23B

loc_249:				; CODE XREF: _BN_bin2bn+DAj
		mov	[esi+4], ecx

loc_24C:				; CODE XREF: _BN_bin2bn+C9j
		pop	ebx
		pop	edi
		pop	ebp
		mov	eax, esi
		pop	esi
		pop	ecx
		retn
_BN_bin2bn	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 254h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_bn2bin
_BN_bn2bin	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	ebp
		push	ebx
		call	_BN_num_bits
		add	eax, 7
		add	esp, 4
		cdq
		and	edx, 7
		add	eax, edx
		sar	eax, 3
		mov	ebp, eax
		test	eax, eax
		jz	short loc_2AC
		push	esi
		push	edi
		mov	edi, [esp+10h+arg_4]

loc_27B:				; CODE XREF: _BN_bn2bin+52j
		dec	eax
		mov	esi, eax
		test	esi, esi
		jns	short loc_285
		add	esi, 3

loc_285:				; CODE XREF: _BN_bn2bin+2Cj
		sar	esi, 2
		mov	edx, [ebx]
		mov	ecx, eax
		and	ecx, 80000003h
		jns	short loc_299
		dec	ecx
		or	ecx, 0FFFFFFFCh
		inc	ecx

loc_299:				; CODE XREF: _BN_bn2bin+3Ej
		mov	edx, [edx+esi*4]
		shl	ecx, 3
		shr	edx, cl
		mov	[edi], dl
		inc	edi
		test	eax, eax
		jnz	short loc_27B
		pop	edi
		mov	eax, ebp
		pop	esi

loc_2AC:				; CODE XREF: _BN_bn2bin+1Fj
		pop	ebp
		pop	ebx
		retn
_BN_bn2bin	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2B0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_clear
_BN_clear	proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	ecx, [esi]
		test	ecx, ecx
		jz	short loc_2CD
		mov	eax, [esi+8]
		shl	eax, 2
		push	eax		; Size
		push	0		; Val
		push	ecx		; Dst
		call	_memset
		add	esp, 0Ch

loc_2CD:				; CODE XREF: _BN_clear+9j
		mov	dword ptr [esi+0Ch], 0
		mov	dword ptr [esi+4], 0
		pop	esi
		retn
_BN_clear	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_clear_bit
_BN_clear_bit	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_4]
		test	esi, esi
		jns	short loc_2ED
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_2ED:				; CODE XREF: _BN_clear_bit+7j
		mov	eax, esi
		cdq
		and	edx, 1Fh
		push	edi
		mov	edi, [esp+8+arg_0]
		lea	ecx, [edx+eax]
		sar	ecx, 5
		cmp	[edi+4], ecx
		jg	short loc_308
		pop	edi
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_308:				; CODE XREF: _BN_clear_bit+21j
		mov	eax, [edi]
		lea	ecx, [eax+ecx*4]
		and	esi, 8000001Fh
		jns	short loc_31A
		dec	esi
		or	esi, 0FFFFFFE0h
		inc	esi

loc_31A:				; CODE XREF: _BN_clear_bit+33j
		mov	eax, [ecx]
		btr	eax, esi
		mov	[ecx], eax
		mov	eax, [edi+4]
		test	eax, eax
		jle	short loc_341
		mov	ecx, [edi]
		lea	edx, [eax-1]
		lea	edx, [ecx+edx*4]

loc_330:				; CODE XREF: _BN_clear_bit+5Cj
		mov	ecx, [edx]
		lea	edx, [edx-4]
		test	ecx, ecx
		jnz	short loc_33E
		dec	eax
		test	eax, eax
		jg	short loc_330

loc_33E:				; CODE XREF: _BN_clear_bit+57j
		mov	[edi+4], eax

loc_341:				; CODE XREF: _BN_clear_bit+46j
		pop	edi
		mov	eax, 1
		pop	esi
		retn
_BN_clear_bit	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 34Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_clear_free
_BN_clear_free	proc near

arg_0		= dword	ptr  4

		push	edi
		mov	edi, [esp+4+arg_0]
		test	edi, edi
		jz	short loc_399
		mov	ecx, [edi]
		test	ecx, ecx
		jz	short loc_37B
		mov	eax, [edi+8]
		shl	eax, 2
		push	eax
		push	ecx
		call	_OPENSSL_cleanse
		add	esp, 8
		test	byte ptr [edi+10h], 2
		jnz	short loc_37B
		push	dword ptr [edi]
		call	_CRYPTO_free
		add	esp, 4

loc_37B:				; CODE XREF: _BN_clear_free+Dj
					; _BN_clear_free+23j
		push	esi
		mov	esi, [edi+10h]
		push	14h
		push	edi
		call	_OPENSSL_cleanse
		add	esp, 8
		and	esi, 1
		pop	esi
		jz	short loc_399
		push	edi
		call	_CRYPTO_free
		add	esp, 4

loc_399:				; CODE XREF: _BN_clear_free+7j
					; _BN_clear_free+42j
		pop	edi
		retn
_BN_clear_free	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 39Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_cmp
_BN_cmp		proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	loc_42F
		mov	ecx, [esp+arg_4]
		test	ecx, ecx
		jz	short loc_42B
		mov	edx, [eax+0Ch]
		cmp	edx, [ecx+0Ch]
		jz	short loc_3C7
		xor	eax, eax
		test	edx, edx
		setz	al
		lea	eax, ds:0FFFFFFFFh[eax*2]
		retn
; ---------------------------------------------------------------------------

loc_3C7:				; CODE XREF: _BN_cmp+1Aj
		push	ebx
		push	ebp
		test	edx, edx
		jnz	short loc_3D5
		lea	ebx, [edx+1]
		or	ebp, 0FFFFFFFFh
		jmp	short loc_3DB
; ---------------------------------------------------------------------------

loc_3D5:				; CODE XREF: _BN_cmp+2Fj
		or	ebx, 0FFFFFFFFh
		lea	ebp, [ebx+2]

loc_3DB:				; CODE XREF: _BN_cmp+37j
		mov	edx, [eax+4]
		push	esi
		mov	esi, [ecx+4]
		cmp	edx, esi
		jle	short loc_3EC
		pop	esi
		pop	ebp
		mov	eax, ebx
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_3EC:				; CODE XREF: _BN_cmp+48j
		jge	short loc_3F4
		pop	esi
		mov	eax, ebp
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_3F4:				; CODE XREF: _BN_cmp:loc_3ECj
		add	edx, 0FFFFFFFFh
		push	edi
		js	short loc_416
		mov	edi, [eax]
		mov	eax, [ecx]
		sub	edi, eax
		lea	ecx, [eax+edx*4]

loc_403:				; CODE XREF: _BN_cmp+78j
		mov	eax, [edi+ecx]
		mov	esi, [ecx]
		cmp	eax, esi
		ja	short loc_424
		jb	short loc_41D
		sub	ecx, 4
		sub	edx, 1
		jns	short loc_403

loc_416:				; CODE XREF: _BN_cmp+5Cj
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_41D:				; CODE XREF: _BN_cmp+70j
		pop	edi
		pop	esi
		mov	eax, ebp
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_424:				; CODE XREF: _BN_cmp+6Ej
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, ebx
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_42B:				; CODE XREF: _BN_cmp+12j
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_42F:				; CODE XREF: _BN_cmp+6j
		xor	eax, eax
		cmp	[esp+arg_4], eax
		setnz	al
		retn
_BN_cmp		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 43Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_consttime_swap
_BN_consttime_swap proc	near

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, 10h
		call	__chkstk
		push	ebx
		mov	ebx, [esp+14h+arg_4]
		push	ebp
		mov	ebp, [esp+18h+arg_0]
		push	esi
		mov	ecx, [ebx+4]
		push	edi
		mov	edi, [esp+20h+arg_8]
		lea	ebp, [ebp-1]
		shr	ebp, 1Fh
		dec	ebp
		mov	[esp+20h+arg_0], ebp
		mov	eax, [edi+4]
		xor	eax, ecx
		and	eax, ebp
		movd	xmm0, ebp
		xor	ecx, eax
		pshufd	xmm3, xmm0, 0
		mov	[ebx+4], ecx
		xor	[edi+4], eax
		mov	eax, [esp+20h+arg_C]
		lea	edx, [eax-1]	; switch 10 cases
		cmp	edx, 9
		ja	short loc_48F	; jumptable 00000488 default case
		jmp	ds:$LN71[edx*4]	; switch jump
; ---------------------------------------------------------------------------

loc_48F:				; CODE XREF: _BN_consttime_swap+4Aj
		mov	ebp, 0Ah	; jumptable 00000488 default case
		lea	ecx, [eax-0Ah]
		cmp	eax, ebp
		jle	loc_581
		cmp	ecx, 4
		jb	loc_55A
		mov	esi, [edi]
		mov	eax, [ebx]
		mov	[esp+20h+var_10], eax
		mov	ebx, eax
		lea	eax, [esi+28h]
		mov	[esp+20h+arg_8], eax
		lea	esi, [esi+edx*4]
		mov	eax, [esp+20h+var_10]
		add	eax, 28h ; '('
		mov	[esp+20h+var_C], eax
		lea	eax, [ebx+edx*4]
		cmp	[esp+20h+arg_8], eax
		mov	ebx, [esp+20h+arg_4]
		mov	edx, [esp+20h+var_C]
		mov	[esp+20h+var_8], eax
		mov	eax, [esp+20h+arg_C]
		ja	short loc_4E4
		cmp	esi, edx
		jnb	short loc_55A

loc_4E4:				; CODE XREF: _BN_consttime_swap+A2j
		cmp	[esp+20h+arg_8], edi
		ja	short loc_4EE
		cmp	esi, edi
		jnb	short loc_55A

loc_4EE:				; CODE XREF: _BN_consttime_swap+ACj
		cmp	[esp+20h+arg_8], ebx
		ja	short loc_4F8
		cmp	esi, ebx
		jnb	short loc_55A

loc_4F8:				; CODE XREF: _BN_consttime_swap+B6j
		mov	esi, [esp+20h+var_8]
		cmp	edx, edi
		ja	short loc_504
		cmp	esi, edi
		jnb	short loc_55A

loc_504:				; CODE XREF: _BN_consttime_swap+C2j
		cmp	edx, ebx
		ja	short loc_50C
		cmp	esi, ebx
		jnb	short loc_55A

loc_50C:				; CODE XREF: _BN_consttime_swap+CAj
		and	ecx, 80000003h
		jns	short loc_519
		dec	ecx
		or	ecx, 0FFFFFFFCh
		inc	ecx

loc_519:				; CODE XREF: _BN_consttime_swap+D6j
		mov	esi, [esp+20h+var_10]
		mov	edx, eax
		sub	edx, ecx
		mov	ecx, [edi]
		nop	word ptr [eax+eax+00000000h]

loc_52C:				; CODE XREF: _BN_consttime_swap+11Cj
		movups	xmm1, xmmword ptr [esi+ebp*4]
		movups	xmm2, xmmword ptr [ecx+ebp*4]
		pxor	xmm2, xmm1
		pand	xmm2, xmm3
		movaps	xmm0, xmm2
		pxor	xmm0, xmm1
		movups	xmmword	ptr [esi+ebp*4], xmm0
		movups	xmm0, xmmword ptr [ecx+ebp*4]
		pxor	xmm0, xmm2
		movups	xmmword	ptr [ecx+ebp*4], xmm0
		add	ebp, 4
		cmp	ebp, edx
		jl	short loc_52C

loc_55A:				; CODE XREF: _BN_consttime_swap+66j
					; _BN_consttime_swap+A6j ...
		cmp	ebp, eax
		jge	short loc_581

loc_55E:				; CODE XREF: _BN_consttime_swap+143j
		mov	eax, [ebx]
		mov	ecx, [eax+ebp*4]
		lea	edx, [eax+ebp*4]
		mov	eax, [edi]
		mov	esi, [eax+ebp*4]
		xor	esi, ecx
		and	esi, [esp+20h+arg_0]
		xor	ecx, esi
		mov	[edx], ecx
		mov	eax, [edi]
		xor	[eax+ebp*4], esi
		inc	ebp
		cmp	ebp, [esp+20h+arg_C]
		jl	short loc_55E

loc_581:				; CODE XREF: _BN_consttime_swap+5Dj
					; _BN_consttime_swap+120j
		mov	ebp, [esp+20h+arg_0]

$LN12:					; CODE XREF: _BN_consttime_swap+4Cj
					; DATA XREF: .text$mn:$LN71o
		mov	eax, [edi]	; jumptable 00000488 case 10
		mov	esi, [ebx]
		mov	edx, [eax+24h]
		mov	ecx, [esi+24h]
		xor	edx, ecx
		and	edx, ebp
		xor	ecx, edx
		mov	[esi+24h], ecx
		mov	eax, [edi]
		xor	[eax+24h], edx

$LN11:					; CODE XREF: _BN_consttime_swap+4Cj
					; DATA XREF: .text$mn:$LN71o
		mov	eax, [edi]	; jumptable 00000488 case 9
		mov	esi, [ebx]
		mov	edx, [eax+20h]
		mov	ecx, [esi+20h]
		xor	edx, ecx
		and	edx, ebp
		xor	ecx, edx
		mov	[esi+20h], ecx
		mov	eax, [edi]
		xor	[eax+20h], edx

$LN14:					; CODE XREF: _BN_consttime_swap+4Cj
					; DATA XREF: .text$mn:$LN71o
		mov	eax, [edi]	; jumptable 00000488 case 8
		mov	esi, [ebx]
		mov	edx, [eax+1Ch]
		mov	ecx, [esi+1Ch]
		xor	edx, ecx
		and	edx, ebp
		xor	ecx, edx
		mov	[esi+1Ch], ecx
		mov	eax, [edi]
		xor	[eax+1Ch], edx

$LN17:					; CODE XREF: _BN_consttime_swap+4Cj
					; DATA XREF: .text$mn:$LN71o
		mov	eax, [edi]	; jumptable 00000488 case 7
		mov	esi, [ebx]
		mov	edx, [eax+18h]
		mov	ecx, [esi+18h]
		xor	edx, ecx
		and	edx, ebp
		xor	ecx, edx
		mov	[esi+18h], ecx
		mov	eax, [edi]
		xor	[eax+18h], edx

$LN20:					; CODE XREF: _BN_consttime_swap+4Cj
					; DATA XREF: .text$mn:$LN71o
		mov	eax, [edi]	; jumptable 00000488 case 6
		mov	esi, [ebx]
		mov	edx, [eax+14h]
		mov	ecx, [esi+14h]
		xor	edx, ecx
		and	edx, ebp
		xor	ecx, edx
		mov	[esi+14h], ecx
		mov	eax, [edi]
		xor	[eax+14h], edx

$LN23:					; CODE XREF: _BN_consttime_swap+4Cj
					; DATA XREF: .text$mn:$LN71o
		mov	eax, [edi]	; jumptable 00000488 case 5
		mov	esi, [ebx]
		mov	edx, [eax+10h]
		mov	ecx, [esi+10h]
		xor	edx, ecx
		and	edx, ebp
		xor	ecx, edx
		mov	[esi+10h], ecx
		mov	eax, [edi]
		xor	[eax+10h], edx

$LN26:					; CODE XREF: _BN_consttime_swap+4Cj
					; DATA XREF: .text$mn:$LN71o
		mov	eax, [edi]	; jumptable 00000488 case 4
		mov	esi, [ebx]
		mov	edx, [eax+0Ch]
		mov	ecx, [esi+0Ch]
		xor	edx, ecx
		and	edx, ebp
		xor	ecx, edx
		mov	[esi+0Ch], ecx
		mov	eax, [edi]
		xor	[eax+0Ch], edx

$LN29:					; CODE XREF: _BN_consttime_swap+4Cj
					; DATA XREF: .text$mn:$LN71o
		mov	eax, [edi]	; jumptable 00000488 case 3
		mov	esi, [ebx]
		mov	edx, [eax+8]
		mov	ecx, [esi+8]
		xor	edx, ecx
		and	edx, ebp
		xor	ecx, edx
		mov	[esi+8], ecx
		mov	eax, [edi]
		xor	[eax+8], edx

$LN32:					; CODE XREF: _BN_consttime_swap+4Cj
					; DATA XREF: .text$mn:$LN71o
		mov	eax, [edi]	; jumptable 00000488 case 2
		mov	esi, [ebx]
		mov	edx, [eax+4]
		mov	ecx, [esi+4]
		xor	edx, ecx
		and	edx, ebp
		xor	ecx, edx
		mov	[esi+4], ecx
		mov	eax, [edi]
		xor	[eax+4], edx

$LN35:					; CODE XREF: _BN_consttime_swap+4Cj
					; DATA XREF: .text$mn:$LN71o
		mov	eax, [edi]	; jumptable 00000488 case 1
		mov	esi, [ebx]
		mov	ecx, [eax]
		mov	edx, [esi]
		xor	ecx, edx
		and	ecx, ebp
		xor	edx, ecx
		mov	[esi], edx
		mov	eax, [edi]
		pop	edi
		pop	esi
		pop	ebp
		xor	[eax], ecx
		pop	ebx
		add	esp, 10h
		retn
_BN_consttime_swap endp

; ---------------------------------------------------------------------------
		align 4
$LN71		dd offset $LN35		; DATA XREF: _BN_consttime_swap+4Cr
		dd offset $LN32		; jump table for switch	statement
		dd offset $LN29
		dd offset $LN26
		dd offset $LN23
		dd offset $LN20
		dd offset $LN17
		dd offset $LN14
		dd offset $LN11
		dd offset $LN12
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6A4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_copy
_BN_copy	proc near		; CODE XREF: _BN_dup+1Bp
					; _bn_dup_expand+68p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 4
		call	__chkstk
		push	ebp
		mov	ebp, [esp+8+arg_0]
		push	esi
		mov	esi, [esp+0Ch+arg_4]
		cmp	ebp, esi
		jnz	short loc_6C2
		pop	esi
		mov	eax, ebp
		pop	ebp
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_6C2:				; CODE XREF: _BN_copy+16j
		push	ebx
		push	edi
		mov	edi, [esi+4]
		cmp	edi, [ebp+8]
		jle	short loc_6F6
		push	edi
		push	ebp
		call	_bn_expand_internal
		mov	ebx, eax
		add	esp, 8
		test	ebx, ebx
		jz	loc_769
		mov	ecx, [ebp+0]
		test	ecx, ecx
		jz	short loc_6F0
		push	ecx
		call	_CRYPTO_free
		add	esp, 4

loc_6F0:				; CODE XREF: _BN_copy+41j
		mov	[ebp+0], ebx
		mov	[ebp+8], edi

loc_6F6:				; CODE XREF: _BN_copy+26j
		mov	eax, [esi+4]
		mov	edi, [ebp+0]
		mov	ebx, [esi]
		sar	eax, 2
		test	eax, eax
		jle	short loc_730
		mov	ebp, eax

loc_707:				; CODE XREF: _BN_copy+82j
		mov	ecx, [ebx+4]
		dec	ebp
		mov	edx, [ebx+8]
		mov	esi, [ebx+0Ch]
		mov	eax, [ebx]
		add	ebx, 10h
		mov	[edi], eax
		mov	[edi+4], ecx
		mov	[edi+8], edx
		mov	[edi+0Ch], esi
		add	edi, 10h
		test	ebp, ebp
		jg	short loc_707
		mov	ebp, [esp+14h+arg_0]
		mov	esi, [esp+14h+arg_4]

loc_730:				; CODE XREF: _BN_copy+5Fj
		mov	eax, [esi+4]
		and	eax, 3
		sub	eax, 1
		jz	short loc_751
		sub	eax, 1
		jz	short loc_74B
		sub	eax, 1
		jnz	short loc_755
		mov	eax, [ebx+8]
		mov	[edi+8], eax

loc_74B:				; CODE XREF: _BN_copy+9Aj
		mov	eax, [ebx+4]
		mov	[edi+4], eax

loc_751:				; CODE XREF: _BN_copy+95j
		mov	eax, [ebx]
		mov	[edi], eax

loc_755:				; CODE XREF: _BN_copy+9Fj
		mov	eax, [esi+4]
		pop	edi
		mov	[ebp+4], eax
		mov	eax, [esi+0Ch]
		pop	ebx
		mov	[ebp+0Ch], eax
		mov	eax, ebp
		pop	esi
		pop	ebp
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_769:				; CODE XREF: _BN_copy+36j
		pop	edi
		pop	ebx
		pop	esi
		xor	eax, eax
		pop	ebp
		pop	ecx
		retn
_BN_copy	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 774h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_dup
_BN_dup		proc near

arg_0		= dword	ptr  4

		cmp	[esp+arg_0], 0
		jnz	short loc_77E
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_77E:				; CODE XREF: _BN_dup+5j
		push	esi
		call	_BN_new
		mov	esi, eax
		test	esi, esi
		jz	short loc_7A4
		push	[esp+4+arg_0]
		push	esi
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jnz	short loc_7A8
		push	esi
		call	_BN_free
		add	esp, 4

loc_7A4:				; CODE XREF: _BN_dup+14j
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_7A8:				; CODE XREF: _BN_dup+25j
		mov	eax, esi
		pop	esi
		retn
_BN_dup		endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7ACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_free
_BN_free	proc near		; CODE XREF: _BN_bin2bn+7Ap
					; _BN_dup+28p ...

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	short loc_7EA
		mov	eax, [esi]
		test	eax, eax
		jz	short loc_7CA
		test	byte ptr [esi+10h], 2
		jnz	short loc_7CA
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_7CA:				; CODE XREF: _BN_free+Dj _BN_free+13j
		mov	eax, [esi+10h]
		test	al, 1
		jz	short loc_7DC
		push	esi
		call	_CRYPTO_free
		add	esp, 4
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_7DC:				; CODE XREF: _BN_free+23j
		or	eax, 8000h
		mov	dword ptr [esi], 0
		mov	[esi+10h], eax

loc_7EA:				; CODE XREF: _BN_free+7j
		pop	esi
		retn
_BN_free	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7ECh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_get_params
_BN_get_params	proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		test	ecx, ecx
		jnz	short loc_7FA
		mov	eax, ds:_bn_limit_bits
		retn
; ---------------------------------------------------------------------------

loc_7FA:				; CODE XREF: _BN_get_params+6j
		cmp	ecx, 1
		jnz	short loc_805
		mov	eax, ds:_bn_limit_bits_high
		retn
; ---------------------------------------------------------------------------

loc_805:				; CODE XREF: _BN_get_params+11j
		cmp	ecx, 2
		jnz	short loc_810
		mov	eax, ds:_bn_limit_bits_low
		retn
; ---------------------------------------------------------------------------

loc_810:				; CODE XREF: _BN_get_params+1Cj
		xor	eax, eax
		cmp	ecx, 3
		cmovz	eax, ds:_bn_limit_bits_mont
		retn
_BN_get_params	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 820h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_get_word
_BN_get_word	proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		mov	eax, [ecx+4]
		cmp	eax, 1
		jle	short loc_830
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_830:				; CODE XREF: _BN_get_word+Aj
		jnz	short loc_837
		mov	eax, [ecx]
		mov	eax, [eax]
		retn
; ---------------------------------------------------------------------------

loc_837:				; CODE XREF: _BN_get_word:loc_830j
		xor	eax, eax
		retn
_BN_get_word	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 83Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_init
_BN_init	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		xorps	xmm0, xmm0
		movups	xmmword	ptr [eax], xmm0
		mov	dword ptr [eax+10h], 0
		retn
_BN_init	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 850h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_is_bit_set
_BN_is_bit_set	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_4]
		test	ecx, ecx
		jns	short loc_85B

loc_858:				; CODE XREF: _BN_is_bit_set+1Dj
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_85B:				; CODE XREF: _BN_is_bit_set+6j
		mov	eax, ecx
		cdq
		and	edx, 1Fh
		add	edx, eax
		mov	eax, [esp+arg_0]
		sar	edx, 5
		cmp	[eax+4], edx
		jle	short loc_858
		mov	eax, [eax]
		and	ecx, 8000001Fh
		jns	short loc_87E
		dec	ecx
		or	ecx, 0FFFFFFE0h
		inc	ecx

loc_87E:				; CODE XREF: _BN_is_bit_set+27j
		mov	eax, [eax+edx*4]
		shr	eax, cl
		and	eax, 1
		retn
_BN_is_bit_set	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 888h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_mask_bits
_BN_mask_bits	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_4]
		test	ecx, ecx
		jns	short loc_893
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_893:				; CODE XREF: _BN_mask_bits+6j
		mov	eax, ecx
		cdq
		and	edx, 1Fh
		add	edx, eax
		sar	edx, 5
		push	esi
		and	ecx, 8000001Fh
		jns	short loc_8AC
		dec	ecx
		or	ecx, 0FFFFFFE0h
		inc	ecx

loc_8AC:				; CODE XREF: _BN_mask_bits+1Dj
		mov	esi, [esp+4+arg_0]
		cmp	edx, [esi+4]
		jl	short loc_8B9
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_8B9:				; CODE XREF: _BN_mask_bits+2Bj
		test	ecx, ecx
		jnz	short loc_8C2
		mov	[esi+4], edx
		jmp	short loc_8D6
; ---------------------------------------------------------------------------

loc_8C2:				; CODE XREF: _BN_mask_bits+33j
		lea	eax, [edx+1]
		mov	[esi+4], eax
		mov	eax, [esi]
		lea	edx, [eax+edx*4]
		or	eax, 0FFFFFFFFh
		shl	eax, cl
		not	eax
		and	[edx], eax

loc_8D6:				; CODE XREF: _BN_mask_bits+38j
		mov	eax, [esi+4]
		test	eax, eax
		jle	short loc_8F9
		mov	ecx, [esi]
		lea	edx, [eax-1]
		lea	edx, [ecx+edx*4]
		nop	dword ptr [eax]

loc_8E8:				; CODE XREF: _BN_mask_bits+6Cj
		mov	ecx, [edx]
		lea	edx, [edx-4]
		test	ecx, ecx
		jnz	short loc_8F6
		dec	eax
		test	eax, eax
		jg	short loc_8E8

loc_8F6:				; CODE XREF: _BN_mask_bits+67j
		mov	[esi+4], eax

loc_8F9:				; CODE XREF: _BN_mask_bits+53j
		mov	eax, 1
		pop	esi
		retn
_BN_mask_bits	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 900h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_new
_BN_new		proc near		; CODE XREF: _BN_bin2bn+1Bp _BN_dup+Bp ...
		push	110h
		push	offset ??_C@_0BF@OGBNCIDG@?4?2crypto?2bn?2bn_lib?4c?$AA@ ; ".\\crypto\\bn\\bn_lib.c"
		push	14h
		call	_CRYPTO_malloc
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_933
		push	111h
		push	offset ??_C@_0BF@OGBNCIDG@?4?2crypto?2bn?2bn_lib?4c?$AA@ ; ".\\crypto\\bn\\bn_lib.c"
		push	41h ; 'A'
		push	71h ; 'q'
		push	3
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_933:				; CODE XREF: _BN_new+16j
		mov	dword ptr [eax+10h], 1
		mov	dword ptr [eax+4], 0
		mov	dword ptr [eax+0Ch], 0
		mov	dword ptr [eax+8], 0
		mov	dword ptr [eax], 0
		retn
_BN_new		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 958h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_num_bits
_BN_num_bits	proc near		; CODE XREF: _BN_bn2bin+7p

arg_0		= dword	ptr  4

		mov	edx, [esp+arg_0]
		mov	eax, [edx+4]
		lea	ecx, [eax-1]
		test	eax, eax
		jnz	short loc_967
		retn
; ---------------------------------------------------------------------------

loc_967:				; CODE XREF: _BN_num_bits+Cj
		mov	eax, [edx]
		mov	eax, [eax+ecx*4]
		test	eax, 0FFFF0000h
		jz	short loc_9A0
		test	eax, 0FF000000h
		jz	short loc_98D
		shr	eax, 18h
		shl	ecx, 5
		movzx	eax, ?bits@?1??BN_num_bits_word@@9@9[eax] ; `BN_num_bits_word'::`2'::bits
		add	eax, 18h
		add	eax, ecx
		retn
; ---------------------------------------------------------------------------

loc_98D:				; CODE XREF: _BN_num_bits+20j
		shr	eax, 10h
		shl	ecx, 5
		movzx	eax, ?bits@?1??BN_num_bits_word@@9@9[eax] ; `BN_num_bits_word'::`2'::bits
		add	eax, 10h
		add	eax, ecx
		retn
; ---------------------------------------------------------------------------

loc_9A0:				; CODE XREF: _BN_num_bits+19j
		test	eax, 0FF00h
		jz	short loc_9BA
		shr	eax, 8
		shl	ecx, 5
		movzx	eax, ?bits@?1??BN_num_bits_word@@9@9[eax] ; `BN_num_bits_word'::`2'::bits
		add	eax, 8
		add	eax, ecx
		retn
; ---------------------------------------------------------------------------

loc_9BA:				; CODE XREF: _BN_num_bits+4Dj
		movzx	eax, ?bits@?1??BN_num_bits_word@@9@9[eax] ; `BN_num_bits_word'::`2'::bits
		shl	ecx, 5
		add	eax, ecx
		retn
_BN_num_bits	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 9C8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_num_bits_word
_BN_num_bits_word proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, 0FFFF0000h
		jz	short loc_9F6
		test	eax, 0FF000000h
		jz	short loc_9E8
		shr	eax, 18h
		movzx	eax, ?bits@?1??BN_num_bits_word@@9@9[eax] ; `BN_num_bits_word'::`2'::bits
		add	eax, 18h
		retn
; ---------------------------------------------------------------------------

loc_9E8:				; CODE XREF: _BN_num_bits_word+10j
		shr	eax, 10h
		movzx	eax, ?bits@?1??BN_num_bits_word@@9@9[eax] ; `BN_num_bits_word'::`2'::bits
		add	eax, 10h
		retn
; ---------------------------------------------------------------------------

loc_9F6:				; CODE XREF: _BN_num_bits_word+9j
		test	eax, 0FF00h
		jz	short loc_A0B
		shr	eax, 8
		movzx	eax, ?bits@?1??BN_num_bits_word@@9@9[eax] ; `BN_num_bits_word'::`2'::bits
		add	eax, 8
		retn
; ---------------------------------------------------------------------------

loc_A0B:				; CODE XREF: _BN_num_bits_word+33j
		movzx	eax, ?bits@?1??BN_num_bits_word@@9@9[eax] ; `BN_num_bits_word'::`2'::bits
		retn
_BN_num_bits_word endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A14h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_set_bit
_BN_set_bit	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		mov	ebx, [esp+4+arg_4]
		test	ebx, ebx
		jns	short loc_A21
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_A21:				; CODE XREF: _BN_set_bit+7j
		mov	eax, ebx
		cdq
		and	edx, 1Fh
		push	ebp
		push	esi
		push	edi
		lea	ebp, [edx+eax]
		sar	ebp, 5
		and	ebx, 8000001Fh
		jns	short loc_A3D
		dec	ebx
		or	ebx, 0FFFFFFE0h
		inc	ebx

loc_A3D:				; CODE XREF: _BN_set_bit+22j
		mov	esi, [esp+10h+arg_0]
		cmp	[esi+4], ebp
		jg	short loc_A85
		lea	edi, [ebp+1]
		cmp	edi, [esi+8]
		jg	short loc_A52
		mov	eax, esi
		jmp	short loc_A5C
; ---------------------------------------------------------------------------

loc_A52:				; CODE XREF: _BN_set_bit+38j
		push	edi
		push	esi
		call	_bn_expand2
		add	esp, 8

loc_A5C:				; CODE XREF: _BN_set_bit+3Cj
		test	eax, eax
		jnz	short loc_A65
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_A65:				; CODE XREF: _BN_set_bit+4Aj
		mov	eax, [esi+4]
		cmp	eax, edi
		jge	short loc_A82
		nop	dword ptr [eax+eax+00000000h]

loc_A74:				; CODE XREF: _BN_set_bit+6Cj
		mov	ecx, [esi]
		mov	dword ptr [ecx+eax*4], 0
		inc	eax
		cmp	eax, edi
		jl	short loc_A74

loc_A82:				; CODE XREF: _BN_set_bit+56j
		mov	[esi+4], edi

loc_A85:				; CODE XREF: _BN_set_bit+30j
		mov	eax, [esi]
		pop	edi
		pop	esi
		lea	ecx, [eax+ebp*4]
		mov	eax, [ecx]
		bts	eax, ebx
		pop	ebp
		mov	[ecx], eax
		mov	eax, 1
		pop	ebx
		retn
_BN_set_bit	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A9Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_set_negative
_BN_set_negative proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		cmp	[esp+arg_4], 0
		mov	eax, [esp+arg_0]
		jz	short loc_AB5
		cmp	dword ptr [eax+4], 0
		jz	short loc_AB5
		mov	dword ptr [eax+0Ch], 1
		retn
; ---------------------------------------------------------------------------

loc_AB5:				; CODE XREF: _BN_set_negative+9j
					; _BN_set_negative+Fj
		mov	dword ptr [eax+0Ch], 0
		retn
_BN_set_negative endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0AC0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_set_params
_BN_set_params	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	ecx, [esp+arg_0]
		push	esi
		mov	esi, 1Fh
		lea	edx, [esi-1Eh]
		test	ecx, ecx
		js	short loc_AE5
		cmp	ecx, esi
		mov	eax, edx
		cmovg	ecx, esi
		shl	eax, cl
		mov	ds:_bn_limit_bits, ecx
		mov	ds:_bn_limit_num, eax

loc_AE5:				; CODE XREF: _BN_set_params+Fj
		mov	ecx, [esp+4+arg_4]
		test	ecx, ecx
		js	short loc_B01
		cmp	ecx, esi
		mov	eax, edx
		cmovg	ecx, esi
		shl	eax, cl
		mov	ds:_bn_limit_bits_high,	ecx
		mov	ds:_bn_limit_num_high, eax

loc_B01:				; CODE XREF: _BN_set_params+2Bj
		mov	ecx, [esp+4+arg_8]
		test	ecx, ecx
		js	short loc_B1D
		cmp	ecx, esi
		mov	eax, edx
		cmovg	ecx, esi
		shl	eax, cl
		mov	ds:_bn_limit_bits_low, ecx
		mov	ds:_bn_limit_num_low, eax

loc_B1D:				; CODE XREF: _BN_set_params+47j
		mov	ecx, [esp+4+arg_C]
		test	ecx, ecx
		js	short loc_B38
		cmp	ecx, esi
		cmovg	ecx, esi
		shl	edx, cl
		mov	ds:_bn_limit_bits_mont,	ecx
		mov	ds:_bn_limit_num_mont, edx

loc_B38:				; CODE XREF: _BN_set_params+63j
		pop	esi
		retn
_BN_set_params	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B3Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_set_word
_BN_set_word	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		cmp	dword ptr [esi+8], 1
		jge	short loc_B71
		push	1
		push	esi
		call	_bn_expand_internal
		mov	edi, eax
		add	esp, 8
		test	edi, edi
		jz	short loc_B92
		mov	eax, [esi]
		test	eax, eax
		jz	short loc_B68
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_B68:				; CODE XREF: _BN_set_word+21j
		mov	[esi], edi
		mov	dword ptr [esi+8], 1

loc_B71:				; CODE XREF: _BN_set_word+Aj
		mov	eax, [esi]
		mov	ecx, [esp+8+arg_4]
		mov	dword ptr [esi+0Ch], 0
		pop	edi
		mov	[eax], ecx
		xor	eax, eax
		test	ecx, ecx
		setnz	al
		mov	[esi+4], eax
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_B92:				; CODE XREF: _BN_set_word+1Bj
		pop	edi
		xor	eax, eax
		pop	esi
		retn
_BN_set_word	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B98h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_swap
_BN_swap	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	ebp
		push	esi
		push	edi
		mov	eax, [ebx+10h]
		mov	edi, [ebx]
		mov	esi, [ebx+4]
		mov	edx, [ebx+8]
		mov	[esp+10h+arg_0], eax
		mov	eax, [esp+10h+arg_4]
		mov	ecx, [ebx+0Ch]
		mov	ebp, [eax+10h]
		mov	eax, [eax]
		mov	[ebx], eax
		mov	eax, [esp+10h+arg_4]
		mov	eax, [eax+4]
		mov	[ebx+4], eax
		mov	eax, [esp+10h+arg_4]
		mov	eax, [eax+8]
		mov	[ebx+8], eax
		mov	eax, [esp+10h+arg_4]
		mov	eax, [eax+0Ch]
		mov	[ebx+0Ch], eax
		mov	eax, [esp+10h+arg_4]
		mov	[eax+8], edx
		mov	edx, [esp+10h+arg_0]
		mov	[eax+0Ch], ecx
		mov	ecx, ebp
		mov	[eax], edi
		and	ecx, 2
		mov	[eax+4], esi
		and	ebp, 1
		mov	eax, edx
		and	edx, 2
		and	eax, 1
		or	ebp, edx
		or	ecx, eax
		mov	eax, [esp+10h+arg_4]
		pop	edi
		mov	[ebx+10h], ecx
		pop	esi
		mov	[eax+10h], ebp
		pop	ebp
		pop	ebx
		retn
_BN_swap	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C14h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_ucmp
_BN_ucmp	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		push	edi
		mov	edi, [esp+4+arg_0]
		mov	ecx, [edi+4]
		mov	eax, ecx
		sub	eax, [edx+4]
		jnz	short loc_C4A
		add	ecx, 0FFFFFFFFh
		mov	edi, [edi]
		mov	edx, [edx]
		push	esi
		js	short loc_C47
		lea	eax, [edx+ecx*4]
		sub	edi, edx

loc_C36:				; CODE XREF: _BN_ucmp+31j
		mov	edx, [edi+eax]
		mov	esi, [eax]
		cmp	esi, edx
		jnz	short loc_C4C
		sub	eax, 4
		sub	ecx, 1
		jns	short loc_C36

loc_C47:				; CODE XREF: _BN_ucmp+1Bj
		xor	eax, eax
		pop	esi

loc_C4A:				; CODE XREF: _BN_ucmp+11j
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_C4C:				; CODE XREF: _BN_ucmp+29j
		sbb	eax, eax
		and	eax, 2
		pop	esi
		dec	eax
		pop	edi
		retn
_BN_ucmp	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C58h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_value_one
_BN_value_one	proc near
		mov	eax, offset ?const_one@?1??BN_value_one@@9@9 ; `BN_value_one'::`2'::const_one
		retn
_BN_value_one	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C60h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _bn_cmp_part_words
_bn_cmp_part_words proc	near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	ecx, [esp+arg_C]
		push	ebx
		mov	ebx, [esp+4+arg_8]
		push	ebp
		push	esi
		mov	esi, [esp+0Ch+arg_4]
		lea	ebp, [ebx-1]
		test	ecx, ecx
		jns	short loc_C8D
		mov	eax, ebp
		mov	edx, ecx
		sub	eax, ecx
		lea	eax, [esi+eax*4]
		nop

loc_C80:				; CODE XREF: _bn_cmp_part_words+2Bj
		cmp	dword ptr [eax], 0
		jnz	short loc_CC6
		sub	eax, 4
		add	edx, 1
		js	short loc_C80

loc_C8D:				; CODE XREF: _bn_cmp_part_words+14j
		push	edi
		mov	edi, [esp+10h+arg_0]
		test	ecx, ecx
		jle	short loc_CAD
		lea	eax, [ecx+ebp]
		lea	eax, [edi+eax*4]
		nop	dword ptr [eax+00h]

loc_CA0:				; CODE XREF: _bn_cmp_part_words+4Bj
		cmp	dword ptr [eax], 0
		jnz	short loc_CCD
		dec	ecx
		sub	eax, 4
		test	ecx, ecx
		jg	short loc_CA0

loc_CAD:				; CODE XREF: _bn_cmp_part_words+34j
		mov	eax, [edi+ebx*4-4]
		mov	ecx, [esi+ebx*4-4]
		cmp	eax, ecx
		jz	short loc_CD7
		cmp	ecx, eax

loc_CBB:				; CODE XREF: _bn_cmp_part_words+8Aj
		pop	edi
		sbb	eax, eax
		pop	esi
		and	eax, 2
		pop	ebp
		dec	eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_CC6:				; CODE XREF: _bn_cmp_part_words+23j
		pop	esi
		pop	ebp
		or	eax, 0FFFFFFFFh
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_CCD:				; CODE XREF: _bn_cmp_part_words+43j
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, 1
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_CD7:				; CODE XREF: _bn_cmp_part_words+57j
		lea	ecx, [ebx-2]
		test	ecx, ecx
		js	short loc_CF4
		lea	eax, [esi+ecx*4]
		sub	edi, esi

loc_CE3:				; CODE XREF: _bn_cmp_part_words+92j
		mov	edx, [edi+eax]
		mov	esi, [eax]
		cmp	esi, edx
		jnz	short loc_CBB
		sub	eax, 4
		sub	ecx, 1
		jns	short loc_CE3

loc_CF4:				; CODE XREF: _bn_cmp_part_words+7Cj
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
_bn_cmp_part_words endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0CFCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _bn_cmp_words
_bn_cmp_words	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	edx, [esp+arg_4]
		push	esi
		mov	esi, [esp+4+arg_8]
		push	edi
		mov	edi, [esp+8+arg_0]
		mov	ecx, [edx+esi*4-4]
		mov	eax, [edi+esi*4-4]
		cmp	eax, ecx
		jz	short loc_D21
		cmp	ecx, eax

loc_D18:				; CODE XREF: _bn_cmp_words+38j
		sbb	eax, eax
		and	eax, 2
		pop	edi
		dec	eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_D21:				; CODE XREF: _bn_cmp_words+18j
		lea	ecx, [esi-2]
		test	ecx, ecx
		js	short loc_D3E
		lea	eax, [edx+ecx*4]
		sub	edi, edx

loc_D2D:				; CODE XREF: _bn_cmp_words+40j
		mov	edx, [edi+eax]
		mov	esi, [eax]
		cmp	esi, edx
		jnz	short loc_D18
		sub	eax, 4
		sub	ecx, 1
		jns	short loc_D2D

loc_D3E:				; CODE XREF: _bn_cmp_words+2Aj
		pop	edi
		xor	eax, eax
		pop	esi
		retn
_bn_cmp_words	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D44h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _bn_dup_expand
_bn_dup_expand	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		mov	ebx, [esp+4+arg_4]
		push	esi
		push	edi
		mov	edi, [esp+0Ch+arg_0]
		cmp	ebx, [edi+8]
		jle	short loc_D9F
		push	ebp
		push	ebx
		push	edi
		call	_bn_expand_internal
		mov	ebp, eax
		add	esp, 8
		test	ebp, ebp
		jz	short loc_D98
		call	_BN_new
		mov	esi, eax
		test	esi, esi
		jz	short loc_D88
		mov	eax, [edi+4]
		mov	[esi+4], eax
		mov	[esi+8], ebx
		mov	eax, [edi+0Ch]
		mov	[esi], ebp
		pop	ebp
		mov	[esi+0Ch], eax
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_D88:				; CODE XREF: _bn_dup_expand+2Aj
		push	ebp
		call	_CRYPTO_free
		add	esp, 4
		mov	eax, esi
		pop	ebp
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_D98:				; CODE XREF: _bn_dup_expand+1Fj
		pop	ebp
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_D9F:				; CODE XREF: _bn_dup_expand+Ej
		call	_BN_new
		mov	esi, eax
		test	esi, esi
		jz	short loc_DC1
		push	edi
		push	esi
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jnz	short loc_DC7
		push	esi
		call	_BN_free
		add	esp, 4

loc_DC1:				; CODE XREF: _bn_dup_expand+64j
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_DC7:				; CODE XREF: _bn_dup_expand+72j
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebx
		retn
_bn_dup_expand	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0DD0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _bn_expand2
_bn_expand2	proc near		; CODE XREF: _BN_bin2bn+5Fp
					; _BN_set_bit+40p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		push	esi
		mov	esi, [esp+8+arg_0]
		push	edi
		mov	edi, [esp+0Ch+arg_4]
		cmp	edi, [esi+8]
		jle	short loc_E08
		push	edi
		push	esi
		call	_bn_expand_internal
		mov	ebx, eax
		add	esp, 8
		test	ebx, ebx
		jnz	short loc_DF4
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_DF4:				; CODE XREF: _bn_expand2+1Ej
		mov	ecx, [esi]
		test	ecx, ecx
		jz	short loc_E03
		push	ecx
		call	_CRYPTO_free
		add	esp, 4

loc_E03:				; CODE XREF: _bn_expand2+28j
		mov	[esi], ebx
		mov	[esi+8], edi

loc_E08:				; CODE XREF: _bn_expand2+Ej
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebx
		retn
_bn_expand2	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E10h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_bn_expand_internal proc near		; CODE XREF: _BN_copy+2Ap
					; _BN_set_word+Fp ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_4]
		cmp	eax, 0FFFFFFh
		jle	short loc_E36
		push	128h
		push	offset ??_C@_0BF@OGBNCIDG@?4?2crypto?2bn?2bn_lib?4c?$AA@ ; ".\\crypto\\bn\\bn_lib.c"
		push	72h ; 'r'
		push	78h ; 'x'
		push	3
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_E36:				; CODE XREF: _bn_expand_internal+9j
		push	esi
		mov	esi, [esp+4+arg_0]
		test	byte ptr [esi+10h], 2
		jz	short loc_E5D
		push	12Ch
		push	offset ??_C@_0BF@OGBNCIDG@?4?2crypto?2bn?2bn_lib?4c?$AA@ ; ".\\crypto\\bn\\bn_lib.c"
		push	69h ; 'i'
		push	78h ; 'x'
		push	3
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_E5D:				; CODE XREF: _bn_expand_internal+2Fj
		push	edi
		push	12Fh
		shl	eax, 2
		push	offset ??_C@_0BF@OGBNCIDG@?4?2crypto?2bn?2bn_lib?4c?$AA@ ; ".\\crypto\\bn\\bn_lib.c"
		push	eax
		call	_CRYPTO_malloc
		mov	edi, eax
		add	esp, 0Ch
		mov	edx, edi
		mov	[esp+8+arg_4], edx
		test	edi, edi
		jnz	short loc_E9D
		push	131h
		push	offset ??_C@_0BF@OGBNCIDG@?4?2crypto?2bn?2bn_lib?4c?$AA@ ; ".\\crypto\\bn\\bn_lib.c"
		push	41h ; 'A'
		push	78h ; 'x'
		push	3
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_E9D:				; CODE XREF: _bn_expand_internal+6Ej
		push	ebx
		mov	ebx, [esi]
		test	ebx, ebx
		jz	short loc_EFF
		push	ebp
		mov	ebp, [esi+4]
		sar	ebp, 2
		test	ebp, ebp
		jle	short loc_ED9
		nop

loc_EB0:				; CODE XREF: _bn_expand_internal+BFj
		mov	ecx, [ebx+4]
		dec	ebp
		mov	edx, [ebx+8]
		mov	esi, [ebx+0Ch]
		mov	eax, [ebx]
		add	ebx, 10h
		mov	[edi], eax
		mov	[edi+4], ecx
		mov	[edi+8], edx
		mov	[edi+0Ch], esi
		add	edi, 10h
		test	ebp, ebp
		jg	short loc_EB0
		mov	esi, [esp+10h+arg_0]
		mov	edx, [esp+10h+arg_4]

loc_ED9:				; CODE XREF: _bn_expand_internal+9Dj
		mov	eax, [esi+4]
		and	eax, 3
		pop	ebp
		sub	eax, 1
		jz	short loc_EFB
		sub	eax, 1
		jz	short loc_EF5
		sub	eax, 1
		jnz	short loc_EFF
		mov	eax, [ebx+8]
		mov	[edi+8], eax

loc_EF5:				; CODE XREF: _bn_expand_internal+D8j
		mov	ecx, [ebx+4]
		mov	[edi+4], ecx

loc_EFB:				; CODE XREF: _bn_expand_internal+D3j
		mov	ecx, [ebx]
		mov	[edi], ecx

loc_EFF:				; CODE XREF: _bn_expand_internal+92j
					; _bn_expand_internal+DDj
		pop	ebx
		pop	edi
		mov	eax, edx
		pop	esi
		retn
_bn_expand_internal endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F08h
; COMDAT (pick any)
		public ??_C@_0BF@OGBNCIDG@?4?2crypto?2bn?2bn_lib?4c?$AA@
; `string'
??_C@_0BF@OGBNCIDG@?4?2crypto?2bn?2bn_lib?4c?$AA@ db '.\crypto\bn\bn_lib.c',0
					; DATA XREF: _BN_new+5o _BN_new+1Do ...
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _CRYPTO_malloc:near ; CODE XREF: _BN_new+Cp
					; _bn_expand_internal+5Cp
		extrn _CRYPTO_free:near	; CODE XREF: _BN_clear_free+27p
					; _BN_clear_free+45p ...
		extrn _OPENSSL_cleanse:near ; CODE XREF: _BN_clear_free+17p
					; _BN_clear_free+36p
		extrn _ERR_put_error:near ; CODE XREF: _BN_new+28p
					; _bn_expand_internal+1Bp ...
		extrn __chkstk:near	; CODE XREF: _BN_bin2bn+5p
					; _BN_consttime_swap+5p ...
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _BN_clear+15p


		end
