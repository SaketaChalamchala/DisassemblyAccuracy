;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	C4ADC3878CB8EBC832CCA4A9CE35B8E8
; Input	CRC32 :	59DB0821

; File Name   :	C:\compspace\Diff\openssl\obj\bn_recp.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_RECP_CTX_free
_BN_RECP_CTX_free proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	short loc_2A
		push	esi
		call	_BN_free
		lea	eax, [esi+14h]
		push	eax
		call	_BN_free
		add	esp, 8
		test	byte ptr [esi+30h], 1
		jz	short loc_2A
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_2A:					; CODE XREF: _BN_RECP_CTX_free+7j
					; _BN_RECP_CTX_free+1Fj
		pop	esi
		retn
_BN_RECP_CTX_free endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_RECP_CTX_init
_BN_RECP_CTX_init proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		push	esi
		call	_BN_init
		lea	eax, [esi+14h]
		push	eax
		call	_BN_init
		add	esp, 8
		mov	dword ptr [esi+28h], 0
		mov	dword ptr [esi+2Ch], 0
		mov	dword ptr [esi+30h], 0
		pop	esi
		retn
_BN_RECP_CTX_init endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_RECP_CTX_new
_BN_RECP_CTX_new proc near
		push	esi
		push	4Ch ; 'L'
		push	offset ??_C@_0BG@KPFPNIIP@?4?2crypto?2bn?2bn_recp?4c?$AA@ ; ".\\crypto\\bn\\bn_recp.c"
		push	34h ; '4'
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jnz	short loc_76
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_76:					; CODE XREF: _BN_RECP_CTX_new+16j
		push	esi
		call	_BN_init
		lea	eax, [esi+14h]
		push	eax
		call	_BN_init
		add	esp, 8
		mov	dword ptr [esi+28h], 0
		mov	dword ptr [esi+2Ch], 0
		mov	eax, esi
		mov	dword ptr [esi+30h], 1
		pop	esi
		retn
_BN_RECP_CTX_new endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_RECP_CTX_set
_BN_RECP_CTX_set proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		push	[esp+4+arg_4]
		mov	esi, [esp+8+arg_0]
		push	esi
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jnz	short loc_BC
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_BC:					; CODE XREF: _BN_RECP_CTX_set+14j
		lea	eax, [esi+14h]
		push	0
		push	eax
		call	_BN_set_word
		push	[esp+0Ch+arg_4]
		call	_BN_num_bits
		add	esp, 0Ch
		mov	[esi+28h], eax
		mov	dword ptr [esi+2Ch], 0
		mov	eax, 1
		pop	esi
		retn
_BN_RECP_CTX_set endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_div_recp
_BN_div_recp	proc near		; CODE XREF: _BN_mod_mul_reciprocal+60p

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	eax, 0Ch
		call	__chkstk
		push	ebx
		mov	ebx, [esp+10h+arg_10]
		push	ebp
		push	esi
		push	edi
		push	ebx
		mov	[esp+20h+var_4], 0
		call	_BN_CTX_start
		push	ebx
		call	_BN_CTX_get
		push	ebx
		mov	[esp+28h+var_8], eax
		call	_BN_CTX_get
		mov	ebp, [esp+28h+arg_0]
		add	esp, 0Ch
		mov	edi, eax
		mov	[esp+1Ch+var_C], edi
		test	ebp, ebp
		jnz	short loc_130
		push	ebx
		call	_BN_CTX_get
		add	esp, 4
		mov	ebp, eax

loc_130:				; CODE XREF: _BN_div_recp+3Fj
		mov	esi, [esp+1Ch+arg_4]
		test	esi, esi
		jnz	short loc_143
		push	ebx
		call	_BN_CTX_get
		add	esp, 4
		mov	esi, eax

loc_143:				; CODE XREF: _BN_div_recp+52j
		cmp	[esp+1Ch+var_8], 0
		jz	$err$34
		test	edi, edi
		jz	$err$34
		test	ebp, ebp
		jz	$err$34
		test	esi, esi
		jz	$err$34
		mov	edi, [esp+1Ch+arg_C]
		push	edi
		push	[esp+20h+arg_8]
		call	_BN_ucmp
		add	esp, 8
		test	eax, eax
		jns	short loc_1BC
		push	0
		push	ebp
		call	_BN_set_word
		push	[esp+24h+arg_8]
		push	esi
		call	_BN_copy
		add	esp, 10h
		push	ebx
		test	eax, eax
		jnz	short loc_1A7
		call	_BN_CTX_end
		add	esp, 4
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_1A7:				; CODE XREF: _BN_div_recp+AFj
		call	_BN_CTX_end
		add	esp, 4
		mov	eax, 1
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_1BC:				; CODE XREF: _BN_div_recp+95j
		push	[esp+1Ch+arg_8]
		call	_BN_num_bits
		mov	ecx, eax
		add	esp, 4
		mov	eax, [edi+28h]
		add	eax, eax
		cmp	eax, ecx
		cmovg	ecx, eax
		mov	[esp+1Ch+arg_0], ecx
		cmp	ecx, [edi+2Ch]
		jz	short loc_1EF
		push	ebx
		push	ecx
		lea	eax, [edi+14h]
		push	edi
		push	eax
		call	_BN_reciprocal
		add	esp, 10h
		mov	[edi+2Ch], eax

loc_1EF:				; CODE XREF: _BN_div_recp+F7j
		cmp	dword ptr [edi+2Ch], 0FFFFFFFFh
		jz	$err$34
		push	dword ptr [edi+28h]
		push	[esp+20h+arg_8]
		push	[esp+24h+var_8]
		call	_BN_rshift
		add	esp, 0Ch
		test	eax, eax
		jz	$err$34
		push	ebx
		lea	eax, [edi+14h]
		push	eax
		push	[esp+24h+var_8]
		push	[esp+28h+var_C]
		call	_BN_mul
		add	esp, 10h
		test	eax, eax
		jz	$err$34
		mov	eax, [esp+1Ch+arg_0]
		sub	eax, [edi+28h]
		push	eax
		push	[esp+20h+var_C]
		push	ebp
		call	_BN_rshift
		add	esp, 0Ch
		test	eax, eax
		jz	$err$34
		push	ebx
		push	ebp
		push	edi
		push	[esp+28h+var_C]
		mov	dword ptr [ebp+0Ch], 0
		call	_BN_mul
		add	esp, 10h
		test	eax, eax
		jz	$err$34
		push	[esp+1Ch+var_C]
		push	[esp+20h+arg_8]
		push	esi
		call	_BN_usub
		add	esp, 0Ch
		test	eax, eax
		jz	$err$34
		push	edi
		push	esi
		mov	dword ptr [esi+0Ch], 0
		mov	[esp+24h+arg_0], 0
		call	_BN_ucmp
		add	esp, 8
		test	eax, eax
		js	short loc_2E0
		xchg	ax, ax

loc_2A4:				; CODE XREF: _BN_div_recp+1FAj
		mov	ecx, [esp+1Ch+arg_0]
		mov	eax, ecx
		inc	ecx
		mov	[esp+1Ch+arg_0], ecx
		cmp	eax, 2
		jg	short loc_2EE
		push	edi
		push	esi
		push	esi
		call	_BN_usub
		add	esp, 0Ch
		test	eax, eax
		jz	short $err$34
		push	1
		push	ebp
		call	_BN_add_word
		add	esp, 8
		test	eax, eax
		jz	short $err$34
		push	edi
		push	esi
		call	_BN_ucmp
		add	esp, 8
		test	eax, eax
		jns	short loc_2A4

loc_2E0:				; CODE XREF: _BN_div_recp+1BCj
		cmp	dword ptr [esi+4], 0
		mov	eax, [esp+1Ch+arg_8]
		jnz	short loc_31E
		xor	ecx, ecx
		jmp	short loc_321
; ---------------------------------------------------------------------------

loc_2EE:				; CODE XREF: _BN_div_recp+1CEj
		push	0CEh ; 'Î'
		push	offset ??_C@_0BG@KPFPNIIP@?4?2crypto?2bn?2bn_recp?4c?$AA@ ; ".\\crypto\\bn\\bn_recp.c"
		push	65h ; 'e'
		push	82h ; '‚'
		push	3
		call	_ERR_put_error
		add	esp, 14h
		push	ebx
		call	_BN_CTX_end
		mov	eax, [esp+20h+var_4]
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_31E:				; CODE XREF: _BN_div_recp+204j
		mov	ecx, [eax+0Ch]

loc_321:				; CODE XREF: _BN_div_recp+208j
		mov	[esi+0Ch], ecx
		mov	eax, [eax+0Ch]
		xor	eax, [edi+0Ch]
		mov	[ebp+0Ch], eax
		mov	[esp+1Ch+var_4], 1

$err$34:				; CODE XREF: _BN_div_recp+64j
					; _BN_div_recp+6Cj ...
		push	ebx
		call	_BN_CTX_end
		mov	eax, [esp+20h+var_4]
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 0Ch
		retn
_BN_div_recp	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 34Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_mod_mul_reciprocal
_BN_mod_mul_reciprocal proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		push	ebx
		push	esi
		mov	esi, [esp+8+arg_10]
		xor	ebx, ebx
		push	edi
		push	esi
		call	_BN_CTX_start
		push	esi
		call	_BN_CTX_get
		mov	edi, eax
		add	esp, 8
		test	edi, edi
		jz	short $err$11
		mov	eax, [esp+0Ch+arg_8]
		test	eax, eax
		jz	short loc_39C
		mov	ecx, [esp+0Ch+arg_4]
		push	esi
		cmp	ecx, eax
		jnz	short loc_38B
		push	ecx
		push	edi
		call	_BN_sqr
		add	esp, 0Ch
		test	eax, eax
		jz	short $err$11
		jmp	short loc_3A0
; ---------------------------------------------------------------------------

loc_38B:				; CODE XREF: _BN_mod_mul_reciprocal+2Dj
		push	eax
		push	ecx
		push	edi
		call	_BN_mul
		add	esp, 10h
		test	eax, eax
		jz	short $err$11
		jmp	short loc_3A0
; ---------------------------------------------------------------------------

loc_39C:				; CODE XREF: _BN_mod_mul_reciprocal+24j
		mov	edi, [esp+0Ch+arg_4]

loc_3A0:				; CODE XREF: _BN_mod_mul_reciprocal+3Dj
					; _BN_mod_mul_reciprocal+4Ej
		push	esi
		push	[esp+10h+arg_C]
		push	edi
		push	[esp+18h+arg_0]
		push	0
		call	_BN_div_recp
		add	esp, 14h
		mov	ebx, eax

$err$11:				; CODE XREF: _BN_mod_mul_reciprocal+1Cj
					; _BN_mod_mul_reciprocal+3Bj ...
		push	esi
		call	_BN_CTX_end
		add	esp, 4
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebx
		retn
_BN_mod_mul_reciprocal endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3C8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_reciprocal
_BN_reciprocal	proc near		; CODE XREF: _BN_div_recp+100p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	ebx
		push	esi
		mov	esi, [esp+8+arg_C]
		push	edi
		push	esi
		or	edi, 0FFFFFFFFh
		call	_BN_CTX_start
		push	esi
		call	_BN_CTX_get
		mov	ebx, eax
		add	esp, 8
		test	ebx, ebx
		jz	short $err$7
		push	[esp+0Ch+arg_8]
		push	ebx
		call	_BN_set_bit
		add	esp, 8
		test	eax, eax
		jz	short $err$7
		push	esi
		push	[esp+10h+arg_4]
		push	ebx
		push	0
		push	[esp+1Ch+arg_0]
		call	_BN_div
		add	esp, 14h
		test	eax, eax
		cmovnz	edi, [esp+0Ch+arg_8]

$err$7:					; CODE XREF: _BN_reciprocal+1Dj
					; _BN_reciprocal+2Ej
		push	esi
		call	_BN_CTX_end
		add	esp, 4
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebx
		retn
_BN_reciprocal	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 424h
; COMDAT (pick any)
		public ??_C@_0BG@KPFPNIIP@?4?2crypto?2bn?2bn_recp?4c?$AA@
; `string'
??_C@_0BG@KPFPNIIP@?4?2crypto?2bn?2bn_recp?4c?$AA@ db '.\crypto\bn\bn_recp.c',0
					; DATA XREF: _BN_RECP_CTX_new+3o
					; _BN_div_recp+20Fo
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _CRYPTO_malloc:near ; CODE XREF: _BN_RECP_CTX_new+Ap
		extrn _CRYPTO_free:near	; CODE XREF: _BN_RECP_CTX_free+22p
		extrn _ERR_put_error:near ; CODE XREF: _BN_div_recp+21Dp
		extrn _BN_CTX_start:near ; CODE	XREF: _BN_div_recp+1Bp
					; _BN_mod_mul_reciprocal+Ap ...
		extrn _BN_CTX_get:near	; CODE XREF: _BN_div_recp+21p
					; _BN_div_recp+2Bp ...
		extrn _BN_CTX_end:near	; CODE XREF: _BN_div_recp+B1p
					; _BN_div_recp:loc_1A7p ...
		extrn _BN_num_bits:near	; CODE XREF: _BN_RECP_CTX_set+27p
					; _BN_div_recp+DCp
		extrn _BN_init:near	; CODE XREF: _BN_RECP_CTX_init+6p
					; _BN_RECP_CTX_init+Fp	...
		extrn _BN_copy:near	; CODE XREF: _BN_RECP_CTX_set+Ap
					; _BN_div_recp+A4p
		extrn _BN_usub:near	; CODE XREF: _BN_div_recp+191p
					; _BN_div_recp+1D3p
		extrn _BN_mul:near	; CODE XREF: _BN_div_recp+13Dp
					; _BN_div_recp+178p ...
		extrn _BN_sqr:near	; CODE XREF: _BN_mod_mul_reciprocal+31p
		extrn _BN_div:near	; CODE XREF: _BN_reciprocal+3Cp
		extrn _BN_add_word:near	; CODE XREF: _BN_div_recp+1E2p
		extrn _BN_set_word:near	; CODE XREF: _BN_RECP_CTX_set+1Ep
					; _BN_div_recp+9Ap
		extrn _BN_free:near	; CODE XREF: _BN_RECP_CTX_free+Ap
					; _BN_RECP_CTX_free+13p
		extrn _BN_rshift:near	; CODE XREF: _BN_div_recp+120p
					; _BN_div_recp+15Ap
		extrn _BN_ucmp:near	; CODE XREF: _BN_div_recp+8Bp
					; _BN_div_recp+1B2p ...
		extrn _BN_set_bit:near	; CODE XREF: _BN_reciprocal+24p
		extrn __chkstk:near	; CODE XREF: _BN_div_recp+5p


		end
