;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	28E5DB39C89C1BE35EDCDD8FD5065161
; Input	CRC32 :	7EA9B7AB

; File Name   :	C:\compspace\Diff\openssl\obj\x86cpuid.obj
; Format      :	COFF (X386MAGIC)

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
; Segment alignment '64byte' can not be represented in assembly
_text		segment	para public 'CODE' use32
		assume cs:_text
		assume es:nothing, ss:nothing, ds:_CRT$XCU, fs:nothing,	gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public L$_OPENSSL_ia32_cpuid_begin
L$_OPENSSL_ia32_cpuid_begin proc near

arg_0		= dword	ptr  4

		push	ebp
		push	ebx
		push	esi
		push	edi
		xor	edx, edx
		pushf
		pop	eax
		mov	ecx, eax
		xor	eax, 200000h
		push	eax
		popf
		pushf
		pop	eax
		xor	ecx, eax
		xor	eax, eax
		bt	ecx, 15h
		jnb	L$000nocpuid
		mov	esi, [esp+10h+arg_0]
		mov	[esi+8], eax
		cpuid
		mov	edi, eax
		xor	eax, eax
		cmp	ebx, 756E6547h
		setnz	al
		mov	ebp, eax
		cmp	edx, 49656E69h
		setnz	al
		or	ebp, eax
		cmp	ecx, 6C65746Eh
		setnz	al
		or	ebp, eax
		jz	L$001intel
		cmp	ebx, 68747541h
		setnz	al
		mov	esi, eax
		cmp	edx, 69746E65h
		setnz	al
		or	esi, eax
		cmp	ecx, 444D4163h
		setnz	al
		or	esi, eax
		jnz	L$001intel
		mov	eax, 80000000h
		cpuid
		cmp	eax, 80000001h
		jb	L$001intel
		mov	esi, eax
		mov	eax, 80000001h
		cpuid
		or	ebp, ecx
		and	ebp, 801h
		cmp	esi, 80000008h
		jb	L$001intel
		mov	eax, 80000008h
		cpuid
		movzx	esi, cl
		inc	esi
		mov	eax, 1
		xor	ecx, ecx
		cpuid
		bt	edx, 1Ch
		jnb	L$002generic
		shr	ebx, 10h
		and	ebx, 0FFh
		cmp	ebx, esi
		ja	L$002generic
		and	edx, 0EFFFFFFFh
		jmp	L$002generic
; ---------------------------------------------------------------------------

L$001intel:				; CODE XREF: L$_OPENSSL_ia32_cpuid_begin+4Fj
					; L$_OPENSSL_ia32_cpuid_begin+76j ...
		cmp	edi, 7
		jb	L$003cacheinfo
		mov	esi, [esp+10h+arg_0]
		mov	eax, 7
		xor	ecx, ecx
		cpuid
		mov	[esi+8], ebx

L$003cacheinfo:				; CODE XREF: L$_OPENSSL_ia32_cpuid_begin+E8j
		cmp	edi, 4
		mov	edi, 0FFFFFFFFh
		jb	L$004nocacheinfo
		mov	eax, 4
		mov	ecx, 0
		cpuid
		mov	edi, eax
		shr	edi, 0Eh
		and	edi, 0FFFh

L$004nocacheinfo:			; CODE XREF: L$_OPENSSL_ia32_cpuid_begin+106j
		mov	eax, 1
		xor	ecx, ecx
		cpuid
		and	edx, 0BFEFFFFFh
		cmp	ebp, 0
		jnz	L$005notintel
		or	edx, 40000000h
		and	ah, 0Fh
		cmp	ah, 0Fh
		jnz	L$005notintel
		or	edx, 100000h

L$005notintel:				; CODE XREF: L$_OPENSSL_ia32_cpuid_begin+135j
					; L$_OPENSSL_ia32_cpuid_begin+147j
		bt	edx, 1Ch
		jnb	L$002generic
		and	edx, 0EFFFFFFFh
		cmp	edi, 0
		jz	L$002generic
		or	edx, 10000000h
		shr	ebx, 10h
		cmp	bl, 1
		ja	L$002generic
		and	edx, 0EFFFFFFFh

L$002generic:				; CODE XREF: L$_OPENSSL_ia32_cpuid_begin+C3j
					; L$_OPENSSL_ia32_cpuid_begin+D4j ...
		and	ebp, 800h
		and	ecx, 0FFFFF7FFh
		mov	esi, edx
		or	ebp, ecx
		bt	ecx, 1Bh
		jnb	L$006clear_avx
		xor	ecx, ecx
		xgetbv
		and	eax, 6
		cmp	eax, 6
		jz	L$007done
		cmp	eax, 2
		jz	L$006clear_avx

L$008clear_xmm:
		and	ebp, 0FDFFFFFDh
		and	esi, 0FEFFFFFFh

L$006clear_avx:				; CODE XREF: L$_OPENSSL_ia32_cpuid_begin+198j
					; L$_OPENSSL_ia32_cpuid_begin+1B2j
		and	ebp, 0EFFFE7FFh
		mov	edi, [esp+10h+arg_0]
		and	dword ptr [edi+8], 0FFFFFFDFh

L$007done:				; CODE XREF: L$_OPENSSL_ia32_cpuid_begin+1A9j
		mov	eax, esi
		mov	edx, ebp

L$000nocpuid:				; CODE XREF: L$_OPENSSL_ia32_cpuid_begin+1Bj
		pop	edi
		pop	esi
		pop	ebx
		pop	ebp
		retn
L$_OPENSSL_ia32_cpuid_begin endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================


		public L$_OPENSSL_rdtsc_begin
L$_OPENSSL_rdtsc_begin proc near
		xor	eax, eax
		xor	edx, edx
		lea	ecx, _OPENSSL_ia32cap_P
		bt	dword ptr [ecx], 4
		jnb	L$009notsc
		rdtsc

L$009notsc:				; CODE XREF: L$_OPENSSL_rdtsc_begin+Ej
		retn
L$_OPENSSL_rdtsc_begin endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================


		public L$_OPENSSL_instrument_halt_begin
L$_OPENSSL_instrument_halt_begin proc near

var_8		= dword	ptr -8
var_4		= dword	ptr -4

		lea	ecx, _OPENSSL_ia32cap_P
		bt	dword ptr [ecx], 4
		jnb	L$010nohalt
		push	cs
		nop
		pop	eax
		nop
		and	eax, 3
		jnz	L$010nohalt
		pushf
		pop	eax
		bt	eax, 9
		jnb	L$010nohalt
		rdtsc
		push	edx
		push	eax
		hlt
; ---------------------------------------------------------------------------
		dw 310Fh
; ---------------------------------------------------------------------------
		sub	eax, [esp+8+var_8]
		sbb	edx, [esp+8+var_4]
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

L$010nohalt:				; CODE XREF: L$_OPENSSL_instrument_halt_begin+Aj
					; L$_OPENSSL_instrument_halt_begin+17j	...
		xor	eax, eax
		xor	edx, edx
		retn
L$_OPENSSL_instrument_halt_begin endp


; =============== S U B	R O U T	I N E =======================================


		public L$_OPENSSL_far_spin_begin
L$_OPENSSL_far_spin_begin proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		pushf
		pop	eax
		bt	eax, 9
		jnb	L$011nospin
		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		push	ds
		mov	ds, eax
		nop
		xor	eax, eax
		mov	edx, [ecx]
		jmp	L$012spin
; ---------------------------------------------------------------------------
		align 10h

L$012spin:				; CODE XREF: L$_OPENSSL_far_spin_begin+1Cj
					; L$_OPENSSL_far_spin_begin+33j
		inc	eax
		cmp	edx, [ecx]
		jz	L$012spin
		nop
		nop
		nop
		pop	ds
		retn
; ---------------------------------------------------------------------------

L$011nospin:				; CODE XREF: L$_OPENSSL_far_spin_begin+6j
		xor	eax, eax
		xor	edx, edx
		retn
L$_OPENSSL_far_spin_begin endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================


		public L$_OPENSSL_wipe_cpu_begin
L$_OPENSSL_wipe_cpu_begin proc near

arg_0		= byte ptr  4

		xor	eax, eax
		xor	edx, edx
		lea	ecx, _OPENSSL_ia32cap_P
		mov	ecx, [ecx]
		bt	dword ptr [ecx], 1
		jnb	L$013no_x87
		and	ecx, 5000000h
		cmp	ecx, 5000000h
		jnz	L$014no_sse2
		pxor	xmm0, xmm0
		pxor	xmm1, xmm1
		pxor	xmm2, xmm2
		pxor	xmm3, xmm3
		pxor	xmm4, xmm4
		pxor	xmm5, xmm5
		pxor	xmm6, xmm6
		pxor	xmm7, xmm7

L$014no_sse2:				; CODE XREF: L$_OPENSSL_wipe_cpu_begin+22j
		fldz
		fldz
		fldz
		fldz
		fldz
		fldz
		fldz
		fldz
		finit
		nop

L$013no_x87:				; CODE XREF: L$_OPENSSL_wipe_cpu_begin+10j
		lea	eax, [esp+arg_0]
		retn
L$_OPENSSL_wipe_cpu_begin endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================


		public L$_OPENSSL_atomic_add_begin
L$_OPENSSL_atomic_add_begin proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		push	ebx
		nop
		mov	eax, [edx]

L$015spin:				; CODE XREF: L$_OPENSSL_atomic_add_begin+14j
		lea	ebx, [eax+ecx]
		nop
		lock cmpxchg [edx], ebx
		jnz	L$015spin
		mov	eax, ebx
		pop	ebx
		retn
L$_OPENSSL_atomic_add_begin endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public L$_OPENSSL_indirect_call_begin
L$_OPENSSL_indirect_call_begin proc near

arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		sub	esp, 1Ch
		mov	ecx, [ebp+arg_4]
		mov	[esp], ecx
		mov	edx, [ebp+arg_8]
		mov	[esp+4], edx
		mov	eax, [ebp+arg_C]
		mov	[esp+8], eax
		mov	eax, [ebp+arg_10]
		mov	[esp+0Ch], eax
		mov	eax, [ebp+arg_14]
		mov	[esp+10h], eax
		mov	eax, [ebp+arg_18]
		mov	[esp+14h], eax
		mov	eax, [ebp+arg_1C]
		mov	[esp+18h], eax
		call	[ebp+arg_0]
		mov	esp, ebp
		pop	ebp
		retn
L$_OPENSSL_indirect_call_begin endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================


		public L$_OPENSSL_cleanse_begin
L$_OPENSSL_cleanse_begin proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		xor	eax, eax
		cmp	ecx, 7
		jnb	L$016lot
		cmp	ecx, 0
		jz	L$017ret

L$018little:				; CODE XREF: L$_OPENSSL_cleanse_begin+24j
					; L$_OPENSSL_cleanse_begin+60j
		mov	[edx], al
		sub	ecx, 1
		lea	edx, [edx+1]
		jnz	L$018little

L$017ret:				; CODE XREF: L$_OPENSSL_cleanse_begin+16j
		retn
; ---------------------------------------------------------------------------
		align 10h

L$016lot:				; CODE XREF: L$_OPENSSL_cleanse_begin+Dj
					; L$_OPENSSL_cleanse_begin+44j
		test	edx, 3
		jz	L$019aligned
		mov	[edx], al
		lea	ecx, [ecx-1]
		lea	edx, [edx+1]
		jmp	L$016lot
; ---------------------------------------------------------------------------

L$019aligned:				; CODE XREF: L$_OPENSSL_cleanse_begin+36j
					; L$_OPENSSL_cleanse_begin+57j
		mov	[edx], eax
		lea	ecx, [ecx-4]
		test	ecx, 0FFFFFFFCh
		lea	edx, [edx+4]
		jnz	L$019aligned
		cmp	ecx, 0
		jnz	L$018little
		retn
L$_OPENSSL_cleanse_begin endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================


		public L$_OPENSSL_ia32_rdrand_begin
L$_OPENSSL_ia32_rdrand_begin proc near
		mov	ecx, 8

L$020loop:				; CODE XREF: L$_OPENSSL_ia32_rdrand_begin+Ej
		rdrand	eax
		jb	L$021break
		loop	L$020loop

L$021break:				; CODE XREF: L$_OPENSSL_ia32_rdrand_begin+8j
		cmp	eax, 0
		cmovz	eax, ecx
		retn
L$_OPENSSL_ia32_rdrand_begin endp

; ---------------------------------------------------------------------------
		align 10h

; =============== S U B	R O U T	I N E =======================================


		public L$_OPENSSL_ia32_rdseed_begin
L$_OPENSSL_ia32_rdseed_begin proc near
		mov	ecx, 8

L$022loop:				; CODE XREF: L$_OPENSSL_ia32_rdseed_begin+Ej
		rdseed	eax
		jb	L$023break
		loop	L$022loop

L$023break:				; CODE XREF: L$_OPENSSL_ia32_rdseed_begin+8j
		cmp	eax, 0
		cmovz	eax, ecx
		retn
L$_OPENSSL_ia32_rdseed_begin endp

; ---------------------------------------------------------------------------
		align 4
_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_CRT$XCU	segment	dword public 'DATA' use32
		assume cs:_CRT$XCU
		;org 40Ch
		dd offset _OPENSSL_cpuid_setup
_CRT$XCU	ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _OPENSSL_cpuid_setup:near	; DATA XREF: .CRT$XCU:0000040Co
		extrn _OPENSSL_ia32cap_P:near ;	DATA XREF: L$_OPENSSL_rdtsc_begin+4o
					; L$_OPENSSL_instrument_halt_begino ...


		end
