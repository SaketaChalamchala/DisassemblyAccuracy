;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	7B4C6293CDA2B2E40E901A0C1A4256EC
; Input	CRC32 :	CC43A506

; File Name   :	C:\compspace\Diff\openssl\obj\ec_key.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_check_key
_EC_KEY_check_key proc near		; CODE XREF: _EC_KEY_set_public_key_affine_coordinates+12Ap

arg_0		= dword	ptr  4

		push	ebp
		push	esi
		mov	esi, [esp+8+arg_0]
		xor	ebp, ebp
		test	esi, esi
		jz	loc_1D9
		mov	eax, [esi+4]
		test	eax, eax
		jz	loc_1D9
		mov	ecx, [esi+8]
		test	ecx, ecx
		jz	loc_1D9
		push	ecx
		push	eax
		call	_EC_POINT_is_at_infinity
		add	esp, 8
		test	eax, eax
		jz	short loc_54
		push	133h
		push	offset ??_C@_0BF@PJJIPJIB@?4?2crypto?2ec?2ec_key?4c?$AA@ ; ".\\crypto\\ec\\ec_key.c"
		push	6Ah ; 'j'
		push	0B1h ; '±'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		mov	eax, ebp
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_54:					; CODE XREF: _EC_KEY_check_key+32j
		push	ebx
		call	_BN_CTX_new
		mov	ebx, eax
		test	ebx, ebx
		jz	loc_1D3
		push	edi
		push	dword ptr [esi+4]
		call	_EC_POINT_new
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jz	$err$24
		push	ebx
		push	dword ptr [esi+8]
		push	dword ptr [esi+4]
		call	_EC_POINT_is_on_curve
		add	esp, 0Ch
		test	eax, eax
		jg	short loc_AD
		push	13Eh
		push	offset ??_C@_0BF@PJJIPJIB@?4?2crypto?2ec?2ec_key?4c?$AA@ ; ".\\crypto\\ec\\ec_key.c"
		push	6Bh ; 'k'
		push	0B1h ; '±'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		jmp	$err$24
; ---------------------------------------------------------------------------

loc_AD:					; CODE XREF: _EC_KEY_check_key+8Bj
		mov	ecx, [esi+4]
		lea	eax, [ecx+8]
		mov	[esp+10h+arg_0], ecx
		cmp	[eax+4], ebp
		jnz	short loc_DC
		push	144h
		push	offset ??_C@_0BF@PJJIPJIB@?4?2crypto?2ec?2ec_key?4c?$AA@ ; ".\\crypto\\ec\\ec_key.c"
		push	7Ah ; 'z'
		push	0B1h ; '±'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		jmp	$err$24
; ---------------------------------------------------------------------------

loc_DC:					; CODE XREF: _EC_KEY_check_key+BAj
		push	ebx
		push	eax
		push	dword ptr [esi+8]
		push	0
		push	edi
		push	ecx
		call	_EC_POINT_mul
		add	esp, 18h
		test	eax, eax
		jnz	short loc_111
		push	148h

loc_F6:					; CODE XREF: _EC_KEY_check_key+181j
		push	offset ??_C@_0BF@PJJIPJIB@?4?2crypto?2ec?2ec_key?4c?$AA@ ; ".\\crypto\\ec\\ec_key.c"
		push	10h
		push	0B1h ; '±'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		jmp	$err$24
; ---------------------------------------------------------------------------

loc_111:				; CODE XREF: _EC_KEY_check_key+EFj
		push	edi
		push	dword ptr [esi+4]
		call	_EC_POINT_is_at_infinity
		add	esp, 8
		test	eax, eax
		jnz	short loc_141
		push	14Ch

loc_126:				; CODE XREF: _EC_KEY_check_key+162j
		push	offset ??_C@_0BF@PJJIPJIB@?4?2crypto?2ec?2ec_key?4c?$AA@ ; ".\\crypto\\ec\\ec_key.c"
		push	82h ; '‚'
		push	0B1h ; '±'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		jmp	short $err$24
; ---------------------------------------------------------------------------

loc_141:				; CODE XREF: _EC_KEY_check_key+11Fj
		mov	ecx, [esi+0Ch]
		test	ecx, ecx
		jz	short loc_1B7
		mov	eax, [esp+10h+arg_0]
		add	eax, 8
		push	eax
		push	ecx
		call	_BN_cmp
		add	esp, 8
		test	eax, eax
		js	short loc_164
		push	155h
		jmp	short loc_126
; ---------------------------------------------------------------------------

loc_164:				; CODE XREF: _EC_KEY_check_key+15Bj
		push	ebx
		push	0
		push	0
		push	dword ptr [esi+0Ch]
		push	edi
		push	dword ptr [esi+4]
		call	_EC_POINT_mul
		add	esp, 18h
		test	eax, eax
		jnz	short loc_186
		push	15Ah
		jmp	loc_F6
; ---------------------------------------------------------------------------

loc_186:				; CODE XREF: _EC_KEY_check_key+17Aj
		push	ebx
		push	dword ptr [esi+8]
		push	edi
		push	dword ptr [esi+4]
		call	_EC_POINT_cmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_1B7
		push	15Eh
		push	offset ??_C@_0BF@PJJIPJIB@?4?2crypto?2ec?2ec_key?4c?$AA@ ; ".\\crypto\\ec\\ec_key.c"
		push	7Bh ; '{'
		push	0B1h ; '±'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		jmp	short $err$24
; ---------------------------------------------------------------------------

loc_1B7:				; CODE XREF: _EC_KEY_check_key+146j
					; _EC_KEY_check_key+198j
		mov	ebp, 1

$err$24:				; CODE XREF: _EC_KEY_check_key+74j
					; _EC_KEY_check_key+A8j ...
		push	ebx
		call	_BN_CTX_free
		add	esp, 4
		test	edi, edi
		jz	short loc_1D2
		push	edi
		call	_EC_POINT_free
		add	esp, 4

loc_1D2:				; CODE XREF: _EC_KEY_check_key+1C7j
		pop	edi

loc_1D3:				; CODE XREF: _EC_KEY_check_key+5Ej
		pop	ebx
		pop	esi
		mov	eax, ebp
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_1D9:				; CODE XREF: _EC_KEY_check_key+Aj
					; _EC_KEY_check_key+15j ...
		push	12Eh
		push	offset ??_C@_0BF@PJJIPJIB@?4?2crypto?2ec?2ec_key?4c?$AA@ ; ".\\crypto\\ec\\ec_key.c"
		push	43h ; 'C'
		push	0B1h ; '±'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		pop	ebp
		retn
_EC_KEY_check_key endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1FCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_clear_flags
_EC_KEY_clear_flags proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		mov	eax, [esp+arg_4]
		not	eax
		and	[ecx+1Ch], eax
		retn
_EC_KEY_clear_flags endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 20Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_copy
_EC_KEY_copy	proc near		; CODE XREF: _EC_KEY_dup+11p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	edi
		test	ebx, ebx
		jz	loc_33C
		mov	edi, [esp+8+arg_4]
		test	edi, edi
		jz	loc_33C
		mov	eax, [edi+4]
		push	esi
		test	eax, eax
		jz	short loc_269
		push	eax
		call	_EC_GROUP_method_of
		mov	esi, eax
		add	esp, 4
		mov	eax, [ebx+4]
		test	eax, eax
		jz	short loc_249
		push	eax
		call	_EC_GROUP_free
		add	esp, 4

loc_249:				; CODE XREF: _EC_KEY_copy+32j
		push	esi
		call	_EC_GROUP_new
		add	esp, 4
		mov	[ebx+4], eax
		test	eax, eax
		jz	short loc_2D1
		push	dword ptr [edi+4]
		push	eax
		call	_EC_GROUP_copy
		add	esp, 8
		test	eax, eax
		jz	short loc_2D1

loc_269:				; CODE XREF: _EC_KEY_copy+20j
		cmp	dword ptr [edi+8], 0
		jz	short loc_2A7
		cmp	dword ptr [edi+4], 0
		jz	short loc_2A7
		mov	eax, [ebx+8]
		test	eax, eax
		jz	short loc_285
		push	eax
		call	_EC_POINT_free
		add	esp, 4

loc_285:				; CODE XREF: _EC_KEY_copy+6Ej
		push	dword ptr [edi+4]
		call	_EC_POINT_new
		add	esp, 4
		mov	[ebx+8], eax
		test	eax, eax
		jz	short loc_2D1
		push	dword ptr [edi+8]
		push	eax
		call	_EC_POINT_copy
		add	esp, 8
		test	eax, eax
		jz	short loc_2D1

loc_2A7:				; CODE XREF: _EC_KEY_copy+61j
					; _EC_KEY_copy+67j
		cmp	dword ptr [edi+0Ch], 0
		jz	short loc_2D7
		cmp	dword ptr [ebx+0Ch], 0
		jnz	short loc_2BF
		call	_BN_new
		mov	[ebx+0Ch], eax
		test	eax, eax
		jz	short loc_2D1

loc_2BF:				; CODE XREF: _EC_KEY_copy+A5j
		push	dword ptr [edi+0Ch]
		push	dword ptr [ebx+0Ch]
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jnz	short loc_2D7

loc_2D1:				; CODE XREF: _EC_KEY_copy+4Bj
					; _EC_KEY_copy+5Bj ...
		pop	esi
		pop	edi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_2D7:				; CODE XREF: _EC_KEY_copy+9Fj
					; _EC_KEY_copy+C3j
		push	ebp
		lea	ebp, [ebx+20h]
		push	ebp
		call	_EC_EX_DATA_free_all_data
		mov	esi, [edi+20h]
		add	esp, 4
		test	esi, esi
		jz	short loc_318
		nop

loc_2EC:				; CODE XREF: _EC_KEY_copy+10Aj
		push	dword ptr [esi+4]
		mov	eax, [esi+8]
		call	eax
		add	esp, 4
		test	eax, eax
		jz	short loc_335
		push	dword ptr [esi+10h]
		push	dword ptr [esi+0Ch]
		push	dword ptr [esi+8]
		push	eax
		push	ebp
		call	_EC_EX_DATA_set_data
		add	esp, 14h
		test	eax, eax
		jz	short loc_335
		mov	esi, [esi]
		test	esi, esi
		jnz	short loc_2EC

loc_318:				; CODE XREF: _EC_KEY_copy+DDj
		mov	ecx, [edi+10h]
		mov	eax, ebx
		mov	[ebx+10h], ecx
		mov	ecx, [edi+14h]
		mov	[ebx+14h], ecx
		mov	ecx, [edi]
		pop	ebp
		mov	[ebx], ecx
		mov	ecx, [edi+1Ch]
		pop	esi
		pop	edi
		mov	[ebx+1Ch], ecx
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_335:				; CODE XREF: _EC_KEY_copy+EDj
					; _EC_KEY_copy+104j
		pop	ebp
		pop	esi
		pop	edi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_33C:				; CODE XREF: _EC_KEY_copy+8j
					; _EC_KEY_copy+14j
		push	91h ; '‘'
		push	offset ??_C@_0BF@PJJIPJIB@?4?2crypto?2ec?2ec_key?4c?$AA@ ; ".\\crypto\\ec\\ec_key.c"
		push	43h ; 'C'
		push	0B2h ; '²'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	ebx
		retn
_EC_KEY_copy	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 35Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_dup
_EC_KEY_dup	proc near

arg_0		= dword	ptr  4

		push	esi
		call	_EC_KEY_new
		mov	esi, eax
		test	esi, esi
		jz	short loc_382
		push	[esp+4+arg_0]
		push	esi
		call	_EC_KEY_copy
		add	esp, 8
		test	eax, eax
		jnz	short loc_386
		push	esi
		call	_EC_KEY_free
		add	esp, 4

loc_382:				; CODE XREF: _EC_KEY_dup+Aj
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_386:				; CODE XREF: _EC_KEY_dup+1Bj
		mov	eax, esi
		pop	esi
		retn
_EC_KEY_dup	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 38Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_free
_EC_KEY_free	proc near		; CODE XREF: _EC_KEY_dup+1Ep
					; _EC_KEY_new_by_curve_name+20p

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	short loc_3FA
		push	71h ; 'q'
		push	offset ??_C@_0BF@PJJIPJIB@?4?2crypto?2ec?2ec_key?4c?$AA@ ; ".\\crypto\\ec\\ec_key.c"
		push	21h ; '!'
		lea	eax, [esi+18h]
		push	0FFFFFFFFh
		push	eax
		call	_CRYPTO_add_lock
		add	esp, 14h
		test	eax, eax
		jg	short loc_3FA
		mov	eax, [esi+4]
		test	eax, eax
		jz	short loc_3C0
		push	eax
		call	_EC_GROUP_free
		add	esp, 4

loc_3C0:				; CODE XREF: _EC_KEY_free+29j
		mov	eax, [esi+8]
		test	eax, eax
		jz	short loc_3D0
		push	eax
		call	_EC_POINT_free
		add	esp, 4

loc_3D0:				; CODE XREF: _EC_KEY_free+39j
		mov	eax, [esi+0Ch]
		test	eax, eax
		jz	short loc_3E0
		push	eax
		call	_BN_clear_free
		add	esp, 4

loc_3E0:				; CODE XREF: _EC_KEY_free+49j
		lea	eax, [esi+20h]
		push	eax
		call	_EC_EX_DATA_free_all_data
		push	24h ; '$'
		push	esi
		call	_OPENSSL_cleanse
		push	esi
		call	_CRYPTO_free
		add	esp, 10h

loc_3FA:				; CODE XREF: _EC_KEY_free+7j
					; _EC_KEY_free+22j
		pop	esi
		retn
_EC_KEY_free	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3FCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_generate_key
_EC_KEY_generate_key proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 4
		call	__chkstk
		push	ebx
		push	esi
		push	edi
		mov	edi, [esp+10h+arg_0]
		xor	esi, esi
		xor	ebx, ebx
		mov	[esp+10h+var_4], 0
		test	edi, edi
		jz	loc_50A
		cmp	[edi+4], ebx
		jz	loc_50A
		push	ebp
		call	_BN_new
		mov	ebp, eax
		test	ebp, ebp
		jz	loc_500
		call	_BN_CTX_new
		mov	[esp+14h+arg_0], eax
		test	eax, eax
		jz	short $err$29
		mov	esi, [edi+0Ch]
		test	esi, esi
		jnz	short loc_45D
		call	_BN_new
		mov	esi, eax
		test	esi, esi
		jz	short $err$29
		mov	eax, [esp+14h+arg_0]

loc_45D:				; CODE XREF: _EC_KEY_generate_key+50j
		push	eax
		push	ebp
		push	dword ptr [edi+4]
		call	_EC_GROUP_get_order
		add	esp, 0Ch
		test	eax, eax
		jz	short $err$29

loc_46E:				; CODE XREF: _EC_KEY_generate_key+83j
		push	ebp
		push	esi
		call	_BN_rand_range
		add	esp, 8
		test	eax, eax
		jz	short $err$29
		cmp	[esi+4], ebx
		jz	short loc_46E
		mov	ebx, [edi+8]
		test	ebx, ebx
		jnz	short loc_499
		push	dword ptr [edi+4]
		call	_EC_POINT_new
		mov	ebx, eax
		add	esp, 4
		test	ebx, ebx
		jz	short $err$29

loc_499:				; CODE XREF: _EC_KEY_generate_key+8Aj
		push	[esp+14h+arg_0]
		push	0
		push	0
		push	esi
		push	ebx
		push	dword ptr [edi+4]
		call	_EC_POINT_mul
		add	esp, 18h
		test	eax, eax
		jz	short $err$29
		mov	[edi+0Ch], esi
		mov	[edi+8], ebx
		mov	[esp+14h+var_4], 1

$err$29:				; CODE XREF: _EC_KEY_generate_key+49j
					; _EC_KEY_generate_key+5Bj ...
		push	ebp
		call	_BN_free
		add	esp, 4
		test	ebx, ebx
		jz	short loc_4DC
		cmp	dword ptr [edi+8], 0
		jnz	short loc_4DC
		push	ebx
		call	_EC_POINT_free
		add	esp, 4

loc_4DC:				; CODE XREF: _EC_KEY_generate_key+CFj
					; _EC_KEY_generate_key+D5j
		test	esi, esi
		jz	short loc_4EF
		cmp	dword ptr [edi+0Ch], 0
		jnz	short loc_4EF
		push	esi
		call	_BN_free
		add	esp, 4

loc_4EF:				; CODE XREF: _EC_KEY_generate_key+E2j
					; _EC_KEY_generate_key+E8j
		mov	eax, [esp+14h+arg_0]
		test	eax, eax
		jz	short loc_500
		push	eax
		call	_BN_CTX_free
		add	esp, 4

loc_500:				; CODE XREF: _EC_KEY_generate_key+38j
					; _EC_KEY_generate_key+F9j
		mov	eax, [esp+14h+var_4]
		pop	ebp
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_50A:				; CODE XREF: _EC_KEY_generate_key+1Fj
					; _EC_KEY_generate_key+28j
		push	0F3h ; 'ó'
		push	offset ??_C@_0BF@PJJIPJIB@?4?2crypto?2ec?2ec_key?4c?$AA@ ; ".\\crypto\\ec\\ec_key.c"
		push	43h ; 'C'
		push	0B3h ; '³'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
_EC_KEY_generate_key endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 52Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_get0_group
_EC_KEY_get0_group proc	near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+4]
		retn
_EC_KEY_get0_group endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 534h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_get0_private_key
_EC_KEY_get0_private_key proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+0Ch]
		retn
_EC_KEY_get0_private_key endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 53Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_get0_public_key
_EC_KEY_get0_public_key	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+8]
		retn
_EC_KEY_get0_public_key	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 544h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_get_conv_form
_EC_KEY_get_conv_form proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+14h]
		retn
_EC_KEY_get_conv_form endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 54Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_get_enc_flags
_EC_KEY_get_enc_flags proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+10h]
		retn
_EC_KEY_get_enc_flags endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 554h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_get_flags
_EC_KEY_get_flags proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+1Ch]
		retn
_EC_KEY_get_flags endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 55Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_get_key_method_data
_EC_KEY_get_key_method_data proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	esi
		push	1FFh
		push	offset ??_C@_0BF@PJJIPJIB@?4?2crypto?2ec?2ec_key?4c?$AA@ ; ".\\crypto\\ec\\ec_key.c"
		push	21h ; '!'
		push	5
		call	_CRYPTO_lock
		push	[esp+14h+arg_C]
		mov	eax, [esp+18h+arg_0]
		push	[esp+18h+arg_8]
		push	[esp+1Ch+arg_4]
		push	dword ptr [eax+20h]
		call	_EC_EX_DATA_get_data
		push	203h
		push	offset ??_C@_0BF@PJJIPJIB@?4?2crypto?2ec?2ec_key?4c?$AA@ ; ".\\crypto\\ec\\ec_key.c"
		push	21h ; '!'
		push	6
		mov	esi, eax
		call	_CRYPTO_lock
		add	esp, 30h
		mov	eax, esi
		pop	esi
		retn
_EC_KEY_get_key_method_data endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5A4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_insert_key_method_data
_EC_KEY_insert_key_method_data proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		push	esi
		push	edi
		push	20Fh
		push	offset ??_C@_0BF@PJJIPJIB@?4?2crypto?2ec?2ec_key?4c?$AA@ ; ".\\crypto\\ec\\ec_key.c"
		push	21h ; '!'
		push	9
		call	_CRYPTO_lock
		push	[esp+18h+arg_10]
		mov	edi, [esp+1Ch+arg_0]
		push	[esp+1Ch+arg_C]
		add	edi, 20h ; ' '
		push	[esp+20h+arg_8]
		push	dword ptr [edi]
		call	_EC_EX_DATA_get_data
		mov	esi, eax
		add	esp, 20h
		test	esi, esi
		jnz	short loc_5F5
		push	[esp+8+arg_10]
		push	[esp+0Ch+arg_C]
		push	[esp+10h+arg_8]
		push	[esp+14h+arg_4]
		push	edi
		call	_EC_EX_DATA_set_data
		add	esp, 14h

loc_5F5:				; CODE XREF: _EC_KEY_insert_key_method_data+36j
		push	216h
		push	offset ??_C@_0BF@PJJIPJIB@?4?2crypto?2ec?2ec_key?4c?$AA@ ; ".\\crypto\\ec\\ec_key.c"
		push	21h ; '!'
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h
		mov	eax, esi
		pop	edi
		pop	esi
		retn
_EC_KEY_insert_key_method_data endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 610h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_new
_EC_KEY_new	proc near		; CODE XREF: _EC_KEY_dup+1p
					; _EC_KEY_new_by_curve_name+1p
		push	4Bh ; 'K'
		push	offset ??_C@_0BF@PJJIPJIB@?4?2crypto?2ec?2ec_key?4c?$AA@ ; ".\\crypto\\ec\\ec_key.c"
		push	24h ; '$'
		call	_CRYPTO_malloc
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_640
		push	4Dh ; 'M'
		push	offset ??_C@_0BF@PJJIPJIB@?4?2crypto?2ec?2ec_key?4c?$AA@ ; ".\\crypto\\ec\\ec_key.c"
		push	41h ; 'A'
		push	0B6h ; '¶'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_640:				; CODE XREF: _EC_KEY_new+13j
		mov	dword ptr [eax], 1
		mov	dword ptr [eax+1Ch], 0
		mov	dword ptr [eax+4], 0
		mov	dword ptr [eax+8], 0
		mov	dword ptr [eax+0Ch], 0
		mov	dword ptr [eax+10h], 0
		mov	dword ptr [eax+14h], 4
		mov	dword ptr [eax+18h], 1
		mov	dword ptr [eax+20h], 0
		retn
_EC_KEY_new	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 680h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_new_by_curve_name
_EC_KEY_new_by_curve_name proc near

arg_0		= dword	ptr  4

		push	esi
		call	_EC_KEY_new
		mov	esi, eax
		test	esi, esi
		jz	short loc_6A8
		push	[esp+4+arg_0]
		call	_EC_GROUP_new_by_curve_name
		add	esp, 4
		mov	[esi+4], eax
		test	eax, eax
		jnz	short loc_6AC
		push	esi
		call	_EC_KEY_free
		add	esp, 4

loc_6A8:				; CODE XREF: _EC_KEY_new_by_curve_name+Aj
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_6AC:				; CODE XREF: _EC_KEY_new_by_curve_name+1Dj
		mov	eax, esi
		pop	esi
		retn
_EC_KEY_new_by_curve_name endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6B0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_precompute_mult
_EC_KEY_precompute_mult	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+4]
		test	eax, eax
		jnz	short loc_6BC
		retn
; ---------------------------------------------------------------------------

loc_6BC:				; CODE XREF: _EC_KEY_precompute_mult+9j
		mov	[esp+arg_0], eax
		jmp	_EC_GROUP_precompute_mult
_EC_KEY_precompute_mult	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6C8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_set_asn1_flag
_EC_KEY_set_asn1_flag proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+4]
		test	eax, eax
		jz	short locret_6DC
		mov	[esp+arg_0], eax
		jmp	_EC_GROUP_set_asn1_flag
; ---------------------------------------------------------------------------

locret_6DC:				; CODE XREF: _EC_KEY_set_asn1_flag+9j
		retn
_EC_KEY_set_asn1_flag endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6E0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_set_conv_form
_EC_KEY_set_conv_form proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+14h], ecx
		mov	eax, [eax+4]
		test	eax, eax
		jz	short locret_6FF
		mov	[esp+arg_4], ecx
		mov	[esp+arg_0], eax
		jmp	_EC_GROUP_set_point_conversion_form
; ---------------------------------------------------------------------------

locret_6FF:				; CODE XREF: _EC_KEY_set_conv_form+10j
		retn
_EC_KEY_set_conv_form endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 700h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_set_enc_flags
_EC_KEY_set_enc_flags proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	[eax+10h], ecx
		retn
_EC_KEY_set_enc_flags endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 70Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_set_flags
_EC_KEY_set_flags proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		mov	eax, [esp+arg_4]
		or	[ecx+1Ch], eax
		retn
_EC_KEY_set_flags endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 718h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_set_group
_EC_KEY_set_group proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, [esi+4]
		test	eax, eax
		jz	short loc_72D
		push	eax
		call	_EC_GROUP_free
		add	esp, 4

loc_72D:				; CODE XREF: _EC_KEY_set_group+Aj
		push	[esp+4+arg_4]
		call	_EC_GROUP_dup
		xor	ecx, ecx
		mov	[esi+4], eax
		add	esp, 4
		test	eax, eax
		setnz	cl
		mov	eax, ecx
		pop	esi
		retn
_EC_KEY_set_group endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 748h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_set_private_key
_EC_KEY_set_private_key	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, [esi+0Ch]
		test	eax, eax
		jz	short loc_75D
		push	eax
		call	_BN_clear_free
		add	esp, 4

loc_75D:				; CODE XREF: _EC_KEY_set_private_key+Aj
		push	[esp+4+arg_4]
		call	_BN_dup
		xor	ecx, ecx
		mov	[esi+0Ch], eax
		add	esp, 4
		test	eax, eax
		setnz	cl
		mov	eax, ecx
		pop	esi
		retn
_EC_KEY_set_private_key	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 778h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_set_public_key
_EC_KEY_set_public_key proc near	; CODE XREF: _EC_KEY_set_public_key_affine_coordinates+11Dp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, [esi+8]
		test	eax, eax
		jz	short loc_78D
		push	eax
		call	_EC_POINT_free
		add	esp, 4

loc_78D:				; CODE XREF: _EC_KEY_set_public_key+Aj
		push	dword ptr [esi+4]
		push	[esp+8+arg_4]
		call	_EC_POINT_dup
		xor	ecx, ecx
		mov	[esi+8], eax
		add	esp, 8
		test	eax, eax
		setnz	cl
		mov	eax, ecx
		pop	esi
		retn
_EC_KEY_set_public_key endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7ACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_set_public_key_affine_coordinates
_EC_KEY_set_public_key_affine_coordinates proc near

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 8
		call	__chkstk
		push	ebp
		push	esi
		mov	esi, [esp+10h+arg_0]
		mov	[esp+10h+var_4], 0
		test	esi, esi
		jz	loc_92C
		cmp	dword ptr [esi+4], 0
		jz	loc_92C
		mov	ebp, [esp+10h+arg_4]
		test	ebp, ebp
		jz	loc_92C
		cmp	[esp+10h+arg_8], 0
		jz	loc_92C
		push	ebx
		call	_BN_CTX_new
		mov	ebx, eax
		test	ebx, ebx
		jz	loc_921
		push	edi
		push	dword ptr [esi+4]
		call	_EC_POINT_new
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jz	$err$26
		push	ebx
		call	_BN_CTX_get
		push	ebx
		mov	[esp+20h+arg_0], eax
		call	_BN_CTX_get
		add	esp, 8
		mov	[esp+18h+var_8], eax
		test	eax, eax
		jz	$err$26
		push	dword ptr [esi+4]
		call	_EC_GROUP_method_of
		push	eax
		call	_EC_METHOD_get_field_type
		add	esp, 8
		cmp	eax, 197h
		mov	eax, [esp+18h+arg_8]
		push	ebx
		push	eax
		push	ebp
		push	edi
		push	dword ptr [esi+4]
		jnz	short loc_879
		call	_EC_POINT_set_affine_coordinates_GF2m
		add	esp, 14h
		test	eax, eax
		jz	$err$26
		push	ebx
		push	[esp+1Ch+var_8]
		push	[esp+20h+arg_0]
		push	edi
		push	dword ptr [esi+4]
		call	_EC_POINT_get_affine_coordinates_GF2m
		jmp	short loc_89B
; ---------------------------------------------------------------------------

loc_879:				; CODE XREF: _EC_KEY_set_public_key_affine_coordinates+A7j
		call	_EC_POINT_set_affine_coordinates_GFp
		add	esp, 14h
		test	eax, eax
		jz	$err$26
		push	ebx
		push	[esp+1Ch+var_8]
		push	[esp+20h+arg_0]
		push	edi
		push	dword ptr [esi+4]
		call	_EC_POINT_get_affine_coordinates_GFp

loc_89B:				; CODE XREF: _EC_KEY_set_public_key_affine_coordinates+CBj
		add	esp, 14h
		test	eax, eax
		jz	short $err$26
		push	[esp+18h+arg_0]
		push	ebp
		call	_BN_cmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_8EC
		push	[esp+18h+var_8]
		push	[esp+1Ch+arg_8]
		call	_BN_cmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_8EC
		push	edi
		push	esi
		call	_EC_KEY_set_public_key
		add	esp, 8
		test	eax, eax
		jz	short $err$26
		push	esi
		call	_EC_KEY_check_key
		add	esp, 4
		test	eax, eax
		jz	short $err$26
		mov	[esp+18h+var_4], 1
		jmp	short $err$26
; ---------------------------------------------------------------------------

loc_8EC:				; CODE XREF: _EC_KEY_set_public_key_affine_coordinates+105j
					; _EC_KEY_set_public_key_affine_coordinates+119j
		push	1A6h
		push	offset ??_C@_0BF@PJJIPJIB@?4?2crypto?2ec?2ec_key?4c?$AA@ ; ".\\crypto\\ec\\ec_key.c"
		push	92h ; '’'
		push	0E5h ; 'å'
		push	10h
		call	_ERR_put_error
		add	esp, 14h

$err$26:				; CODE XREF: _EC_KEY_set_public_key_affine_coordinates+61j
					; _EC_KEY_set_public_key_affine_coordinates+80j ...
		push	ebx
		call	_BN_CTX_free
		add	esp, 4
		test	edi, edi
		jz	short loc_920
		push	edi
		call	_EC_POINT_free
		add	esp, 4

loc_920:				; CODE XREF: _EC_KEY_set_public_key_affine_coordinates+169j
		pop	edi

loc_921:				; CODE XREF: _EC_KEY_set_public_key_affine_coordinates+4Bj
		mov	eax, [esp+14h+var_4]
		pop	ebx
		pop	esi
		pop	ebp
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_92C:				; CODE XREF: _EC_KEY_set_public_key_affine_coordinates+1Aj
					; _EC_KEY_set_public_key_affine_coordinates+24j ...
		push	178h
		push	offset ??_C@_0BF@PJJIPJIB@?4?2crypto?2ec?2ec_key?4c?$AA@ ; ".\\crypto\\ec\\ec_key.c"
		push	43h ; 'C'
		push	0E5h ; 'å'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		pop	ebp
		add	esp, 8
		retn
_EC_KEY_set_public_key_affine_coordinates endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 950h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_KEY_up_ref
_EC_KEY_up_ref	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		push	0D9h ; 'Ù'
		push	offset ??_C@_0BF@PJJIPJIB@?4?2crypto?2ec?2ec_key?4c?$AA@ ; ".\\crypto\\ec\\ec_key.c"
		push	21h ; '!'
		add	eax, 18h
		push	1
		push	eax
		call	_CRYPTO_add_lock
		xor	ecx, ecx
		add	esp, 14h
		cmp	eax, 1
		setnle	cl
		mov	eax, ecx
		retn
_EC_KEY_up_ref	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 97Ch
; COMDAT (pick any)
		public ??_C@_0BF@PJJIPJIB@?4?2crypto?2ec?2ec_key?4c?$AA@
; `string'
??_C@_0BF@PJJIPJIB@?4?2crypto?2ec?2ec_key?4c?$AA@ db '.\crypto\ec\ec_key.c',0
					; DATA XREF: _EC_KEY_check_key+39o
					; _EC_KEY_check_key+92o ...
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _CRYPTO_lock:near	; CODE XREF: _EC_KEY_get_key_method_data+Fp
					; _EC_KEY_get_key_method_data+3Cp ...
		extrn _CRYPTO_add_lock:near ; CODE XREF: _EC_KEY_free+18p
					; _EC_KEY_up_ref+16p
		extrn _CRYPTO_malloc:near ; CODE XREF: _EC_KEY_new+9p
		extrn _CRYPTO_free:near	; CODE XREF: _EC_KEY_free+66p
		extrn _OPENSSL_cleanse:near ; CODE XREF: _EC_KEY_free+60p
		extrn _BN_CTX_new:near	; CODE XREF: _EC_KEY_check_key+55p
					; _EC_KEY_generate_key+3Ep ...
		extrn _BN_CTX_free:near	; CODE XREF: _EC_KEY_check_key+1BDp
					; _EC_KEY_generate_key+FCp ...
		extrn _BN_CTX_get:near	; CODE XREF: _EC_KEY_set_public_key_affine_coordinates+68p
					; _EC_KEY_set_public_key_affine_coordinates+72p
		extrn _BN_rand_range:near ; CODE XREF: _EC_KEY_generate_key+74p
		extrn _BN_new:near	; CODE XREF: _EC_KEY_copy+A7p
					; _EC_KEY_generate_key+2Fp ...
		extrn _BN_clear_free:near ; CODE XREF: _EC_KEY_free+4Cp
					; _EC_KEY_set_private_key+Dp
		extrn _BN_copy:near	; CODE XREF: _EC_KEY_copy+B9p
		extrn _BN_cmp:near	; CODE XREF: _EC_KEY_check_key+151p
					; _EC_KEY_set_public_key_affine_coordinates+FBp ...
		extrn _BN_free:near	; CODE XREF: _EC_KEY_generate_key+C5p
					; _EC_KEY_generate_key+EBp
		extrn _BN_dup:near	; CODE XREF: _EC_KEY_set_private_key+19p
		extrn _EC_GROUP_new:near ; CODE	XREF: _EC_KEY_copy+3Ep
		extrn _EC_GROUP_free:near ; CODE XREF: _EC_KEY_copy+35p
					; _EC_KEY_free+2Cp ...
		extrn _EC_GROUP_copy:near ; CODE XREF: _EC_KEY_copy+51p
		extrn _EC_GROUP_dup:near ; CODE	XREF: _EC_KEY_set_group+19p
		extrn _EC_GROUP_method_of:near ; CODE XREF: _EC_KEY_copy+23p
					; _EC_KEY_set_public_key_affine_coordinates+89p
		extrn _EC_METHOD_get_field_type:near
					; CODE XREF: _EC_KEY_set_public_key_affine_coordinates+8Fp
		extrn _EC_GROUP_get_order:near ; CODE XREF: _EC_KEY_generate_key+66p
		extrn _EC_GROUP_set_asn1_flag:near ; CODE XREF:	_EC_KEY_set_asn1_flag+Fj
		extrn _EC_GROUP_set_point_conversion_form:near
					; CODE XREF: _EC_KEY_set_conv_form+1Aj
		extrn _EC_GROUP_new_by_curve_name:near
					; CODE XREF: _EC_KEY_new_by_curve_name+10p
		extrn _EC_POINT_new:near ; CODE	XREF: _EC_KEY_check_key+68p
					; _EC_KEY_copy+7Cp ...
		extrn _EC_POINT_free:near ; CODE XREF: _EC_KEY_check_key+1CAp
					; _EC_KEY_copy+71p ...
		extrn _EC_POINT_copy:near ; CODE XREF: _EC_KEY_copy+8Fp
		extrn _EC_POINT_dup:near ; CODE	XREF: _EC_KEY_set_public_key+1Cp
		extrn _EC_POINT_set_affine_coordinates_GFp:near
					; CODE XREF: _EC_KEY_set_public_key_affine_coordinates:loc_879p
		extrn _EC_POINT_get_affine_coordinates_GFp:near
					; CODE XREF: _EC_KEY_set_public_key_affine_coordinates+EAp
		extrn _EC_POINT_set_affine_coordinates_GF2m:near
					; CODE XREF: _EC_KEY_set_public_key_affine_coordinates+A9p
		extrn _EC_POINT_get_affine_coordinates_GF2m:near
					; CODE XREF: _EC_KEY_set_public_key_affine_coordinates+C6p
		extrn _EC_POINT_is_at_infinity:near ; CODE XREF: _EC_KEY_check_key+28p
					; _EC_KEY_check_key+115p
		extrn _EC_POINT_is_on_curve:near ; CODE	XREF: _EC_KEY_check_key+81p
		extrn _EC_POINT_cmp:near ; CODE	XREF: _EC_KEY_check_key+18Ep
		extrn _EC_POINT_mul:near ; CODE	XREF: _EC_KEY_check_key+E5p
					; _EC_KEY_check_key+170p ...
		extrn _EC_GROUP_precompute_mult:near
					; CODE XREF: _EC_KEY_precompute_mult+10j
		extrn _EC_EX_DATA_set_data:near	; CODE XREF: _EC_KEY_copy+FAp
					; _EC_KEY_insert_key_method_data+49p
		extrn _EC_EX_DATA_get_data:near	; CODE XREF: _EC_KEY_get_key_method_data+27p
					; _EC_KEY_insert_key_method_data+2Ap
		extrn _EC_EX_DATA_free_all_data:near ; CODE XREF: _EC_KEY_copy+D0p
					; _EC_KEY_free+58p
		extrn _ERR_put_error:near ; CODE XREF: _EC_KEY_check_key+47p
					; _EC_KEY_check_key+A0p ...
		extrn __chkstk:near	; CODE XREF: _EC_KEY_generate_key+5p
					; _EC_KEY_set_public_key_affine_coordinates+5p


		end
