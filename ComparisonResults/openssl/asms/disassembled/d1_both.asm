;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	E248F2330097D6F17FBB3FA2484C008A
; Input	CRC32 :	3083FD68

; File Name   :	C:\compspace\Diff\openssl\obj\d1_both.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
_bitmask_start_values db 0FFh		; DATA XREF: _dtls1_reassemble_fragment+1CFr
		db 0FEh, 0FCh, 0F8h
		dd 80C0E0F0h
_bitmask_end_values db 0FFh		; DATA XREF: _dtls1_reassemble_fragment+216r
					; _dtls1_reassemble_fragment+24Dr
		db 1, 3, 7
		dd 7F3F1F0Fh
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
_g_probable_mtu	dd offset loc_5DB+1
		dd offset loc_1FD+3
		dd offset loc_FF+1
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public ___local_stdio_printf_options
___local_stdio_printf_options proc near	; CODE XREF: __vfprintf_l+10p
					; _fprintf+Fp
		mov	eax, offset ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
		retn
___local_stdio_printf_options endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 24h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl _vfprintf_l(FILE *File, const char *Format, _locale_t Locale, va_list ArgList)
		public __vfprintf_l
__vfprintf_l	proc near

File		= dword	ptr  4
Format		= dword	ptr  8
Locale		= dword	ptr  0Ch
ArgList		= dword	ptr  10h

		push	[esp+ArgList]
		push	[esp+4+Locale]
		push	[esp+8+Format]
		push	[esp+0Ch+File]
		call	___local_stdio_printf_options
		push	dword ptr [eax+4]
		push	dword ptr [eax]
		call	dword ptr ds:__imp____stdio_common_vfprintf
		add	esp, 18h
		retn
__vfprintf_l	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 48h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_buffer_message
_dtls1_buffer_message proc near		; CODE XREF: _dtls1_send_change_cipher_spec+A3p

var_C		= qword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 0Ch
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+0Ch+var_4], eax
		push	ebx
		push	ebp
		push	esi
		mov	esi, [esp+18h+arg_0]
		push	edi
		cmp	dword ptr [esi+48h], 0
		jz	short loc_82
		push	offset ??_C@_0BB@JNHBKAGH@s?9?$DOinit_off?5?$DN?$DN?50?$AA@ ; "s->init_off == 0"
		push	47Ah
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_82:					; CODE XREF: _dtls1_buffer_message+21j
		mov	ebp, [esi+44h]
		xor	ebx, ebx
		push	0B5h ; 'µ'
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		push	34h ; '4'
		call	_CRYPTO_malloc
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jz	short loc_C7
		test	ebp, ebp
		jz	short loc_DC
		push	0BAh ; 'º'
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		push	ebp
		call	_CRYPTO_malloc
		mov	ebx, eax
		add	esp, 0Ch
		test	ebx, ebx
		jnz	short loc_DC
		push	edi
		call	_CRYPTO_free

loc_C4:					; CODE XREF: _dtls1_buffer_message:loc_1FDj
		add	esp, 4

loc_C7:					; CODE XREF: _dtls1_buffer_message+57j
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		mov	ecx, [esp+0Ch+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_DC:					; CODE XREF: _dtls1_buffer_message+5Bj
					; _dtls1_buffer_message+74j
		mov	[edi+2Ch], ebx
		mov	dword ptr [edi+30h], 0
		mov	eax, [esi+3Ch]
		push	dword ptr [esi+44h] ; Size
		push	dword ptr [eax+4] ; Src
		push	ebx		; Dst
		call	_memcpy
		mov	ebx, [esp+28h+arg_4]
		add	esp, 0Ch
		mov	eax, [esi+5Ch]

loc_FF:					; DATA XREF: .rdata:00000018o
		test	ebx, ebx
		jz	short loc_12C
		xor	ecx, ecx
		cmp	dword ptr [esi], 100h
		setz	cl
		lea	ecx, ds:1[ecx*2]
		add	ecx, [eax+264h]
		cmp	ecx, [esi+44h]
		jz	short loc_151
		push	offset ??_C@_0HA@GEKIBMBM@s?9?$DOd1?9?$DOw_msg_hdr?4msg_len?5?$CL?5?$CI?$CIs?9?$DO@ ; "s->d1->w_msg_hdr.msg_len	+ ((s->version"...
		push	486h
		jmp	short loc_144
; ---------------------------------------------------------------------------

loc_12C:				; CODE XREF: _dtls1_buffer_message+B9j
		mov	eax, [eax+264h]
		add	eax, 0Ch
		cmp	eax, [esi+44h]
		jz	short loc_151
		push	offset ??_C@_0EP@GFDKHMFP@s?9?$DOd1?9?$DOw_msg_hdr?4msg_len?5?$CL?5DTLS1@ ; "s->d1->w_msg_hdr.msg_len +	DTLS1_HM_HEA"...
		push	489h

loc_144:				; CODE XREF: _dtls1_buffer_message+E2j
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_151:				; CODE XREF: _dtls1_buffer_message+D6j
					; _dtls1_buffer_message+F0j
		mov	eax, [esi+5Ch]
		xorps	xmm0, xmm0
		push	edi
		mov	eax, [eax+264h]
		mov	[edi+4], eax
		mov	eax, [esi+5Ch]
		movzx	eax, word ptr [eax+268h]
		mov	[edi+8], ax
		mov	eax, [esi+5Ch]
		movzx	eax, byte ptr [eax+260h]
		mov	[edi], al
		mov	dword ptr [edi+0Ch], 0
		mov	eax, [esi+5Ch]
		mov	eax, [eax+264h]
		mov	[edi+10h], eax
		mov	[edi+14h], ebx
		mov	eax, [esi+8Ch]
		mov	[edi+18h], eax
		mov	eax, [esi+90h]
		mov	[edi+1Ch], eax
		mov	eax, [esi+94h]
		mov	[edi+20h], eax
		mov	eax, [esi+0C0h]
		mov	[edi+24h], eax
		mov	eax, [esi+5Ch]
		movzx	eax, word ptr [eax+20Ah]
		mov	[edi+28h], ax
		movq	[esp+20h+var_C], xmm0
		movzx	eax, word ptr [edi+8]
		add	eax, eax
		sub	eax, [edi+14h]
		sar	eax, 8
		mov	byte ptr [esp+20h+var_C+6], al
		movzx	eax, byte ptr [edi+8]
		add	al, al
		sub	al, [edi+14h]
		mov	byte ptr [esp+20h+var_C+7], al
		lea	eax, [esp+20h+var_C]
		push	eax
		call	_pitem_new
		add	esp, 8
		test	eax, eax
		jnz	short loc_202
		push	edi
		call	_dtls1_hm_fragment_free

loc_1FD:				; DATA XREF: .rdata:00000014o
		jmp	loc_C4
; ---------------------------------------------------------------------------

loc_202:				; CODE XREF: _dtls1_buffer_message+1ADj
		push	eax
		mov	eax, [esi+5Ch]
		push	dword ptr [eax+248h]
		call	_pqueue_insert
		mov	ecx, [esp+24h+var_4]
		add	esp, 8
		mov	eax, 1
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 0Ch
		retn
_dtls1_buffer_message endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 22Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_clear_record_buffer
_dtls1_clear_record_buffer proc	near

arg_0		= dword	ptr  4

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	edi
		mov	eax, [ebx+5Ch]
		push	dword ptr [eax+248h]
		call	_pqueue_pop
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jz	short loc_2AC
		push	esi
		xchg	ax, ax

loc_24C:				; CODE XREF: _dtls1_clear_record_buffer+7Dj
		mov	esi, [edi+8]
		cmp	dword ptr [esi+14h], 0
		jz	short loc_268
		push	dword ptr [esi+18h]
		call	_EVP_CIPHER_CTX_free
		push	dword ptr [esi+1Ch]
		call	_EVP_MD_CTX_destroy
		add	esp, 8

loc_268:				; CODE XREF: _dtls1_clear_record_buffer+27j
		mov	eax, [esi+2Ch]
		test	eax, eax
		jz	short loc_278
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_278:				; CODE XREF: _dtls1_clear_record_buffer+41j
		mov	eax, [esi+30h]
		test	eax, eax
		jz	short loc_288
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_288:				; CODE XREF: _dtls1_clear_record_buffer+51j
		push	esi
		call	_CRYPTO_free
		push	edi
		call	_pitem_free
		mov	eax, [ebx+5Ch]
		push	dword ptr [eax+248h]
		call	_pqueue_pop
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jnz	short loc_24C
		pop	esi

loc_2AC:				; CODE XREF: _dtls1_clear_record_buffer+1Bj
		pop	edi
		pop	ebx
		retn
_dtls1_clear_record_buffer endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2B0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_do_write
_dtls1_do_write	proc near		; CODE XREF: _dtls1_retransmit_buffered_messages+1E4p
					; _dtls1_retransmit_message+1B7p ...

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 0Ch
		call	__chkstk
		push	esi
		mov	esi, [esp+10h+arg_0]
		push	esi
		mov	[esp+14h+var_8], 1
		call	_dtls1_query_mtu
		add	esp, 4
		test	eax, eax
		jnz	short loc_2DC
		or	eax, 0FFFFFFFFh
		pop	esi
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_2DC:				; CODE XREF: _dtls1_do_write+22j
		push	0
		push	0
		push	31h ; '1'
		push	esi
		call	_SSL_get_wbio
		add	esp, 4
		push	eax
		call	_BIO_ctrl
		mov	ecx, 100h
		add	esp, 10h
		sub	ecx, eax
		mov	eax, [esi+5Ch]
		cmp	[eax+25Ch], ecx
		jnb	short loc_31D
		push	offset ??_C@_0BP@ICKAAGNH@s?9?$DOd1?9?$DOmtu?5?$DO?$DN?5dtls1_min_mtu?$CIs?$CJ?$AA@ ; "s->d1->mtu >= dtls1_min_mtu(s)"
		push	112h
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_31D:				; CODE XREF: _dtls1_do_write+54j
		cmp	dword ptr [esi+48h], 0
		push	ebx
		mov	ebx, [esp+14h+arg_4]
		jnz	short loc_355
		cmp	ebx, 16h
		jnz	short loc_355
		mov	eax, [esi+5Ch]
		mov	eax, [eax+264h]
		add	eax, 0Ch
		cmp	[esi+44h], eax
		jz	short loc_355
		push	offset ??_C@_0EG@CCIHJLOA@s?9?$DOinit_num?5?$DN?$DN?5?$CIint?$CJs?9?$DOd1?9?$DOw_msg@ ;	"s->init_num ==	(int)s->d1->w_msg_hdr.ms"...
		push	118h
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_355:				; CODE XREF: _dtls1_do_write+76j
					; _dtls1_do_write+7Bj ...
		cmp	dword ptr [esi+90h], 0
		jz	short loc_395
		mov	eax, [esi+8Ch]
		test	eax, eax
		jz	short loc_37B
		push	eax
		call	_EVP_CIPHER_CTX_flags
		and	eax, 0F0007h
		add	esp, 4
		cmp	eax, 6
		jz	short loc_395

loc_37B:				; CODE XREF: _dtls1_do_write+B6j
		push	dword ptr [esi+90h]
		call	_EVP_MD_CTX_md
		push	eax
		call	_EVP_MD_size
		add	esp, 8
		mov	[esp+14h+var_C], eax
		jmp	short loc_39D
; ---------------------------------------------------------------------------

loc_395:				; CODE XREF: _dtls1_do_write+ACj
					; _dtls1_do_write+C9j
		mov	[esp+14h+var_C], 0

loc_39D:				; CODE XREF: _dtls1_do_write+E3j
		mov	eax, [esi+8Ch]
		push	edi
		test	eax, eax
		jz	short loc_3D1
		push	eax
		call	_EVP_CIPHER_CTX_flags
		and	eax, 0F0007h
		add	esp, 4
		cmp	eax, 2
		jnz	short loc_3D1
		mov	eax, [esi+8Ch]
		push	dword ptr [eax]
		call	_EVP_CIPHER_block_size
		mov	edi, eax
		add	esp, 4
		add	edi, edi
		jmp	short loc_3D3
; ---------------------------------------------------------------------------

loc_3D1:				; CODE XREF: _dtls1_do_write+F6j
					; _dtls1_do_write+109j
		xor	edi, edi

loc_3D3:				; CODE XREF: _dtls1_do_write+11Fj
		push	ebp
		xor	ebp, ebp
		mov	[esp+1Ch+var_4], edi
		mov	dword ptr [esi+18h], 1
		cmp	[esi+44h], ebp
		jle	loc_6FA
		nop	word ptr [eax+eax+00h]

loc_3F0:				; CODE XREF: _dtls1_do_write+3F1j
		cmp	ebx, 16h
		jnz	short loc_41E
		mov	eax, [esi+48h]
		test	eax, eax
		jz	short loc_41E
		test	ebp, ebp
		jz	short loc_415
		cmp	eax, 0Ch
		jle	loc_6E0
		add	eax, 0FFFFFFF4h
		add	dword ptr [esi+44h], 0Ch
		mov	[esi+48h], eax
		jmp	short loc_41E
; ---------------------------------------------------------------------------

loc_415:				; CODE XREF: _dtls1_do_write+14Ej
		mov	eax, [esi+5Ch]
		mov	ebp, [eax+26Ch]

loc_41E:				; CODE XREF: _dtls1_do_write+143j
					; _dtls1_do_write+14Aj	...
		push	0
		push	0
		push	0Dh
		push	esi
		call	_SSL_get_wbio
		add	esp, 4
		push	eax
		call	_BIO_ctrl
		mov	ecx, [esp+2Ch+var_C]
		add	eax, edi
		mov	edx, [esi+5Ch]
		add	ecx, 0Dh
		add	eax, ecx
		add	esp, 10h
		mov	ecx, [edx+25Ch]
		cmp	ecx, eax
		jbe	short loc_455
		sub	ecx, eax
		cmp	ecx, 0Ch
		ja	short loc_494

loc_455:				; CODE XREF: _dtls1_do_write+19Cj
		push	0
		push	0
		push	0Bh
		push	esi
		call	_SSL_get_wbio
		add	esp, 4
		push	eax
		call	_BIO_ctrl
		add	esp, 10h
		test	eax, eax
		jle	loc_6EB
		mov	eax, [esp+1Ch+var_C]
		mov	edx, [esi+5Ch]
		add	eax, 0Dh
		add	edi, eax
		mov	ecx, [edx+25Ch]
		lea	eax, [edi+0Ch]
		cmp	ecx, eax
		jbe	loc_6E0
		sub	ecx, edi

loc_494:				; CODE XREF: _dtls1_do_write+1A3j
		mov	edi, [esi+44h]
		mov	eax, 7FFFFFFFh
		cmp	edi, ecx
		cmova	edi, ecx
		cmp	edi, 7FFFFFFFh
		cmova	edi, eax
		cmp	ebx, 16h
		jnz	short loc_52B
		cmp	edi, 0Ch
		jb	loc_6E0
		mov	[edx+26Ch], ebp
		lea	eax, [edi-0Ch]
		mov	[edx+270h], eax
		mov	eax, [esi+3Ch]
		mov	ecx, [esi+5Ch]
		mov	edx, [eax+4]
		add	edx, [esi+48h]
		add	ecx, 260h
		movzx	eax, byte ptr [ecx]
		mov	[edx], al
		movzx	eax, byte ptr [ecx+6]
		mov	[edx+1], al
		movzx	eax, byte ptr [ecx+5]
		mov	[edx+2], al
		movzx	eax, byte ptr [ecx+4]
		mov	[edx+3], al
		movzx	eax, byte ptr [ecx+9]
		mov	[edx+4], al
		movzx	eax, byte ptr [ecx+8]
		mov	[edx+5], al
		movzx	eax, byte ptr [ecx+0Eh]
		mov	[edx+6], al
		movzx	eax, byte ptr [ecx+0Dh]
		mov	[edx+7], al
		movzx	eax, byte ptr [ecx+0Ch]
		mov	[edx+8], al
		movzx	eax, byte ptr [ecx+12h]
		mov	[edx+9], al
		movzx	eax, byte ptr [ecx+11h]
		mov	[edx+0Ah], al
		movzx	eax, byte ptr [ecx+10h]
		mov	[edx+0Bh], al

loc_52B:				; CODE XREF: _dtls1_do_write+1FDj
		mov	eax, [esi+3Ch]
		push	edi
		mov	eax, [eax+4]
		add	eax, [esi+48h]
		push	eax
		push	ebx
		push	esi
		call	_dtls1_write_bytes
		mov	ebx, eax
		add	esp, 10h
		test	ebx, ebx
		jns	short loc_5A9
		cmp	[esp+1Ch+var_8], 0
		jz	loc_6E0
		push	0
		push	0
		push	2Bh ; '+'
		push	esi
		call	_SSL_get_wbio
		add	esp, 4
		push	eax
		call	_BIO_ctrl
		add	esp, 10h
		test	eax, eax
		jle	loc_6E0
		push	0
		push	0
		push	20h ; ' '
		push	esi
		call	_SSL_ctrl
		add	esp, 10h
		test	eax, 1000h
		jnz	loc_6E0
		push	esi
		call	_dtls1_query_mtu
		add	esp, 4
		test	eax, eax
		jz	loc_6E0
		mov	[esp+1Ch+var_8], 0
		jmp	loc_693
; ---------------------------------------------------------------------------

loc_5A9:				; CODE XREF: _dtls1_do_write+294j
		cmp	edi, ebx
		jz	short loc_5C4
		push	offset ??_C@_0BJ@DFLCCFFN@len?5?$DN?$DN?5?$CIunsigned?5int?$CJret?$AA@ ; "len == (unsigned int)ret"
		push	1A3h
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_5C4:				; CODE XREF: _dtls1_do_write+2FBj
		mov	edi, [esp+1Ch+arg_4]
		cmp	edi, 16h
		jnz	loc_66C
		mov	edx, [esi+5Ch]
		cmp	dword ptr [edx+2E4h], 0

loc_5DB:				; DATA XREF: .rdata:_g_probable_mtuo
		jnz	loc_66C
		mov	eax, [esi+3Ch]
		mov	ecx, [eax+4]
		add	ecx, [esi+48h]
		test	ebp, ebp
		jnz	short loc_65B
		cmp	dword ptr [esi], 100h
		jz	short loc_65B
		movzx	eax, byte ptr [edx+260h]
		mov	[ecx], al
		movzx	eax, byte ptr [edx+266h]
		mov	[ecx+1], al
		movzx	eax, byte ptr [edx+265h]
		mov	[ecx+2], al
		movzx	eax, byte ptr [edx+264h]
		mov	[ecx+3], al
		movzx	eax, byte ptr [edx+269h]
		mov	[ecx+4], al
		movzx	eax, byte ptr [edx+268h]
		mov	[ecx+5], al
		mov	[ecx+6], bp
		mov	byte ptr [ecx+8], 0
		movzx	eax, byte ptr [edx+266h]
		mov	[ecx+9], al
		movzx	eax, byte ptr [edx+265h]
		mov	[ecx+0Ah], al
		movzx	eax, byte ptr [edx+264h]
		mov	[ecx+0Bh], al
		mov	eax, ebx
		jmp	short loc_661
; ---------------------------------------------------------------------------

loc_65B:				; CODE XREF: _dtls1_do_write+33Cj
					; _dtls1_do_write+344j
		add	ecx, 0Ch
		lea	eax, [ebx-0Ch]

loc_661:				; CODE XREF: _dtls1_do_write+3A9j
		push	eax
		push	ecx
		push	esi
		call	_ssl3_finish_mac
		add	esp, 0Ch

loc_66C:				; CODE XREF: _dtls1_do_write+31Bj
					; _dtls1_do_write:loc_5DBj
		mov	eax, [esi+44h]
		cmp	ebx, eax
		jz	short loc_6A6
		add	[esi+48h], ebx
		sub	eax, ebx
		mov	[esi+44h], eax
		add	ebp, 0FFFFFFF4h
		mov	eax, [esi+5Ch]
		add	ebp, ebx
		mov	[eax+26Ch], ebp
		mov	dword ptr [eax+270h], 0

loc_693:				; CODE XREF: _dtls1_do_write+2F4j
		cmp	dword ptr [esi+44h], 0
		jle	short loc_6FA
		mov	ebx, [esp+1Ch+arg_4]
		mov	edi, [esp+1Ch+var_4]
		jmp	loc_3F0
; ---------------------------------------------------------------------------

loc_6A6:				; CODE XREF: _dtls1_do_write+3C1j
		mov	ecx, [esi+64h]
		test	ecx, ecx
		jz	short loc_6C5
		push	dword ptr [esi+68h]
		add	eax, [esi+48h]
		push	esi
		push	eax
		mov	eax, [esi+3Ch]
		push	dword ptr [eax+4]
		push	edi
		push	dword ptr [esi]
		push	1
		call	ecx
		add	esp, 1Ch

loc_6C5:				; CODE XREF: _dtls1_do_write+3FBj
		pop	ebp
		pop	edi
		pop	ebx
		mov	dword ptr [esi+48h], 0
		mov	eax, 1
		mov	dword ptr [esi+44h], 0
		pop	esi
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_6E0:				; CODE XREF: _dtls1_do_write+153j
					; _dtls1_do_write+1DCj	...
		pop	ebp
		pop	edi
		pop	ebx
		or	eax, 0FFFFFFFFh
		pop	esi
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_6EB:				; CODE XREF: _dtls1_do_write+1BFj
		pop	ebp
		pop	edi
		pop	ebx
		mov	dword ptr [esi+18h], 2
		pop	esi
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_6FA:				; CODE XREF: _dtls1_do_write+134j
					; _dtls1_do_write+3E7j
		pop	ebp
		pop	edi
		pop	ebx
		xor	eax, eax
		pop	esi
		add	esp, 0Ch
		retn
_dtls1_do_write	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 704h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_dtls1_fix_message_header proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, [esp+arg_0]
		mov	ecx, [eax+5Ch]
		mov	eax, [esp+arg_4]
		mov	[ecx+26Ch], eax
		mov	eax, [esp+arg_8]
		mov	[ecx+270h], eax
		retn
_dtls1_fix_message_header endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 720h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_get_ccs_header
_dtls1_get_ccs_header proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_4]
		mov	eax, [esp+arg_0]
		mov	dword ptr [ecx], 0
		mov	al, [eax]
		mov	[ecx], al
		retn
_dtls1_get_ccs_header endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 734h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_get_message
_dtls1_get_message proc	near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		push	ebx
		push	ebp
		push	esi
		mov	esi, [esp+0Ch+arg_0]
		push	edi
		mov	edi, [esp+10h+arg_14]
		mov	eax, [esi+58h]
		cmp	dword ptr [eax+354h], 0
		jz	short loc_798
		mov	ecx, [esp+10h+arg_C]
		mov	dword ptr [eax+354h], 0
		test	ecx, ecx
		js	short loc_773
		mov	eax, [esi+58h]
		cmp	[eax+340h], ecx
		jz	short loc_773
		push	1F3h
		jmp	loc_7F6
; ---------------------------------------------------------------------------

loc_773:				; CODE XREF: _dtls1_get_message+28j
					; _dtls1_get_message+33j
		mov	eax, edi
		pop	edi
		mov	dword ptr [eax], 1
		mov	eax, [esi+3Ch]
		mov	eax, [eax+4]
		add	eax, 0Ch
		mov	[esi+40h], eax
		mov	eax, [esi+58h]
		mov	eax, [eax+33Ch]
		mov	[esi+44h], eax
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_798:				; CODE XREF: _dtls1_get_message+16j
		mov	ebp, [esi+5Ch]
		push	2Ch ; ','       ; Size
		add	ebp, 28Ch
		push	0		; Val
		push	ebp		; Dst
		call	_memset
		mov	ebx, [esp+1Ch+arg_10]
		add	esp, 0Ch
		xchg	ax, ax

$again$19:				; CODE XREF: _dtls1_get_message+96j
					; _dtls1_get_message+9Bj
		push	edi
		push	ebx
		push	[esp+18h+arg_8]
		push	[esp+1Ch+arg_4]
		push	esi
		call	_dtls1_get_message_fragment
		add	esp, 14h
		cmp	eax, 0FFFFFFFEh
		jz	short $again$19
		cmp	eax, 0FFFFFFFDh
		jz	short $again$19
		test	eax, eax
		jg	short loc_7DE
		cmp	dword ptr [edi], 0
		jz	loc_8D0

loc_7DE:				; CODE XREF: _dtls1_get_message+9Fj
		mov	ecx, [esp+10h+arg_C]
		test	ecx, ecx
		js	short loc_82A
		mov	eax, [esi+58h]
		cmp	[eax+340h], ecx
		jz	short loc_82A
		push	20Ah

loc_7F6:				; CODE XREF: _dtls1_get_message+3Aj
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		push	0F4h ; 'ô'
		push	0FCh ; 'ü'
		push	14h
		call	_ERR_put_error
		add	esp, 14h

$f_err$20:
		push	0Ah
		push	2
		push	esi
		call	_ssl3_send_alert
		add	esp, 0Ch
		mov	dword ptr [edi], 0
		or	eax, 0FFFFFFFFh
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_82A:				; CODE XREF: _dtls1_get_message+B0j
					; _dtls1_get_message+BBj
		mov	eax, [esi+3Ch]
		mov	ebx, [ebp+4]
		mov	edx, ebx
		shr	edx, 10h
		mov	ecx, ebx
		shr	ecx, 8
		mov	edi, [eax+4]
		movzx	eax, byte ptr [ebp+0]
		mov	[edi], al
		mov	[edi+1], dl
		mov	[edi+2], cl
		mov	[edi+3], bl
		movzx	eax, byte ptr [ebp+9]
		mov	[edi+4], al
		movzx	eax, byte ptr [ebp+8]
		mov	[edi+5], al
		mov	word ptr [edi+6], 0
		mov	byte ptr [edi+8], 0
		mov	[edi+9], dl
		mov	[edi+0Ah], cl
		mov	[edi+0Bh], bl
		add	edi, 0Ch
		cmp	dword ptr [esi], 100h
		jz	short loc_87E
		sub	edi, 0Ch
		add	ebx, 0Ch

loc_87E:				; CODE XREF: _dtls1_get_message+142j
		push	ebx
		push	edi
		push	esi
		call	_ssl3_finish_mac
		mov	eax, [esi+64h]
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_8A1
		push	dword ptr [esi+68h]
		push	esi
		push	ebx
		push	edi
		push	16h
		push	dword ptr [esi]
		push	0
		call	eax
		add	esp, 1Ch

loc_8A1:				; CODE XREF: _dtls1_get_message+15Aj
		push	2Ch ; ','       ; Size
		push	0		; Val
		push	ebp		; Dst
		call	_memset
		mov	eax, [esi+5Ch]
		add	esp, 0Ch
		cmp	dword ptr [eax+254h], 0
		jnz	short loc_8C1
		inc	word ptr [eax+228h]

loc_8C1:				; CODE XREF: _dtls1_get_message+184j
		mov	ecx, [esi+3Ch]
		mov	eax, [esi+44h]
		mov	ecx, [ecx+4]
		add	ecx, 0Ch
		mov	[esi+40h], ecx

loc_8D0:				; CODE XREF: _dtls1_get_message+A4j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_dtls1_get_message endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8D8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_dtls1_get_message_fragment proc near	; CODE XREF: _dtls1_get_message+8Bp

var_40		= dword	ptr -40h
Dst		= byte ptr -3Ch
var_38		= dword	ptr -38h
var_34		= word ptr -34h
var_30		= dword	ptr -30h
var_2C		= dword	ptr -2Ch
var_10		= byte ptr -10h
var_F		= byte ptr -0Fh
var_E		= byte ptr -0Eh
var_D		= byte ptr -0Dh
var_C		= byte ptr -0Ch
var_B		= byte ptr -0Bh
var_A		= byte ptr -0Ah
var_9		= byte ptr -9
var_8		= byte ptr -8
var_7		= byte ptr -7
var_6		= byte ptr -6
var_5		= byte ptr -5
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	eax, 40h ; '@'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+40h+var_4], eax
		push	ebx
		mov	ebx, [esp+44h+arg_10]
		push	ebp
		push	esi
		mov	esi, [esp+4Ch+arg_0]
		push	edi
		push	ebx
		push	[esp+54h+arg_C]
		push	esi
		call	_dtls1_retrieve_buffered_fragment
		add	esp, 0Ch
		test	eax, eax
		jnz	loc_A85

$redo$37:				; CODE XREF: _dtls1_get_message_fragment+1A7j
		cmp	dword ptr [ebx], 0
		jnz	loc_A8A
		mov	eax, [esi+8]
		lea	ecx, [esp+50h+var_10]
		push	0
		push	0Ch
		push	ecx
		mov	eax, [eax+34h]
		push	16h
		push	esi
		call	eax
		add	esp, 14h
		test	eax, eax
		jle	loc_B30
		cmp	eax, 0Ch
		jnz	loc_BA3
		push	2Ch ; ','       ; Size
		lea	eax, [esp+54h+Dst]
		push	0		; Val
		push	eax		; Dst
		call	_memset
		mov	al, [esp+5Ch+var_10]
		add	esp, 0Ch
		movzx	edx, [esp+50h+var_F]
		movzx	ecx, [esp+50h+var_C]
		movzx	ebp, [esp+50h+var_A]
		movzx	edi, [esp+50h+var_7]
		mov	[esp+50h+Dst], al
		movzx	eax, [esp+50h+var_E]
		shl	edx, 8
		or	edx, eax
		shl	cx, 8
		movzx	eax, [esp+50h+var_D]
		shl	edx, 8
		or	edx, eax
		shl	ebp, 8
		movzx	eax, [esp+50h+var_B]
		or	cx, ax
		shl	edi, 8
		movzx	eax, [esp+50h+var_9]
		or	ebp, eax
		mov	[esp+50h+var_38], edx
		movzx	eax, [esp+50h+var_8]
		shl	ebp, 8
		or	ebp, eax
		mov	[esp+50h+var_34], cx
		movzx	eax, [esp+50h+var_6]
		or	edi, eax
		mov	[esp+50h+var_40], ebp
		movzx	eax, [esp+50h+var_5]
		shl	edi, 8
		or	edi, eax
		mov	[esp+50h+var_30], ebp
		mov	eax, [esi+58h]
		mov	[esp+50h+var_2C], edi
		cmp	edi, [eax+110h]
		ja	loc_B8D
		mov	eax, [esi+5Ch]
		cmp	cx, [eax+228h]
		jz	short loc_9FC
		cmp	dword ptr [eax+254h], 0
		jz	loc_AA0
		cmp	cx, 1
		jnz	loc_AA0

loc_9FC:				; CODE XREF: _dtls1_get_message_fragment+10Bj
		test	edi, edi
		jz	short loc_A08
		cmp	edi, edx
		jb	loc_AC2

loc_A08:				; CODE XREF: _dtls1_get_message_fragment+126j
		cmp	dword ptr [esi+24h], 0
		jnz	loc_AEE
		cmp	dword ptr [eax+298h], 0
		jnz	loc_AEE
		cmp	[esp+50h+var_10], 0
		jnz	loc_AEE
		cmp	[esp+50h+var_F], 0
		jnz	loc_AE4
		cmp	[esp+50h+var_E], 0
		jnz	loc_AE4
		cmp	[esp+50h+var_D], 0
		jnz	loc_AE4
		mov	eax, [esi+64h]
		test	eax, eax
		jz	short loc_A68
		push	dword ptr [esi+68h]
		lea	ecx, [esp+54h+var_10]
		push	esi
		push	0Ch
		push	ecx
		push	16h
		push	dword ptr [esi]
		push	0
		call	eax
		add	esp, 1Ch

loc_A68:				; CODE XREF: _dtls1_get_message_fragment+178j
		push	ebx
		push	[esp+54h+arg_C]
		mov	dword ptr [esi+44h], 0
		push	esi
		call	_dtls1_retrieve_buffered_fragment
		add	esp, 0Ch
		test	eax, eax
		jz	$redo$37

loc_A85:				; CODE XREF: _dtls1_get_message_fragment+31j
		cmp	dword ptr [ebx], 0
		jz	short loc_A8D

loc_A8A:				; CODE XREF: _dtls1_get_message_fragment+3Aj
		mov	[esi+44h], eax

loc_A8D:				; CODE XREF: _dtls1_get_message_fragment+1B0j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+40h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 40h
		retn
; ---------------------------------------------------------------------------

loc_AA0:				; CODE XREF: _dtls1_get_message_fragment+114j
					; _dtls1_get_message_fragment+11Ej
		push	ebx
		lea	eax, [esp+54h+Dst]
		push	eax
		push	esi
		call	_dtls1_process_out_of_seq_message
		add	esp, 0Ch
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+40h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 40h
		retn
; ---------------------------------------------------------------------------

loc_AC2:				; CODE XREF: _dtls1_get_message_fragment+12Aj
		push	ebx
		lea	eax, [esp+54h+Dst]
		push	eax
		push	esi
		call	_dtls1_reassemble_fragment
		add	esp, 0Ch
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+40h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 40h
		retn
; ---------------------------------------------------------------------------

loc_AE4:				; CODE XREF: _dtls1_get_message_fragment+157j
					; _dtls1_get_message_fragment+162j ...
		push	3BCh
		jmp	loc_BA8
; ---------------------------------------------------------------------------

loc_AEE:				; CODE XREF: _dtls1_get_message_fragment+134j
					; _dtls1_get_message_fragment+141j ...
		push	[esp+50h+arg_C]
		lea	eax, [esp+54h+Dst]
		push	eax
		push	esi
		call	_dtls1_preprocess_fragment
		mov	ebp, eax
		add	esp, 0Ch
		test	ebp, ebp
		jnz	$f_err$38
		test	edi, edi
		jz	short loc_B50
		mov	eax, [esi+3Ch]
		mov	ecx, [esi+8]
		push	ebp
		push	edi
		mov	eax, [eax+4]
		add	eax, 0Ch
		add	eax, [esp+58h+var_40]
		push	eax
		mov	eax, [ecx+34h]
		push	16h
		push	esi
		call	eax
		add	esp, 14h
		test	eax, eax
		jg	short loc_B52

loc_B30:				; CODE XREF: _dtls1_get_message_fragment+59j
		pop	edi
		mov	dword ptr [esi+18h], 3
		pop	esi
		pop	ebp
		mov	dword ptr [ebx], 0
		pop	ebx
		mov	ecx, [esp+40h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 40h
		retn
; ---------------------------------------------------------------------------

loc_B50:				; CODE XREF: _dtls1_get_message_fragment+234j
		xor	eax, eax

loc_B52:				; CODE XREF: _dtls1_get_message_fragment+256j
		cmp	eax, edi
		jz	short loc_B68
		push	3DDh
		mov	ebp, 2Fh ; '/'
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		push	ebp
		jmp	short loc_BB7
; ---------------------------------------------------------------------------

loc_B68:				; CODE XREF: _dtls1_get_message_fragment+27Cj
		mov	ecx, [esp+50h+arg_8]
		mov	eax, edi
		mov	dword ptr [ebx], 1
		mov	[esi+44h], edi
		pop	edi
		mov	[esi+34h], ecx
		pop	esi
		pop	ebp
		pop	ebx
		mov	ecx, [esp+40h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 40h
		retn
; ---------------------------------------------------------------------------

loc_B8D:				; CODE XREF: _dtls1_get_message_fragment+FBj
		push	398h
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		mov	ebp, 2Fh ; '/'
		push	10Fh
		jmp	short loc_BB7
; ---------------------------------------------------------------------------

loc_BA3:				; CODE XREF: _dtls1_get_message_fragment+62j
		push	387h

loc_BA8:				; CODE XREF: _dtls1_get_message_fragment+211j
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		push	0F4h ; 'ô'
		mov	ebp, 0Ah

loc_BB7:				; CODE XREF: _dtls1_get_message_fragment+28Ej
					; _dtls1_get_message_fragment+2C9j
		push	0FDh ; 'ý'
		push	14h
		call	_ERR_put_error
		add	esp, 14h

$f_err$38:				; CODE XREF: _dtls1_get_message_fragment+22Cj
		push	ebp
		push	2
		push	esi
		call	_ssl3_send_alert
		mov	ecx, [esp+5Ch+var_4]
		add	esp, 0Ch
		mov	dword ptr [esi+44h], 0
		or	eax, 0FFFFFFFFh
		mov	dword ptr [ebx], 0
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 40h
		retn
_dtls1_get_message_fragment endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0BF8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl dtls1_get_message_header(int, void *Dst)
		public _dtls1_get_message_header
_dtls1_get_message_header proc near

arg_0		= dword	ptr  4
Dst		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+Dst]
		push	2Ch ; ','       ; Size
		push	0		; Val
		push	esi		; Dst
		call	_memset
		mov	edx, [esp+10h+arg_0]
		add	esp, 0Ch
		mov	al, [edx]
		mov	[esi], al
		movzx	ecx, byte ptr [edx+1]
		movzx	eax, byte ptr [edx+2]
		shl	ecx, 8
		or	ecx, eax
		movzx	eax, byte ptr [edx+3]
		shl	ecx, 8
		or	ecx, eax
		mov	[esi+4], ecx
		movzx	ecx, byte ptr [edx+4]
		movzx	eax, byte ptr [edx+5]
		shl	cx, 8
		or	cx, ax
		mov	[esi+8], cx
		movzx	ecx, byte ptr [edx+6]
		movzx	eax, byte ptr [edx+7]
		shl	ecx, 8
		or	ecx, eax
		movzx	eax, byte ptr [edx+8]
		shl	ecx, 8
		or	ecx, eax
		mov	[esi+0Ch], ecx
		movzx	ecx, byte ptr [edx+9]
		movzx	eax, byte ptr [edx+0Ah]
		shl	ecx, 8
		or	ecx, eax
		movzx	eax, byte ptr [edx+0Bh]
		shl	ecx, 8
		or	ecx, eax
		mov	[esi+10h], ecx
		pop	esi
		retn
_dtls1_get_message_header endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C74h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_get_queue_priority
_dtls1_get_queue_priority proc near

arg_0		= word ptr  4
arg_4		= dword	ptr  8

		movzx	eax, [esp+arg_0]
		add	eax, eax
		sub	eax, [esp+arg_4]
		retn
_dtls1_get_queue_priority endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C80h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_heartbeat
_dtls1_heartbeat proc near

arg_0		= dword	ptr  4

		push	ebp
		push	esi
		mov	esi, [esp+8+arg_0]
		or	ebp, 0FFFFFFFFh
		mov	eax, [esi+184h]
		and	al, 3
		cmp	al, 1
		jnz	loc_D8D
		cmp	dword ptr [esi+188h], 0
		jz	short loc_CB6
		push	5F2h
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		push	16Eh
		jmp	loc_D9C
; ---------------------------------------------------------------------------

loc_CB6:				; CODE XREF: _dtls1_heartbeat+20j
		push	esi
		call	_SSL_state
		add	esp, 4
		test	eax, 3000h
		jnz	loc_D7C
		cmp	dword ptr [esi+1Ch], 0
		jnz	loc_D7C
		push	ebx
		push	edi
		push	60Ch
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		push	25h ; '%'
		call	_CRYPTO_malloc
		mov	ebx, eax
		lea	edi, [ebx+1]
		push	10h
		mov	byte ptr [ebx],	1
		mov	word ptr [edi],	1200h
		movzx	eax, byte ptr [esi+18Dh]
		mov	[edi+2], al
		movzx	eax, byte ptr [esi+18Ch]
		mov	[edi+3], al
		add	edi, 4
		push	edi
		call	_RAND_pseudo_bytes
		add	esp, 14h
		test	eax, eax
		js	short $err$16
		lea	eax, [edi+10h]
		push	10h
		push	eax
		call	_RAND_pseudo_bytes
		add	esp, 8
		test	eax, eax
		js	short $err$16
		push	25h ; '%'
		push	ebx
		push	18h
		push	esi
		call	_dtls1_write_bytes
		mov	ebp, eax
		add	esp, 10h
		test	ebp, ebp
		js	short $err$16
		mov	eax, [esi+64h]
		test	eax, eax
		jz	short loc_D59
		push	dword ptr [esi+68h]
		push	esi
		push	25h ; '%'
		push	ebx
		push	18h
		push	dword ptr [esi]
		push	1
		call	eax
		add	esp, 1Ch

loc_D59:				; CODE XREF: _dtls1_heartbeat+C5j
		push	esi
		call	_dtls1_start_timer
		add	esp, 4
		mov	dword ptr [esi+188h], 1

$err$16:				; CODE XREF: _dtls1_heartbeat+98j
					; _dtls1_heartbeat+AAj	...
		push	ebx
		call	_CRYPTO_free
		add	esp, 4
		mov	eax, ebp
		pop	edi
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_D7C:				; CODE XREF: _dtls1_heartbeat+44j
					; _dtls1_heartbeat+4Ej
		push	5F8h
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		push	0F4h ; 'ô'
		jmp	short loc_D9C
; ---------------------------------------------------------------------------

loc_D8D:				; CODE XREF: _dtls1_heartbeat+13j
		push	5ECh
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		push	16Dh

loc_D9C:				; CODE XREF: _dtls1_heartbeat+31j
					; _dtls1_heartbeat+10Bj
		push	131h
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		or	eax, 0FFFFFFFFh
		pop	esi
		pop	ebp
		retn
_dtls1_heartbeat endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0DB4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_hm_fragment_free
_dtls1_hm_fragment_free	proc near	; CODE XREF: _dtls1_buffer_message+1B0p
					; _dtls1_process_out_of_seq_message+150p ...

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		cmp	dword ptr [esi+14h], 0
		jz	short loc_DD2
		push	dword ptr [esi+18h]
		call	_EVP_CIPHER_CTX_free
		push	dword ptr [esi+1Ch]
		call	_EVP_MD_CTX_destroy
		add	esp, 8

loc_DD2:				; CODE XREF: _dtls1_hm_fragment_free+9j
		mov	eax, [esi+2Ch]
		test	eax, eax
		jz	short loc_DE2
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_DE2:				; CODE XREF: _dtls1_hm_fragment_free+23j
		mov	eax, [esi+30h]
		test	eax, eax
		jz	short loc_DF2
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_DF2:				; CODE XREF: _dtls1_hm_fragment_free+33j
		push	esi
		call	_CRYPTO_free
		add	esp, 4
		pop	esi
		retn
_dtls1_hm_fragment_free	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E00h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_dtls1_hm_fragment_new proc near	; CODE XREF: _dtls1_process_out_of_seq_message+FBp
					; _dtls1_reassemble_fragment+ABp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		push	esi
		push	edi
		push	0B5h ; 'µ'
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		push	34h ; '4'
		xor	edi, edi
		xor	ebx, ebx
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jnz	short loc_E25
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_E25:				; CODE XREF: _dtls1_hm_fragment_new+1Fj
		push	ebp
		mov	ebp, [esp+10h+arg_0]
		test	ebp, ebp
		jz	short loc_E47
		push	0BAh ; 'º'
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		push	ebp
		call	_CRYPTO_malloc
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jz	short loc_E7C

loc_E47:				; CODE XREF: _dtls1_hm_fragment_new+2Cj
		mov	[esi+2Ch], edi
		cmp	[esp+10h+arg_4], ebx
		jz	short loc_E98
		push	0C7h ; 'Ç'
		add	ebp, 7
		shr	ebp, 3
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		push	ebp
		call	_CRYPTO_malloc
		mov	ebx, eax
		add	esp, 0Ch
		test	ebx, ebx
		jnz	short loc_E8C
		test	edi, edi
		jz	short loc_E7C
		push	edi
		call	_CRYPTO_free
		add	esp, 4

loc_E7C:				; CODE XREF: _dtls1_hm_fragment_new+45j
					; _dtls1_hm_fragment_new+71j
		push	esi
		call	_CRYPTO_free
		add	esp, 4
		xor	eax, eax
		pop	ebp
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_E8C:				; CODE XREF: _dtls1_hm_fragment_new+6Dj
		push	ebp		; Size
		push	0		; Val
		push	ebx		; Dst
		call	_memset
		add	esp, 0Ch

loc_E98:				; CODE XREF: _dtls1_hm_fragment_new+4Ej
		pop	ebp
		pop	edi
		mov	[esi+30h], ebx
		mov	eax, esi
		pop	esi
		pop	ebx
		retn
_dtls1_hm_fragment_new endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0EA4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_link_min_mtu
_dtls1_link_min_mtu proc near
		mov	eax, 100h
		retn
_dtls1_link_min_mtu endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0EACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_dtls1_max_handshake_message_len proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	ecx, [eax+108h]
		mov	eax, 454Ch
		cmp	ecx, eax
		cmova	eax, ecx
		retn
_dtls1_max_handshake_message_len endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0EC4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_min_mtu
_dtls1_min_mtu	proc near

arg_0		= dword	ptr  4

		push	0
		push	0
		push	31h ; '1'
		push	[esp+0Ch+arg_0]
		call	_SSL_get_wbio
		add	esp, 4
		push	eax
		call	_BIO_ctrl
		mov	ecx, 100h
		add	esp, 10h
		sub	ecx, eax
		mov	eax, ecx
		retn
_dtls1_min_mtu	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0EECh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_dtls1_preprocess_fragment proc	near	; CODE XREF: _dtls1_get_message_fragment+220p
					; _dtls1_retrieve_buffered_fragment+66p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_4]
		push	edi
		mov	eax, [esi+10h]
		add	eax, [esi+0Ch]
		mov	edi, [esi+4]
		cmp	eax, edi
		jbe	short loc_F25
		push	23Bh

loc_F04:				; CODE XREF: _dtls1_preprocess_fragment+44j
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		push	98h ; ''
		push	120h
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		mov	eax, 2Fh ; '/'
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_F25:				; CODE XREF: _dtls1_preprocess_fragment+11j
		cmp	eax, [esp+8+arg_8]
		jbe	short loc_F32
		push	240h
		jmp	short loc_F04
; ---------------------------------------------------------------------------

loc_F32:				; CODE XREF: _dtls1_preprocess_fragment+3Dj
		push	ebx
		mov	ebx, [esp+0Ch+arg_0]
		mov	eax, [ebx+5Ch]
		cmp	dword ptr [eax+298h], 0
		jnz	short loc_FB7
		lea	eax, [edi+0Ch]
		push	eax
		push	dword ptr [ebx+3Ch]
		call	_BUF_MEM_grow_clean
		add	esp, 8
		test	eax, eax
		jnz	short loc_F7A
		push	24Bh
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		push	7
		push	120h
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		mov	eax, 50h ; 'P'
		pop	ebx
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_F7A:				; CODE XREF: _dtls1_preprocess_fragment+68j
		mov	eax, [ebx+58h]
		mov	[eax+33Ch], edi
		mov	eax, [ebx+5Ch]
		mov	[eax+290h], edi
		mov	eax, [ebx+58h]
		movzx	ecx, byte ptr [esi]
		mov	[eax+340h], ecx
		mov	ecx, [ebx+5Ch]
		mov	al, [esi]
		mov	[ecx+28Ch], al
		mov	ecx, [ebx+5Ch]
		mov	ax, [esi+8]
		mov	[ecx+294h], ax

loc_FB1:				; CODE XREF: _dtls1_preprocess_fragment+D1j
		pop	ebx
		pop	edi
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_FB7:				; CODE XREF: _dtls1_preprocess_fragment+55j
		cmp	edi, [eax+290h]
		jz	short loc_FB1
		push	259h
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		push	98h ; ''
		push	120h
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		mov	eax, 2Fh ; '/'
		pop	ebx
		pop	edi
		pop	esi
		retn
_dtls1_preprocess_fragment endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0FE8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl dtls1_process_heartbeat(size_t Size)
		public _dtls1_process_heartbeat
_dtls1_process_heartbeat proc near

Src		= dword	ptr -4
Size		= dword	ptr  4

		mov	eax, 4
		call	__chkstk
		push	esi
		push	edi
		mov	edi, [esp+0Ch+Size]
		mov	eax, [edi+58h]
		mov	ecx, [edi+64h]
		mov	esi, [eax+118h]
		test	ecx, ecx
		jz	short loc_101E
		push	dword ptr [edi+68h]
		push	edi
		push	dword ptr [eax+110h]
		push	esi
		push	18h
		push	dword ptr [edi]
		push	0
		call	ecx
		add	esp, 1Ch

loc_101E:				; CODE XREF: _dtls1_process_heartbeat+1Ej
		mov	eax, [edi+58h]
		mov	edx, [eax+110h]
		cmp	edx, 13h
		jnb	short loc_1032

loc_102C:				; CODE XREF: _dtls1_process_heartbeat+50j
		pop	edi
		xor	eax, eax
		pop	esi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_1032:				; CODE XREF: _dtls1_process_heartbeat+42j
		cmp	edx, 4000h
		ja	short loc_102C
		movzx	ecx, byte ptr [esi+1]
		movzx	eax, byte ptr [esi+2]
		shl	ecx, 8
		or	ecx, eax
		push	ebx
		movzx	ebx, byte ptr [esi]
		mov	[esp+10h+Size],	ecx
		lea	eax, [ecx+13h]
		cmp	eax, edx
		jbe	short loc_105D
		pop	ebx
		pop	edi
		xor	eax, eax
		pop	esi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_105D:				; CODE XREF: _dtls1_process_heartbeat+6Cj
		lea	eax, [esi+3]
		mov	[esp+10h+Src], eax
		push	ebp
		cmp	ebx, 1
		jnz	loc_111F
		lea	ebp, [ecx+13h]
		cmp	ebp, 4000h
		ja	loc_1156
		push	5B5h
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		push	ebp
		call	_CRYPTO_malloc
		mov	ebx, eax
		add	esp, 0Ch
		test	ebx, ebx
		jz	short loc_10D6
		mov	ecx, [esp+14h+Size]
		lea	esi, [ebx+1]
		mov	eax, ecx
		mov	byte ptr [ebx],	2
		push	ecx		; Size
		push	[esp+18h+Src]	; Src
		shr	eax, 8
		mov	[esi], al
		mov	[esi+1], cl
		add	esi, 2
		push	esi		; Dst
		call	_memcpy
		mov	eax, [esp+20h+Size]
		add	eax, esi
		push	10h
		push	eax
		call	_RAND_pseudo_bytes
		add	esp, 14h
		test	eax, eax
		jns	short loc_10DF
		push	ebx
		call	_CRYPTO_free
		add	esp, 4

loc_10D6:				; CODE XREF: _dtls1_process_heartbeat+ACj
		pop	ebp
		pop	ebx
		pop	edi
		or	eax, 0FFFFFFFFh
		pop	esi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_10DF:				; CODE XREF: _dtls1_process_heartbeat+E3j
		push	ebp
		push	ebx
		push	18h
		push	edi
		call	_dtls1_write_bytes
		mov	esi, eax
		add	esp, 10h
		test	esi, esi
		js	short loc_110A
		mov	eax, [edi+64h]
		test	eax, eax
		jz	short loc_110A
		push	dword ptr [edi+68h]
		push	edi
		push	ebp
		push	ebx
		push	18h
		push	dword ptr [edi]
		push	1
		call	eax
		add	esp, 1Ch

loc_110A:				; CODE XREF: _dtls1_process_heartbeat+108j
					; _dtls1_process_heartbeat+10Fj
		push	ebx
		call	_CRYPTO_free
		add	esp, 4
		test	esi, esi
		jns	short loc_1156
		pop	ebp
		pop	ebx
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_111F:				; CODE XREF: _dtls1_process_heartbeat+80j
		cmp	ebx, 2
		jnz	short loc_1156
		cmp	ecx, 12h
		jnz	short loc_1156
		movzx	ecx, byte ptr [eax]
		movzx	eax, byte ptr [eax+1]
		shl	ecx, 8
		or	ecx, eax
		cmp	ecx, [edi+18Ch]
		jnz	short loc_1156
		push	edi
		call	_dtls1_stop_timer
		add	esp, 4
		mov	dword ptr [edi+188h], 0
		inc	dword ptr [edi+18Ch]

loc_1156:				; CODE XREF: _dtls1_process_heartbeat+8Fj
					; _dtls1_process_heartbeat+12Dj ...
		pop	ebp
		pop	ebx
		pop	edi
		xor	eax, eax
		pop	esi
		pop	ecx
		retn
_dtls1_process_heartbeat endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1160h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_dtls1_process_out_of_seq_message proc near ; CODE XREF: _dtls1_get_message_fragment+1CFp

var_114		= dword	ptr -114h
var_110		= dword	ptr -110h
var_10C		= qword	ptr -10Ch
var_104		= byte ptr -104h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 114h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+114h+var_4], eax
		mov	eax, [esp+114h+arg_8]
		push	ebx
		mov	ebx, [esp+118h+arg_4]
		push	ebp
		mov	ebp, [esp+11Ch+arg_0]
		mov	[esp+11Ch+var_110], eax
		mov	eax, [ebx+0Ch]
		push	esi
		mov	esi, [ebx+10h]
		add	eax, esi
		push	edi
		or	edi, 0FFFFFFFFh
		cmp	eax, [ebx+4]
		ja	loc_12B8
		movzx	eax, byte ptr [ebx+9]
		xorps	xmm0, xmm0
		movq	[esp+124h+var_10C], xmm0
		mov	byte ptr [esp+124h+var_10C+6], al
		movzx	eax, byte ptr [ebx+8]
		mov	byte ptr [esp+124h+var_10C+7], al
		lea	eax, [esp+124h+var_10C]
		push	eax
		mov	eax, [ebp+5Ch]
		push	dword ptr [eax+244h]
		call	_pqueue_find
		mov	edx, eax
		add	esp, 8
		test	edx, edx
		jz	short loc_11E6
		xor	eax, eax
		cmp	esi, [ebx+4]
		cmovnz	edx, eax

loc_11E6:				; CODE XREF: _dtls1_process_out_of_seq_message+7Cj
		mov	eax, [ebp+5Ch]
		movzx	ecx, word ptr [ebx+8]
		movzx	eax, word ptr [eax+228h]
		mov	[esp+124h+var_114], eax
		cmp	cx, ax
		jbe	loc_132B
		movzx	ecx, ax
		movzx	eax, word ptr [ebx+8]
		add	ecx, 0Ah
		cmp	eax, ecx
		jg	loc_132B
		test	edx, edx
		jnz	loc_132B
		cmp	word ptr [esp+124h+var_114], dx
		jnz	short loc_122B
		cmp	byte ptr [ebx],	14h
		jz	loc_132B

loc_122B:				; CODE XREF: _dtls1_process_out_of_seq_message+C0j
		cmp	esi, [ebx+4]
		jz	short loc_1244
		mov	eax, [esp+124h+var_110]
		push	eax
		push	ebx
		push	ebp
		call	_dtls1_reassemble_fragment
		add	esp, 0Ch
		jmp	loc_12C4
; ---------------------------------------------------------------------------

loc_1244:				; CODE XREF: _dtls1_process_out_of_seq_message+CEj
		mov	eax, [ebp+108h]
		mov	ecx, 454Ch
		cmp	eax, ecx
		cmova	ecx, eax
		cmp	esi, ecx
		ja	short loc_12B8
		push	0
		push	esi
		call	_dtls1_hm_fragment_new
		mov	ecx, eax
		add	esp, 8
		mov	[esp+124h+var_114], ecx
		test	ecx, ecx
		jz	short loc_12B8
		movups	xmm0, xmmword ptr [ebx]
		movups	xmmword	ptr [ecx], xmm0
		movups	xmm0, xmmword ptr [ebx+10h]
		movups	xmmword	ptr [ecx+10h], xmm0
		movq	xmm0, qword ptr	[ebx+20h]
		movq	qword ptr [ecx+20h], xmm0
		mov	eax, [ebx+28h]
		mov	[ecx+28h], eax
		test	esi, esi
		jz	short loc_12E5
		mov	eax, [ebp+8]
		push	0
		push	esi
		push	dword ptr [ecx+2Ch]
		mov	eax, [eax+34h]
		push	16h
		push	ebp
		call	eax
		mov	edi, eax
		add	esp, 14h
		cmp	edi, esi
		jz	short loc_12DD
		or	edi, 0FFFFFFFFh

loc_12AC:				; CODE XREF: _dtls1_process_out_of_seq_message+17Fj
					; _dtls1_process_out_of_seq_message+195j
		push	[esp+124h+var_114]
		call	_dtls1_hm_fragment_free
		add	esp, 4

loc_12B8:				; CODE XREF: _dtls1_process_out_of_seq_message+43j
					; _dtls1_process_out_of_seq_message+F6j ...
		mov	eax, [esp+124h+var_110]
		mov	dword ptr [eax], 0
		mov	eax, edi

loc_12C4:				; CODE XREF: _dtls1_process_out_of_seq_message+DFj
					; _dtls1_process_out_of_seq_message+1C9j ...
		mov	ecx, [esp+124h+var_4]
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 114h
		retn
; ---------------------------------------------------------------------------

loc_12DD:				; CODE XREF: _dtls1_process_out_of_seq_message+147j
		test	edi, edi
		jle	short loc_12AC
		mov	ecx, [esp+124h+var_114]

loc_12E5:				; CODE XREF: _dtls1_process_out_of_seq_message+12Dj
		push	ecx
		lea	eax, [esp+128h+var_10C]
		push	eax
		call	_pitem_new
		add	esp, 8
		test	eax, eax
		jz	short loc_12AC
		push	eax
		mov	eax, [ebp+5Ch]
		push	dword ptr [eax+244h]
		call	_pqueue_insert
		add	esp, 8
		test	eax, eax
		jnz	short loc_135F
		push	offset ??_C@_0N@BMFCCKCA@item?5?$CB?$DN?5NULL?$AA@ ; "item != NULL"
		push	360h
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		call	_OpenSSLDie
		add	esp, 0Ch
		mov	eax, 0FFFFFFFDh
		jmp	short loc_12C4
; ---------------------------------------------------------------------------

loc_132B:				; CODE XREF: _dtls1_process_out_of_seq_message+9Bj
					; _dtls1_process_out_of_seq_message+ADj ...
		test	esi, esi
		jz	short loc_135F
		mov	ebx, 100h

loc_1334:				; CODE XREF: _dtls1_process_out_of_seq_message+1FDj
		mov	ecx, [ebp+8]
		cmp	esi, ebx
		push	0
		mov	eax, esi
		cmova	eax, ebx
		push	eax
		lea	eax, [esp+12Ch+var_104]
		push	eax
		mov	eax, [ecx+34h]
		push	16h
		push	ebp
		call	eax
		mov	edi, eax
		add	esp, 14h
		test	edi, edi
		jle	loc_12B8
		sub	esi, edi
		jnz	short loc_1334

loc_135F:				; CODE XREF: _dtls1_process_out_of_seq_message+1ABj
					; _dtls1_process_out_of_seq_message+1CDj
		mov	eax, 0FFFFFFFDh
		jmp	loc_12C4
_dtls1_process_out_of_seq_message endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 136Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_dtls1_query_mtu proc near		; CODE XREF: _dtls1_do_write+18p
					; _dtls1_do_write+2DCp

arg_0		= dword	ptr  4

		push	edi
		mov	edi, [esp+4+arg_0]
		mov	eax, [edi+5Ch]
		cmp	dword ptr [eax+258h], 0
		jz	short loc_13B4
		push	esi
		push	0
		push	0
		push	31h ; '1'
		push	edi
		mov	esi, eax
		call	_SSL_get_wbio
		add	esp, 4
		push	eax
		call	_BIO_ctrl
		mov	ecx, [esi+258h]
		add	esp, 10h
		sub	ecx, eax
		mov	[esi+25Ch], ecx
		mov	eax, [edi+5Ch]
		pop	esi
		mov	dword ptr [eax+258h], 0

loc_13B4:				; CODE XREF: _dtls1_query_mtu+Fj
		push	0
		push	0
		push	31h ; '1'
		push	edi
		call	_SSL_get_wbio
		add	esp, 4
		push	eax
		call	_BIO_ctrl
		mov	ecx, 100h
		add	esp, 10h
		sub	ecx, eax
		mov	eax, [edi+5Ch]
		cmp	[eax+25Ch], ecx
		jnb	loc_148E
		push	0
		push	0
		push	20h ; ' '
		push	edi
		call	_SSL_ctrl
		add	esp, 10h
		test	eax, 1000h
		jnz	loc_1495
		push	0
		push	0
		push	28h ; '('
		push	edi
		call	_SSL_get_wbio
		add	esp, 4
		push	eax
		call	_BIO_ctrl
		mov	ecx, [edi+5Ch]
		add	esp, 10h
		push	0
		push	0
		push	31h ; '1'
		push	edi
		mov	[ecx+25Ch], eax
		call	_SSL_get_wbio
		add	esp, 4
		push	eax
		call	_BIO_ctrl
		mov	ecx, 100h
		add	esp, 10h
		sub	ecx, eax
		mov	eax, [edi+5Ch]
		cmp	[eax+25Ch], ecx
		jnb	short loc_148E
		push	0
		push	0
		push	31h ; '1'
		push	edi
		call	_SSL_get_wbio
		add	esp, 4
		push	eax
		call	_BIO_ctrl
		mov	ecx, 100h
		add	esp, 10h
		sub	ecx, eax
		mov	eax, [edi+5Ch]
		push	0
		mov	[eax+25Ch], ecx
		mov	eax, [edi+5Ch]
		push	dword ptr [eax+25Ch]
		push	2Ah ; '*'
		push	edi
		call	_SSL_get_wbio
		add	esp, 4
		push	eax
		call	_BIO_ctrl
		add	esp, 10h

loc_148E:				; CODE XREF: _dtls1_query_mtu+70j
					; _dtls1_query_mtu+D9j
		mov	eax, 1
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_1495:				; CODE XREF: _dtls1_query_mtu+8Aj
		xor	eax, eax
		pop	edi
		retn
_dtls1_query_mtu endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 149Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_read_failed
_dtls1_read_failed proc	near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	edi
		mov	edi, [esp+4+arg_4]
		test	edi, edi
		jle	short loc_14CF
		push	420h
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		push	offset ??_C@_0BM@PPAKALD@invalid?5state?5reached?5?$CFs?3?$CFd?$AA@ ; "invalid state reached %s:%d"
		push	2
		call	dword ptr ds:__imp____acrt_iob_func
		add	esp, 4
		push	eax		; File
		call	_fprintf
		add	esp, 10h
		mov	eax, 1
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_14CF:				; CODE XREF: _dtls1_read_failed+7j
		push	esi
		mov	esi, [esp+8+arg_0]
		push	esi
		call	_dtls1_is_timer_expired
		add	esp, 4
		test	eax, eax
		jz	short loc_150E
		push	esi
		call	_SSL_state
		add	esp, 4
		test	eax, 3000h
		jnz	short loc_1513
		cmp	dword ptr [esi+188h], 0
		jnz	short loc_1513
		push	1
		push	esi
		call	_SSL_get_rbio
		add	esp, 4
		push	eax
		call	_BIO_set_flags
		add	esp, 8

loc_150E:				; CODE XREF: _dtls1_read_failed+43j
		pop	esi
		mov	eax, edi
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_1513:				; CODE XREF: _dtls1_read_failed+53j
					; _dtls1_read_failed+5Cj
		push	esi
		call	_dtls1_handle_timeout
		add	esp, 4
		pop	esi
		pop	edi
		retn
_dtls1_read_failed endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1520h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_dtls1_reassemble_fragment proc	near	; CODE XREF: _dtls1_get_message_fragment+1F1p
					; _dtls1_process_out_of_seq_message+D7p

var_118		= dword	ptr -118h
var_114		= dword	ptr -114h
var_110		= dword	ptr -110h
var_10C		= qword	ptr -10Ch
var_104		= byte ptr -104h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 118h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+118h+var_4], eax
		mov	eax, [esp+118h+arg_8]
		mov	edx, [esp+118h+arg_0]
		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	edi, [esp+128h+arg_4]
		or	ebp, 0FFFFFFFFh
		mov	[esp+128h+var_110], eax
		mov	[esp+128h+var_118], edx
		mov	eax, [edi+0Ch]
		mov	esi, [edi+10h]
		add	eax, esi
		mov	ebx, [edi+4]
		cmp	eax, ebx
		ja	loc_1687
		mov	eax, [edx+108h]
		mov	ecx, 454Ch
		cmp	eax, ecx
		cmova	ecx, eax
		cmp	ebx, ecx
		ja	loc_1687
		test	esi, esi
		jz	loc_164B
		movzx	eax, byte ptr [edi+9]
		xorps	xmm0, xmm0
		movq	[esp+128h+var_10C], xmm0
		mov	byte ptr [esp+128h+var_10C+6], al
		movzx	eax, byte ptr [edi+8]
		mov	byte ptr [esp+128h+var_10C+7], al
		lea	eax, [esp+128h+var_10C]
		push	eax
		mov	eax, [edx+5Ch]
		push	dword ptr [eax+244h]
		call	_pqueue_find
		add	esp, 8
		mov	[esp+128h+var_114], eax
		test	eax, eax
		jnz	short loc_160A
		push	1
		push	dword ptr [edi+4]
		call	_dtls1_hm_fragment_new
		mov	ebx, eax
		add	esp, 8
		test	ebx, ebx
		jz	loc_1687
		movups	xmm0, xmmword ptr [edi]
		movups	xmmword	ptr [ebx], xmm0
		movups	xmm0, xmmword ptr [edi+10h]
		movups	xmmword	ptr [ebx+10h], xmm0
		movq	xmm0, qword ptr	[edi+20h]
		movq	qword ptr [ebx+20h], xmm0
		mov	eax, [edi+28h]
		mov	[ebx+28h], eax
		mov	eax, [ebx+4]
		mov	[ebx+10h], eax
		mov	dword ptr [ebx+0Ch], 0
		jmp	short loc_1615
; ---------------------------------------------------------------------------

loc_160A:				; CODE XREF: _dtls1_reassemble_fragment+A4j
		mov	ebx, [eax+8]
		mov	eax, [ebx+4]
		cmp	eax, [edi+4]
		jnz	short loc_1687

loc_1615:				; CODE XREF: _dtls1_reassemble_fragment+E8j
		cmp	dword ptr [ebx+30h], 0
		jnz	short loc_1652
		mov	edi, 100h

loc_1620:				; CODE XREF: _dtls1_reassemble_fragment+129j
		mov	edx, [esp+128h+var_118]
		cmp	esi, edi
		push	0
		mov	eax, esi
		cmova	eax, edi
		mov	ecx, [edx+8]
		push	eax
		lea	eax, [esp+130h+var_104]
		push	eax
		mov	eax, [ecx+34h]
		push	16h
		push	edx
		call	eax
		mov	ebp, eax
		add	esp, 14h
		test	ebp, ebp
		jle	short $err$64
		sub	esi, ebp
		jnz	short loc_1620

loc_164B:				; CODE XREF: _dtls1_reassemble_fragment+69j
		mov	eax, 0FFFFFFFDh
		jmp	short loc_1693
; ---------------------------------------------------------------------------

loc_1652:				; CODE XREF: _dtls1_reassemble_fragment+F9j
		mov	edx, [esp+128h+var_118]
		mov	eax, [ebx+2Ch]
		add	eax, [edi+0Ch]
		push	0
		mov	ecx, [edx+8]
		push	esi
		push	eax
		push	16h
		mov	eax, [ecx+34h]
		push	edx
		call	eax
		mov	ebp, eax
		add	esp, 14h
		cmp	ebp, esi
		jz	short loc_16AC
		or	ebp, 0FFFFFFFFh

$err$64:				; CODE XREF: _dtls1_reassemble_fragment+125j
					; _dtls1_reassemble_fragment+18Ej
		cmp	[esp+128h+var_114], 0
		jnz	short loc_1687

loc_167E:				; CODE XREF: _dtls1_reassemble_fragment+297j
		push	ebx
		call	_dtls1_hm_fragment_free
		add	esp, 4

loc_1687:				; CODE XREF: _dtls1_reassemble_fragment+49j
					; _dtls1_reassemble_fragment+61j ...
		mov	eax, [esp+128h+var_110]
		mov	dword ptr [eax], 0
		mov	eax, ebp

loc_1693:				; CODE XREF: _dtls1_reassemble_fragment+130j
					; _dtls1_reassemble_fragment+2D2j
		mov	ecx, [esp+128h+var_4]
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 118h
		retn
; ---------------------------------------------------------------------------

loc_16AC:				; CODE XREF: _dtls1_reassemble_fragment+152j
		test	ebp, ebp
		jle	short $err$64
		cmp	esi, 8
		jg	short loc_16E1
		mov	ebp, [edi+0Ch]
		lea	eax, [esi+ebp]
		cmp	ebp, eax
		jge	short loc_173E
		nop

loc_16C0:				; CODE XREF: _dtls1_reassemble_fragment+1BDj
		mov	edx, ebp
		mov	eax, ebp
		sar	edx, 3
		and	eax, 7
		add	edx, [ebx+30h]
		inc	ebp
		movzx	ecx, byte ptr [edx]
		bts	ecx, eax
		mov	[edx], cl
		mov	eax, [edi+0Ch]
		add	eax, esi
		cmp	ebp, eax
		jl	short loc_16C0
		jmp	short loc_173E
; ---------------------------------------------------------------------------

loc_16E1:				; CODE XREF: _dtls1_reassemble_fragment+193j
		mov	edx, [edi+0Ch]
		mov	ecx, edx
		sar	ecx, 3
		and	edx, 7
		add	ecx, [ebx+30h]
		mov	al, _bitmask_start_values[edx]
		or	[ecx], al
		mov	eax, [edi+0Ch]
		mov	ecx, eax
		dec	eax
		sar	ecx, 3
		add	eax, esi
		inc	ecx
		sar	eax, 3
		cmp	ecx, eax
		jge	short loc_1725
		nop	word ptr [eax+eax+00h]

loc_1710:				; CODE XREF: _dtls1_reassemble_fragment+203j
		mov	eax, [ebx+30h]
		mov	byte ptr [ecx+eax], 0FFh
		inc	ecx
		mov	eax, [edi+0Ch]
		dec	eax
		add	eax, esi
		sar	eax, 3
		cmp	ecx, eax
		jl	short loc_1710

loc_1725:				; CODE XREF: _dtls1_reassemble_fragment+1E8j
		mov	edx, [edi+0Ch]
		add	edx, esi
		lea	ecx, [edx-1]
		and	edx, 7
		sar	ecx, 3
		add	ecx, [ebx+30h]
		mov	al, _bitmask_end_values[edx]
		or	[ecx], al

loc_173E:				; CODE XREF: _dtls1_reassemble_fragment+19Dj
					; _dtls1_reassemble_fragment+1BFj
		cmp	dword ptr [edi+4], 0
		jg	short loc_175B
		push	offset ??_C@_0BN@LINMFPNB@?$CI?$CIlong?$CJmsg_hdr?9?$DOmsg_len?$CJ?5?$DO?50?$AA@ ; "((long)msg_hdr->msg_len) > 0"
		push	2EAh
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_175B:				; CODE XREF: _dtls1_reassemble_fragment+222j
		mov	ecx, [edi+4]
		mov	edx, [ebx+30h]
		lea	esi, [ecx-1]
		and	ecx, 7
		sar	esi, 3
		mov	al, [esi+edx]
		cmp	al, _bitmask_end_values[ecx]
		jnz	short loc_179B
		lea	eax, [esi-1]
		test	eax, eax
		js	short loc_178B
		nop	dword ptr [eax+00h]

loc_1780:				; CODE XREF: _dtls1_reassemble_fragment+269j
		cmp	byte ptr [edx+eax], 0FFh
		jnz	short loc_179B
		sub	eax, 1
		jns	short loc_1780

loc_178B:				; CODE XREF: _dtls1_reassemble_fragment+25Aj
		push	edx
		call	_CRYPTO_free
		add	esp, 4
		mov	dword ptr [ebx+30h], 0

loc_179B:				; CODE XREF: _dtls1_reassemble_fragment+253j
					; _dtls1_reassemble_fragment+264j
		cmp	[esp+128h+var_114], 0
		jnz	short loc_17ED
		lea	eax, [esp+128h+var_10C]
		push	ebx
		push	eax
		call	_pitem_new
		add	esp, 8
		test	eax, eax
		jnz	short loc_17BC
		or	ebp, 0FFFFFFFFh
		jmp	loc_167E
; ---------------------------------------------------------------------------

loc_17BC:				; CODE XREF: _dtls1_reassemble_fragment+292j
		push	eax
		mov	eax, [esp+12Ch+var_118]
		mov	eax, [eax+5Ch]
		push	dword ptr [eax+244h]
		call	_pqueue_insert
		add	esp, 8
		test	eax, eax
		jnz	short loc_17ED
		push	offset ??_C@_0N@BMFCCKCA@item?5?$CB?$DN?5NULL?$AA@ ; "item != NULL"
		push	2FFh
		push	offset ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ ; ".\\ssl\\d1_both.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_17ED:				; CODE XREF: _dtls1_reassemble_fragment+280j
					; _dtls1_reassemble_fragment+2B4j
		mov	eax, 0FFFFFFFDh
		jmp	loc_1693
_dtls1_reassemble_fragment endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 17F8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_retransmit_buffered_messages
_dtls1_retransmit_buffered_messages proc near

var_2E		= word ptr -2Eh
var_2C		= dword	ptr -2Ch
var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= qword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 30h ; '0'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+30h+var_4], eax
		push	ebx
		push	ebp
		push	esi
		mov	esi, [esp+3Ch+arg_0]
		push	edi
		mov	eax, [esi+5Ch]
		push	dword ptr [eax+248h]
		call	_pqueue_iterator
		mov	[esp+44h+var_24], eax
		lea	eax, [esp+44h+var_24]
		push	eax
		call	_pqueue_next
		add	esp, 8
		mov	ebp, 1
		test	eax, eax
		jz	loc_1A8F
		mov	ecx, dword ptr [esp+40h+var_C+4]
		mov	[esp+40h+var_2C], ecx
		mov	ecx, dword ptr [esp+40h+var_C]
		mov	[esp+40h+var_28], ecx
		nop	dword ptr [eax+00000000h]

loc_1858:				; CODE XREF: _dtls1_retransmit_buffered_messages+28Cj
		mov	eax, [eax+8]
		xorps	xmm0, xmm0
		movq	[esp+40h+var_C], xmm0
		movzx	ebx, word ptr [eax+8]
		add	ebx, ebx
		sub	ebx, [eax+14h]
		mov	eax, ebx
		mov	byte ptr [esp+40h+var_C+7], bl
		shr	eax, 8
		mov	byte ptr [esp+40h+var_C+6], al
		lea	eax, [esp+40h+var_C]
		push	eax
		mov	eax, [esi+5Ch]
		push	dword ptr [eax+248h]
		call	_pqueue_find
		add	esp, 8
		test	eax, eax
		jnz	short loc_18B6
		movzx	eax, bx
		push	eax
		push	offset ??_C@_0CG@JAOANJGB@retransmit?3?5?5message?5?$CFd?5non?9exis@ ; "retransmit:  message %d	non-existant\n"
		push	2
		call	dword ptr ds:__imp____acrt_iob_func
		add	esp, 4
		push	eax		; File
		call	_fprintf
		add	esp, 0Ch
		jmp	loc_1A75
; ---------------------------------------------------------------------------

loc_18B6:				; CODE XREF: _dtls1_retransmit_buffered_messages+9Aj
		mov	ebp, [eax+8]
		mov	edi, 0Ch
		mov	eax, 1
		cmp	dword ptr [ebp+14h], 0
		cmovnz	edi, eax
		mov	eax, [ebp+4]
		add	eax, edi
		push	eax		; Size
		mov	eax, [esi+3Ch]
		push	dword ptr [ebp+2Ch] ; Src
		push	dword ptr [eax+4] ; Dst
		call	_memcpy
		mov	eax, [ebp+4]
		add	esp, 0Ch
		add	eax, edi
		mov	edi, [esi+5Ch]
		mov	[esi+44h], eax
		movzx	edx, word ptr [ebp+8]
		mov	al, [ebp+0]
		mov	ecx, [ebp+4]
		mov	ebx, [ebp+10h]
		mov	[edi+264h], ecx
		mov	[edi+260h], al
		mov	[edi+268h], dx
		mov	dword ptr [edi+26Ch], 0
		mov	[edi+270h], ebx
		mov	eax, [esi+8Ch]
		mov	[esp+40h+var_20], eax
		mov	eax, [esi+90h]
		mov	[esp+40h+var_1C], eax
		mov	eax, [esi+94h]
		mov	[esp+40h+var_18], eax
		mov	eax, [esi+0C0h]
		mov	[esp+40h+var_14], eax
		mov	eax, [esi+5Ch]
		mov	dx, [eax+20Ah]
		mov	dword ptr [eax+2E4h], 1
		mov	eax, [ebp+18h]
		mov	ecx, [esi+5Ch]
		mov	[esi+8Ch], eax
		mov	eax, [ebp+1Ch]
		mov	[esi+90h], eax
		mov	eax, [ebp+20h]
		mov	[esi+94h], eax
		mov	eax, [ebp+24h]
		mov	[esi+0C0h], eax
		mov	ax, [ebp+28h]
		mov	[ecx+20Ah], ax
		movzx	eax, word ptr [ebp+28h]
		movzx	ecx, dx
		dec	ecx
		mov	[esp+40h+var_2E], dx
		mov	[esp+40h+var_10], ecx
		cmp	eax, ecx
		jnz	short loc_19C7
		mov	edx, [esi+58h]
		mov	ecx, [esi+5Ch]
		mov	eax, [edx+54h]
		mov	ebx, [edx+58h]
		mov	[esp+40h+var_28], eax
		mov	eax, [ecx+22Ah]
		mov	[edx+54h], eax
		mov	eax, [ecx+22Eh]
		mov	[esp+40h+var_2C], ebx
		mov	[edx+58h], eax
		jmp	short loc_19CB
; ---------------------------------------------------------------------------

loc_19C7:				; CODE XREF: _dtls1_retransmit_buffered_messages+1A5j
		mov	ebx, [esp+40h+var_2C]

loc_19CB:				; CODE XREF: _dtls1_retransmit_buffered_messages+1CDj
		xor	eax, eax
		cmp	[ebp+14h], eax
		setz	al
		lea	eax, ds:14h[eax*2]
		push	eax
		push	esi
		call	_dtls1_do_write
		mov	ecx, [esi+5Ch]
		mov	edi, eax
		mov	eax, [esp+48h+var_20]
		add	esp, 8
		mov	[esi+8Ch], eax
		mov	eax, [esp+40h+var_1C]
		mov	[esi+90h], eax
		mov	eax, [esp+40h+var_18]
		mov	[esi+94h], eax
		mov	eax, [esp+40h+var_14]
		mov	[esi+0C0h], eax
		mov	ax, [esp+40h+var_2E]
		mov	[ecx+20Ah], ax
		movzx	ecx, word ptr [ebp+28h]
		cmp	ecx, [esp+40h+var_10]
		jnz	short loc_1A4C
		mov	ecx, [esi+58h]
		mov	edx, [esi+5Ch]
		mov	eax, [ecx+54h]
		mov	[edx+22Ah], eax
		mov	eax, [ecx+58h]
		mov	ecx, [esp+40h+var_28]
		mov	[edx+22Eh], eax
		mov	eax, [esi+58h]
		mov	[eax+54h], ecx
		mov	[eax+58h], ebx

loc_1A4C:				; CODE XREF: _dtls1_retransmit_buffered_messages+22Dj
		mov	eax, [esi+5Ch]
		push	0
		push	0
		push	0Bh
		push	esi
		mov	dword ptr [eax+2E4h], 0
		call	_SSL_get_wbio
		add	esp, 4
		push	eax
		call	_BIO_ctrl
		add	esp, 10h
		test	edi, edi
		jle	short loc_1AA4

loc_1A75:				; CODE XREF: _dtls1_retransmit_buffered_messages+B9j
		lea	eax, [esp+40h+var_24]
		push	eax
		call	_pqueue_next
		add	esp, 4
		test	eax, eax
		jnz	loc_1858
		mov	ebp, 1

loc_1A8F:				; CODE XREF: _dtls1_retransmit_buffered_messages+43j
		pop	edi
		pop	esi
		mov	eax, ebp
		pop	ebp
		pop	ebx
		mov	ecx, [esp+30h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 30h
		retn
; ---------------------------------------------------------------------------

loc_1AA4:				; CODE XREF: _dtls1_retransmit_buffered_messages+27Bj
		push	offset ??_C@_0CD@FMODJFBI@dtls1_retransmit_message?$CI?$CJ?5faile@ ; "dtls1_retransmit_message() failed\n"
		push	2
		call	dword ptr ds:__imp____acrt_iob_func
		add	esp, 4
		push	eax		; File
		call	_fprintf
		mov	ecx, [esp+48h+var_4]
		add	esp, 8
		or	eax, 0FFFFFFFFh
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 30h
		retn
_dtls1_retransmit_buffered_messages endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1AD4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_retransmit_message
_dtls1_retransmit_message proc near

var_26		= word ptr -26h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= qword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_C		= dword	ptr  10h

		mov	eax, 28h ; '('
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+28h+var_4], eax
		mov	ecx, [esp+28h+arg_4]
		xorps	xmm0, xmm0
		push	ebx
		mov	ebx, [esp+2Ch+arg_0]
		mov	eax, ecx
		shr	eax, 8
		movq	[esp+2Ch+var_C], xmm0
		mov	byte ptr [esp+2Ch+var_C+6], al
		lea	eax, [esp+2Ch+var_C]
		push	esi
		mov	esi, [esp+30h+arg_C]
		push	eax
		mov	eax, [ebx+5Ch]
		mov	byte ptr [esp+34h+var_C+7], cl
		push	dword ptr [eax+248h]
		call	_pqueue_find
		add	esp, 8
		test	eax, eax
		jnz	short loc_1B61
		mov	eax, [esp+30h+arg_4]
		movzx	eax, ax
		push	eax
		push	offset ??_C@_0CG@JAOANJGB@retransmit?3?5?5message?5?$CFd?5non?9exis@ ; "retransmit:  message %d	non-existant\n"
		push	2
		call	dword ptr ds:__imp____acrt_iob_func
		add	esp, 4
		push	eax		; File
		call	_fprintf
		add	esp, 0Ch
		mov	dword ptr [esi], 0
		xor	eax, eax
		pop	esi
		pop	ebx
		mov	ecx, [esp+28h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 28h
		retn
; ---------------------------------------------------------------------------

loc_1B61:				; CODE XREF: _dtls1_retransmit_message+51j
		mov	dword ptr [esi], 1
		mov	esi, 0Ch
		push	ebp
		mov	ebp, [eax+8]
		mov	eax, 1
		push	edi
		cmp	dword ptr [ebp+14h], 0
		cmovnz	esi, eax
		mov	eax, [ebp+4]
		add	eax, esi
		push	eax		; Size
		mov	eax, [ebx+3Ch]
		push	dword ptr [ebp+2Ch] ; Src
		push	dword ptr [eax+4] ; Dst
		call	_memcpy
		mov	eax, [ebp+4]
		add	esp, 0Ch
		add	eax, esi
		mov	esi, [ebx+5Ch]
		mov	[ebx+44h], eax
		movzx	edx, word ptr [ebp+8]
		mov	al, [ebp+0]
		mov	ecx, [ebp+4]
		mov	edi, [ebp+10h]
		mov	[esi+264h], ecx
		mov	[esi+260h], al
		mov	[esi+268h], dx
		mov	dword ptr [esi+26Ch], 0
		mov	[esi+270h], edi
		mov	eax, [ebx+8Ch]
		mov	[esp+38h+var_24], eax
		mov	eax, [ebx+90h]
		mov	[esp+38h+var_20], eax
		mov	eax, [ebx+94h]
		mov	[esp+38h+var_1C], eax
		mov	eax, [ebx+0C0h]
		mov	[esp+38h+var_18], eax
		mov	eax, [ebx+5Ch]
		mov	dx, [eax+20Ah]
		mov	dword ptr [eax+2E4h], 1
		mov	eax, [ebp+18h]
		mov	ecx, [ebx+5Ch]
		mov	[ebx+8Ch], eax
		mov	eax, [ebp+1Ch]
		mov	[ebx+90h], eax
		mov	eax, [ebp+20h]
		mov	[ebx+94h], eax
		mov	eax, [ebp+24h]
		mov	[ebx+0C0h], eax
		mov	ax, [ebp+28h]
		mov	[ecx+20Ah], ax
		movzx	eax, word ptr [ebp+28h]
		movzx	ecx, dx
		dec	ecx
		mov	[esp+38h+var_26], dx
		mov	[esp+38h+var_14], ecx
		cmp	eax, ecx
		jnz	short loc_1C72
		mov	edx, [ebx+58h]
		mov	ecx, [ebx+5Ch]
		mov	esi, [edx+54h]
		mov	eax, [ecx+22Ah]
		mov	edi, [edx+58h]
		mov	[edx+54h], eax
		mov	eax, [ecx+22Eh]
		mov	[edx+58h], eax
		jmp	short loc_1C7A
; ---------------------------------------------------------------------------

loc_1C72:				; CODE XREF: _dtls1_retransmit_message+17Cj
		mov	edi, dword ptr [esp+38h+var_C+4]
		mov	esi, dword ptr [esp+38h+var_C]

loc_1C7A:				; CODE XREF: _dtls1_retransmit_message+19Cj
		xor	eax, eax
		cmp	[ebp+14h], eax
		setz	al
		lea	eax, ds:14h[eax*2]
		push	eax
		push	ebx
		call	_dtls1_do_write
		mov	ecx, [ebx+5Ch]
		add	esp, 8
		mov	[esp+38h+var_10], eax
		mov	eax, [esp+38h+var_24]
		mov	[ebx+8Ch], eax
		mov	eax, [esp+38h+var_20]
		mov	[ebx+90h], eax
		mov	eax, [esp+38h+var_1C]
		mov	[ebx+94h], eax
		mov	eax, [esp+38h+var_18]
		mov	[ebx+0C0h], eax
		mov	ax, [esp+38h+var_26]
		mov	[ecx+20Ah], ax
		movzx	ecx, word ptr [ebp+28h]
		cmp	ecx, [esp+38h+var_14]
		jnz	short loc_1CF9
		mov	ecx, [ebx+58h]
		mov	edx, [ebx+5Ch]
		mov	eax, [ecx+54h]
		mov	[edx+22Ah], eax
		mov	eax, [ecx+58h]
		mov	[edx+22Eh], eax
		mov	eax, [ebx+58h]
		mov	[eax+54h], esi
		mov	[eax+58h], edi

loc_1CF9:				; CODE XREF: _dtls1_retransmit_message+202j
		mov	eax, [ebx+5Ch]
		push	0
		push	0
		push	0Bh
		push	ebx
		mov	dword ptr [eax+2E4h], 0
		call	_SSL_get_wbio
		add	esp, 4
		push	eax
		call	_BIO_ctrl
		mov	ecx, [esp+48h+var_4]
		add	esp, 10h
		mov	eax, [esp+38h+var_10]
		pop	edi
		pop	ebp
		pop	esi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 28h
		retn
_dtls1_retransmit_message endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1D38h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_dtls1_retrieve_buffered_fragment proc near ; CODE XREF: _dtls1_get_message_fragment+27p
					; _dtls1_get_message_fragment+19Dp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		mov	ebx, [esp+4+arg_8]
		push	ebp
		push	edi
		mov	edi, [esp+0Ch+arg_0]
		mov	dword ptr [ebx], 0
		mov	eax, [edi+5Ch]
		push	dword ptr [eax+244h]
		call	_pqueue_peek
		mov	ebp, eax
		add	esp, 4
		test	ebp, ebp
		jnz	short loc_1D64
		pop	edi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1D64:				; CODE XREF: _dtls1_retrieve_buffered_fragment+26j
		push	esi
		mov	esi, [ebp+8]
		cmp	dword ptr [esi+30h], 0
		jnz	loc_1E12
		mov	ecx, [edi+5Ch]
		mov	ax, [ecx+228h]
		cmp	ax, [esi+8]
		jnz	loc_1E12
		mov	eax, [esi+10h]
		push	dword ptr [ecx+244h]
		mov	[esp+14h+arg_0], eax
		call	_pqueue_pop
		push	[esp+14h+arg_4]
		push	esi
		push	edi
		call	_dtls1_preprocess_fragment
		add	esp, 10h
		mov	[esp+10h+arg_8], eax
		test	eax, eax
		jnz	short loc_1DCB
		mov	ecx, [edi+3Ch]
		push	dword ptr [esi+10h] ; Size
		mov	eax, [esi+0Ch]
		push	dword ptr [esi+2Ch] ; Src
		mov	ecx, [ecx+4]
		add	ecx, 0Ch
		add	eax, ecx
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch

loc_1DCB:				; CODE XREF: _dtls1_retrieve_buffered_fragment+74j
		push	esi
		call	_dtls1_hm_fragment_free
		push	ebp
		call	_pitem_free
		mov	eax, [esp+18h+arg_8]
		add	esp, 8
		test	eax, eax
		jnz	short loc_1DF1
		mov	eax, [esp+10h+arg_0]
		pop	esi
		pop	edi
		pop	ebp
		mov	dword ptr [ebx], 1
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1DF1:				; CODE XREF: _dtls1_retrieve_buffered_fragment+A8j
		push	eax
		push	2
		push	edi
		call	_ssl3_send_alert
		add	esp, 0Ch
		mov	dword ptr [edi+44h], 0
		mov	dword ptr [ebx], 0
		or	eax, 0FFFFFFFFh
		pop	esi
		pop	edi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1E12:				; CODE XREF: _dtls1_retrieve_buffered_fragment+34j
					; _dtls1_retrieve_buffered_fragment+48j
		pop	esi
		pop	edi
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
_dtls1_retrieve_buffered_fragment endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1E1Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_send_change_cipher_spec
_dtls1_send_change_cipher_spec proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, [esi+34h]
		cmp	eax, [esp+4+arg_4]
		jnz	loc_1ECE
		mov	eax, [esi+3Ch]
		mov	edx, [eax+4]
		mov	byte ptr [edx],	1
		mov	ecx, [esi+5Ch]
		mov	ax, [ecx+226h]
		mov	[ecx+224h], ax
		cmp	dword ptr [esi], 100h
		mov	dword ptr [esi+44h], 1
		jnz	short loc_1E7F
		mov	eax, [esi+5Ch]
		inc	word ptr [eax+226h]
		mov	eax, [esi+5Ch]
		movzx	eax, byte ptr [eax+225h]
		mov	[edx+1], al
		mov	eax, [esi+5Ch]
		movzx	eax, byte ptr [eax+224h]
		mov	[edx+2], al
		add	dword ptr [esi+44h], 2

loc_1E7F:				; CODE XREF: _dtls1_send_change_cipher_spec+39j
		mov	ecx, [esi+5Ch]
		mov	dword ptr [esi+48h], 0
		push	1
		push	esi
		movzx	eax, word ptr [ecx+224h]
		mov	byte ptr [ecx+260h], 1
		mov	dword ptr [ecx+264h], 0
		mov	[ecx+268h], ax
		mov	dword ptr [ecx+26Ch], 0
		mov	dword ptr [ecx+270h], 0
		call	_dtls1_buffer_message
		mov	eax, [esp+0Ch+arg_8]
		add	esp, 8
		mov	[esi+34h], eax

loc_1ECE:				; CODE XREF: _dtls1_send_change_cipher_spec+Cj
		push	14h
		push	esi
		call	_dtls1_do_write
		add	esp, 8
		pop	esi
		retn
_dtls1_send_change_cipher_spec endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1EDCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_set_message_header
_dtls1_set_message_header proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= byte ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	edx, [esp+arg_0]
		push	esi
		mov	esi, [esp+4+arg_10]
		test	esi, esi
		jnz	short loc_1F0D
		mov	ecx, [edx+5Ch]
		cmp	dword ptr [ecx+254h], 0
		jnz	short loc_1F0D
		mov	ax, [ecx+226h]
		mov	[ecx+224h], ax
		mov	eax, [edx+5Ch]
		inc	word ptr [eax+226h]

loc_1F0D:				; CODE XREF: _dtls1_set_message_header+Bj
					; _dtls1_set_message_header+17j
		mov	edx, [edx+5Ch]
		mov	al, [esp+4+arg_8]
		movzx	ecx, word ptr [edx+224h]
		mov	[edx+260h], al
		mov	eax, [esp+4+arg_C]
		mov	[edx+264h], eax
		mov	eax, [esp+4+arg_14]
		mov	[edx+270h], eax
		mov	eax, [esp+4+arg_4]
		mov	[edx+26Ch], esi
		add	eax, 0Ch
		mov	[edx+268h], cx
		pop	esi
		retn
_dtls1_set_message_header endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1F4Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_dtls1_set_message_header_int proc near

arg_0		= dword	ptr  4
arg_4		= byte ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= word ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	eax, [esp+arg_0]
		mov	ecx, [eax+5Ch]
		mov	al, [esp+arg_4]
		mov	[ecx+260h], al
		mov	eax, [esp+arg_8]
		mov	[ecx+264h], eax
		mov	ax, [esp+arg_C]
		mov	[ecx+268h], ax
		mov	eax, [esp+arg_10]
		mov	[ecx+26Ch], eax
		mov	eax, [esp+arg_14]
		mov	[ecx+270h], eax
		retn
_dtls1_set_message_header_int endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1F88h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dtls1_shutdown
_dtls1_shutdown	proc near
		jmp	_ssl3_shutdown
_dtls1_shutdown	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1F90h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_dtls1_write_message_header proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_4]
		mov	eax, [esp+arg_0]
		mov	edx, [eax+5Ch]
		movzx	eax, byte ptr [edx+260h]
		add	edx, 260h
		mov	[ecx], al
		movzx	eax, byte ptr [edx+6]
		mov	[ecx+1], al
		movzx	eax, byte ptr [edx+5]
		mov	[ecx+2], al
		movzx	eax, byte ptr [edx+4]
		mov	[ecx+3], al
		movzx	eax, byte ptr [edx+9]
		mov	[ecx+4], al
		movzx	eax, byte ptr [edx+8]
		mov	[ecx+5], al
		movzx	eax, byte ptr [edx+0Eh]
		mov	[ecx+6], al
		movzx	eax, byte ptr [edx+0Dh]
		mov	[ecx+7], al
		movzx	eax, byte ptr [edx+0Ch]
		mov	[ecx+8], al
		movzx	eax, byte ptr [edx+12h]
		mov	[ecx+9], al
		movzx	eax, byte ptr [edx+11h]
		mov	[ecx+0Ah], al
		movzx	eax, byte ptr [edx+10h]
		mov	[ecx+0Bh], al
		lea	eax, [ecx+0Ch]
		retn
_dtls1_write_message_header endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1FFCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int fprintf(FILE *File, const	char *Format, ...)
		public _fprintf
_fprintf	proc near		; CODE XREF: _dtls1_read_failed+24p
					; _dtls1_retransmit_buffered_messages+B1p ...

File		= dword	ptr  4
Format		= dword	ptr  8
arg_8		= byte ptr  0Ch

		lea	eax, [esp+arg_8]
		push	eax
		push	0
		push	[esp+8+Format]
		push	[esp+0Ch+File]
		call	___local_stdio_printf_options
		push	dword ptr [eax+4]
		push	dword ptr [eax]
		call	dword ptr ds:__imp____stdio_common_vfprintf
		add	esp, 18h
		retn
_fprintf	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2020h
; COMDAT (pick any)
		public ??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@
; `string'
??_C@_0BA@CHFBCHML@?4?2ssl?2d1_both?4c?$AA@ db '.\ssl\d1_both.c',0
					; DATA XREF: _dtls1_buffer_message+2Do
					; _dtls1_buffer_message+44o ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2030h
; COMDAT (pick any)
		public ??_C@_0BP@ICKAAGNH@s?9?$DOd1?9?$DOmtu?5?$DO?$DN?5dtls1_min_mtu?$CIs?$CJ?$AA@
; `string'
??_C@_0BP@ICKAAGNH@s?9?$DOd1?9?$DOmtu?5?$DO?$DN?5dtls1_min_mtu?$CIs?$CJ?$AA@ db	's->d1->mtu >= dtls1_min_mtu(s)',0
					; DATA XREF: _dtls1_do_write+56o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 2050h
; COMDAT (pick any)
		public ??_C@_0EG@CCIHJLOA@s?9?$DOinit_num?5?$DN?$DN?5?$CIint?$CJs?9?$DOd1?9?$DOw_msg@
; `string'
??_C@_0EG@CCIHJLOA@s?9?$DOinit_num?5?$DN?$DN?5?$CIint?$CJs?9?$DOd1?9?$DOw_msg@ db 's->init_num == (int)s->d1->w_msg_hdr.msg_len + DTLS1_HM_HEADER_LE'
					; DATA XREF: _dtls1_do_write+8Eo
		db 'NGTH',0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2098h
; COMDAT (pick any)
		public ??_C@_0BJ@DFLCCFFN@len?5?$DN?$DN?5?$CIunsigned?5int?$CJret?$AA@
; `string'
??_C@_0BJ@DFLCCFFN@len?5?$DN?$DN?5?$CIunsigned?5int?$CJret?$AA@	db 'len == (unsigned int)ret',0
					; DATA XREF: _dtls1_do_write+2FDo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20B4h
; COMDAT (pick any)
		public ??_C@_0BN@LINMFPNB@?$CI?$CIlong?$CJmsg_hdr?9?$DOmsg_len?$CJ?5?$DO?50?$AA@
; `string'
??_C@_0BN@LINMFPNB@?$CI?$CIlong?$CJmsg_hdr?9?$DOmsg_len?$CJ?5?$DO?50?$AA@ db '((long)msg_hdr->msg_len) > 0',0
					; DATA XREF: _dtls1_reassemble_fragment+224o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20D4h
; COMDAT (pick any)
		public ??_C@_0N@BMFCCKCA@item?5?$CB?$DN?5NULL?$AA@
; `string'
??_C@_0N@BMFCCKCA@item?5?$CB?$DN?5NULL?$AA@ db 'item != NULL',0
					; DATA XREF: _dtls1_process_out_of_seq_message+1ADo
					; _dtls1_reassemble_fragment+2B6o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20E4h
; COMDAT (pick any)
		public ??_C@_0BM@PPAKALD@invalid?5state?5reached?5?$CFs?3?$CFd?$AA@
; char `string'[]
??_C@_0BM@PPAKALD@invalid?5state?5reached?5?$CFs?3?$CFd?$AA@ db	'invalid state reached %s:%d',0
					; DATA XREF: _dtls1_read_failed+13o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2100h
; COMDAT (pick any)
		public ??_C@_0CD@FMODJFBI@dtls1_retransmit_message?$CI?$CJ?5faile@
; char `string'[]
??_C@_0CD@FMODJFBI@dtls1_retransmit_message?$CI?$CJ?5faile@ db 'dtls1_retransmit_message() failed',0Ah,0
					; DATA XREF: _dtls1_retransmit_buffered_messages:loc_1AA4o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2124h
; COMDAT (pick any)
		public ??_C@_0BB@JNHBKAGH@s?9?$DOinit_off?5?$DN?$DN?50?$AA@
; `string'
??_C@_0BB@JNHBKAGH@s?9?$DOinit_off?5?$DN?$DN?50?$AA@ db	's->init_off == 0',0
					; DATA XREF: _dtls1_buffer_message+23o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 2138h
; COMDAT (pick any)
		public ??_C@_0HA@GEKIBMBM@s?9?$DOd1?9?$DOw_msg_hdr?4msg_len?5?$CL?5?$CI?$CIs?9?$DO@
; `string'
??_C@_0HA@GEKIBMBM@s?9?$DOd1?9?$DOw_msg_hdr?4msg_len?5?$CL?5?$CI?$CIs?9?$DO@ db	's->d1->w_msg_hdr.msg_len + ((s->version==DTLS1_BAD_VER)?3:DTLS1_C'
					; DATA XREF: _dtls1_buffer_message+D8o
		db 'CS_HEADER_LENGTH) == (unsigned int)s->init_num',0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 21A8h
; COMDAT (pick any)
		public ??_C@_0EP@GFDKHMFP@s?9?$DOd1?9?$DOw_msg_hdr?4msg_len?5?$CL?5DTLS1@
; `string'
??_C@_0EP@GFDKHMFP@s?9?$DOd1?9?$DOw_msg_hdr?4msg_len?5?$CL?5DTLS1@ db 's->d1->w_msg_hdr.msg_len + DTLS1_HM_HEADER_LENGTH == (unsigned in'
					; DATA XREF: _dtls1_buffer_message+F2o
		db 't)s->init_num',0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 21F8h
; COMDAT (pick any)
		public ??_C@_0CG@JAOANJGB@retransmit?3?5?5message?5?$CFd?5non?9exis@
; char `string'[]
??_C@_0CG@JAOANJGB@retransmit?3?5?5message?5?$CFd?5non?9exis@ db 'retransmit:  message %d non-existant',0Ah,0
					; DATA XREF: _dtls1_retransmit_buffered_messages+A0o
					; _dtls1_retransmit_message+5Bo
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __imp____acrt_iob_func:near ; CODE XREF: _dtls1_read_failed+1Ap
					; _dtls1_retransmit_buffered_messages+A7p ...
		extrn __imp____stdio_common_vfprintf:near ; CODE XREF: __vfprintf_l+1Ap
					; _fprintf+19p
					; DATA XREF: ...
		extrn _BUF_MEM_grow_clean:near ; CODE XREF: _dtls1_preprocess_fragment+5Ep
		extrn _CRYPTO_malloc:near ; CODE XREF: _dtls1_buffer_message+4Bp
					; _dtls1_buffer_message+68p ...
		extrn _CRYPTO_free:near	; CODE XREF: _dtls1_buffer_message+77p
					; _dtls1_clear_record_buffer+44p ...
		extrn _OpenSSLDie:near	; CODE XREF: _dtls1_buffer_message+32p
					; _dtls1_buffer_message+101p ...
		extrn _BIO_set_flags:near ; CODE XREF: _dtls1_read_failed+6Ap
		extrn _BIO_ctrl:near	; CODE XREF: _dtls1_do_write+3Cp
					; _dtls1_do_write+17Ep	...
		extrn _ERR_put_error:near ; CODE XREF: _dtls1_get_message+D3p
					; _dtls1_get_message_fragment+2E6p ...
		extrn _EVP_MD_size:near	; CODE XREF: _dtls1_do_write+D7p
		extrn _EVP_MD_CTX_md:near ; CODE XREF: _dtls1_do_write+D1p
		extrn _EVP_CIPHER_block_size:near ; CODE XREF: _dtls1_do_write+113p
		extrn _EVP_CIPHER_CTX_flags:near ; CODE	XREF: _dtls1_do_write+B9p
					; _dtls1_do_write+F9p
		extrn _EVP_MD_CTX_destroy:near ; CODE XREF: _dtls1_clear_record_buffer+34p
					; _dtls1_hm_fragment_free+16p
		extrn _EVP_CIPHER_CTX_free:near	; CODE XREF: _dtls1_clear_record_buffer+2Cp
					; _dtls1_hm_fragment_free+Ep
		extrn _pitem_new:near	; CODE XREF: _dtls1_buffer_message+1A3p
					; _dtls1_process_out_of_seq_message+18Bp ...
		extrn _pitem_free:near	; CODE XREF: _dtls1_clear_record_buffer+63p
					; _dtls1_retrieve_buffered_fragment+9Ap
		extrn _pqueue_insert:near ; CODE XREF: _dtls1_buffer_message+1C4p
					; _dtls1_process_out_of_seq_message+1A1p ...
		extrn _pqueue_peek:near	; CODE XREF: _dtls1_retrieve_buffered_fragment+1Ap
		extrn _pqueue_pop:near	; CODE XREF: _dtls1_clear_record_buffer+Fp
					; _dtls1_clear_record_buffer+71p ...
		extrn _pqueue_find:near	; CODE XREF: _dtls1_process_out_of_seq_message+70p
					; _dtls1_reassemble_fragment+96p ...
		extrn _pqueue_iterator:near
					; CODE XREF: _dtls1_retransmit_buffered_messages+26p
		extrn _pqueue_next:near	; CODE XREF: _dtls1_retransmit_buffered_messages+34p
					; _dtls1_retransmit_buffered_messages+282p
		extrn _SSL_get_rbio:near ; CODE	XREF: _dtls1_read_failed+61p
		extrn _SSL_get_wbio:near ; CODE	XREF: _dtls1_do_write+33p
					; _dtls1_do_write+175p	...
		extrn _SSL_ctrl:near	; CODE XREF: _dtls1_do_write+2C8p
					; _dtls1_query_mtu+7Dp
		extrn _SSL_state:near	; CODE XREF: _dtls1_heartbeat+37p
					; _dtls1_read_failed+46p
		extrn _ssl3_send_alert:near ; CODE XREF: _dtls1_get_message+E0p
					; _dtls1_get_message_fragment+2F2p ...
		extrn _ssl3_finish_mac:near ; CODE XREF: _dtls1_do_write+3B4p
					; _dtls1_get_message+14Dp
		extrn _ssl3_shutdown:near ; CODE XREF: _dtls1_shutdownj
		extrn _dtls1_write_bytes:near ;	CODE XREF: _dtls1_do_write+288p
					; _dtls1_heartbeat+B2p	...
		extrn _dtls1_handle_timeout:near ; CODE	XREF: _dtls1_read_failed+78p
		extrn _dtls1_start_timer:near ;	CODE XREF: _dtls1_heartbeat+DAp
		extrn _dtls1_stop_timer:near ; CODE XREF: _dtls1_process_heartbeat+156p
		extrn _dtls1_is_timer_expired:near ; CODE XREF:	_dtls1_read_failed+39p
		extrn _RAND_pseudo_bytes:near ;	CODE XREF: _dtls1_heartbeat+8Ep
					; _dtls1_heartbeat+A0p	...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _dtls1_buffer_message+8Bp
					; _dtls1_buffer_message+1DBp ...
		extrn __chkstk:near	; CODE XREF: _dtls1_buffer_message+5p
					; _dtls1_do_write+5p ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _dtls1_buffer_message+A8p
					; _dtls1_process_heartbeat+CBp	...
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _dtls1_get_message+72p
					; _dtls1_get_message+172p ...
; `__local_stdio_printf_options'::`2'::_OptionsStorage
		extrn ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:near
					; DATA XREF: ___local_stdio_printf_optionso
		extrn ___security_cookie:near ;	DATA XREF: _dtls1_buffer_message+Ar
					; _dtls1_get_message_fragment+Ar ...


		end
