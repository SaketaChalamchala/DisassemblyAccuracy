;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	5953C80DE9E3745C08AE571C13710C97
; Input	CRC32 :	93B71234

; File Name   :	C:\compspace\Diff\openssl\obj\s3_both.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_freelist_extract proc near		; CODE XREF: _ssl3_setup_read_buffer+5Cp
					; _ssl3_setup_write_buffer+5Cp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		push	edi
		push	25Bh
		push	offset ??_C@_0BA@MMNFJFNM@?4?2ssl?2s3_both?4c?$AA@ ; ".\\ssl\\s3_both.c"
		push	0Ch
		push	9
		xor	esi, esi
		call	_CRYPTO_lock
		mov	eax, [esp+18h+arg_0]
		add	esp, 10h
		cmp	[esp+8+arg_4], esi
		jz	short loc_2C
		mov	ecx, [eax+160h]
		jmp	short loc_32
; ---------------------------------------------------------------------------

loc_2C:					; CODE XREF: _freelist_extract+22j
		mov	ecx, [eax+15Ch]

loc_32:					; CODE XREF: _freelist_extract+2Aj
		mov	edi, [esp+8+arg_8]
		test	ecx, ecx
		jz	short loc_58
		cmp	edi, [ecx]
		jnz	short loc_58
		mov	edx, [ecx+8]
		test	edx, edx
		jz	short loc_58
		mov	eax, [edx]
		mov	esi, edx
		add	dword ptr [ecx+4], 0FFFFFFFFh
		mov	[ecx+8], eax
		jnz	short loc_58
		mov	dword ptr [ecx], 0

loc_58:					; CODE XREF: _freelist_extract+38j
					; _freelist_extract+3Cj ...
		push	265h
		push	offset ??_C@_0BA@MMNFJFNM@?4?2ssl?2s3_both?4c?$AA@ ; ".\\ssl\\s3_both.c"
		push	0Ch
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h
		test	esi, esi
		jnz	short loc_88
		push	267h
		push	offset ??_C@_0BA@MMNFJFNM@?4?2ssl?2s3_both?4c?$AA@ ; ".\\ssl\\s3_both.c"
		push	edi
		call	_CRYPTO_malloc
		add	esp, 0Ch
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_88:					; CODE XREF: _freelist_extract+70j
		pop	edi
		mov	eax, esi
		pop	esi
		retn
_freelist_extract endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 90h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_freelist_insert proc near		; CODE XREF: _ssl3_release_read_buffer+21p
					; _ssl3_release_write_buffer+21p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	270h
		push	offset ??_C@_0BA@MMNFJFNM@?4?2ssl?2s3_both?4c?$AA@ ; ".\\ssl\\s3_both.c"
		push	0Ch
		push	9
		call	_CRYPTO_lock
		mov	ecx, [esp+10h+arg_0]
		add	esp, 10h
		cmp	[esp+arg_4], 0
		jz	short loc_B9
		mov	edx, [ecx+160h]
		jmp	short loc_BF
; ---------------------------------------------------------------------------

loc_B9:					; CODE XREF: _freelist_insert+1Fj
		mov	edx, [ecx+15Ch]

loc_BF:					; CODE XREF: _freelist_insert+27j
		push	esi
		test	edx, edx
		jz	short loc_F7
		mov	eax, [edx]
		mov	esi, [esp+4+arg_8]
		cmp	esi, eax
		jz	short loc_D2
		test	eax, eax
		jnz	short loc_F7

loc_D2:					; CODE XREF: _freelist_insert+3Cj
		mov	eax, [edx+4]
		cmp	eax, [ecx+158h]
		jnb	short loc_F7
		cmp	esi, 4
		jb	short loc_F7
		mov	ecx, [esp+4+arg_C]
		mov	eax, [edx+8]
		mov	[edx], esi
		mov	[ecx], eax
		inc	dword ptr [edx+4]
		xor	esi, esi
		mov	[edx+8], ecx
		jmp	short loc_FB
; ---------------------------------------------------------------------------

loc_F7:					; CODE XREF: _freelist_insert+32j
					; _freelist_insert+40j	...
		mov	esi, [esp+4+arg_C]

loc_FB:					; CODE XREF: _freelist_insert+65j
		push	27Dh
		push	offset ??_C@_0BA@MMNFJFNM@?4?2ssl?2s3_both?4c?$AA@ ; ".\\ssl\\s3_both.c"
		push	0Ch
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h
		test	esi, esi
		jz	short loc_11E
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_11E:				; CODE XREF: _freelist_insert+83j
		pop	esi
		retn
_freelist_insert endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 120h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl3_do_write
_ssl3_do_write	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		mov	ebx, [esp+4+arg_4]
		push	esi
		mov	esi, [esp+8+arg_0]
		push	edi
		mov	eax, [esi+3Ch]
		push	dword ptr [esi+44h]
		mov	eax, [eax+4]
		add	eax, [esi+48h]
		push	eax
		push	ebx
		push	esi
		call	_ssl3_write_bytes
		mov	edi, eax
		add	esp, 10h
		test	edi, edi
		jns	short loc_14F
		pop	edi
		pop	esi
		or	eax, 0FFFFFFFFh
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_14F:				; CODE XREF: _ssl3_do_write+26j
		cmp	ebx, 16h
		jnz	short loc_168
		mov	eax, [esi+3Ch]
		push	edi
		mov	eax, [eax+4]
		add	eax, [esi+48h]
		push	eax
		push	esi
		call	_ssl3_finish_mac
		add	esp, 0Ch

loc_168:				; CODE XREF: _ssl3_do_write+32j
		mov	ecx, [esi+44h]
		cmp	edi, ecx
		jnz	short loc_199
		mov	edx, [esi+64h]
		test	edx, edx
		jz	short loc_190
		push	dword ptr [esi+68h]
		mov	eax, [esi+48h]
		push	esi
		add	eax, ecx
		push	eax
		mov	eax, [esi+3Ch]
		push	dword ptr [eax+4]
		push	ebx
		push	dword ptr [esi]
		push	1
		call	edx
		add	esp, 1Ch

loc_190:				; CODE XREF: _ssl3_do_write+54j
		pop	edi
		pop	esi
		mov	eax, 1
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_199:				; CODE XREF: _ssl3_do_write+4Dj
		add	[esi+48h], edi
		sub	ecx, edi
		pop	edi
		mov	[esi+44h], ecx
		xor	eax, eax
		pop	esi
		pop	ebx
		retn
_ssl3_do_write	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1A8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl3_get_finished
_ssl3_get_finished proc	near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_0]
		lea	ecx, [esp+4+arg_0]
		push	ecx
		push	40h ; '@'
		push	14h
		push	[esp+10h+arg_8]
		mov	eax, [esi+8]
		push	[esp+14h+arg_4]
		push	esi
		mov	eax, [eax+30h]
		call	eax
		add	esp, 18h
		mov	ecx, eax
		cmp	[esp+4+arg_0], 0
		jz	loc_307
		mov	eax, [esi+58h]
		push	ebx
		push	edi
		cmp	dword ptr [eax+180h], 0
		jnz	short loc_1FB
		push	101h
		push	offset ??_C@_0BA@MMNFJFNM@?4?2ssl?2s3_both?4c?$AA@ ; ".\\ssl\\s3_both.c"
		mov	edi, 0Ah
		push	9Ah ; 'š'
		jmp	short loc_24F
; ---------------------------------------------------------------------------

loc_1FB:				; CODE XREF: _ssl3_get_finished+3Bj
		mov	dword ptr [eax+180h], 0
		mov	eax, [esi+58h]
		mov	ebx, [eax+338h]
		cmp	ebx, ecx
		jz	short loc_225
		push	10Bh
		push	offset ??_C@_0BA@MMNFJFNM@?4?2ssl?2s3_both?4c?$AA@ ; ".\\ssl\\s3_both.c"
		mov	edi, 32h ; '2'
		push	6Fh ; 'o'
		jmp	short loc_24F
; ---------------------------------------------------------------------------

loc_225:				; CODE XREF: _ssl3_get_finished+68j
		push	ebx
		add	eax, 2B8h
		push	eax
		push	dword ptr [esi+40h]
		call	_CRYPTO_memcmp
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_270
		push	111h
		push	offset ??_C@_0BA@MMNFJFNM@?4?2ssl?2s3_both?4c?$AA@ ; ".\\ssl\\s3_both.c"
		mov	edi, 33h ; '3'
		push	95h ; '•'

loc_24F:				; CODE XREF: _ssl3_get_finished+51j
					; _ssl3_get_finished+7Bj
		push	8Ch ; 'Œ'
		push	14h
		call	_ERR_put_error
		add	esp, 14h

$f_err$18:
		push	edi
		push	2
		push	esi
		call	_ssl3_send_alert
		add	esp, 0Ch
		xor	eax, eax
		pop	edi
		pop	ebx
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_270:				; CODE XREF: _ssl3_get_finished+91j
		cmp	dword ptr [esi+4], 2000h
		jnz	short loc_2C1
		cmp	ebx, 40h ; '@'
		jle	short loc_295
		push	offset ??_C@_0BF@MDPNEINP@i?5?$DM?$DN?5EVP_MAX_MD_SIZE?$AA@ ; "i <= EVP_MAX_MD_SIZE"
		push	119h
		push	offset ??_C@_0BA@MMNFJFNM@?4?2ssl?2s3_both?4c?$AA@ ; ".\\ssl\\s3_both.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_295:				; CODE XREF: _ssl3_get_finished+D4j
		mov	ecx, [esi+58h]
		push	ebx		; Size
		lea	eax, [ecx+2B8h]
		push	eax		; Src
		lea	eax, [ecx+394h]
		push	eax		; Dst
		call	_memcpy
		mov	eax, [esi+58h]
		add	esp, 0Ch
		pop	edi
		mov	[eax+3D4h], bl
		mov	eax, 1
		pop	ebx
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_2C1:				; CODE XREF: _ssl3_get_finished+CFj
		cmp	ebx, 40h ; '@'
		jle	short loc_2DD
		push	offset ??_C@_0BF@MDPNEINP@i?5?$DM?$DN?5EVP_MAX_MD_SIZE?$AA@ ; "i <= EVP_MAX_MD_SIZE"
		push	11Dh
		push	offset ??_C@_0BA@MMNFJFNM@?4?2ssl?2s3_both?4c?$AA@ ; ".\\ssl\\s3_both.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_2DD:				; CODE XREF: _ssl3_get_finished+11Cj
		mov	ecx, [esi+58h]
		push	ebx		; Size
		lea	eax, [ecx+2B8h]
		push	eax		; Src
		lea	eax, [ecx+3D5h]
		push	eax		; Dst
		call	_memcpy
		mov	eax, [esi+58h]
		add	esp, 0Ch
		mov	[eax+415h], bl
		mov	eax, 1
		pop	edi
		pop	ebx

loc_307:				; CODE XREF: _ssl3_get_finished+29j
		pop	esi
		retn
_ssl3_get_finished endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 30Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl3_get_message
_ssl3_get_message proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		push	ebx
		push	esi
		mov	esi, [esp+8+arg_0]
		push	edi
		mov	eax, [esi+58h]
		cmp	dword ptr [eax+354h], 0
		jz	short loc_382
		mov	ecx, [esp+0Ch+arg_C]
		mov	dword ptr [eax+354h], 0
		test	ecx, ecx
		js	short loc_355
		mov	eax, [esi+58h]
		cmp	[eax+340h], ecx
		jz	short loc_355
		push	162h
		push	offset ??_C@_0BA@MMNFJFNM@?4?2ssl?2s3_both?4c?$AA@ ; ".\\ssl\\s3_both.c"
		mov	edi, 0Ah
		push	0F4h ; 'ô'
		jmp	loc_4A0
; ---------------------------------------------------------------------------

loc_355:				; CODE XREF: _ssl3_get_message+23j
					; _ssl3_get_message+2Ej
		mov	eax, [esp+0Ch+arg_14]
		pop	edi
		mov	dword ptr [eax], 1
		mov	eax, [esp+8+arg_8]
		mov	[esi+34h], eax
		mov	eax, [esi+3Ch]
		mov	eax, [eax+4]
		add	eax, 4
		mov	[esi+40h], eax
		mov	eax, [esi+58h]
		mov	eax, [eax+33Ch]
		mov	[esi+44h], eax
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_382:				; CODE XREF: _ssl3_get_message+11j
		mov	eax, [esi+3Ch]
		mov	edi, [eax+4]
		mov	eax, [esi+34h]
		cmp	eax, [esp+0Ch+arg_4]
		jnz	loc_532
		nop	dword ptr [eax+00000000h]

loc_39C:				; CODE XREF: _ssl3_get_message+F7j
					; _ssl3_get_message+10Bj
		cmp	dword ptr [esi+44h], 4
		jge	short loc_3DA
		db	66h, 66h
		nop	word ptr [eax+eax+00000000h]

loc_3AC:				; CODE XREF: _ssl3_get_message+CCj
		mov	ecx, [esi+44h]
		mov	eax, 4
		mov	edx, [esi+8]
		sub	eax, ecx
		push	0
		push	eax
		lea	eax, [ecx+edi]
		push	eax
		mov	eax, [edx+34h]
		push	16h
		push	esi
		call	eax
		mov	ecx, eax
		add	esp, 14h
		test	ecx, ecx
		jle	short loc_419
		add	[esi+44h], ecx
		cmp	dword ptr [esi+44h], 4
		jl	short loc_3AC

loc_3DA:				; CODE XREF: _ssl3_get_message+94j
		cmp	dword ptr [esi+24h], 0
		jnz	short loc_430
		cmp	byte ptr [edi],	0
		jnz	short loc_430
		cmp	byte ptr [edi+1], 0
		jnz	short loc_430
		cmp	byte ptr [edi+2], 0
		jnz	short loc_430
		cmp	byte ptr [edi+3], 0
		jnz	short loc_430
		mov	eax, [esi+64h]
		mov	dword ptr [esi+44h], 0
		test	eax, eax
		jz	short loc_39C
		push	dword ptr [esi+68h]
		push	esi
		push	4
		push	edi
		push	16h
		push	dword ptr [esi]
		push	0
		call	eax
		add	esp, 1Ch
		jmp	short loc_39C
; ---------------------------------------------------------------------------

loc_419:				; CODE XREF: _ssl3_get_message+C3j
					; _ssl3_get_message+25Bj
		mov	eax, [esp+0Ch+arg_14]
		pop	edi
		mov	dword ptr [esi+18h], 3
		pop	esi
		mov	dword ptr [eax], 0
		mov	eax, ecx
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_430:				; CODE XREF: _ssl3_get_message+D2j
					; _ssl3_get_message+D7j ...
		mov	ecx, [esp+0Ch+arg_C]
		test	ecx, ecx
		js	short loc_455
		movzx	eax, byte ptr [edi]
		cmp	eax, ecx
		jz	short loc_455
		push	196h
		push	offset ??_C@_0BA@MMNFJFNM@?4?2ssl?2s3_both?4c?$AA@ ; ".\\ssl\\s3_both.c"
		mov	edi, 0Ah
		push	0F4h ; 'ô'
		jmp	short loc_4A0
; ---------------------------------------------------------------------------

loc_455:				; CODE XREF: _ssl3_get_message+12Aj
					; _ssl3_get_message+131j
		mov	eax, [esi+58h]
		movzx	ecx, byte ptr [edi]
		mov	[eax+340h], ecx
		movzx	eax, byte ptr [edi+1]
		movzx	ebx, byte ptr [edi+2]
		shl	eax, 8
		or	ebx, eax
		movzx	eax, byte ptr [edi+3]
		shl	ebx, 8
		or	ebx, eax
		cmp	ebx, [esp+0Ch+arg_10]
		jbe	short loc_484
		push	19Fh
		jmp	short loc_491
; ---------------------------------------------------------------------------

loc_484:				; CODE XREF: _ssl3_get_message+16Fj
		cmp	ebx, 7FFFFFFBh
		jbe	short loc_4CC
		push	1A4h

loc_491:				; CODE XREF: _ssl3_get_message+176j
		push	offset ??_C@_0BA@MMNFJFNM@?4?2ssl?2s3_both?4c?$AA@ ; ".\\ssl\\s3_both.c"
		push	98h ; '˜'
		mov	edi, 2Fh ; '/'

loc_4A0:				; CODE XREF: _ssl3_get_message+44j
					; _ssl3_get_message+147j
		push	8Eh ; 'Ž'
		push	14h
		call	_ERR_put_error
		add	esp, 14h

$f_err$43:
		push	edi
		push	2
		push	esi
		call	_ssl3_send_alert
		mov	eax, [esp+18h+arg_14]
		add	esp, 0Ch
		pop	edi
		pop	esi
		mov	dword ptr [eax], 0
		or	eax, 0FFFFFFFFh
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_4CC:				; CODE XREF: _ssl3_get_message+17Ej
		test	ebx, ebx
		jz	short loc_50F
		lea	eax, [ebx+4]
		push	eax
		push	dword ptr [esi+3Ch]
		call	_BUF_MEM_grow_clean
		add	esp, 8
		test	eax, eax
		jnz	short loc_50F
		push	1A8h
		push	offset ??_C@_0BA@MMNFJFNM@?4?2ssl?2s3_both?4c?$AA@ ; ".\\ssl\\s3_both.c"
		push	7
		push	8Eh ; 'Ž'
		push	14h
		call	_ERR_put_error
		add	esp, 14h

$err$44:
		mov	eax, [esp+0Ch+arg_14]
		pop	edi
		pop	esi
		pop	ebx
		mov	dword ptr [eax], 0
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_50F:				; CODE XREF: _ssl3_get_message+1C2j
					; _ssl3_get_message+1D5j
		mov	eax, [esi+58h]
		mov	[eax+33Ch], ebx
		mov	eax, [esp+0Ch+arg_8]
		mov	[esi+34h], eax
		mov	eax, [esi+3Ch]
		mov	eax, [eax+4]
		add	eax, 4
		mov	dword ptr [esi+44h], 0
		mov	[esi+40h], eax

loc_532:				; CODE XREF: _ssl3_get_message+83j
		mov	eax, [esi+58h]
		mov	ebx, [esi+40h]
		mov	edi, [eax+33Ch]
		sub	edi, [esi+44h]
		test	edi, edi
		jle	short loc_576
		nop	dword ptr [eax+00000000h]

loc_54C:				; CODE XREF: _ssl3_get_message+268j
		mov	eax, [esi+44h]
		mov	ecx, [esi+8]
		add	eax, ebx
		push	0
		push	edi
		push	eax
		mov	eax, [ecx+34h]
		push	16h
		push	esi
		call	eax
		mov	ecx, eax
		add	esp, 14h
		test	ecx, ecx
		jle	loc_419
		add	[esi+44h], ecx
		sub	edi, ecx
		test	edi, edi
		jg	short loc_54C

loc_576:				; CODE XREF: _ssl3_get_message+237j
		mov	eax, [esi+3Ch]
		mov	eax, [eax+4]
		cmp	byte ptr [eax],	14h
		jnz	short loc_58A
		push	esi
		call	_ssl3_take_mac
		add	esp, 4

loc_58A:				; CODE XREF: _ssl3_get_message+273j
		mov	eax, [esi+44h]
		add	eax, 4
		push	eax
		mov	eax, [esi+3Ch]
		push	dword ptr [eax+4]
		push	esi
		call	_ssl3_finish_mac
		mov	ecx, [esi+64h]
		add	esp, 0Ch
		test	ecx, ecx
		jz	short loc_5C3
		push	dword ptr [esi+68h]
		mov	eax, [esi+44h]
		push	esi
		add	eax, 4
		push	eax
		mov	eax, [esi+3Ch]
		push	dword ptr [eax+4]
		push	16h
		push	dword ptr [esi]
		push	0
		call	ecx
		add	esp, 1Ch

loc_5C3:				; CODE XREF: _ssl3_get_message+299j
		mov	eax, [esp+0Ch+arg_14]
		pop	edi
		mov	dword ptr [eax], 1
		mov	eax, [esi+44h]
		pop	esi
		pop	ebx
		retn
_ssl3_get_message endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5D4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl3_output_cert_chain
_ssl3_output_cert_chain	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, [esi+8]
		mov	eax, [eax+64h]
		mov	eax, [eax+3Ch]
		add	eax, 3
		mov	[esp+4+arg_0], eax
		lea	eax, [esp+4+arg_0]
		push	eax
		push	[esp+8+arg_4]
		push	esi
		call	_ssl_add_cert_chain
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_601
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_601:				; CODE XREF: _ssl3_output_cert_chain+29j
		mov	edx, [esi+8]
		mov	ecx, 0FFFFFFFDh
		push	ebx
		mov	ebx, [esp+8+arg_0]
		mov	eax, [edx+64h]
		sub	ecx, [eax+3Ch]
		mov	eax, [esi+3Ch]
		add	ebx, ecx
		mov	[esp+8+arg_0], ebx
		mov	ecx, [edx+64h]
		shr	ebx, 10h
		mov	edx, [eax+4]
		add	edx, [ecx+3Ch]
		mov	[edx], bl
		mov	eax, [esp+8+arg_0]
		shr	eax, 8
		mov	[edx+1], al
		mov	al, byte ptr [esp+8+arg_0]
		mov	[edx+2], al
		mov	ecx, [esp+8+arg_0]
		mov	eax, [esi+8]
		add	ecx, 3
		mov	[esp+8+arg_0], ecx
		push	ecx
		push	0Bh
		mov	eax, [eax+64h]
		push	esi
		mov	eax, [eax+40h]
		call	eax
		mov	eax, [esi+8]
		add	esp, 0Ch
		mov	eax, [eax+64h]
		pop	ebx
		pop	esi
		mov	eax, [eax+3Ch]
		add	eax, [esp+arg_0]
		retn
_ssl3_output_cert_chain	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 66Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl3_release_read_buffer
_ssl3_release_read_buffer proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, [esi+58h]
		mov	ecx, [eax+0ECh]
		test	ecx, ecx
		jz	short loc_6A2
		push	ecx
		push	dword ptr [eax+0F0h]
		push	1
		push	dword ptr [esi+0E4h]
		call	_freelist_insert
		mov	eax, [esi+58h]
		add	esp, 10h
		mov	dword ptr [eax+0ECh], 0

loc_6A2:				; CODE XREF: _ssl3_release_read_buffer+10j
		mov	eax, 1
		pop	esi
		retn
_ssl3_release_read_buffer endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6ACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl3_release_write_buffer
_ssl3_release_write_buffer proc	near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, [esi+58h]
		mov	ecx, [eax+0FCh]
		test	ecx, ecx
		jz	short loc_6E2
		push	ecx
		push	dword ptr [eax+100h]
		push	0
		push	dword ptr [esi+0E4h]
		call	_freelist_insert
		mov	eax, [esi+58h]
		add	esp, 10h
		mov	dword ptr [eax+0FCh], 0

loc_6E2:				; CODE XREF: _ssl3_release_write_buffer+10j
		mov	eax, 1
		pop	esi
		retn
_ssl3_release_write_buffer endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6ECh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl3_send_change_cipher_spec
_ssl3_send_change_cipher_spec proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	eax, [esi+34h]
		cmp	eax, [esp+4+arg_4]
		jnz	short loc_718
		mov	eax, [esi+3Ch]
		mov	eax, [eax+4]
		mov	byte ptr [eax],	1
		mov	eax, [esp+4+arg_8]
		mov	dword ptr [esi+44h], 1
		mov	dword ptr [esi+48h], 0
		mov	[esi+34h], eax

loc_718:				; CODE XREF: _ssl3_send_change_cipher_spec+Cj
		mov	eax, [esi+3Ch]
		push	dword ptr [esi+44h]
		mov	eax, [eax+4]
		add	eax, [esi+48h]
		push	eax
		push	14h
		push	esi
		call	_ssl3_write_bytes
		add	esp, 10h
		test	eax, eax
		jns	short loc_739
		or	eax, 0FFFFFFFFh
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_739:				; CODE XREF: _ssl3_send_change_cipher_spec+46j
		mov	ecx, [esi+44h]
		cmp	eax, ecx
		jnz	short loc_769
		mov	edx, [esi+64h]
		test	edx, edx
		jz	short loc_762
		push	dword ptr [esi+68h]
		mov	eax, [esi+48h]
		push	esi
		add	eax, ecx
		push	eax
		mov	eax, [esi+3Ch]
		push	dword ptr [eax+4]
		push	14h
		push	dword ptr [esi]
		push	1
		call	edx
		add	esp, 1Ch

loc_762:				; CODE XREF: _ssl3_send_change_cipher_spec+59j
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_769:				; CODE XREF: _ssl3_send_change_cipher_spec+52j
		add	[esi+48h], eax
		sub	ecx, eax
		mov	[esi+44h], ecx
		xor	eax, eax
		pop	esi
		retn
_ssl3_send_change_cipher_spec endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 778h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl3_send_finished
_ssl3_send_finished proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		push	ebx
		push	esi
		mov	esi, [esp+8+arg_0]
		push	edi
		mov	eax, [esi+34h]
		cmp	eax, [esp+0Ch+arg_4]
		jnz	loc_87C
		mov	eax, [esi+8]
		mov	ecx, [eax+64h]
		mov	eax, [esi+3Ch]
		mov	edi, [eax+4]
		mov	eax, [esi+58h]
		add	edi, [ecx+3Ch]
		add	eax, 234h
		push	eax
		push	[esp+10h+arg_10]
		mov	eax, [ecx+14h]
		push	[esp+14h+arg_C]
		push	esi
		call	eax
		mov	ebx, eax
		add	esp, 10h
		test	ebx, ebx
		jg	short loc_7C1
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_7C1:				; CODE XREF: _ssl3_send_finished+41j
		mov	eax, [esi+58h]
		push	ebx		; Size
		mov	[eax+2B4h], ebx
		mov	eax, [esi+58h]
		add	eax, 234h
		push	eax		; Src
		push	edi		; Dst
		call	_memcpy
		add	esp, 0Ch
		cmp	dword ptr [esi+4], 1000h
		jnz	short loc_824
		cmp	ebx, 40h ; '@'
		jle	short loc_802
		push	offset ??_C@_0BF@MDPNEINP@i?5?$DM?$DN?5EVP_MAX_MD_SIZE?$AA@ ; "i <= EVP_MAX_MD_SIZE"
		push	0B5h ; 'µ'
		push	offset ??_C@_0BA@MMNFJFNM@?4?2ssl?2s3_both?4c?$AA@ ; ".\\ssl\\s3_both.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_802:				; CODE XREF: _ssl3_send_finished+71j
		mov	ecx, [esi+58h]
		push	ebx		; Size
		lea	eax, [ecx+234h]
		push	eax		; Src
		lea	eax, [ecx+394h]
		push	eax		; Dst
		call	_memcpy
		mov	eax, [esi+58h]
		mov	[eax+3D4h], bl
		jmp	short loc_860
; ---------------------------------------------------------------------------

loc_824:				; CODE XREF: _ssl3_send_finished+6Cj
		cmp	ebx, 40h ; '@'
		jle	short loc_840
		push	offset ??_C@_0BF@MDPNEINP@i?5?$DM?$DN?5EVP_MAX_MD_SIZE?$AA@ ; "i <= EVP_MAX_MD_SIZE"
		push	0B9h ; '¹'
		push	offset ??_C@_0BA@MMNFJFNM@?4?2ssl?2s3_both?4c?$AA@ ; ".\\ssl\\s3_both.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_840:				; CODE XREF: _ssl3_send_finished+AFj
		mov	ecx, [esi+58h]
		push	ebx		; Size
		lea	eax, [ecx+234h]
		push	eax		; Src
		lea	eax, [ecx+3D5h]
		push	eax		; Dst
		call	_memcpy
		mov	eax, [esi+58h]
		mov	[eax+415h], bl

loc_860:				; CODE XREF: _ssl3_send_finished+AAj
		mov	eax, [esi+8]
		add	esp, 0Ch
		mov	eax, [eax+64h]
		push	ebx
		push	14h
		push	esi
		mov	eax, [eax+40h]
		call	eax
		mov	eax, [esp+18h+arg_8]
		add	esp, 0Ch
		mov	[esi+34h], eax

loc_87C:				; CODE XREF: _ssl3_send_finished+Ej
		mov	eax, [esi+8]
		push	esi
		mov	eax, [eax+64h]
		mov	eax, [eax+44h]
		call	eax
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		retn
_ssl3_send_finished endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 890h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl3_setup_buffers
_ssl3_setup_buffers proc near

arg_0		= dword	ptr  4

		push	[esp+arg_0]
		call	_ssl3_setup_read_buffer
		add	esp, 4
		test	eax, eax
		jnz	short loc_8A1
		retn
; ---------------------------------------------------------------------------

loc_8A1:				; CODE XREF: _ssl3_setup_buffers+Ej
		push	[esp+arg_0]
		call	_ssl3_setup_write_buffer
		add	esp, 4
		neg	eax
		sbb	eax, eax
		neg	eax
		retn
_ssl3_setup_buffers endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8B4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl3_setup_read_buffer
_ssl3_setup_read_buffer	proc near	; CODE XREF: _ssl3_setup_buffers+4p

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		mov	eax, [esi+8]
		mov	eax, [eax+64h]
		movzx	edi, byte ptr [eax+38h]
		mov	eax, [esi+58h]
		and	edi, 8
		or	edi, 5
		cmp	dword ptr [eax+0ECh], 0
		jnz	short loc_950
		add	edi, 4143h
		test	byte ptr [esi+100h], 20h
		jz	short loc_8F5
		mov	dword ptr [eax+0E8h], 1
		add	edi, 4000h

loc_8F5:				; CODE XREF: _ssl3_setup_read_buffer+2Fj
		test	dword ptr [esi+100h], 20000h
		jnz	short loc_907
		add	edi, 400h

loc_907:				; CODE XREF: _ssl3_setup_read_buffer+4Bj
		push	edi
		push	1
		push	dword ptr [esi+0E4h]
		call	_freelist_extract
		mov	ecx, eax
		add	esp, 0Ch
		test	ecx, ecx
		jnz	short loc_93E

$err$10:
		push	2A9h
		push	offset ??_C@_0BA@MMNFJFNM@?4?2ssl?2s3_both?4c?$AA@ ; ".\\ssl\\s3_both.c"
		push	41h ; 'A'
		push	9Ch ; 'œ'
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_93E:				; CODE XREF: _ssl3_setup_read_buffer+68j
		mov	eax, [esi+58h]
		mov	[eax+0ECh], ecx
		mov	eax, [esi+58h]
		mov	[eax+0F0h], edi

loc_950:				; CODE XREF: _ssl3_setup_read_buffer+20j
		mov	eax, [esi+58h]
		pop	edi
		mov	eax, [eax+0ECh]
		mov	[esi+4Ch], eax
		mov	eax, 1
		pop	esi
		retn
_ssl3_setup_read_buffer	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 964h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl3_setup_write_buffer
_ssl3_setup_write_buffer proc near	; CODE XREF: _ssl3_setup_buffers+15p

arg_0		= dword	ptr  4

		push	esi
		push	edi
		mov	edi, [esp+8+arg_0]
		mov	ecx, 5
		mov	eax, [edi+8]
		mov	eax, [eax+64h]
		test	byte ptr [eax+38h], 8
		mov	eax, 0Eh
		cmovnz	ecx, eax
		mov	eax, [edi+58h]
		cmp	dword ptr [eax+0FCh], 0
		jnz	short loc_A00
		mov	esi, [edi+114h]
		mov	eax, [edi+100h]
		add	esi, 53h ; 'S'
		add	esi, ecx
		test	eax, 20000h
		jnz	short loc_9AB
		add	esi, 400h

loc_9AB:				; CODE XREF: _ssl3_setup_write_buffer+3Fj
		test	eax, 800h
		jnz	short loc_9B7
		add	esi, 53h ; 'S'
		add	esi, ecx

loc_9B7:				; CODE XREF: _ssl3_setup_write_buffer+4Cj
		push	esi
		push	0
		push	dword ptr [edi+0E4h]
		call	_freelist_extract
		mov	ecx, eax
		add	esp, 0Ch
		test	ecx, ecx
		jnz	short loc_9EE

$err$10_0:
		push	2CEh
		push	offset ??_C@_0BA@MMNFJFNM@?4?2ssl?2s3_both?4c?$AA@ ; ".\\ssl\\s3_both.c"
		push	41h ; 'A'
		push	123h
		push	14h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_9EE:				; CODE XREF: _ssl3_setup_write_buffer+68j
		mov	eax, [edi+58h]
		mov	[eax+0FCh], ecx
		mov	eax, [edi+58h]
		mov	[eax+100h], esi

loc_A00:				; CODE XREF: _ssl3_setup_write_buffer+27j
		pop	edi
		mov	eax, 1
		pop	esi
		retn
_ssl3_setup_write_buffer endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A08h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssl3_take_mac	proc near		; CODE XREF: _ssl3_get_message+276p

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	edx, [esi+58h]
		cmp	dword ptr [edx+344h], 0
		jz	short loc_A5B
		test	dword ptr [esi+34h], 1000h
		mov	eax, [esi+8]
		push	ebx
		push	edi
		mov	eax, [eax+64h]
		jz	short loc_A32
		mov	edi, [eax+28h]
		mov	ebx, [eax+2Ch]
		jmp	short loc_A38
; ---------------------------------------------------------------------------

loc_A32:				; CODE XREF: _ssl3_take_mac+20j
		mov	edi, [eax+20h]
		mov	ebx, [eax+24h]

loc_A38:				; CODE XREF: _ssl3_take_mac+28j
		mov	eax, [esi+8]
		mov	ecx, [eax+64h]
		lea	eax, [edx+2B8h]
		push	eax
		push	ebx
		push	edi
		mov	eax, [ecx+14h]
		push	esi
		call	eax
		mov	ecx, [esi+58h]
		add	esp, 10h
		pop	edi
		mov	[ecx+338h], eax
		pop	ebx

loc_A5B:				; CODE XREF: _ssl3_take_mac+Fj
		pop	esi
		retn
_ssl3_take_mac	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A60h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_cert_type
_ssl_cert_type	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		mov	ebx, [esp+4+arg_4]
		push	ebp
		mov	ebp, [esp+8+arg_0]
		push	esi
		or	esi, 0FFFFFFFFh
		push	edi
		test	ebx, ebx
		jnz	short loc_A80
		push	ebp
		call	_X509_get_pubkey
		add	esp, 4
		mov	edi, eax
		jmp	short loc_A82
; ---------------------------------------------------------------------------

loc_A80:				; CODE XREF: _ssl_cert_type+11j
		mov	edi, ebx

loc_A82:				; CODE XREF: _ssl_cert_type+1Ej
		test	edi, edi
		jz	$err$26
		mov	eax, [edi]
		cmp	eax, 6
		jnz	short loc_A95
		xor	esi, esi
		jmp	short $err$26
; ---------------------------------------------------------------------------

loc_A95:				; CODE XREF: _ssl_cert_type+2Fj
		cmp	eax, 74h ; 't'
		jnz	short loc_A9F
		lea	esi, [eax-72h]
		jmp	short $err$26
; ---------------------------------------------------------------------------

loc_A9F:				; CODE XREF: _ssl_cert_type+38j
		cmp	eax, 198h
		jnz	short loc_AAD
		mov	esi, 5
		jmp	short $err$26
; ---------------------------------------------------------------------------

loc_AAD:				; CODE XREF: _ssl_cert_type+44j
		cmp	eax, 32Ch
		jz	short loc_B06
		cmp	eax, 352h
		jz	short loc_B06
		cmp	eax, 32Bh
		jz	short loc_AFF
		cmp	eax, 353h
		jz	short loc_AFF
		test	ebp, ebp
		jz	short $err$26
		cmp	eax, 1Ch
		jz	short loc_AD9
		cmp	eax, 398h
		jnz	short $err$26

loc_AD9:				; CODE XREF: _ssl_cert_type+70j
		push	edi
		push	ebp
		call	_X509_certificate_type
		add	esp, 8
		test	eax, 100h
		jz	short loc_AF1
		mov	esi, 3
		jmp	short $err$26
; ---------------------------------------------------------------------------

loc_AF1:				; CODE XREF: _ssl_cert_type+88j
		test	eax, 200h
		jz	short $err$26
		mov	esi, 4
		jmp	short $err$26
; ---------------------------------------------------------------------------

loc_AFF:				; CODE XREF: _ssl_cert_type+60j
					; _ssl_cert_type+67j
		mov	esi, 7
		jmp	short $err$26
; ---------------------------------------------------------------------------

loc_B06:				; CODE XREF: _ssl_cert_type+52j
					; _ssl_cert_type+59j
		mov	esi, 6

$err$26:				; CODE XREF: _ssl_cert_type+24j
					; _ssl_cert_type+33j ...
		test	ebx, ebx
		jnz	short loc_B18
		push	edi
		call	_EVP_PKEY_free
		add	esp, 4

loc_B18:				; CODE XREF: _ssl_cert_type+ADj
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_ssl_cert_type	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B20h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssl_verify_alarm_type
_ssl_verify_alarm_type proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		add	eax, 0FFFFFFFEh	; switch 49 cases
		cmp	eax, 30h ; '0'
		ja	short $LN13	; jumptable 00000B33 default case
		movzx	eax, ds:$LN15[eax]
		jmp	ds:$LN17[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN4:					; CODE XREF: _ssl_verify_alarm_type+13j
					; DATA XREF: .text$mn:$LN17o
		mov	eax, 30h ; '0'  ; jumptable 00000B33 cases 2,3,18-22,24,25,33
		retn
; ---------------------------------------------------------------------------

$LN5:					; CODE XREF: _ssl_verify_alarm_type+13j
					; DATA XREF: .text$mn:$LN17o
		mov	eax, 2Ah ; '*'  ; jumptable 00000B33 cases 4-6,9,11,13-16,27,28
		retn
; ---------------------------------------------------------------------------

$LN6:					; CODE XREF: _ssl_verify_alarm_type+13j
					; DATA XREF: .text$mn:$LN17o
		mov	eax, 33h ; '3'  ; jumptable 00000B33 cases 7,8
		retn
; ---------------------------------------------------------------------------

$LN7:					; CODE XREF: _ssl_verify_alarm_type+13j
					; DATA XREF: .text$mn:$LN17o
		mov	eax, 2Dh ; '-'  ; jumptable 00000B33 cases 10,12
		retn
; ---------------------------------------------------------------------------

$LN8:					; CODE XREF: _ssl_verify_alarm_type+13j
					; DATA XREF: .text$mn:$LN17o
		mov	eax, 2Ch ; ','  ; jumptable 00000B33 case 23
		retn
; ---------------------------------------------------------------------------

$LN9:					; CODE XREF: _ssl_verify_alarm_type+13j
					; DATA XREF: .text$mn:$LN17o
		mov	eax, 50h ; 'P'  ; jumptable 00000B33 case 17
		retn
; ---------------------------------------------------------------------------

$LN11:					; CODE XREF: _ssl_verify_alarm_type+13j
					; DATA XREF: .text$mn:$LN17o
		mov	eax, 28h ; '('  ; jumptable 00000B33 case 50
		retn
; ---------------------------------------------------------------------------

$LN12:					; CODE XREF: _ssl_verify_alarm_type+13j
					; DATA XREF: .text$mn:$LN17o
		mov	eax, 2Bh ; '+'  ; jumptable 00000B33 case 26
		retn
; ---------------------------------------------------------------------------

$LN13:					; CODE XREF: _ssl_verify_alarm_type+Aj
					; _ssl_verify_alarm_type+13j
					; DATA XREF: ...
		mov	eax, 2Eh ; '.'  ; jumptable 00000B33 default case
		retn
_ssl_verify_alarm_type endp

; ---------------------------------------------------------------------------
$LN17		dd offset $LN4		; DATA XREF: _ssl_verify_alarm_type+13r
		dd offset $LN5		; jump table for switch	statement
		dd offset $LN6
		dd offset $LN7
		dd offset $LN9
		dd offset $LN8
		dd offset $LN12
		dd offset $LN11
		dd offset $LN13
$LN15		db	0,     0,     1,     1 ; DATA XREF: _ssl_verify_alarm_type+Cr
		db	1,     2,     2,     1 ; indirect table	for switch statement
		db	3,     1,     3,     1
		db	1,     1,     1,     4
		db	0,     0,     0,     0
		db	0,     5,     0,     0
		db	6,     1,     1,     8
		db	8,     8,     8,     0
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	8,     8,     8,     8
		db	7
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BC8h
; COMDAT (pick any)
		public ??_C@_0BF@MDPNEINP@i?5?$DM?$DN?5EVP_MAX_MD_SIZE?$AA@
; `string'
??_C@_0BF@MDPNEINP@i?5?$DM?$DN?5EVP_MAX_MD_SIZE?$AA@ db	'i <= EVP_MAX_MD_SIZE',0
					; DATA XREF: _ssl3_get_finished+D6o
					; _ssl3_get_finished+11Eo ...
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BE0h
; COMDAT (pick any)
		public ??_C@_0BA@MMNFJFNM@?4?2ssl?2s3_both?4c?$AA@
; `string'
??_C@_0BA@MMNFJFNM@?4?2ssl?2s3_both?4c?$AA@ db '.\ssl\s3_both.c',0
					; DATA XREF: _freelist_extract+7o
					; _freelist_extract+5Do ...
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _BUF_MEM_grow_clean:near ; CODE XREF: _ssl3_get_message+1CBp
		extrn _CRYPTO_lock:near	; CODE XREF: _freelist_extract+12p
					; _freelist_extract+66p ...
		extrn _CRYPTO_malloc:near ; CODE XREF: _freelist_extract+7Dp
		extrn _CRYPTO_free:near	; CODE XREF: _freelist_insert+86p
		extrn _OpenSSLDie:near	; CODE XREF: _ssl3_get_finished+E5p
					; _ssl3_get_finished+12Dp ...
		extrn _CRYPTO_memcmp:near ; CODE XREF: _ssl3_get_finished+87p
		extrn _ERR_put_error:near ; CODE XREF: _ssl3_get_finished+AEp
					; _ssl3_get_message+19Bp ...
		extrn _EVP_PKEY_free:near ; CODE XREF: _ssl_cert_type+B0p
		extrn _X509_get_pubkey:near ; CODE XREF: _ssl_cert_type+14p
		extrn _X509_certificate_type:near ; CODE XREF: _ssl_cert_type+7Bp
		extrn _ssl_add_cert_chain:near ; CODE XREF: _ssl3_output_cert_chain+1Fp
		extrn _ssl3_send_alert:near ; CODE XREF: _ssl3_get_finished+BAp
					; _ssl3_get_message+1A7p
		extrn _ssl3_write_bytes:near ; CODE XREF: _ssl3_do_write+1Ap
					; _ssl3_send_change_cipher_spec+3Cp
		extrn _ssl3_finish_mac:near ; CODE XREF: _ssl3_do_write+40p
					; _ssl3_get_message+28Cp
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _ssl3_get_finished+FFp
					; _ssl3_get_finished+147p ...


		end
