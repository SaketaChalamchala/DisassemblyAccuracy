;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	840B0CFDD8ED03B641C4E69263A69A2D
; Input	CRC32 :	3765AD37

; File Name   :	C:\compspace\Diff\openssl\obj\md_rand.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_bss		segment	para public 'BSS' use32
		assume cs:_bss
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
_state_num	dd ?			; DATA XREF: _ssleay_rand_cleanup+16w
					; _ssleay_rand_add+E7w	...
_state_index	dd ?			; DATA XREF: _ssleay_rand_cleanup+20w
					; _ssleay_rand_add:loc_5A5r ...
_md_count	dd ?			; DATA XREF: _ssleay_rand_cleanup+32w
					; _ssleay_rand_add+A7r	...
dword_C		dd ?			; DATA XREF: _ssleay_rand_cleanup+3Fw
					; _ssleay_rand_add+BBr	...
_entropy	dq ?			; DATA XREF: _ssleay_rand_cleanup+49w
					; _ssleay_rand_add+2FAr ...
_initialized	dd ?			; DATA XREF: _ssleay_rand_cleanup+51w
					; _ssleay_rand_status:loc_934r	...
_crypto_lock_rand dd ?			; DATA XREF: _ssleay_rand_add+2Ar
					; _ssleay_rand_status+19r ...
; `ssleay_rand_bytes'::`2'::stirred_pool
?stirred_pool@?1??ssleay_rand_bytes@@9@9 dd ? ;	DATA XREF: _ssleay_rand_bytes:loc_A84r
					; _ssleay_rand_bytes+16Dw
_md		xmmword	?		; DATA XREF: _ssleay_rand_cleanup+11o
					; _ssleay_rand_add+ACr	...
dword_34	dd ?			; DATA XREF: _ssleay_rand_add+C6r
					; _ssleay_rand_bytes+1A0r
_state		db ?			; DATA XREF: _ssleay_rand_cleanup+5o
					; _ssleay_rand_add+1D6o ...
		align 4
		dd 104h	dup(?)
_locking_threadid dd 2 dup(?)		; DATA XREF: _ssleay_rand_add+56o
					; _ssleay_rand_status+3Ao ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 454h
		public _RAND_version
_RAND_version	db 'RAND part of OpenSSL 1.0.2h  3 May 2016',0
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 47Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssleay_rand_cleanup proc near		; DATA XREF: .data:00000994o
		push	413h
		push	offset _state
		call	_OPENSSL_cleanse
		push	14h
		push	offset _md
		mov	ds:_state_num, 0
		mov	ds:_state_index, 0
		call	_OPENSSL_cleanse
		xorps	xmm0, xmm0
		mov	ds:_md_count, 0
		add	esp, 10h
		mov	ds:dword_C, 0
		movsd	ds:_entropy, xmm0
		mov	ds:_initialized, 0
		retn
_ssleay_rand_cleanup endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4D8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssleay_rand_seed proc near		; DATA XREF: .data:_rand_ssleay_metho

var_8		= qword	ptr -8
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_4]
		mov	eax, 8
		movd	xmm0, ecx
		cvtdq2pd xmm0, xmm0
		call	__chkstk
		movsd	[esp+8+var_8], xmm0
		push	ecx
		push	[esp+0Ch+arg_0]
		call	_ssleay_rand_add
		add	esp, 10h
		retn
_ssleay_rand_seed endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 504h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssleay_rand_add proc near		; CODE XREF: _ssleay_rand_seed+20p
					; _ssleay_rand_bytes+156p
					; DATA XREF: ...

var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_38		= dword	ptr -38h
var_34		= dword	ptr -34h
var_30		= byte ptr -30h
var_18		= xmmword ptr -18h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= qword	ptr  0Ch

		mov	eax, 48h ; 'H'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+48h+var_4], eax
		mov	eax, [esp+48h+arg_0]
		push	ebx
		mov	ebx, [esp+4Ch+arg_4]
		mov	[esp+4Ch+var_48], eax
		test	ebx, ebx
		jz	loc_835
		cmp	ds:_crypto_lock_rand, 0
		push	ebp
		jz	short loc_589
		lea	eax, [esp+50h+var_40]
		push	eax
		call	_CRYPTO_THREADID_current
		push	0DFh ; 'ß'
		push	offset ??_C@_0BI@MJCOAGKM@?4?2crypto?2rand?2md_rand?4c?$AA@ ; ".\\crypto\\rand\\md_rand.c"
		push	13h
		push	5
		call	_CRYPTO_lock
		lea	eax, [esp+64h+var_40]
		push	eax
		push	offset _locking_threadid
		call	_CRYPTO_THREADID_cmp
		neg	eax
		push	0E1h ; 'á'
		push	offset ??_C@_0BI@MJCOAGKM@?4?2crypto?2rand?2md_rand?4c?$AA@ ; ".\\crypto\\rand\\md_rand.c"
		sbb	ebp, ebp
		push	13h
		inc	ebp
		push	6
		mov	[esp+7Ch+var_44], ebp
		call	_CRYPTO_lock
		add	esp, 2Ch
		test	ebp, ebp
		jnz	short loc_5A5
		jmp	short loc_58F
; ---------------------------------------------------------------------------

loc_589:				; CODE XREF: _ssleay_rand_add+32j
		xor	ebp, ebp
		mov	[esp+50h+var_44], ebp

loc_58F:				; CODE XREF: _ssleay_rand_add+83j
		push	0E6h ; 'æ'
		push	offset ??_C@_0BI@MJCOAGKM@?4?2crypto?2rand?2md_rand?4c?$AA@ ; ".\\crypto\\rand\\md_rand.c"
		push	12h
		push	9
		call	_CRYPTO_lock
		add	esp, 10h

loc_5A5:				; CODE XREF: _ssleay_rand_add+81j
		mov	ecx, ds:_state_index
		mov	eax, ds:_md_count
		movups	xmm0, ds:_md
		push	esi
		push	edi
		mov	[esp+58h+var_38], eax
		mov	edi, ecx
		mov	eax, ds:dword_C
		add	ecx, ebx
		mov	[esp+58h+var_34], eax
		mov	eax, ds:dword_34
		mov	[esp+58h+var_8], eax
		mov	ds:_state_index, ecx
		movups	[esp+58h+var_18], xmm0
		cmp	ecx, 3FFh
		jl	short loc_613
		mov	eax, 7FDFF7FDh
		mov	ds:_state_num, 3FFh
		imul	ecx
		sub	edx, ecx
		sar	edx, 9
		mov	eax, edx
		shr	eax, 1Fh
		add	eax, edx
		imul	eax, 3FFh
		add	ecx, eax
		mov	ds:_state_index, ecx
		jmp	short loc_629
; ---------------------------------------------------------------------------

loc_613:				; CODE XREF: _ssleay_rand_add+E0j
		mov	eax, ds:_state_num
		cmp	eax, 3FFh
		jge	short loc_629
		cmp	ecx, eax
		cmovg	eax, ecx
		mov	ds:_state_num, eax

loc_629:				; CODE XREF: _ssleay_rand_add+10Dj
					; _ssleay_rand_add+119j
		mov	eax, 66666667h
		mov	ecx, ebx
		imul	ebx
		sar	edx, 3
		mov	esi, edx
		shr	esi, 1Fh
		add	esi, edx
		lea	eax, [esi+esi*4]
		shl	eax, 2
		sub	ecx, eax
		xor	eax, eax
		test	ecx, ecx
		setnle	al
		add	eax, esi
		add	ds:dword_C, eax
		test	ebp, ebp
		jnz	short loc_66D
		push	106h
		push	offset ??_C@_0BI@MJCOAGKM@?4?2crypto?2rand?2md_rand?4c?$AA@ ; ".\\crypto\\rand\\md_rand.c"
		push	12h
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h

loc_66D:				; CODE XREF: _ssleay_rand_add+151j
		lea	eax, [esp+58h+var_30]
		push	eax
		call	_EVP_MD_CTX_init
		add	esp, 4
		test	ebx, ebx
		jle	loc_796
		lea	ecx, [ebx-1]
		mov	eax, 0CCCCCCCDh
		mul	ecx
		mov	eax, edx
		shr	eax, 4
		inc	eax
		mov	[esp+58h+var_40], eax
		mov	eax, 14h

loc_69B:				; CODE XREF: _ssleay_rand_add+288j
		cmp	ebx, 14h
		mov	esi, ebx
		push	0
		cmovg	esi, eax
		call	_EVP_sha1
		push	eax
		lea	eax, [esp+60h+var_30]
		push	eax
		call	_EVP_DigestInit_ex
		push	14h
		lea	eax, [esp+68h+var_18]
		push	eax
		lea	eax, [esp+6Ch+var_30]
		push	eax
		call	_EVP_DigestUpdate
		lea	ebp, [edi-3FFh]
		add	esp, 18h
		add	ebp, esi
		test	ebp, ebp
		jle	short loc_700
		mov	eax, esi
		sub	eax, ebp
		push	eax
		lea	eax, _state[edi]
		push	eax
		lea	eax, [esp+60h+var_30]
		push	eax
		call	_EVP_DigestUpdate
		push	ebp
		lea	eax, [esp+68h+var_30]
		push	offset _state
		push	eax
		call	_EVP_DigestUpdate
		add	esp, 18h
		jmp	short loc_715
; ---------------------------------------------------------------------------

loc_700:				; CODE XREF: _ssleay_rand_add+1CFj
		push	esi
		lea	eax, _state[edi]
		push	eax
		lea	eax, [esp+60h+var_30]
		push	eax
		call	_EVP_DigestUpdate
		add	esp, 0Ch

loc_715:				; CODE XREF: _ssleay_rand_add+1FAj
		mov	ebp, [esp+58h+var_48]
		lea	eax, [esp+58h+var_30]
		push	esi
		push	ebp
		push	eax
		call	_EVP_DigestUpdate
		push	8
		lea	eax, [esp+68h+var_38]
		push	eax
		lea	eax, [esp+6Ch+var_30]
		push	eax
		call	_EVP_DigestUpdate
		push	0
		lea	eax, [esp+74h+var_18]
		push	eax
		lea	eax, [esp+78h+var_30]
		push	eax
		call	_EVP_DigestFinal_ex
		inc	[esp+7Ch+var_34]
		add	ebp, esi
		add	esp, 24h
		mov	[esp+58h+var_48], ebp
		xor	ecx, ecx
		test	esi, esi
		jle	short loc_77F
		db	66h, 66h
		nop	word ptr [eax+eax+00000000h]

loc_764:				; CODE XREF: _ssleay_rand_add+279j
		mov	al, byte ptr [esp+ecx+58h+var_18]
		xor	ds:_state[edi],	al
		inc	edi
		xor	eax, eax
		cmp	edi, 3FFh
		cmovge	edi, eax
		inc	ecx
		cmp	ecx, esi
		jl	short loc_764

loc_77F:				; CODE XREF: _ssleay_rand_add+254j
		sub	ebx, 14h
		mov	eax, 14h
		sub	[esp+58h+var_40], 1
		jnz	loc_69B
		mov	ebp, [esp+58h+var_44]

loc_796:				; CODE XREF: _ssleay_rand_add+178j
		lea	eax, [esp+58h+var_30]
		push	eax
		call	_EVP_MD_CTX_cleanup
		add	esp, 4
		pop	edi
		pop	esi
		test	ebp, ebp
		jnz	short loc_7BF
		push	137h
		push	offset ??_C@_0BI@MJCOAGKM@?4?2crypto?2rand?2md_rand?4c?$AA@ ; ".\\crypto\\rand\\md_rand.c"
		push	12h
		push	9
		call	_CRYPTO_lock
		add	esp, 10h

loc_7BF:				; CODE XREF: _ssleay_rand_add+2A3j
		movups	xmm1, ds:_md
		xor	ecx, ecx
		mov	edx, 4
		movups	xmm0, [esp+50h+var_18]
		pxor	xmm1, xmm0
		movups	ds:_md,	xmm1
		nop	dword ptr [eax+00000000h]

loc_7E4:				; CODE XREF: _ssleay_rand_add+2F0j
		mov	al, byte ptr [esp+ecx+50h+var_8]
		lea	ecx, [ecx+1]
		xor	byte ptr ds:(_md+0Fh)[ecx], al
		sub	edx, 1
		jnz	short loc_7E4
		movsd	xmm0, ds:__real@4040000000000000
		movsd	xmm1, ds:_entropy
		comisd	xmm0, xmm1
		jbe	short loc_81A
		addsd	xmm1, [esp+50h+arg_8]
		movsd	ds:_entropy, xmm1

loc_81A:				; CODE XREF: _ssleay_rand_add+306j
		test	ebp, ebp
		pop	ebp
		jnz	short loc_835
		push	144h
		push	offset ??_C@_0BI@MJCOAGKM@?4?2crypto?2rand?2md_rand?4c?$AA@ ; ".\\crypto\\rand\\md_rand.c"
		push	12h
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h

loc_835:				; CODE XREF: _ssleay_rand_add+24j
					; _ssleay_rand_add+319j
		mov	ecx, [esp+4Ch+var_4]
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 48h
		retn
_ssleay_rand_add endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 848h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssleay_rand_nopseudo_bytes proc near	; DATA XREF: .data:00000990o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	1
		push	0
		push	[esp+8+arg_4]
		push	[esp+0Ch+arg_0]
		call	_ssleay_rand_bytes
		add	esp, 10h
		retn
_ssleay_rand_nopseudo_bytes endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 860h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssleay_rand_pseudo_bytes proc near	; DATA XREF: .data:0000099Co

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	1
		push	1
		push	[esp+8+arg_4]
		push	[esp+0Ch+arg_0]
		call	_ssleay_rand_bytes
		add	esp, 10h
		retn
_ssleay_rand_pseudo_bytes endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 878h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssleay_rand_status proc near		; DATA XREF: .data:000009A0o

var_8		= byte ptr -8

		mov	eax, 8
		call	__chkstk
		push	ebx
		lea	eax, [esp+0Ch+var_8]
		push	esi
		push	eax
		call	_CRYPTO_THREADID_current
		add	esp, 4
		cmp	ds:_crypto_lock_rand, 0
		jz	short loc_8DD
		push	22Fh
		push	offset ??_C@_0BI@MJCOAGKM@?4?2crypto?2rand?2md_rand?4c?$AA@ ; ".\\crypto\\rand\\md_rand.c"
		push	13h
		push	5
		call	_CRYPTO_lock
		lea	eax, [esp+20h+var_8]
		push	eax
		push	offset _locking_threadid
		call	_CRYPTO_THREADID_cmp
		push	231h
		push	offset ??_C@_0BI@MJCOAGKM@?4?2crypto?2rand?2md_rand?4c?$AA@ ; ".\\crypto\\rand\\md_rand.c"
		neg	eax
		push	13h
		push	6
		sbb	esi, esi
		call	_CRYPTO_lock
		add	esp, 28h
		add	esi, 1
		jnz	short loc_934
		jmp	short loc_8DF
; ---------------------------------------------------------------------------

loc_8DD:				; CODE XREF: _ssleay_rand_status+20j
		xor	esi, esi

loc_8DF:				; CODE XREF: _ssleay_rand_status+63j
		push	236h
		push	offset ??_C@_0BI@MJCOAGKM@?4?2crypto?2rand?2md_rand?4c?$AA@ ; ".\\crypto\\rand\\md_rand.c"
		push	12h
		push	9
		call	_CRYPTO_lock
		push	23Bh
		push	offset ??_C@_0BI@MJCOAGKM@?4?2crypto?2rand?2md_rand?4c?$AA@ ; ".\\crypto\\rand\\md_rand.c"
		push	13h
		push	9
		call	_CRYPTO_lock
		lea	eax, [esp+30h+var_8]
		push	eax
		push	offset _locking_threadid
		call	_CRYPTO_THREADID_cpy
		push	23Dh
		push	offset ??_C@_0BI@MJCOAGKM@?4?2crypto?2rand?2md_rand?4c?$AA@ ; ".\\crypto\\rand\\md_rand.c"
		push	13h
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 38h
		mov	ds:_crypto_lock_rand, 1

loc_934:				; CODE XREF: _ssleay_rand_status+61j
		cmp	ds:_initialized, 0
		jnz	short loc_94C
		call	_RAND_poll
		mov	ds:_initialized, 1

loc_94C:				; CODE XREF: _ssleay_rand_status+C3j
		movsd	xmm0, ds:_entropy
		xor	ebx, ebx
		comisd	xmm0, ds:__real@4040000000000000
		setnb	bl
		test	esi, esi
		jnz	short loc_981
		push	24Ch
		push	offset ??_C@_0BI@MJCOAGKM@?4?2crypto?2rand?2md_rand?4c?$AA@ ; ".\\crypto\\rand\\md_rand.c"
		push	12h
		push	0Ah
		mov	ds:_crypto_lock_rand, esi
		call	_CRYPTO_lock
		add	esp, 10h

loc_981:				; CODE XREF: _ssleay_rand_status+EBj
		pop	esi
		mov	eax, ebx
		pop	ebx
		add	esp, 8
		retn
_ssleay_rand_status endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 98Ch
		public _rand_ssleay_meth
_rand_ssleay_meth dd offset _ssleay_rand_seed ;	DATA XREF: _RAND_SSLeayo
		dd offset _ssleay_rand_nopseudo_bytes
		dd offset _ssleay_rand_cleanup
		dd offset _ssleay_rand_add
		dd offset _ssleay_rand_pseudo_bytes
		dd offset _ssleay_rand_status
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 9A4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _RAND_SSLeay
_RAND_SSLeay	proc near
		mov	eax, offset _rand_ssleay_meth
		retn
_RAND_SSLeay	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 9ACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ssleay_rand_bytes
_ssleay_rand_bytes proc	near		; CODE XREF: _ssleay_rand_nopseudo_bytes+Cp
					; _ssleay_rand_pseudo_bytes+Cp

var_54		= qword	ptr -54h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
var_38		= byte ptr -38h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= xmmword ptr -18h
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, 40h ; '@'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+40h+var_4], eax
		push	ebx
		mov	ebx, [esp+44h+arg_4]
		push	esi
		xor	esi, esi
		push	edi
		mov	edi, [esp+4Ch+arg_0]
		test	ebx, ebx
		jg	short loc_9E9

loc_9D2:				; CODE XREF: _ssleay_rand_bytes+49Dj
		pop	edi
		pop	esi
		mov	eax, 1
		pop	ebx
		mov	ecx, [esp+40h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 40h
		retn
; ---------------------------------------------------------------------------

loc_9E9:				; CODE XREF: _ssleay_rand_bytes+24j
		lea	eax, [esp+4Ch+var_38]
		push	eax
		call	_EVP_MD_CTX_init
		lea	ecx, [ebx-1]
		mov	eax, 66666667h
		imul	ecx
		add	esp, 4
		sar	edx, 2
		mov	eax, edx
		shr	eax, 1Fh
		inc	eax
		add	eax, edx
		lea	eax, [eax+eax*4]
		add	eax, eax
		mov	[esp+4Ch+var_40], eax
		cmp	[esp+4Ch+arg_C], esi
		jz	short loc_A30
		push	182h
		push	offset ??_C@_0BI@MJCOAGKM@?4?2crypto?2rand?2md_rand?4c?$AA@ ; ".\\crypto\\rand\\md_rand.c"
		push	12h
		push	9
		call	_CRYPTO_lock
		add	esp, 10h

loc_A30:				; CODE XREF: _ssleay_rand_bytes+6Cj
		push	185h
		push	offset ??_C@_0BI@MJCOAGKM@?4?2crypto?2rand?2md_rand?4c?$AA@ ; ".\\crypto\\rand\\md_rand.c"
		push	13h
		push	9
		call	_CRYPTO_lock
		push	offset _locking_threadid
		call	_CRYPTO_THREADID_current
		push	187h
		push	offset ??_C@_0BI@MJCOAGKM@?4?2crypto?2rand?2md_rand?4c?$AA@ ; ".\\crypto\\rand\\md_rand.c"
		push	13h
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 24h
		mov	ds:_crypto_lock_rand, 1
		cmp	ds:_initialized, esi
		jnz	short loc_A84
		call	_RAND_poll
		mov	ds:_initialized, 1

loc_A84:				; CODE XREF: _ssleay_rand_bytes+C7j
		mov	eax, ds:?stirred_pool@?1??ssleay_rand_bytes@@9@9 ; `ssleay_rand_bytes'::`2'::stirred_pool
		mov	ecx, 1
		movsd	xmm1, ds:_entropy
		test	eax, eax
		cmovz	esi, ecx
		xor	eax, eax
		comisd	xmm1, ds:__real@4040000000000000
		setnb	al
		mov	[esp+4Ch+var_3C], eax
		test	eax, eax
		jnz	short loc_AD7
		movd	xmm0, ebx
		cvtdq2pd xmm0, xmm0
		subsd	xmm1, xmm0
		xorps	xmm0, xmm0
		comisd	xmm0, xmm1
		movsd	ds:_entropy, xmm1
		jbe	short loc_ADA
		movsd	ds:_entropy, xmm0
		jmp	short loc_ADA
; ---------------------------------------------------------------------------

loc_AD7:				; CODE XREF: _ssleay_rand_bytes+102j
		xorps	xmm0, xmm0

loc_ADA:				; CODE XREF: _ssleay_rand_bytes+11Fj
					; _ssleay_rand_bytes+129j
		test	esi, esi
		jz	short loc_B23
		mov	esi, 34h ; '4'
		nop	word ptr [eax+eax+00000000h]

loc_AEC:				; CODE XREF: _ssleay_rand_bytes+164j
		mov	eax, 8
		call	__chkstk
		movsd	[esp+54h+var_54], xmm0
		push	14h
		push	offset ??_C@_0BF@KNMHCCP@?4?4?4?4?4?4?4?4?4?4?4?4?4?4?4?4?4?4?4?4?$AA@ ; "...................."
		call	_ssleay_rand_add
		add	esp, 10h
		xorps	xmm0, xmm0
		sub	esi, 1
		jnz	short loc_AEC
		cmp	[esp+4Ch+var_3C], 0
		jz	short loc_B23
		mov	ds:?stirred_pool@?1??ssleay_rand_bytes@@9@9, 1 ; `ssleay_rand_bytes'::`2'::stirred_pool

loc_B23:				; CODE XREF: _ssleay_rand_bytes+130j
					; _ssleay_rand_bytes+16Bj
		mov	edx, ds:_state_index
		mov	esi, edx
		mov	eax, ds:dword_C
		movups	xmm0, ds:_md
		add	edx, [esp+4Ch+var_40]
		mov	ecx, ds:_md_count
		push	ebp
		mov	ebp, ds:_state_num
		mov	[esp+50h+var_1C], eax
		mov	eax, ds:dword_34
		mov	[esp+50h+var_20], ecx
		mov	[esp+50h+var_8], eax
		mov	ds:_state_index, edx
		movups	[esp+50h+var_18], xmm0
		cmp	edx, ebp
		jle	short loc_B73
		mov	eax, edx
		cdq
		idiv	ebp
		mov	ds:_state_index, edx

loc_B73:				; CODE XREF: _ssleay_rand_bytes+1BAj
		inc	ecx
		mov	ds:_crypto_lock_rand, 0
		cmp	[esp+50h+arg_C], 0
		mov	ds:_md_count, ecx
		jz	short loc_BA1
		push	1D2h
		push	offset ??_C@_0BI@MJCOAGKM@?4?2crypto?2rand?2md_rand?4c?$AA@ ; ".\\crypto\\rand\\md_rand.c"
		push	12h
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h

loc_BA1:				; CODE XREF: _ssleay_rand_bytes+1DDj
		mov	ecx, 0Ah
		mov	eax, ebx
		nop	dword ptr [eax+00h]

loc_BAC:				; CODE XREF: _ssleay_rand_bytes+3EDj
		cmp	eax, 0Ah
		mov	ebx, eax
		push	0
		cmovge	ebx, ecx
		sub	eax, ebx
		mov	[esp+54h+arg_4], eax
		call	_EVP_sha1
		push	eax
		lea	eax, [esp+58h+var_38]
		push	eax
		call	_EVP_DigestInit_ex
		push	14h
		lea	eax, [esp+60h+var_18]
		push	eax
		lea	eax, [esp+64h+var_38]
		push	eax
		call	_EVP_DigestUpdate
		push	8
		lea	eax, [esp+6Ch+var_20]
		push	eax
		lea	eax, [esp+70h+var_38]
		push	eax
		call	_EVP_DigestUpdate
		push	ebx
		lea	eax, [esp+78h+var_38]
		push	edi
		push	eax
		call	_EVP_DigestUpdate
		mov	edx, esi
		add	esp, 30h
		sub	edx, ebp
		add	edx, 0Ah
		mov	[esp+50h+var_40], edx
		test	edx, edx
		jle	short loc_C3D
		mov	eax, 0Ah
		lea	ecx, _state[esi]
		sub	eax, edx
		push	eax
		push	ecx
		lea	eax, [esp+58h+var_38]
		push	eax
		call	_EVP_DigestUpdate
		push	[esp+5Ch+var_40]
		lea	eax, [esp+60h+var_38]
		push	offset _state
		push	eax
		call	_EVP_DigestUpdate
		add	esp, 18h
		jmp	short loc_C53
; ---------------------------------------------------------------------------

loc_C3D:				; CODE XREF: _ssleay_rand_bytes+25Ej
		lea	eax, _state[esi]
		push	0Ah
		push	eax
		lea	eax, [esp+58h+var_38]
		push	eax
		call	_EVP_DigestUpdate
		add	esp, 0Ch

loc_C53:				; CODE XREF: _ssleay_rand_bytes+28Fj
		push	0
		lea	eax, [esp+54h+var_18]
		push	eax
		lea	eax, [esp+58h+var_38]
		push	eax
		call	_EVP_DigestFinal_ex
		mov	al, byte ptr [esp+5Ch+var_18]
		add	esp, 0Ch
		xor	ds:_state[esi],	al
		inc	esi
		xor	eax, eax
		cmp	esi, ebp
		cmovge	esi, eax
		test	ebx, ebx
		jle	short loc_C84
		mov	al, byte ptr [esp+50h+var_18+0Ah]
		mov	[edi], al
		inc	edi

loc_C84:				; CODE XREF: _ssleay_rand_bytes+2CFj
		mov	al, byte ptr [esp+50h+var_18+1]
		xor	ds:_state[esi],	al
		inc	esi
		xor	eax, eax
		cmp	esi, ebp
		cmovge	esi, eax
		cmp	ebx, 1
		jle	short loc_CA2
		mov	al, byte ptr [esp+50h+var_18+0Bh]
		mov	[edi], al
		inc	edi

loc_CA2:				; CODE XREF: _ssleay_rand_bytes+2EDj
		mov	al, byte ptr [esp+50h+var_18+2]
		xor	ds:_state[esi],	al
		inc	esi
		xor	eax, eax
		cmp	esi, ebp
		cmovge	esi, eax
		cmp	ebx, 2
		jle	short loc_CC0
		mov	al, byte ptr [esp+50h+var_18+0Ch]
		mov	[edi], al
		inc	edi

loc_CC0:				; CODE XREF: _ssleay_rand_bytes+30Bj
		mov	al, byte ptr [esp+50h+var_18+3]
		xor	ds:_state[esi],	al
		inc	esi
		xor	eax, eax
		cmp	esi, ebp
		cmovge	esi, eax
		cmp	ebx, 3
		jle	short loc_CDE
		mov	al, byte ptr [esp+50h+var_18+0Dh]
		mov	[edi], al
		inc	edi

loc_CDE:				; CODE XREF: _ssleay_rand_bytes+329j
		mov	al, byte ptr [esp+50h+var_18+4]
		xor	ds:_state[esi],	al
		inc	esi
		xor	eax, eax
		cmp	esi, ebp
		cmovge	esi, eax
		cmp	ebx, 4
		jle	short loc_CFC
		mov	al, byte ptr [esp+50h+var_18+0Eh]
		mov	[edi], al
		inc	edi

loc_CFC:				; CODE XREF: _ssleay_rand_bytes+347j
		mov	al, byte ptr [esp+50h+var_18+5]
		xor	ds:_state[esi],	al
		inc	esi
		xor	eax, eax
		cmp	esi, ebp
		cmovge	esi, eax
		cmp	ebx, 5
		jle	short loc_D1A
		mov	al, byte ptr [esp+50h+var_18+0Fh]
		mov	[edi], al
		inc	edi

loc_D1A:				; CODE XREF: _ssleay_rand_bytes+365j
		mov	al, byte ptr [esp+50h+var_18+6]
		xor	ds:_state[esi],	al
		inc	esi
		mov	ecx, [esp+50h+var_8]
		xor	eax, eax
		cmp	esi, ebp
		cmovge	esi, eax
		cmp	ebx, 6
		jle	short loc_D38
		mov	[edi], cl
		inc	edi

loc_D38:				; CODE XREF: _ssleay_rand_bytes+387j
		mov	al, byte ptr [esp+50h+var_18+7]
		xor	ds:_state[esi],	al
		inc	esi
		xor	eax, eax
		cmp	esi, ebp
		cmovge	esi, eax
		cmp	ebx, 7
		jle	short loc_D52
		mov	[edi], ch
		inc	edi

loc_D52:				; CODE XREF: _ssleay_rand_bytes+3A1j
		mov	al, byte ptr [esp+50h+var_18+8]
		xor	ds:_state[esi],	al
		inc	esi
		xor	eax, eax
		cmp	esi, ebp
		cmovge	esi, eax
		cmp	ebx, 8
		jle	short loc_D70
		mov	al, byte ptr [esp+50h+var_8+2]
		mov	[edi], al
		inc	edi

loc_D70:				; CODE XREF: _ssleay_rand_bytes+3BBj
		mov	al, byte ptr [esp+50h+var_18+9]
		xor	ds:_state[esi],	al
		inc	esi
		xor	eax, eax
		cmp	esi, ebp
		cmovge	esi, eax
		cmp	ebx, 9
		jle	short loc_D8E
		mov	al, byte ptr [esp+50h+var_8+3]
		mov	[edi], al
		inc	edi

loc_D8E:				; CODE XREF: _ssleay_rand_bytes+3D9j
		mov	eax, [esp+50h+arg_4]
		mov	ecx, 0Ah
		test	eax, eax
		jg	loc_BAC
		push	0
		call	_EVP_sha1
		push	eax
		lea	eax, [esp+58h+var_38]
		push	eax
		call	_EVP_DigestInit_ex
		push	8
		lea	eax, [esp+60h+var_20]
		push	eax
		lea	eax, [esp+64h+var_38]
		push	eax
		call	_EVP_DigestUpdate
		push	14h
		lea	eax, [esp+6Ch+var_18]
		push	eax
		lea	eax, [esp+70h+var_38]
		push	eax
		call	_EVP_DigestUpdate
		mov	ebx, [esp+74h+arg_C]
		add	esp, 24h
		pop	ebp
		test	ebx, ebx
		jz	short loc_DF8
		push	203h
		push	offset ??_C@_0BI@MJCOAGKM@?4?2crypto?2rand?2md_rand?4c?$AA@ ; ".\\crypto\\rand\\md_rand.c"
		push	12h
		push	9
		call	_CRYPTO_lock
		add	esp, 10h

loc_DF8:				; CODE XREF: _ssleay_rand_bytes+434j
		push	14h
		lea	eax, [esp+50h+var_38]
		push	offset _md
		push	eax
		call	_EVP_DigestUpdate
		push	0
		lea	eax, [esp+5Ch+var_38]
		push	offset _md
		push	eax
		call	_EVP_DigestFinal_ex
		add	esp, 18h
		test	ebx, ebx
		jz	short loc_E37
		push	207h
		push	offset ??_C@_0BI@MJCOAGKM@?4?2crypto?2rand?2md_rand?4c?$AA@ ; ".\\crypto\\rand\\md_rand.c"
		push	12h
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h

loc_E37:				; CODE XREF: _ssleay_rand_bytes+473j
		lea	ecx, [esp+4Ch+var_38]
		push	ecx
		call	_EVP_MD_CTX_cleanup
		add	esp, 4
		cmp	[esp+4Ch+var_3C], 0
		jnz	loc_9D2
		cmp	[esp+4Ch+arg_8], 0
		jnz	short loc_E7A
		push	20Fh
		push	offset ??_C@_0BI@MJCOAGKM@?4?2crypto?2rand?2md_rand?4c?$AA@ ; ".\\crypto\\rand\\md_rand.c"
		push	64h ; 'd'
		push	64h ; 'd'
		push	24h ; '$'
		call	_ERR_put_error
		push	offset ??_C@_0EK@MHBHPLPP@You?5need?5to?5read?5the?5OpenSSL?5FAQ@ ; "You need to read the OpenSSL FAQ, http:"...
		push	1
		call	_ERR_add_error_data
		add	esp, 1Ch

loc_E7A:				; CODE XREF: _ssleay_rand_bytes+4A8j
		mov	ecx, [esp+4Ch+var_4]
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 40h
		retn
_ssleay_rand_bytes endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E90h
; COMDAT (pick any)
		public ??_C@_0BI@MJCOAGKM@?4?2crypto?2rand?2md_rand?4c?$AA@
; `string'
??_C@_0BI@MJCOAGKM@?4?2crypto?2rand?2md_rand?4c?$AA@ db	'.\crypto\rand\md_rand.c',0
					; DATA XREF: _ssleay_rand_add+43o
					; _ssleay_rand_add+67o	...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0EA8h
; COMDAT (pick any)
		public ??_C@_0BF@KNMHCCP@?4?4?4?4?4?4?4?4?4?4?4?4?4?4?4?4?4?4?4?4?$AA@
; `string'
??_C@_0BF@KNMHCCP@?4?4?4?4?4?4?4?4?4?4?4?4?4?4?4?4?4?4?4?4?$AA@	db '....................',0
					; DATA XREF: _ssleay_rand_bytes+151o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0EC0h
; COMDAT (pick any)
		public ??_C@_0EK@MHBHPLPP@You?5need?5to?5read?5the?5OpenSSL?5FAQ@
; `string'
??_C@_0EK@MHBHPLPP@You?5need?5to?5read?5the?5OpenSSL?5FAQ@ db 'You need to read the OpenSSL FAQ, http://www.openssl.org/support/'
					; DATA XREF: _ssleay_rand_bytes+4BFo
		db 'faq.html',0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0F0Ch
; COMDAT (pick any)
		public __real@4040000000000000
__real@4040000000000000	dq 4040000000000000h ; DATA XREF: _ssleay_rand_add+2F2r
					; _ssleay_rand_status+DEr ...
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _CRYPTO_lock:near	; CODE XREF: _ssleay_rand_add+4Cp
					; _ssleay_rand_add+77p	...
		extrn _CRYPTO_THREADID_current:near ; CODE XREF: _ssleay_rand_add+39p
					; _ssleay_rand_status+11p ...
		extrn _CRYPTO_THREADID_cmp:near	; CODE XREF: _ssleay_rand_add+5Bp
					; _ssleay_rand_status+3Fp
		extrn _CRYPTO_THREADID_cpy:near	; CODE XREF: _ssleay_rand_status+97p
		extrn _OPENSSL_cleanse:near ; CODE XREF: _ssleay_rand_cleanup+Ap
					; _ssleay_rand_cleanup+2Ap
		extrn _RAND_poll:near	; CODE XREF: _ssleay_rand_status+C5p
					; _ssleay_rand_bytes+C9p
		extrn _EVP_MD_CTX_init:near ; CODE XREF: _ssleay_rand_add+16Ep
					; _ssleay_rand_bytes+42p
		extrn _EVP_MD_CTX_cleanup:near ; CODE XREF: _ssleay_rand_add+297p
					; _ssleay_rand_bytes+490p
		extrn _EVP_DigestInit_ex:near ;	CODE XREF: _ssleay_rand_add+1ACp
					; _ssleay_rand_bytes+21Bp ...
		extrn _EVP_DigestUpdate:near ; CODE XREF: _ssleay_rand_add+1BDp
					; _ssleay_rand_add+1E2p ...
		extrn _EVP_DigestFinal_ex:near ; CODE XREF: _ssleay_rand_add+23Ep
					; _ssleay_rand_bytes+2B3p ...
		extrn _EVP_sha1:near	; CODE XREF: _ssleay_rand_add+1A1p
					; _ssleay_rand_bytes+210p ...
		extrn _ERR_put_error:near ; CODE XREF: _ssleay_rand_bytes+4BAp
		extrn _ERR_add_error_data:near ; CODE XREF: _ssleay_rand_bytes+4C6p
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _ssleay_rand_add+338p
					; _ssleay_rand_bytes+34p ...
		extrn __chkstk:near	; CODE XREF: _ssleay_rand_seed+11p
					; _ssleay_rand_add+5p ...
		extrn ___security_cookie:near ;	DATA XREF: _ssleay_rand_add+Ar
					; _ssleay_rand_bytes+Ar
		extrn __fltused:near


		end
