;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	692288DB91CB26EBB1ED17D7D89AE8A7
; Input	CRC32 :	AD377FF1

; File Name   :	C:\compspace\Diff\openssl\obj\bn_rand.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_bntest_rand
_BN_bntest_rand	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	[esp+arg_C]
		push	[esp+4+arg_8]
		push	[esp+8+arg_4]
		push	[esp+0Ch+arg_0]
		push	2
		call	_bnrand
		add	esp, 14h
		retn
_BN_bntest_rand	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_pseudo_rand
_BN_pseudo_rand	proc near		; DATA XREF: _bn_rand_range+10o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	[esp+arg_C]
		push	[esp+4+arg_8]
		push	[esp+8+arg_4]
		push	[esp+0Ch+arg_0]
		push	1
		call	_bnrand
		add	esp, 14h
		retn
_BN_pseudo_rand	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 38h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_pseudo_rand_range
_BN_pseudo_rand_range proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	[esp+arg_4]
		push	[esp+4+arg_0]
		push	1
		call	_bn_rand_range
		add	esp, 0Ch
		retn
_BN_pseudo_rand_range endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_rand
_BN_rand	proc near		; DATA XREF: _bn_rand_range+5o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	[esp+arg_C]
		push	[esp+4+arg_8]
		push	[esp+8+arg_4]
		push	[esp+0Ch+arg_0]
		push	0
		call	_bnrand
		add	esp, 14h
		retn
_BN_rand	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 68h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BN_rand_range
_BN_rand_range	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	[esp+arg_4]
		push	[esp+4+arg_0]
		push	0
		call	_bn_rand_range
		add	esp, 0Ch
		retn
_BN_rand_range	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_bn_rand_range	proc near		; CODE XREF: _BN_pseudo_rand_range+Ap
					; _BN_rand_range+Ap

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		cmp	[esp+arg_0], 0
		mov	eax, offset _BN_rand
		push	ebx
		push	edi
		mov	edi, [esp+8+arg_8]
		mov	ecx, offset _BN_pseudo_rand
		cmovnz	eax, ecx
		mov	ebx, 64h ; 'd'
		mov	[esp+8+arg_0], eax
		cmp	dword ptr [edi+0Ch], 0
		jnz	loc_1D9
		cmp	dword ptr [edi+4], 0
		jz	loc_1D9
		push	ebp
		push	esi
		push	edi
		call	_BN_num_bits
		mov	ebp, eax
		add	esp, 4
		cmp	ebp, 1
		jnz	short loc_D8
		push	0
		push	[esp+14h+arg_4]
		call	_BN_set_word
		add	esp, 8
		mov	eax, ebp
		pop	esi
		pop	ebp
		pop	edi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_D8:					; CODE XREF: _bn_rand_range+45j
		lea	eax, [ebp-2]
		push	eax
		push	edi
		call	_BN_is_bit_set
		add	esp, 8
		test	eax, eax
		jnz	loc_182
		lea	eax, [ebp-3]
		push	eax
		push	edi
		call	_BN_is_bit_set
		add	esp, 8
		test	eax, eax
		jnz	loc_182
		mov	esi, [esp+10h+arg_4]
		lea	eax, [ebp+1]
		mov	ebp, [esp+10h+arg_0]
		mov	[esp+10h+arg_8], eax

loc_111:				; CODE XREF: _bn_rand_range+FDj
		push	0
		push	0FFFFFFFFh
		push	eax
		push	esi
		call	ebp
		add	esp, 10h
		test	eax, eax
		jz	loc_1D2
		push	edi
		push	esi
		call	_BN_cmp
		add	esp, 8
		test	eax, eax
		js	short loc_162
		push	edi
		push	esi
		push	esi
		call	_BN_sub
		add	esp, 0Ch
		test	eax, eax
		jz	loc_1D2
		push	edi
		push	esi
		call	_BN_cmp
		add	esp, 8
		test	eax, eax
		js	short loc_162
		push	edi
		push	esi
		push	esi
		call	_BN_sub
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_1D2

loc_162:				; CODE XREF: _bn_rand_range+B4j
					; _bn_rand_range+D5j
		sub	ebx, 1
		jz	short loc_17B
		push	edi
		push	esi
		call	_BN_cmp
		add	esp, 8
		test	eax, eax
		js	short loc_1B0
		mov	eax, [esp+10h+arg_8]
		jmp	short loc_111
; ---------------------------------------------------------------------------

loc_17B:				; CODE XREF: _bn_rand_range+E9j
		push	107h
		jmp	short loc_1BF
; ---------------------------------------------------------------------------

loc_182:				; CODE XREF: _bn_rand_range+6Bj
					; _bn_rand_range+80j
		mov	esi, [esp+10h+arg_4]
		nop	word ptr [eax+eax+00h]

loc_18C:				; CODE XREF: _bn_rand_range+132j
		push	0
		push	0FFFFFFFFh
		push	ebp
		push	esi
		call	[esp+20h+arg_0]
		add	esp, 10h
		test	eax, eax
		jz	short loc_1D2
		sub	ebx, 1
		jz	short loc_1BA
		push	edi
		push	esi
		call	_BN_cmp
		add	esp, 8
		test	eax, eax
		jns	short loc_18C

loc_1B0:				; CODE XREF: _bn_rand_range+F7j
		pop	esi
		pop	ebp
		pop	edi
		mov	eax, 1
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1BA:				; CODE XREF: _bn_rand_range+124j
		push	114h

loc_1BF:				; CODE XREF: _bn_rand_range+104j
		push	offset ??_C@_0BG@BDCFJOOA@?4?2crypto?2bn?2bn_rand?4c?$AA@ ; ".\\crypto\\bn\\bn_rand.c"
		push	71h ; 'q'
		push	7Ah ; 'z'
		push	3
		call	_ERR_put_error
		add	esp, 14h

loc_1D2:				; CODE XREF: _bn_rand_range+A2j
					; _bn_rand_range+C3j ...
		pop	esi
		pop	ebp
		pop	edi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1D9:				; CODE XREF: _bn_rand_range+25j
					; _bn_rand_range+2Fj
		push	0E6h ; 'æ'
		push	offset ??_C@_0BG@BDCFJOOA@?4?2crypto?2bn?2bn_rand?4c?$AA@ ; ".\\crypto\\bn\\bn_rand.c"
		push	73h ; 's'
		push	7Ah ; 'z'
		push	3
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	ebx
		retn
_bn_rand_range	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1F8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_bnrand		proc near		; CODE XREF: _BN_bntest_rand+12p
					; _BN_pseudo_rand+12p ...

var_28		= qword	ptr -28h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
Time		= qword	ptr -8
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	eax, 10h
		call	__chkstk
		mov	ecx, [esp+10h+arg_8]
		push	ebp
		xor	ebp, ebp
		test	ecx, ecx
		js	loc_3BD
		cmp	ecx, 1
		jnz	short loc_28A
		cmp	[esp+14h+arg_C], ebp
		jg	loc_3BD

loc_220:				; CODE XREF: _bnrand+94j
		lea	eax, [ecx+7]
		cdq
		and	edx, 7
		push	ebx
		push	esi
		lea	ebx, [edx+eax]
		lea	eax, [ecx-1]
		sar	ebx, 3
		and	eax, 80000007h
		jns	short loc_23E
		dec	eax
		or	eax, 0FFFFFFF8h
		inc	eax

loc_23E:				; CODE XREF: _bnrand+3Fj
		mov	[esp+1Ch+var_10], eax
		lea	ecx, [eax+1]
		push	8Ah ; ''
		mov	eax, 0FFh
		shl	eax, cl
		push	offset ??_C@_0BG@BDCFJOOA@?4?2crypto?2bn?2bn_rand?4c?$AA@ ; ".\\crypto\\bn\\bn_rand.c"
		push	ebx
		mov	[esp+28h+var_C], eax
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jnz	short loc_2A5
		push	8Ch ; ''
		push	offset ??_C@_0BG@BDCFJOOA@?4?2crypto?2bn?2bn_rand?4c?$AA@ ; ".\\crypto\\bn\\bn_rand.c"
		push	41h ; 'A'
		push	7Fh ; ''
		push	3
		call	_ERR_put_error
		add	esp, 14h
		mov	eax, ebp
		pop	esi
		pop	ebx
		pop	ebp
		add	esp, 10h
		retn
; ---------------------------------------------------------------------------

loc_28A:				; CODE XREF: _bnrand+1Cj
		test	ecx, ecx
		jnz	short loc_220
		push	ecx
		push	[esp+18h+arg_4]
		call	_BN_set_word
		add	esp, 8
		mov	eax, 1
		pop	ebp
		add	esp, 10h
		retn
; ---------------------------------------------------------------------------

loc_2A5:				; CODE XREF: _bnrand+6Fj
		lea	eax, [esp+1Ch+Time]
		push	edi
		push	eax		; Time
		call	dword ptr ds:__imp___time64
		add	esp, 4
		mov	eax, 8
		call	__chkstk
		xorps	xmm0, xmm0
		lea	eax, [esp+28h+Time]
		movsd	[esp+28h+var_28], xmm0
		push	8
		push	eax
		call	_RAND_add
		mov	edi, [esp+30h+arg_0]
		add	esp, 10h
		push	ebx
		push	esi
		test	edi, edi
		jz	short loc_340
		call	_RAND_pseudo_bytes
		add	esp, 8
		cmp	eax, 0FFFFFFFFh
		jz	$err$38
		cmp	edi, 2
		jnz	short loc_34C
		xor	edi, edi
		test	ebx, ebx
		jle	short loc_34C

loc_2FB:				; CODE XREF: _bnrand+144j
		lea	eax, [esp+20h+arg_8]
		push	1
		push	eax
		call	_RAND_pseudo_bytes
		add	esp, 8
		test	eax, eax
		js	$err$38
		mov	al, byte ptr [esp+20h+arg_8]
		cmp	al, 80h	; ''
		jb	short loc_327
		test	edi, edi
		jle	short loc_327
		mov	al, [edi+esi-1]
		mov	[edi+esi], al
		jmp	short loc_339
; ---------------------------------------------------------------------------

loc_327:				; CODE XREF: _bnrand+120j _bnrand+124j
		cmp	al, 2Ah	; '*'
		jnb	short loc_331
		mov	byte ptr [edi+esi], 0
		jmp	short loc_339
; ---------------------------------------------------------------------------

loc_331:				; CODE XREF: _bnrand+131j
		cmp	al, 54h	; 'T'
		jnb	short loc_339
		mov	byte ptr [edi+esi], 0FFh

loc_339:				; CODE XREF: _bnrand+12Dj _bnrand+137j ...
		inc	edi
		cmp	edi, ebx
		jl	short loc_2FB
		jmp	short loc_34C
; ---------------------------------------------------------------------------

loc_340:				; CODE XREF: _bnrand+E5j
		call	_RAND_bytes
		add	esp, 8
		test	eax, eax
		jle	short $err$38

loc_34C:				; CODE XREF: _bnrand+FBj _bnrand+101j	...
		mov	eax, [esp+20h+arg_C]
		test	eax, eax
		js	short loc_378
		mov	ecx, [esp+20h+var_10]
		jz	short loc_370
		test	ecx, ecx
		jnz	short loc_367
		or	byte ptr [esi+1], 80h
		mov	byte ptr [esi],	1
		jmp	short loc_378
; ---------------------------------------------------------------------------

loc_367:				; CODE XREF: _bnrand+164j
		dec	ecx
		mov	al, 3
		shl	al, cl
		or	[esi], al
		jmp	short loc_378
; ---------------------------------------------------------------------------

loc_370:				; CODE XREF: _bnrand+160j
		movzx	eax, byte ptr [esi]
		bts	eax, ecx
		mov	[esi], al

loc_378:				; CODE XREF: _bnrand+15Aj _bnrand+16Dj ...
		mov	eax, [esp+20h+var_C]
		not	al
		and	[esi], al
		cmp	[esp+20h+arg_10], ebp
		jz	short loc_38B
		or	byte ptr [ebx+esi-1], 1

loc_38B:				; CODE XREF: _bnrand+18Cj
		push	[esp+20h+arg_4]
		push	ebx
		push	esi
		call	_BN_bin2bn
		add	esp, 0Ch
		mov	ecx, 1
		test	eax, eax
		cmovnz	ebp, ecx

$err$38:				; CODE XREF: _bnrand+F2j _bnrand+114j	...
		push	ebx
		push	esi
		call	_OPENSSL_cleanse
		push	esi
		call	_CRYPTO_free
		add	esp, 0Ch
		mov	eax, ebp
		pop	edi
		pop	esi
		pop	ebx
		pop	ebp
		add	esp, 10h
		retn
; ---------------------------------------------------------------------------

loc_3BD:				; CODE XREF: _bnrand+13j _bnrand+22j
		push	7Dh ; '}'
		push	offset ??_C@_0BG@BDCFJOOA@?4?2crypto?2bn?2bn_rand?4c?$AA@ ; ".\\crypto\\bn\\bn_rand.c"
		push	76h ; 'v'
		push	7Fh ; ''
		push	3
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	ebp
		add	esp, 10h
		retn
_bnrand		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3DCh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; time_t __cdecl static	time(time_t *Time)
_time		proc near
		jmp	dword ptr ds:__imp___time64
_time		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3E4h
; COMDAT (pick any)
		public ??_C@_0BG@BDCFJOOA@?4?2crypto?2bn?2bn_rand?4c?$AA@
; `string'
??_C@_0BG@BDCFJOOA@?4?2crypto?2bn?2bn_rand?4c?$AA@ db '.\crypto\bn\bn_rand.c',0
					; DATA XREF: _bn_rand_range:loc_1BFo
					; _bn_rand_range+162o ...
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; __time64_t __cdecl __time64(__time64_t *Time)
		extrn __imp___time64:near ; CODE XREF: _bnrand+B3p
					; DATA XREF: _bnrand+B3r ...
		extrn _CRYPTO_malloc:near ; CODE XREF: _bnrand+63p
		extrn _CRYPTO_free:near	; CODE XREF: _bnrand+1B3p
		extrn _OPENSSL_cleanse:near ; CODE XREF: _bnrand+1ADp
		extrn _ERR_put_error:near ; CODE XREF: _bn_rand_range+14Ep
					; _bn_rand_range+16Dp ...
		extrn _BN_num_bits:near	; CODE XREF: _bn_rand_range+38p
		extrn _BN_bin2bn:near	; CODE XREF: _bnrand+199p
		extrn _BN_sub:near	; CODE XREF: _bn_rand_range+B9p
					; _bn_rand_range+DAp
		extrn _BN_set_word:near	; CODE XREF: _bn_rand_range+4Dp
					; _bnrand+9Bp
		extrn _BN_cmp:near	; CODE XREF: _bn_rand_range+AAp
					; _bn_rand_range+CBp ...
		extrn _BN_is_bit_set:near ; CODE XREF: _bn_rand_range+61p
					; _bn_rand_range+76p
		extrn _RAND_bytes:near	; CODE XREF: _bnrand:loc_340p
		extrn _RAND_pseudo_bytes:near ;	CODE XREF: _bnrand+E7p
					; _bnrand+10Ap
		extrn _RAND_add:near	; CODE XREF: _bnrand+D5p
		extrn __chkstk:near	; CODE XREF: _bnrand+5p _bnrand+C1p
		extrn __fltused:near


		end
