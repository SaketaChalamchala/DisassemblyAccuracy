;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	8E223A5C33168D358709F302EB944374
; Input	CRC32 :	E0FE1031

; File Name   :	C:\compspace\Diff\openssl\obj\apps.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_bss		segment	para public 'BSS' use32
		assume cs:_bss
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
_ui_method	dd ?			; DATA XREF: _destroy_ui_methodr
					; _destroy_ui_method+12w ...
; HANDLE `app_tminterval'::`2'::proc
?proc@?1??app_tminterval@@9@9 dd ?	; DATA XREF: _app_tminterval+15r
					; _app_tminterval+43w
; `load_config'::`2'::load_config_called
?load_config_called@?1??load_config@@9@9 dd ? ;	DATA XREF: _load_configr
					; _load_config+14w
; `app_get_pass'::`2'::pwdbio
?pwdbio@?1??app_get_pass@@9@9 dd ?	; DATA XREF: _app_get_pass+9Br
					; _app_get_pass+CAw ...
; `app_tminterval'::`2'::tmstart
?tmstart@?1??app_tminterval@@9@9 dd ?	; DATA XREF: _app_tminterval+B6w
					; _app_tminterval+D6r
dword_14	dd ?			; DATA XREF: _app_tminterval+BFw
					; _app_tminterval+E0r
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 18h
; `app_tminterval'::`2'::warning
?warning@?1??app_tminterval@@9@9 dd 1	; DATA XREF: _app_tminterval:loc_978r
					; _app_tminterval+84w
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 1Ch
; `set_cert_ex'::`2'::cert_tbl
?cert_tbl@?1??set_cert_ex@@9@9 dd offset ??_C@_0L@JNOGJJCA@compatible?$AA@
					; DATA XREF: _set_cert_exo
					; "compatible"
dword_20	dd 0			; DATA XREF: .rdata:00000068o
					; .rdata:00000144o
		dd 0FFFFFFFFh
		dd offset ??_C@_0L@GPCPPOGC@ca_default?$AA@ ; "ca_default"
		dd offset byte_93
		dd 0FFFFFFFFh
		dd offset ??_C@_09HPOELMCI@no_header?$AA@ ; "no_header"
		dd 1, 0
off_40		dd offset ??_C@_0L@KOCPJNEK@no_version?$AA@ ; DATA XREF: .rdata:00000074o
					; .rdata:00000150o
					; "no_version"
		dd 2, 0
		dd offset ??_C@_09BMFPNGJA@no_serial?$AA@ ; "no_serial"
		dd 4, 0
		dd offset ??_C@_0L@MPMABMAL@no_signame?$AA@ ; "no_signame"
		dd 8, 0
		dd offset ??_C@_0M@LFPGDAPD@no_validity?$AA@ ; "no_validity"
		dd offset dword_20
		align 10h
		dd offset ??_C@_0L@BMNGEEIP@no_subject?$AA@ ; "no_subject"
		dd offset off_40
		dd 0
		dd offset ??_C@_09POJJKCAC@no_issuer?$AA@ ; "no_issuer"
dword_80	dd 10h,	0		; DATA XREF: .rdata:0000008Co
					; .rdata:0000015Co
		dd offset ??_C@_09NEDENPFH@no_pubkey?$AA@ ; "no_pubkey"
		dd offset dword_80
		db 3 dup(0)
byte_93		db 0			; DATA XREF: .rdata:0000002Co
		dd offset ??_C@_0O@BIDECDDG@no_extensions?$AA@ ; "no_extensions"
		dd offset dword_100
		align 10h
		dd offset ??_C@_0L@GNLOCCHG@no_sigdump?$AA@ ; "no_sigdump"
		dd offset off_200
		dd 0
		dd offset ??_C@_06MMLNDLIP@no_aux?$AA@ ; "no_aux"
		dd offset ??_C@_07BPCNMIP@nofname?$AA@+4 ; "ame"
		align 8
		dd offset ??_C@_0O@OHNPCCEE@no_attributes?$AA@ ; "no_attributes"
		dd offset loc_7FF+1
		dd 0
		dd offset ??_C@_0M@IDNMJLNK@ext_default?$AA@ ; "ext_default"
		dd 0
		dd 0F0000h
		dd offset ??_C@_09NJNIONHM@ext_error?$AA@ ; "ext_error"
		dd 10000h, 0F0000h
		dd offset ??_C@_09LNDMENIE@ext_parse?$AA@ ; "ext_parse"
		dd 20000h, 0F0000h
		dd offset ??_C@_08MKCLELCD@ext_dump?$AA@ ; "ext_dump"
		dd 30000h, 0F0000h, 3 dup(0)
dword_100	dd 0			; DATA XREF: .rdata:00000098o
					; .rdata:00000168o
; `set_name_ex'::`2'::ex_tbl
?ex_tbl@?1??set_name_ex@@9@9 dd	offset ??_C@_08DNFDMMBE@esc_2253?$AA@
					; DATA XREF: _set_name_ex+5o
					; "esc_2253"
		dd 1, 0
		dd offset ??_C@_08MOKJPHFA@esc_ctrl?$AA@ ; "esc_ctrl"
		dd 2, 0
		dd offset ??_C@_07CDEFJBOD@esc_msb?$AA@	; "esc_msb"
		dd 4, 0
		dd offset ??_C@_09FBNGBICE@use_quote?$AA@ ; "use_quote"
		dd 8, 0
		dd offset ??_C@_04LHHHFLPP@utf8?$AA@ ; "utf8"
		dd 10h,	0
		dd offset ??_C@_0M@JIPHIHCC@ignore_type?$AA@ ; "ignore_type"
		dd offset dword_20
		dd 0
		dd offset ??_C@_09GNHCDCJF@show_type?$AA@ ; "show_type"
		dd offset off_40
		align 8
		dd offset ??_C@_08KMNGFKHK@dump_all?$AA@ ; "dump_all"
		dd offset dword_80
		dd 0
		dd offset ??_C@_0L@KOBDNBHE@dump_nostr?$AA@ ; "dump_nostr"
		dd offset dword_100
		align 10h
		dd offset ??_C@_08EAJIKOBI@dump_der?$AA@ ; "dump_der"
		dd offset off_200
		dd 0
		dd offset ??_C@_06CJLEMFPD@compat?$AA@ ; "compat"
		dd 0
		dd 0FFFFFFFFh
		dd offset ??_C@_0P@MCGDLNKE@sep_comma_plus?$AA@	; "sep_comma_plus"
		dd 10000h, 0F0000h
		dd offset ??_C@_0BF@KBBKPJJN@sep_comma_plus_space?$AA@ ; "sep_comma_plus_space"
		dd 20000h, 0F0000h
		dd offset ??_C@_0BE@CGGJPCMP@sep_semi_plus_space?$AA@ ;	"sep_semi_plus_space"
		dd 30000h, 0F0000h
		dd offset ??_C@_0O@KAAJMPE@sep_multiline?$AA@ ;	"sep_multiline"
		dd 40000h, 0F0000h
		dd offset ??_C@_06GDJIMBOL@dn_rev?$AA@ ; "dn_rev"
		dd 100000h, 0
		dd offset ??_C@_07BPCNMIP@nofname?$AA@ ; "nofname"
		dd 2 dup(600000h)
		dd offset ??_C@_05DOJGLPOI@sname?$AA@ ;	"sname"
		dd 0
		dd 600000h
		dd offset ??_C@_05MMBGAPKG@lname?$AA@ ;	"lname"
		dd 200000h, 600000h
		dd offset ??_C@_05CBJPDLOK@align?$AA@ ;	"align"
		dd 2000000h, 0
		dd offset ??_C@_03PLGJJJLK@oid?$AA@ ; `string'
		dd 400000h, 600000h
off_200		dd offset ??_C@_08GFKNBJMB@space_eq?$AA@ ; DATA	XREF: .rdata:000000A4o
					; .rdata:00000174o
					; "space_eq"
		dd 800000h, 0
		dd offset ??_C@_0N@PAEHGOAB@dump_unknown?$AA@ ;	"dump_unknown"
		dd 1000000h, 0
		dd offset ??_C@_07HEMBHFCL@RFC2253?$AA@	; "RFC2253"
		dd 1110317h, 0FFFFFFFFh
		dd offset ??_C@_07FAIJGANN@oneline?$AA@	; "oneline"
		dd 82031Fh, 0FFFFFFFFh
		dd offset ??_C@_09HCOPNKIA@multiline?$AA@ ; "multiline"
		dd 2A40006h, 0FFFFFFFFh
		dd offset ??_C@_0L@GPCPPOGC@ca_default?$AA@ ; "ca_default"
		dd 2A40006h, 0FFFFFFFFh, 3 dup(0)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 254h
; COMDAT (pick any)
		public ??_C@_0L@JNOGJJCA@compatible?$AA@
; `string'
??_C@_0L@JNOGJJCA@compatible?$AA@ db 'compatible',0
					; DATA XREF: .rdata:`set_cert_ex'::`2'::cert_tblo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 260h
; COMDAT (pick any)
		public ??_C@_0L@GPCPPOGC@ca_default?$AA@
; `string'
??_C@_0L@GPCPPOGC@ca_default?$AA@ db 'ca_default',0 ; DATA XREF: .rdata:00000028o
					; .rdata:0000023Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 26Ch
; COMDAT (pick any)
		public ??_C@_09HPOELMCI@no_header?$AA@
; `string'
??_C@_09HPOELMCI@no_header?$AA@	db 'no_header',0 ; DATA XREF: .rdata:00000034o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 278h
; COMDAT (pick any)
		public ??_C@_0L@KOCPJNEK@no_version?$AA@
; `string'
??_C@_0L@KOCPJNEK@no_version?$AA@ db 'no_version',0 ; DATA XREF: .rdata:off_40o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 284h
; COMDAT (pick any)
		public ??_C@_09BMFPNGJA@no_serial?$AA@
; `string'
??_C@_09BMFPNGJA@no_serial?$AA@	db 'no_serial',0 ; DATA XREF: .rdata:0000004Co
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 290h
; COMDAT (pick any)
		public ??_C@_0L@MPMABMAL@no_signame?$AA@
; `string'
??_C@_0L@MPMABMAL@no_signame?$AA@ db 'no_signame',0 ; DATA XREF: .rdata:00000058o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 29Ch
; COMDAT (pick any)
		public ??_C@_0M@LFPGDAPD@no_validity?$AA@
; `string'
??_C@_0M@LFPGDAPD@no_validity?$AA@ db 'no_validity',0 ; DATA XREF: .rdata:00000064o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2A8h
; COMDAT (pick any)
		public ??_C@_0L@BMNGEEIP@no_subject?$AA@
; `string'
??_C@_0L@BMNGEEIP@no_subject?$AA@ db 'no_subject',0 ; DATA XREF: .rdata:00000070o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2B4h
; COMDAT (pick any)
		public ??_C@_09POJJKCAC@no_issuer?$AA@
; `string'
??_C@_09POJJKCAC@no_issuer?$AA@	db 'no_issuer',0 ; DATA XREF: .rdata:0000007Co
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2C0h
; COMDAT (pick any)
		public ??_C@_09NEDENPFH@no_pubkey?$AA@
; `string'
??_C@_09NEDENPFH@no_pubkey?$AA@	db 'no_pubkey',0 ; DATA XREF: .rdata:00000088o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2CCh
; COMDAT (pick any)
		public ??_C@_0O@BIDECDDG@no_extensions?$AA@
; `string'
??_C@_0O@BIDECDDG@no_extensions?$AA@ db	'no_extensions',0 ; DATA XREF: .rdata:00000094o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2DCh
; COMDAT (pick any)
		public ??_C@_0L@GNLOCCHG@no_sigdump?$AA@
; `string'
??_C@_0L@GNLOCCHG@no_sigdump?$AA@ db 'no_sigdump',0 ; DATA XREF: .rdata:000000A0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2E8h
; COMDAT (pick any)
		public ??_C@_06MMLNDLIP@no_aux?$AA@
; `string'
??_C@_06MMLNDLIP@no_aux?$AA@ db	'no_aux',0 ; DATA XREF: .rdata:000000ACo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 2F0h
; COMDAT (pick any)
		public ??_C@_0O@OHNPCCEE@no_attributes?$AA@
; `string'
??_C@_0O@OHNPCCEE@no_attributes?$AA@ db	'no_attributes',0 ; DATA XREF: .rdata:000000B8o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 300h
; COMDAT (pick any)
		public ??_C@_0M@IDNMJLNK@ext_default?$AA@
; `string'
??_C@_0M@IDNMJLNK@ext_default?$AA@ db 'ext_default',0 ; DATA XREF: .rdata:000000C4o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 30Ch
; COMDAT (pick any)
		public ??_C@_09NJNIONHM@ext_error?$AA@
; `string'
??_C@_09NJNIONHM@ext_error?$AA@	db 'ext_error',0 ; DATA XREF: .rdata:000000D0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 318h
; COMDAT (pick any)
		public ??_C@_09LNDMENIE@ext_parse?$AA@
; `string'
??_C@_09LNDMENIE@ext_parse?$AA@	db 'ext_parse',0 ; DATA XREF: .rdata:000000DCo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 324h
; COMDAT (pick any)
		public ??_C@_08MKCLELCD@ext_dump?$AA@
; `string'
??_C@_08MKCLELCD@ext_dump?$AA@ db 'ext_dump',0 ; DATA XREF: .rdata:000000E8o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 330h
; COMDAT (pick any)
		public ??_C@_08DNFDMMBE@esc_2253?$AA@
; `string'
??_C@_08DNFDMMBE@esc_2253?$AA@ db 'esc_2253',0
					; DATA XREF: .rdata:`set_name_ex'::`2'::ex_tblo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 33Ch
; COMDAT (pick any)
		public ??_C@_08MOKJPHFA@esc_ctrl?$AA@
; `string'
??_C@_08MOKJPHFA@esc_ctrl?$AA@ db 'esc_ctrl',0 ; DATA XREF: .rdata:00000110o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 348h
; COMDAT (pick any)
		public ??_C@_07CDEFJBOD@esc_msb?$AA@
; `string'
??_C@_07CDEFJBOD@esc_msb?$AA@ db 'esc_msb',0 ; DATA XREF: .rdata:0000011Co
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 350h
; COMDAT (pick any)
		public ??_C@_09FBNGBICE@use_quote?$AA@
; `string'
??_C@_09FBNGBICE@use_quote?$AA@	db 'use_quote',0 ; DATA XREF: .rdata:00000128o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 35Ch
; COMDAT (pick any)
		public ??_C@_04LHHHFLPP@utf8?$AA@
; `string'
??_C@_04LHHHFLPP@utf8?$AA@ db 'utf8',0  ; DATA XREF: .rdata:00000134o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 364h
; COMDAT (pick any)
		public ??_C@_0M@JIPHIHCC@ignore_type?$AA@
; `string'
??_C@_0M@JIPHIHCC@ignore_type?$AA@ db 'ignore_type',0 ; DATA XREF: .rdata:00000140o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 370h
; COMDAT (pick any)
		public ??_C@_09GNHCDCJF@show_type?$AA@
; `string'
??_C@_09GNHCDCJF@show_type?$AA@	db 'show_type',0 ; DATA XREF: .rdata:0000014Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 37Ch
; COMDAT (pick any)
		public ??_C@_08KMNGFKHK@dump_all?$AA@
; `string'
??_C@_08KMNGFKHK@dump_all?$AA@ db 'dump_all',0 ; DATA XREF: .rdata:00000158o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 388h
; COMDAT (pick any)
		public ??_C@_0L@KOBDNBHE@dump_nostr?$AA@
; `string'
??_C@_0L@KOBDNBHE@dump_nostr?$AA@ db 'dump_nostr',0 ; DATA XREF: .rdata:00000164o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 394h
; COMDAT (pick any)
		public ??_C@_08EAJIKOBI@dump_der?$AA@
; `string'
??_C@_08EAJIKOBI@dump_der?$AA@ db 'dump_der',0 ; DATA XREF: .rdata:00000170o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3A0h
; COMDAT (pick any)
		public ??_C@_06CJLEMFPD@compat?$AA@
; `string'
??_C@_06CJLEMFPD@compat?$AA@ db	'compat',0 ; DATA XREF: .rdata:0000017Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3A8h
; COMDAT (pick any)
		public ??_C@_0P@MCGDLNKE@sep_comma_plus?$AA@
; `string'
??_C@_0P@MCGDLNKE@sep_comma_plus?$AA@ db 'sep_comma_plus',0 ; DATA XREF: .rdata:00000188o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3B8h
; COMDAT (pick any)
		public ??_C@_0BF@KBBKPJJN@sep_comma_plus_space?$AA@
; `string'
??_C@_0BF@KBBKPJJN@sep_comma_plus_space?$AA@ db	'sep_comma_plus_space',0
					; DATA XREF: .rdata:00000194o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3D0h
; COMDAT (pick any)
		public ??_C@_0BE@CGGJPCMP@sep_semi_plus_space?$AA@
; `string'
??_C@_0BE@CGGJPCMP@sep_semi_plus_space?$AA@ db 'sep_semi_plus_space',0
					; DATA XREF: .rdata:000001A0o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3E4h
; COMDAT (pick any)
		public ??_C@_0O@KAAJMPE@sep_multiline?$AA@
; `string'
??_C@_0O@KAAJMPE@sep_multiline?$AA@ db 'sep_multiline',0 ; DATA XREF: .rdata:000001ACo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3F4h
; COMDAT (pick any)
		public ??_C@_06GDJIMBOL@dn_rev?$AA@
; `string'
??_C@_06GDJIMBOL@dn_rev?$AA@ db	'dn_rev',0 ; DATA XREF: .rdata:000001B8o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 3FCh
; COMDAT (pick any)
		public ??_C@_07BPCNMIP@nofname?$AA@
; `string'
??_C@_07BPCNMIP@nofname?$AA@ db	'nofname',0 ; DATA XREF: .rdata:000001C4o
					; .rdata:000000B0o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 404h
; COMDAT (pick any)
		public ??_C@_05DOJGLPOI@sname?$AA@
; `string'
??_C@_05DOJGLPOI@sname?$AA@ db 'sname',0 ; DATA XREF: .rdata:000001D0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40Ch
; COMDAT (pick any)
		public ??_C@_05MMBGAPKG@lname?$AA@
; `string'
??_C@_05MMBGAPKG@lname?$AA@ db 'lname',0 ; DATA XREF: .rdata:000001DCo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 414h
; COMDAT (pick any)
		public ??_C@_05CBJPDLOK@align?$AA@
; `string'
??_C@_05CBJPDLOK@align?$AA@ db 'align',0 ; DATA XREF: .rdata:000001E8o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 41Ch
; COMDAT (pick any)
		public ??_C@_03PLGJJJLK@oid?$AA@
; `string'
??_C@_03PLGJJJLK@oid?$AA@ dd 64696Fh	; DATA XREF: .rdata:000001F4o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 420h
; COMDAT (pick any)
		public ??_C@_08GFKNBJMB@space_eq?$AA@
; `string'
??_C@_08GFKNBJMB@space_eq?$AA@ db 'space_eq',0 ; DATA XREF: .rdata:off_200o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 42Ch
; COMDAT (pick any)
		public ??_C@_0N@PAEHGOAB@dump_unknown?$AA@
; `string'
??_C@_0N@PAEHGOAB@dump_unknown?$AA@ db 'dump_unknown',0 ; DATA XREF: .rdata:0000020Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 43Ch
; COMDAT (pick any)
		public ??_C@_07HEMBHFCL@RFC2253?$AA@
; `string'
??_C@_07HEMBHFCL@RFC2253?$AA@ db 'RFC2253',0 ; DATA XREF: .rdata:00000218o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 444h
; COMDAT (pick any)
		public ??_C@_07FAIJGANN@oneline?$AA@
; `string'
??_C@_07FAIJGANN@oneline?$AA@ db 'oneline',0 ; DATA XREF: .rdata:00000224o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 44Ch
; COMDAT (pick any)
		public ??_C@_09HCOPNKIA@multiline?$AA@
; `string'
??_C@_09HCOPNKIA@multiline?$AA@	db 'multiline',0 ; DATA XREF: .rdata:00000230o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 458h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl WIN32_rename(LPCSTR lpExistingFileName, LPCSTR lpNewFileName)
_WIN32_rename	proc near		; CODE XREF: _rotate_index+12Ep
					; _rotate_index+182p ...

lpExistingFileName= dword ptr  4
lpNewFileName	= dword	ptr  8

		push	esi
		mov	esi, [esp+4+lpNewFileName]
		push	esi		; lpNewFileName
		push	[esp+8+lpExistingFileName] ; lpExistingFileName
		call	dword ptr ds:__imp__MoveFileA@8	; MoveFileA(x,x)
		test	eax, eax
		jnz	short loc_4E0
		call	dword ptr ds:__imp__GetLastError@0 ; GetLastError()
		cmp	eax, 0B7h ; '·'
		jz	short loc_47E
		cmp	eax, 50h ; 'P'
		jnz	short loc_49E

loc_47E:				; CODE XREF: _WIN32_rename+1Fj
		push	esi		; lpFileName
		call	dword ptr ds:__imp__DeleteFileA@4 ; DeleteFileA(x)
		test	eax, eax
		jz	short loc_498
		push	esi		; lpNewFileName
		push	[esp+8+lpExistingFileName] ; lpExistingFileName
		call	dword ptr ds:__imp__MoveFileA@8	; MoveFileA(x,x)
		test	eax, eax
		jnz	short loc_4E0

loc_498:				; CODE XREF: _WIN32_rename+2Fj
		call	dword ptr ds:__imp__GetLastError@0 ; GetLastError()

loc_49E:				; CODE XREF: _WIN32_rename+24j
		cmp	eax, 2
		jz	short loc_4CF
		cmp	eax, 3
		jz	short loc_4CF
		cmp	eax, 5
		jnz	short loc_4BE
		call	dword ptr ds:__imp___errno
		pop	esi
		mov	dword ptr [eax], 0Dh
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_4BE:				; CODE XREF: _WIN32_rename+53j
		call	dword ptr ds:__imp___errno
		pop	esi
		mov	dword ptr [eax], 16h
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

loc_4CF:				; CODE XREF: _WIN32_rename+49j
					; _WIN32_rename+4Ej
		call	dword ptr ds:__imp___errno

$err$27:
		mov	dword ptr [eax], 2
		or	eax, 0FFFFFFFFh
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_4E0:				; CODE XREF: _WIN32_rename+12j
					; _WIN32_rename+3Ej
		xor	eax, eax

$ok$28:
		pop	esi
		retn
_WIN32_rename	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4E4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public ___local_stdio_printf_options
___local_stdio_printf_options proc near	; CODE XREF: __vfprintf_l+10p
					; _fprintf+Fp
		mov	eax, offset ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
		retn
___local_stdio_printf_options endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4ECh
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public ___local_stdio_scanf_options
___local_stdio_scanf_options proc near	; CODE XREF: __vsscanf_l+12p
					; _sscanf+11p
		mov	eax, offset ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
		retn
___local_stdio_scanf_options endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4F4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl _vfprintf_l(FILE *File, const char *Format, _locale_t Locale, va_list ArgList)
		public __vfprintf_l
__vfprintf_l	proc near

File		= dword	ptr  4
Format		= dword	ptr  8
Locale		= dword	ptr  0Ch
ArgList		= dword	ptr  10h

		push	[esp+ArgList]
		push	[esp+4+Locale]
		push	[esp+8+Format]
		push	[esp+0Ch+File]
		call	___local_stdio_printf_options
		push	dword ptr [eax+4]
		push	dword ptr [eax]
		call	dword ptr ds:__imp____stdio_common_vfprintf
		add	esp, 18h
		retn
__vfprintf_l	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 518h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public __vsscanf_l
__vsscanf_l	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	[esp+arg_C]
		push	[esp+4+arg_8]
		push	[esp+8+arg_4]
		push	0FFFFFFFFh
		push	[esp+10h+arg_0]
		call	___local_stdio_scanf_options
		push	dword ptr [eax+4]
		push	dword ptr [eax]
		call	dword ptr ds:__imp____stdio_common_vsscanf
		add	esp, 1Ch
		retn
__vsscanf_l	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 540h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _add_oid_section
_add_oid_section proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		push	edi
		mov	edi, [esp+8+arg_4]
		push	offset ??_C@_0M@HCKPEIO@oid_section?$AA@ ; "oid_section"
		push	0
		push	edi
		call	_NCONF_get_string
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jnz	short loc_567
		call	_ERR_clear_error
		pop	edi
		lea	eax, [esi+1]
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_567:				; CODE XREF: _add_oid_section+1Aj
		push	esi
		push	edi
		call	_NCONF_get_section
		mov	edi, eax
		add	esp, 8
		test	edi, edi
		jnz	short loc_58E
		push	esi
		push	offset ??_C@_0CA@HDAKCCMK@problem?5loading?5oid?5section?5?$CFs?6?$AA@ ; "problem loading oid section %s\n"
		push	[esp+10h+arg_0]
		call	_BIO_printf
		add	esp, 0Ch
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_58E:				; CODE XREF: _add_oid_section+35j
		push	ebx
		push	edi
		xor	esi, esi
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jle	short loc_5CB
		xchg	ax, ax

loc_5A0:				; CODE XREF: _add_oid_section+89j
		push	esi
		push	edi
		call	_sk_value
		mov	ebx, eax
		mov	ecx, [ebx+4]
		push	ecx
		push	ecx
		push	dword ptr [ebx+8]
		call	_OBJ_create
		add	esp, 14h
		test	eax, eax
		jz	short loc_5D4
		push	edi
		inc	esi
		call	_sk_num
		add	esp, 4
		cmp	esi, eax
		jl	short loc_5A0

loc_5CB:				; CODE XREF: _add_oid_section+5Cj
		pop	ebx
		pop	edi
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_5D4:				; CODE XREF: _add_oid_section+7Bj
		push	dword ptr [ebx+8]
		push	dword ptr [ebx+4]
		push	offset ??_C@_0BP@DCFHMIBP@problem?5creating?5object?5?$CFs?$DN?$CFs?6?$AA@ ; "problem creating object %s=%s\n"
		push	[esp+18h+arg_0]
		call	_BIO_printf
		add	esp, 10h
		xor	eax, eax
		pop	ebx
		pop	edi
		pop	esi
		retn
_add_oid_section endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5F4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl app_get_pass(int,	char *Str1, int)
_app_get_pass	proc near		; CODE XREF: _app_passwd+51p
					; _app_passwd+86p

Str		= byte ptr -404h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
Str1		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 404h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+404h+var_4], eax
		push	ebx
		mov	ebx, dword ptr ds:__imp__strncmp
		push	esi
		mov	esi, [esp+40Ch+Str1]
		push	edi
		mov	edi, [esp+410h+arg_0]
		push	5		; MaxCount
		push	offset ??_C@_05OLNJAKGC@pass?3?$AA@ ; "pass:"
		push	esi		; Str1
		call	ebx ; __imp__strncmp
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_658
		lea	eax, [esi+5]

loc_637:				; CODE XREF: _app_get_pass+84j
		push	eax
		call	_BUF_strdup
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [esp+404h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 404h
		retn
; ---------------------------------------------------------------------------

loc_658:				; CODE XREF: _app_get_pass+3Ej
		push	4		; MaxCount
		push	offset ??_C@_04MGCDLKHE@env?3?$AA@ ; "env:"
		push	esi		; Str1
		call	ebx ; __imp__strncmp
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_685
		add	esi, 4
		push	esi		; VarName
		call	dword ptr ds:__imp__getenv
		add	esp, 4
		test	eax, eax
		jnz	short loc_637
		push	esi
		push	offset ??_C@_0CE@NKEIKLNB@Can?8t?5read?5environment?5variable?5@ ; "Can't read environment variable %s\n"
		jmp	loc_7C3
; ---------------------------------------------------------------------------

loc_685:				; CODE XREF: _app_get_pass+73j
		cmp	[esp+410h+arg_8], 0
		jz	short loc_69C
		mov	eax, ds:?pwdbio@?1??app_get_pass@@9@9 ;	`app_get_pass'::`2'::pwdbio
		test	eax, eax
		jnz	loc_736

loc_69C:				; CODE XREF: _app_get_pass+99j
		push	5		; MaxCount
		push	offset ??_C@_05BOPHDICO@file?3?$AA@ ; "file:"
		push	esi		; Str1
		call	ebx ; __imp__strncmp
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_6D2
		add	esi, 5
		push	offset ??_C@_01KDCPPGHE@r?$AA@ ; `string'
		push	esi
		call	_BIO_new_file
		add	esp, 8
		mov	ds:?pwdbio@?1??app_get_pass@@9@9, eax ;	`app_get_pass'::`2'::pwdbio
		test	eax, eax
		jnz	short loc_736
		push	esi
		push	offset ??_C@_0BE@DGGEJBEC@Can?8t?5open?5file?5?$CFs?6?$AA@ ; "Can't open file %s\n"
		jmp	loc_7C3
; ---------------------------------------------------------------------------

loc_6D2:				; CODE XREF: _app_get_pass+B7j
		mov	ecx, offset ??_C@_05MHOFLBOO@stdin?$AA@	; "stdin"
		mov	eax, esi

loc_6D9:				; CODE XREF: _app_get_pass+FFj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_6F9
		test	dl, dl
		jz	short loc_6F5
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_6F9
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_6D9

loc_6F5:				; CODE XREF: _app_get_pass+EDj
		xor	eax, eax
		jmp	short loc_6FE
; ---------------------------------------------------------------------------

loc_6F9:				; CODE XREF: _app_get_pass+E9j
					; _app_get_pass+F5j
		sbb	eax, eax
		or	eax, 1

loc_6FE:				; CODE XREF: _app_get_pass+103j
		test	eax, eax
		jnz	loc_7BD
		push	eax
		push	eax
		call	dword ptr ds:__imp____acrt_iob_func
		add	esp, 4
		push	eax
		call	_BIO_new_fp
		add	esp, 8
		mov	ds:?pwdbio@?1??app_get_pass@@9@9, eax ;	`app_get_pass'::`2'::pwdbio
		test	eax, eax
		jnz	short loc_736
		push	offset ??_C@_0BK@EEFMFEJC@Can?8t?5open?5BIO?5for?5stdin?6?$AA@ ; "Can't open BIO for stdin\n"
		push	edi
		call	_BIO_printf
		add	esp, 8
		jmp	loc_7CC
; ---------------------------------------------------------------------------

loc_736:				; CODE XREF: _app_get_pass+A2j
					; _app_get_pass+D1j ...
		push	400h
		lea	ecx, [esp+414h+Str]
		push	ecx
		push	eax
		call	_BIO_gets
		add	esp, 0Ch
		mov	esi, eax
		cmp	[esp+410h+arg_8], 1
		jz	short loc_76D
		push	ds:?pwdbio@?1??app_get_pass@@9@9 ; `app_get_pass'::`2'::pwdbio
		call	_BIO_free_all
		add	esp, 4
		mov	ds:?pwdbio@?1??app_get_pass@@9@9, 0 ; `app_get_pass'::`2'::pwdbio

loc_76D:				; CODE XREF: _app_get_pass+15Fj
		test	esi, esi
		jg	short loc_781
		push	offset ??_C@_0CB@KJOAPACB@Error?5reading?5password?5from?5BIO?6@ ; "Error reading password from	BIO\n"
		push	edi
		call	_BIO_printf
		add	esp, 8
		jmp	short loc_7CC
; ---------------------------------------------------------------------------

loc_781:				; CODE XREF: _app_get_pass+17Bj
		lea	eax, [esp+410h+Str]
		push	0Ah		; Val
		push	eax		; Str
		call	dword ptr ds:__imp__strchr
		add	esp, 8
		test	eax, eax
		jz	short loc_798
		mov	byte ptr [eax],	0

loc_798:				; CODE XREF: _app_get_pass+19Fj
		lea	eax, [esp+410h+Str]
		push	eax
		call	_BUF_strdup
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [esp+404h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 404h
		retn
; ---------------------------------------------------------------------------

loc_7BD:				; CODE XREF: _app_get_pass+10Cj
		push	esi
		push	offset ??_C@_0CA@FEIKIBOM@Invalid?5password?5argument?5?$CC?$CFs?$CC?6?$AA@ ; "Invalid password	argument \"%s\"\n"

loc_7C3:				; CODE XREF: _app_get_pass+8Cj
					; _app_get_pass+D9j
		push	edi
		call	_BIO_printf
		add	esp, 0Ch

loc_7CC:				; CODE XREF: _app_get_pass+13Dj
					; _app_get_pass+18Bj
		mov	ecx, [esp+410h+var_4]
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 404h
		retn
_app_get_pass	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7E8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _app_init
_app_init	proc near
		mov	eax, 1
		retn
_app_init	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7F0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl app_isdir(LPCSTR lpFileName)
		public _app_isdir
_app_isdir	proc near

var_144		= dword	ptr -144h
var_4		= dword	ptr -4
lpFileName	= dword	ptr  4

		mov	eax, 144h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie

loc_7FF:				; DATA XREF: .rdata:000000BCo
		xor	eax, esp
		mov	[esp+144h+var_4], eax
		mov	eax, [esp+144h+lpFileName]
		lea	ecx, [esp+144h+var_144]
		push	ecx		; lpFindFileData
		push	eax		; lpFileName
		call	dword ptr ds:__imp__FindFirstFileA@8 ; FindFirstFileA(x,x)
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_836
		or	eax, eax
		mov	ecx, [esp+144h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 144h
		retn
; ---------------------------------------------------------------------------

loc_836:				; CODE XREF: _app_isdir+2Dj
		push	eax		; hFindFile
		call	dword ptr ds:__imp__FindClose@4	; FindClose(x)
		mov	eax, [esp+144h+var_144]
		mov	ecx, [esp+144h+var_4]
		shr	eax, 4
		xor	ecx, esp
		and	eax, 1
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 144h
		retn
_app_isdir	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 85Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl app_passwd(int, char *Str1, char *, int, int)
		public _app_passwd
_app_passwd	proc near

arg_0		= dword	ptr  4
Str1		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		push	ebx
		mov	ebx, [esp+4+arg_8]
		push	esi
		push	edi
		mov	edi, [esp+0Ch+Str1]
		test	ebx, ebx
		jz	short loc_8A1
		test	edi, edi
		jz	short loc_8A1
		mov	ecx, ebx
		mov	eax, edi

loc_873:				; CODE XREF: _app_passwd+31j
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_893
		test	dl, dl
		jz	short loc_88F
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_893
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_873

loc_88F:				; CODE XREF: _app_passwd+1Fj
		xor	eax, eax
		jmp	short loc_898
; ---------------------------------------------------------------------------

loc_893:				; CODE XREF: _app_passwd+1Bj
					; _app_passwd+27j
		sbb	eax, eax
		or	eax, 1

loc_898:				; CODE XREF: _app_passwd+35j
		test	eax, eax
		jnz	short loc_8A1
		lea	esi, [eax+1]
		jmp	short loc_8A3
; ---------------------------------------------------------------------------

loc_8A1:				; CODE XREF: _app_passwd+Dj
					; _app_passwd+11j ...
		xor	esi, esi

loc_8A3:				; CODE XREF: _app_passwd+43j
		test	edi, edi
		jz	short loc_8C3
		push	esi		; int
		push	edi		; Str1
		push	[esp+14h+arg_0]	; int
		call	_app_get_pass
		mov	ecx, [esp+18h+arg_C]
		add	esp, 0Ch
		mov	[ecx], eax
		test	eax, eax
		jnz	short loc_8D1
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_8C3:				; CODE XREF: _app_passwd+49j
		mov	eax, [esp+0Ch+arg_C]
		test	eax, eax
		jz	short loc_8D1
		mov	dword ptr [eax], 0

loc_8D1:				; CODE XREF: _app_passwd+61j
					; _app_passwd+6Dj
		test	ebx, ebx
		jz	short loc_8F8
		neg	esi
		sbb	esi, esi
		and	esi, 2
		push	esi		; int
		push	ebx		; Str1
		push	[esp+14h+arg_0]	; int
		call	_app_get_pass
		mov	ecx, [esp+18h+arg_10]
		add	esp, 0Ch
		mov	[ecx], eax
		test	eax, eax
		jnz	short loc_906
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_8F8:				; CODE XREF: _app_passwd+77j
		mov	eax, [esp+0Ch+arg_10]
		test	eax, eax
		jz	short loc_906
		mov	dword ptr [eax], 0

loc_906:				; CODE XREF: _app_passwd+96j
					; _app_passwd+A2j
		pop	edi
		pop	esi
		mov	eax, 1
		pop	ebx
		retn
_app_passwd	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 910h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _app_tminterval
_app_tminterval	proc near

var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= qword	ptr -1Ch
CreationTime	= _FILETIME ptr	-14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 24h ; '$'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+24h+var_4], eax
		mov	eax, ds:?proc@?1??app_tminterval@@9@9 ;	`app_tminterval'::`2'::proc
		xorps	xmm0, xmm0
		movsd	[esp+24h+var_1C], xmm0
		test	eax, eax
		jnz	short loc_958
		call	dword ptr ds:__imp__GetCurrentProcessId@0 ; GetCurrentProcessId()
		push	eax		; dwProcessId
		push	0		; bInheritHandle
		push	400h		; dwDesiredAccess
		call	dword ptr ds:__imp__OpenProcess@12 ; OpenProcess(x,x,x)
		or	ecx, 0FFFFFFFFh
		test	eax, eax
		cmovz	eax, ecx
		mov	ds:?proc@?1??app_tminterval@@9@9, eax ;	`app_tminterval'::`2'::proc

loc_958:				; CODE XREF: _app_tminterval+25j
		cmp	[esp+24h+arg_4], 0
		jz	short loc_99E
		cmp	eax, 0FFFFFFFFh
		jz	short loc_978
		lea	ecx, [esp+24h+var_24]
		push	ecx		; lpUserTime
		lea	ecx, [esp+28h+CreationTime]
		push	ecx		; lpKernelTime
		push	ecx		; lpExitTime
		push	ecx		; lpCreationTime
		push	eax		; hProcess
		call	dword ptr ds:__imp__GetProcessTimes@20 ; GetProcessTimes(x,x,x,x,x)
		jmp	short loc_9B8
; ---------------------------------------------------------------------------

loc_978:				; CODE XREF: _app_tminterval+52j
		cmp	?warning@?1??app_tminterval@@9@9, 0 ; `app_tminterval'::`2'::warning
		jz	short loc_99E
		push	offset ??_C@_0DN@IIJMFLNE@To?5get?5meaningful?5results?0?5run?5t@ ; "To	get meaningful results,	run this pro"...
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 8
		mov	?warning@?1??app_tminterval@@9@9, 0 ; `app_tminterval'::`2'::warning

loc_99E:				; CODE XREF: _app_tminterval+4Dj
					; _app_tminterval+6Fj
		lea	eax, [esp+24h+CreationTime]
		push	eax		; lpSystemTime
		call	dword ptr ds:__imp__GetSystemTime@4 ; GetSystemTime(x)
		lea	eax, [esp+24h+var_24]
		push	eax		; lpFileTime
		lea	eax, [esp+28h+CreationTime]
		push	eax		; lpSystemTime
		call	dword ptr ds:__imp__SystemTimeToFileTime@8 ; SystemTimeToFileTime(x,x)

loc_9B8:				; CODE XREF: _app_tminterval+66j
		cmp	[esp+24h+arg_0], 0
		jnz	short loc_9E3
		mov	eax, [esp+24h+var_24]
		fld	[esp+24h+var_1C]
		mov	ds:?tmstart@?1??app_tminterval@@9@9, eax ; `app_tminterval'::`2'::tmstart
		mov	eax, [esp+24h+var_20]
		mov	ds:dword_14, eax
		mov	ecx, [esp+24h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 24h
		retn
; ---------------------------------------------------------------------------

loc_9E3:				; CODE XREF: _app_tminterval+ADj
		mov	ecx, [esp+24h+var_24]
		sub	ecx, ds:?tmstart@?1??app_tminterval@@9@9 ; `app_tminterval'::`2'::tmstart
		mov	edx, [esp+24h+var_20]
		sbb	edx, ds:dword_14
		call	__ltod3
		mulsd	xmm0, ds:__real@3e7ad7f29abcaf48
		mov	ecx, [esp+24h+var_4]
		xor	ecx, esp
		movsd	[esp+24h+var_1C], xmm0
		fld	[esp+24h+var_1C]
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 24h
		retn
_app_tminterval	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A1Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _args_verify
_args_verify	proc near

var_28		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= qword	ptr -8
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	eax, 28h ; '('
		call	__chkstk
		xor	eax, eax
		mov	[esp+28h+var_28], 0
		mov	[esp+28h+var_24], eax
		xorps	xmm0, xmm0
		mov	eax, [esp+28h+arg_0]
		mov	ecx, offset ??_C@_07EDOEKPLG@?9policy?$AA@ ; "-policy"
		push	ebx
		push	ebp
		push	esi
		mov	eax, [eax]
		push	edi
		mov	[esp+38h+var_C], eax
		xor	edi, edi
		mov	[esp+38h+var_20], 0FFFFFFFFh
		mov	ebx, [eax]
		mov	esi, [eax+4]
		xor	eax, eax
		mov	[esp+38h+var_1C], eax
		mov	[esp+38h+var_18], eax
		mov	[esp+38h+var_14], eax
		mov	eax, ebx
		movlpd	[esp+38h+var_8], xmm0

loc_A6E:				; CODE XREF: _args_verify+6Cj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_A8E
		test	dl, dl
		jz	short loc_A8A
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_A8E
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_A6E

loc_A8A:				; CODE XREF: _args_verify+5Aj
		xor	eax, eax
		jmp	short loc_A93
; ---------------------------------------------------------------------------

loc_A8E:				; CODE XREF: _args_verify+56j
					; _args_verify+62j
		sbb	eax, eax
		or	eax, 1

loc_A93:				; CODE XREF: _args_verify+70j
		mov	ebp, [esp+38h+arg_8]
		test	eax, eax
		jnz	short loc_AD7
		test	esi, esi
		jz	short loc_AC4
		push	0
		push	esi
		call	_OBJ_txt2obj
		add	esp, 8
		mov	[esp+38h+var_28], eax
		test	eax, eax
		jnz	short loc_ACB
		push	esi
		push	offset ??_C@_0BF@OKHBOGOJ@Invalid?5Policy?5?$CC?$CFs?$CC?6?$AA@	; "Invalid Policy \"%s\"\n"
		push	[esp+40h+arg_C]
		call	_BIO_printf
		add	esp, 0Ch

loc_AC4:				; CODE XREF: _args_verify+81j
		mov	dword ptr [ebp+0], 1

loc_ACB:				; CODE XREF: _args_verify+94j
		mov	ebx, [esp+38h+arg_0]
		add	dword ptr [ebx], 4
		jmp	loc_11E2
; ---------------------------------------------------------------------------

loc_AD7:				; CODE XREF: _args_verify+7Dj
		mov	ecx, offset ??_C@_08OKAIACAC@?9purpose?$AA@ ; "-purpose"
		mov	eax, ebx

loc_ADE:				; CODE XREF: _args_verify+DCj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_AFE
		test	dl, dl
		jz	short loc_AFA
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_AFE
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_ADE

loc_AFA:				; CODE XREF: _args_verify+CAj
		xor	eax, eax
		jmp	short loc_B03
; ---------------------------------------------------------------------------

loc_AFE:				; CODE XREF: _args_verify+C6j
					; _args_verify+D2j
		sbb	eax, eax
		or	eax, 1

loc_B03:				; CODE XREF: _args_verify+E0j
		test	eax, eax
		jnz	short loc_B6E
		test	esi, esi
		jnz	short loc_B1E
		mov	ebx, [esp+38h+arg_0]
		mov	dword ptr [ebp+0], 1
		add	dword ptr [ebx], 4
		jmp	loc_11E2
; ---------------------------------------------------------------------------

loc_B1E:				; CODE XREF: _args_verify+EDj
		push	esi
		call	_X509_PURPOSE_get_by_sname
		add	esp, 4
		test	eax, eax
		jns	short loc_B4F
		push	offset ??_C@_0BG@MLBGEMEI@unrecognized?5purpose?6?$AA@ ; "unrecognized purpose\n"
		push	[esp+3Ch+arg_C]
		call	_BIO_printf
		mov	ebx, [esp+40h+arg_0]
		add	esp, 8
		mov	dword ptr [ebp+0], 1
		add	dword ptr [ebx], 4
		jmp	loc_11E2
; ---------------------------------------------------------------------------

loc_B4F:				; CODE XREF: _args_verify+10Dj
		push	eax
		call	_X509_PURPOSE_get0
		push	eax
		call	_X509_PURPOSE_get_id
		mov	ebx, [esp+40h+arg_0]
		add	esp, 8
		mov	[esp+38h+var_24], eax
		add	dword ptr [ebx], 4
		jmp	loc_11E2
; ---------------------------------------------------------------------------

loc_B6E:				; CODE XREF: _args_verify+E9j
		mov	ecx, offset ??_C@_0O@GLCJCNHH@?9verify_depth?$AA@ ; "-verify_depth"
		mov	eax, ebx
		nop	dword ptr [eax+00000000h]

loc_B7C:				; CODE XREF: _args_verify+17Aj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_B9C
		test	dl, dl
		jz	short loc_B98
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_B9C
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_B7C

loc_B98:				; CODE XREF: _args_verify+168j
		xor	eax, eax
		jmp	short loc_BA1
; ---------------------------------------------------------------------------

loc_B9C:				; CODE XREF: _args_verify+164j
					; _args_verify+170j
		sbb	eax, eax
		or	eax, 1

loc_BA1:				; CODE XREF: _args_verify+17Ej
		test	eax, eax
		jnz	short loc_BDF
		test	esi, esi
		jz	short loc_BCC
		push	esi		; Str
		call	dword ptr ds:__imp__atoi
		add	esp, 4
		mov	[esp+38h+var_20], eax
		test	eax, eax
		jns	short loc_BD3
		push	offset ??_C@_0P@PLGBDNLB@invalid?5depth?6?$AA@ ; "invalid depth\n"
		push	[esp+3Ch+arg_C]
		call	_BIO_printf
		add	esp, 8

loc_BCC:				; CODE XREF: _args_verify+18Bj
		mov	dword ptr [ebp+0], 1

loc_BD3:				; CODE XREF: _args_verify+19Dj
		mov	ebx, [esp+38h+arg_0]
		add	dword ptr [ebx], 4
		jmp	loc_11E2
; ---------------------------------------------------------------------------

loc_BDF:				; CODE XREF: _args_verify+187j
		mov	ecx, offset ??_C@_07FHCFGGIA@?9attime?$AA@ ; "-attime"
		mov	eax, ebx
		nop	word ptr [eax+eax+00h]

loc_BEC:				; CODE XREF: _args_verify+1EAj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_C0C
		test	dl, dl
		jz	short loc_C08
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_C0C
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_BEC

loc_C08:				; CODE XREF: _args_verify+1D8j
		xor	eax, eax
		jmp	short loc_C11
; ---------------------------------------------------------------------------

loc_C0C:				; CODE XREF: _args_verify+1D4j
					; _args_verify+1E0j
		sbb	eax, eax
		or	eax, 1

loc_C11:				; CODE XREF: _args_verify+1EEj
		test	eax, eax
		jnz	short loc_C78
		test	esi, esi
		jnz	short loc_C2C
		mov	ebx, [esp+38h+arg_0]
		mov	dword ptr [ebp+0], 1
		add	dword ptr [ebx], 4
		jmp	loc_11E2
; ---------------------------------------------------------------------------

loc_C2C:				; CODE XREF: _args_verify+1FBj
		lea	eax, [esp+38h+var_10]
		push	eax
		push	offset ??_C@_03LMKFJNEF@?$CFli?$AA@ ; "%li"
		push	esi		; Src
		call	_sscanf
		add	esp, 0Ch
		cmp	eax, 1
		jz	short loc_C5F
		push	esi
		push	offset ??_C@_0BM@BLOMJHGB@Error?5parsing?5timestamp?5?$CFs?6?$AA@ ; "Error parsing timestamp %s\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 0Ch
		mov	dword ptr [ebp+0], 1

loc_C5F:				; CODE XREF: _args_verify+226j
		mov	ebx, [esp+38h+arg_0]
		mov	eax, [esp+38h+var_10]
		cdq
		mov	dword ptr [esp+38h+var_8], eax
		add	dword ptr [ebx], 4
		mov	dword ptr [esp+38h+var_8+4], edx
		jmp	loc_11E2
; ---------------------------------------------------------------------------

loc_C78:				; CODE XREF: _args_verify+1F7j
		mov	ecx, offset ??_C@_0BB@CBGFOLCL@?9verify_hostname?$AA@ ;	"-verify_hostname"
		mov	eax, ebx

loc_C7F:				; CODE XREF: _args_verify+27Dj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_C9F
		test	dl, dl
		jz	short loc_C9B
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_C9F
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_C7F

loc_C9B:				; CODE XREF: _args_verify+26Bj
		xor	eax, eax
		jmp	short loc_CA4
; ---------------------------------------------------------------------------

loc_C9F:				; CODE XREF: _args_verify+267j
					; _args_verify+273j
		sbb	eax, eax
		or	eax, 1

loc_CA4:				; CODE XREF: _args_verify+281j
		test	eax, eax
		jnz	short loc_CC3
		test	esi, esi
		jnz	short loc_CB3
		mov	dword ptr [ebp+0], 1

loc_CB3:				; CODE XREF: _args_verify+28Ej
		mov	ebx, [esp+38h+arg_0]
		mov	[esp+38h+var_1C], esi
		add	dword ptr [ebx], 4
		jmp	loc_11E2
; ---------------------------------------------------------------------------

loc_CC3:				; CODE XREF: _args_verify+28Aj
		mov	ecx, offset ??_C@_0O@IDCHAMO@?9verify_email?$AA@ ; "-verify_email"
		mov	eax, ebx
		xchg	ax, ax

loc_CCC:				; CODE XREF: _args_verify+2CAj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_CEC
		test	dl, dl
		jz	short loc_CE8
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_CEC
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_CCC

loc_CE8:				; CODE XREF: _args_verify+2B8j
		xor	eax, eax
		jmp	short loc_CF1
; ---------------------------------------------------------------------------

loc_CEC:				; CODE XREF: _args_verify+2B4j
					; _args_verify+2C0j
		sbb	eax, eax
		or	eax, 1

loc_CF1:				; CODE XREF: _args_verify+2CEj
		test	eax, eax
		jnz	short loc_D10
		test	esi, esi
		jnz	short loc_D00
		mov	dword ptr [ebp+0], 1

loc_D00:				; CODE XREF: _args_verify+2DBj
		mov	ebx, [esp+38h+arg_0]
		mov	[esp+38h+var_18], esi
		add	dword ptr [ebx], 4
		jmp	loc_11E2
; ---------------------------------------------------------------------------

loc_D10:				; CODE XREF: _args_verify+2D7j
		mov	ecx, offset ??_C@_0L@BFLANKHI@?9verify_ip?$AA@ ; "-verify_ip"
		mov	eax, ebx
		nop	dword ptr [eax+eax+00h]

loc_D1C:				; CODE XREF: _args_verify+31Aj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_D3C
		test	dl, dl
		jz	short loc_D38
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_D3C
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_D1C

loc_D38:				; CODE XREF: _args_verify+308j
		xor	eax, eax
		jmp	short loc_D41
; ---------------------------------------------------------------------------

loc_D3C:				; CODE XREF: _args_verify+304j
					; _args_verify+310j
		sbb	eax, eax
		or	eax, 1

loc_D41:				; CODE XREF: _args_verify+31Ej
		test	eax, eax
		jnz	short loc_D60
		test	esi, esi
		jnz	short loc_D50
		mov	dword ptr [ebp+0], 1

loc_D50:				; CODE XREF: _args_verify+32Bj
		mov	ebx, [esp+38h+arg_0]
		mov	[esp+38h+var_14], esi
		add	dword ptr [ebx], 4
		jmp	loc_11E2
; ---------------------------------------------------------------------------

loc_D60:				; CODE XREF: _args_verify+327j
		mov	ecx, offset ??_C@_0BB@MAMKNOBM@?9ignore_critical?$AA@ ;	"-ignore_critical"
		mov	eax, ebx
		nop	dword ptr [eax+eax+00h]

loc_D6C:				; CODE XREF: _args_verify+36Aj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_D8C
		test	dl, dl
		jz	short loc_D88
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_D8C
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_D6C

loc_D88:				; CODE XREF: _args_verify+358j
		xor	eax, eax
		jmp	short loc_D91
; ---------------------------------------------------------------------------

loc_D8C:				; CODE XREF: _args_verify+354j
					; _args_verify+360j
		sbb	eax, eax
		or	eax, 1

loc_D91:				; CODE XREF: _args_verify+36Ej
		test	eax, eax
		jnz	short loc_D9D
		lea	edi, [eax+10h]
		jmp	loc_11DE
; ---------------------------------------------------------------------------

loc_D9D:				; CODE XREF: _args_verify+377j
		mov	ecx, offset ??_C@_0P@KGEGMNHK@?9issuer_checks?$AA@ ; "-issuer_checks"
		mov	eax, ebx

loc_DA4:				; CODE XREF: _args_verify+3A2j
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_DC4
		test	dl, dl
		jz	short loc_DC0
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_DC4
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_DA4

loc_DC0:				; CODE XREF: _args_verify+390j
		xor	eax, eax
		jmp	short loc_DC9
; ---------------------------------------------------------------------------

loc_DC4:				; CODE XREF: _args_verify+38Cj
					; _args_verify+398j
		sbb	eax, eax
		or	eax, 1

loc_DC9:				; CODE XREF: _args_verify+3A6j
		test	eax, eax
		jnz	short loc_DD5
		lea	edi, [eax+1]
		jmp	loc_11DE
; ---------------------------------------------------------------------------

loc_DD5:				; CODE XREF: _args_verify+3AFj
		mov	ecx, offset ??_C@_0L@IIGOHFBF@?9crl_check?$AA@ ; "-crl_check"
		mov	eax, ebx

loc_DDC:				; CODE XREF: _args_verify+3DAj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_DFC
		test	dl, dl
		jz	short loc_DF8
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_DFC
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_DDC

loc_DF8:				; CODE XREF: _args_verify+3C8j
		xor	eax, eax
		jmp	short loc_E01
; ---------------------------------------------------------------------------

loc_DFC:				; CODE XREF: _args_verify+3C4j
					; _args_verify+3D0j
		sbb	eax, eax
		or	eax, 1

loc_E01:				; CODE XREF: _args_verify+3DEj
		test	eax, eax
		jnz	short loc_E0D
		lea	edi, [eax+4]
		jmp	loc_11DE
; ---------------------------------------------------------------------------

loc_E0D:				; CODE XREF: _args_verify+3E7j
		mov	ecx, offset ??_C@_0P@JMLMJOLO@?9crl_check_all?$AA@ ; "-crl_check_all"
		mov	eax, ebx

loc_E14:				; CODE XREF: _args_verify+412j
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_E34
		test	dl, dl
		jz	short loc_E30
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_E34
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_E14

loc_E30:				; CODE XREF: _args_verify+400j
		xor	eax, eax
		jmp	short loc_E39
; ---------------------------------------------------------------------------

loc_E34:				; CODE XREF: _args_verify+3FCj
					; _args_verify+408j
		sbb	eax, eax
		or	eax, 1

loc_E39:				; CODE XREF: _args_verify+416j
		test	eax, eax
		jnz	short loc_E45
		lea	edi, [eax+0Ch]
		jmp	loc_11DE
; ---------------------------------------------------------------------------

loc_E45:				; CODE XREF: _args_verify+41Fj
		mov	ecx, offset ??_C@_0O@CHPKAFNL@?9policy_check?$AA@ ; "-policy_check"
		mov	eax, ebx

loc_E4C:				; CODE XREF: _args_verify+44Aj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_E6C
		test	dl, dl
		jz	short loc_E68
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_E6C
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_E4C

loc_E68:				; CODE XREF: _args_verify+438j
		xor	eax, eax
		jmp	short loc_E71
; ---------------------------------------------------------------------------

loc_E6C:				; CODE XREF: _args_verify+434j
					; _args_verify+440j
		sbb	eax, eax
		or	eax, 1

loc_E71:				; CODE XREF: _args_verify+44Ej
		test	eax, eax
		jnz	short loc_E7F
		mov	edi, 80h ; ''
		jmp	loc_11DE
; ---------------------------------------------------------------------------

loc_E7F:				; CODE XREF: _args_verify+457j
		mov	ecx, offset ??_C@_0BB@DFNKALPO@?9explicit_policy?$AA@ ;	"-explicit_policy"
		mov	eax, ebx
		nop	word ptr [eax+eax+00h]

loc_E8C:				; CODE XREF: _args_verify+48Aj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_EAC
		test	dl, dl
		jz	short loc_EA8
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_EAC
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_E8C

loc_EA8:				; CODE XREF: _args_verify+478j
		xor	eax, eax
		jmp	short loc_EB1
; ---------------------------------------------------------------------------

loc_EAC:				; CODE XREF: _args_verify+474j
					; _args_verify+480j
		sbb	eax, eax
		or	eax, 1

loc_EB1:				; CODE XREF: _args_verify+48Ej
		test	eax, eax
		jnz	short loc_EBF
		mov	edi, 100h
		jmp	loc_11DE
; ---------------------------------------------------------------------------

loc_EBF:				; CODE XREF: _args_verify+497j
		mov	ecx, offset ??_C@_0N@BIEOAHOE@?9inhibit_any?$AA@ ; "-inhibit_any"
		mov	eax, ebx
		nop	word ptr [eax+eax+00h]

loc_ECC:				; CODE XREF: _args_verify+4CAj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_EEC
		test	dl, dl
		jz	short loc_EE8
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_EEC
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_ECC

loc_EE8:				; CODE XREF: _args_verify+4B8j
		xor	eax, eax
		jmp	short loc_EF1
; ---------------------------------------------------------------------------

loc_EEC:				; CODE XREF: _args_verify+4B4j
					; _args_verify+4C0j
		sbb	eax, eax
		or	eax, 1

loc_EF1:				; CODE XREF: _args_verify+4CEj
		test	eax, eax
		jnz	short loc_EFF
		mov	edi, 200h
		jmp	loc_11DE
; ---------------------------------------------------------------------------

loc_EFF:				; CODE XREF: _args_verify+4D7j
		mov	ecx, offset ??_C@_0N@IIAGEECI@?9inhibit_map?$AA@ ; "-inhibit_map"
		mov	eax, ebx
		nop	word ptr [eax+eax+00h]

loc_F0C:				; CODE XREF: _args_verify+50Aj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_F2C
		test	dl, dl
		jz	short loc_F28
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_F2C
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_F0C

loc_F28:				; CODE XREF: _args_verify+4F8j
		xor	eax, eax
		jmp	short loc_F31
; ---------------------------------------------------------------------------

loc_F2C:				; CODE XREF: _args_verify+4F4j
					; _args_verify+500j
		sbb	eax, eax
		or	eax, 1

loc_F31:				; CODE XREF: _args_verify+50Ej
		test	eax, eax
		jnz	short loc_F3F
		mov	edi, 400h
		jmp	loc_11DE
; ---------------------------------------------------------------------------

loc_F3F:				; CODE XREF: _args_verify+517j
		mov	ecx, offset ??_C@_0N@JAAINALF@?9x509_strict?$AA@ ; "-x509_strict"
		mov	eax, ebx
		nop	word ptr [eax+eax+00h]

loc_F4C:				; CODE XREF: _args_verify+54Aj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_F6C
		test	dl, dl
		jz	short loc_F68
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_F6C
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_F4C

loc_F68:				; CODE XREF: _args_verify+538j
		xor	eax, eax
		jmp	short loc_F71
; ---------------------------------------------------------------------------

loc_F6C:				; CODE XREF: _args_verify+534j
					; _args_verify+540j
		sbb	eax, eax
		or	eax, 1

loc_F71:				; CODE XREF: _args_verify+54Ej
		test	eax, eax
		jnz	short loc_F7D
		lea	edi, [eax+20h]
		jmp	loc_11DE
; ---------------------------------------------------------------------------

loc_F7D:				; CODE XREF: _args_verify+557j
		mov	ecx, offset ??_C@_0O@JLHDLMKC@?9extended_crl?$AA@ ; "-extended_crl"
		mov	eax, ebx

loc_F84:				; CODE XREF: _args_verify+582j
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_FA4
		test	dl, dl
		jz	short loc_FA0
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_FA4
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_F84

loc_FA0:				; CODE XREF: _args_verify+570j
		xor	eax, eax
		jmp	short loc_FA9
; ---------------------------------------------------------------------------

loc_FA4:				; CODE XREF: _args_verify+56Cj
					; _args_verify+578j
		sbb	eax, eax
		or	eax, 1

loc_FA9:				; CODE XREF: _args_verify+586j
		test	eax, eax
		jnz	short loc_FB7
		mov	edi, 1000h
		jmp	loc_11DE
; ---------------------------------------------------------------------------

loc_FB7:				; CODE XREF: _args_verify+58Fj
		mov	ecx, offset ??_C@_0M@NIBFNGJH@?9use_deltas?$AA@	; "-use_deltas"
		mov	eax, ebx

loc_FBE:				; CODE XREF: _args_verify+5BCj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_FDE
		test	dl, dl
		jz	short loc_FDA
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_FDE
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_FBE

loc_FDA:				; CODE XREF: _args_verify+5AAj
		xor	eax, eax
		jmp	short loc_FE3
; ---------------------------------------------------------------------------

loc_FDE:				; CODE XREF: _args_verify+5A6j
					; _args_verify+5B2j
		sbb	eax, eax
		or	eax, 1

loc_FE3:				; CODE XREF: _args_verify+5C0j
		test	eax, eax
		jnz	short loc_FF1
		mov	edi, 2000h
		jmp	loc_11DE
; ---------------------------------------------------------------------------

loc_FF1:				; CODE XREF: _args_verify+5C9j
		mov	ecx, offset ??_C@_0O@HLMNILI@?9policy_print?$AA@ ; "-policy_print"
		mov	eax, ebx
		nop	dword ptr [eax+00h]

loc_FFC:				; CODE XREF: _args_verify+5FAj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_101C
		test	dl, dl
		jz	short loc_1018
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_101C
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_FFC

loc_1018:				; CODE XREF: _args_verify+5E8j
		xor	eax, eax
		jmp	short loc_1021
; ---------------------------------------------------------------------------

loc_101C:				; CODE XREF: _args_verify+5E4j
					; _args_verify+5F0j
		sbb	eax, eax
		or	eax, 1

loc_1021:				; CODE XREF: _args_verify+5FEj
		test	eax, eax
		jnz	short loc_102F
		mov	edi, 800h
		jmp	loc_11DE
; ---------------------------------------------------------------------------

loc_102F:				; CODE XREF: _args_verify+607j
		mov	ecx, offset ??_C@_0O@HOJLLGLJ@?9check_ss_sig?$AA@ ; "-check_ss_sig"
		mov	eax, ebx
		nop	word ptr [eax+eax+00h]

loc_103C:				; CODE XREF: _args_verify+63Aj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_105C
		test	dl, dl
		jz	short loc_1058
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_105C
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_103C

loc_1058:				; CODE XREF: _args_verify+628j
		xor	eax, eax
		jmp	short loc_1061
; ---------------------------------------------------------------------------

loc_105C:				; CODE XREF: _args_verify+624j
					; _args_verify+630j
		sbb	eax, eax
		or	eax, 1

loc_1061:				; CODE XREF: _args_verify+63Ej
		test	eax, eax
		jnz	short loc_106F
		mov	edi, 4000h
		jmp	loc_11DE
; ---------------------------------------------------------------------------

loc_106F:				; CODE XREF: _args_verify+647j
		mov	ecx, offset ??_C@_0P@FAJCKKIM@?9trusted_first?$AA@ ; "-trusted_first"
		mov	eax, ebx
		nop	word ptr [eax+eax+00h]

loc_107C:				; CODE XREF: _args_verify+67Aj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_109C
		test	dl, dl
		jz	short loc_1098
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_109C
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_107C

loc_1098:				; CODE XREF: _args_verify+668j
		xor	eax, eax
		jmp	short loc_10A1
; ---------------------------------------------------------------------------

loc_109C:				; CODE XREF: _args_verify+664j
					; _args_verify+670j
		sbb	eax, eax
		or	eax, 1

loc_10A1:				; CODE XREF: _args_verify+67Ej
		test	eax, eax
		jnz	short loc_10AF
		mov	edi, 8000h
		jmp	loc_11DE
; ---------------------------------------------------------------------------

loc_10AF:				; CODE XREF: _args_verify+687j
		mov	ecx, offset ??_C@_0BB@CJLNDP@?9suiteB_128_only?$AA@ ; "-suiteB_128_only"
		mov	eax, ebx
		nop	word ptr [eax+eax+00h]

loc_10BC:				; CODE XREF: _args_verify+6BAj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_10DC
		test	dl, dl
		jz	short loc_10D8
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_10DC
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_10BC

loc_10D8:				; CODE XREF: _args_verify+6A8j
		xor	eax, eax
		jmp	short loc_10E1
; ---------------------------------------------------------------------------

loc_10DC:				; CODE XREF: _args_verify+6A4j
					; _args_verify+6B0j
		sbb	eax, eax
		or	eax, 1

loc_10E1:				; CODE XREF: _args_verify+6BEj
		test	eax, eax
		jnz	short loc_10EF
		mov	edi, 10000h
		jmp	loc_11DE
; ---------------------------------------------------------------------------

loc_10EF:				; CODE XREF: _args_verify+6C7j
		mov	ecx, offset ??_C@_0M@PEHELDMD@?9suiteB_128?$AA@	; "-suiteB_128"
		mov	eax, ebx
		nop	word ptr [eax+eax+00h]

loc_10FC:				; CODE XREF: _args_verify+6FAj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_111C
		test	dl, dl
		jz	short loc_1118
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_111C
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_10FC

loc_1118:				; CODE XREF: _args_verify+6E8j
		xor	eax, eax
		jmp	short loc_1121
; ---------------------------------------------------------------------------

loc_111C:				; CODE XREF: _args_verify+6E4j
					; _args_verify+6F0j
		sbb	eax, eax
		or	eax, 1

loc_1121:				; CODE XREF: _args_verify+6FEj
		test	eax, eax
		jnz	short loc_112F
		mov	edi, 30000h
		jmp	loc_11DE
; ---------------------------------------------------------------------------

loc_112F:				; CODE XREF: _args_verify+707j
		mov	ecx, offset ??_C@_0M@CMOLEKI@?9suiteB_192?$AA@ ; "-suiteB_192"
		mov	eax, ebx
		nop	word ptr [eax+eax+00h]

loc_113C:				; CODE XREF: _args_verify+73Aj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_115C
		test	dl, dl
		jz	short loc_1158
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_115C
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_113C

loc_1158:				; CODE XREF: _args_verify+728j
		xor	eax, eax
		jmp	short loc_1161
; ---------------------------------------------------------------------------

loc_115C:				; CODE XREF: _args_verify+724j
					; _args_verify+730j
		sbb	eax, eax
		or	eax, 1

loc_1161:				; CODE XREF: _args_verify+73Ej
		test	eax, eax
		jnz	short loc_116C
		mov	edi, 20000h
		jmp	short loc_11DE
; ---------------------------------------------------------------------------

loc_116C:				; CODE XREF: _args_verify+747j
		mov	ecx, offset ??_C@_0P@MPJEMPGB@?9partial_chain?$AA@ ; "-partial_chain"
		mov	eax, ebx

loc_1173:				; CODE XREF: _args_verify+771j
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_1193
		test	dl, dl
		jz	short loc_118F
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_1193
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_1173

loc_118F:				; CODE XREF: _args_verify+75Fj
		xor	eax, eax
		jmp	short loc_1198
; ---------------------------------------------------------------------------

loc_1193:				; CODE XREF: _args_verify+75Bj
					; _args_verify+767j
		sbb	eax, eax
		or	eax, 1

loc_1198:				; CODE XREF: _args_verify+775j
		test	eax, eax
		jnz	short loc_11A3
		mov	edi, 80000h
		jmp	short loc_11DE
; ---------------------------------------------------------------------------

loc_11A3:				; CODE XREF: _args_verify+77Ej
		mov	eax, offset ??_C@_0P@PNNLIPKE@?9no_alt_chains?$AA@ ; "-no_alt_chains"
		nop	dword ptr [eax+00h]

loc_11AC:				; CODE XREF: _args_verify+7AAj
		mov	cl, [ebx]
		cmp	cl, [eax]
		jnz	short loc_11CC
		test	cl, cl
		jz	short loc_11C8
		mov	cl, [ebx+1]
		cmp	cl, [eax+1]
		jnz	short loc_11CC
		add	ebx, 2
		add	eax, 2
		test	cl, cl
		jnz	short loc_11AC

loc_11C8:				; CODE XREF: _args_verify+798j
		xor	eax, eax
		jmp	short loc_11D1
; ---------------------------------------------------------------------------

loc_11CC:				; CODE XREF: _args_verify+794j
					; _args_verify+7A0j
		sbb	eax, eax
		or	eax, 1

loc_11D1:				; CODE XREF: _args_verify+7AEj
		test	eax, eax
		jnz	loc_12FD
		mov	edi, 100000h

loc_11DE:				; CODE XREF: _args_verify+37Cj
					; _args_verify+3B4j ...
		mov	ebx, [esp+38h+arg_0]

loc_11E2:				; CODE XREF: _args_verify+B6j
					; _args_verify+FDj ...
		cmp	dword ptr [ebp+0], 0
		mov	esi, [esp+38h+arg_10]
		jz	short loc_1206
		mov	eax, [esi]
		test	eax, eax
		jz	short loc_11FB
		push	eax
		call	_X509_VERIFY_PARAM_free
		add	esp, 4

loc_11FB:				; CODE XREF: _args_verify+7D4j
		mov	dword ptr [esi], 0
		jmp	$end$193
; ---------------------------------------------------------------------------

loc_1206:				; CODE XREF: _args_verify+7CEj
		cmp	dword ptr [esi], 0
		jnz	short loc_121A
		call	_X509_VERIFY_PARAM_new
		mov	[esi], eax
		test	eax, eax
		jz	loc_12D3

loc_121A:				; CODE XREF: _args_verify+7EDj
		mov	eax, [esp+38h+var_28]
		test	eax, eax
		jz	short loc_122D
		push	eax
		push	dword ptr [esi]
		call	_X509_VERIFY_PARAM_add0_policy
		add	esp, 8

loc_122D:				; CODE XREF: _args_verify+804j
		test	edi, edi
		jz	short loc_123C
		push	edi
		push	dword ptr [esi]
		call	_X509_VERIFY_PARAM_set_flags
		add	esp, 8

loc_123C:				; CODE XREF: _args_verify+813j
		mov	eax, [esp+38h+var_24]
		test	eax, eax
		jz	short loc_124F
		push	eax
		push	dword ptr [esi]
		call	_X509_VERIFY_PARAM_set_purpose
		add	esp, 8

loc_124F:				; CODE XREF: _args_verify+826j
		mov	eax, [esp+38h+var_20]
		test	eax, eax
		js	short loc_1262
		push	eax
		push	dword ptr [esi]
		call	_X509_VERIFY_PARAM_set_depth
		add	esp, 8

loc_1262:				; CODE XREF: _args_verify+839j
		mov	ecx, dword ptr [esp+38h+var_8]
		mov	eax, ecx
		mov	edx, dword ptr [esp+38h+var_8+4]
		or	eax, edx
		jz	short loc_127C
		push	edx
		push	ecx
		push	dword ptr [esi]
		call	_X509_VERIFY_PARAM_set_time
		add	esp, 0Ch

loc_127C:				; CODE XREF: _args_verify+852j
		mov	eax, [esp+38h+var_1C]
		test	eax, eax
		jz	short loc_129C
		push	0
		push	eax
		push	dword ptr [esi]
		call	_X509_VERIFY_PARAM_set1_host
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_129C
		mov	dword ptr [ebp+0], 1

loc_129C:				; CODE XREF: _args_verify+866j
					; _args_verify+877j
		mov	eax, [esp+38h+var_18]
		test	eax, eax
		jz	short loc_12BC
		push	0
		push	eax
		push	dword ptr [esi]
		call	_X509_VERIFY_PARAM_set1_email
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_12BC
		mov	dword ptr [ebp+0], 1

loc_12BC:				; CODE XREF: _args_verify+886j
					; _args_verify+897j
		mov	eax, [esp+38h+var_14]
		test	eax, eax
		jz	short $end$193
		push	eax
		push	dword ptr [esi]
		call	_X509_VERIFY_PARAM_set1_ip_asc
		add	esp, 8
		test	eax, eax
		jnz	short $end$193

loc_12D3:				; CODE XREF: _args_verify+7F8j
		mov	dword ptr [ebp+0], 1

$end$193:				; CODE XREF: _args_verify+7E5j
					; _args_verify+8A6j ...
		add	dword ptr [ebx], 4
		mov	ecx, [esp+38h+arg_4]
		mov	eax, [ebx]
		test	ecx, ecx
		jz	short loc_12F0
		sub	eax, [esp+38h+var_C]
		sar	eax, 2
		sub	[ecx], eax

loc_12F0:				; CODE XREF: _args_verify+8C9j
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, 1
		pop	ebx
		add	esp, 28h
		retn
; ---------------------------------------------------------------------------

loc_12FD:				; CODE XREF: _args_verify+7B7j
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		add	esp, 28h
		retn
_args_verify	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1308h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _bio_to_mem
_bio_to_mem	proc near

var_408		= dword	ptr -408h
var_404		= byte ptr -404h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 408h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+408h+var_4], eax
		mov	eax, [esp+408h+arg_0]
		push	ebx
		push	ebp
		mov	ebp, [esp+410h+arg_8]
		mov	[esp+410h+var_408], eax
		call	_BIO_s_mem
		push	eax
		call	_BIO_new
		mov	ebx, eax
		add	esp, 4
		test	ebx, ebx
		jnz	short loc_1362
		pop	ebp
		or	eax, 0FFFFFFFFh
		pop	ebx
		mov	ecx, [esp+408h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 408h
		retn
; ---------------------------------------------------------------------------

loc_1362:				; CODE XREF: _bio_to_mem+3Ej
		push	esi
		mov	esi, [esp+414h+arg_4]
		push	edi

loc_136B:				; CODE XREF: _bio_to_mem+A3j
		cmp	esi, 0FFFFFFFFh
		jz	short loc_137A
		mov	eax, esi
		cmp	esi, 400h
		jl	short loc_137F

loc_137A:				; CODE XREF: _bio_to_mem+66j
		mov	eax, 400h

loc_137F:				; CODE XREF: _bio_to_mem+70j
		push	eax
		lea	eax, [esp+41Ch+var_404]
		push	eax
		push	ebp
		call	_BIO_read
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		js	short loc_13D5
		jz	short loc_13AD
		push	edi
		lea	eax, [esp+41Ch+var_404]
		push	eax
		push	ebx
		call	_BIO_write
		add	esp, 0Ch
		cmp	eax, edi
		jnz	short loc_13D5
		sub	esi, edi
		jnz	short loc_136B

loc_13AD:				; CODE XREF: _bio_to_mem+8Cj
		push	[esp+418h+var_408]
		push	0
		push	3
		push	ebx
		call	_BIO_ctrl
		push	200h
		push	ebx
		mov	esi, eax
		call	_BIO_set_flags
		push	ebx
		call	_BIO_free
		add	esp, 1Ch
		mov	eax, esi
		jmp	short loc_13E1
; ---------------------------------------------------------------------------

loc_13D5:				; CODE XREF: _bio_to_mem+8Aj
					; _bio_to_mem+9Fj
		push	ebx
		call	_BIO_free
		add	esp, 4
		or	eax, 0FFFFFFFFh

loc_13E1:				; CODE XREF: _bio_to_mem+CBj
		mov	ecx, [esp+418h+var_4]
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 408h
		retn
_bio_to_mem	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 13FCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _chopup_args
_chopup_args	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, [esp+arg_8]
		push	edi
		mov	edi, [esp+4+arg_0]
		mov	dword ptr [eax], 0
		mov	eax, [esp+4+arg_C]
		mov	dword ptr [eax], 0
		cmp	dword ptr [edi+4], 0
		jnz	short loc_143E
		push	187h
		push	offset ??_C@_0O@BBAIDNNM@?4?2apps?2apps?4c?$AA@	; ".\\apps\\apps.c"
		push	50h ; 'P'
		mov	dword ptr [edi+4], 14h
		call	_CRYPTO_malloc
		add	esp, 0Ch
		mov	[edi], eax
		test	eax, eax
		jnz	short loc_143E
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_143E:				; CODE XREF: _chopup_args+1Dj
					; _chopup_args+3Ej
		xor	ecx, ecx
		cmp	[edi+4], ecx
		jle	short loc_145B
		nop	dword ptr [eax+00000000h]

loc_144C:				; CODE XREF: _chopup_args+5Dj
		mov	eax, [edi]
		mov	dword ptr [eax+ecx*4], 0
		inc	ecx
		cmp	ecx, [edi+4]
		jl	short loc_144C

loc_145B:				; CODE XREF: _chopup_args+47j
		push	ebx
		push	ebp
		push	esi
		mov	esi, [esp+10h+arg_4]
		xor	ebp, ebp
		cmp	byte ptr [esi],	0
		jz	short loc_1486
		nop	dword ptr [eax]

loc_146C:				; CODE XREF: _chopup_args+145j
		mov	al, [esi]
		test	al, al
		jz	short loc_1486

loc_1472:				; CODE XREF: _chopup_args+88j
		cmp	al, 20h	; ' '
		jz	short loc_147E
		cmp	al, 9
		jz	short loc_147E
		cmp	al, 0Ah
		jnz	short loc_149E

loc_147E:				; CODE XREF: _chopup_args+78j
					; _chopup_args+7Cj
		mov	al, [esi+1]
		inc	esi
		test	al, al
		jnz	short loc_1472

loc_1486:				; CODE XREF: _chopup_args+6Bj
					; _chopup_args+74j ...
		mov	eax, [esp+10h+arg_8]
		mov	ecx, [esp+10h+arg_C]
		pop	esi
		mov	[eax], ebp
		mov	eax, [edi]
		pop	ebp
		pop	ebx
		mov	[ecx], eax
		mov	eax, 1
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_149E:				; CODE XREF: _chopup_args+80j
		cmp	byte ptr [esi],	0
		jz	short loc_1486
		mov	eax, [edi+4]
		cmp	ebp, eax
		jl	short loc_14EB
		push	19Eh
		lea	ebx, [eax+14h]
		push	offset ??_C@_0O@BBAIDNNM@?4?2apps?2apps?4c?$AA@	; ".\\apps\\apps.c"
		lea	eax, ds:0[ebx*4]
		push	eax
		push	dword ptr [edi]
		call	_CRYPTO_realloc
		add	esp, 10h
		test	eax, eax
		jz	short loc_154C
		mov	[edi], eax
		mov	ecx, ebp
		mov	[edi+4], ebx
		cmp	ebp, ebx
		jge	short loc_14EB
		nop	dword ptr [eax+00h]

loc_14DC:				; CODE XREF: _chopup_args+EDj
		mov	eax, [edi]
		mov	dword ptr [eax+ecx*4], 0
		inc	ecx
		cmp	ecx, [edi+4]
		jl	short loc_14DC

loc_14EB:				; CODE XREF: _chopup_args+ACj
					; _chopup_args+DAj
		mov	eax, [edi]
		mov	[eax+ebp*4], esi
		inc	ebp
		mov	al, [esi]
		cmp	al, 27h	; '''
		jz	short loc_151E
		cmp	al, 22h	; '"'
		jz	short loc_151E
		test	al, al
		jz	short loc_151B

loc_14FF:				; CODE XREF: _chopup_args+115j
		cmp	al, 20h	; ' '
		jz	short loc_1516
		cmp	al, 9
		jz	short loc_1516
		cmp	al, 0Ah
		jz	short loc_1516
		mov	al, [esi+1]
		inc	esi
		test	al, al
		jnz	short loc_14FF
		dec	esi
		jmp	short loc_153D
; ---------------------------------------------------------------------------

loc_1516:				; CODE XREF: _chopup_args+105j
					; _chopup_args+109j ...
		cmp	byte ptr [esi],	0
		jnz	short loc_153A

loc_151B:				; CODE XREF: _chopup_args+101j
		dec	esi
		jmp	short loc_153D
; ---------------------------------------------------------------------------

loc_151E:				; CODE XREF: _chopup_args+F9j
					; _chopup_args+FDj
		movsx	ecx, al
		inc	esi
		mov	eax, [edi]
		inc	dword ptr [eax+ebp*4-4]
		cmp	byte ptr [esi],	0
		jz	short loc_153A

loc_152D:				; CODE XREF: _chopup_args+13Cj
		movsx	eax, byte ptr [esi]
		cmp	eax, ecx
		jz	short loc_153A
		inc	esi
		cmp	byte ptr [esi],	0
		jnz	short loc_152D

loc_153A:				; CODE XREF: _chopup_args+11Dj
					; _chopup_args+12Fj ...
		mov	byte ptr [esi],	0

loc_153D:				; CODE XREF: _chopup_args+118j
					; _chopup_args+120j
		inc	esi
		cmp	byte ptr [esi],	0
		jnz	loc_146C
		jmp	loc_1486
; ---------------------------------------------------------------------------

loc_154C:				; CODE XREF: _chopup_args+CFj
		pop	esi
		pop	ebp
		pop	ebx
		xor	eax, eax
		pop	edi
		retn
_chopup_args	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1554h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _copy_extensions
_copy_extensions proc near

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 10h
		call	__chkstk
		push	ebx
		mov	ebx, [esp+14h+arg_0]
		mov	[esp+14h+var_10], 0
		test	ebx, ebx
		jz	loc_1663
		mov	eax, [esp+14h+arg_4]
		test	eax, eax
		jz	loc_1663
		cmp	[esp+14h+arg_8], 0
		jz	loc_1663
		push	ebp
		push	esi
		push	edi
		push	eax
		call	_X509_REQ_get_extensions
		mov	edi, eax
		xor	ebp, ebp
		push	edi
		mov	[esp+28h+var_8], edi
		mov	[esp+28h+arg_0], ebp
		call	_sk_num
		add	esp, 8
		test	eax, eax
		jle	loc_1641
		nop	dword ptr [eax+00h]

loc_15B4:				; CODE XREF: _copy_extensions+E7j
		push	ebp
		push	edi
		call	_sk_value
		push	eax
		mov	[esp+2Ch+var_4], eax
		call	_X509_EXTENSION_get_object
		push	0FFFFFFFFh
		push	eax
		push	ebx
		mov	[esp+38h+var_C], eax
		call	_X509_get_ext_by_OBJ
		mov	esi, eax
		add	esp, 18h
		cmp	esi, 0FFFFFFFFh
		jz	short loc_1618
		cmp	[esp+20h+arg_8], 1
		jz	short loc_162B
		mov	ebp, [esp+20h+var_C]

loc_15E7:				; CODE XREF: _copy_extensions+BAj
		push	esi
		push	ebx
		call	_X509_get_ext
		push	esi
		push	ebx
		mov	edi, eax
		call	_X509_delete_ext
		push	edi
		call	_X509_EXTENSION_free
		push	0FFFFFFFFh
		push	ebp
		push	ebx
		call	_X509_get_ext_by_OBJ
		mov	esi, eax
		add	esp, 20h
		cmp	esi, 0FFFFFFFFh
		jnz	short loc_15E7
		mov	ebp, [esp+20h+arg_0]
		mov	edi, [esp+20h+var_8]

loc_1618:				; CODE XREF: _copy_extensions+86j
		push	0FFFFFFFFh
		push	[esp+24h+var_4]
		push	ebx
		call	_X509_add_ext
		add	esp, 0Ch
		test	eax, eax
		jz	short $end$23

loc_162B:				; CODE XREF: _copy_extensions+8Dj
		inc	ebp
		push	edi
		mov	[esp+24h+arg_0], ebp
		call	_sk_num
		add	esp, 4
		cmp	ebp, eax
		jl	loc_15B4

loc_1641:				; CODE XREF: _copy_extensions+56j
		mov	[esp+20h+var_10], 1

$end$23:				; CODE XREF: _copy_extensions+D5j
		push	offset _X509_EXTENSION_free
		push	edi
		call	_sk_pop_free
		mov	eax, [esp+28h+var_10]
		add	esp, 8
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 10h
		retn
; ---------------------------------------------------------------------------

loc_1663:				; CODE XREF: _copy_extensions+19j
					; _copy_extensions+25j	...
		mov	eax, 1
		pop	ebx
		add	esp, 10h
		retn
_copy_extensions endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1670h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_crls_http_cb	proc near		; DATA XREF: _store_setup_crl_downloado

arg_0		= dword	ptr  4

		push	ebx
		push	ebp
		push	esi
		push	[esp+0Ch+arg_0]
		call	_X509_STORE_CTX_get_current_cert
		push	0
		push	0
		mov	ebx, eax
		push	67h ; 'g'
		push	ebx
		call	_X509_get_ext_d2i
		mov	esi, eax
		push	esi
		call	_load_crl_crldp
		push	offset _DIST_POINT_free
		push	esi
		mov	ebp, eax
		call	_sk_pop_free
		add	esp, 20h
		test	ebp, ebp
		jnz	short loc_16AC
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_16AC:				; CODE XREF: _crls_http_cb+34j
		push	edi
		call	_sk_new_null
		mov	edi, eax
		push	ebp
		push	edi
		call	_sk_push
		push	0
		push	0
		push	359h
		push	ebx
		call	_X509_get_ext_d2i
		mov	esi, eax
		push	esi
		call	_load_crl_crldp
		push	offset _DIST_POINT_free
		push	esi
		mov	ebx, eax
		call	_sk_pop_free
		add	esp, 24h
		test	ebx, ebx
		jz	short loc_16F0
		push	ebx
		push	edi
		call	_sk_push
		add	esp, 8

loc_16F0:				; CODE XREF: _crls_http_cb+74j
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_crls_http_cb	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 16F8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _destroy_ui_method
_destroy_ui_method proc	near
		mov	eax, ds:_ui_method
		test	eax, eax
		jz	short locret_1714
		push	eax
		call	_UI_destroy_method
		add	esp, 4
		mov	ds:_ui_method, 0

locret_1714:				; CODE XREF: _destroy_ui_method+7j
		retn
_destroy_ui_method endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1718h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _dump_cert_text
_dump_cert_text	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		push	esi
		push	0
		push	0
		push	[esp+10h+arg_4]
		call	_X509_get_subject_name
		add	esp, 4
		push	eax
		call	_X509_NAME_oneline
		mov	ebx, [esp+14h+arg_0]
		mov	esi, eax
		push	offset ??_C@_08MAHPNCKH@subject?$DN?$AA@ ; "subject="
		push	ebx
		call	_BIO_puts
		push	esi
		push	ebx
		call	_BIO_puts
		push	esi
		call	_CRYPTO_free
		add	esp, 20h
		push	0
		push	0
		push	[esp+10h+arg_4]
		call	_X509_get_issuer_name
		add	esp, 4
		push	eax
		call	_X509_NAME_oneline
		push	offset ??_C@_08BDBNPDII@?6issuer?$DN?$AA@ ; "\nissuer="
		push	ebx
		mov	esi, eax
		call	_BIO_puts
		push	esi
		push	ebx
		call	_BIO_puts
		push	offset ??_C@_01EEMJAFIK@?6?$AA@	; `string'
		push	ebx
		call	_BIO_puts
		push	esi
		call	_CRYPTO_free
		add	esp, 28h
		xor	eax, eax
		pop	esi
		pop	ebx
		retn
_dump_cert_text	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1794h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int fprintf(FILE *File, const	char *Format, ...)
		public _fprintf
_fprintf	proc near		; CODE XREF: _load_index+126p

File		= dword	ptr  4
Format		= dword	ptr  8
arg_8		= byte ptr  0Ch

		lea	eax, [esp+arg_8]
		push	eax
		push	0
		push	[esp+8+Format]
		push	[esp+0Ch+File]
		call	___local_stdio_printf_options
		push	dword ptr [eax+4]
		push	dword ptr [eax]
		call	dword ptr ds:__imp____stdio_common_vfprintf
		add	esp, 18h
		retn
_fprintf	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 17B8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _free_index
_free_index	proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	short loc_17DA
		mov	eax, [esi+4]
		test	eax, eax
		jz	short loc_17D1
		push	eax
		call	_TXT_DB_free
		add	esp, 4

loc_17D1:				; CODE XREF: _free_index+Ej
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_17DA:				; CODE XREF: _free_index+7j
		pop	esi
		retn
_free_index	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 17DCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_get_dp_url	proc near		; CODE XREF: _load_crl_crldp+28p

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		push	ebx
		mov	ebx, [eax]
		test	ebx, ebx
		jz	loc_1870
		cmp	dword ptr [ebx], 0
		jnz	loc_1870
		mov	ebx, [ebx+4]
		push	ebp
		push	esi
		push	edi
		push	ebx
		xor	esi, esi
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jle	short loc_1862
		mov	ebp, dword ptr ds:__imp__strncmp

loc_180F:				; CODE XREF: _get_dp_url+84j
		push	esi
		push	ebx
		call	_sk_value
		lea	ecx, [esp+18h+arg_0]
		push	ecx
		push	eax
		call	_GENERAL_NAME_get0_value
		add	esp, 10h
		mov	edi, eax
		cmp	[esp+10h+arg_0], 6
		jnz	short loc_1854
		push	edi
		call	_ASN1_STRING_length
		add	esp, 4
		cmp	eax, 6
		jle	short loc_1854
		push	edi
		call	_ASN1_STRING_data
		push	7		; MaxCount
		mov	edi, eax
		push	offset ??_C@_07FGAOOBMN@http?3?1?1?$AA@	; "http://"
		push	edi		; Str1
		call	ebp ; __imp__strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_1869

loc_1854:				; CODE XREF: _get_dp_url+4Fj
					; _get_dp_url+5Dj
		push	ebx
		inc	esi
		call	_sk_num
		add	esp, 4
		cmp	esi, eax
		jl	short loc_180F

loc_1862:				; CODE XREF: _get_dp_url+2Bj
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1869:				; CODE XREF: _get_dp_url+76j
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1870:				; CODE XREF: _get_dp_url+9j
					; _get_dp_url+12j
		xor	eax, eax
		pop	ebx
		retn
_get_dp_url	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1874h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _index_index
_index_index	proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		push	offset _index_serial_LHASH_COMP
		push	offset _index_serial_LHASH_HASH
		push	0
		push	3
		push	dword ptr [esi+4]
		call	_TXT_DB_create_index
		add	esp, 14h
		test	eax, eax
		jnz	short loc_18B9
		mov	eax, [esi+4]
		push	dword ptr [eax+18h]
		push	dword ptr [eax+14h]
		push	dword ptr [eax+10h]
		push	offset ??_C@_0DC@FMBAALNJ@error?5creating?5serial?5number?5ind@	; "error creating serial number	index:(%ld"...
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_18B9:				; CODE XREF: _index_index+20j
		cmp	dword ptr [esi], 0
		jz	short loc_1901
		push	offset _index_name_LHASH_COMP
		push	offset _index_name_LHASH_HASH
		push	offset _index_name_qual
		push	5
		push	dword ptr [esi+4]
		call	_TXT_DB_create_index
		add	esp, 14h
		test	eax, eax
		jnz	short loc_1901
		mov	eax, [esi+4]
		push	dword ptr [eax+18h]
		push	dword ptr [eax+14h]
		push	dword ptr [eax+10h]
		push	offset ??_C@_0CJ@LAHEODBL@error?5creating?5name?5index?3?$CI?$CFld?0?$CF@ ; "error creating name index:(%ld,%ld,%ld)"...
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1901:				; CODE XREF: _index_index+48j
					; _index_index+68j
		mov	eax, 1
		pop	esi
		retn
_index_index	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1908h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_index_name_LHASH_COMP proc near	; DATA XREF: _index_index+4Ao

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_4]
		mov	ecx, [eax+14h]
		mov	eax, [esp+arg_0]
		mov	eax, [eax+14h]
		xchg	ax, ax

loc_1918:				; CODE XREF: _index_name_LHASH_COMP+2Aj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_1937
		test	dl, dl
		jz	short loc_1934
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_1937
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_1918

loc_1934:				; CODE XREF: _index_name_LHASH_COMP+18j
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1937:				; CODE XREF: _index_name_LHASH_COMP+14j
					; _index_name_LHASH_COMP+20j
		sbb	eax, eax
		or	eax, 1
		retn
_index_name_LHASH_COMP endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1940h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_index_name_LHASH_HASH proc near	; DATA XREF: _index_index+4Fo

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		push	dword ptr [eax+14h]
		call	_lh_strhash
		add	esp, 4
		retn
_index_name_LHASH_HASH endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1950h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _index_name_cmp
_index_name_cmp	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_4]
		mov	ecx, [eax+14h]
		mov	eax, [esp+arg_0]
		mov	eax, [eax+14h]
		xchg	ax, ax

loc_1960:				; CODE XREF: _index_name_cmp+2Aj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_197F
		test	dl, dl
		jz	short loc_197C
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_197F
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_1960

loc_197C:				; CODE XREF: _index_name_cmp+18j
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_197F:				; CODE XREF: _index_name_cmp+14j
					; _index_name_cmp+20j
		sbb	eax, eax
		or	eax, 1
		retn
_index_name_cmp	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1988h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_index_name_hash proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		push	dword ptr [eax+14h]
		call	_lh_strhash
		add	esp, 4
		retn
_index_name_hash endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1998h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_index_name_qual proc near		; DATA XREF: _index_index+54o

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	ecx, [eax]
		xor	eax, eax
		cmp	byte ptr [ecx],	56h ; 'V'
		setz	al
		retn
_index_name_qual endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 19A8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_index_serial_LHASH_COMP proc near	; DATA XREF: _index_index+5o
		jmp	_index_serial_cmp
_index_serial_LHASH_COMP endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 19B0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_index_serial_LHASH_HASH proc near	; DATA XREF: _index_index+Ao

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+0Ch]
		cmp	byte ptr [eax],	30h ; '0'
		jnz	short loc_19C6
		nop	dword ptr [eax+00h]

loc_19C0:				; CODE XREF: _index_serial_LHASH_HASH+14j
		inc	eax
		cmp	byte ptr [eax],	30h ; '0'
		jz	short loc_19C0

loc_19C6:				; CODE XREF: _index_serial_LHASH_HASH+Aj
		mov	[esp+arg_0], eax
		jmp	_lh_strhash
_index_serial_LHASH_HASH endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 19D0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_index_serial_cmp proc near		; CODE XREF: _index_serial_LHASH_COMPj

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	eax, [eax+0Ch]
		cmp	byte ptr [eax],	30h ; '0'
		jnz	short loc_19E6
		nop	dword ptr [eax+00h]

loc_19E0:				; CODE XREF: _index_serial_cmp+14j
		inc	eax
		cmp	byte ptr [eax],	30h ; '0'
		jz	short loc_19E0

loc_19E6:				; CODE XREF: _index_serial_cmp+Aj
		mov	ecx, [esp+arg_4]
		mov	ecx, [ecx+0Ch]
		cmp	byte ptr [ecx],	30h ; '0'
		jnz	short loc_19F8

loc_19F2:				; CODE XREF: _index_serial_cmp+26j
		inc	ecx
		cmp	byte ptr [ecx],	30h ; '0'
		jz	short loc_19F2

loc_19F8:				; CODE XREF: _index_serial_cmp+20j
					; _index_serial_cmp+42j
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_1A17
		test	dl, dl
		jz	short loc_1A14
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_1A17
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_19F8

loc_1A14:				; CODE XREF: _index_serial_cmp+30j
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1A17:				; CODE XREF: _index_serial_cmp+2Cj
					; _index_serial_cmp+38j
		sbb	eax, eax
		or	eax, 1
		retn
_index_serial_cmp endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1A20h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_index_serial_hash proc	near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+0Ch]
		cmp	byte ptr [eax],	30h ; '0'
		jnz	short loc_1A36
		nop	dword ptr [eax+00h]

loc_1A30:				; CODE XREF: _index_serial_hash+14j
		inc	eax
		cmp	byte ptr [eax],	30h ; '0'
		jz	short loc_1A30

loc_1A36:				; CODE XREF: _index_serial_hash+Aj
		mov	[esp+arg_0], eax
		jmp	_lh_strhash
_index_serial_hash endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1A40h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl load_cert(int, char *Buf,	int, int, int, int)
		public _load_cert
_load_cert	proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
Buf		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_14		= dword	ptr  18h

		mov	eax, 4
		call	__chkstk
		push	ebp
		mov	ebp, [esp+8+arg_8]
		mov	[esp+8+var_4], 0
		cmp	ebp, 0Dh
		jnz	short loc_1A7A
		push	0
		lea	eax, [esp+0Ch+var_4]
		push	eax
		push	[esp+10h+arg_0]
		push	[esp+14h+Buf]
		call	_load_cert_crl_http
		mov	eax, [esp+18h+var_4]
		add	esp, 10h
		pop	ebp
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_1A7A:				; CODE XREF: _load_cert+1Aj
		push	ebx
		push	edi
		call	_BIO_s_file
		push	eax
		call	_BIO_new
		mov	ebx, [esp+14h+arg_0]
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jnz	short loc_1AA2
		push	ebx
		call	_ERR_print_errors
		add	esp, 4
		jmp	$end$26
; ---------------------------------------------------------------------------

loc_1AA2:				; CODE XREF: _load_cert+52j
		push	esi
		mov	esi, [esp+14h+Buf]
		test	esi, esi
		jnz	short loc_1AED
		push	esi		; Size
		push	4		; Mode
		push	esi		; Buf
		push	esi
		mov	esi, dword ptr ds:__imp____acrt_iob_func
		call	esi ; __imp____acrt_iob_func
		add	esp, 4
		push	eax		; File
		call	dword ptr ds:__imp__setvbuf
		push	0
		call	esi ; __imp____acrt_iob_func
		push	eax
		push	0
		push	6Ah ; 'j'
		push	edi
		call	_BIO_ctrl
		add	esp, 24h

loc_1AD4:				; CODE XREF: _load_cert+BDj
		cmp	ebp, 1
		jnz	short loc_1B1D
		push	0
		push	edi
		call	_d2i_X509_bio
		add	esp, 8
		mov	[esp+14h+var_4], eax
		jmp	loc_1BCC
; ---------------------------------------------------------------------------

loc_1AED:				; CODE XREF: _load_cert+69j
		push	esi
		push	3
		push	6Ch ; 'l'
		push	edi
		call	_BIO_ctrl
		add	esp, 10h
		test	eax, eax
		jg	short loc_1AD4
		push	esi
		push	[esp+18h+arg_14]
		push	offset ??_C@_0BF@JJKPOFNI@Error?5opening?5?$CFs?5?$CFs?6?$AA@ ;	"Error opening %s %s\n"
		push	ebx
		call	_BIO_printf
		push	ebx
		call	_ERR_print_errors
		add	esp, 14h
		jmp	loc_1BCC
; ---------------------------------------------------------------------------

loc_1B1D:				; CODE XREF: _load_cert+97j
		cmp	ebp, 4
		jnz	short loc_1B7B
		push	0
		push	edi
		call	_NETSCAPE_X509_it
		push	eax
		call	_ASN1_item_d2i_bio
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jz	loc_1BCC
		mov	ecx, [esi]
		push	dword ptr [ecx]	; MaxCount
		push	dword ptr [ecx+8] ; Str2
		push	offset ??_C@_0M@LLNFCECG@certificate?$AA@ ; "certificate"
		call	dword ptr ds:__imp__strncmp
		add	esp, 0Ch
		push	esi
		test	eax, eax
		jz	short loc_1B63
		call	_NETSCAPE_X509_free
		push	offset ??_C@_0CF@BGMEBKBE@Error?5reading?5header?5on?5certific@	; "Error reading header	on certificate\n"
		jmp	short loc_1BC3
; ---------------------------------------------------------------------------

loc_1B63:				; CODE XREF: _load_cert+115j
		mov	eax, [esi+4]
		mov	[esp+18h+var_4], eax
		mov	dword ptr [esi+4], 0
		call	_NETSCAPE_X509_free
		add	esp, 4
		jmp	short loc_1BCC
; ---------------------------------------------------------------------------

loc_1B7B:				; CODE XREF: _load_cert+E0j
		cmp	ebp, 3
		jnz	short loc_1B98
		push	0
		push	offset _password_callback
		push	0
		push	edi
		call	_PEM_read_bio_X509_AUX
		add	esp, 10h
		mov	[esp+14h+var_4], eax
		jmp	short loc_1BCC
; ---------------------------------------------------------------------------

loc_1B98:				; CODE XREF: _load_cert+13Ej
		cmp	ebp, 5
		jnz	short loc_1BBA
		push	0
		lea	eax, [esp+18h+var_4]
		push	eax
		push	0
		push	0
		push	0
		push	[esp+28h+arg_14]
		push	edi
		push	ebx
		call	_load_pkcs12
		add	esp, 20h
		jmp	short loc_1BCC
; ---------------------------------------------------------------------------

loc_1BBA:				; CODE XREF: _load_cert+15Bj
		push	[esp+14h+arg_14]
		push	offset ??_C@_0CD@HFNMCDK@bad?5input?5format?5specified?5for?5?$CF@ ; "bad input	format specified for %s\n"

loc_1BC3:				; CODE XREF: _load_cert+121j
		push	ebx
		call	_BIO_printf
		add	esp, 0Ch

loc_1BCC:				; CODE XREF: _load_cert+A8j
					; _load_cert+D8j ...
		pop	esi

$end$26:				; CODE XREF: _load_cert+5Dj
		cmp	[esp+10h+var_4], 0
		jnz	short loc_1BE8
		push	offset ??_C@_0BM@FDKJDCHF@unable?5to?5load?5certificate?6?$AA@ ; "unable to load certificate\n"
		push	ebx
		call	_BIO_printf
		push	ebx
		call	_ERR_print_errors
		add	esp, 0Ch

loc_1BE8:				; CODE XREF: _load_cert+192j
		test	edi, edi
		jz	short loc_1BF5
		push	edi
		call	_BIO_free
		add	esp, 4

loc_1BF5:				; CODE XREF: _load_cert+1AAj
		mov	eax, [esp+10h+var_4]
		pop	edi
		pop	ebx
		pop	ebp
		pop	ecx
		retn
_load_cert	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1C00h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _load_cert_crl_http
_load_cert_crl_http proc near		; CODE XREF: _load_cert+2Bp
					; _load_crl+2Dp ...

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, 10h
		call	__chkstk
		push	ebx
		push	ebp
		push	esi
		push	edi
		lea	eax, [esp+20h+var_4]
		mov	[esp+20h+var_10], 0
		push	eax
		lea	eax, [esp+24h+var_C]
		mov	[esp+24h+var_8], 0
		push	eax
		lea	eax, [esp+28h+var_8]
		mov	[esp+28h+var_C], 0
		push	eax
		lea	eax, [esp+2Ch+var_10]
		xor	ebp, ebp
		push	eax
		push	[esp+30h+arg_0]
		xor	edi, edi
		xor	esi, esi
		call	_OCSP_parse_url
		mov	ebx, [esp+34h+arg_8]
		add	esp, 14h
		test	eax, eax
		mov	eax, [esp+20h+arg_4]
		jz	$err$39
		cmp	[esp+20h+var_4], esi
		jz	short loc_1C7D
		test	eax, eax
		jz	$err$39
		push	offset ??_C@_0BF@LDHEOEBK@https?5not?5supported?6?$AA@ ; "https	not supported\n"
		push	eax
		call	_BIO_puts
		add	esp, 8
		jmp	$err$39
; ---------------------------------------------------------------------------

loc_1C7D:				; CODE XREF: _load_cert_crl_http+60j
		push	[esp+20h+var_10]
		call	_BIO_new_connect
		mov	ebp, eax
		add	esp, 4
		test	ebp, ebp
		jz	$err$39
		push	[esp+20h+var_8]
		push	1
		push	64h ; 'd'
		push	ebp
		call	_BIO_ctrl
		add	esp, 10h
		test	eax, eax
		jz	short $err$39
		push	400h
		push	ebp
		call	_OCSP_REQ_CTX_new
		mov	edi, eax
		add	esp, 8
		test	edi, edi
		jz	short $err$39
		push	[esp+20h+var_C]
		push	offset ??_C@_03HAPOJHBM@GET?$AA@ ; `string'
		push	edi
		call	_OCSP_REQ_CTX_http
		add	esp, 0Ch
		test	eax, eax
		jz	short $err$39
		push	[esp+20h+var_10]
		push	offset ??_C@_04CPPPJGME@Host?$AA@ ; "Host"
		push	edi
		call	_OCSP_REQ_CTX_add1_header
		add	esp, 0Ch
		test	eax, eax
		jz	short $err$39
		test	ebx, ebx
		jz	short loc_1D03
		nop	dword ptr [eax+00h]

loc_1CF0:				; CODE XREF: _load_cert_crl_http+FFj
		push	ebx
		push	edi
		call	_X509_http_nbio
		mov	esi, eax
		add	esp, 8
		cmp	esi, 0FFFFFFFFh
		jz	short loc_1CF0
		jmp	short $err$39
; ---------------------------------------------------------------------------

loc_1D03:				; CODE XREF: _load_cert_crl_http+EAj
		mov	ebx, [esp+20h+arg_C]

loc_1D07:				; CODE XREF: _load_cert_crl_http+116j
		push	ebx
		push	edi
		call	_X509_CRL_http_nbio
		mov	esi, eax
		add	esp, 8
		cmp	esi, 0FFFFFFFFh
		jz	short loc_1D07
		mov	ebx, [esp+20h+arg_8]

$err$39:				; CODE XREF: _load_cert_crl_http+56j
					; _load_cert_crl_http+64j ...
		mov	eax, [esp+20h+var_10]
		test	eax, eax
		jz	short loc_1D2D
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_1D2D:				; CODE XREF: _load_cert_crl_http+122j
		mov	eax, [esp+20h+var_C]
		test	eax, eax
		jz	short loc_1D3E
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_1D3E:				; CODE XREF: _load_cert_crl_http+133j
		mov	eax, [esp+20h+var_8]
		test	eax, eax
		jz	short loc_1D4F
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_1D4F:				; CODE XREF: _load_cert_crl_http+144j
		test	ebp, ebp
		jz	short loc_1D5C
		push	ebp
		call	_BIO_free_all
		add	esp, 4

loc_1D5C:				; CODE XREF: _load_cert_crl_http+151j
		test	edi, edi
		jz	short loc_1D69
		push	edi
		call	_OCSP_REQ_CTX_free
		add	esp, 4

loc_1D69:				; CODE XREF: _load_cert_crl_http+15Ej
		cmp	esi, 1
		jz	short loc_1DAE
		test	ebp, ebp
		jz	short loc_1DA0
		cmp	[esp+20h+arg_4], 0
		jz	short loc_1DA0
		push	[esp+20h+arg_0]
		mov	ecx, offset ??_C@_03GEOOCNOH@CRL?$AA@ ;	"CRL"
		test	ebx, ebx
		mov	eax, offset ??_C@_0M@LLNFCECG@certificate?$AA@ ; "certificate"
		cmovz	eax, ecx
		push	eax
		push	offset ??_C@_0BK@FAFHEINM@Error?5loading?5?$CFs?5from?5?$CFs?6?$AA@ ; "Error loading %s	from %s\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 10h

loc_1DA0:				; CODE XREF: _load_cert_crl_http+170j
					; _load_cert_crl_http+177j
		push	dword ptr ds:_bio_err
		call	_ERR_print_errors
		add	esp, 4

loc_1DAE:				; CODE XREF: _load_cert_crl_http+16Cj
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 10h
		retn
_load_cert_crl_http endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1DB8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _load_certs
_load_certs	proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	eax, 4
		call	__chkstk
		push	0
		lea	eax, [esp+8+var_4]
		push	eax
		push	[esp+0Ch+arg_14]
		push	[esp+10h+arg_10]
		push	[esp+14h+arg_C]
		push	[esp+18h+arg_8]
		push	[esp+1Ch+arg_4]
		push	[esp+20h+arg_0]
		call	_load_certs_crls
		neg	eax
		sbb	eax, eax
		and	eax, [esp+24h+var_4]
		add	esp, 24h
		retn
_load_certs	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1DF4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_load_certs_crls proc near		; CODE XREF: _load_certs+29p
					; _load_crls+28p

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_14		= dword	ptr  18h
arg_18		= dword	ptr  1Ch
arg_1C		= dword	ptr  20h

		mov	eax, 0Ch
		call	__chkstk
		cmp	[esp+0Ch+arg_8], 3
		mov	eax, [esp+0Ch+arg_C]
		push	esi
		mov	esi, [esp+10h+arg_4]
		mov	[esp+10h+var_C], 0
		mov	[esp+10h+var_8], eax
		mov	[esp+10h+var_4], esi
		jz	short loc_1E3A
		push	[esp+10h+arg_14]
		push	offset ??_C@_0CD@HFNMCDK@bad?5input?5format?5specified?5for?5?$CF@ ; "bad input	format specified for %s\n"
		push	[esp+18h+arg_0]
		call	_BIO_printf
		add	esp, 0Ch
		xor	eax, eax
		pop	esi
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_1E3A:				; CODE XREF: _load_certs_crls+28j
		push	edi
		test	esi, esi
		jnz	short loc_1E52
		push	esi
		push	esi
		call	dword ptr ds:__imp____acrt_iob_func
		add	esp, 4
		push	eax
		call	_BIO_new_fp
		jmp	short loc_1E5D
; ---------------------------------------------------------------------------

loc_1E52:				; CODE XREF: _load_certs_crls+49j
		push	offset ??_C@_01KDCPPGHE@r?$AA@ ; `string'
		push	esi
		call	_BIO_new_file

loc_1E5D:				; CODE XREF: _load_certs_crls+5Cj
		mov	edi, eax
		add	esp, 8
		test	edi, edi
		jnz	short loc_1E95
		test	esi, esi
		mov	eax, offset ??_C@_05MHOFLBOO@stdin?$AA@	; "stdin"
		cmovnz	eax, esi
		mov	esi, [esp+14h+arg_0]
		push	eax
		push	[esp+18h+arg_14]
		push	offset ??_C@_0BF@JJKPOFNI@Error?5opening?5?$CFs?5?$CFs?6?$AA@ ;	"Error opening %s %s\n"
		push	esi
		call	_BIO_printf
		push	esi
		call	_ERR_print_errors
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_1E95:				; CODE XREF: _load_certs_crls+70j
		push	ebx
		push	ebp
		lea	eax, [esp+1Ch+var_8]
		push	eax
		push	offset _password_callback
		push	0
		push	edi
		call	_PEM_X509_INFO_read_bio
		mov	esi, eax
		push	edi
		mov	[esp+30h+arg_C], esi
		call	_BIO_free
		mov	ebx, [esp+30h+arg_18]
		add	esp, 14h
		mov	ebp, [esp+1Ch+arg_1C]
		test	ebx, ebx
		jz	short loc_1ED3
		call	_sk_new_null
		mov	[ebx], eax
		test	eax, eax
		jz	$end$34_0

loc_1ED3:				; CODE XREF: _load_certs_crls+CEj
		test	ebp, ebp
		jz	short loc_1EE7
		call	_sk_new_null
		mov	[ebp+0], eax
		test	eax, eax
		jz	$end$34_0

loc_1EE7:				; CODE XREF: _load_certs_crls+E1j
		push	esi
		xor	edi, edi
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jle	short loc_1F55

loc_1EF6:				; CODE XREF: _load_certs_crls+15Fj
		push	edi
		push	esi
		call	_sk_value
		mov	esi, eax
		add	esp, 8
		mov	eax, [esi]
		test	eax, eax
		jz	short loc_1F21
		test	ebx, ebx
		jz	short loc_1F21
		push	eax
		push	dword ptr [ebx]
		call	_sk_push
		add	esp, 8
		test	eax, eax
		jz	short $end$34_0
		mov	dword ptr [esi], 0

loc_1F21:				; CODE XREF: _load_certs_crls+112j
					; _load_certs_crls+116j
		mov	eax, [esi+4]
		test	eax, eax
		jz	short loc_1F43
		test	ebp, ebp
		jz	short loc_1F43
		push	eax
		push	dword ptr [ebp+0]
		call	_sk_push
		add	esp, 8
		test	eax, eax
		jz	short $end$34_0
		mov	dword ptr [esi+4], 0

loc_1F43:				; CODE XREF: _load_certs_crls+132j
					; _load_certs_crls+136j
		mov	esi, [esp+1Ch+arg_C]
		inc	edi
		push	esi
		call	_sk_num
		add	esp, 4
		cmp	edi, eax
		jl	short loc_1EF6

loc_1F55:				; CODE XREF: _load_certs_crls+100j
		mov	edi, 1
		test	ebx, ebx
		jz	short loc_1F75
		push	dword ptr [ebx]
		call	_sk_num
		xor	esi, esi
		add	esp, 4
		test	eax, eax
		cmovg	esi, edi
		mov	[esp+1Ch+var_C], esi
		jmp	short loc_1F77
; ---------------------------------------------------------------------------

loc_1F75:				; CODE XREF: _load_certs_crls+168j
		xor	esi, esi

loc_1F77:				; CODE XREF: _load_certs_crls+17Fj
		test	ebp, ebp
		jz	short $end$34_0
		push	dword ptr [ebp+0]
		call	_sk_num
		add	esp, 4
		test	eax, eax
		cmovg	esi, edi
		mov	[esp+1Ch+var_C], esi

$end$34_0:				; CODE XREF: _load_certs_crls+D9j
					; _load_certs_crls+EDj	...
		mov	eax, [esp+1Ch+arg_C]
		test	eax, eax
		jz	short loc_1FA5
		push	offset _X509_INFO_free
		push	eax
		call	_sk_pop_free
		add	esp, 8

loc_1FA5:				; CODE XREF: _load_certs_crls+1A1j
		mov	edi, [esp+1Ch+var_C]
		test	edi, edi
		jnz	short loc_2005
		test	ebx, ebx
		jz	short loc_1FC2
		push	offset _X509_free
		push	dword ptr [ebx]
		call	_sk_pop_free
		add	esp, 8
		mov	[ebx], edi

loc_1FC2:				; CODE XREF: _load_certs_crls+1BBj
		test	ebp, ebp
		jz	short loc_1FDD
		push	offset _X509_CRL_free
		push	dword ptr [ebp+0]
		call	_sk_pop_free
		add	esp, 8
		mov	dword ptr [ebp+0], 0

loc_1FDD:				; CODE XREF: _load_certs_crls+1D0j
		mov	esi, [esp+1Ch+arg_0]
		mov	ecx, offset ??_C@_04DKBILDMD@CRLs?$AA@ ; "CRLs"
		test	ebx, ebx
		mov	eax, offset ??_C@_0N@NGKEHKOM@certificates?$AA@	; "certificates"
		cmovz	eax, ecx
		push	eax
		push	offset ??_C@_0BD@DHEMONEO@unable?5to?5load?5?$CFs?6?$AA@ ; "unable to load %s\n"
		push	esi
		call	_BIO_printf
		push	esi
		call	_ERR_print_errors
		add	esp, 10h

loc_2005:				; CODE XREF: _load_certs_crls+1B7j
		pop	ebp
		pop	ebx
		mov	eax, edi
		pop	edi
		pop	esi
		add	esp, 0Ch
		retn
_load_certs_crls endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2010h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _load_config
_load_config	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		cmp	ds:?load_config_called@?1??load_config@@9@9, 0 ; `load_config'::`2'::load_config_called
		jz	short loc_201F
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_201F:				; CODE XREF: _load_config+7j
		push	esi
		mov	esi, [esp+4+arg_4]
		mov	ds:?load_config_called@?1??load_config@@9@9, 1 ; `load_config'::`2'::load_config_called
		test	esi, esi
		jnz	short loc_203C
		mov	esi, dword ptr ds:_config
		test	esi, esi
		jz	short loc_206E

loc_203C:				; CODE XREF: _load_config+20j
		call	_OPENSSL_load_builtin_modules
		push	0
		push	0
		push	esi
		call	_CONF_modules_load
		add	esp, 0Ch
		test	eax, eax
		jg	short loc_206E
		mov	esi, [esp+4+arg_0]
		push	offset ??_C@_0BL@IPMGKJPN@Error?5configuring?5OpenSSL?6?$AA@ ; "Error configuring OpenSSL\n"
		push	esi
		call	_BIO_printf
		push	esi
		call	_ERR_print_errors
		add	esp, 0Ch
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_206E:				; CODE XREF: _load_config+2Aj
					; _load_config+40j
		mov	eax, 1
		pop	esi
		retn
_load_config	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2078h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl load_crl(char *ErrMsg, int)
		public _load_crl
_load_crl	proc near

var_4		= dword	ptr -4
ErrMsg		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 4
		call	__chkstk
		push	edi
		mov	edi, [esp+8+arg_4]
		mov	[esp+8+var_4], 0
		cmp	edi, 0Dh
		jnz	short loc_20B4
		lea	eax, [esp+8+var_4]
		push	eax
		push	0
		push	dword ptr ds:_bio_err
		push	[esp+14h+ErrMsg]
		call	_load_cert_crl_http
		mov	eax, [esp+18h+var_4]
		add	esp, 10h
		pop	edi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_20B4:				; CODE XREF: _load_crl+1Aj
		push	esi
		call	_BIO_s_file
		push	eax
		call	_BIO_new
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jnz	short loc_20E8
		push	dword ptr ds:_bio_err
		call	_ERR_print_errors
		add	esp, 4
		push	esi
		call	_BIO_free
		mov	eax, [esp+10h+var_4]
		add	esp, 4
		pop	esi
		pop	edi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_20E8:				; CODE XREF: _load_crl+4Fj
		push	ebx
		mov	ebx, [esp+10h+ErrMsg]
		test	ebx, ebx
		jnz	short loc_2117
		push	ebx
		call	dword ptr ds:__imp____acrt_iob_func
		push	eax
		push	ebx
		push	6Ah ; 'j'
		push	esi
		call	_BIO_ctrl
		add	esp, 14h

loc_2105:				; CODE XREF: _load_crl+AFj
		cmp	edi, 1
		jnz	short loc_2145
		push	0
		push	esi
		call	_d2i_X509_CRL_bio
		add	esp, 8
		jmp	short loc_2159
; ---------------------------------------------------------------------------

loc_2117:				; CODE XREF: _load_crl+77j
		push	ebx
		push	3
		push	6Ch ; 'l'
		push	esi
		call	_BIO_ctrl
		add	esp, 10h
		test	eax, eax
		jg	short loc_2105
		push	ebx		; ErrMsg
		call	dword ptr ds:__imp__perror
		add	esp, 4
		pop	ebx
		push	esi
		call	_BIO_free
		mov	eax, [esp+10h+var_4]
		add	esp, 4
		pop	esi
		pop	edi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_2145:				; CODE XREF: _load_crl+90j
		cmp	edi, 3
		jnz	short loc_2191
		push	0
		push	0
		push	0
		push	esi
		call	_PEM_read_bio_X509_CRL
		add	esp, 10h

loc_2159:				; CODE XREF: _load_crl+9Dj
		mov	[esp+10h+var_4], eax
		test	eax, eax
		jnz	short loc_21A4
		push	offset ??_C@_0BE@BBFHHDDE@unable?5to?5load?5CRL?6?$AA@ ; "unable to load CRL\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		push	dword ptr ds:_bio_err
		call	_ERR_print_errors
		add	esp, 0Ch
		pop	ebx
		push	esi
		call	_BIO_free
		mov	eax, [esp+10h+var_4]
		add	esp, 4
		pop	esi
		pop	edi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_2191:				; CODE XREF: _load_crl+D0j
		push	offset ??_C@_0CK@DJFFGPOF@bad?5input?5format?5specified?5for?5i@ ; "bad	input format specified for input cr"...
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 8

loc_21A4:				; CODE XREF: _load_crl+E7j
		pop	ebx

$end$17:
		push	esi
		call	_BIO_free
		mov	eax, [esp+10h+var_4]
		add	esp, 4
		pop	esi
		pop	edi
		pop	ecx
		retn
_load_crl	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 21B8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_load_crl_crldp	proc near		; CODE XREF: _crls_http_cb+1Dp
					; _crls_http_cb+5Dp

var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 4
		call	__chkstk
		push	esi
		push	edi
		mov	edi, [esp+0Ch+arg_0]
		xor	esi, esi
		push	edi
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jle	short loc_21FA
		nop

loc_21D8:				; CODE XREF: _load_crl_crldp+40j
		push	esi
		push	edi
		call	_sk_value
		push	eax
		call	_get_dp_url
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_2200
		push	edi
		inc	esi
		call	_sk_num
		add	esp, 4
		cmp	esi, eax
		jl	short loc_21D8

loc_21FA:				; CODE XREF: _load_crl_crldp+1Dj
		pop	edi
		xor	eax, eax
		pop	esi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_2200:				; CODE XREF: _load_crl_crldp+32j
		lea	ecx, [esp+0Ch+var_4]
		mov	[esp+0Ch+var_4], 0
		push	ecx
		push	0
		push	dword ptr ds:_bio_err
		push	eax
		call	_load_cert_crl_http
		add	esp, 10h

$end$25:
		mov	eax, [esp+0Ch+var_4]
		pop	edi
		pop	esi
		pop	ecx
		retn
_load_crl_crldp	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2228h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _load_crls
_load_crls	proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	eax, 4
		call	__chkstk
		lea	eax, [esp+4+var_4]
		push	eax
		push	0
		push	[esp+0Ch+arg_14]
		push	[esp+10h+arg_10]
		push	[esp+14h+arg_C]
		push	[esp+18h+arg_8]
		push	[esp+1Ch+arg_4]
		push	[esp+20h+arg_0]
		call	_load_certs_crls
		neg	eax
		sbb	eax, eax
		and	eax, [esp+24h+var_4]
		add	esp, 24h
		retn
_load_crls	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2264h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl load_index(char *ErrMsg, int)
		public _load_index
_load_index	proc near

var_108		= dword	ptr -108h
var_104		= byte ptr -104h
var_4		= dword	ptr -4
ErrMsg		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 108h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+108h+var_4], eax
		push	ebp
		push	esi
		push	edi
		mov	edi, [esp+114h+ErrMsg]
		xor	esi, esi
		call	_BIO_s_file
		push	eax
		call	_BIO_new
		mov	ebp, eax
		mov	[esp+118h+var_108], 0FFFFFFFFh
		add	esp, 4
		test	ebp, ebp
		jnz	short loc_22B4
		push	dword ptr ds:_bio_err
		call	_ERR_print_errors
		jmp	loc_23F3
; ---------------------------------------------------------------------------

loc_22B4:				; CODE XREF: _load_index+3Ej
		push	edi
		push	3
		push	6Ch ; 'l'
		push	ebp
		call	_BIO_ctrl
		add	esp, 10h
		test	eax, eax
		jg	short loc_22E6
		push	edi		; ErrMsg
		call	dword ptr ds:__imp__perror
		push	edi
		push	offset ??_C@_0BF@BIGLPGDL@unable?5to?5open?5?8?$CFs?8?6?$AA@ ; "unable to open '%s'\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 10h
		jmp	loc_23ED
; ---------------------------------------------------------------------------

loc_22E6:				; CODE XREF: _load_index+60j
		push	ebx
		push	6
		push	ebp
		call	_TXT_DB_read
		mov	ebx, eax
		add	esp, 8
		test	ebx, ebx
		jz	loc_23EC
		push	edi
		push	offset ??_C@_07MFJDFAJK@?$CFs?4attr?$AA@ ; "%s.attr"
		lea	eax, [esp+120h+var_104]
		push	100h
		push	eax
		call	_BIO_snprintf
		push	0
		call	_NCONF_new
		mov	edi, eax
		lea	eax, [esp+12Ch+var_108]
		push	eax
		lea	eax, [esp+130h+var_104]
		push	eax
		push	edi
		call	_NCONF_load
		add	esp, 20h
		test	eax, eax
		jg	short loc_235F
		mov	eax, [esp+118h+var_108]
		test	eax, eax
		jle	short loc_2354
		lea	ecx, [esp+118h+var_104]
		push	ecx
		push	eax
		push	offset ??_C@_0CN@KHNEBDJO@error?5on?5line?5?$CFld?5of?5db?5attribut@ ; "error on line %ld of db	attribute file "...
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 10h
		jmp	short $err$21_0
; ---------------------------------------------------------------------------

loc_2354:				; CODE XREF: _load_index+D3j
		push	edi
		call	_NCONF_free
		add	esp, 4
		xor	edi, edi

loc_235F:				; CODE XREF: _load_index+CBj
		push	759h
		push	offset ??_C@_0O@BBAIDNNM@?4?2apps?2apps?4c?$AA@	; ".\\apps\\apps.c"
		push	8
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jnz	short loc_2391
		push	offset ??_C@_0P@HKFKDJCC@Out?5of?5memory?6?$AA@	; "Out of memory\n"
		push	2
		call	dword ptr ds:__imp____acrt_iob_func
		add	esp, 4
		push	eax		; File
		call	_fprintf
		jmp	short loc_23CF
; ---------------------------------------------------------------------------

loc_2391:				; CODE XREF: _load_index+113j
		mov	eax, [esp+118h+arg_4]
		mov	[esi+4], ebx
		xor	ebx, ebx
		test	eax, eax
		jz	short loc_23A7
		mov	eax, [eax]
		mov	[esi], eax
		jmp	short loc_23AD
; ---------------------------------------------------------------------------

loc_23A7:				; CODE XREF: _load_index+13Bj
		mov	dword ptr [esi], 1

loc_23AD:				; CODE XREF: _load_index+141j
		test	edi, edi
		jz	short loc_23EC
		push	offset ??_C@_0P@HOGDIGGB@unique_subject?$AA@ ; "unique_subject"
		push	0
		push	edi
		call	_NCONF_get_string
		add	esp, 0Ch
		test	eax, eax
		jz	short $err$21_0
		push	1
		push	eax
		call	_parse_yesno
		mov	[esi], eax

loc_23CF:				; CODE XREF: _load_index+12Bj
		add	esp, 8

$err$21_0:				; CODE XREF: _load_index+EEj
					; _load_index+15Fj
		test	edi, edi
		jz	short loc_23DF
		push	edi
		call	_NCONF_free
		add	esp, 4

loc_23DF:				; CODE XREF: _load_index+170j
		test	ebx, ebx
		jz	short loc_23EC
		push	ebx
		call	_TXT_DB_free
		add	esp, 4

loc_23EC:				; CODE XREF: _load_index+92j
					; _load_index+14Bj ...
		pop	ebx

loc_23ED:				; CODE XREF: _load_index+7Dj
		push	ebp
		call	_BIO_free_all

loc_23F3:				; CODE XREF: _load_index+4Bj
		mov	ecx, [esp+118h+var_4]
		add	esp, 4
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebp
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 108h
		retn
_load_index	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2410h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl load_key(int, char *Buf, int, int, int, int, int)
		public _load_key
_load_key	proc near

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
Buf		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h
arg_18		= dword	ptr  1Ch

		mov	eax, 0Ch
		call	__chkstk
		mov	eax, [esp+0Ch+arg_10]
		push	ebx
		push	ebp
		mov	ebp, [esp+14h+arg_18]
		push	esi
		mov	esi, [esp+18h+Buf]
		mov	[esp+18h+var_C], 0
		mov	[esp+18h+var_8], eax
		mov	[esp+18h+var_4], esi
		push	edi
		test	esi, esi
		jnz	short loc_2465
		cmp	[esp+1Ch+arg_C], 0
		jz	short loc_244E
		mov	ebx, [esp+1Ch+arg_8]
		cmp	ebx, 7
		jnz	short loc_24CC

loc_244E:				; CODE XREF: _load_key+33j
		mov	edi, [esp+1Ch+arg_0]
		push	offset ??_C@_0BG@OLBFGCBD@no?5keyfile?5specified?6?$AA@	; "no keyfile specified\n"
		push	edi
		call	_BIO_printf
		add	esp, 8
		jmp	loc_2627
; ---------------------------------------------------------------------------

loc_2465:				; CODE XREF: _load_key+2Cj
		mov	ebx, [esp+1Ch+arg_8]
		cmp	ebx, 7
		jnz	short loc_24CC
		mov	eax, [esp+1Ch+arg_14]
		test	eax, eax
		jnz	short loc_248D
		mov	edi, [esp+1Ch+arg_0]
		push	offset ??_C@_0BF@MCNMEPFL@no?5engine?5specified?6?$AA@ ; "no engine specified\n"
		push	edi
		call	_BIO_printf
		add	esp, 8
		jmp	loc_2627
; ---------------------------------------------------------------------------

loc_248D:				; CODE XREF: _load_key+64j
		lea	ecx, [esp+1Ch+var_8]
		push	ecx
		push	ds:_ui_method
		push	esi
		push	eax
		call	_ENGINE_load_private_key
		add	esp, 10h
		mov	[esp+1Ch+var_C], eax
		test	eax, eax
		jnz	loc_2648
		mov	edi, [esp+1Ch+arg_0]
		push	ebp
		push	offset ??_C@_0BM@OODBDEPN@cannot?5load?5?$CFs?5from?5engine?6?$AA@ ; "cannot load %s from engine\n"
		push	edi
		call	_BIO_printf
		push	edi
		call	_ERR_print_errors
		add	esp, 10h
		jmp	loc_2627
; ---------------------------------------------------------------------------

loc_24CC:				; CODE XREF: _load_key+3Cj
					; _load_key+5Cj
		call	_BIO_s_file
		push	eax
		call	_BIO_new
		mov	edi, [esp+20h+arg_0]
		mov	ebp, eax
		add	esp, 4
		test	ebp, ebp
		jnz	short loc_24EF
		push	edi
		call	_ERR_print_errors
		jmp	loc_2620
; ---------------------------------------------------------------------------

loc_24EF:				; CODE XREF: _load_key+D2j
		test	esi, esi
		jnz	short loc_253F
		cmp	[esp+1Ch+arg_C], esi
		jz	short loc_253F
		push	esi		; Size
		push	4		; Mode
		push	esi		; Buf
		push	esi
		mov	esi, dword ptr ds:__imp____acrt_iob_func
		call	esi ; __imp____acrt_iob_func
		add	esp, 4
		push	eax		; File
		call	dword ptr ds:__imp__setvbuf
		push	0
		call	esi ; __imp____acrt_iob_func
		push	eax
		push	0
		push	6Ah ; 'j'
		push	ebp
		call	_BIO_ctrl
		mov	esi, [esp+40h+Buf]
		add	esp, 24h

loc_2526:				; CODE XREF: _load_key+13Fj
		cmp	ebx, 1
		jnz	short loc_256D
		push	0
		push	ebp
		call	_d2i_PrivateKey_bio
		add	esp, 8
		mov	[esp+1Ch+var_C], eax
		jmp	$end$34
; ---------------------------------------------------------------------------

loc_253F:				; CODE XREF: _load_key+E1j
					; _load_key+E7j
		push	esi
		push	3
		push	6Ch ; 'l'
		push	ebp
		call	_BIO_ctrl
		add	esp, 10h
		test	eax, eax
		jg	short loc_2526
		mov	eax, [esp+1Ch+arg_18]
		push	esi
		push	eax
		push	offset ??_C@_0BF@JJKPOFNI@Error?5opening?5?$CFs?5?$CFs?6?$AA@ ;	"Error opening %s %s\n"
		push	edi
		call	_BIO_printf
		push	edi
		call	_ERR_print_errors
		jmp	loc_2617
; ---------------------------------------------------------------------------

loc_256D:				; CODE XREF: _load_key+119j
		cmp	ebx, 3
		jnz	short loc_2590
		lea	eax, [esp+1Ch+var_8]
		push	eax
		push	offset _password_callback
		push	0
		push	ebp
		call	_PEM_read_bio_PrivateKey
		add	esp, 10h
		mov	[esp+1Ch+var_C], eax
		jmp	$end$34
; ---------------------------------------------------------------------------

loc_2590:				; CODE XREF: _load_key+160j
		cmp	ebx, 4
		jz	short loc_2605
		cmp	ebx, 8
		jz	short loc_2605
		cmp	ebx, 5
		jnz	short loc_25C3
		push	0
		push	0
		lea	eax, [esp+24h+var_C]
		push	eax
		lea	eax, [esp+28h+var_8]
		push	eax
		mov	eax, [esp+2Ch+arg_18]
		push	offset _password_callback
		push	eax
		push	ebp
		push	edi
		call	_load_pkcs12
		add	esp, 20h
		jmp	short $end$34
; ---------------------------------------------------------------------------

loc_25C3:				; CODE XREF: _load_key+18Dj
		cmp	ebx, 0Bh
		jnz	short loc_25D7
		push	ebp
		call	_b2i_PrivateKey_bio
		add	esp, 4
		mov	[esp+1Ch+var_C], eax
		jmp	short $end$34
; ---------------------------------------------------------------------------

loc_25D7:				; CODE XREF: _load_key+1B6j
		cmp	ebx, 0Ch
		jnz	short loc_25F5
		lea	eax, [esp+1Ch+var_8]
		push	eax
		push	offset _password_callback
		push	ebp
		call	_b2i_PVK_bio
		add	esp, 0Ch
		mov	[esp+1Ch+var_C], eax
		jmp	short $end$34
; ---------------------------------------------------------------------------

loc_25F5:				; CODE XREF: _load_key+1CAj
		push	offset ??_C@_0CJ@DHFLKNAM@bad?5input?5format?5specified?5for?5k@ ; "bad	input format specified for key file"...
		push	edi
		call	_BIO_printf
		add	esp, 8
		jmp	short $end$34
; ---------------------------------------------------------------------------

loc_2605:				; CODE XREF: _load_key+183j
					; _load_key+188j
		mov	eax, [esp+1Ch+arg_18]
		push	ebx
		push	eax
		push	esi
		push	ebp
		push	edi
		call	_load_netscape_key
		mov	[esp+30h+var_C], eax

loc_2617:				; CODE XREF: _load_key+158j
		add	esp, 14h

$end$34:				; CODE XREF: _load_key+12Aj
					; _load_key+17Bj ...
		push	ebp
		call	_BIO_free

loc_2620:				; CODE XREF: _load_key+DAj
		mov	ebp, [esp+20h+arg_18]
		add	esp, 4

loc_2627:				; CODE XREF: _load_key+50j
					; _load_key+78j ...
		mov	eax, [esp+1Ch+var_C]
		test	eax, eax
		jnz	short loc_2648
		push	ebp
		push	offset ??_C@_0BD@DHEMONEO@unable?5to?5load?5?$CFs?6?$AA@ ; "unable to load %s\n"
		push	edi
		call	_BIO_printf
		push	edi
		call	_ERR_print_errors
		mov	eax, [esp+2Ch+var_C]
		add	esp, 10h

loc_2648:				; CODE XREF: _load_key+98j
					; _load_key+21Dj
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 0Ch
		retn
_load_key	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2650h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_load_netscape_key proc	near		; CODE XREF: _load_key+1FEp
					; _load_pubkey+20Bp

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	eax, 4
		call	__chkstk
		push	ebx
		push	ebp
		push	esi
		push	edi
		call	_BUF_MEM_new
		mov	edi, eax
		call	_EVP_PKEY_new
		xor	esi, esi
		mov	ebx, eax
		test	edi, edi
		jz	short $error$19
		test	ebx, ebx
		jz	short $error$19
		push	2800h
		push	edi
		call	_BUF_MEM_grow_clean
		add	esp, 8
		test	eax, eax
		jz	short $error$19
		mov	ebp, [esp+14h+arg_4]
		nop	dword ptr [eax+00h]

loc_2690:				; CODE XREF: _load_netscape_key+6Ej
		mov	eax, [edi+4]
		push	2800h
		add	eax, esi
		push	eax
		push	ebp
		call	_BIO_read
		add	esp, 0Ch
		add	esi, eax
		test	eax, eax
		jz	short loc_26F2
		js	short loc_26D7
		lea	eax, [esi+2800h]
		push	eax
		push	edi
		call	_BUF_MEM_grow_clean
		add	esp, 8
		test	eax, eax
		jnz	short loc_2690

$error$19:				; CODE XREF: _load_netscape_key+20j
					; _load_netscape_key+24j ...
		push	edi
		call	_BUF_MEM_free
		push	ebx
		call	_EVP_PKEY_free
		add	esp, 8
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_26D7:				; CODE XREF: _load_netscape_key+5Aj
		push	[esp+14h+arg_8]
		push	[esp+18h+arg_C]
		push	offset ??_C@_0BE@NPKILBBI@Error?5reading?5?$CFs?5?$CFs?$AA@ ; "Error reading %s	%s"
		push	[esp+20h+arg_0]
		call	_BIO_printf
		add	esp, 10h
		jmp	short $error$19
; ---------------------------------------------------------------------------

loc_26F2:				; CODE XREF: _load_netscape_key+58j
		mov	eax, [edi+4]
		mov	[esp+14h+var_4], eax
		xor	eax, eax
		cmp	[esp+14h+arg_10], 8
		setz	al
		push	eax
		push	0
		push	esi
		lea	eax, [esp+20h+var_4]
		push	eax
		push	0
		call	_d2i_RSA_NET
		mov	esi, eax
		add	esp, 14h
		test	esi, esi
		jz	short $error$19
		push	edi
		call	_BUF_MEM_free
		push	esi
		push	ebx
		call	_EVP_PKEY_set1_RSA
		add	esp, 0Ch
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
_load_netscape_key endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2734h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_load_pkcs12	proc near		; CODE XREF: _load_cert+170p
					; _load_key+1A9p

var_418		= dword	ptr -418h
var_414		= dword	ptr -414h
var_410		= dword	ptr -410h
var_40C		= dword	ptr -40Ch
var_408		= dword	ptr -408h
var_404		= byte ptr -404h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h
arg_18		= dword	ptr  1Ch
arg_1C		= dword	ptr  20h

		mov	eax, 418h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+418h+var_4], eax
		mov	ecx, [esp+418h+arg_C]
		mov	eax, [esp+418h+arg_4]
		push	ebx
		mov	ebx, [esp+41Ch+arg_8]
		push	ebp
		mov	[esp+420h+var_418], ecx
		xor	ebp, ebp
		mov	ecx, [esp+420h+arg_10]
		push	esi
		mov	[esp+424h+var_414], ecx
		mov	ecx, [esp+424h+arg_14]
		push	edi
		mov	edi, [esp+428h+arg_0]
		mov	[esp+428h+var_408], ecx
		mov	ecx, [esp+428h+arg_18]
		mov	[esp+428h+var_40C], ecx
		mov	ecx, [esp+428h+arg_1C]
		push	ebp
		push	eax
		mov	[esp+430h+var_410], ecx
		call	_d2i_PKCS12_bio
		mov	esi, eax
		add	esp, 8
		test	esi, esi
		jnz	short loc_27C2
		push	ebx
		push	offset ??_C@_0CC@PEGFFLPF@Error?5loading?5PKCS12?5file?5for?5?$CFs@ ; "Error loading PKCS12 file for %s\n"
		push	edi
		call	_BIO_printf
		add	esp, 0Ch
		jmp	loc_287B
; ---------------------------------------------------------------------------

loc_27C2:				; CODE XREF: _load_pkcs12+78j
		push	0
		push	offset ??_C@_00CNPNBAHC@?$AA@ ;	`string'
		push	esi
		call	_PKCS12_verify_mac
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_2855
		push	eax
		push	eax
		push	esi
		call	_PKCS12_verify_mac
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_2855
		push	[esp+428h+var_414]
		mov	eax, [esp+42Ch+var_418]
		mov	ecx, offset _password_callback
		test	eax, eax
		push	0
		cmovz	eax, ecx
		lea	ecx, [esp+430h+var_404]
		push	400h
		push	ecx
		call	eax
		add	esp, 10h
		test	eax, eax
		jns	short loc_281D
		push	ebx
		push	offset ??_C@_0CC@DKCLIBKC@Passpharse?5callback?5error?5for?5?$CFs@ ; "Passpharse callback error	for %s\n"
		push	edi
		call	_BIO_printf
		add	esp, 0Ch
		jmp	short $die$17
; ---------------------------------------------------------------------------

loc_281D:				; CODE XREF: _load_pkcs12+D6j
		cmp	eax, 400h
		jge	short loc_282B
		jnb	short loc_2896
		mov	[esp+eax+428h+var_404],	0

loc_282B:				; CODE XREF: _load_pkcs12+EEj
		push	eax
		lea	eax, [esp+42Ch+var_404]
		push	eax
		push	esi
		call	_PKCS12_verify_mac
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_284F
		push	ebx
		push	offset ??_C@_0DK@EMMPDJCK@Mac?5verify?5error?5?$CIwrong?5password@ ; "Mac verify error (wrong password?) in P"...
		push	edi
		call	_BIO_printf
		add	esp, 0Ch
		jmp	short $die$17
; ---------------------------------------------------------------------------

loc_284F:				; CODE XREF: _load_pkcs12+108j
		lea	eax, [esp+428h+var_404]
		jmp	short loc_285A
; ---------------------------------------------------------------------------

loc_2855:				; CODE XREF: _load_pkcs12+A0j
					; _load_pkcs12+AFj
		mov	eax, offset ??_C@_00CNPNBAHC@?$AA@ ; `string'

loc_285A:				; CODE XREF: _load_pkcs12+11Fj
		push	[esp+428h+var_410]
		push	[esp+42Ch+var_40C]
		push	[esp+430h+var_408]
		push	eax
		push	esi
		call	_PKCS12_parse
		add	esp, 14h
		mov	ebp, eax

$die$17:				; CODE XREF: _load_pkcs12+E7j
					; _load_pkcs12+119j
		push	esi
		call	_PKCS12_free
		add	esp, 4

loc_287B:				; CODE XREF: _load_pkcs12+89j
		mov	ecx, [esp+428h+var_4]
		mov	eax, ebp
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 418h
		retn
; ---------------------------------------------------------------------------

loc_2896:				; CODE XREF: _load_pkcs12+F0j
		call	___report_rangecheckfailure

$LN16:					; $LN14
		int	3
_load_pkcs12	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 289Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl load_pubkey(int, char *Buf, int, int, int, int, int)
		public _load_pubkey
_load_pubkey	proc near

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
Buf		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h
arg_18		= dword	ptr  1Ch

		mov	eax, 8
		call	__chkstk
		mov	eax, [esp+8+arg_10]
		push	ebx
		push	ebp
		push	esi
		mov	esi, [esp+14h+arg_0]
		push	edi
		mov	[esp+18h+var_8], eax
		xor	edi, edi
		mov	eax, [esp+18h+Buf]
		mov	[esp+18h+var_4], eax
		test	eax, eax
		jnz	short loc_28EA
		cmp	[esp+18h+arg_C], edi
		jz	short loc_28D3
		mov	ebx, [esp+18h+arg_8]
		cmp	ebx, 7
		jnz	short loc_2937

loc_28D3:				; CODE XREF: _load_pubkey+2Cj
		push	offset ??_C@_0BG@OLBFGCBD@no?5keyfile?5specified?6?$AA@	; "no keyfile specified\n"
		push	esi
		call	_BIO_printf
		mov	ebx, [esp+20h+arg_18]
		add	esp, 8
		jmp	loc_2ABE
; ---------------------------------------------------------------------------

loc_28EA:				; CODE XREF: _load_pubkey+26j
		mov	ebx, [esp+18h+arg_8]
		cmp	ebx, 7
		jnz	short loc_2937
		mov	ecx, [esp+18h+arg_14]
		test	ecx, ecx
		jnz	short loc_2917
		push	offset ??_C@_0BF@MCNMEPFL@no?5engine?5specified?6?$AA@ ; "no engine specified\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		mov	ebx, [esp+20h+arg_18]
		add	esp, 8
		jmp	loc_2ABE
; ---------------------------------------------------------------------------

loc_2917:				; CODE XREF: _load_pubkey+5Dj
		lea	edx, [esp+18h+var_8]
		push	edx
		push	ds:_ui_method
		push	eax
		push	ecx
		call	_ENGINE_load_public_key
		mov	ebx, [esp+28h+arg_18]
		add	esp, 10h
		mov	edi, eax
		jmp	loc_2ABA
; ---------------------------------------------------------------------------

loc_2937:				; CODE XREF: _load_pubkey+35j
					; _load_pubkey+55j
		call	_BIO_s_file
		push	eax
		call	_BIO_new
		mov	ebp, eax
		add	esp, 4
		test	ebp, ebp
		jnz	short loc_295D
		push	esi
		call	_ERR_print_errors
		mov	ebx, [esp+1Ch+arg_18]
		add	esp, 4
		jmp	loc_2ABE
; ---------------------------------------------------------------------------

loc_295D:				; CODE XREF: _load_pubkey+ADj
		mov	eax, [esp+18h+Buf]
		test	eax, eax
		jnz	short loc_29B3
		cmp	[esp+18h+arg_C], edi
		jz	short loc_29B3
		mov	esi, dword ptr ds:__imp____acrt_iob_func
		push	eax		; Size
		push	4		; Mode
		push	eax		; Buf
		push	eax
		call	esi ; __imp____acrt_iob_func
		add	esp, 4
		push	eax		; File
		call	dword ptr ds:__imp__setvbuf
		push	0
		call	esi ; __imp____acrt_iob_func
		push	eax
		push	0
		push	6Ah ; 'j'
		push	ebp
		call	_BIO_ctrl
		mov	esi, [esp+3Ch+arg_0]
		add	esp, 24h

loc_2998:				; CODE XREF: _load_pubkey+127j
		cmp	ebx, 1
		jnz	short loc_29E4
		push	0
		push	ebp
		call	_d2i_PUBKEY_bio
		mov	ebx, [esp+20h+arg_18]
		add	esp, 8
		mov	edi, eax
		jmp	$end$41
; ---------------------------------------------------------------------------

loc_29B3:				; CODE XREF: _load_pubkey+C7j
					; _load_pubkey+CDj
		push	eax
		push	3
		push	6Ch ; 'l'
		push	ebp
		call	_BIO_ctrl
		add	esp, 10h
		test	eax, eax
		jg	short loc_2998
		push	[esp+18h+Buf]
		mov	ebx, [esp+1Ch+arg_18]
		push	ebx
		push	offset ??_C@_0BF@JJKPOFNI@Error?5opening?5?$CFs?5?$CFs?6?$AA@ ;	"Error opening %s %s\n"
		push	esi
		call	_BIO_printf
		push	esi
		call	_ERR_print_errors
		jmp	loc_2AAE
; ---------------------------------------------------------------------------

loc_29E4:				; CODE XREF: _load_pubkey+FFj
		cmp	ebx, 0Ah
		jnz	short loc_2A21
		push	0
		push	ebp
		call	_d2i_RSAPublicKey_bio
		add	esp, 8

loc_29F4:				; CODE XREF: _load_pubkey+19Fj
		mov	ebx, eax
		test	ebx, ebx
		jz	short loc_2A3D
		call	_EVP_PKEY_new
		mov	edi, eax
		test	edi, edi
		jz	short loc_2A0F
		push	ebx
		push	edi
		call	_EVP_PKEY_set1_RSA
		add	esp, 8

loc_2A0F:				; CODE XREF: _load_pubkey+167j
		push	ebx
		call	_RSA_free
		mov	ebx, [esp+1Ch+arg_18]
		add	esp, 4
		jmp	$end$41
; ---------------------------------------------------------------------------

loc_2A21:				; CODE XREF: _load_pubkey+14Bj
		cmp	ebx, 9
		jnz	short loc_2A45
		lea	eax, [esp+18h+var_8]
		push	eax
		push	offset _password_callback
		push	0
		push	ebp
		call	_PEM_read_bio_RSAPublicKey
		add	esp, 10h
		jmp	short loc_29F4
; ---------------------------------------------------------------------------

loc_2A3D:				; CODE XREF: _load_pubkey+15Cj
		mov	ebx, [esp+18h+arg_18]
		xor	edi, edi
		jmp	short $end$41
; ---------------------------------------------------------------------------

loc_2A45:				; CODE XREF: _load_pubkey+188j
		cmp	ebx, 3
		jnz	short loc_2A67
		lea	eax, [esp+18h+var_8]
		push	eax
		push	offset _password_callback
		push	0
		push	ebp
		call	_PEM_read_bio_PUBKEY
		mov	ebx, [esp+28h+arg_18]
		add	esp, 10h
		mov	edi, eax
		jmp	short $end$41
; ---------------------------------------------------------------------------

loc_2A67:				; CODE XREF: _load_pubkey+1ACj
		cmp	ebx, 4
		jz	short loc_2A9B
		cmp	ebx, 8
		jz	short loc_2A9B
		cmp	ebx, 0Bh
		jnz	short loc_2A87
		push	ebp
		call	_b2i_PublicKey_bio
		mov	ebx, [esp+1Ch+arg_18]
		add	esp, 4
		mov	edi, eax
		jmp	short $end$41
; ---------------------------------------------------------------------------

loc_2A87:				; CODE XREF: _load_pubkey+1D8j
		push	offset ??_C@_0CJ@DHFLKNAM@bad?5input?5format?5specified?5for?5k@ ; "bad	input format specified for key file"...
		push	esi
		call	_BIO_printf
		mov	ebx, [esp+20h+arg_18]
		add	esp, 8
		jmp	short $end$41
; ---------------------------------------------------------------------------

loc_2A9B:				; CODE XREF: _load_pubkey+1CEj
					; _load_pubkey+1D3j
		push	ebx
		mov	ebx, [esp+1Ch+arg_18]
		push	ebx
		push	[esp+20h+Buf]
		push	ebp
		push	esi
		call	_load_netscape_key
		mov	edi, eax

loc_2AAE:				; CODE XREF: _load_pubkey+143j
		add	esp, 14h

$end$41:				; CODE XREF: _load_pubkey+112j
					; _load_pubkey+180j ...
		push	ebp
		call	_BIO_free
		add	esp, 4

loc_2ABA:				; CODE XREF: _load_pubkey+96j
		test	edi, edi
		jnz	short loc_2ACD

loc_2ABE:				; CODE XREF: _load_pubkey+49j
					; _load_pubkey+76j ...
		push	ebx
		push	offset ??_C@_0BD@DHEMONEO@unable?5to?5load?5?$CFs?6?$AA@ ; "unable to load %s\n"
		push	esi
		call	_BIO_printf
		add	esp, 0Ch

loc_2ACD:				; CODE XREF: _load_pubkey+220j
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 8
		retn
_load_pubkey	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2AD8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl load_serial(char *ErrMsg,	int, int)
		public _load_serial
_load_serial	proc near

var_408		= dword	ptr -408h
var_404		= byte ptr -404h
var_4		= dword	ptr -4
ErrMsg		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 408h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+408h+var_4], eax
		mov	eax, [esp+408h+arg_8]
		push	ebx
		mov	ebx, [esp+40Ch+ErrMsg]
		push	esi
		push	edi
		mov	[esp+414h+var_408], eax
		xor	esi, esi
		call	_ASN1_INTEGER_new
		mov	edi, eax
		test	edi, edi
		jz	loc_2BB6
		push	ebp
		call	_BIO_s_file
		push	eax
		call	_BIO_new
		mov	ebp, eax
		add	esp, 4
		test	ebp, ebp
		jnz	short loc_2B38
		push	dword ptr ds:_bio_err
		call	_ERR_print_errors
		jmp	short loc_2BA5
; ---------------------------------------------------------------------------

loc_2B38:				; CODE XREF: _load_serial+51j
		push	ebx
		push	3
		push	6Ch ; 'l'
		push	ebp
		call	_BIO_ctrl
		add	esp, 10h
		test	eax, eax
		jg	loc_2BD0
		cmp	[esp+418h+arg_4], esi
		jnz	short loc_2B63
		push	ebx		; ErrMsg
		call	dword ptr ds:__imp__perror
		add	esp, 4
		jmp	short $err$21
; ---------------------------------------------------------------------------

loc_2B63:				; CODE XREF: _load_serial+7Dj
		call	_BN_new
		mov	esi, eax
		test	esi, esi
		jz	short loc_2B7C
		push	edi
		push	esi
		call	_rand_serial
		add	esp, 8
		test	eax, eax
		jnz	short loc_2B8F

loc_2B7C:				; CODE XREF: _load_serial+94j
		push	offset ??_C@_0P@HKFKDJCC@Out?5of?5memory?6?$AA@	; "Out of memory\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 8

loc_2B8F:				; CODE XREF: _load_serial+A2j
		test	esi, esi
		jz	short $err$21

loc_2B93:				; CODE XREF: _load_serial+135j
		mov	eax, [esp+418h+var_408]
		test	eax, eax
		jz	short $err$21
		mov	[eax], edi
		xor	edi, edi

$err$21:				; CODE XREF: _load_serial+89j
					; _load_serial+B9j ...
		push	ebp
		call	_BIO_free

loc_2BA5:				; CODE XREF: _load_serial+5Ej
		add	esp, 4
		pop	ebp
		test	edi, edi
		jz	short loc_2BB6
		push	edi
		call	_ASN1_INTEGER_free
		add	esp, 4

loc_2BB6:				; CODE XREF: _load_serial+38j
					; _load_serial+D3j
		mov	ecx, [esp+414h+var_4]
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 408h
		retn
; ---------------------------------------------------------------------------

loc_2BD0:				; CODE XREF: _load_serial+70j
		push	400h
		lea	eax, [esp+41Ch+var_404]
		push	eax
		push	edi
		push	ebp
		call	_a2i_ASN1_INTEGER
		add	esp, 10h
		test	eax, eax
		jnz	short loc_2BFE
		push	ebx
		push	offset ??_C@_0BP@IBMKHAAI@unable?5to?5load?5number?5from?5?$CFs?6?$AA@ ; "unable to load number	from %s\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 0Ch
		jmp	short $err$21
; ---------------------------------------------------------------------------

loc_2BFE:				; CODE XREF: _load_serial+10Ej
		push	0
		push	edi
		call	_ASN1_INTEGER_to_BN
		mov	esi, eax
		add	esp, 8
		test	esi, esi
		jnz	short loc_2B93
		push	offset ??_C@_0CM@KKKLPGOP@error?5converting?5number?5from?5bin@	; "error converting number from	bin to BIG"...
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 8
		jmp	$err$21
_load_serial	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2C28h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _make_config_name
_make_config_name proc near
		push	ebx
		push	esi
		push	edi
		call	_X509_get_default_cert_area
		mov	ebx, eax
		mov	edx, ebx
		lea	eax, [edx+1]
		nop

loc_2C38:				; CODE XREF: _make_config_name+15j
		mov	cl, [edx]
		inc	edx
		test	cl, cl
		jnz	short loc_2C38
		sub	edx, eax
		push	63Fh
		push	offset ??_C@_0O@BBAIDNNM@?4?2apps?2apps?4c?$AA@	; ".\\apps\\apps.c"
		lea	edi, [edx+0Dh]
		push	edi
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jnz	short loc_2C61
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_2C61:				; CODE XREF: _make_config_name+33j
		push	edi
		push	ebx
		push	esi
		call	_BUF_strlcpy
		push	edi
		push	offset ??_C@_01KMDKNFGN@?1?$AA@	; `string'
		push	esi
		call	_BUF_strlcat
		push	edi
		push	offset ??_C@_0M@CFEEHNHP@openssl?4cnf?$AA@ ; "openssl.cnf"
		push	esi
		call	_BUF_strlcat
		add	esp, 24h
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebx
		retn
_make_config_name endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2C8Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _next_protos_parse
_next_protos_parse proc	near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		push	esi
		push	edi
		mov	edi, [esp+0Ch+arg_4]
		xor	ebx, ebx
		mov	esi, edi
		lea	ecx, [esi+1]
		xchg	ax, ax

loc_2C9C:				; CODE XREF: _next_protos_parse+15j
		mov	al, [esi]
		inc	esi
		test	al, al
		jnz	short loc_2C9C
		sub	esi, ecx
		cmp	esi, 0FFFFh
		jnb	short loc_2D1F
		mov	ecx, edi
		lea	edx, [ecx+1]

loc_2CB2:				; CODE XREF: _next_protos_parse+2Bj
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_2CB2
		sub	ecx, edx
		push	0ACFh
		push	offset ??_C@_0O@BBAIDNNM@?4?2apps?2apps?4c?$AA@	; ".\\apps\\apps.c"
		lea	eax, [ecx+1]
		push	eax
		call	_CRYPTO_malloc
		mov	edx, eax
		add	esp, 0Ch
		xor	eax, eax
		test	edx, edx
		jz	short loc_2D21
		cmp	eax, esi

loc_2CDB:				; CODE XREF: _next_protos_parse+78j
		jz	short loc_2CEB
		mov	cl, [eax+edi]
		cmp	cl, 2Ch	; ','
		jz	short loc_2CEB
		mov	[eax+edx+1], cl
		jmp	short loc_2D01
; ---------------------------------------------------------------------------

loc_2CEB:				; CODE XREF: _next_protos_parse:loc_2CDBj
					; _next_protos_parse+57j
		mov	ecx, eax
		sub	ecx, ebx
		cmp	ecx, 0FFh
		ja	short loc_2D16
		mov	cl, al
		sub	cl, bl
		mov	[edx+ebx], cl
		lea	ebx, [eax+1]

loc_2D01:				; CODE XREF: _next_protos_parse+5Dj
		inc	eax
		cmp	eax, esi
		jbe	short loc_2CDB
		mov	eax, [esp+0Ch+arg_0]
		lea	ecx, [esi+1]
		pop	edi
		pop	esi
		pop	ebx
		mov	[eax], cx
		mov	eax, edx
		retn
; ---------------------------------------------------------------------------

loc_2D16:				; CODE XREF: _next_protos_parse+69j
		push	edx
		call	_CRYPTO_free
		add	esp, 4

loc_2D1F:				; CODE XREF: _next_protos_parse+1Fj
		xor	eax, eax

loc_2D21:				; CODE XREF: _next_protos_parse+4Bj
		pop	edi
		pop	esi
		pop	ebx
		retn
_next_protos_parse endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2D28h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_nodes_print	proc near		; CODE XREF: _policies_print+65p
					; _policies_print+77p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	edi
		push	[esp+8+arg_4]
		push	offset ??_C@_0N@ENJCIODO@?$CFs?5Policies?3?$AA@	; "%s Policies:"
		push	ebx
		call	_BIO_printf
		mov	edi, [esp+14h+arg_8]
		add	esp, 0Ch
		test	edi, edi
		jz	short loc_2D8A
		push	esi
		push	offset ??_C@_01EEMJAFIK@?6?$AA@	; `string'
		push	ebx
		call	_BIO_puts
		push	edi
		xor	esi, esi
		call	_sk_num
		add	esp, 0Ch
		test	eax, eax
		jle	short loc_2D86
		nop	dword ptr [eax+eax+00h]

loc_2D68:				; CODE XREF: _nodes_print+5Cj
		push	esi
		push	edi
		call	_sk_value
		push	2
		push	eax
		push	ebx
		call	_X509_POLICY_NODE_print
		push	edi
		inc	esi
		call	_sk_num
		add	esp, 18h
		cmp	esi, eax
		jl	short loc_2D68

loc_2D86:				; CODE XREF: _nodes_print+39j
		pop	esi
		pop	edi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_2D8A:				; CODE XREF: _nodes_print+1Ej
		push	offset ??_C@_09CMBKKAKN@?5?$DMempty?$DO?6?$AA@ ; " <empty>\n"
		push	ebx
		call	_BIO_puts
		add	esp, 8
		pop	edi
		pop	ebx
		retn
_nodes_print	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2D9Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _parse_name
_parse_name	proc near

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 14h
		call	__chkstk
		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	edi, [esp+24h+arg_0]
		mov	esi, edi
		lea	ecx, [esi+1]

loc_2DB3:				; CODE XREF: _parse_name+1Cj
		mov	al, [esi]
		inc	esi
		test	al, al
		jnz	short loc_2DB3
		sub	esi, ecx
		push	857h
		inc	esi
		push	offset ??_C@_0O@BBAIDNNM@?4?2apps?2apps?4c?$AA@	; ".\\apps\\apps.c"
		push	esi
		call	_CRYPTO_malloc
		shr	esi, 1
		mov	ebp, eax
		push	859h
		inc	esi
		mov	[esp+34h+var_8], ebp
		shl	esi, 2
		push	offset ??_C@_0O@BBAIDNNM@?4?2apps?2apps?4c?$AA@	; ".\\apps\\apps.c"
		push	esi
		call	_CRYPTO_malloc
		push	85Ah
		mov	ebx, eax
		push	offset ??_C@_0O@BBAIDNNM@?4?2apps?2apps?4c?$AA@	; ".\\apps\\apps.c"
		push	esi
		mov	[esp+48h+var_14], ebx
		call	_CRYPTO_malloc
		push	85Bh
		push	offset ??_C@_0O@BBAIDNNM@?4?2apps?2apps?4c?$AA@	; ".\\apps\\apps.c"
		push	esi
		mov	[esp+54h+arg_0], eax
		call	_CRYPTO_malloc
		mov	ecx, ebp
		add	esp, 30h
		xor	ebp, ebp
		mov	edx, eax
		mov	[esp+24h+var_C], edx
		mov	[esp+24h+var_4], ebp
		cmp	ecx, ebp
		jz	loc_301F
		test	ebx, ebx
		jz	loc_301F
		mov	esi, [esp+24h+arg_0]
		test	esi, esi
		jz	loc_301F
		test	edx, edx
		jz	loc_301F
		cmp	byte ptr [edi],	2Fh ; '/'
		jz	short loc_2E67
		push	offset ??_C@_0CC@MFKPEIBE@Subject?5does?5not?5start?5with?5?8?1?8?4@ ; "Subject	does not start with '/'.\n"

loc_2E52:				; CODE XREF: _parse_name+1B3j
					; _parse_name+288j
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 8
		xor	eax, eax
		jmp	$error$67
; ---------------------------------------------------------------------------

loc_2E67:				; CODE XREF: _parse_name+AFj
		lea	eax, [edi+1]
		mov	[edx], ebp
		cmp	byte ptr [eax],	0
		jz	loc_2F58
		mov	edi, esi
		lea	esi, [edx+4]
		mov	edx, ebx
		mov	ebx, [esp+24h+arg_8]
		sub	edx, [esp+24h+arg_0]
		mov	[esp+24h+var_10], edx
		nop	dword ptr [eax+00h]

loc_2E8C:				; CODE XREF: _parse_name+1A9j
		mov	[edx+edi], ecx
		mov	dl, [eax]
		test	dl, dl
		jz	short loc_2EC3
		nop	dword ptr [eax+00000000h]

loc_2E9C:				; CODE XREF: _parse_name+125j
		cmp	dl, 5Ch	; '\'
		jnz	short loc_2EB4
		mov	dl, [eax+1]
		test	dl, dl
		jz	loc_2F4A
		mov	[ecx], dl
		inc	ecx
		add	eax, 2
		jmp	short loc_2EBD
; ---------------------------------------------------------------------------

loc_2EB4:				; CODE XREF: _parse_name+103j
		cmp	dl, 3Dh	; '='
		jz	short loc_2EDE
		mov	[ecx], dl
		inc	ecx
		inc	eax

loc_2EBD:				; CODE XREF: _parse_name+116j
		mov	dl, [eax]
		test	dl, dl
		jnz	short loc_2E9C

loc_2EC3:				; CODE XREF: _parse_name+F7j
					; _parse_name+14Aj
		push	ebp
		push	offset ??_C@_0EN@LIPKONBC@end?5of?5string?5encountered?5while?5@ ; "end	of string encountered while process"...
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 0Ch
		xor	eax, eax
		jmp	$error$67
; ---------------------------------------------------------------------------

loc_2EDE:				; CODE XREF: _parse_name+11Bj
		inc	eax
		mov	byte ptr [ecx],	0
		inc	ecx
		cmp	byte ptr [eax],	0
		jz	short loc_2EC3
		mov	[edi], ecx
		mov	dl, [eax]
		test	dl, dl
		jz	short loc_2F2D

loc_2EF0:				; CODE XREF: _parse_name+17Ej
		cmp	dl, 5Ch	; '\'
		jnz	short loc_2F04
		mov	dl, [eax+1]
		test	dl, dl
		jz	short loc_2F4A
		mov	[ecx], dl
		inc	ecx
		add	eax, 2
		jmp	short loc_2F16
; ---------------------------------------------------------------------------

loc_2F04:				; CODE XREF: _parse_name+157j
		cmp	dl, 2Fh	; '/'
		jz	short loc_2F26
		cmp	dl, 2Bh	; '+'
		jnz	short loc_2F12
		test	ebx, ebx
		jnz	short loc_2F1E

loc_2F12:				; CODE XREF: _parse_name+170j
		mov	[ecx], dl
		inc	ecx
		inc	eax

loc_2F16:				; CODE XREF: _parse_name+166j
		mov	dl, [eax]
		test	dl, dl
		jnz	short loc_2EF0
		jmp	short loc_2F2D
; ---------------------------------------------------------------------------

loc_2F1E:				; CODE XREF: _parse_name+174j
		mov	dword ptr [esi], 0FFFFFFFFh
		jmp	short loc_2F2C
; ---------------------------------------------------------------------------

loc_2F26:				; CODE XREF: _parse_name+16Bj
		mov	dword ptr [esi], 0

loc_2F2C:				; CODE XREF: _parse_name+188j
		inc	eax

loc_2F2D:				; CODE XREF: _parse_name+152j
					; _parse_name+180j
		mov	byte ptr [ecx],	0
		inc	ebp
		inc	ecx
		mov	[esp+24h+var_4], ebp
		add	edi, 4
		add	esi, 4
		cmp	byte ptr [eax],	0
		jz	short loc_2F54
		mov	edx, [esp+24h+var_10]
		jmp	loc_2E8C
; ---------------------------------------------------------------------------

loc_2F4A:				; CODE XREF: _parse_name+10Aj
					; _parse_name+15Ej
		push	offset ??_C@_0CD@EOHKOJGN@escape?5character?5at?5end?5of?5strin@ ; "escape character at	end of string\n"
		jmp	loc_2E52
; ---------------------------------------------------------------------------

loc_2F54:				; CODE XREF: _parse_name+1A3j
		mov	ebx, [esp+24h+var_14]

loc_2F58:				; CODE XREF: _parse_name+D3j
		call	_X509_NAME_new
		mov	[esp+24h+var_10], eax
		test	eax, eax
		jz	$error$67
		xor	edi, edi
		test	ebp, ebp
		jle	short loc_2FEC
		mov	ebp, [esp+24h+var_C]
		mov	esi, ebx
		sub	ebp, ebx
		mov	ebx, [esp+24h+arg_0]
		sub	ebx, [esp+24h+var_14]

loc_2F7F:				; CODE XREF: _parse_name+24Ej
		push	dword ptr [esi]
		call	_OBJ_txt2nid
		mov	ecx, eax
		add	esp, 4
		test	ecx, ecx
		jnz	short loc_2FA6
		push	dword ptr [esi]
		push	offset ??_C@_0DA@DIKEDNCG@Subject?5Attribute?5?$CFs?5has?5no?5know@ ; "Subject Attribute %s has	no known NID, "...
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 0Ch
		jmp	short loc_2FE2
; ---------------------------------------------------------------------------

loc_2FA6:				; CODE XREF: _parse_name+1F1j
		mov	eax, [ebx+esi]
		cmp	byte ptr [eax],	0
		jnz	short loc_2FC5
		push	dword ptr [esi]
		push	offset ??_C@_0DF@IJPKHMNK@No?5value?5provided?5for?5Subject?5At@ ; "No value provided for Subject Attribute"...
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 0Ch
		jmp	short loc_2FE2
; ---------------------------------------------------------------------------

loc_2FC5:				; CODE XREF: _parse_name+210j
		push	dword ptr [esi+ebp]
		push	0FFFFFFFFh
		push	0FFFFFFFFh
		push	eax
		push	[esp+34h+arg_4]
		push	ecx
		push	[esp+3Ch+var_10]
		call	_X509_NAME_add_entry_by_NID
		add	esp, 1Ch
		test	eax, eax
		jz	short loc_3029

loc_2FE2:				; CODE XREF: _parse_name+208j
					; _parse_name+227j
		inc	edi
		add	esi, 4
		cmp	edi, [esp+24h+var_4]
		jl	short loc_2F7F

loc_2FEC:				; CODE XREF: _parse_name+1D1j
		push	[esp+24h+arg_0]
		call	_CRYPTO_free
		push	[esp+28h+var_14]
		call	_CRYPTO_free
		push	[esp+2Ch+var_8]
		call	_CRYPTO_free
		push	[esp+30h+var_C]
		call	_CRYPTO_free
		mov	eax, [esp+34h+var_10]
		add	esp, 10h
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_301F:				; CODE XREF: _parse_name+8Aj
					; _parse_name+92j ...
		push	offset ??_C@_0O@NPENBAOL@malloc?5error?6?$AA@ ;	"malloc	error\n"
		jmp	loc_2E52
; ---------------------------------------------------------------------------

loc_3029:				; CODE XREF: _parse_name+244j
		mov	eax, [esp+24h+var_10]

$error$67:				; CODE XREF: _parse_name+C6j
					; _parse_name+13Dj ...
		push	eax
		call	_X509_NAME_free
		mov	eax, [esp+28h+arg_0]
		add	esp, 4
		test	eax, eax
		jz	short loc_3047
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_3047:				; CODE XREF: _parse_name+2A0j
		mov	eax, [esp+24h+var_14]
		test	eax, eax
		jz	short loc_3058
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_3058:				; CODE XREF: _parse_name+2B1j
		mov	eax, [esp+24h+var_C]
		test	eax, eax
		jz	short loc_3069
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_3069:				; CODE XREF: _parse_name+2C2j
		mov	eax, [esp+24h+var_8]
		test	eax, eax
		jz	short loc_307A
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_307A:				; CODE XREF: _parse_name+2D3j
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		add	esp, 14h
		retn
_parse_name	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3084h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _parse_yesno
_parse_yesno	proc near		; CODE XREF: _load_index+164p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		test	eax, eax
		jz	short $LN10	; jumptable 000030A2 default case
		movsx	eax, byte ptr [eax]
		add	eax, 0FFFFFFD0h	; switch 74 cases
		cmp	eax, 49h ; 'I'
		ja	short $LN10	; jumptable 000030A2 default case
		movzx	eax, ds:$LN9[eax]
		jmp	ds:$LN12[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN5:					; CODE XREF: _parse_yesno+1Ej
					; DATA XREF: .text$mn:$LN12o
		xor	eax, eax	; jumptable 000030A2 cases 48,70,78,102,110
		retn
; ---------------------------------------------------------------------------

$LN6:					; CODE XREF: _parse_yesno+1Ej
					; DATA XREF: .text$mn:$LN12o
		mov	eax, 1		; jumptable 000030A2 cases 49,84,89,116,121
		retn
; ---------------------------------------------------------------------------

$LN10:					; CODE XREF: _parse_yesno+Aj
					; _parse_yesno+15j ...
		mov	eax, ecx	; jumptable 000030A2 default case
		retn
_parse_yesno	endp

; ---------------------------------------------------------------------------
		align 4
$LN12		dd offset $LN5,	offset $LN6, offset $LN10 ; DATA XREF: _parse_yesno+1Er
					; jump table for switch	statement
$LN9		db	0,     1,     2,     2 ; DATA XREF: _parse_yesno+17r
		db	2,     2,     2,     2 ; indirect table	for switch statement
		db	2,     2,     2,     2
		db	2,     2,     2,     2
		db	2,     2,     2,     2
		db	2,     2,     0,     2
		db	2,     2,     2,     2
		db	2,     2,     0,     2
		db	2,     2,     2,     2
		db	1,     2,     2,     2
		db	2,     1,     2,     2
		db	2,     2,     2,     2
		db	2,     2,     2,     2
		db	2,     2,     0,     2
		db	2,     2,     2,     2
		db	2,     2,     0,     2
		db	2,     2,     2,     2
		db	1,     2,     2,     2
		db	2,     1
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3110h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl password_callback(void *Dst, size_t Size,	int, int)
		public _password_callback
_password_callback proc	near		; DATA XREF: _load_cert+142o
					; _load_certs_crls+A8o	...

var_4		= dword	ptr -4
Dst		= dword	ptr  4
Size		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, 4
		call	__chkstk
		mov	edx, [esp+4+arg_C]
		xor	ecx, ecx
		push	ebx
		push	esi
		push	edi
		xor	edi, edi
		xor	ebx, ebx
		test	edx, edx
		jz	short loc_316A
		mov	eax, [edx]
		test	eax, eax
		cmovnz	ecx, eax
		mov	eax, [edx+4]
		test	eax, eax
		cmovnz	ebx, eax
		test	ecx, ecx
		jz	short loc_316A
		mov	esi, ecx
		lea	edx, [esi+1]

loc_3143:				; CODE XREF: _password_callback+38j
		mov	al, [esi]
		inc	esi
		test	al, al
		jnz	short loc_3143
		sub	esi, edx
		cmp	esi, [esp+10h+Size]
		cmovg	esi, [esp+10h+Size]
		push	esi		; Size
		push	ecx		; Src
		push	[esp+18h+Dst]	; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, esi
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_316A:				; CODE XREF: _password_callback+19j
					; _password_callback+2Cj
		push	ebp
		push	ds:_ui_method
		call	_UI_new_method
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jz	loc_331C
		push	ebx
		push	offset ??_C@_0M@FKGGGFHP@pass?5phrase?$AA@ ; "pass phrase"
		push	esi
		xor	ebp, ebp
		call	_UI_construct_prompt
		mov	ebx, eax
		add	esp, 0Ch
		mov	[esp+14h+arg_C], ebx
		test	ebx, ebx
		jnz	short loc_31BF
		push	offset ??_C@_0P@HKFKDJCC@Out?5of?5memory?6?$AA@	; "Out of memory\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		push	esi
		call	_UI_free
		add	esp, 0Ch
		xor	eax, eax
		pop	ebp
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_31BF:				; CODE XREF: _password_callback+8Cj
		push	0
		push	0
		push	1
		push	1
		push	esi
		call	_UI_ctrl
		mov	eax, [esp+28h+Size]
		dec	eax
		push	eax
		push	4
		push	[esp+30h+Dst]
		mov	[esp+34h+var_4], eax
		push	2
		push	ebx
		push	esi
		call	_UI_add_input_string
		mov	ebx, eax
		add	esp, 2Ch
		test	ebx, ebx
		js	loc_32B3
		cmp	[esp+14h+arg_8], edi
		jz	short loc_325B
		push	24Bh
		push	offset ??_C@_0O@BBAIDNNM@?4?2apps?2apps?4c?$AA@	; ".\\apps\\apps.c"
		push	[esp+1Ch+Size]
		call	_CRYPTO_malloc
		mov	ebp, eax
		add	esp, 0Ch
		test	ebp, ebp
		jnz	short loc_323F
		push	offset ??_C@_0P@HKFKDJCC@Out?5of?5memory?6?$AA@	; "Out of memory\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		push	esi
		call	_UI_free
		push	[esp+20h+arg_C]
		call	_CRYPTO_free
		add	esp, 10h
		xor	eax, eax
		pop	ebp
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_323F:				; CODE XREF: _password_callback+103j
		push	[esp+14h+Dst]
		push	[esp+18h+var_4]
		push	4
		push	ebp
		push	2
		push	[esp+28h+arg_C]
		push	esi
		call	_UI_add_verify_string
		add	esp, 1Ch
		mov	ebx, eax

loc_325B:				; CODE XREF: _password_callback+E7j
		test	ebx, ebx
		js	short loc_3284
		nop

loc_3260:				; CODE XREF: _password_callback+172j
		push	esi
		call	_UI_process
		mov	ebx, eax
		add	esp, 4
		test	ebx, ebx
		jns	short loc_3284
		push	0
		push	0
		push	0
		push	2
		push	esi
		call	_UI_ctrl
		add	esp, 14h
		test	eax, eax
		jnz	short loc_3260

loc_3284:				; CODE XREF: _password_callback+14Dj
					; _password_callback+15Dj
		test	ebp, ebp
		jz	short loc_329B
		push	[esp+14h+Size]
		push	ebp
		call	_OPENSSL_cleanse
		push	ebp
		call	_CRYPTO_free
		add	esp, 0Ch

loc_329B:				; CODE XREF: _password_callback+176j
		mov	ebp, [esp+14h+Dst]
		test	ebx, ebx
		js	short loc_32B7
		mov	edi, ebp
		lea	ecx, [edi+1]

loc_32A8:				; CODE XREF: _password_callback+19Dj
		mov	al, [edi]
		inc	edi
		test	al, al
		jnz	short loc_32A8
		sub	edi, ecx
		jmp	short loc_32B7
; ---------------------------------------------------------------------------

loc_32B3:				; CODE XREF: _password_callback+DDj
		mov	ebp, [esp+14h+Dst]

loc_32B7:				; CODE XREF: _password_callback+191j
					; _password_callback+1A1j
		cmp	ebx, 0FFFFFFFFh
		jnz	short loc_32E6
		push	offset ??_C@_0BG@HNCPHOCJ@User?5interface?5error?6?$AA@	; "User	interface error\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		push	dword ptr ds:_bio_err
		call	_ERR_print_errors
		push	[esp+20h+Size]
		push	ebp
		call	_OPENSSL_cleanse
		add	esp, 14h
		jmp	short loc_3308
; ---------------------------------------------------------------------------

loc_32E6:				; CODE XREF: _password_callback+1AAj
		cmp	ebx, 0FFFFFFFEh
		jnz	short loc_330A
		push	offset ??_C@_09JELMDBBD@aborted?$CB?6?$AA@ ; "aborted!\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		push	[esp+1Ch+Size]
		push	ebp
		call	_OPENSSL_cleanse
		add	esp, 10h

loc_3308:				; CODE XREF: _password_callback+1D4j
		xor	edi, edi

loc_330A:				; CODE XREF: _password_callback+1D9j
		push	esi
		call	_UI_free
		push	[esp+18h+arg_C]
		call	_CRYPTO_free
		add	esp, 8

loc_331C:				; CODE XREF: _password_callback+6Dj
		pop	ebp
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebx
		pop	ecx
		retn
_password_callback endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3324h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _pkey_ctrl_string
_pkey_ctrl_string proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	edi
		push	[esp+4+arg_4]
		call	_BUF_strdup
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jnz	short loc_333C
		or	eax, 0FFFFFFFFh
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_333C:				; CODE XREF: _pkey_ctrl_string+11j
		push	3Ah ; ':'       ; Val
		push	edi		; Str
		call	dword ptr ds:__imp__strchr
		add	esp, 8
		test	eax, eax
		jz	short loc_3350
		mov	byte ptr [eax],	0
		inc	eax

loc_3350:				; CODE XREF: _pkey_ctrl_string+26j
		push	esi
		push	eax
		push	edi
		push	[esp+10h+arg_0]
		call	_EVP_PKEY_CTX_ctrl_str
		push	edi
		mov	esi, eax
		call	_CRYPTO_free
		add	esp, 10h
		mov	eax, esi
		pop	esi
		pop	edi
		retn
_pkey_ctrl_string endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 336Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _policies_print
_policies_print	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	ebp
		xor	ebp, ebp
		test	ebx, ebx
		jnz	short loc_3394
		push	ebx
		push	2
		call	dword ptr ds:__imp____acrt_iob_func
		add	esp, 4
		push	eax
		call	_BIO_new_fp
		add	esp, 8
		mov	ebx, eax
		mov	ebp, 1

loc_3394:				; CODE XREF: _policies_print+Aj
		push	edi
		push	[esp+0Ch+arg_4]
		call	_X509_STORE_CTX_get0_policy_tree
		push	[esp+10h+arg_4]
		mov	edi, eax
		call	_X509_STORE_CTX_get_explicit_policy
		test	eax, eax
		mov	edx, offset ??_C@_05MKDOIIA@False?$AA@ ; "False"
		mov	ecx, offset ??_C@_04HPMIDMKH@True?$AA@ ; "True"
		cmovz	ecx, edx
		push	ecx
		push	offset ??_C@_0BN@IBNHIEPH@Require?5explicit?5Policy?3?5?$CFs?6?$AA@ ; "Require explicit	Policy:	%s\n"
		push	ebx
		call	_BIO_printf
		push	edi
		call	_X509_policy_tree_get0_policies
		push	eax
		push	offset ??_C@_09NGOBFEPP@Authority?$AA@ ; "Authority"
		push	ebx
		call	_nodes_print
		push	edi
		call	_X509_policy_tree_get0_user_policies
		push	eax
		push	offset ??_C@_04ODLBFFJE@User?$AA@ ; "User"
		push	ebx
		call	_nodes_print
		add	esp, 34h
		pop	edi
		test	ebp, ebp
		jz	short loc_33F9
		push	ebx
		call	_BIO_free
		add	esp, 4

loc_33F9:				; CODE XREF: _policies_print+82j
		pop	ebp
		pop	ebx
		retn
_policies_print	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 33FCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _print_cert_checks
_print_cert_checks proc	near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		push	esi
		mov	esi, [esp+4+arg_4]
		test	esi, esi
		jz	loc_34A4
		push	ebx
		mov	ebx, [esp+8+arg_8]
		push	ebp
		mov	ebp, [esp+0Ch+arg_0]
		push	edi
		mov	edi, offset ??_C@_00CNPNBAHC@?$AA@ ; `string'
		test	ebx, ebx
		jz	short loc_3447
		push	0
		push	0
		push	0
		push	ebx
		push	esi
		call	_X509_check_host
		cmp	eax, 1
		mov	ecx, edi
		mov	eax, offset ??_C@_04CGMGFKEF@?5NOT?$AA@	; " NOT"
		cmovnz	ecx, eax
		push	ecx
		push	ebx
		push	offset ??_C@_0CG@BEAMIHCH@Hostname?5?$CFs?5does?$CFs?5match?5certifi@ ;	"Hostname %s does%s match certificate\n"
		push	ebp
		call	_BIO_printf
		add	esp, 24h

loc_3447:				; CODE XREF: _print_cert_checks+1Fj
		mov	ebx, [esp+10h+arg_C]
		test	ebx, ebx
		jz	short loc_3476
		push	0
		push	0
		push	ebx
		push	esi
		call	_X509_check_email
		test	eax, eax
		mov	ecx, edi
		mov	eax, offset ??_C@_04CGMGFKEF@?5NOT?$AA@	; " NOT"
		cmovz	ecx, eax
		push	ecx
		push	ebx
		push	offset ??_C@_0CD@CDKJLNLJ@Email?5?$CFs?5does?$CFs?5match?5certificat@ ;	"Email %s does%s match certificate\n"
		push	ebp
		call	_BIO_printf
		add	esp, 20h

loc_3476:				; CODE XREF: _print_cert_checks+51j
		mov	ebx, [esp+10h+arg_10]
		test	ebx, ebx
		jz	short loc_34A1
		push	0
		push	ebx
		push	esi
		call	_X509_check_ip_asc
		test	eax, eax
		mov	eax, offset ??_C@_04CGMGFKEF@?5NOT?$AA@	; " NOT"
		cmovz	edi, eax
		push	edi
		push	ebx
		push	offset ??_C@_0CA@BEKABJAC@IP?5?$CFs?5does?$CFs?5match?5certificate?6?$AA@ ; "IP	%s does%s match	certificate\n"
		push	ebp
		call	_BIO_printf
		add	esp, 1Ch

loc_34A1:				; CODE XREF: _print_cert_checks+80j
		pop	edi
		pop	ebp
		pop	ebx

loc_34A4:				; CODE XREF: _print_cert_checks+7j
		pop	esi
		retn
_print_cert_checks endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 34A8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _print_name
_print_name	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, [esp+arg_4]
		push	ebx
		push	ebp
		push	esi
		xor	bl, bl
		xor	ebp, ebp
		push	edi
		mov	edi, [esp+10h+arg_0]
		test	eax, eax
		jz	short loc_34C6
		push	eax
		push	edi
		call	_BIO_puts
		add	esp, 8

loc_34C6:				; CODE XREF: _print_name+12j
		mov	esi, [esp+10h+arg_C]
		mov	eax, esi
		and	eax, 0F0000h
		cmp	eax, 40000h
		jnz	short loc_34DF
		mov	bl, 1
		mov	ebp, 4

loc_34DF:				; CODE XREF: _print_name+2Ej
		test	esi, esi
		jnz	short loc_3510
		push	esi
		push	esi
		push	[esp+18h+arg_8]
		call	_X509_NAME_oneline
		mov	esi, eax
		push	esi
		push	edi
		call	_BIO_puts
		push	offset ??_C@_01EEMJAFIK@?6?$AA@	; `string'
		push	edi
		call	_BIO_puts
		push	esi
		call	_CRYPTO_free
		add	esp, 20h
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_3510:				; CODE XREF: _print_name+39j
		test	bl, bl
		jz	short loc_3522
		push	offset ??_C@_01EEMJAFIK@?6?$AA@	; `string'
		push	edi
		call	_BIO_puts
		add	esp, 8

loc_3522:				; CODE XREF: _print_name+6Aj
		push	esi
		push	ebp
		push	[esp+18h+arg_8]
		push	edi
		call	_X509_NAME_print_ex
		push	offset ??_C@_01EEMJAFIK@?6?$AA@	; `string'
		push	edi
		call	_BIO_puts
		add	esp, 18h
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_print_name	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3544h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _program_name
_program_name	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	ecx, esi
		lea	edx, [ecx+1]
		nop	word ptr [eax+eax+00h]

loc_3554:				; CODE XREF: _program_name+15j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_3554
		sub	ecx, edx
		lea	eax, [ecx-1]
		test	eax, eax
		jle	short loc_3584

loc_3564:				; CODE XREF: _program_name+35j
		mov	cl, [eax+esi]
		cmp	cl, 2Fh	; '/'
		jz	short loc_357D
		cmp	cl, 5Ch	; '\'
		jz	short loc_357D
		cmp	cl, 3Ah	; ':'
		jz	short loc_357D
		dec	eax
		test	eax, eax
		jg	short loc_3564
		jmp	short loc_3584
; ---------------------------------------------------------------------------

loc_357D:				; CODE XREF: _program_name+26j
					; _program_name+2Bj ...
		lea	edx, [esi+1]
		add	edx, eax
		jnz	short loc_3586

loc_3584:				; CODE XREF: _program_name+1Ej
					; _program_name+37j
		mov	edx, esi

loc_3586:				; CODE XREF: _program_name+3Ej
		mov	ecx, edx
		lea	esi, [ecx+1]

loc_358B:				; CODE XREF: _program_name+4Cj
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_358B
		sub	ecx, esi
		cmp	ecx, 4
		jle	short loc_35C7
		cmp	byte ptr [ecx+edx-4], 2Eh ; '.'
		jnz	short loc_35C7
		mov	al, [ecx+edx-3]
		cmp	al, 65h	; 'e'
		jz	short loc_35AC
		cmp	al, 45h	; 'E'
		jnz	short loc_35C7

loc_35AC:				; CODE XREF: _program_name+62j
		mov	al, [ecx+edx-2]
		cmp	al, 78h	; 'x'
		jz	short loc_35B8
		cmp	al, 58h	; 'X'
		jnz	short loc_35C7

loc_35B8:				; CODE XREF: _program_name+6Ej
		mov	al, [ecx+edx-1]
		cmp	al, 65h	; 'e'
		jz	short loc_35C4
		cmp	al, 45h	; 'E'
		jnz	short loc_35C7

loc_35C4:				; CODE XREF: _program_name+7Aj
		sub	ecx, 4

loc_35C7:				; CODE XREF: _program_name+53j
					; _program_name+5Aj ...
		mov	eax, [esp+4+arg_8]
		dec	eax
		cmp	ecx, eax
		cmovg	ecx, eax
		test	ecx, ecx
		jle	short loc_3601
		push	ebx
		mov	ebx, [esp+8+arg_4]
		mov	esi, ebx
		push	edi
		sub	esi, edx
		mov	edi, ecx
		nop	dword ptr [eax]

loc_35E4:				; CODE XREF: _program_name+B3j
		mov	al, [edx]
		cmp	al, 41h	; 'A'
		jl	short loc_35F0
		cmp	al, 5Ah	; 'Z'
		jg	short loc_35F0
		add	al, 20h	; ' '

loc_35F0:				; CODE XREF: _program_name+A4j
					; _program_name+A8j
		mov	[esi+edx], al
		inc	edx
		sub	edi, 1
		jnz	short loc_35E4
		pop	edi
		mov	byte ptr [ecx+ebx], 0
		pop	ebx
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_3601:				; CODE XREF: _program_name+8Fj
		mov	eax, [esp+4+arg_4]
		pop	esi
		mov	byte ptr [ecx+eax], 0
		retn
_program_name	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 360Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _rand_serial
_rand_serial	proc near		; CODE XREF: _load_serial+98p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		push	esi
		push	edi
		mov	edi, [esp+0Ch+arg_0]
		xor	ebx, ebx
		test	edi, edi
		jz	short loc_361D
		mov	esi, edi
		jmp	short loc_3624
; ---------------------------------------------------------------------------

loc_361D:				; CODE XREF: _rand_serial+Bj
		call	_BN_new
		mov	esi, eax

loc_3624:				; CODE XREF: _rand_serial+Fj
		test	esi, esi
		jnz	short loc_362E
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_362E:				; CODE XREF: _rand_serial+1Aj
		push	0
		push	0
		push	40h ; '@'
		push	esi
		call	_BN_pseudo_rand
		add	esp, 10h
		test	eax, eax
		jz	short $error$10
		mov	eax, [esp+0Ch+arg_4]
		test	eax, eax
		jz	short loc_3657
		push	eax
		push	esi
		call	_BN_to_ASN1_INTEGER
		add	esp, 8
		test	eax, eax
		jz	short $error$10

loc_3657:				; CODE XREF: _rand_serial+3Bj
		mov	ebx, 1

$error$10:				; CODE XREF: _rand_serial+33j
					; _rand_serial+49j
		test	edi, edi
		jnz	short loc_3669
		push	esi
		call	_BN_free
		add	esp, 4

loc_3669:				; CODE XREF: _rand_serial+52j
		pop	edi
		pop	esi
		mov	eax, ebx
		pop	ebx
		retn
_rand_serial	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3670h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl raw_read_stdin(LPVOID lpBuffer, DWORD nNumberOfBytesToRead)
		public _raw_read_stdin
_raw_read_stdin	proc near

NumberOfBytesRead= dword ptr -4
lpBuffer	= dword	ptr  4
nNumberOfBytesToRead= dword ptr	 8

		mov	eax, 4
		call	__chkstk
		push	0		; lpOverlapped
		lea	eax, [esp+8+NumberOfBytesRead]
		push	eax		; lpNumberOfBytesRead
		push	[esp+0Ch+nNumberOfBytesToRead] ; nNumberOfBytesToRead
		push	[esp+10h+lpBuffer] ; lpBuffer
		push	0FFFFFFF6h	; nStdHandle
		call	dword ptr ds:__imp__GetStdHandle@4 ; GetStdHandle(x)
		push	eax		; hFile
		call	dword ptr ds:__imp__ReadFile@20	; ReadFile(x,x,x,x,x)
		or	ecx, 0FFFFFFFFh
		test	eax, eax
		cmovnz	ecx, [esp+4+NumberOfBytesRead]
		mov	eax, ecx
		pop	ecx
		retn
_raw_read_stdin	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 36A8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl raw_write_stdout(LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite)
		public _raw_write_stdout
_raw_write_stdout proc near

NumberOfBytesWritten= dword ptr	-4
lpBuffer	= dword	ptr  4
nNumberOfBytesToWrite= dword ptr  8

		mov	eax, 4
		call	__chkstk
		push	0		; lpOverlapped
		lea	eax, [esp+8+NumberOfBytesWritten]
		push	eax		; lpNumberOfBytesWritten
		push	[esp+0Ch+nNumberOfBytesToWrite]	; nNumberOfBytesToWrite
		push	[esp+10h+lpBuffer] ; lpBuffer
		push	0FFFFFFF5h	; nStdHandle
		call	dword ptr ds:__imp__GetStdHandle@4 ; GetStdHandle(x)
		push	eax		; hFile
		call	dword ptr ds:__imp__WriteFile@20 ; WriteFile(x,x,x,x,x)
		or	ecx, 0FFFFFFFFh
		test	eax, eax
		cmovnz	ecx, [esp+4+NumberOfBytesWritten]
		mov	eax, ecx
		pop	ecx
		retn
_raw_write_stdout endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 36E0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl rotate_index(LPCSTR lpExistingFileName, int, int)
		public _rotate_index
_rotate_index	proc near

var_508		= dword	ptr -508h
ExistingFileName= byte ptr -504h
NewFileName	= byte ptr -404h
var_304		= byte ptr -304h
var_204		= byte ptr -204h
var_104		= byte ptr -104h
var_4		= dword	ptr -4
lpExistingFileName= dword ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 508h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+508h+var_4], eax
		push	ebx
		mov	ebx, [esp+50Ch+arg_8]
		push	ebp
		mov	ebp, [esp+510h+arg_4]
		push	esi
		mov	esi, [esp+514h+lpExistingFileName]
		mov	ecx, esi
		push	edi
		lea	edx, [ecx+1]

loc_3716:				; CODE XREF: _rotate_index+3Bj
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_3716
		sub	ecx, edx
		mov	edx, ebx
		lea	edi, [edx+1]

loc_3724:				; CODE XREF: _rotate_index+49j
		mov	al, [edx]
		inc	edx
		test	al, al
		jnz	short loc_3724
		sub	edx, edi
		lea	eax, [edx+ecx]
		mov	ecx, esi
		mov	[esp+518h+var_508], eax
		lea	edx, [ecx+1]
		nop	dword ptr [eax+00000000h]

loc_3740:				; CODE XREF: _rotate_index+65j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_3740
		sub	ecx, edx
		mov	edx, ebp
		lea	edi, [edx+1]
		xchg	ax, ax

loc_3750:				; CODE XREF: _rotate_index+75j
		mov	al, [edx]
		inc	edx
		test	al, al
		jnz	short loc_3750
		sub	edx, edi
		lea	eax, [edx+ecx]
		cmp	[esp+518h+var_508], eax
		cmovg	eax, [esp+518h+var_508]
		add	eax, 6
		cmp	eax, 100h
		jl	short loc_3789
		push	offset ??_C@_0BE@PGHNBIGG@file?5name?5too?5long?6?$AA@ ; "file name too	long\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 8
		xor	eax, eax
		jmp	loc_39A0
; ---------------------------------------------------------------------------

loc_3789:				; CODE XREF: _rotate_index+8Dj
		push	esi
		push	offset ??_C@_07MFJDFAJK@?$CFs?4attr?$AA@ ; "%s.attr"
		lea	eax, [esp+520h+var_104]
		push	100h
		push	eax
		call	_BIO_snprintf
		push	ebp
		push	esi
		push	offset ??_C@_0L@FJEANEHK@?$CFs?4attr?4?$CFs?$AA@ ; "%s.attr.%s"
		lea	eax, [esp+534h+var_304]
		push	100h
		push	eax
		call	_BIO_snprintf
		push	ebp
		push	esi
		push	offset ??_C@_05NNFHCGPF@?$CFs?4?$CFs?$AA@ ; "%s.%s"
		lea	eax, [esp+548h+ExistingFileName]
		push	100h
		push	eax
		call	_BIO_snprintf
		push	ebx
		push	esi
		push	offset ??_C@_05NNFHCGPF@?$CFs?4?$CFs?$AA@ ; "%s.%s"
		lea	eax, [esp+55Ch+NewFileName]
		push	100h
		push	eax
		call	_BIO_snprintf
		add	esp, 4Ch
		lea	eax, [esp+518h+var_204]
		push	ebx
		push	esi
		push	offset ??_C@_0L@FJEANEHK@?$CFs?4attr?4?$CFs?$AA@ ; "%s.attr.%s"
		push	100h
		push	eax
		call	_BIO_snprintf
		lea	eax, [esp+52Ch+NewFileName]
		push	eax		; lpNewFileName
		push	esi		; lpExistingFileName
		call	_WIN32_rename
		mov	edi, dword ptr ds:__imp___errno
		add	esp, 1Ch
		test	eax, eax
		jns	short loc_385C
		call	edi ; __imp___errno
		cmp	dword ptr [eax], 2
		jz	short loc_385C
		call	edi ; __imp___errno
		cmp	dword ptr [eax], 14h
		jz	short loc_385C
		lea	eax, [esp+518h+NewFileName]
		push	eax
		push	esi
		push	offset ??_C@_0BL@PJHGPAJJ@unable?5to?5rename?5?$CFs?5to?5?$CFs?6?$AA@ ;	"unable	to rename %s to	%s\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		push	offset ??_C@_06CEHAOENB@reason?$AA@ ; "reason"
		call	dword ptr ds:__imp__perror
		add	esp, 14h
		xor	eax, eax
		jmp	loc_39A0
; ---------------------------------------------------------------------------

loc_385C:				; CODE XREF: _rotate_index+13Ej
					; _rotate_index+145j ...
		lea	eax, [esp+518h+ExistingFileName]
		push	esi		; lpNewFileName
		push	eax		; lpExistingFileName
		call	_WIN32_rename
		add	esp, 8
		test	eax, eax
		jns	short loc_38A7
		push	esi
		lea	eax, [esp+51Ch+ExistingFileName]
		push	eax
		push	offset ??_C@_0BL@PJHGPAJJ@unable?5to?5rename?5?$CFs?5to?5?$CFs?6?$AA@ ;	"unable	to rename %s to	%s\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		push	offset ??_C@_06CEHAOENB@reason?$AA@ ; "reason"
		call	dword ptr ds:__imp__perror
		lea	eax, [esp+52Ch+NewFileName]
		push	esi		; lpNewFileName
		push	eax		; lpExistingFileName
		call	_WIN32_rename
		add	esp, 1Ch
		xor	eax, eax
		jmp	loc_39A0
; ---------------------------------------------------------------------------

loc_38A7:				; CODE XREF: _rotate_index+18Cj
		lea	eax, [esp+518h+var_204]
		push	eax		; lpNewFileName
		lea	eax, [esp+51Ch+var_104]
		push	eax		; lpExistingFileName
		call	_WIN32_rename
		add	esp, 8
		test	eax, eax
		jns	short loc_391F
		call	edi ; __imp___errno
		cmp	dword ptr [eax], 2
		jz	short loc_391F
		call	edi ; __imp___errno
		cmp	dword ptr [eax], 14h
		jz	short loc_391F
		lea	eax, [esp+518h+var_204]
		push	eax
		lea	eax, [esp+51Ch+var_104]
		push	eax
		push	offset ??_C@_0BL@PJHGPAJJ@unable?5to?5rename?5?$CFs?5to?5?$CFs?6?$AA@ ;	"unable	to rename %s to	%s\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		push	offset ??_C@_06CEHAOENB@reason?$AA@ ; "reason"
		call	dword ptr ds:__imp__perror
		lea	eax, [esp+52Ch+ExistingFileName]
		push	eax		; lpNewFileName
		push	esi		; lpExistingFileName
		call	_WIN32_rename
		lea	eax, [esp+534h+NewFileName]
		push	esi		; lpNewFileName
		push	eax		; lpExistingFileName
		call	_WIN32_rename
		add	esp, 24h
		xor	eax, eax
		jmp	loc_39A0
; ---------------------------------------------------------------------------

loc_391F:				; CODE XREF: _rotate_index+1E1j
					; _rotate_index+1E8j ...
		lea	eax, [esp+518h+var_104]
		push	eax		; lpNewFileName
		lea	eax, [esp+51Ch+var_304]
		push	eax		; lpExistingFileName
		call	_WIN32_rename
		add	esp, 8
		test	eax, eax
		jns	short loc_399B
		lea	eax, [esp+518h+var_104]
		push	eax
		lea	eax, [esp+51Ch+var_304]
		push	eax
		push	offset ??_C@_0BL@PJHGPAJJ@unable?5to?5rename?5?$CFs?5to?5?$CFs?6?$AA@ ;	"unable	to rename %s to	%s\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		push	offset ??_C@_06CEHAOENB@reason?$AA@ ; "reason"
		call	dword ptr ds:__imp__perror
		lea	eax, [esp+52Ch+var_104]
		push	eax		; lpNewFileName
		lea	eax, [esp+530h+var_204]
		push	eax		; lpExistingFileName
		call	_WIN32_rename
		lea	eax, [esp+534h+ExistingFileName]
		push	eax		; lpNewFileName
		push	esi		; lpExistingFileName
		call	_WIN32_rename
		lea	eax, [esp+53Ch+NewFileName]
		push	esi		; lpNewFileName
		push	eax		; lpExistingFileName
		call	_WIN32_rename
		add	esp, 2Ch

$err$14:
		xor	eax, eax
		jmp	short loc_39A0
; ---------------------------------------------------------------------------

loc_399B:				; CODE XREF: _rotate_index+259j
		mov	eax, 1

loc_39A0:				; CODE XREF: _rotate_index+A4j
					; _rotate_index+177j ...
		mov	ecx, [esp+518h+var_4]
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 508h
		retn
_rotate_index	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 39BCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl rotate_serial(LPCSTR lpExistingFileName, int, int)
		public _rotate_serial
_rotate_serial	proc near

var_508		= dword	ptr -508h
ExistingFileName= byte ptr -504h
NewFileName	= byte ptr -404h
var_4		= dword	ptr -4
lpExistingFileName= dword ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 508h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+508h+var_4], eax
		push	ebx
		mov	ebx, [esp+50Ch+arg_8]
		push	ebp
		mov	ebp, [esp+510h+arg_4]
		push	esi
		mov	esi, [esp+514h+lpExistingFileName]
		mov	ecx, esi
		push	edi
		lea	edx, [ecx+1]

loc_39F2:				; CODE XREF: _rotate_serial+3Bj
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_39F2
		sub	ecx, edx
		mov	edx, ebx
		lea	edi, [edx+1]

loc_3A00:				; CODE XREF: _rotate_serial+49j
		mov	al, [edx]
		inc	edx
		test	al, al
		jnz	short loc_3A00
		sub	edx, edi
		lea	eax, [edx+ecx]
		mov	ecx, esi
		mov	[esp+518h+var_508], eax
		lea	edx, [ecx+1]
		nop	dword ptr [eax+00000000h]

loc_3A1C:				; CODE XREF: _rotate_serial+65j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_3A1C
		sub	ecx, edx
		mov	edx, ebp
		lea	edi, [edx+1]
		xchg	ax, ax

loc_3A2C:				; CODE XREF: _rotate_serial+75j
		mov	al, [edx]
		inc	edx
		test	al, al
		jnz	short loc_3A2C
		sub	edx, edi
		lea	eax, [edx+ecx]
		cmp	[esp+518h+var_508], eax
		cmovg	eax, [esp+518h+var_508]
		inc	eax
		cmp	eax, 100h
		jl	short loc_3A63
		push	offset ??_C@_0BE@PGHNBIGG@file?5name?5too?5long?6?$AA@ ; "file name too	long\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 8
		xor	eax, eax
		jmp	loc_3B33
; ---------------------------------------------------------------------------

loc_3A63:				; CODE XREF: _rotate_serial+8Bj
		push	ebp
		push	esi
		push	offset ??_C@_05NNFHCGPF@?$CFs?4?$CFs?$AA@ ; "%s.%s"
		lea	eax, [esp+524h+ExistingFileName]
		push	100h
		push	eax
		call	_BIO_snprintf
		push	ebx
		push	esi
		push	offset ??_C@_05NNFHCGPF@?$CFs?4?$CFs?$AA@ ; "%s.%s"
		lea	eax, [esp+538h+NewFileName]
		push	100h
		push	eax
		call	_BIO_snprintf
		lea	eax, [esp+540h+NewFileName]
		push	eax		; lpNewFileName
		push	esi		; lpExistingFileName
		call	_WIN32_rename
		add	esp, 30h
		test	eax, eax
		jns	short loc_3AE6
		mov	edi, dword ptr ds:__imp___errno
		call	edi ; __imp___errno
		cmp	dword ptr [eax], 2
		jz	short loc_3AE6
		call	edi ; __imp___errno
		cmp	dword ptr [eax], 14h
		jz	short loc_3AE6
		lea	eax, [esp+518h+NewFileName]
		push	eax
		push	esi
		push	offset ??_C@_0BL@PJHGPAJJ@unable?5to?5rename?5?$CFs?5to?5?$CFs?6?$AA@ ;	"unable	to rename %s to	%s\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		push	offset ??_C@_06CEHAOENB@reason?$AA@ ; "reason"
		call	dword ptr ds:__imp__perror
		add	esp, 14h
		xor	eax, eax
		jmp	short loc_3B33
; ---------------------------------------------------------------------------

loc_3AE6:				; CODE XREF: _rotate_serial+E9j
					; _rotate_serial+F6j ...
		lea	eax, [esp+518h+ExistingFileName]
		push	esi		; lpNewFileName
		push	eax		; lpExistingFileName
		call	_WIN32_rename
		add	esp, 8
		test	eax, eax
		jns	short loc_3B2E
		push	esi
		lea	eax, [esp+51Ch+ExistingFileName]
		push	eax
		push	offset ??_C@_0BL@PJHGPAJJ@unable?5to?5rename?5?$CFs?5to?5?$CFs?6?$AA@ ;	"unable	to rename %s to	%s\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		push	offset ??_C@_06CEHAOENB@reason?$AA@ ; "reason"
		call	dword ptr ds:__imp__perror
		lea	eax, [esp+52Ch+NewFileName]
		push	esi		; lpNewFileName
		push	eax		; lpExistingFileName
		call	_WIN32_rename
		add	esp, 1Ch

$err$12:
		xor	eax, eax
		jmp	short loc_3B33
; ---------------------------------------------------------------------------

loc_3B2E:				; CODE XREF: _rotate_serial+13Aj
		mov	eax, 1

loc_3B33:				; CODE XREF: _rotate_serial+A2j
					; _rotate_serial+128j ...
		mov	ecx, [esp+518h+var_4]
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 508h
		retn
_rotate_serial	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3B4Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl save_index(char *ErrMsg, int, int)
		public _save_index
_save_index	proc near

var_308		= dword	ptr -308h
var_304		= byte ptr -304h
var_204		= byte ptr -204h
var_104		= byte ptr -104h
var_4		= dword	ptr -4
ErrMsg		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 308h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+308h+var_4], eax
		push	ebx
		mov	ebx, [esp+30Ch+arg_8]
		push	ebp
		mov	ebp, [esp+310h+arg_4]
		push	esi
		mov	esi, [esp+314h+ErrMsg]
		push	edi
		call	_BIO_s_file
		push	eax
		call	_BIO_new
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jnz	short loc_3BBA
		push	dword ptr ds:_bio_err
		call	_ERR_print_errors
		add	esp, 4

$err$12_0:				; CODE XREF: _save_index+AFj
					; _save_index+129j ...
		xor	eax, eax

loc_3BA1:				; CODE XREF: _save_index+1B0j
		mov	ecx, [esp+318h+var_4]
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 308h
		retn
; ---------------------------------------------------------------------------

loc_3BBA:				; CODE XREF: _save_index+43j
		mov	ecx, esi
		lea	edx, [ecx+1]

loc_3BBF:				; CODE XREF: _save_index+78j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_3BBF
		sub	ecx, edx
		mov	edx, ebp
		lea	eax, [edx+1]
		mov	[esp+318h+var_308], eax

loc_3BD1:				; CODE XREF: _save_index+8Aj
		mov	al, [edx]
		inc	edx
		test	al, al
		jnz	short loc_3BD1
		sub	edx, [esp+318h+var_308]
		lea	eax, [ecx+6]
		add	eax, edx
		cmp	eax, 100h
		jl	short loc_3BFD
		push	offset ??_C@_0BE@PGHNBIGG@file?5name?5too?5long?6?$AA@ ; "file name too	long\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 8
		jmp	short $err$12_0
; ---------------------------------------------------------------------------

loc_3BFD:				; CODE XREF: _save_index+9Aj
		push	esi
		push	offset ??_C@_07MFJDFAJK@?$CFs?4attr?$AA@ ; "%s.attr"
		lea	eax, [esp+320h+var_104]
		push	100h
		push	eax
		call	_BIO_snprintf
		push	ebp
		push	esi
		push	offset ??_C@_0L@FJEANEHK@?$CFs?4attr?4?$CFs?$AA@ ; "%s.attr.%s"
		lea	eax, [esp+334h+var_204]
		push	100h
		push	eax
		call	_BIO_snprintf
		push	ebp
		push	esi
		push	offset ??_C@_05NNFHCGPF@?$CFs?4?$CFs?$AA@ ; "%s.%s"
		lea	eax, [esp+348h+var_304]
		push	100h
		push	eax
		call	_BIO_snprintf
		lea	eax, [esp+350h+var_304]
		push	eax
		push	5
		push	6Ch ; 'l'
		push	edi
		call	_BIO_ctrl
		add	esp, 48h
		test	eax, eax
		jg	short loc_3C7A
		push	esi		; ErrMsg
		call	dword ptr ds:__imp__perror
		push	esi

loc_3C62:				; CODE XREF: _save_index+184j
		push	offset ??_C@_0BF@BIGLPGDL@unable?5to?5open?5?8?$CFs?8?6?$AA@ ; "unable to open '%s'\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 10h
		jmp	$err$12_0
; ---------------------------------------------------------------------------

loc_3C7A:				; CODE XREF: _save_index+10Cj
		push	dword ptr [ebx+4]
		push	edi
		call	_TXT_DB_write
		add	esp, 8
		test	eax, eax
		jle	$err$12_0
		push	edi
		call	_BIO_free
		call	_BIO_s_file
		push	eax
		call	_BIO_new
		mov	esi, eax
		lea	eax, [esp+320h+var_204]
		push	eax
		push	5
		push	6Ch ; 'l'
		push	esi
		call	_BIO_ctrl
		add	esp, 18h
		test	eax, eax
		jg	short loc_3CD2
		lea	eax, [esp+318h+var_104]
		push	eax		; ErrMsg
		call	dword ptr ds:__imp__perror
		lea	eax, [esp+31Ch+var_104]
		push	eax
		jmp	short loc_3C62
; ---------------------------------------------------------------------------

loc_3CD2:				; CODE XREF: _save_index+16Cj
		cmp	dword ptr [ebx], 0
		mov	ecx, offset ??_C@_02KAJCLHKP@no?$AA@ ; `string'
		mov	eax, offset ??_C@_03ICICOMAL@yes?$AA@ ;	`string'
		cmovz	eax, ecx
		push	eax
		push	offset ??_C@_0BF@HNOOHBO@unique_subject?5?$DN?5?$CFs?6?$AA@ ; "unique_subject =	%s\n"
		push	esi
		call	_BIO_printf
		push	esi
		call	_BIO_free
		add	esp, 10h
		mov	eax, 1
		jmp	loc_3BA1
_save_index	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3D04h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl save_serial(char *ErrMsg,	int, int, int)
		public _save_serial
_save_serial	proc near

var_110		= dword	ptr -110h
var_10C		= dword	ptr -10Ch
var_108		= dword	ptr -108h
var_104		= byte ptr -104h
var_4		= dword	ptr -4
ErrMsg		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, 110h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+110h+var_4], eax
		mov	eax, [esp+110h+arg_8]
		push	ebx
		push	ebp
		mov	ebp, [esp+118h+ErrMsg]
		xor	ebx, ebx
		push	esi
		mov	esi, [esp+11Ch+arg_4]
		mov	ecx, ebp
		push	edi
		mov	[esp+120h+var_10C], eax
		xor	edi, edi
		mov	eax, [esp+120h+arg_C]
		mov	[esp+120h+var_108], eax
		lea	edx, [ecx+1]
		test	esi, esi
		jnz	short loc_3D64
		nop	dword ptr [eax]

loc_3D54:				; CODE XREF: _save_serial+55j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_3D54
		sub	ecx, edx
		jmp	short loc_3D84
; ---------------------------------------------------------------------------
		db 0Fh,	1Fh, 44h, 2 dup(0)
; ---------------------------------------------------------------------------

loc_3D64:				; CODE XREF: _save_serial+4Bj
					; _save_serial+65j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_3D64
		sub	ecx, edx
		mov	edx, esi
		lea	eax, [edx+1]
		mov	[esp+120h+var_110], eax

loc_3D76:				; CODE XREF: _save_serial+77j
		mov	al, [edx]
		inc	edx
		test	al, al
		jnz	short loc_3D76
		sub	edx, [esp+120h+var_110]
		inc	ecx
		add	ecx, edx

loc_3D84:				; CODE XREF: _save_serial+59j
		cmp	ecx, 100h
		jl	short loc_3DA4
		push	offset ??_C@_0BE@PGHNBIGG@file?5name?5too?5long?6?$AA@ ; "file name too	long\n"
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 8
		jmp	loc_3E7D
; ---------------------------------------------------------------------------

loc_3DA4:				; CODE XREF: _save_serial+86j
		lea	eax, [esp+120h+var_104]
		test	esi, esi
		jnz	short loc_3DBD
		push	100h
		push	ebp
		push	eax
		call	_BUF_strlcpy
		add	esp, 0Ch
		jmp	short loc_3DD2
; ---------------------------------------------------------------------------

loc_3DBD:				; CODE XREF: _save_serial+A6j
		push	esi
		push	ebp
		push	offset ??_C@_05NNFHCGPF@?$CFs?4?$CFs?$AA@ ; "%s.%s"
		push	100h
		push	eax
		call	_BIO_snprintf
		add	esp, 14h

loc_3DD2:				; CODE XREF: _save_serial+B7j
		call	_BIO_s_file
		push	eax
		call	_BIO_new
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jnz	short loc_3DF6
		push	dword ptr ds:_bio_err
		call	_ERR_print_errors
		jmp	loc_3E7A
; ---------------------------------------------------------------------------

loc_3DF6:				; CODE XREF: _save_serial+E0j
		lea	eax, [esp+120h+var_104]
		push	eax
		push	5
		push	6Ch ; 'l'
		push	esi
		call	_BIO_ctrl
		add	esp, 10h
		test	eax, eax
		jg	short loc_3E18
		push	ebp		; ErrMsg
		call	dword ptr ds:__imp__perror
		add	esp, 4
		jmp	short $err$20
; ---------------------------------------------------------------------------

loc_3E18:				; CODE XREF: _save_serial+106j
		push	0
		push	[esp+124h+var_10C]
		call	_BN_to_ASN1_INTEGER
		mov	edi, eax
		add	esp, 8
		test	edi, edi
		jnz	short loc_3E41
		push	offset ??_C@_0CJ@OGFINJBE@error?5converting?5serial?5to?5ASN?41@ ; "error converting serial to ASN.1 format"...
		push	dword ptr ds:_bio_err
		call	_BIO_printf
		add	esp, 8
		jmp	short $err$20
; ---------------------------------------------------------------------------

loc_3E41:				; CODE XREF: _save_serial+126j
		push	edi
		push	esi
		call	_i2a_ASN1_INTEGER
		push	offset ??_C@_01EEMJAFIK@?6?$AA@	; `string'
		push	esi
		call	_BIO_puts
		mov	eax, [esp+130h+var_108]
		add	esp, 10h
		mov	ebx, 1
		test	eax, eax
		jz	short $err$20
		mov	[eax], edi
		xor	edi, edi

$err$20:				; CODE XREF: _save_serial+112j
					; _save_serial+13Bj ...
		push	esi
		call	_BIO_free_all
		add	esp, 4
		test	edi, edi
		jz	short loc_3E7D
		push	edi
		call	_ASN1_INTEGER_free

loc_3E7A:				; CODE XREF: _save_serial+EDj
		add	esp, 4

loc_3E7D:				; CODE XREF: _save_serial+9Bj
					; _save_serial+16Ej
		mov	ecx, [esp+120h+var_4]
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 110h
		retn
_save_serial	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3E98h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _set_cert_ex
_set_cert_ex	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	offset ?cert_tbl@?1??set_cert_ex@@9@9 ;	`set_cert_ex'::`2'::cert_tbl
		push	[esp+4+arg_4]
		push	[esp+8+arg_0]
		call	_set_multi_opts
		add	esp, 0Ch
		retn
_set_cert_ex	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3EB0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl set_ext_copy(int,	char *Str1)
		public _set_ext_copy
_set_ext_copy	proc near

arg_0		= dword	ptr  4
Str1		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+Str1]
		push	edi
		mov	edi, dword ptr ds:__imp___stricmp
		push	offset ??_C@_04CGFJFPFD@none?$AA@ ; "none"
		push	esi		; Str1
		call	edi ; __imp___stricmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_3EDD
		mov	eax, [esp+8+arg_0]
		pop	edi
		pop	esi
		mov	dword ptr [eax], 0
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_3EDD:				; CODE XREF: _set_ext_copy+19j
		push	offset ??_C@_04COAGEIMF@copy?$AA@ ; "copy"
		push	esi		; Str1
		call	edi ; __imp___stricmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_3EFE
		mov	eax, [esp+8+arg_0]
		pop	edi
		pop	esi
		mov	dword ptr [eax], 1
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_3EFE:				; CODE XREF: _set_ext_copy+3Aj
		push	offset ??_C@_07ENLILCDE@copyall?$AA@ ; "copyall"
		push	esi		; Str1
		call	edi ; __imp___stricmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_3F1F
		mov	eax, [esp+8+arg_0]
		pop	edi
		pop	esi
		mov	dword ptr [eax], 2
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_3F1F:				; CODE XREF: _set_ext_copy+5Bj
		pop	edi
		xor	eax, eax
		pop	esi
		retn
_set_ext_copy	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3F24h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_set_multi_opts	proc near		; CODE XREF: _set_cert_ex+Dp
					; _set_name_ex+Fp

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 4
		call	__chkstk
		mov	eax, [esp+4+arg_4]
		push	esi
		mov	esi, 1
		mov	[esp+8+var_4], esi
		test	eax, eax
		jnz	short loc_3F43
		pop	esi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_3F43:				; CODE XREF: _set_multi_opts+1Aj
		push	ebx
		push	ebp
		push	eax
		call	_X509V3_parse_list
		mov	ebx, eax
		xor	ebp, ebp
		push	ebx
		mov	[esp+18h+arg_4], ebx
		call	_sk_num
		add	esp, 8
		test	eax, eax
		jle	short loc_3FC5
		push	edi
		nop	dword ptr [eax]

loc_3F64:				; CODE XREF: _set_multi_opts+9Ej
		push	ebp
		push	ebx
		call	_sk_value
		add	esp, 8
		mov	edi, [eax+4]
		mov	al, [edi]
		cmp	al, 2Dh	; '-'
		jnz	short loc_3F7B
		xor	bl, bl
		jmp	short loc_3F81
; ---------------------------------------------------------------------------

loc_3F7B:				; CODE XREF: _set_multi_opts+51j
		mov	bl, 1
		cmp	al, 2Bh	; '+'
		jnz	short loc_3F82

loc_3F81:				; CODE XREF: _set_multi_opts+55j
		inc	edi

loc_3F82:				; CODE XREF: _set_multi_opts+5Bj
		mov	eax, [esp+14h+arg_8]
		mov	esi, eax
		cmp	dword ptr [eax], 0
		jz	short loc_3FAC
		nop	dword ptr [eax+00000000h]

loc_3F94:				; CODE XREF: _set_multi_opts+86j
		push	dword ptr [esi]	; Str2
		push	edi		; Str1
		call	dword ptr ds:__imp___stricmp
		add	esp, 8
		test	eax, eax
		jz	short loc_3FDA
		add	esi, 0Ch
		cmp	dword ptr [esi], 0
		jnz	short loc_3F94

loc_3FAC:				; CODE XREF: _set_multi_opts+67j
		xor	esi, esi
		mov	[esp+14h+var_4], esi

loc_3FB2:				; CODE XREF: _set_multi_opts+D2j
					; _set_multi_opts+DAj
		mov	ebx, [esp+14h+arg_4]
		inc	ebp
		push	ebx
		call	_sk_num
		add	esp, 4
		cmp	ebp, eax
		jl	short loc_3F64
		pop	edi

loc_3FC5:				; CODE XREF: _set_multi_opts+3Aj
		push	offset _X509V3_conf_free
		push	ebx
		call	_sk_pop_free
		add	esp, 8
		mov	eax, esi
		pop	ebp
		pop	ebx
		pop	esi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_3FDA:				; CODE XREF: _set_multi_opts+7Ej
		mov	eax, [esi+8]
		mov	edx, [esp+14h+arg_0]
		not	eax
		and	[edx], eax
		mov	eax, [esi+4]
		mov	ecx, [edx]
		mov	esi, [esp+14h+var_4]
		test	bl, bl
		jz	short loc_3FF8
		or	eax, ecx
		mov	[edx], eax
		jmp	short loc_3FB2
; ---------------------------------------------------------------------------

loc_3FF8:				; CODE XREF: _set_multi_opts+CCj
		not	eax
		and	eax, ecx
		mov	[edx], eax
		jmp	short loc_3FB2
_set_multi_opts	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4000h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _set_name_ex
_set_name_ex	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		push	offset ?ex_tbl@?1??set_name_ex@@9@9 ; `set_name_ex'::`2'::ex_tbl
		push	[esp+8+arg_4]
		push	esi
		call	_set_multi_opts
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_401D
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_401D:				; CODE XREF: _set_name_ex+19j
		mov	eax, [esi]
		test	eax, 0F0000h
		jnz	short loc_402D
		or	eax, 20000h
		mov	[esi], eax

loc_402D:				; CODE XREF: _set_name_ex+24j
		mov	eax, 1
		pop	esi
		retn
_set_name_ex	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4034h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl set_table_opts(int, char *Str1, int)
_set_table_opts	proc near

arg_0		= dword	ptr  4
Str1		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	edi, [esp+10h+Str1]
		mov	al, [edi]
		cmp	al, 2Dh	; '-'
		jnz	short loc_4046
		xor	bl, bl
		jmp	short loc_404C
; ---------------------------------------------------------------------------

loc_4046:				; CODE XREF: _set_table_opts+Cj
		mov	bl, 1
		cmp	al, 2Bh	; '+'
		jnz	short loc_404D

loc_404C:				; CODE XREF: _set_table_opts+10j
		inc	edi

loc_404D:				; CODE XREF: _set_table_opts+16j
		mov	esi, [esp+10h+arg_8]
		cmp	dword ptr [esi], 0
		jz	short loc_4070
		mov	ebp, dword ptr ds:__imp___stricmp

loc_405C:				; CODE XREF: _set_table_opts+3Aj
		push	dword ptr [esi]	; Str2
		push	edi		; Str1
		call	ebp ; __imp___stricmp
		add	esp, 8
		test	eax, eax
		jz	short loc_4077
		add	esi, 0Ch
		cmp	dword ptr [esi], 0
		jnz	short loc_405C

loc_4070:				; CODE XREF: _set_table_opts+20j
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_4077:				; CODE XREF: _set_table_opts+32j
		mov	ecx, [esp+10h+arg_0]
		mov	eax, [esi+8]
		not	eax
		and	[ecx], eax
		mov	edx, [ecx]
		mov	eax, [esi+4]
		test	bl, bl
		jz	short loc_4099
		pop	edi
		pop	esi
		or	eax, edx
		pop	ebp
		mov	[ecx], eax
		mov	eax, 1
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_4099:				; CODE XREF: _set_table_opts+55j
		pop	edi
		not	eax
		pop	esi
		and	eax, edx
		pop	ebp
		mov	[ecx], eax
		mov	eax, 1
		pop	ebx
		retn
_set_table_opts	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 40ACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _setup_engine
_setup_engine	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		mov	ebx, [esp+4+arg_4]
		push	esi
		xor	esi, esi
		push	edi
		test	ebx, ebx
		jz	loc_41C6
		mov	ecx, offset ??_C@_04HAPDLBFF@auto?$AA@ ; "auto"
		mov	eax, ebx

loc_40C4:				; CODE XREF: _setup_engine+32j
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_40E4
		test	dl, dl
		jz	short loc_40E0
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_40E4
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_40C4

loc_40E0:				; CODE XREF: _setup_engine+20j
		xor	eax, eax
		jmp	short loc_40E9
; ---------------------------------------------------------------------------

loc_40E4:				; CODE XREF: _setup_engine+1Cj
					; _setup_engine+28j
		sbb	eax, eax
		or	eax, 1

loc_40E9:				; CODE XREF: _setup_engine+36j
		test	eax, eax
		jnz	short loc_4109
		push	offset ??_C@_0BO@GLIGNJMA@enabling?5auto?5ENGINE?5support?6?$AA@ ; "enabling auto ENGINE support\n"
		push	[esp+10h+arg_0]
		call	_BIO_printf
		add	esp, 8
		call	_ENGINE_register_all_complete
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_4109:				; CODE XREF: _setup_engine+3Fj
		push	ebx
		call	_ENGINE_by_id
		mov	edi, [esp+10h+arg_0]
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jnz	short loc_414B
		push	[esp+0Ch+arg_8]
		push	ebx
		push	edi
		call	_try_load_engine
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jnz	short loc_414B
		push	ebx
		push	offset ??_C@_0BF@FDAJFBF@invalid?5engine?5?$CC?$CFs?$CC?6?$AA@ ; "invalid engine \"%s\"\n"
		push	edi
		call	_BIO_printf
		push	edi
		call	_ERR_print_errors
		add	esp, 10h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_414B:				; CODE XREF: _setup_engine+6Ej
					; _setup_engine+82j
		cmp	[esp+0Ch+arg_8], 0
		jz	short loc_4162
		push	0
		push	edi
		push	0
		push	1
		push	esi
		call	_ENGINE_ctrl
		add	esp, 14h

loc_4162:				; CODE XREF: _setup_engine+A4j
		push	1
		push	0
		push	ds:_ui_method
		push	0
		push	offset ??_C@_0BD@HNMPJJDL@SET_USER_INTERFACE?$AA@ ; "SET_USER_INTERFACE"
		push	esi
		call	_ENGINE_ctrl_cmd
		push	0FFFFh
		push	esi
		call	_ENGINE_set_default
		add	esp, 20h
		test	eax, eax
		jnz	short loc_41AB
		push	offset ??_C@_0BH@OBPKDCDO@can?8t?5use?5that?5engine?6?$AA@ ; "can't use that engine\n"
		push	edi
		call	_BIO_printf
		push	edi
		call	_ERR_print_errors
		push	esi
		call	_ENGINE_free
		add	esp, 10h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_41AB:				; CODE XREF: _setup_engine+DDj
		push	esi
		call	_ENGINE_get_id
		push	eax
		push	offset ??_C@_0BC@CPAKBHCD@engine?5?$CC?$CFs?$CC?5set?4?6?$AA@ ;	"engine	\"%s\" set.\n"
		push	edi
		call	_BIO_printf
		push	esi
		call	_ENGINE_free
		add	esp, 14h

loc_41C6:				; CODE XREF: _setup_engine+Bj
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebx
		retn
_setup_engine	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 41CCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _setup_ui_method
_setup_ui_method proc near
		push	offset ??_C@_0CD@HINDFPHK@OpenSSL?5application?5user?5interfa@ ; "OpenSSL application user interface"
		call	_UI_create_method
		push	offset _ui_open
		push	eax
		mov	ds:_ui_method, eax
		call	_UI_method_set_opener
		push	offset _ui_read
		push	ds:_ui_method
		call	_UI_method_set_reader
		push	offset _ui_write
		push	ds:_ui_method
		call	_UI_method_set_writer
		push	offset _ui_close
		push	ds:_ui_method
		call	_UI_method_set_closer
		add	esp, 24h
		xor	eax, eax
		retn
_setup_ui_method endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 421Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _setup_verify
_setup_verify	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		push	edi
		call	_X509_STORE_new
		mov	esi, eax
		test	esi, esi
		jz	short $end$14
		call	_X509_LOOKUP_file
		push	eax
		push	esi
		call	_X509_STORE_add_lookup
		add	esp, 8
		test	eax, eax
		jz	short $end$14
		mov	edi, [esp+8+arg_4]
		push	0
		test	edi, edi
		jz	short loc_4278
		push	1
		push	edi
		push	1
		push	eax
		call	_X509_LOOKUP_ctrl
		add	esp, 14h
		test	eax, eax
		jnz	short loc_4287
		push	edi
		push	offset ??_C@_0BH@FHLAEOCH@Error?5loading?5file?5?$CFs?6?$AA@ ; "Error loading file %s\n"

loc_425E:				; CODE XREF: _setup_verify+A0j
		push	[esp+10h+arg_0]
		call	_BIO_printf
		add	esp, 0Ch

$end$14:				; CODE XREF: _setup_verify+Bj
					; _setup_verify+1Ej ...
		push	esi
		call	_X509_STORE_free
		add	esp, 4
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_4278:				; CODE XREF: _setup_verify+28j
		push	3
		push	0
		push	1
		push	eax
		call	_X509_LOOKUP_ctrl
		add	esp, 14h

loc_4287:				; CODE XREF: _setup_verify+3Aj
		call	_X509_LOOKUP_hash_dir
		push	eax
		push	esi
		call	_X509_STORE_add_lookup
		add	esp, 8
		test	eax, eax
		jz	short $end$14
		mov	edi, [esp+8+arg_8]
		push	0
		test	edi, edi
		jz	short loc_42BE
		push	1
		push	edi
		push	2
		push	eax
		call	_X509_LOOKUP_ctrl
		add	esp, 14h
		test	eax, eax
		jnz	short loc_42CD
		push	edi
		push	offset ??_C@_0BM@OKGFCOK@Error?5loading?5directory?5?$CFs?6?$AA@ ; "Error loading directory %s\n"
		jmp	short loc_425E
; ---------------------------------------------------------------------------

loc_42BE:				; CODE XREF: _setup_verify+86j
		push	3
		push	0
		push	2
		push	eax
		call	_X509_LOOKUP_ctrl
		add	esp, 14h

loc_42CD:				; CODE XREF: _setup_verify+98j
		call	_ERR_clear_error
		pop	edi
		mov	eax, esi
		pop	esi
		retn
_setup_verify	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 42D8h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int sscanf(const char	*Src, const char *Format, ...)
		public _sscanf
_sscanf		proc near		; CODE XREF: _args_verify+21Bp

Src		= dword	ptr  4
Format		= dword	ptr  8
arg_8		= byte ptr  0Ch

		lea	eax, [esp+arg_8]
		push	eax
		push	0
		push	[esp+8+Format]
		push	0FFFFFFFFh
		push	[esp+10h+Src]
		call	___local_stdio_scanf_options
		push	dword ptr [eax+4]
		push	dword ptr [eax]
		call	dword ptr ds:__imp____stdio_common_vsscanf
		add	esp, 1Ch
		retn
_sscanf		endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4300h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _store_setup_crl_download
_store_setup_crl_download proc near

arg_0		= dword	ptr  4

		push	offset _crls_http_cb
		push	[esp+4+arg_0]
		call	_X509_STORE_set_lookup_crls_cb
		add	esp, 8
		retn
_store_setup_crl_download endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4314h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _str2fmt
_str2fmt	proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jnz	short loc_4321
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_4321:				; CODE XREF: _str2fmt+7j
		mov	al, [esi]
		cmp	al, 44h	; 'D'
		jz	loc_44B1
		cmp	al, 64h	; 'd'
		jz	loc_44B1
		cmp	al, 54h	; 'T'
		jz	loc_44AA
		cmp	al, 74h	; 't'
		jz	loc_44AA
		cmp	al, 4Eh	; 'N'
		jz	loc_44A3
		cmp	al, 6Eh	; 'n'
		jz	loc_44A3
		cmp	al, 53h	; 'S'
		jz	loc_449C
		cmp	al, 73h	; 's'
		jz	loc_449C
		cmp	al, 4Dh	; 'M'
		jz	loc_4495
		cmp	al, 6Dh	; 'm'
		jz	loc_4495
		push	ebx
		cmp	al, 31h	; '1'
		jz	loc_448D
		mov	edx, offset ??_C@_06CKOLGKJK@PKCS12?$AA@ ; "PKCS12"
		mov	ecx, esi
		nop

loc_4384:				; CODE XREF: _str2fmt+8Aj
		mov	bl, [ecx]
		cmp	bl, [edx]
		jnz	short loc_43A4
		test	bl, bl
		jz	short loc_43A0
		mov	bl, [ecx+1]
		cmp	bl, [edx+1]
		jnz	short loc_43A4
		add	ecx, 2
		add	edx, 2
		test	bl, bl
		jnz	short loc_4384

loc_43A0:				; CODE XREF: _str2fmt+78j
		xor	ecx, ecx
		jmp	short loc_43A9
; ---------------------------------------------------------------------------

loc_43A4:				; CODE XREF: _str2fmt+74j _str2fmt+80j
		sbb	ecx, ecx
		or	ecx, 1

loc_43A9:				; CODE XREF: _str2fmt+8Ej
		test	ecx, ecx
		jz	loc_448D
		mov	edx, offset ??_C@_06IDAJNGAK@pkcs12?$AA@ ; "pkcs12"
		mov	ecx, esi

loc_43B8:				; CODE XREF: _str2fmt+BEj
		mov	bl, [ecx]
		cmp	bl, [edx]
		jnz	short loc_43D8
		test	bl, bl
		jz	short loc_43D4
		mov	bl, [ecx+1]
		cmp	bl, [edx+1]
		jnz	short loc_43D8
		add	ecx, 2
		add	edx, 2
		test	bl, bl
		jnz	short loc_43B8

loc_43D4:				; CODE XREF: _str2fmt+ACj
		xor	ecx, ecx
		jmp	short loc_43DD
; ---------------------------------------------------------------------------

loc_43D8:				; CODE XREF: _str2fmt+A8j _str2fmt+B4j
		sbb	ecx, ecx
		or	ecx, 1

loc_43DD:				; CODE XREF: _str2fmt+C2j
		test	ecx, ecx
		jz	loc_448D
		mov	edx, offset ??_C@_03NNGPPEJH@P12?$AA@ ;	`string'
		mov	ecx, esi

loc_43EC:				; CODE XREF: _str2fmt+F2j
		mov	bl, [ecx]
		cmp	bl, [edx]
		jnz	short loc_440C
		test	bl, bl
		jz	short loc_4408
		mov	bl, [ecx+1]
		cmp	bl, [edx+1]
		jnz	short loc_440C
		add	ecx, 2
		add	edx, 2
		test	bl, bl
		jnz	short loc_43EC

loc_4408:				; CODE XREF: _str2fmt+E0j
		xor	ecx, ecx
		jmp	short loc_4411
; ---------------------------------------------------------------------------

loc_440C:				; CODE XREF: _str2fmt+DCj _str2fmt+E8j
		sbb	ecx, ecx
		or	ecx, 1

loc_4411:				; CODE XREF: _str2fmt+F6j
		test	ecx, ecx
		jz	short loc_448D
		mov	edx, offset ??_C@_03HNFNFLKJ@p12?$AA@ ;	`string'
		mov	ecx, esi

loc_441C:				; CODE XREF: _str2fmt+122j
		mov	bl, [ecx]
		cmp	bl, [edx]
		jnz	short loc_443C
		test	bl, bl
		jz	short loc_4438
		mov	bl, [ecx+1]
		cmp	bl, [edx+1]
		jnz	short loc_443C
		add	ecx, 2
		add	edx, 2
		test	bl, bl
		jnz	short loc_441C

loc_4438:				; CODE XREF: _str2fmt+110j
		xor	ecx, ecx
		jmp	short loc_4441
; ---------------------------------------------------------------------------

loc_443C:				; CODE XREF: _str2fmt+10Cj
					; _str2fmt+118j
		sbb	ecx, ecx
		or	ecx, 1

loc_4441:				; CODE XREF: _str2fmt+126j
		test	ecx, ecx
		jz	short loc_448D
		cmp	al, 45h	; 'E'
		jz	short loc_4485
		cmp	al, 65h	; 'e'
		jz	short loc_4485
		cmp	al, 48h	; 'H'
		jz	short loc_447D
		cmp	al, 68h	; 'h'
		jz	short loc_447D
		cmp	al, 50h	; 'P'
		jz	short loc_4462
		cmp	al, 70h	; 'p'
		jz	short loc_4462
		pop	ebx
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_4462:				; CODE XREF: _str2fmt+143j
					; _str2fmt+147j
		mov	al, [esi+1]
		cmp	al, 56h	; 'V'
		jz	short loc_4475
		cmp	al, 76h	; 'v'
		jz	short loc_4475
		pop	ebx
		mov	eax, 3
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_4475:				; CODE XREF: _str2fmt+153j
					; _str2fmt+157j
		pop	ebx
		mov	eax, 0Ch
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_447D:				; CODE XREF: _str2fmt+13Bj
					; _str2fmt+13Fj
		pop	ebx
		mov	eax, 0Dh
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_4485:				; CODE XREF: _str2fmt+133j
					; _str2fmt+137j
		pop	ebx
		mov	eax, 7
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_448D:				; CODE XREF: _str2fmt+62j _str2fmt+97j ...
		pop	ebx
		mov	eax, 5
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_4495:				; CODE XREF: _str2fmt+51j _str2fmt+59j
		mov	eax, 0Bh
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_449C:				; CODE XREF: _str2fmt+41j _str2fmt+49j
		mov	eax, 6
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_44A3:				; CODE XREF: _str2fmt+31j _str2fmt+39j
		mov	eax, 4
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_44AA:				; CODE XREF: _str2fmt+21j _str2fmt+29j
		mov	eax, 2
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_44B1:				; CODE XREF: _str2fmt+11j _str2fmt+19j
		mov	eax, 1
		pop	esi
		retn
_str2fmt	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 44B8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_try_load_engine proc near		; CODE XREF: _setup_engine+76p

arg_4		= dword	ptr  8

		push	esi
		push	offset ??_C@_07OBLKMMON@dynamic?$AA@ ; "dynamic"
		call	_ENGINE_by_id
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jz	short loc_4509
		push	0
		push	[esp+8+arg_4]
		push	offset ??_C@_07EGEBNIPD@SO_PATH?$AA@ ; "SO_PATH"
		push	esi
		call	_ENGINE_ctrl_cmd_string
		add	esp, 10h
		test	eax, eax
		jz	short loc_44FE
		push	0
		push	0
		push	offset ??_C@_04ICOEJIDH@LOAD?$AA@ ; "LOAD"
		push	esi
		call	_ENGINE_ctrl_cmd_string
		add	esp, 10h
		test	eax, eax
		jz	short loc_44FE
		mov	eax, esi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_44FE:				; CODE XREF: _try_load_engine+2Aj
					; _try_load_engine+40j
		push	esi
		call	_ENGINE_free
		add	esp, 4
		xor	eax, eax

loc_4509:				; CODE XREF: _try_load_engine+12j
		pop	esi
		retn
_try_load_engine endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 450Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ui_close	proc near		; DATA XREF: _setup_ui_method+3Ao

arg_0		= dword	ptr  4

		push	[esp+arg_0]
		call	_UI_OpenSSL
		push	eax
		call	_UI_method_get_closer
		add	esp, 4
		call	eax
		add	esp, 4
		retn
_ui_close	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4524h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ui_open	proc near		; DATA XREF: _setup_ui_method+Ao

arg_0		= dword	ptr  4

		push	[esp+arg_0]
		call	_UI_OpenSSL
		push	eax
		call	_UI_method_get_opener
		add	esp, 4
		call	eax
		add	esp, 4
		retn
_ui_open	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 453Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ui_read	proc near		; DATA XREF: _setup_ui_method+1Ao

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		push	edi
		mov	edi, [esp+8+arg_4]
		push	edi
		call	_UI_get_input_flags
		mov	esi, [esp+0Ch+arg_0]
		add	esp, 4
		test	al, 2
		jz	short loc_4596
		push	esi
		call	_UI_get0_user_data
		add	esp, 4
		test	eax, eax
		jz	short loc_4596
		push	edi
		call	_UI_get_string_type
		dec	eax
		add	esp, 4
		cmp	eax, 1
		ja	short loc_4596
		push	esi
		call	_UI_get0_user_data
		add	esp, 4
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_4596
		cmp	byte ptr [eax],	0
		jz	short loc_4596
		push	eax
		push	edi
		push	esi
		call	_UI_set_result
		add	esp, 0Ch
		mov	eax, 1
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_4596:				; CODE XREF: _ui_read+15j _ui_read+22j ...
		push	edi
		push	esi
		call	_UI_OpenSSL
		push	eax
		call	_UI_method_get_reader
		add	esp, 4
		call	eax
		add	esp, 8
		pop	edi
		pop	esi
		retn
_ui_read	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 45B0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ui_write	proc near		; DATA XREF: _setup_ui_method+2Ao

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		push	edi
		mov	edi, [esp+8+arg_4]
		push	edi
		call	_UI_get_input_flags
		mov	esi, [esp+0Ch+arg_0]
		add	esp, 4
		test	al, 2
		jz	short loc_45FF
		push	esi
		call	_UI_get0_user_data
		add	esp, 4
		test	eax, eax
		jz	short loc_45FF
		push	edi
		call	_UI_get_string_type
		dec	eax
		add	esp, 4
		cmp	eax, 1
		ja	short loc_45FF
		push	esi
		call	_UI_get0_user_data
		add	esp, 4
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_45FF
		cmp	byte ptr [eax],	0
		jz	short loc_45FF
		pop	edi
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_45FF:				; CODE XREF: _ui_write+15j
					; _ui_write+22j ...
		push	edi
		push	esi
		call	_UI_OpenSSL
		push	eax
		call	_UI_method_get_writer
		add	esp, 4
		call	eax
		add	esp, 8
		pop	edi
		pop	esi
		retn
_ui_write	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4618h
; COMDAT (pick any)
		public ??_C@_06CKOLGKJK@PKCS12?$AA@
; `string'
??_C@_06CKOLGKJK@PKCS12?$AA@ db	'PKCS12',0 ; DATA XREF: _str2fmt+68o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4620h
; COMDAT (pick any)
		public ??_C@_06IDAJNGAK@pkcs12?$AA@
; `string'
??_C@_06IDAJNGAK@pkcs12?$AA@ db	'pkcs12',0 ; DATA XREF: _str2fmt+9Do
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4628h
; COMDAT (pick any)
		public ??_C@_03NNGPPEJH@P12?$AA@
; `string'
??_C@_03NNGPPEJH@P12?$AA@ dd 323150h	; DATA XREF: _str2fmt+D1o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 462Ch
; COMDAT (pick any)
		public ??_C@_03HNFNFLKJ@p12?$AA@
; `string'
??_C@_03HNFNFLKJ@p12?$AA@ dd 323170h	; DATA XREF: _str2fmt+101o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4630h
; COMDAT (pick any)
		public ??_C@_0O@BBAIDNNM@?4?2apps?2apps?4c?$AA@
; `string'
??_C@_0O@BBAIDNNM@?4?2apps?2apps?4c?$AA@ db '.\apps\apps.c',0 ; DATA XREF: _chopup_args+24o
					; _chopup_args+B6o ...
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4640h
; COMDAT (pick any)
		public ??_C@_08MAHPNCKH@subject?$DN?$AA@
; `string'
??_C@_08MAHPNCKH@subject?$DN?$AA@ db 'subject=',0 ; DATA XREF: _dump_cert_text+1Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 464Ch
; COMDAT (pick any)
		public ??_C@_08BDBNPDII@?6issuer?$DN?$AA@
; `string'
??_C@_08BDBNPDII@?6issuer?$DN?$AA@ db 0Ah ; DATA XREF: _dump_cert_text+4Fo
		db 'issuer=',0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4658h
; COMDAT (pick any)
		public ??_C@_01EEMJAFIK@?6?$AA@
; `string'
??_C@_01EEMJAFIK@?6?$AA@ db 0Ah, 0	; DATA XREF: _dump_cert_text+63o
					; _nodes_print+21o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 465Ch
; COMDAT (pick any)
		public ??_C@_0CD@HINDFPHK@OpenSSL?5application?5user?5interfa@
; `string'
??_C@_0CD@HINDFPHK@OpenSSL?5application?5user?5interfa@	db 'OpenSSL application user interface',0
					; DATA XREF: _setup_ui_methodo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4680h
; COMDAT (pick any)
		public ??_C@_0M@FKGGGFHP@pass?5phrase?$AA@
; `string'
??_C@_0M@FKGGGFHP@pass?5phrase?$AA@ db 'pass phrase',0 ; DATA XREF: _password_callback+74o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 468Ch
; COMDAT (pick any)
		public ??_C@_0P@HKFKDJCC@Out?5of?5memory?6?$AA@
; char `string'[]
??_C@_0P@HKFKDJCC@Out?5of?5memory?6?$AA@ db 'Out of memory',0Ah,0
					; DATA XREF: _load_index+115o
					; _load_serial:loc_2B7Co ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 469Ch
; COMDAT (pick any)
		public ??_C@_0BG@HNCPHOCJ@User?5interface?5error?6?$AA@
; `string'
??_C@_0BG@HNCPHOCJ@User?5interface?5error?6?$AA@ db 'User interface error',0Ah,0
					; DATA XREF: _password_callback+1ACo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 46B4h
; COMDAT (pick any)
		public ??_C@_09JELMDBBD@aborted?$CB?6?$AA@
; `string'
??_C@_09JELMDBBD@aborted?$CB?6?$AA@ db 'aborted!',0Ah,0 ; DATA XREF: _password_callback+1DBo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 46C0h
; COMDAT (pick any)
		public ??_C@_05OLNJAKGC@pass?3?$AA@
; char `string'[]
??_C@_05OLNJAKGC@pass?3?$AA@ db	'pass:',0 ; DATA XREF: _app_get_pass+31o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 46C8h
; COMDAT (pick any)
		public ??_C@_04MGCDLKHE@env?3?$AA@
; char `string'[]
??_C@_04MGCDLKHE@env?3?$AA@ db 'env:',0 ; DATA XREF: _app_get_pass+66o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 46D0h
; COMDAT (pick any)
		public ??_C@_0CE@NKEIKLNB@Can?8t?5read?5environment?5variable?5@
; `string'
??_C@_0CE@NKEIKLNB@Can?8t?5read?5environment?5variable?5@ db 'Can',27h,'t read environment variable %s',0Ah,0
					; DATA XREF: _app_get_pass+87o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 46F4h
; COMDAT (pick any)
		public ??_C@_05BOPHDICO@file?3?$AA@
; char `string'[]
??_C@_05BOPHDICO@file?3?$AA@ db	'file:',0 ; DATA XREF: _app_get_pass+AAo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 46FCh
; COMDAT (pick any)
		public ??_C@_01KDCPPGHE@r?$AA@
; `string'
??_C@_01KDCPPGHE@r?$AA@	db 72h,	0	; DATA XREF: _app_get_pass+BCo
					; _load_certs_crls:loc_1E52o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4700h
; COMDAT (pick any)
		public ??_C@_0BE@DGGEJBEC@Can?8t?5open?5file?5?$CFs?6?$AA@
; `string'
??_C@_0BE@DGGEJBEC@Can?8t?5open?5file?5?$CFs?6?$AA@ db 'Can',27h,'t open file %s',0Ah,0
					; DATA XREF: _app_get_pass+D4o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4714h
; COMDAT (pick any)
		public ??_C@_05MHOFLBOO@stdin?$AA@
; `string'
??_C@_05MHOFLBOO@stdin?$AA@ db 'stdin',0 ; DATA XREF: _app_get_pass:loc_6D2o
					; _load_certs_crls+74o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 471Ch
; COMDAT (pick any)
		public ??_C@_0BK@EEFMFEJC@Can?8t?5open?5BIO?5for?5stdin?6?$AA@
; `string'
??_C@_0BK@EEFMFEJC@Can?8t?5open?5BIO?5for?5stdin?6?$AA@	db 'Can',27h,'t open BIO for stdin',0Ah,0
					; DATA XREF: _app_get_pass+12Fo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4738h
; COMDAT (pick any)
		public ??_C@_0CA@FEIKIBOM@Invalid?5password?5argument?5?$CC?$CFs?$CC?6?$AA@
; `string'
??_C@_0CA@FEIKIBOM@Invalid?5password?5argument?5?$CC?$CFs?$CC?6?$AA@ db	'Invalid password argument "%s"',0Ah,0
					; DATA XREF: _app_get_pass+1CAo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4758h
; COMDAT (pick any)
		public ??_C@_0CB@KJOAPACB@Error?5reading?5password?5from?5BIO?6@
; `string'
??_C@_0CB@KJOAPACB@Error?5reading?5password?5from?5BIO?6@ db 'Error reading password from BIO',0Ah,0
					; DATA XREF: _app_get_pass+17Do
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 477Ch
; COMDAT (pick any)
		public ??_C@_0M@HCKPEIO@oid_section?$AA@
; `string'
??_C@_0M@HCKPEIO@oid_section?$AA@ db 'oid_section',0 ; DATA XREF: _add_oid_section+6o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4788h
; COMDAT (pick any)
		public ??_C@_0CA@HDAKCCMK@problem?5loading?5oid?5section?5?$CFs?6?$AA@
; `string'
??_C@_0CA@HDAKCCMK@problem?5loading?5oid?5section?5?$CFs?6?$AA@	db 'problem loading oid section %s',0Ah,0
					; DATA XREF: _add_oid_section+38o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 47A8h
; COMDAT (pick any)
		public ??_C@_0BP@DCFHMIBP@problem?5creating?5object?5?$CFs?$DN?$CFs?6?$AA@
; `string'
??_C@_0BP@DCFHMIBP@problem?5creating?5object?5?$CFs?$DN?$CFs?6?$AA@ db 'problem creating object %s=%s',0Ah,0
					; DATA XREF: _add_oid_section+9Ao
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 47C8h
; COMDAT (pick any)
		public ??_C@_0CC@PEGFFLPF@Error?5loading?5PKCS12?5file?5for?5?$CFs@
; `string'
??_C@_0CC@PEGFFLPF@Error?5loading?5PKCS12?5file?5for?5?$CFs@ db	'Error loading PKCS12 file for %s',0Ah,0
					; DATA XREF: _load_pkcs12+7Bo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	byte public 'DATA' use32
		assume cs:_rdata
		;org 47ECh
; COMDAT (pick any)
		public ??_C@_00CNPNBAHC@?$AA@
; `string'
??_C@_00CNPNBAHC@?$AA@ db 0		; DATA XREF: _load_pkcs12+90o
					; _load_pkcs12:loc_2855o ...
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 47F0h
; COMDAT (pick any)
		public ??_C@_0CC@DKCLIBKC@Passpharse?5callback?5error?5for?5?$CFs@
; `string'
??_C@_0CC@DKCLIBKC@Passpharse?5callback?5error?5for?5?$CFs@ db 'Passpharse callback error for %s',0Ah,0
					; DATA XREF: _load_pkcs12+D9o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4814h
; COMDAT (pick any)
		public ??_C@_0DK@EMMPDJCK@Mac?5verify?5error?5?$CIwrong?5password@
; `string'
??_C@_0DK@EMMPDJCK@Mac?5verify?5error?5?$CIwrong?5password@ db 'Mac verify error (wrong password?) in PKCS12 file for %s',0Ah,0
					; DATA XREF: _load_pkcs12+10Bo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4850h
; COMDAT (pick any)
		public ??_C@_0BF@LDHEOEBK@https?5not?5supported?6?$AA@
; `string'
??_C@_0BF@LDHEOEBK@https?5not?5supported?6?$AA@	db 'https not supported',0Ah,0
					; DATA XREF: _load_cert_crl_http+6Ao
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4868h
; COMDAT (pick any)
		public ??_C@_03HAPOJHBM@GET?$AA@
; `string'
??_C@_03HAPOJHBM@GET?$AA@ dd 544547h	; DATA XREF: _load_cert_crl_http+C0o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 486Ch
; COMDAT (pick any)
		public ??_C@_04CPPPJGME@Host?$AA@
; `string'
??_C@_04CPPPJGME@Host?$AA@ db 'Host',0  ; DATA XREF: _load_cert_crl_http+D6o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4874h
; COMDAT (pick any)
		public ??_C@_0M@LLNFCECG@certificate?$AA@
; char `string'[]
??_C@_0M@LLNFCECG@certificate?$AA@ db 'certificate',0 ; DATA XREF: _load_cert+104o
					; _load_cert_crl_http+184o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4880h
; COMDAT (pick any)
		public ??_C@_03GEOOCNOH@CRL?$AA@
; `string'
??_C@_03GEOOCNOH@CRL?$AA@ db 'CRL',0    ; DATA XREF: _load_cert_crl_http+17Do
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4884h
; COMDAT (pick any)
		public ??_C@_0BK@FAFHEINM@Error?5loading?5?$CFs?5from?5?$CFs?6?$AA@
; `string'
??_C@_0BK@FAFHEINM@Error?5loading?5?$CFs?5from?5?$CFs?6?$AA@ db	'Error loading %s from %s',0Ah,0
					; DATA XREF: _load_cert_crl_http+18Do
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48A0h
; COMDAT (pick any)
		public ??_C@_0BF@JJKPOFNI@Error?5opening?5?$CFs?5?$CFs?6?$AA@
; `string'
??_C@_0BF@JJKPOFNI@Error?5opening?5?$CFs?5?$CFs?6?$AA@ db 'Error opening %s %s',0Ah,0
					; DATA XREF: _load_cert+C4o
					; _load_certs_crls+85o	...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48B8h
; COMDAT (pick any)
		public ??_C@_0CF@BGMEBKBE@Error?5reading?5header?5on?5certific@
; `string'
??_C@_0CF@BGMEBKBE@Error?5reading?5header?5on?5certific@ db 'Error reading header on certificate',0Ah,0
					; DATA XREF: _load_cert+11Co
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 48E0h
; COMDAT (pick any)
		public ??_C@_0CD@HFNMCDK@bad?5input?5format?5specified?5for?5?$CF@
; `string'
??_C@_0CD@HFNMCDK@bad?5input?5format?5specified?5for?5?$CF@ db 'bad input format specified for %s',0Ah,0
					; DATA XREF: _load_cert+17Eo
					; _load_certs_crls+2Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4904h
; COMDAT (pick any)
		public ??_C@_0BM@FDKJDCHF@unable?5to?5load?5certificate?6?$AA@
; `string'
??_C@_0BM@FDKJDCHF@unable?5to?5load?5certificate?6?$AA@	db 'unable to load certificate',0Ah,0
					; DATA XREF: _load_cert+194o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4920h
; COMDAT (pick any)
		public ??_C@_0CK@DJFFGPOF@bad?5input?5format?5specified?5for?5i@
; `string'
??_C@_0CK@DJFFGPOF@bad?5input?5format?5specified?5for?5i@ db 'bad input format specified for input crl',0Ah,0
					; DATA XREF: _load_crl:loc_2191o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 494Ch
; COMDAT (pick any)
		public ??_C@_0BE@BBFHHDDE@unable?5to?5load?5CRL?6?$AA@
; `string'
??_C@_0BE@BBFHHDDE@unable?5to?5load?5CRL?6?$AA@	db 'unable to load CRL',0Ah,0
					; DATA XREF: _load_crl+E9o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4960h
; COMDAT (pick any)
		public ??_C@_0BG@OLBFGCBD@no?5keyfile?5specified?6?$AA@
; `string'
??_C@_0BG@OLBFGCBD@no?5keyfile?5specified?6?$AA@ db 'no keyfile specified',0Ah,0
					; DATA XREF: _load_key+42o
					; _load_pubkey:loc_28D3o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4978h
; COMDAT (pick any)
		public ??_C@_0BF@MCNMEPFL@no?5engine?5specified?6?$AA@
; `string'
??_C@_0BF@MCNMEPFL@no?5engine?5specified?6?$AA@	db 'no engine specified',0Ah,0
					; DATA XREF: _load_key+6Ao
					; _load_pubkey+5Fo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4990h
; COMDAT (pick any)
		public ??_C@_0BM@OODBDEPN@cannot?5load?5?$CFs?5from?5engine?6?$AA@
; `string'
??_C@_0BM@OODBDEPN@cannot?5load?5?$CFs?5from?5engine?6?$AA@ db 'cannot load %s from engine',0Ah,0
					; DATA XREF: _load_key+A3o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 49ACh
; COMDAT (pick any)
		public ??_C@_0CJ@DHFLKNAM@bad?5input?5format?5specified?5for?5k@
; `string'
??_C@_0CJ@DHFLKNAM@bad?5input?5format?5specified?5for?5k@ db 'bad input format specified for key file',0Ah,0
					; DATA XREF: _load_key:loc_25F5o
					; _load_pubkey:loc_2A87o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 49D8h
; COMDAT (pick any)
		public ??_C@_0BD@DHEMONEO@unable?5to?5load?5?$CFs?6?$AA@
; `string'
??_C@_0BD@DHEMONEO@unable?5to?5load?5?$CFs?6?$AA@ db 'unable to load %s',0Ah,0
					; DATA XREF: _load_certs_crls+1FDo
					; _load_key+220o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 49ECh
; COMDAT (pick any)
		public ??_C@_0BE@NPKILBBI@Error?5reading?5?$CFs?5?$CFs?$AA@
; `string'
??_C@_0BE@NPKILBBI@Error?5reading?5?$CFs?5?$CFs?$AA@ db	'Error reading %s %s',0
					; DATA XREF: _load_netscape_key+8Fo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4A00h
; COMDAT (pick any)
		public ??_C@_0N@NGKEHKOM@certificates?$AA@
; `string'
??_C@_0N@NGKEHKOM@certificates?$AA@ db 'certificates',0 ; DATA XREF: _load_certs_crls+1F4o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4A10h
; COMDAT (pick any)
		public ??_C@_04DKBILDMD@CRLs?$AA@
; `string'
??_C@_04DKBILDMD@CRLs?$AA@ db 'CRLs',0  ; DATA XREF: _load_certs_crls+1EDo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4A18h
; COMDAT (pick any)
		public ??_C@_04CGFJFPFD@none?$AA@
; char `string'[]
??_C@_04CGFJFPFD@none?$AA@ db 'none',0  ; DATA XREF: _set_ext_copy+Co
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4A20h
; COMDAT (pick any)
		public ??_C@_04COAGEIMF@copy?$AA@
; char `string'[]
??_C@_04COAGEIMF@copy?$AA@ db 'copy',0  ; DATA XREF: _set_ext_copy:loc_3EDDo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4A28h
; COMDAT (pick any)
		public ??_C@_07ENLILCDE@copyall?$AA@
; char `string'[]
??_C@_07ENLILCDE@copyall?$AA@ db 'copyall',0 ; DATA XREF: _set_ext_copy:loc_3EFEo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4A30h
; COMDAT (pick any)
		public ??_C@_0BH@FHLAEOCH@Error?5loading?5file?5?$CFs?6?$AA@
; `string'
??_C@_0BH@FHLAEOCH@Error?5loading?5file?5?$CFs?6?$AA@ db 'Error loading file %s',0Ah,0
					; DATA XREF: _setup_verify+3Do
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4A48h
; COMDAT (pick any)
		public ??_C@_0BM@OKGFCOK@Error?5loading?5directory?5?$CFs?6?$AA@
; `string'
??_C@_0BM@OKGFCOK@Error?5loading?5directory?5?$CFs?6?$AA@ db 'Error loading directory %s',0Ah,0
					; DATA XREF: _setup_verify+9Bo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4A64h
; COMDAT (pick any)
		public ??_C@_07OBLKMMON@dynamic?$AA@
; `string'
??_C@_07OBLKMMON@dynamic?$AA@ db 'dynamic',0 ; DATA XREF: _try_load_engine+1o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4A6Ch
; COMDAT (pick any)
		public ??_C@_07EGEBNIPD@SO_PATH?$AA@
; `string'
??_C@_07EGEBNIPD@SO_PATH?$AA@ db 'SO_PATH',0 ; DATA XREF: _try_load_engine+1Ao
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4A74h
; COMDAT (pick any)
		public ??_C@_04ICOEJIDH@LOAD?$AA@
; `string'
??_C@_04ICOEJIDH@LOAD?$AA@ db 'LOAD',0  ; DATA XREF: _try_load_engine+30o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4A7Ch
; COMDAT (pick any)
		public ??_C@_04HAPDLBFF@auto?$AA@
; `string'
??_C@_04HAPDLBFF@auto?$AA@ db 'auto',0  ; DATA XREF: _setup_engine+11o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4A84h
; COMDAT (pick any)
		public ??_C@_0BO@GLIGNJMA@enabling?5auto?5ENGINE?5support?6?$AA@
; `string'
??_C@_0BO@GLIGNJMA@enabling?5auto?5ENGINE?5support?6?$AA@ db 'enabling auto ENGINE support',0Ah,0
					; DATA XREF: _setup_engine+41o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4AA4h
; COMDAT (pick any)
		public ??_C@_0BF@FDAJFBF@invalid?5engine?5?$CC?$CFs?$CC?6?$AA@
; `string'
??_C@_0BF@FDAJFBF@invalid?5engine?5?$CC?$CFs?$CC?6?$AA@	db 'invalid engine "%s"',0Ah,0
					; DATA XREF: _setup_engine+85o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4ABCh
; COMDAT (pick any)
		public ??_C@_0BD@HNMPJJDL@SET_USER_INTERFACE?$AA@
; `string'
??_C@_0BD@HNMPJJDL@SET_USER_INTERFACE?$AA@ db 'SET_USER_INTERFACE',0
					; DATA XREF: _setup_engine+C2o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4AD0h
; COMDAT (pick any)
		public ??_C@_0BH@OBPKDCDO@can?8t?5use?5that?5engine?6?$AA@
; `string'
??_C@_0BH@OBPKDCDO@can?8t?5use?5that?5engine?6?$AA@ db 'can',27h,'t use that engine',0Ah,0
					; DATA XREF: _setup_engine+DFo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4AE8h
; COMDAT (pick any)
		public ??_C@_0BC@CPAKBHCD@engine?5?$CC?$CFs?$CC?5set?4?6?$AA@
; `string'
??_C@_0BC@CPAKBHCD@engine?5?$CC?$CFs?$CC?5set?4?6?$AA@ db 'engine "%s" set.',0Ah,0
					; DATA XREF: _setup_engine+106o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4AFCh
; COMDAT (pick any)
		public ??_C@_0BL@IPMGKJPN@Error?5configuring?5OpenSSL?6?$AA@
; `string'
??_C@_0BL@IPMGKJPN@Error?5configuring?5OpenSSL?6?$AA@ db 'Error configuring OpenSSL',0Ah,0
					; DATA XREF: _load_config+46o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4B18h
; COMDAT (pick any)
		public ??_C@_01KMDKNFGN@?1?$AA@
; `string'
??_C@_01KMDKNFGN@?1?$AA@ db 2Fh, 0	; DATA XREF: _make_config_name+42o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4B1Ch
; COMDAT (pick any)
		public ??_C@_0M@CFEEHNHP@openssl?4cnf?$AA@
; `string'
??_C@_0M@CFEEHNHP@openssl?4cnf?$AA@ db 'openssl.cnf',0 ; DATA XREF: _make_config_name+4Eo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4B28h
; COMDAT (pick any)
		public ??_C@_0BP@IBMKHAAI@unable?5to?5load?5number?5from?5?$CFs?6?$AA@
; `string'
??_C@_0BP@IBMKHAAI@unable?5to?5load?5number?5from?5?$CFs?6?$AA@	db 'unable to load number from %s',0Ah,0
					; DATA XREF: _load_serial+111o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4B48h
; COMDAT (pick any)
		public ??_C@_0CM@KKKLPGOP@error?5converting?5number?5from?5bin@
; `string'
??_C@_0CM@KKKLPGOP@error?5converting?5number?5from?5bin@ db 'error converting number from bin to BIGNUM',0Ah,0
					; DATA XREF: _load_serial+137o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4B74h
; COMDAT (pick any)
		public ??_C@_0BE@PGHNBIGG@file?5name?5too?5long?6?$AA@
; `string'
??_C@_0BE@PGHNBIGG@file?5name?5too?5long?6?$AA@	db 'file name too long',0Ah,0
					; DATA XREF: _rotate_index+8Fo
					; _rotate_serial+8Do ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4B88h
; COMDAT (pick any)
		public ??_C@_05NNFHCGPF@?$CFs?4?$CFs?$AA@
; `string'
??_C@_05NNFHCGPF@?$CFs?4?$CFs?$AA@ db '%s.%s',0 ; DATA XREF: _rotate_index+DCo
					; _rotate_index+F2o ...
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4B90h
; COMDAT (pick any)
		public ??_C@_0CJ@OGFINJBE@error?5converting?5serial?5to?5ASN?41@
; `string'
??_C@_0CJ@OGFINJBE@error?5converting?5serial?5to?5ASN?41@ db 'error converting serial to ASN.1 format',0Ah,0
					; DATA XREF: _save_serial+128o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4BBCh
; COMDAT (pick any)
		public ??_C@_0BL@PJHGPAJJ@unable?5to?5rename?5?$CFs?5to?5?$CFs?6?$AA@
; `string'
??_C@_0BL@PJHGPAJJ@unable?5to?5rename?5?$CFs?5to?5?$CFs?6?$AA@ db 'unable to rename %s to %s',0Ah,0
					; DATA XREF: _rotate_index+157o
					; _rotate_index+194o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4BD8h
; COMDAT (pick any)
		public ??_C@_06CEHAOENB@reason?$AA@
; char `string'[]
??_C@_06CEHAOENB@reason?$AA@ db	'reason',0 ; DATA XREF: _rotate_index+167o
					; _rotate_index+1A4o ...
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4BE0h
; COMDAT (pick any)
		public ??_C@_0BF@BIGLPGDL@unable?5to?5open?5?8?$CFs?8?6?$AA@
; `string'
??_C@_0BF@BIGLPGDL@unable?5to?5open?5?8?$CFs?8?6?$AA@ db 'unable to open ',27h,'%s',27h,0Ah,0
					; DATA XREF: _load_index+6Ao
					; _save_index:loc_3C62o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4BF8h
; COMDAT (pick any)
		public ??_C@_07MFJDFAJK@?$CFs?4attr?$AA@
; `string'
??_C@_07MFJDFAJK@?$CFs?4attr?$AA@ db '%s.attr',0 ; DATA XREF: _load_index+99o
					; _rotate_index+AAo ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4C00h
; COMDAT (pick any)
		public ??_C@_0CN@KHNEBDJO@error?5on?5line?5?$CFld?5of?5db?5attribut@
; `string'
??_C@_0CN@KHNEBDJO@error?5on?5line?5?$CFld?5of?5db?5attribut@ db 'error on line %ld of db attribute file ',27h,'%s',27h,0Ah,0
					; DATA XREF: _load_index+DBo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4C30h
; COMDAT (pick any)
		public ??_C@_0P@HOGDIGGB@unique_subject?$AA@
; `string'
??_C@_0P@HOGDIGGB@unique_subject?$AA@ db 'unique_subject',0 ; DATA XREF: _load_index+14Do
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4C40h
; COMDAT (pick any)
		public ??_C@_0DC@FMBAALNJ@error?5creating?5serial?5number?5ind@
; `string'
??_C@_0DC@FMBAALNJ@error?5creating?5serial?5number?5ind@ db 'error creating serial number index:(%ld,%ld,%ld)',0Ah,0
					; DATA XREF: _index_index+2Eo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4C74h
; COMDAT (pick any)
		public ??_C@_0CJ@LAHEODBL@error?5creating?5name?5index?3?$CI?$CFld?0?$CF@
; `string'
??_C@_0CJ@LAHEODBL@error?5creating?5name?5index?3?$CI?$CFld?0?$CF@ db 'error creating name index:(%ld,%ld,%ld)',0Ah,0
					; DATA XREF: _index_index+76o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4CA0h
; COMDAT (pick any)
		public ??_C@_0L@FJEANEHK@?$CFs?4attr?4?$CFs?$AA@
; `string'
??_C@_0L@FJEANEHK@?$CFs?4attr?4?$CFs?$AA@ db '%s.attr.%s',0 ; DATA XREF: _rotate_index+C3o
					; _rotate_index+115o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4CACh
; COMDAT (pick any)
		public ??_C@_03ICICOMAL@yes?$AA@
; `string'
??_C@_03ICICOMAL@yes?$AA@ dd 736579h	; DATA XREF: _save_index+18Eo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4CB0h
; COMDAT (pick any)
		public ??_C@_02KAJCLHKP@no?$AA@
; `string'
??_C@_02KAJCLHKP@no?$AA@ db 6Eh, 6Fh, 0	; DATA XREF: _save_index+189o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4CB4h
; COMDAT (pick any)
		public ??_C@_0BF@HNOOHBO@unique_subject?5?$DN?5?$CFs?6?$AA@
; `string'
??_C@_0BF@HNOOHBO@unique_subject?5?$DN?5?$CFs?6?$AA@ db	'unique_subject = %s',0Ah,0
					; DATA XREF: _save_index+197o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4CCCh
; COMDAT (pick any)
		public ??_C@_0O@NPENBAOL@malloc?5error?6?$AA@
; `string'
??_C@_0O@NPENBAOL@malloc?5error?6?$AA@ db 'malloc error',0Ah,0
					; DATA XREF: _parse_name:loc_301Fo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4CDCh
; COMDAT (pick any)
		public ??_C@_0CC@MFKPEIBE@Subject?5does?5not?5start?5with?5?8?1?8?4@
; `string'
??_C@_0CC@MFKPEIBE@Subject?5does?5not?5start?5with?5?8?1?8?4@ db 'Subject does not start with ',27h,'/',27h,'.',0Ah,0
					; DATA XREF: _parse_name+B1o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4D00h
; COMDAT (pick any)
		public ??_C@_0CD@EOHKOJGN@escape?5character?5at?5end?5of?5strin@
; `string'
??_C@_0CD@EOHKOJGN@escape?5character?5at?5end?5of?5strin@ db 'escape character at end of string',0Ah,0
					; DATA XREF: _parse_name:loc_2F4Ao
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 4D24h
; COMDAT (pick any)
		public ??_C@_0EN@LIPKONBC@end?5of?5string?5encountered?5while?5@
; `string'
??_C@_0EN@LIPKONBC@end?5of?5string?5encountered?5while?5@ db 'end of string encountered while processing type of subject name e'
					; DATA XREF: _parse_name+128o
		db 'lement #%d',0Ah,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4D74h
; COMDAT (pick any)
		public ??_C@_0DA@DIKEDNCG@Subject?5Attribute?5?$CFs?5has?5no?5know@
; `string'
??_C@_0DA@DIKEDNCG@Subject?5Attribute?5?$CFs?5has?5no?5know@ db	'Subject Attribute %s has no known NID, skipped',0Ah,0
					; DATA XREF: _parse_name+1F5o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4DA4h
; COMDAT (pick any)
		public ??_C@_0DF@IJPKHMNK@No?5value?5provided?5for?5Subject?5At@
; `string'
??_C@_0DF@IJPKHMNK@No?5value?5provided?5for?5Subject?5At@ db 'No value provided for Subject Attribute %s, skipped',0Ah,0
					; DATA XREF: _parse_name+214o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4DDCh
; COMDAT (pick any)
		public ??_C@_07EDOEKPLG@?9policy?$AA@
; `string'
??_C@_07EDOEKPLG@?9policy?$AA@ db '-policy',0 ; DATA XREF: _args_verify+1Eo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4DE4h
; COMDAT (pick any)
		public ??_C@_0BF@OKHBOGOJ@Invalid?5Policy?5?$CC?$CFs?$CC?6?$AA@
; `string'
??_C@_0BF@OKHBOGOJ@Invalid?5Policy?5?$CC?$CFs?$CC?6?$AA@ db 'Invalid Policy "%s"',0Ah,0
					; DATA XREF: _args_verify+97o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4DFCh
; COMDAT (pick any)
		public ??_C@_08OKAIACAC@?9purpose?$AA@
; `string'
??_C@_08OKAIACAC@?9purpose?$AA@	db '-purpose',0 ; DATA XREF: _args_verify:loc_AD7o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4E08h
; COMDAT (pick any)
		public ??_C@_0BG@MLBGEMEI@unrecognized?5purpose?6?$AA@
; `string'
??_C@_0BG@MLBGEMEI@unrecognized?5purpose?6?$AA@	db 'unrecognized purpose',0Ah,0
					; DATA XREF: _args_verify+10Fo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4E20h
; COMDAT (pick any)
		public ??_C@_0O@GLCJCNHH@?9verify_depth?$AA@
; `string'
??_C@_0O@GLCJCNHH@?9verify_depth?$AA@ db '-verify_depth',0
					; DATA XREF: _args_verify:loc_B6Eo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4E30h
; COMDAT (pick any)
		public ??_C@_0P@PLGBDNLB@invalid?5depth?6?$AA@
; `string'
??_C@_0P@PLGBDNLB@invalid?5depth?6?$AA@	db 'invalid depth',0Ah,0
					; DATA XREF: _args_verify+19Fo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4E40h
; COMDAT (pick any)
		public ??_C@_07FHCFGGIA@?9attime?$AA@
; `string'
??_C@_07FHCFGGIA@?9attime?$AA@ db '-attime',0 ; DATA XREF: _args_verify:loc_BDFo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4E48h
; COMDAT (pick any)
		public ??_C@_03LMKFJNEF@?$CFli?$AA@
; char `string'[]
??_C@_03LMKFJNEF@?$CFli?$AA@ db	'%li',0 ; DATA XREF: _args_verify+215o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4E4Ch
; COMDAT (pick any)
		public ??_C@_0BM@BLOMJHGB@Error?5parsing?5timestamp?5?$CFs?6?$AA@
; `string'
??_C@_0BM@BLOMJHGB@Error?5parsing?5timestamp?5?$CFs?6?$AA@ db 'Error parsing timestamp %s',0Ah,0
					; DATA XREF: _args_verify+229o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4E68h
; COMDAT (pick any)
		public ??_C@_0BB@CBGFOLCL@?9verify_hostname?$AA@
; `string'
??_C@_0BB@CBGFOLCL@?9verify_hostname?$AA@ db '-verify_hostname',0
					; DATA XREF: _args_verify:loc_C78o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4E7Ch
; COMDAT (pick any)
		public ??_C@_0O@IDCHAMO@?9verify_email?$AA@
; `string'
??_C@_0O@IDCHAMO@?9verify_email?$AA@ db	'-verify_email',0 ; DATA XREF: _args_verify:loc_CC3o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4E8Ch
; COMDAT (pick any)
		public ??_C@_0L@BFLANKHI@?9verify_ip?$AA@
; `string'
??_C@_0L@BFLANKHI@?9verify_ip?$AA@ db '-verify_ip',0 ; DATA XREF: _args_verify:loc_D10o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4E98h
; COMDAT (pick any)
		public ??_C@_0BB@MAMKNOBM@?9ignore_critical?$AA@
; `string'
??_C@_0BB@MAMKNOBM@?9ignore_critical?$AA@ db '-ignore_critical',0
					; DATA XREF: _args_verify:loc_D60o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4EACh
; COMDAT (pick any)
		public ??_C@_0P@KGEGMNHK@?9issuer_checks?$AA@
; `string'
??_C@_0P@KGEGMNHK@?9issuer_checks?$AA@ db '-issuer_checks',0
					; DATA XREF: _args_verify:loc_D9Do
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4EBCh
; COMDAT (pick any)
		public ??_C@_0L@IIGOHFBF@?9crl_check?$AA@
; `string'
??_C@_0L@IIGOHFBF@?9crl_check?$AA@ db '-crl_check',0 ; DATA XREF: _args_verify:loc_DD5o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4EC8h
; COMDAT (pick any)
		public ??_C@_0P@JMLMJOLO@?9crl_check_all?$AA@
; `string'
??_C@_0P@JMLMJOLO@?9crl_check_all?$AA@ db '-crl_check_all',0
					; DATA XREF: _args_verify:loc_E0Do
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4ED8h
; COMDAT (pick any)
		public ??_C@_0O@CHPKAFNL@?9policy_check?$AA@
; `string'
??_C@_0O@CHPKAFNL@?9policy_check?$AA@ db '-policy_check',0
					; DATA XREF: _args_verify:loc_E45o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4EE8h
; COMDAT (pick any)
		public ??_C@_0BB@DFNKALPO@?9explicit_policy?$AA@
; `string'
??_C@_0BB@DFNKALPO@?9explicit_policy?$AA@ db '-explicit_policy',0
					; DATA XREF: _args_verify:loc_E7Fo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4EFCh
; COMDAT (pick any)
		public ??_C@_0N@BIEOAHOE@?9inhibit_any?$AA@
; `string'
??_C@_0N@BIEOAHOE@?9inhibit_any?$AA@ db	'-inhibit_any',0 ; DATA XREF: _args_verify:loc_EBFo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4F0Ch
; COMDAT (pick any)
		public ??_C@_0N@IIAGEECI@?9inhibit_map?$AA@
; `string'
??_C@_0N@IIAGEECI@?9inhibit_map?$AA@ db	'-inhibit_map',0 ; DATA XREF: _args_verify:loc_EFFo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4F1Ch
; COMDAT (pick any)
		public ??_C@_0N@JAAINALF@?9x509_strict?$AA@
; `string'
??_C@_0N@JAAINALF@?9x509_strict?$AA@ db	'-x509_strict',0 ; DATA XREF: _args_verify:loc_F3Fo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4F2Ch
; COMDAT (pick any)
		public ??_C@_0O@JLHDLMKC@?9extended_crl?$AA@
; `string'
??_C@_0O@JLHDLMKC@?9extended_crl?$AA@ db '-extended_crl',0
					; DATA XREF: _args_verify:loc_F7Do
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4F3Ch
; COMDAT (pick any)
		public ??_C@_0M@NIBFNGJH@?9use_deltas?$AA@
; `string'
??_C@_0M@NIBFNGJH@?9use_deltas?$AA@ db '-use_deltas',0 ; DATA XREF: _args_verify:loc_FB7o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4F48h
; COMDAT (pick any)
		public ??_C@_0O@HLMNILI@?9policy_print?$AA@
; `string'
??_C@_0O@HLMNILI@?9policy_print?$AA@ db	'-policy_print',0 ; DATA XREF: _args_verify:loc_FF1o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4F58h
; COMDAT (pick any)
		public ??_C@_0O@HOJLLGLJ@?9check_ss_sig?$AA@
; `string'
??_C@_0O@HOJLLGLJ@?9check_ss_sig?$AA@ db '-check_ss_sig',0
					; DATA XREF: _args_verify:loc_102Fo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4F68h
; COMDAT (pick any)
		public ??_C@_0P@FAJCKKIM@?9trusted_first?$AA@
; `string'
??_C@_0P@FAJCKKIM@?9trusted_first?$AA@ db '-trusted_first',0
					; DATA XREF: _args_verify:loc_106Fo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4F78h
; COMDAT (pick any)
		public ??_C@_0BB@CJLNDP@?9suiteB_128_only?$AA@
; `string'
??_C@_0BB@CJLNDP@?9suiteB_128_only?$AA@	db '-suiteB_128_only',0
					; DATA XREF: _args_verify:loc_10AFo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4F8Ch
; COMDAT (pick any)
		public ??_C@_0M@PEHELDMD@?9suiteB_128?$AA@
; `string'
??_C@_0M@PEHELDMD@?9suiteB_128?$AA@ db '-suiteB_128',0 ; DATA XREF: _args_verify:loc_10EFo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4F98h
; COMDAT (pick any)
		public ??_C@_0M@CMOLEKI@?9suiteB_192?$AA@
; `string'
??_C@_0M@CMOLEKI@?9suiteB_192?$AA@ db '-suiteB_192',0 ; DATA XREF: _args_verify:loc_112Fo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4FA4h
; COMDAT (pick any)
		public ??_C@_0P@MPJEMPGB@?9partial_chain?$AA@
; `string'
??_C@_0P@MPJEMPGB@?9partial_chain?$AA@ db '-partial_chain',0
					; DATA XREF: _args_verify:loc_116Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4FB4h
; COMDAT (pick any)
		public ??_C@_0P@PNNLIPKE@?9no_alt_chains?$AA@
; `string'
??_C@_0P@PNNLIPKE@?9no_alt_chains?$AA@ db '-no_alt_chains',0
					; DATA XREF: _args_verify:loc_11A3o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4FC4h
; COMDAT (pick any)
		public ??_C@_0N@ENJCIODO@?$CFs?5Policies?3?$AA@
; `string'
??_C@_0N@ENJCIODO@?$CFs?5Policies?3?$AA@ db '%s Policies:',0 ; DATA XREF: _nodes_print+Ao
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4FD4h
; COMDAT (pick any)
		public ??_C@_09CMBKKAKN@?5?$DMempty?$DO?6?$AA@
; `string'
??_C@_09CMBKKAKN@?5?$DMempty?$DO?6?$AA@	db ' <empty>',0Ah,0
					; DATA XREF: _nodes_print:loc_2D8Ao
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4FE0h
; COMDAT (pick any)
		public ??_C@_04HPMIDMKH@True?$AA@
; `string'
??_C@_04HPMIDMKH@True?$AA@ db 'True',0  ; DATA XREF: _policies_print+44o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4FE8h
; COMDAT (pick any)
		public ??_C@_05MKDOIIA@False?$AA@
; `string'
??_C@_05MKDOIIA@False?$AA@ db 'False',0 ; DATA XREF: _policies_print+3Fo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4FF0h
; COMDAT (pick any)
		public ??_C@_0BN@IBNHIEPH@Require?5explicit?5Policy?3?5?$CFs?6?$AA@
; `string'
??_C@_0BN@IBNHIEPH@Require?5explicit?5Policy?3?5?$CFs?6?$AA@ db	'Require explicit Policy: %s',0Ah,0
					; DATA XREF: _policies_print+4Do
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5010h
; COMDAT (pick any)
		public ??_C@_09NGOBFEPP@Authority?$AA@
; `string'
??_C@_09NGOBFEPP@Authority?$AA@	db 'Authority',0 ; DATA XREF: _policies_print+5Fo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 501Ch
; COMDAT (pick any)
		public ??_C@_04ODLBFFJE@User?$AA@
; `string'
??_C@_04ODLBFFJE@User?$AA@ db 'User',0  ; DATA XREF: _policies_print+71o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5024h
; COMDAT (pick any)
		public ??_C@_04CGMGFKEF@?5NOT?$AA@
; `string'
??_C@_04CGMGFKEF@?5NOT?$AA@ db ' NOT',0 ; DATA XREF: _print_cert_checks+33o
					; _print_cert_checks+62o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 502Ch
; COMDAT (pick any)
		public ??_C@_0CG@BEAMIHCH@Hostname?5?$CFs?5does?$CFs?5match?5certifi@
; `string'
??_C@_0CG@BEAMIHCH@Hostname?5?$CFs?5does?$CFs?5match?5certifi@ db 'Hostname %s does%s match certificate',0Ah,0
					; DATA XREF: _print_cert_checks+3Do
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5054h
; COMDAT (pick any)
		public ??_C@_0CD@CDKJLNLJ@Email?5?$CFs?5does?$CFs?5match?5certificat@
; `string'
??_C@_0CD@CDKJLNLJ@Email?5?$CFs?5does?$CFs?5match?5certificat@ db 'Email %s does%s match certificate',0Ah,0
					; DATA XREF: _print_cert_checks+6Co
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5078h
; COMDAT (pick any)
		public ??_C@_0CA@BEKABJAC@IP?5?$CFs?5does?$CFs?5match?5certificate?6?$AA@
; `string'
??_C@_0CA@BEKABJAC@IP?5?$CFs?5does?$CFs?5match?5certificate?6?$AA@ db 'IP %s does%s match certificate',0Ah,0
					; DATA XREF: _print_cert_checks+97o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 5098h
; COMDAT (pick any)
		public ??_C@_07FGAOOBMN@http?3?1?1?$AA@
; char `string'[]
??_C@_07FGAOOBMN@http?3?1?1?$AA@ db 'http://',0 ; DATA XREF: _get_dp_url+69o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 50A0h
; COMDAT (pick any)
		public ??_C@_0DN@IIJMFLNE@To?5get?5meaningful?5results?0?5run?5t@
; `string'
??_C@_0DN@IIJMFLNE@To?5get?5meaningful?5results?0?5run?5t@ db 'To get meaningful results, run this program on idle system.',0Ah,0
					; DATA XREF: _app_tminterval+71o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 50E0h
; COMDAT (pick any)
		public __real@3e7ad7f29abcaf48
__real@3e7ad7f29abcaf48	dq 3E7AD7F29ABCAF48h ; DATA XREF: _app_tminterval+EBr
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn ___report_rangecheckfailure:near ; CODE XREF: _load_pkcs12:loc_2896p
		extrn __imp____acrt_iob_func:near ; CODE XREF: _app_get_pass+114p
					; _load_cert+76p ...
; void __cdecl _perror(const char *ErrMsg)
		extrn __imp__perror:near ; CODE	XREF: _load_crl+B2p
					; _load_index+63p ...
; int __cdecl _setvbuf(FILE *File, char	*Buf, int Mode,	size_t Size)
		extrn __imp__setvbuf:near ; CODE XREF: _load_cert+7Cp
					; _load_key+FAp ...
		extrn __imp____stdio_common_vfprintf:near ; CODE XREF: __vfprintf_l+1Ap
					; _fprintf+19p
					; DATA XREF: ...
		extrn __imp____stdio_common_vsscanf:near ; CODE	XREF: __vsscanf_l+1Cp
					; _sscanf+1Bp
					; DATA XREF: ...
; int *__cdecl __errno()
		extrn __imp___errno:near ; CODE	XREF: _WIN32_rename+55p
					; _WIN32_rename:loc_4BEp ...
; int __cdecl _atoi(const char *Str)
		extrn __imp__atoi:near	; CODE XREF: _args_verify+18Ep
					; DATA XREF: _args_verify+18Er
; char *__cdecl	_getenv(const char *VarName)
		extrn __imp__getenv:near ; CODE	XREF: _app_get_pass+79p
					; DATA XREF: _app_get_pass+79r
; char *__cdecl	_strchr(const char *Str, int Val)
		extrn __imp__strchr:near ; CODE	XREF: _app_get_pass+194p
					; _pkey_ctrl_string+1Bp
					; DATA XREF: ...
; int __cdecl __stricmp(const char *Str1, const	char *Str2)
		extrn __imp___stricmp:near ; CODE XREF:	_set_ext_copy+12p
					; _set_ext_copy+33p ...
; int __cdecl _strncmp(const char *Str1, const char *Str2, size_t MaxCount)
		extrn __imp__strncmp:near ; CODE XREF: _app_get_pass+37p
					; _app_get_pass+6Cp ...
		extrn _sk_num:near	; CODE XREF: _add_oid_section+52p
					; _add_oid_section+7Fp	...
		extrn _sk_value:near	; CODE XREF: _add_oid_section+62p
					; _copy_extensions+62p	...
		extrn _sk_new_null:near	; CODE XREF: _crls_http_cb+3Dp
					; _load_certs_crls+D0p	...
		extrn _sk_pop_free:near	; CODE XREF: _copy_extensions+FBp
					; _crls_http_cb+2Ap ...
		extrn _sk_push:near	; CODE XREF: _crls_http_cb+46p
					; _crls_http_cb+78p ...
		extrn _CRYPTO_malloc:near ; CODE XREF: _chopup_args+32p
					; _load_index+107p ...
		extrn _CRYPTO_free:near	; CODE XREF: _dump_cert_text+31p
					; _dump_cert_text+6Fp ...
		extrn _CRYPTO_realloc:near ; CODE XREF:	_chopup_args+C5p
		extrn _OPENSSL_cleanse:near ; CODE XREF: _password_callback+17Dp
					; _password_callback+1CCp ...
		extrn _BIO_set_flags:near ; CODE XREF: _bio_to_mem+BBp
		extrn _BIO_s_file:near	; CODE XREF: _load_cert+3Cp
					; _load_crl+3Dp ...
		extrn _BIO_new_file:near ; CODE	XREF: _app_get_pass+C2p
					; _load_certs_crls+64p
		extrn _BIO_new_fp:near	; CODE XREF: _app_get_pass+11Ep
					; _load_certs_crls+57p	...
		extrn _BIO_new:near	; CODE XREF: _bio_to_mem+32p
					; _load_cert+42p ...
		extrn _BIO_free:near	; CODE XREF: _bio_to_mem+C1p
					; _bio_to_mem+CEp ...
		extrn _BIO_read:near	; CODE XREF: _bio_to_mem+7Ep
					; _load_netscape_key+4Cp
		extrn _BIO_gets:near	; CODE XREF: _app_get_pass+14Dp
		extrn _BIO_write:near	; CODE XREF: _bio_to_mem+95p
		extrn _BIO_puts:near	; CODE XREF: _dump_cert_text+24p
					; _dump_cert_text+2Bp ...
		extrn _BIO_ctrl:near	; CODE XREF: _bio_to_mem+AEp
					; _load_cert+8Cp ...
		extrn _BIO_free_all:near ; CODE	XREF: _app_get_pass+167p
					; _load_cert_crl_http+154p ...
		extrn _BIO_s_mem:near	; CODE XREF: _bio_to_mem+2Cp
		extrn _BIO_new_connect:near ; CODE XREF: _load_cert_crl_http+81p
		extrn _BIO_printf:near	; CODE XREF: _add_oid_section+41p
					; _add_oid_section+A3p	...
		extrn _BIO_snprintf:near ; CODE	XREF: _load_index+A8p
					; _rotate_index+BCp ...
		extrn _lh_strhash:near	; CODE XREF: _index_name_LHASH_HASH+7p
					; _index_name_hash+7p ...
		extrn _ERR_clear_error:near ; CODE XREF: _add_oid_section+1Cp
					; _setup_verify:loc_42CDp
		extrn _ERR_print_errors:near ; CODE XREF: _load_cert+55p
					; _load_cert+D0p ...
		extrn _BUF_MEM_new:near	; CODE XREF: _load_netscape_key+Ep
		extrn _BUF_MEM_free:near ; CODE	XREF: _load_netscape_key+71p
					; _load_netscape_key+CDp
		extrn _BUF_MEM_grow_clean:near ; CODE XREF: _load_netscape_key+2Cp
					; _load_netscape_key+64p
		extrn _BUF_strdup:near	; CODE XREF: _app_get_pass+44p
					; _app_get_pass+1A9p ...
		extrn _BUF_strlcpy:near	; CODE XREF: _make_config_name+3Cp
					; _save_serial+AFp
		extrn _BUF_strlcat:near	; CODE XREF: _make_config_name+48p
					; _make_config_name+54p
		extrn _BN_pseudo_rand:near ; CODE XREF:	_rand_serial+29p
		extrn _BN_new:near	; CODE XREF: _load_serial:loc_2B63p
					; _rand_serial:loc_361Dp
		extrn _BN_free:near	; CODE XREF: _rand_serial+55p
		extrn _ASN1_STRING_length:near ; CODE XREF: _get_dp_url+52p
		extrn _ASN1_STRING_data:near ; CODE XREF: _get_dp_url+60p
		extrn _ASN1_INTEGER_new:near ; CODE XREF: _load_serial+2Fp
		extrn _ASN1_INTEGER_free:near ;	CODE XREF: _load_serial+D6p
					; _save_serial+171p
		extrn _i2a_ASN1_INTEGER:near ; CODE XREF: _save_serial+13Fp
		extrn _a2i_ASN1_INTEGER:near ; CODE XREF: _load_serial+104p
		extrn _BN_to_ASN1_INTEGER:near ; CODE XREF: _rand_serial+3Fp
					; _save_serial+11Ap
		extrn _ASN1_INTEGER_to_BN:near ; CODE XREF: _load_serial+129p
		extrn _ASN1_item_d2i_bio:near ;	CODE XREF: _load_cert+EBp
		extrn _NETSCAPE_X509_free:near ; CODE XREF: _load_cert+117p
					; _load_cert+131p
		extrn _NETSCAPE_X509_it:near ; CODE XREF: _load_cert+E5p
		extrn _OBJ_txt2obj:near	; CODE XREF: _args_verify+86p
		extrn _OBJ_txt2nid:near	; CODE XREF: _parse_name+1E5p
		extrn _OBJ_create:near	; CODE XREF: _add_oid_section+71p
		extrn _EVP_PKEY_set1_RSA:near ;	CODE XREF: _load_netscape_key+D4p
					; _load_pubkey+16Bp
		extrn _EVP_PKEY_new:near ; CODE	XREF: _load_netscape_key+15p
					; _load_pubkey+15Ep
		extrn _EVP_PKEY_free:near ; CODE XREF: _load_netscape_key+77p
		extrn _EVP_PKEY_CTX_ctrl_str:near ; CODE XREF: _pkey_ctrl_string+33p
		extrn _RSA_free:near	; CODE XREF: _load_pubkey+174p
		extrn _d2i_RSA_NET:near	; CODE XREF: _load_netscape_key+BEp
		extrn _X509_STORE_new:near ; CODE XREF:	_setup_verify+2p
		extrn _X509_STORE_free:near ; CODE XREF: _setup_verify+4Fp
		extrn _X509_STORE_set_lookup_crls_cb:near
					; CODE XREF: _store_setup_crl_download+9p
		extrn _X509_STORE_add_lookup:near ; CODE XREF: _setup_verify+14p
					; _setup_verify+72p
		extrn _X509_LOOKUP_hash_dir:near ; CODE	XREF: _setup_verify:loc_4287p
		extrn _X509_LOOKUP_file:near ; CODE XREF: _setup_verify+Dp
		extrn _X509_LOOKUP_ctrl:near ; CODE XREF: _setup_verify+30p
					; _setup_verify+63p ...
		extrn _X509_STORE_CTX_get_current_cert:near ; CODE XREF: _crls_http_cb+7p
		extrn _X509_STORE_CTX_get0_policy_tree:near ; CODE XREF: _policies_print+2Dp
		extrn _X509_STORE_CTX_get_explicit_policy:near
					; CODE XREF: _policies_print+38p
		extrn _X509_VERIFY_PARAM_new:near ; CODE XREF: _args_verify+7EFp
		extrn _X509_VERIFY_PARAM_free:near ; CODE XREF:	_args_verify+7D7p
		extrn _X509_VERIFY_PARAM_set_flags:near	; CODE XREF: _args_verify+818p
		extrn _X509_VERIFY_PARAM_set_purpose:near ; CODE XREF: _args_verify+82Bp
		extrn _X509_VERIFY_PARAM_set_depth:near	; CODE XREF: _args_verify+83Ep
		extrn _X509_VERIFY_PARAM_set_time:near ; CODE XREF: _args_verify+858p
		extrn _X509_VERIFY_PARAM_add0_policy:near ; CODE XREF: _args_verify+809p
		extrn _X509_VERIFY_PARAM_set1_host:near	; CODE XREF: _args_verify+86Dp
		extrn _X509_VERIFY_PARAM_set1_email:near ; CODE	XREF: _args_verify+88Dp
		extrn _X509_VERIFY_PARAM_set1_ip_asc:near ; CODE XREF: _args_verify+8ABp
		extrn _X509_policy_tree_get0_policies:near ; CODE XREF:	_policies_print+59p
		extrn _X509_policy_tree_get0_user_policies:near
					; CODE XREF: _policies_print+6Bp
		extrn _X509_http_nbio:near ; CODE XREF:	_load_cert_crl_http+F2p
		extrn _X509_CRL_http_nbio:near ; CODE XREF: _load_cert_crl_http+109p
		extrn _d2i_X509_bio:near ; CODE	XREF: _load_cert+9Cp
		extrn _d2i_X509_CRL_bio:near ; CODE XREF: _load_crl+95p
		extrn _d2i_RSAPublicKey_bio:near ; CODE	XREF: _load_pubkey+150p
		extrn _d2i_PrivateKey_bio:near ; CODE XREF: _load_key+11Ep
		extrn _d2i_PUBKEY_bio:near ; CODE XREF:	_load_pubkey+104p
		extrn _X509_get_default_cert_area:near ; CODE XREF: _make_config_name+3p
		extrn _X509_EXTENSION_free:near	; CODE XREF: _copy_extensions+A4p
					; DATA XREF: _copy_extensions:$end$23o
		extrn _X509_NAME_new:near ; CODE XREF: _parse_name:loc_2F58p
		extrn _X509_NAME_free:near ; CODE XREF:	_parse_name+292p
		extrn _X509_free:near	; DATA XREF: _load_certs_crls+1BDo
		extrn _X509_CRL_free:near ; DATA XREF: _load_certs_crls+1D2o
		extrn _X509_INFO_free:near ; DATA XREF:	_load_certs_crls+1A3o
		extrn _X509_NAME_oneline:near ;	CODE XREF: _dump_cert_text+13p
					; _dump_cert_text+4Ap ...
		extrn _X509_get_issuer_name:near ; CODE	XREF: _dump_cert_text+41p
		extrn _X509_get_subject_name:near ; CODE XREF: _dump_cert_text+Ap
		extrn _X509_REQ_get_extensions:near ; CODE XREF: _copy_extensions+3Ap
		extrn _X509_NAME_print_ex:near ; CODE XREF: _print_name+81p
		extrn _X509_NAME_add_entry_by_NID:near ; CODE XREF: _parse_name+23Ap
		extrn _X509_get_ext_by_OBJ:near	; CODE XREF: _copy_extensions+79p
					; _copy_extensions+ADp
		extrn _X509_get_ext:near ; CODE	XREF: _copy_extensions+95p
		extrn _X509_delete_ext:near ; CODE XREF: _copy_extensions+9Ep
		extrn _X509_add_ext:near ; CODE	XREF: _copy_extensions+CBp
		extrn _X509_get_ext_d2i:near ; CODE XREF: _crls_http_cb+15p
					; _crls_http_cb+55p
		extrn _X509_EXTENSION_get_object:near ;	CODE XREF: _copy_extensions+6Cp
		extrn _NCONF_new:near	; CODE XREF: _load_index+AFp
		extrn _NCONF_free:near	; CODE XREF: _load_index+F1p
					; _load_index+173p
		extrn _NCONF_load:near	; CODE XREF: _load_index+C1p
		extrn _NCONF_get_section:near ;	CODE XREF: _add_oid_section+29p
		extrn _NCONF_get_string:near ; CODE XREF: _add_oid_section+Ep
					; _load_index+155p
		extrn _CONF_modules_load:near ;	CODE XREF: _load_config+36p
		extrn _OPENSSL_load_builtin_modules:near ; CODE	XREF: _load_config:loc_203Cp
		extrn _GENERAL_NAME_get0_value:near ; CODE XREF: _get_dp_url+40p
		extrn _DIST_POINT_free:near ; DATA XREF: _crls_http_cb+22o
					; _crls_http_cb+62o
		extrn _X509V3_conf_free:near ; DATA XREF: _set_multi_opts:loc_3FC5o
		extrn _X509V3_parse_list:near ;	CODE XREF: _set_multi_opts+22p
		extrn _X509_PURPOSE_get0:near ;	CODE XREF: _args_verify+134p
		extrn _X509_PURPOSE_get_by_sname:near ;	CODE XREF: _args_verify+103p
		extrn _X509_PURPOSE_get_id:near	; CODE XREF: _args_verify+13Ap
		extrn _X509_check_host:near ; CODE XREF: _print_cert_checks+29p
		extrn _X509_check_email:near ; CODE XREF: _print_cert_checks+59p
		extrn _X509_check_ip_asc:near ;	CODE XREF: _print_cert_checks+86p
		extrn _X509_POLICY_NODE_print:near ; CODE XREF:	_nodes_print+4Bp
		extrn _PEM_X509_INFO_read_bio:near ; CODE XREF:	_load_certs_crls+B0p
		extrn _PEM_read_bio_X509_AUX:near ; CODE XREF: _load_cert+14Ap
		extrn _PEM_read_bio_X509_CRL:near ; CODE XREF: _load_crl+D9p
		extrn _PEM_read_bio_RSAPublicKey:near ;	CODE XREF: _load_pubkey+197p
		extrn _PEM_read_bio_PrivateKey:near ; CODE XREF: _load_key+16Fp
		extrn _PEM_read_bio_PUBKEY:near	; CODE XREF: _load_pubkey+1BBp
		extrn _b2i_PrivateKey_bio:near ; CODE XREF: _load_key+1B9p
		extrn _b2i_PublicKey_bio:near ;	CODE XREF: _load_pubkey+1DBp
		extrn _b2i_PVK_bio:near	; CODE XREF: _load_key+1D7p
		extrn _PKCS12_verify_mac:near ;	CODE XREF: _load_pkcs12+96p
					; _load_pkcs12+A5p ...
		extrn _PKCS12_free:near	; CODE XREF: _load_pkcs12+13Fp
		extrn _PKCS12_parse:near ; CODE	XREF: _load_pkcs12+134p
		extrn _d2i_PKCS12_bio:near ; CODE XREF:	_load_pkcs12+6Cp
		extrn _UI_new_method:near ; CODE XREF: _password_callback+61p
		extrn _UI_free:near	; CODE XREF: _password_callback+9Fp
					; _password_callback+116p ...
		extrn _UI_add_input_string:near	; CODE XREF: _password_callback+D1p
		extrn _UI_add_verify_string:near ; CODE	XREF: _password_callback+141p
		extrn _UI_construct_prompt:near	; CODE XREF: _password_callback+7Cp
		extrn _UI_get0_user_data:near ;	CODE XREF: _ui_read+18p
					; _ui_read+34p	...
		extrn _UI_process:near	; CODE XREF: _password_callback+151p
		extrn _UI_ctrl:near	; CODE XREF: _password_callback+B8p
					; _password_callback+168p
		extrn _UI_OpenSSL:near	; CODE XREF: _ui_close+4p _ui_open+4p	...
		extrn _UI_create_method:near ; CODE XREF: _setup_ui_method+5p
		extrn _UI_destroy_method:near ;	CODE XREF: _destroy_ui_method+Ap
		extrn _UI_method_set_opener:near ; CODE	XREF: _setup_ui_method+15p
		extrn _UI_method_set_writer:near ; CODE	XREF: _setup_ui_method+35p
		extrn _UI_method_set_reader:near ; CODE	XREF: _setup_ui_method+25p
		extrn _UI_method_set_closer:near ; CODE	XREF: _setup_ui_method+45p
		extrn _UI_method_get_opener:near ; CODE	XREF: _ui_open+Ap
		extrn _UI_method_get_writer:near ; CODE	XREF: _ui_write+57p
		extrn _UI_method_get_reader:near ; CODE	XREF: _ui_read+62p
		extrn _UI_method_get_closer:near ; CODE	XREF: _ui_close+Ap
		extrn _UI_get_string_type:near ; CODE XREF: _ui_read+25p
					; _ui_write+25p
		extrn _UI_get_input_flags:near ; CODE XREF: _ui_read+7p
					; _ui_write+7p
		extrn _UI_set_result:near ; CODE XREF: _ui_read+4Ap
; HANDLE __stdcall GetStdHandle(DWORD nStdHandle)
		extrn __imp__GetStdHandle@4:near ; CODE	XREF: _raw_read_stdin+1Bp
					; _raw_write_stdout+1Bp
					; DATA XREF: ...
; BOOL __stdcall DeleteFileA(LPCSTR lpFileName)
		extrn __imp__DeleteFileA@4:near	; CODE XREF: _WIN32_rename+27p
					; DATA XREF: _WIN32_rename+27r
; BOOL __stdcall FindClose(HANDLE hFindFile)
		extrn __imp__FindClose@4:near ;	CODE XREF: _app_isdir+47p
					; DATA XREF: _app_isdir+47r
; HANDLE __stdcall FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA	lpFindFileData)
		extrn __imp__FindFirstFileA@8:near ; CODE XREF:	_app_isdir+24p
					; DATA XREF: _app_isdir+24r
; BOOL __stdcall ReadFile(HANDLE hFile,	LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
		extrn __imp__ReadFile@20:near ;	CODE XREF: _raw_read_stdin+22p
					; DATA XREF: _raw_read_stdin+22r
; BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite,	LPDWORD	lpNumberOfBytesWritten,	LPOVERLAPPED lpOverlapped)
		extrn __imp__WriteFile@20:near ; CODE XREF: _raw_write_stdout+22p
					; DATA XREF: _raw_write_stdout+22r
; DWORD	__stdcall GetLastError()
		extrn __imp__GetLastError@0:near ; CODE	XREF: _WIN32_rename+14p
					; _WIN32_rename:loc_498p
					; DATA XREF: ...
; BOOL __stdcall GetProcessTimes(HANDLE	hProcess, LPFILETIME lpCreationTime, LPFILETIME	lpExitTime, LPFILETIME lpKernelTime, LPFILETIME	lpUserTime)
		extrn __imp__GetProcessTimes@20:near ; CODE XREF: _app_tminterval+60p
					; DATA XREF: _app_tminterval+60r
; DWORD	__stdcall GetCurrentProcessId()
		extrn __imp__GetCurrentProcessId@0:near	; CODE XREF: _app_tminterval+27p
					; DATA XREF: _app_tminterval+27r
; HANDLE __stdcall OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)
		extrn __imp__OpenProcess@12:near ; CODE	XREF: _app_tminterval+35p
					; DATA XREF: _app_tminterval+35r
; void __stdcall GetSystemTime(LPSYSTEMTIME lpSystemTime)
		extrn __imp__GetSystemTime@4:near ; CODE XREF: _app_tminterval+93p
					; DATA XREF: _app_tminterval+93r
; BOOL __stdcall MoveFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName)
		extrn __imp__MoveFileA@8:near ;	CODE XREF: _WIN32_rename+Ap
					; _WIN32_rename+36p
					; DATA XREF: ...
; BOOL __stdcall SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime)
		extrn __imp__SystemTimeToFileTime@8:near ; CODE	XREF: _app_tminterval+A2p
					; DATA XREF: _app_tminterval+A2r
		extrn _ENGINE_by_id:near ; CODE	XREF: _setup_engine+5Ep
					; _try_load_engine+6p
		extrn _ENGINE_register_all_complete:near ; CODE	XREF: _setup_engine+52p
		extrn _ENGINE_ctrl:near	; CODE XREF: _setup_engine+AEp
		extrn _ENGINE_ctrl_cmd:near ; CODE XREF: _setup_engine+C8p
		extrn _ENGINE_ctrl_cmd_string:near ; CODE XREF:	_try_load_engine+20p
					; _try_load_engine+36p
		extrn _ENGINE_free:near	; CODE XREF: _setup_engine+F1p
					; _setup_engine+112p ...
		extrn _ENGINE_get_id:near ; CODE XREF: _setup_engine+100p
		extrn _ENGINE_load_private_key:near ; CODE XREF: _load_key+8Ap
		extrn _ENGINE_load_public_key:near ; CODE XREF:	_load_pubkey+88p
		extrn _ENGINE_set_default:near ; CODE XREF: _setup_engine+D3p
		extrn _TXT_DB_read:near	; CODE XREF: _load_index+86p
		extrn _TXT_DB_write:near ; CODE	XREF: _save_index+132p
		extrn _TXT_DB_create_index:near	; CODE XREF: _index_index+16p
					; _index_index+5Ep
		extrn _TXT_DB_free:near	; CODE XREF: _free_index+11p
					; _load_index+180p
		extrn _OCSP_REQ_CTX_new:near ; CODE XREF: _load_cert_crl_http+AEp
		extrn _OCSP_REQ_CTX_free:near ;	CODE XREF: _load_cert_crl_http+161p
		extrn _OCSP_REQ_CTX_http:near ;	CODE XREF: _load_cert_crl_http+C6p
		extrn _OCSP_REQ_CTX_add1_header:near ; CODE XREF: _load_cert_crl_http+DCp
		extrn _OCSP_parse_url:near ; CODE XREF:	_load_cert_crl_http+44p
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _app_get_pass+58p
					; _app_get_pass+1BDp ...
		extrn __chkstk:near	; CODE XREF: _app_get_pass+5p
					; _app_isdir+5p ...
		extrn __ltod3:near	; CODE XREF: _app_tminterval+E6p
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _password_callback+4Bp
; `__local_stdio_printf_options'::`2'::_OptionsStorage
		extrn ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:near
					; DATA XREF: ___local_stdio_printf_optionso
; `__local_stdio_scanf_options'::`2'::_OptionsStorage
		extrn ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:near
					; DATA XREF: ___local_stdio_scanf_optionso
		extrn _config:near	; DATA XREF: _load_config+22r
		extrn _bio_err:near	; DATA XREF: _app_tminterval+76r
					; _args_verify+22Er ...
		extrn ___security_cookie:near ;	DATA XREF: _app_get_pass+Ar
					; _app_isdir+Ar ...
		extrn __fltused:near


		end
