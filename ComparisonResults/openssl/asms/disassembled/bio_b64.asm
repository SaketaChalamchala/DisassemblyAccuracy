;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	94E1FA1CC725B3F6435D14A42451815A
; Input	CRC32 :	1053B0F6

; File Name   :	C:\compspace\Diff\openssl\obj\bio_b64.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl b64_write(int, void *Src,	size_t Size)
_b64_write	proc near		; CODE XREF: _b64_puts+1Fp
					; _b64_ctrl+D5p
					; DATA XREF: ...

arg_0		= dword	ptr  4
Src		= dword	ptr  8
Size		= dword	ptr  0Ch

		push	ebx
		mov	ebx, [esp+4+arg_0]
		push	ebp
		push	esi
		push	edi
		mov	esi, [ebx+20h]
		xor	ebp, ebp
		push	0Fh
		push	ebx
		call	_BIO_clear_flags
		add	esp, 8
		cmp	dword ptr [esi+10h], 1
		jz	short loc_39
		lea	eax, [esi+1Ch]
		mov	dword ptr [esi+10h], 1
		push	eax
		mov	[esi], ebp
		mov	[esi+4], ebp
		mov	[esi+8], ebp
		call	_EVP_EncodeInit
		add	esp, 4

loc_39:					; CODE XREF: _b64_write+1Cj
		cmp	dword ptr [esi+4], 5DEh
		jl	short loc_59
		push	offset ??_C@_0CF@ELLFOHKP@ctx?9?$DObuf_off?5?$DM?5?$CIint?$CJsizeof?$CIctx?9?$DO@ ; "ctx->buf_off < (int)sizeof(ctx->buf)"
		push	17Ah
		push	offset ??_C@_0BH@CICFIAAN@?4?2crypto?2evp?2bio_b64?4c?$AA@ ; ".\\crypto\\evp\\bio_b64.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_59:					; CODE XREF: _b64_write+40j
		cmp	dword ptr [esi], 5DEh
		jle	short loc_78
		push	offset ??_C@_0CG@LFOFKIIN@ctx?9?$DObuf_len?5?$DM?$DN?5?$CIint?$CJsizeof?$CIctx?9@ ; "ctx->buf_len <= (int)sizeof(ctx->buf)"
		push	17Bh
		push	offset ??_C@_0BH@CICFIAAN@?4?2crypto?2evp?2bio_b64?4c?$AA@ ; ".\\crypto\\evp\\bio_b64.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_78:					; CODE XREF: _b64_write+5Fj
		mov	eax, [esi]
		cmp	eax, [esi+4]
		jge	short loc_96
		push	offset ??_C@_0BN@FPMDFEFM@ctx?9?$DObuf_len?5?$DO?$DN?5ctx?9?$DObuf_off?$AA@ ; "ctx->buf_len >= ctx->buf_off"
		push	17Ch
		push	offset ??_C@_0BH@CICFIAAN@?4?2crypto?2evp?2bio_b64?4c?$AA@ ; ".\\crypto\\evp\\bio_b64.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_96:					; CODE XREF: _b64_write+7Dj
		mov	edi, [esi]
		sub	edi, [esi+4]
		test	edi, edi
		jle	loc_12C

loc_A3:					; CODE XREF: _b64_write+126j
		mov	eax, [esi+4]
		add	eax, 7Ch ; '|'
		push	edi
		add	eax, esi
		push	eax
		push	dword ptr [ebx+24h]
		call	_BIO_write
		mov	ebx, eax
		add	esp, 0Ch
		test	ebx, ebx
		jle	loc_227
		cmp	ebx, edi
		jle	short loc_DD
		push	offset ??_C@_06NOLCFJLD@i?5?$DM?$DN?5n?$AA@ ; "i <= n"
		push	184h
		push	offset ??_C@_0BH@CICFIAAN@?4?2crypto?2evp?2bio_b64?4c?$AA@ ; ".\\crypto\\evp\\bio_b64.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_DD:					; CODE XREF: _b64_write+C4j
		add	[esi+4], ebx
		cmp	dword ptr [esi+4], 5DEh
		jle	short loc_100
		push	offset ??_C@_0CG@NALBBCEM@ctx?9?$DObuf_off?5?$DM?$DN?5?$CIint?$CJsizeof?$CIctx?9@ ; "ctx->buf_off <= (int)sizeof(ctx->buf)"
		push	186h
		push	offset ??_C@_0BH@CICFIAAN@?4?2crypto?2evp?2bio_b64?4c?$AA@ ; ".\\crypto\\evp\\bio_b64.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_100:				; CODE XREF: _b64_write+E7j
		mov	eax, [esi]
		cmp	eax, [esi+4]
		jge	short loc_11E
		push	offset ??_C@_0BN@FPMDFEFM@ctx?9?$DObuf_len?5?$DO?$DN?5ctx?9?$DObuf_off?$AA@ ; "ctx->buf_len >= ctx->buf_off"
		push	187h
		push	offset ??_C@_0BH@CICFIAAN@?4?2crypto?2evp?2bio_b64?4c?$AA@ ; ".\\crypto\\evp\\bio_b64.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_11E:				; CODE XREF: _b64_write+105j
		sub	edi, ebx
		mov	ebx, [esp+10h+arg_0]
		test	edi, edi
		jg	loc_A3

loc_12C:				; CODE XREF: _b64_write+9Dj
		mov	[esi+4], ebp
		mov	[esi], ebp
		cmp	[esp+10h+Src], ebp
		jz	loc_3E3
		mov	ebx, [esp+10h+Size]
		test	ebx, ebx
		jle	loc_3E3

loc_147:				; CODE XREF: _b64_write+3A6j
		mov	eax, 400h
		mov	edi, ebx
		cmp	ebx, eax
		push	0FFFFFFFFh
		push	[esp+14h+arg_0]
		cmovg	edi, eax
		call	_BIO_test_flags
		add	esp, 8
		test	eax, 100h
		jz	loc_298
		mov	eax, [esi+8]
		test	eax, eax
		jle	loc_23A
		cmp	eax, 3
		jle	short loc_193
		push	offset ??_C@_0BC@BEKEPBME@ctx?9?$DOtmp_len?5?$DM?$DN?53?$AA@ ; "ctx->tmp_len <=	3"
		push	196h
		push	offset ??_C@_0BH@CICFIAAN@?4?2crypto?2evp?2bio_b64?4c?$AA@ ; ".\\crypto\\evp\\bio_b64.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_193:				; CODE XREF: _b64_write+17Aj
		mov	eax, [esi+8]
		mov	edi, 3
		sub	edi, [esi+8]
		cmp	edi, ebx
		cmovg	edi, ebx
		add	eax, 65Ah
		push	edi		; Size
		push	[esp+14h+Src]	; Src
		add	eax, esi
		push	eax		; Dst
		call	_memcpy
		add	[esi+8], edi
		add	esp, 0Ch
		mov	eax, [esi+8]
		add	ebp, edi
		cmp	eax, 3
		jl	loc_3DC
		push	eax
		lea	eax, [esi+65Ah]
		push	eax
		lea	eax, [esi+7Ch]
		push	eax
		call	_EVP_EncodeBlock
		add	esp, 0Ch
		mov	[esi], eax
		cmp	eax, 5DEh
		jle	short loc_1FD
		push	offset ??_C@_0CG@LFOFKIIN@ctx?9?$DObuf_len?5?$DM?$DN?5?$CIint?$CJsizeof?$CIctx?9@ ; "ctx->buf_len <= (int)sizeof(ctx->buf)"
		push	1A5h
		push	offset ??_C@_0BH@CICFIAAN@?4?2crypto?2evp?2bio_b64?4c?$AA@ ; ".\\crypto\\evp\\bio_b64.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_1FD:				; CODE XREF: _b64_write+1E4j
		mov	eax, [esi]
		cmp	eax, [esi+4]
		jge	short loc_21B
		push	offset ??_C@_0BN@FPMDFEFM@ctx?9?$DObuf_len?5?$DO?$DN?5ctx?9?$DObuf_off?$AA@ ; "ctx->buf_len >= ctx->buf_off"

loc_209:				; DATA XREF: .data:_methods_b64o
		push	1A6h
		push	offset ??_C@_0BH@CICFIAAN@?4?2crypto?2evp?2bio_b64?4c?$AA@ ; ".\\crypto\\evp\\bio_b64.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_21B:				; CODE XREF: _b64_write+202j
		mov	dword ptr [esi+8], 0
		jmp	loc_2ED
; ---------------------------------------------------------------------------

loc_227:				; CODE XREF: _b64_write+BCj
		push	[esp+10h+arg_0]
		call	_BIO_copy_next_retry
		add	esp, 4
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_23A:				; CODE XREF: _b64_write+171j
		cmp	edi, 3
		jl	loc_3AB
		mov	eax, 55555556h
		imul	edi
		mov	eax, edx
		shr	eax, 1Fh
		add	eax, edx
		lea	edi, [eax+eax*2]
		push	edi
		push	[esp+14h+Src]
		lea	eax, [esi+7Ch]
		push	eax
		call	_EVP_EncodeBlock
		add	esp, 0Ch
		mov	[esi], eax
		cmp	eax, 5DEh
		jle	short loc_285
		push	offset ??_C@_0CG@LFOFKIIN@ctx?9?$DObuf_len?5?$DM?$DN?5?$CIint?$CJsizeof?$CIctx?9@ ; "ctx->buf_len <= (int)sizeof(ctx->buf)"
		push	1B7h
		push	offset ??_C@_0BH@CICFIAAN@?4?2crypto?2evp?2bio_b64?4c?$AA@ ; ".\\crypto\\evp\\bio_b64.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_285:				; CODE XREF: _b64_write+26Cj
		mov	eax, [esi]
		cmp	eax, [esi+4]
		jge	short loc_2EB
		push	offset ??_C@_0BN@FPMDFEFM@ctx?9?$DObuf_len?5?$DO?$DN?5ctx?9?$DObuf_off?$AA@ ; "ctx->buf_len >= ctx->buf_off"
		push	1B8h
		jmp	short loc_2DE
; ---------------------------------------------------------------------------

loc_298:				; CODE XREF: _b64_write+166j
		push	edi
		push	[esp+14h+Src]
		lea	eax, [esi+7Ch]
		push	esi
		push	eax
		lea	eax, [esi+1Ch]
		push	eax
		call	_EVP_EncodeUpdate
		add	esp, 14h
		cmp	dword ptr [esi], 5DEh
		jle	short loc_2CD
		push	offset ??_C@_0CG@LFOFKIIN@ctx?9?$DObuf_len?5?$DM?$DN?5?$CIint?$CJsizeof?$CIctx?9@ ; "ctx->buf_len <= (int)sizeof(ctx->buf)"
		push	1BFh
		push	offset ??_C@_0BH@CICFIAAN@?4?2crypto?2evp?2bio_b64?4c?$AA@ ; ".\\crypto\\evp\\bio_b64.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_2CD:				; CODE XREF: _b64_write+2B4j
		mov	eax, [esi]
		cmp	eax, [esi+4]
		jge	short loc_2EB
		push	offset ??_C@_0BN@FPMDFEFM@ctx?9?$DObuf_len?5?$DO?$DN?5ctx?9?$DObuf_off?$AA@ ; "ctx->buf_len >= ctx->buf_off"
		push	1C0h

loc_2DE:				; CODE XREF: _b64_write+296j
		push	offset ??_C@_0BH@CICFIAAN@?4?2crypto?2evp?2bio_b64?4c?$AA@ ; ".\\crypto\\evp\\bio_b64.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_2EB:				; CODE XREF: _b64_write+28Aj
					; _b64_write+2D2j
		add	ebp, edi

loc_2ED:				; CODE XREF: _b64_write+222j
		add	[esp+10h+Src], edi
		sub	ebx, edi
		mov	edi, [esi]
		mov	[esp+10h+Size],	ebx
		mov	dword ptr [esi+4], 0
		test	edi, edi
		jle	loc_395

loc_308:				; CODE XREF: _b64_write+38Bj
		mov	eax, [esi+4]
		add	eax, 7Ch ; '|'
		add	eax, esi
		push	edi
		push	eax
		mov	eax, [esp+18h+arg_0]
		push	dword ptr [eax+24h]
		call	_BIO_write
		mov	ebx, eax
		add	esp, 0Ch
		test	ebx, ebx
		jle	loc_3CB
		cmp	ebx, edi
		jle	short loc_346
		push	offset ??_C@_06NOLCFJLD@i?5?$DM?$DN?5n?$AA@ ; "i <= n"
		push	1CEh
		push	offset ??_C@_0BH@CICFIAAN@?4?2crypto?2evp?2bio_b64?4c?$AA@ ; ".\\crypto\\evp\\bio_b64.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_346:				; CODE XREF: _b64_write+32Dj
		add	[esi+4], ebx
		sub	edi, ebx
		cmp	dword ptr [esi+4], 5DEh
		jle	short loc_36B
		push	offset ??_C@_0CG@NALBBCEM@ctx?9?$DObuf_off?5?$DM?$DN?5?$CIint?$CJsizeof?$CIctx?9@ ; "ctx->buf_off <= (int)sizeof(ctx->buf)"
		push	1D1h
		push	offset ??_C@_0BH@CICFIAAN@?4?2crypto?2evp?2bio_b64?4c?$AA@ ; ".\\crypto\\evp\\bio_b64.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_36B:				; CODE XREF: _b64_write+352j
		mov	eax, [esi]
		cmp	eax, [esi+4]
		jge	short loc_389
		push	offset ??_C@_0BN@FPMDFEFM@ctx?9?$DObuf_len?5?$DO?$DN?5ctx?9?$DObuf_off?$AA@ ; "ctx->buf_len >= ctx->buf_off"
		push	1D2h
		push	offset ??_C@_0BH@CICFIAAN@?4?2crypto?2evp?2bio_b64?4c?$AA@ ; ".\\crypto\\evp\\bio_b64.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_389:				; CODE XREF: _b64_write+370j
		test	edi, edi
		jg	loc_308
		mov	ebx, [esp+10h+Size]

loc_395:				; CODE XREF: _b64_write+302j
		mov	dword ptr [esi], 0
		mov	dword ptr [esi+4], 0
		test	ebx, ebx
		jle	short loc_3DC
		jmp	loc_147
; ---------------------------------------------------------------------------

loc_3AB:				; CODE XREF: _b64_write+23Dj
		push	edi		; Size
		push	[esp+14h+Src]	; Src
		lea	eax, [esi+65Ah]
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	[esi+8], edi
		add	ebp, edi
		mov	eax, ebp
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_3CB:				; CODE XREF: _b64_write+325j
		push	[esp+10h+arg_0]
		call	_BIO_copy_next_retry
		add	esp, 4
		test	ebp, ebp
		cmovz	ebp, ebx

loc_3DC:				; CODE XREF: _b64_write+1C3j
					; _b64_write+3A4j
		pop	edi
		pop	esi
		mov	eax, ebp
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_3E3:				; CODE XREF: _b64_write+135j
					; _b64_write+141j
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
_b64_write	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3ECh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl b64_read(int, void *Dst, size_t Size)
_b64_read	proc near		; DATA XREF: .data:00000AF4o

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
Dst		= dword	ptr  8
Size		= dword	ptr  0Ch

		mov	eax, 14h
		call	__chkstk
		push	ebx
		xor	ebx, ebx
		mov	[esp+18h+var_14], ebx
		cmp	[esp+18h+Dst], ebx
		jnz	short loc_40A
		xor	eax, eax
		pop	ebx
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_40A:				; CODE XREF: _b64_read+15j
		push	ebp
		mov	ebp, [esp+1Ch+arg_0]
		push	esi
		mov	esi, [ebp+20h]
		test	esi, esi
		jz	loc_7E2
		cmp	[ebp+24h], ebx
		jz	loc_7E2
		push	0Fh
		push	ebp
		call	_BIO_clear_flags
		add	esp, 8
		cmp	dword ptr [esi+10h], 2
		jz	short loc_450
		lea	eax, [esi+1Ch]
		mov	dword ptr [esi+10h], 2
		push	eax
		mov	[esi], ebx
		mov	[esi+4], ebx
		mov	[esi+8], ebx
		call	_EVP_DecodeInit
		add	esp, 4

loc_450:				; CODE XREF: _b64_read+47j
		mov	eax, [esi]
		push	edi
		test	eax, eax
		jle	loc_4E5
		cmp	eax, [esi+4]
		jge	short loc_477
		push	offset ??_C@_0BN@FPMDFEFM@ctx?9?$DObuf_len?5?$DO?$DN?5ctx?9?$DObuf_off?$AA@ ; "ctx->buf_len >= ctx->buf_off"
		push	0ADh ; '­'
		push	offset ??_C@_0BH@CICFIAAN@?4?2crypto?2evp?2bio_b64?4c?$AA@ ; ".\\crypto\\evp\\bio_b64.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_477:				; CODE XREF: _b64_read+72j
		mov	ebx, [esi]
		sub	ebx, [esi+4]
		mov	edi, [esp+24h+Size]
		cmp	ebx, edi
		mov	eax, [esi+4]
		cmovg	ebx, edi
		add	eax, ebx
		mov	[esp+24h+var_14], ebx
		cmp	eax, 5DEh
		jl	short loc_4AC
		push	offset ??_C@_0CJ@PHNBKJJG@ctx?9?$DObuf_off?5?$CL?5i?5?$DM?5?$CIint?$CJsizeof?$CIc@ ; "ctx->buf_off + i < (int)sizeof(ctx->buf"...
		push	0B1h ; '±'
		push	offset ??_C@_0BH@CICFIAAN@?4?2crypto?2evp?2bio_b64?4c?$AA@ ; ".\\crypto\\evp\\bio_b64.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_4AC:				; CODE XREF: _b64_read+A7j
		mov	eax, [esi+4]
		add	eax, 7Ch ; '|'
		push	ebx		; Size
		add	eax, esi
		push	eax		; Src
		push	[esp+2Ch+Dst]	; Dst
		call	_memcpy
		add	[esi+4], ebx
		sub	edi, ebx
		add	[esp+30h+Dst], ebx
		add	esp, 0Ch
		mov	eax, [esi+4]
		mov	[esp+24h+var_10], edi
		cmp	[esi], eax
		jnz	short loc_4ED
		mov	dword ptr [esi], 0
		mov	dword ptr [esi+4], 0
		jmp	short loc_4ED
; ---------------------------------------------------------------------------

loc_4E5:				; CODE XREF: _b64_read+69j
		mov	edi, [esp+24h+Size]
		mov	[esp+24h+var_10], edi

loc_4ED:				; CODE XREF: _b64_read+E8j
					; _b64_read+F7j
		mov	[esp+24h+var_4], 0
		test	edi, edi
		jle	loc_7C8

loc_4FD:				; CODE XREF: _b64_read+3BEj
		cmp	dword ptr [esi+18h], 0
		jle	loc_7C4
		mov	eax, 400h
		sub	eax, [esi+8]
		push	eax
		lea	eax, [esi+65Ah]
		add	eax, [esi+8]
		push	eax
		push	dword ptr [ebp+24h]
		call	_BIO_read
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jg	short loc_552
		push	8
		push	dword ptr [ebp+24h]
		mov	[esp+2Ch+var_4], edi
		call	_BIO_test_flags
		add	esp, 8
		test	eax, eax
		jnz	loc_7C4
		mov	[esi+18h], edi
		cmp	[esi+8], eax
		jz	loc_7C4
		xor	edi, edi

loc_552:				; CODE XREF: _b64_read+13Dj
		add	[esi+8], edi
		cmp	dword ptr [esi+14h], 0
		mov	ebp, [esi+8]
		jz	loc_6AF
		push	0FFFFFFFFh
		push	[esp+28h+arg_0]
		call	_BIO_test_flags
		add	esp, 8
		test	eax, 100h
		jz	short loc_583

loc_577:				; CODE XREF: _b64_read+26Aj
					; _b64_read+275j
		mov	dword ptr [esi+8], 0
		jmp	loc_6C1
; ---------------------------------------------------------------------------

loc_583:				; CODE XREF: _b64_read+189j
		cmp	dword ptr [esi+14h], 0
		jz	loc_6AF
		lea	edx, [esi+65Ah]
		mov	[esp+24h+var_8], 0
		xor	ecx, ecx
		mov	ebx, edx
		mov	[esp+24h+var_C], ecx
		mov	edi, ebx
		test	ebp, ebp
		jle	loc_654

loc_5AD:				; CODE XREF: _b64_read+21Cj
		mov	al, [edi]
		inc	edi
		cmp	al, 0Ah
		jnz	short loc_601
		cmp	dword ptr [esi+0Ch], 0
		jz	short loc_5C3
		mov	dword ptr [esi+0Ch], 0
		jmp	short loc_5FF
; ---------------------------------------------------------------------------

loc_5C3:				; CODE XREF: _b64_read+1CCj
		mov	eax, edi
		lea	ecx, [esi+1Ch]
		sub	eax, ebx
		push	eax
		push	ebx
		lea	eax, [esp+2Ch+var_8]
		push	eax
		lea	eax, [esi+7Ch]
		push	eax
		push	ecx
		call	_EVP_DecodeUpdate
		add	esp, 14h
		test	eax, eax
		jg	short loc_60C
		cmp	[esp+24h+var_8], 0
		jnz	short loc_60C
		cmp	dword ptr [esi+14h], 0
		jz	short loc_60C
		lea	eax, [esi+1Ch]
		push	eax
		call	_EVP_DecodeInit
		mov	ecx, [esp+28h+var_C]
		add	esp, 4

loc_5FF:				; CODE XREF: _b64_read+1D5j
		mov	ebx, edi

loc_601:				; CODE XREF: _b64_read+1C6j
		inc	ecx
		mov	[esp+24h+var_C], ecx
		cmp	ecx, ebp
		jl	short loc_5AD
		jmp	short loc_64E
; ---------------------------------------------------------------------------

loc_60C:				; CODE XREF: _b64_read+1F4j
					; _b64_read+1FBj ...
		lea	edx, [esi+65Ah]
		cmp	ebx, edx
		jz	short loc_637
		mov	eax, esi
		add	ebp, 65Ah
		sub	eax, ebx
		xor	ecx, ecx
		add	ebp, eax
		test	ebp, ebp
		jle	short loc_637
		nop	dword ptr [eax+00h]

loc_62C:				; CODE XREF: _b64_read+249j
		mov	al, [ecx+ebx]
		mov	[edx+ecx], al
		inc	ecx
		cmp	ecx, ebp
		jl	short loc_62C

loc_637:				; CODE XREF: _b64_read+228j
					; _b64_read+23Aj
		lea	eax, [esi+1Ch]
		push	eax
		call	_EVP_DecodeInit
		mov	ecx, [esp+28h+var_C]
		add	esp, 4
		mov	dword ptr [esi+14h], 0

loc_64E:				; CODE XREF: _b64_read+21Ej
		lea	edx, [esi+65Ah]

loc_654:				; CODE XREF: _b64_read+1BBj
		cmp	ecx, ebp
		jnz	loc_577
		cmp	[esp+24h+var_8], 0
		jnz	loc_577
		cmp	ebx, edx
		jnz	short loc_68A
		cmp	ebp, 400h
		jnz	loc_7A1
		mov	dword ptr [esi+0Ch], 1
		mov	dword ptr [esi+8], 0
		jmp	loc_7A1
; ---------------------------------------------------------------------------

loc_68A:				; CODE XREF: _b64_read+27Dj
		cmp	ebx, edi
		jz	loc_7A1
		sub	edi, ebx
		xor	ecx, ecx
		test	edi, edi
		jle	short loc_6A7
		xchg	ax, ax

loc_69C:				; CODE XREF: _b64_read+2B9j
		mov	al, [ecx+ebx]
		mov	[edx+ecx], al
		inc	ecx
		cmp	ecx, edi
		jl	short loc_69C

loc_6A7:				; CODE XREF: _b64_read+2ACj
		mov	[esi+8], edi
		jmp	loc_7A1
; ---------------------------------------------------------------------------

loc_6AF:				; CODE XREF: _b64_read+170j
					; _b64_read+19Bj
		cmp	ebp, 400h
		jge	short loc_6C1
		cmp	dword ptr [esi+18h], 0
		jg	loc_7A1

loc_6C1:				; CODE XREF: _b64_read+192j
					; _b64_read+2C9j
		push	0FFFFFFFFh
		push	[esp+28h+arg_0]
		call	_BIO_test_flags
		add	esp, 8
		test	eax, 100h
		jz	short loc_735
		mov	edi, ebp
		lea	ecx, [esi+65Ah]
		and	edi, 0FFFFFFFCh
		lea	eax, [esi+7Ch]
		push	edi
		push	ecx
		push	eax
		call	_EVP_DecodeBlock
		add	esp, 0Ch
		mov	ebx, eax
		cmp	edi, 2
		jle	short loc_70C
		cmp	byte ptr [edi+esi+659h], 3Dh ; '='
		jnz	short loc_70C
		dec	ebx
		cmp	byte ptr [edi+esi+658h], 3Dh ; '='
		jnz	short loc_70C
		dec	ebx

loc_70C:				; CODE XREF: _b64_read+308j
					; _b64_read+312j ...
		cmp	edi, ebp
		jz	short loc_72A
		lea	ecx, [esi+65Ah]
		sub	ebp, edi
		push	ebp		; Size
		lea	eax, [ecx+edi]
		push	eax		; Src
		push	ecx		; Dst
		call	dword ptr ds:__imp__memmove
		add	esp, 0Ch
		mov	[esi+8], ebp

loc_72A:				; CODE XREF: _b64_read+322j
		xor	eax, eax
		test	ebx, ebx
		cmovg	eax, ebx
		mov	[esi], eax
		jmp	short loc_757
; ---------------------------------------------------------------------------

loc_735:				; CODE XREF: _b64_read+2E8j
		push	ebp
		lea	eax, [esi+65Ah]
		push	eax
		lea	ecx, [esi+7Ch]
		push	esi
		push	ecx
		lea	eax, [esi+1Ch]
		push	eax
		call	_EVP_DecodeUpdate
		add	esp, 14h
		mov	dword ptr [esi+8], 0
		mov	ebx, eax

loc_757:				; CODE XREF: _b64_read+347j
		mov	dword ptr [esi+4], 0
		test	ebx, ebx
		js	short loc_7B2
		mov	eax, [esi]
		mov	edi, [esp+24h+var_10]
		cmp	eax, edi
		mov	ebx, [esp+24h+Dst]
		cmovle	edi, eax
		lea	eax, [esi+7Ch]
		push	edi		; Size
		push	eax		; Src
		push	ebx		; Dst
		call	_memcpy
		add	[esp+30h+var_14], edi
		add	esp, 0Ch
		mov	[esi+4], edi
		cmp	edi, [esi]
		jnz	short loc_797
		mov	dword ptr [esi], 0
		mov	dword ptr [esi+4], 0

loc_797:				; CODE XREF: _b64_read+39Cj
		sub	[esp+24h+var_10], edi
		add	ebx, edi
		mov	[esp+24h+Dst], ebx

loc_7A1:				; CODE XREF: _b64_read+285j
					; _b64_read+299j ...
		cmp	[esp+24h+var_10], 0
		mov	ebp, [esp+24h+arg_0]
		jg	loc_4FD
		jmp	short loc_7C4
; ---------------------------------------------------------------------------

loc_7B2:				; CODE XREF: _b64_read+374j
		mov	ebp, [esp+24h+arg_0]
		mov	[esp+24h+var_4], 0
		mov	dword ptr [esi], 0

loc_7C4:				; CODE XREF: _b64_read+115j
					; _b64_read+152j ...
		mov	ebx, [esp+24h+var_14]

loc_7C8:				; CODE XREF: _b64_read+10Bj
		push	ebp
		call	_BIO_copy_next_retry
		add	esp, 4
		test	ebx, ebx
		cmovz	ebx, [esp+24h+var_4]
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_7E2:				; CODE XREF: _b64_read+29j
					; _b64_read+32j
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		add	esp, 14h
		retn
_b64_read	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7ECh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl b64_puts(int, void *Src)
_b64_puts	proc near		; DATA XREF: .data:00000AF8o

arg_0		= dword	ptr  4
Src		= dword	ptr  8

		mov	edx, [esp+Src]
		mov	eax, edx
		push	esi
		lea	esi, [eax+1]
		nop	word ptr [eax+eax+00h]

loc_7FC:				; CODE XREF: _b64_puts+15j
		mov	cl, [eax]
		inc	eax
		test	cl, cl
		jnz	short loc_7FC
		sub	eax, esi
		push	eax		; Size
		push	edx		; Src
		push	[esp+0Ch+arg_0]	; int
		call	_b64_write
		add	esp, 0Ch
		pop	esi
		retn
_b64_puts	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 818h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_b64_ctrl	proc near		; DATA XREF: .data:00000B00o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	ebx
		push	ebp
		mov	ebp, [esp+8+arg_4]
		mov	ebx, 1
		push	esi
		push	edi
		mov	edi, [esp+10h+arg_0]
		lea	eax, [ebp-1]	; switch 101 cases
		mov	esi, [edi+20h]
		cmp	eax, 64h ; 'd'
		ja	short $LN24	; jumptable 0000083B default case
		movzx	eax, ds:$LN45[eax]
		jmp	ds:$LN49[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN6:					; CODE XREF: _b64_ctrl+23j
					; DATA XREF: .text$mn:$LN49o
		mov	[esi+18h], ebx	; jumptable 0000083B case 1
		mov	[esi+14h], ebx
		mov	dword ptr [esi+10h], 0

$LN24:					; CODE XREF: _b64_ctrl+1Aj
					; _b64_ctrl+23j ...
		push	[esp+10h+arg_C]	; jumptable 0000083B default case
		push	[esp+14h+arg_8]
		push	ebp
		push	dword ptr [edi+24h]
		call	_BIO_ctrl
		mov	ebx, eax
		add	esp, 10h

$LN2:					; CODE XREF: _b64_ctrl+23j
					; _b64_ctrl+58j ...
		mov	eax, ebx	; jumptable 0000083B case 12

loc_867:				; CODE XREF: _b64_ctrl+DFj
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN7:					; CODE XREF: _b64_ctrl+23j
					; DATA XREF: .text$mn:$LN49o
		cmp	dword ptr [esi+18h], 0 ; jumptable 0000083B case 2
		jle	short $LN2	; jumptable 0000083B case 12
		jmp	short $LN24	; jumptable 0000083B default case
; ---------------------------------------------------------------------------

$LN10:					; CODE XREF: _b64_ctrl+23j
					; DATA XREF: .text$mn:$LN49o
		mov	eax, [esi]	; jumptable 0000083B case 13
		cmp	eax, [esi+4]
		jge	short loc_892
		push	offset ??_C@_0BN@FPMDFEFM@ctx?9?$DObuf_len?5?$DO?$DN?5ctx?9?$DObuf_off?$AA@ ; "ctx->buf_len >= ctx->buf_off"
		push	1F0h
		push	offset ??_C@_0BH@CICFIAAN@?4?2crypto?2evp?2bio_b64?4c?$AA@ ; ".\\crypto\\evp\\bio_b64.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_892:				; CODE XREF: _b64_ctrl+61j
		mov	ebx, [esi]
		sub	ebx, [esi+4]
		jnz	short loc_8D2
		cmp	[esi+10h], ebx
		jz	short $LN24	; jumptable 0000083B default case
		cmp	[esi+1Ch], ebx
		jz	short $LN24	; jumptable 0000083B default case
		pop	edi
		pop	esi
		mov	ebx, 1
		pop	ebp
		mov	eax, ebx
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN14:					; CODE XREF: _b64_ctrl+23j
					; DATA XREF: .text$mn:$LN49o
		mov	eax, [esi]	; jumptable 0000083B case 10
		cmp	eax, [esi+4]
		jge	short loc_8CD
		push	offset ??_C@_0BN@FPMDFEFM@ctx?9?$DObuf_len?5?$DO?$DN?5ctx?9?$DObuf_off?$AA@ ; "ctx->buf_len >= ctx->buf_off"
		push	1F9h
		push	offset ??_C@_0BH@CICFIAAN@?4?2crypto?2evp?2bio_b64?4c?$AA@ ; ".\\crypto\\evp\\bio_b64.c"
		call	_OpenSSLDie
		add	esp, 0Ch

loc_8CD:				; CODE XREF: _b64_ctrl+9Cj
		mov	ebx, [esi]
		sub	ebx, [esi+4]

loc_8D2:				; CODE XREF: _b64_ctrl+7Fj
		test	ebx, ebx
		jg	short $LN2	; jumptable 0000083B case 12
		jmp	$LN24		; jumptable 0000083B default case
; ---------------------------------------------------------------------------

$again$50:				; CODE XREF: _b64_ctrl+23j
					; _b64_ctrl+12Dj ...
		mov	eax, [esi]	; jumptable 0000083B case 11
		cmp	eax, [esi+4]
		jz	short loc_904
		nop	word ptr [eax+eax+00h]

loc_8E8:				; CODE XREF: _b64_ctrl+EAj
		push	0		; Size
		push	0		; Src
		push	edi		; int
		call	_b64_write
		add	esp, 0Ch
		test	eax, eax
		js	loc_867
		mov	eax, [esi]
		cmp	eax, [esi+4]
		jnz	short loc_8E8

loc_904:				; CODE XREF: _b64_ctrl+C8j
		push	0FFFFFFFFh
		push	edi
		call	_BIO_test_flags
		add	esp, 8
		test	eax, 100h
		jz	short loc_947
		mov	eax, [esi+8]
		test	eax, eax
		jz	$LN24		; jumptable 0000083B default case
		push	eax
		lea	eax, [esi+65Ah]
		push	eax
		lea	eax, [esi+7Ch]
		push	eax
		call	_EVP_EncodeBlock
		add	esp, 0Ch
		mov	[esi], eax
		mov	dword ptr [esi+4], 0
		mov	dword ptr [esi+8], 0
		jmp	short $again$50	; jumptable 0000083B case 11
; ---------------------------------------------------------------------------

loc_947:				; CODE XREF: _b64_ctrl+FCj
		cmp	dword ptr [esi+10h], 0
		jz	$LN24		; jumptable 0000083B default case
		cmp	dword ptr [esi+1Ch], 0
		lea	ecx, [esi+1Ch]
		jz	$LN24		; jumptable 0000083B default case
		push	esi
		lea	eax, [esi+7Ch]
		mov	dword ptr [esi+4], 0
		push	eax
		push	ecx
		call	_EVP_EncodeFinal
		add	esp, 0Ch
		jmp	$again$50	; jumptable 0000083B case 11
; ---------------------------------------------------------------------------

$LN22:					; CODE XREF: _b64_ctrl+23j
					; DATA XREF: .text$mn:$LN49o
		push	0Fh		; jumptable 0000083B case 101
		push	edi
		call	_BIO_clear_flags
		push	[esp+18h+arg_C]
		push	[esp+1Ch+arg_8]
		push	ebp
		push	dword ptr [edi+24h]
		call	_BIO_ctrl
		push	edi
		mov	ebx, eax
		call	_BIO_copy_next_retry
		add	esp, 1Ch
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_b64_ctrl	endp

; ---------------------------------------------------------------------------
		align 4
$LN49		dd offset $LN6,	offset $LN7, offset $LN14, offset $again$50
					; DATA XREF: _b64_ctrl+23r
		dd offset $LN2,	offset $LN10, offset $LN22, offset $LN24 ; jump	table for switch statement
$LN45		db	0,     1,     7,     7 ; DATA XREF: _b64_ctrl+1Cr
		db	7,     7,     7,     7 ; indirect table	for switch statement
		db	7,     2,     3,     4
		db	5,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	7,     7,     7,     7
		db	6
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A2Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_b64_new	proc near		; DATA XREF: .data:00000B04o

arg_0		= dword	ptr  4

		push	76h ; 'v'
		push	offset ??_C@_0BH@CICFIAAN@?4?2crypto?2evp?2bio_b64?4c?$AA@ ; ".\\crypto\\evp\\bio_b64.c"
		push	0A5Ch
		call	_CRYPTO_malloc
		mov	ecx, eax
		add	esp, 0Ch
		test	ecx, ecx
		jnz	short loc_A47
		retn
; ---------------------------------------------------------------------------

loc_A47:				; CODE XREF: _b64_new+18j
		mov	eax, [esp+arg_0]
		mov	dword ptr [ecx], 0
		mov	dword ptr [ecx+8], 0
		mov	dword ptr [ecx+0Ch], 0
		mov	dword ptr [ecx+4], 0
		mov	dword ptr [ecx+18h], 1
		mov	dword ptr [ecx+14h], 1
		mov	dword ptr [ecx+10h], 0
		mov	dword ptr [eax+0Ch], 1
		mov	[eax+20h], ecx
		mov	dword ptr [eax+14h], 0
		mov	dword ptr [eax+1Ch], 0
		mov	eax, 1
		retn
_b64_new	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A9Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_b64_free	proc near		; DATA XREF: .data:00000B08o

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jnz	short loc_AA9
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_AA9:				; CODE XREF: _b64_free+7j
		push	dword ptr [esi+20h]
		call	_CRYPTO_free
		add	esp, 4
		mov	dword ptr [esi+20h], 0
		mov	dword ptr [esi+0Ch], 0
		mov	eax, 1
		mov	dword ptr [esi+14h], 0
		pop	esi
		retn
_b64_free	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0AD0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_b64_callback_ctrl proc	near		; DATA XREF: .data:00000B0Co

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax+24h]
		test	eax, eax
		jnz	short loc_ADC
		retn
; ---------------------------------------------------------------------------

loc_ADC:				; CODE XREF: _b64_callback_ctrl+9j
		mov	[esp+arg_0], eax
		jmp	_BIO_callback_ctrl
_b64_callback_ctrl endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 0AE8h
_methods_b64	dd offset loc_209+2	; DATA XREF: _BIO_f_base64o
		dd offset ??_C@_0BA@CNEIDKOH@base64?5encoding?$AA@ ; "base64 encoding"
		dd offset _b64_write
		dd offset _b64_read
		dd offset _b64_puts
		align 10h
		dd offset _b64_ctrl
		dd offset _b64_new
		dd offset _b64_free
		dd offset _b64_callback_ctrl
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B10h
; COMDAT (pick any)
		public ??_C@_0BA@CNEIDKOH@base64?5encoding?$AA@
; `string'
??_C@_0BA@CNEIDKOH@base64?5encoding?$AA@ db 'base64 encoding',0 ; DATA XREF: .data:00000AECo
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B20h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_f_base64
_BIO_f_base64	proc near
		mov	eax, offset _methods_b64
		retn
_BIO_f_base64	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B28h
; COMDAT (pick any)
		public ??_C@_0BH@CICFIAAN@?4?2crypto?2evp?2bio_b64?4c?$AA@
; `string'
??_C@_0BH@CICFIAAN@?4?2crypto?2evp?2bio_b64?4c?$AA@ db '.\crypto\evp\bio_b64.c',0
					; DATA XREF: _b64_write+4Co
					; _b64_write+6Bo ...
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B40h
; COMDAT (pick any)
		public ??_C@_0BN@FPMDFEFM@ctx?9?$DObuf_len?5?$DO?$DN?5ctx?9?$DObuf_off?$AA@
; `string'
??_C@_0BN@FPMDFEFM@ctx?9?$DObuf_len?5?$DO?$DN?5ctx?9?$DObuf_off?$AA@ db	'ctx->buf_len >= ctx->buf_off',0
					; DATA XREF: _b64_write+7Fo
					; _b64_write+107o ...
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B60h
; COMDAT (pick any)
		public ??_C@_0CJ@PHNBKJJG@ctx?9?$DObuf_off?5?$CL?5i?5?$DM?5?$CIint?$CJsizeof?$CIc@
; `string'
??_C@_0CJ@PHNBKJJG@ctx?9?$DObuf_off?5?$CL?5i?5?$DM?5?$CIint?$CJsizeof?$CIc@ db 'ctx->buf_off + i < (int)sizeof(ctx->buf)',0
					; DATA XREF: _b64_read+A9o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B8Ch
; COMDAT (pick any)
		public ??_C@_0CF@ELLFOHKP@ctx?9?$DObuf_off?5?$DM?5?$CIint?$CJsizeof?$CIctx?9?$DO@
; `string'
??_C@_0CF@ELLFOHKP@ctx?9?$DObuf_off?5?$DM?5?$CIint?$CJsizeof?$CIctx?9?$DO@ db 'ctx->buf_off < (int)sizeof(ctx->buf)',0
					; DATA XREF: _b64_write+42o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BB4h
; COMDAT (pick any)
		public ??_C@_0CG@LFOFKIIN@ctx?9?$DObuf_len?5?$DM?$DN?5?$CIint?$CJsizeof?$CIctx?9@
; `string'
??_C@_0CG@LFOFKIIN@ctx?9?$DObuf_len?5?$DM?$DN?5?$CIint?$CJsizeof?$CIctx?9@ db 'ctx->buf_len <= (int)sizeof(ctx->buf)',0
					; DATA XREF: _b64_write+61o
					; _b64_write+1E6o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BDCh
; COMDAT (pick any)
		public ??_C@_06NOLCFJLD@i?5?$DM?$DN?5n?$AA@
; `string'
??_C@_06NOLCFJLD@i?5?$DM?$DN?5n?$AA@ db	'i <= n',0 ; DATA XREF: _b64_write+C6o
					; _b64_write+32Fo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BE4h
; COMDAT (pick any)
		public ??_C@_0CG@NALBBCEM@ctx?9?$DObuf_off?5?$DM?$DN?5?$CIint?$CJsizeof?$CIctx?9@
; `string'
??_C@_0CG@NALBBCEM@ctx?9?$DObuf_off?5?$DM?$DN?5?$CIint?$CJsizeof?$CIctx?9@ db 'ctx->buf_off <= (int)sizeof(ctx->buf)',0
					; DATA XREF: _b64_write+E9o
					; _b64_write+354o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C0Ch
; COMDAT (pick any)
		public ??_C@_0BC@BEKEPBME@ctx?9?$DOtmp_len?5?$DM?$DN?53?$AA@
; `string'
??_C@_0BC@BEKEPBME@ctx?9?$DOtmp_len?5?$DM?$DN?53?$AA@ db 'ctx->tmp_len <= 3',0
					; DATA XREF: _b64_write+17Co
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; void *__cdecl	_memmove(void *Dst, const void *Src, size_t Size)
		extrn __imp__memmove:near ; CODE XREF: _b64_read+332p
					; DATA XREF: _b64_read+332r
		extrn _CRYPTO_malloc:near ; CODE XREF: _b64_new+Cp
		extrn _CRYPTO_free:near	; CODE XREF: _b64_free+10p
		extrn _OpenSSLDie:near	; CODE XREF: _b64_write+51p
					; _b64_write+70p ...
		extrn _BIO_test_flags:near ; CODE XREF:	_b64_write+159p
					; _b64_read+148p ...
		extrn _BIO_clear_flags:near ; CODE XREF: _b64_write+10p
					; _b64_read+3Bp ...
		extrn _BIO_read:near	; CODE XREF: _b64_read+131p
		extrn _BIO_write:near	; CODE XREF: _b64_write+B0p
					; _b64_write+319p
		extrn _BIO_ctrl:near	; CODE XREF: _b64_ctrl+43p
					; _b64_ctrl+174p
		extrn _BIO_callback_ctrl:near ;	CODE XREF: _b64_callback_ctrl+10j
		extrn _BIO_copy_next_retry:near	; CODE XREF: _b64_write+22Bp
					; _b64_write+3CFp ...
		extrn _EVP_EncodeInit:near ; CODE XREF:	_b64_write+31p
		extrn _EVP_EncodeUpdate:near ; CODE XREF: _b64_write+2A6p
		extrn _EVP_EncodeFinal:near ; CODE XREF: _b64_ctrl+153p
		extrn _EVP_EncodeBlock:near ; CODE XREF: _b64_write+1D5p
					; _b64_write+25Dp ...
		extrn _EVP_DecodeInit:near ; CODE XREF:	_b64_read+5Cp
					; _b64_read+207p ...
		extrn _EVP_DecodeUpdate:near ; CODE XREF: _b64_read+1EAp
					; _b64_read+35Ap
		extrn _EVP_DecodeBlock:near ; CODE XREF: _b64_read+2FBp
		extrn __chkstk:near	; CODE XREF: _b64_read+5p
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _b64_write+1B0p
					; _b64_write+3B7p ...


		end
