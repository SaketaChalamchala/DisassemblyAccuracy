;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	8CF59A4AAAF8946F39A3E276CA61ACA4
; Input	CRC32 :	BA0B1211

; File Name   :	C:\compspace\Diff\openssl\obj\e_ubsec.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
; COMDAT (pick any)
		public ??_C@_0P@BJJHFGDF@already?5loaded?$AA@
; `string'
??_C@_0P@BJJHFGDF@already?5loaded?$AA@ db 'already loaded',0 ; DATA XREF: .data:000001F8o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10h
; COMDAT (pick any)
		public ??_C@_0P@NJHPDICB@bn?5expand?5fail?$AA@
; `string'
??_C@_0P@NJHPDICB@bn?5expand?5fail?$AA@	db 'bn expand fail',0 ; DATA XREF: .data:00000200o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 20h
; COMDAT (pick any)
		public ??_C@_0BN@NJGGMLOG@ctrl?5command?5not?5implemented?$AA@
; `string'
??_C@_0BN@NJGGMLOG@ctrl?5command?5not?5implemented?$AA@	db 'ctrl command not implemented',0
					; DATA XREF: .data:00000208o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 40h
; COMDAT (pick any)
		public ??_C@_0M@DBMBNOIK@dso?5failure?$AA@
; `string'
??_C@_0M@DBMBNOIK@dso?5failure?$AA@ db 'dso failure',0 ; DATA XREF: .data:00000210o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 4Ch
; COMDAT (pick any)
		public ??_C@_0BH@KAGGBJK@missing?5key?5components?$AA@
; `string'
??_C@_0BH@KAGGBJK@missing?5key?5components?$AA@	db 'missing key components',0
					; DATA XREF: .data:00000218o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 64h
; COMDAT (pick any)
		public ??_C@_0L@ICAFOIA@not?5loaded?$AA@
; `string'
??_C@_0L@ICAFOIA@not?5loaded?$AA@ db 'not loaded',0 ; DATA XREF: .data:_UBSEC_str_reasonso
					; .data:00000220o ...
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 70h
; COMDAT (pick any)
		public ??_C@_0P@LMFGIOCF@request?5failed?$AA@
; `string'
??_C@_0P@LMFGIOCF@request?5failed?$AA@ db 'request failed',0 ; DATA XREF: .data:00000228o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 80h
; COMDAT (pick any)
		public ??_C@_0BM@FJIHNEBE@size?5too?5large?5or?5too?5small?$AA@
; `string'
??_C@_0BM@FJIHNEBE@size?5too?5large?5or?5too?5small?$AA@ db 'size too large or too small',0
					; DATA XREF: .data:00000230o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 9Ch
; COMDAT (pick any)
		public ??_C@_0N@JLJLJPMB@unit?5failure?$AA@
; `string'
??_C@_0N@JLJLJPMB@unit?5failure?$AA@ db	'unit failure',0 ; DATA XREF: .data:00000238o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data		segment	para public 'DATA' use32
		assume cs:_data
		;org 0ACh
_UBSEC_lib_name	dd 0			; DATA XREF: _ERR_load_UBSEC_strings+4Bo
					; _ERR_load_UBSEC_strings+52w ...
		dd offset ??_C@_0N@IDCAMHPI@ubsec?5engine?$AA@ ; "ubsec	engine"
		dd 2 dup(0)
_UBSEC_error_init dd 1			; DATA XREF: _ERR_load_UBSEC_strings:loc_DEBr
					; _ERR_load_UBSEC_strings+22w ...
_ubsec_rsa	dd offset ??_C@_0BB@CDBDNILJ@UBSEC?5RSA?5method?$AA@
					; DATA XREF: _bind_helper+33o
					; "UBSEC RSA method"
dword_C4	dd 0			; DATA XREF: _bind_helper+DFw
dword_C8	dd 0			; DATA XREF: .rdata:_ubsec_cmd_defnso
					; _bind_helper+E8w
dword_CC	dd 0			; DATA XREF: _bind_helper+F1w
dword_D0	dd 0			; DATA XREF: _bind_helper+FAw
		dd offset _ubsec_rsa_mod_exp
		dd offset _ubsec_mod_exp_mont
		dd 7 dup(0)
_ubsec_dsa	dd offset ??_C@_0BB@GFFANGDB@UBSEC?5DSA?5method?$AA@
					; DATA XREF: _bind_helper+49o
					; "UBSEC DSA method"
		dd offset _ubsec_dsa_do_sign
		dd 0
		dd offset _ubsec_dsa_verify
		dd 8 dup(0)
_ubsec_dh	dd offset ??_C@_0BA@PAHPCBBP@UBSEC?5DH?5method?$AA@
					; DATA XREF: _bind_helper+5Fo
					; "UBSEC DH method"
off_12C		dd offset _ubsec_dh_generate_key ; DATA	XREF: _bind_helper+107w
off_130		dd offset _ubsec_dh_compute_key	; DATA XREF: _bind_helper+110w
		dd offset _ubsec_mod_exp_dh
		dd 5 dup(0)
_engine_ubsec_id dd offset ??_C@_05IPGGNINO@ubsec?$AA@ ; DATA XREF: _bind_engine+75r
					; _bind_fn+8r ...
					; "ubsec"
_engine_ubsec_name dd offset ??_C@_0BO@PGABPCJ@UBSEC?5hardware?5engine?5support?$AA@
					; DATA XREF: _bind_helper+1Cr
					; "UBSEC hardware engine support"
_max_key_len	dd offset loc_3FE+2	; DATA XREF: _ubsec_mod_exp_mont+Er
					; _ubsec_init+286o ...
_UBSEC_F1	dd offset ??_C@_0BE@NJOFPNJG@ubsec_bytes_to_bits?$AA@
					; DATA XREF: _ubsec_init:loc_13DFr
					; "ubsec_bytes_to_bits"
_UBSEC_F2	dd offset ??_C@_0BE@OHJFNGCO@ubsec_bits_to_bytes?$AA@
					; DATA XREF: _ubsec_init+98r
					; "ubsec_bits_to_bytes"
_UBSEC_F3	dd offset ??_C@_0L@BNIDNGJI@ubsec_open?$AA@ ; DATA XREF: _ubsec_init+B6r
					; "ubsec_open"
_UBSEC_F4	dd offset ??_C@_0M@EPNCGNPN@ubsec_close?$AA@ ; DATA XREF: _ubsec_init+D4r
					; "ubsec_close"
_UBSEC_F5	dd offset ??_C@_0BO@JMBHODEE@diffie_hellman_generate_ioctl?$AA@
					; DATA XREF: _ubsec_init+F2r
					; "diffie_hellman_generate_ioctl"
_UBSEC_F6	dd offset ??_C@_0BL@LBOPHDHN@diffie_hellman_agree_ioctl?$AA@
					; DATA XREF: _ubsec_init+112r
					; "diffie_hellman_agree_ioctl"
_UBSEC_F7	dd offset ??_C@_0BC@HODKELEI@rsa_mod_exp_ioctl?$AA@
					; DATA XREF: _ubsec_init+132r
					; "rsa_mod_exp_ioctl"
_UBSEC_F8	dd offset ??_C@_0BG@LJJODNOP@rsa_mod_exp_crt_ioctl?$AA@
					; DATA XREF: _ubsec_init+152r
					; "rsa_mod_exp_crt_ioctl"
_UBSEC_F9	dd offset ??_C@_0P@OJMFCJG@dsa_sign_ioctl?$AA@ ; DATA XREF: _ubsec_init+172r
					; "dsa_sign_ioctl"
_UBSEC_F10	dd offset ??_C@_0BB@KFBEANMO@dsa_verify_ioctl?$AA@
					; DATA XREF: _ubsec_init+192r
					; "dsa_verify_ioctl"
_UBSEC_F11	dd offset ??_C@_0BG@POCKEKBP@math_accelerate_ioctl?$AA@
					; DATA XREF: _ubsec_init+1B2r
					; "math_accelerate_ioctl"
_UBSEC_F12	dd offset ??_C@_09PCGBKKCC@rng_ioctl?$AA@ ; DATA XREF: _ubsec_init+1D2r
					; "rng_ioctl"
_UBSEC_F13	dd offset ??_C@_0BI@GFLOACB@ubsec_max_key_len_ioctl?$AA@
					; DATA XREF: _ubsec_init+1F2r
					; "ubsec_max_key_len_ioctl"
_UBSEC_str_functs dd 64000h		; DATA XREF: _ERR_load_UBSEC_strings+1Co
					; _ERR_unload_UBSEC_strings+9o	...
		dd offset ??_C@_0L@MNIPMMKP@UBSEC_CTRL?$AA@ ; "UBSEC_CTRL"
		dd 65000h
		dd offset ??_C@_0BF@OBJODAOP@UBSEC_DH_COMPUTE_KEY?$AA@ ; "UBSEC_DH_COMPUTE_KEY"
		dd 6F000h
		dd offset ??_C@_0BG@HKJLNBPK@UBSEC_DH_GENERATE_KEY?$AA@	; "UBSEC_DH_GENERATE_KEY"
		dd 66000h
		dd offset ??_C@_0BC@EODPMEE@UBSEC_DSA_DO_SIGN?$AA@ ; "UBSEC_DSA_DO_SIGN"
		dd 67000h
		dd offset ??_C@_0BB@OAENJIDI@UBSEC_DSA_VERIFY?$AA@ ; "UBSEC_DSA_VERIFY"
		dd 68000h
		dd offset ??_C@_0N@JCKJACIF@UBSEC_FINISH?$AA@ ;	"UBSEC_FINISH"
		dd 69000h
		dd offset ??_C@_0L@CKPDLHDN@UBSEC_INIT?$AA@ ; "UBSEC_INIT"
		dd 6A000h
		dd offset ??_C@_0O@DOCOEAOC@UBSEC_MOD_EXP?$AA@ ; "UBSEC_MOD_EXP"
		dd 6E000h
		dd offset ??_C@_0BC@EEIHNNLD@UBSEC_MOD_EXP_CRT?$AA@ ; "UBSEC_MOD_EXP_CRT"
		dd 6B000h
		dd offset ??_C@_0BB@NOKKLICC@UBSEC_RAND_BYTES?$AA@ ; "UBSEC_RAND_BYTES"
		dd 6C000h
		dd offset ??_C@_0BC@NNIFNEAA@UBSEC_RSA_MOD_EXP?$AA@ ; "UBSEC_RSA_MOD_EXP"
		dd 6D000h
		dd offset ??_C@_0BG@LGBLJCMM@UBSEC_RSA_MOD_EXP_CRT?$AA@	; "UBSEC_RSA_MOD_EXP_CRT"
		dd 2 dup(0)
_UBSEC_str_reasons dd offset ??_C@_0L@ICAFOIA@not?5loaded?$AA@
					; DATA XREF: _ERR_load_UBSEC_strings+31o
					; _ERR_unload_UBSEC_strings+19o ...
					; "not loaded"
		dd offset ??_C@_0P@BJJHFGDF@already?5loaded?$AA@ ; "already loaded"
		dd offset ??_C@_0L@ICAFOIA@not?5loaded?$AA@+1 ;	"ot loaded"
		dd offset ??_C@_0P@NJHPDICB@bn?5expand?5fail?$AA@ ; "bn	expand fail"
		dd offset ??_C@_0L@ICAFOIA@not?5loaded?$AA@+2 ;	"t loaded"
		dd offset ??_C@_0BN@NJGGMLOG@ctrl?5command?5not?5implemented?$AA@ ; "ctrl command not implemented"
		dd offset ??_C@_0L@ICAFOIA@not?5loaded?$AA@+3 ;	" loaded"
		dd offset ??_C@_0M@DBMBNOIK@dso?5failure?$AA@ ;	"dso failure"
		dd offset ??_C@_0L@ICAFOIA@not?5loaded?$AA@+4 ;	"loaded"
		dd offset ??_C@_0BH@KAGGBJK@missing?5key?5components?$AA@ ; "missing key components"
		dd offset ??_C@_0L@ICAFOIA@not?5loaded?$AA@+5 ;	"oaded"
		dd offset ??_C@_0L@ICAFOIA@not?5loaded?$AA@ ; "not loaded"
		dd offset ??_C@_0L@ICAFOIA@not?5loaded?$AA@+6 ;	"aded"
		dd offset ??_C@_0P@LMFGIOCF@request?5failed?$AA@ ; "request failed"
		dd offset ??_C@_0L@ICAFOIA@not?5loaded?$AA@+7 ;	"ded"
		dd offset ??_C@_0BM@FJIHNEBE@size?5too?5large?5or?5too?5small?$AA@ ; "size too large or	too small"
		dd offset ??_C@_0L@ICAFOIA@not?5loaded?$AA@+8 ;	"ed"
		dd offset ??_C@_0N@JLJLJPMB@unit?5failure?$AA@ ; "unit failure"
		dd 2 dup(0)
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 244h
; COMDAT (pick any)
		public ??_C@_0N@IDCAMHPI@ubsec?5engine?$AA@
; `string'
??_C@_0N@IDCAMHPI@ubsec?5engine?$AA@ db	'ubsec engine',0 ; DATA XREF: .data:000000B0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 254h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
_UBSEC_lib_error_code dd ?		; DATA XREF: _ubsec_rsa_mod_exp:loc_2F6r
					; _ubsec_rsa_mod_exp+70w ...
_ubsec_dso	dd ?			; DATA XREF: _ubsec_ctrl+2r
					; _ubsec_finish:loc_1252r ...
_p_UBSEC_ubsec_bytes_to_bits dd	?	; DATA XREF: _ubsec_dsa_do_sign+54r
					; _ubsec_dsa_verify+94r ...
_p_UBSEC_ubsec_bits_to_bytes dd	?	; DATA XREF: _ubsec_dh_compute_key+100r
					; _ubsec_finish+A5w ...
_p_UBSEC_ubsec_open dd ?		; DATA XREF: _ubsec_dsa_do_sign+D1r
					; _ubsec_dsa_verify+A3r ...
_p_UBSEC_ubsec_close dd	?		; DATA XREF: _ubsec_dsa_do_sign+1A4r
					; _ubsec_dsa_do_sign+1C7r ...
_p_UBSEC_diffie_hellman_generate_ioctl dd ? ; DATA XREF: _ubsec_dh_generate_key+16Er
					; _ubsec_finish+C3w ...
_p_UBSEC_diffie_hellman_agree_ioctl dd ? ; DATA	XREF: _ubsec_dh_compute_key+A3r
					; _ubsec_finish+CDw ...
_p_UBSEC_rsa_mod_exp_ioctl dd ?		; DATA XREF: _ubsec_finish+D7w
					; _ubsec_init+226w ...
_p_UBSEC_rsa_mod_exp_crt_ioctl dd ?	; DATA XREF: _ubsec_finish+E1w
					; _ubsec_init+22Fw ...
_p_UBSEC_dsa_sign_ioctl	dd ?		; DATA XREF: _ubsec_dsa_do_sign+183r
					; _ubsec_finish+EBw ...
_p_UBSEC_dsa_verify_ioctl dd ?		; DATA XREF: _ubsec_dsa_verify+175r
					; _ubsec_finish+F5w ...
_p_UBSEC_math_accelerate_ioctl dd ?	; DATA XREF: _ubsec_finish+FFw
					; _ubsec_init+24Aw ...
_p_UBSEC_rng_ioctl dd ?			; DATA XREF: _ubsec_finish+109w
					; _ubsec_init+270w ...
_p_UBSEC_max_key_len_ioctl dd ?		; DATA XREF: _ubsec_finish+113w
					; _ubsec_init+275w ...
_UBSEC_LIBNAME	dd ?			; DATA XREF: _free_UBSEC_LIBNAMEr
					; _free_UBSEC_LIBNAME:loc_10CEw ...
_bss		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 294h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ubsec_rsa_mod_exp proc	near		; DATA XREF: .data:000000D4o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	ebx
		push	esi
		mov	esi, [esp+8+arg_8]
		push	edi
		mov	eax, [esi+1Ch]
		test	eax, eax
		jz	short loc_2F6
		mov	ecx, [esi+20h]
		test	ecx, ecx
		jz	short loc_2F6
		mov	edx, [esi+24h]
		test	edx, edx
		jz	short loc_2F6
		mov	edi, [esi+28h]
		test	edi, edi
		jz	short loc_2F6
		mov	ebx, [esi+2Ch]
		test	ebx, ebx
		jz	short loc_2F6
		push	[esp+0Ch+arg_C]
		push	ebx
		mov	ebx, [esp+14h+arg_0]
		push	edi
		mov	edi, [esp+18h+arg_4]
		push	edx
		push	ecx
		push	eax
		push	edi
		push	ebx
		call	_ubsec_mod_exp_crt
		add	esp, 20h
		cmp	eax, 0FFFFFFF1h
		jnz	short $err$11
		call	_RSA_PKCS1_SSLeay
		push	[esp+0Ch+arg_C]
		push	esi
		mov	eax, [eax+14h]
		push	edi
		push	ebx
		call	eax
		add	esp, 10h
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_2F6:				; CODE XREF: _ubsec_rsa_mod_exp+Cj
					; _ubsec_rsa_mod_exp+13j ...
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_309
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_309:				; CODE XREF: _ubsec_rsa_mod_exp+69j
		push	26Ah
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	68h ; 'h'
		push	6Ch ; 'l'
		push	eax
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax

$err$11:				; CODE XREF: _ubsec_rsa_mod_exp+48j
		pop	edi
		pop	esi
		pop	ebx
		retn
_ubsec_rsa_mod_exp endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 328h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ubsec_mod_exp_mont proc near		; DATA XREF: .data:000000D8o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		push	esi
		mov	esi, [esp+4+arg_C]
		push	esi
		call	_BN_num_bits
		add	esp, 4
		cmp	eax, ds:_max_key_len
		jle	short loc_362
		call	_RSA_PKCS1_SSLeay
		push	[esp+4+arg_14]
		push	[esp+8+arg_10]
		mov	eax, [eax+18h]
		push	esi
		push	[esp+10h+arg_8]
		push	[esp+14h+arg_4]
		push	[esp+18h+arg_0]
		call	eax
		add	esp, 18h
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_362:				; CODE XREF: _ubsec_mod_exp_mont+14j
		push	[esp+4+arg_10]
		push	esi
		push	[esp+0Ch+arg_8]
		push	[esp+10h+arg_4]
		push	[esp+14h+arg_0]
		call	_ubsec_mod_exp
		add	esp, 14h
		pop	esi
		retn
_ubsec_mod_exp_mont endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 380h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ubsec_dsa_do_sign proc	near		; DATA XREF: .data:000000FCo

var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= byte ptr -14h
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 20h ; ' '
		call	__chkstk
		push	ebx
		push	ebp
		push	esi
		lea	eax, [esp+2Ch+var_14]
		mov	[esp+2Ch+var_20], 0A0h ; ' '
		push	edi
		push	eax
		xor	ebx, ebx
		mov	[esp+34h+var_1C], 0A0h ; ' '
		call	_BN_init
		add	esp, 4
		call	_BN_new
		mov	edi, eax
		call	_BN_new
		mov	esi, eax
		test	edi, edi
		jz	loc_5A8
		test	esi, esi
		jz	loc_5B5
		push	[esp+30h+arg_4]
		mov	ebp, [esp+34h+arg_0]
		push	ebp
		call	ds:_p_UBSEC_ubsec_bytes_to_bits
		add	esp, 8
		mov	[esp+30h+var_18], eax
		cmp	dword ptr [esi+8], 5
		jl	short loc_3EB
		mov	eax, esi
		jmp	short loc_3F6
; ---------------------------------------------------------------------------

loc_3EB:				; CODE XREF: _ubsec_dsa_do_sign+65j
		push	5
		push	esi
		call	_bn_expand2
		add	esp, 8

loc_3F6:				; CODE XREF: _ubsec_dsa_do_sign+69j
		test	eax, eax
		jz	loc_57E

loc_3FE:				; DATA XREF: .data:_max_key_leno
		cmp	dword ptr [edi+8], 5
		jl	short loc_408
		mov	eax, edi
		jmp	short loc_413
; ---------------------------------------------------------------------------

loc_408:				; CODE XREF: _ubsec_dsa_do_sign+82j
		push	5
		push	edi
		call	_bn_expand2
		add	esp, 8

loc_413:				; CODE XREF: _ubsec_dsa_do_sign+86j
		test	eax, eax
		jz	loc_57E
		lea	eax, [esp+30h+var_14]
		push	eax
		push	[esp+34h+arg_4]
		push	ebp
		call	_BN_bin2bn
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_44C
		push	306h

loc_436:				; CODE XREF: _ubsec_dsa_do_sign+1EEj
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	65h ; 'e'
		push	66h ; 'f'
		call	_ERR_UBSEC_error
		add	esp, 10h
		jmp	loc_5A8
; ---------------------------------------------------------------------------

loc_44C:				; CODE XREF: _ubsec_dsa_do_sign+AFj
		push	offset ??_C@_0M@IDHLONIG@?1dev?1ubskey?$AA@ ; "/dev/ubskey"
		call	ds:_p_UBSEC_ubsec_open
		mov	ebx, eax
		add	esp, 4
		test	ebx, ebx
		jg	short loc_491
		push	30Dh
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	6Ch ; 'l'
		push	66h ; 'f'
		call	_ERR_UBSEC_error
		call	_DSA_OpenSSL
		push	[esp+40h+arg_8]
		mov	ecx, [esp+44h+arg_4]
		push	ecx
		mov	eax, [eax+4]
		push	ebp
		call	eax
		add	esp, 1Ch
		mov	ebx, eax
		jmp	$err$24
; ---------------------------------------------------------------------------

loc_491:				; CODE XREF: _ubsec_dsa_do_sign+DEj
		mov	ecx, [esp+30h+arg_8]
		lea	eax, [esp+30h+var_20]
		push	eax
		push	dword ptr [edi]
		lea	eax, [esp+38h+var_1C]
		push	eax
		push	dword ptr [esi]
		push	dword ptr [ecx+1Ch]
		call	_BN_num_bits
		mov	ecx, [esp+44h+arg_8]
		add	esp, 4
		push	eax
		mov	eax, [ecx+1Ch]
		push	dword ptr [eax]
		push	dword ptr [ecx+14h]
		call	_BN_num_bits
		mov	ecx, [esp+4Ch+arg_8]
		add	esp, 4
		push	eax
		mov	eax, [ecx+14h]
		push	dword ptr [eax]
		push	dword ptr [ecx+10h]
		call	_BN_num_bits
		mov	ecx, [esp+54h+arg_8]
		add	esp, 4
		push	eax
		mov	eax, [ecx+10h]
		push	dword ptr [eax]
		push	dword ptr [ecx+0Ch]
		call	_BN_num_bits
		add	esp, 4
		push	eax
		mov	eax, [esp+5Ch+arg_8]
		mov	eax, [eax+0Ch]
		push	dword ptr [eax]
		push	0
		push	0
		push	[esp+68h+var_18]
		push	ebp
		push	0
		push	ebx
		call	ds:_p_UBSEC_dsa_sign_ioctl
		add	esp, 48h
		test	eax, eax
		jz	short loc_546
		push	324h
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	6Ah ; 'j'
		push	66h ; 'f'
		call	_ERR_UBSEC_error
		push	ebx
		call	ds:_p_UBSEC_ubsec_close
		call	_DSA_OpenSSL
		mov	ecx, [esp+44h+arg_8]
		push	ecx
		mov	ecx, [esp+48h+arg_4]
		mov	eax, [eax+4]
		push	ecx
		push	ebp
		call	eax
		add	esp, 20h
		mov	ebx, eax
		jmp	short $err$24
; ---------------------------------------------------------------------------

loc_546:				; CODE XREF: _ubsec_dsa_do_sign+18Ej
		push	ebx
		call	ds:_p_UBSEC_ubsec_close
		add	esp, 4
		mov	dword ptr [esi+4], 5
		mov	dword ptr [edi+4], 5
		call	_DSA_SIG_new
		mov	ebx, eax
		test	ebx, ebx
		jnz	short loc_573
		push	333h
		jmp	loc_436
; ---------------------------------------------------------------------------

loc_573:				; CODE XREF: _ubsec_dsa_do_sign+1E7j
		mov	[ebx], esi
		mov	[ebx+4], edi

$err$24:				; CODE XREF: _ubsec_dsa_do_sign+10Cj
					; _ubsec_dsa_do_sign+1C4j
		test	ebx, ebx
		jnz	short loc_5C2
		jmp	short loc_5A8
; ---------------------------------------------------------------------------

loc_57E:				; CODE XREF: _ubsec_dsa_do_sign+78j
					; _ubsec_dsa_do_sign+95j
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_591
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_591:				; CODE XREF: _ubsec_dsa_do_sign+205j
		push	301h
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	65h ; 'e'
		push	66h ; 'f'
		push	eax
		call	_ERR_put_error
		add	esp, 14h

loc_5A8:				; CODE XREF: _ubsec_dsa_do_sign+3Dj
					; _ubsec_dsa_do_sign+C7j ...
		test	esi, esi
		jz	short loc_5B5
		push	esi
		call	_BN_free
		add	esp, 4

loc_5B5:				; CODE XREF: _ubsec_dsa_do_sign+45j
					; _ubsec_dsa_do_sign+22Aj
		test	edi, edi
		jz	short loc_5C2
		push	edi
		call	_BN_free
		add	esp, 4

loc_5C2:				; CODE XREF: _ubsec_dsa_do_sign+1FAj
					; _ubsec_dsa_do_sign+237j
		lea	eax, [esp+30h+var_14]
		push	eax
		call	_BN_clear_free
		add	esp, 4
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 20h
		retn
_ubsec_dsa_do_sign endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5DCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ubsec_dsa_verify proc near		; DATA XREF: .data:00000104o

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, 18h
		call	__chkstk
		push	esi
		push	edi
		lea	eax, [esp+20h+var_14]
		xor	edi, edi
		push	eax
		call	_BN_init
		mov	esi, [esp+24h+arg_C]
		add	esp, 4
		mov	eax, [esi+0Ch]
		mov	eax, [eax+4]
		cmp	eax, [esp+20h+var_C]
		jle	short loc_658
		push	eax
		lea	eax, [esp+24h+var_14]
		push	eax
		call	_bn_expand2
		add	esp, 8
		test	eax, eax
		jnz	short loc_658
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_62C
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_62C:				; CODE XREF: _ubsec_dsa_verify+44j
		push	350h
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	65h ; 'e'
		push	67h ; 'g'
		push	eax
		call	_ERR_put_error
		add	esp, 14h
		lea	eax, [esp+20h+var_14]
		push	eax
		call	_BN_clear_free
		add	esp, 4
		mov	eax, edi
		pop	edi
		pop	esi
		add	esp, 18h
		retn
; ---------------------------------------------------------------------------

loc_658:				; CODE XREF: _ubsec_dsa_verify+29j
					; _ubsec_dsa_verify+3Bj
		push	ebx
		push	ebp
		push	dword ptr [esi+0Ch]
		call	_BN_num_bits
		mov	ebp, [esp+2Ch+arg_4]
		mov	ebx, [esp+2Ch+arg_0]
		push	ebp
		push	ebx
		mov	[esp+34h+var_18], eax
		call	ds:_p_UBSEC_ubsec_bytes_to_bits
		push	offset ??_C@_0M@IDHLONIG@?1dev?1ubskey?$AA@ ; "/dev/ubskey"
		mov	[esp+38h+arg_C], eax
		call	ds:_p_UBSEC_ubsec_open
		mov	edi, eax
		add	esp, 10h
		test	edi, edi
		jg	short loc_6D0
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_6A1
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_6A1:				; CODE XREF: _ubsec_dsa_verify+B9j
		push	35Bh
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	6Ch ; 'l'
		push	67h ; 'g'
		push	eax
		call	_ERR_put_error
		call	_DSA_OpenSSL
		push	esi
		push	[esp+40h+arg_8]
		mov	eax, [eax+0Ch]
		push	ebp
		push	ebx
		call	eax
		add	esp, 24h
		mov	edi, eax
		jmp	loc_7B4
; ---------------------------------------------------------------------------

loc_6D0:				; CODE XREF: _ubsec_dsa_verify+B0j
		mov	ecx, [esp+28h+arg_8]
		lea	eax, [esp+28h+var_18]
		push	eax
		push	[esp+2Ch+var_14]
		push	dword ptr [ecx+4]
		call	_BN_num_bits
		mov	ecx, [esp+34h+arg_8]
		add	esp, 4
		push	eax
		mov	eax, [ecx+4]
		push	dword ptr [eax]
		push	dword ptr [ecx]
		call	_BN_num_bits
		add	esp, 4
		push	eax
		mov	eax, [esp+3Ch+arg_8]
		mov	eax, [eax]
		push	dword ptr [eax]
		push	dword ptr [esi+18h]
		call	_BN_num_bits
		add	esp, 4
		push	eax
		mov	eax, [esi+18h]
		push	dword ptr [eax]
		push	dword ptr [esi+14h]
		call	_BN_num_bits
		add	esp, 4
		push	eax
		mov	eax, [esi+14h]
		push	dword ptr [eax]
		push	dword ptr [esi+10h]
		call	_BN_num_bits
		add	esp, 4
		push	eax
		mov	eax, [esi+10h]
		push	dword ptr [eax]
		push	dword ptr [esi+0Ch]
		call	_BN_num_bits
		add	esp, 4
		push	eax
		mov	eax, [esi+0Ch]
		push	dword ptr [eax]
		push	[esp+60h+arg_C]
		push	ebx
		push	0
		push	edi
		call	ds:_p_UBSEC_dsa_verify_ioctl
		add	esp, 48h
		test	eax, eax
		jz	short loc_7A5
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_771
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_771:				; CODE XREF: _ubsec_dsa_verify+189j
		push	371h
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	6Ah ; 'j'
		push	67h ; 'g'
		push	eax
		call	_ERR_put_error
		push	edi
		call	ds:_p_UBSEC_ubsec_close
		call	_DSA_OpenSSL
		mov	ecx, [esp+40h+arg_8]
		push	esi
		push	ecx
		mov	eax, [eax+0Ch]
		push	ebp
		push	ebx
		call	eax
		add	esp, 28h
		mov	edi, eax
		jmp	short loc_7B4
; ---------------------------------------------------------------------------

loc_7A5:				; CODE XREF: _ubsec_dsa_verify+180j
		push	edi
		call	ds:_p_UBSEC_ubsec_close
		add	esp, 4
		mov	edi, 1

loc_7B4:				; CODE XREF: _ubsec_dsa_verify+EFj
					; _ubsec_dsa_verify+1C7j
		pop	ebp
		pop	ebx

$err$20:
		lea	eax, [esp+20h+var_14]
		push	eax
		call	_BN_clear_free
		add	esp, 4
		mov	eax, edi
		pop	edi
		pop	esi
		add	esp, 18h
		retn
_ubsec_dsa_verify endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7CCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ubsec_mod_exp_dh proc near		; DATA XREF: .data:00000134o

arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		push	[esp+arg_14]
		push	[esp+4+arg_10]
		push	[esp+8+arg_C]
		push	[esp+0Ch+arg_8]
		push	[esp+10h+arg_4]
		call	_ubsec_mod_exp
		add	esp, 14h
		retn
_ubsec_mod_exp_dh endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7ECh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ubsec_dh_compute_key proc near		; DATA XREF: .data:off_130o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_8]
		push	edi
		push	dword ptr [esi+8]
		call	_BN_num_bits
		push	offset ??_C@_0M@IDHLONIG@?1dev?1ubskey?$AA@ ; "/dev/ubskey"
		mov	[esp+10h+arg_8], eax
		call	ds:_p_UBSEC_ubsec_open
		mov	edi, eax
		add	esp, 8
		test	edi, edi
		jg	short loc_852
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_825
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_825:				; CODE XREF: _ubsec_dh_compute_key+2Dj
		push	38Dh
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	6Ch ; 'l'
		push	65h ; 'e'
		push	eax
		call	_ERR_put_error
		call	_DH_OpenSSL
		push	esi
		push	[esp+20h+arg_4]
		push	[esp+24h+arg_0]
		mov	eax, [eax+8]
		call	eax
		add	esp, 20h
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_852:				; CODE XREF: _ubsec_dh_compute_key+24j
		push	ebx
		lea	eax, [esp+0Ch+arg_8]
		push	eax
		push	[esp+10h+arg_0]
		push	dword ptr [esi+8]
		call	_BN_num_bits
		mov	ebx, [esp+18h+arg_4]
		add	esp, 4
		push	eax
		mov	eax, [esi+8]
		push	dword ptr [eax]
		push	ebx
		call	_BN_num_bits
		add	esp, 4
		push	eax
		push	dword ptr [ebx]
		push	dword ptr [esi+18h]
		call	_BN_num_bits
		add	esp, 4
		push	eax
		mov	eax, [esi+18h]
		push	dword ptr [eax]
		push	edi
		call	ds:_p_UBSEC_diffie_hellman_agree_ioctl
		add	esp, 24h
		test	eax, eax
		jz	short loc_8E1
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_8AF
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_8AF:				; CODE XREF: _ubsec_dh_compute_key+B7j
		push	39Dh
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	6Ah ; 'j'
		push	65h ; 'e'
		push	eax
		call	_ERR_put_error
		push	edi
		call	ds:_p_UBSEC_ubsec_close
		call	_DH_OpenSSL
		push	esi
		push	ebx
		push	[esp+2Ch+arg_0]
		mov	eax, [eax+8]
		call	eax
		add	esp, 24h
		pop	ebx
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_8E1:				; CODE XREF: _ubsec_dh_compute_key+AEj
		push	edi
		call	ds:_p_UBSEC_ubsec_close
		push	[esp+10h+arg_8]
		call	ds:_p_UBSEC_ubsec_bits_to_bytes
		add	esp, 8

$err$13:
		pop	ebx
		pop	edi
		pop	esi
		retn
_ubsec_dh_compute_key endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8FCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ubsec_dh_generate_key proc near	; DATA XREF: .data:off_12Co

var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 0Ch
		call	__chkstk
		push	esi
		push	edi
		mov	edi, [esp+14h+arg_0]
		mov	[esp+14h+var_4], 0
		mov	[esp+14h+var_C], 0
		mov	[esp+14h+var_8], 0
		mov	esi, [edi+18h]
		test	esi, esi
		jnz	short loc_98F
		call	_BN_new
		mov	esi, eax
		test	esi, esi
		jz	loc_9C0
		push	dword ptr [edi+8]
		call	_BN_num_bits
		mov	[esp+18h+var_8], eax
		add	esp, 4
		mov	eax, [edi+8]
		mov	eax, [eax+4]
		cmp	eax, [esi+8]
		jg	short loc_958
		mov	eax, esi
		jmp	short loc_962
; ---------------------------------------------------------------------------

loc_958:				; CODE XREF: _ubsec_dh_generate_key+56j
		push	eax
		push	esi
		call	_bn_expand2
		add	esp, 8

loc_962:				; CODE XREF: _ubsec_dh_generate_key+5Aj
		test	eax, eax
		jz	short loc_9C0
		nop	word ptr [eax+eax+00h]

loc_96C:				; CODE XREF: _ubsec_dh_generate_key+84j
		push	dword ptr [edi+8]
		push	esi
		call	_BN_rand_range
		add	esp, 8
		test	eax, eax
		jz	short loc_9C0
		cmp	dword ptr [esi+4], 0
		jz	short loc_96C
		push	esi
		call	_BN_num_bits
		add	esp, 4
		mov	[esp+14h+var_4], eax

loc_98F:				; CODE XREF: _ubsec_dh_generate_key+2Dj
		push	ebx
		mov	ebx, [edi+14h]
		test	ebx, ebx
		jnz	short loc_9DF
		call	_BN_new
		mov	ebx, eax
		test	ebx, ebx
		jz	short loc_9D6
		push	dword ptr [edi+8]
		call	_BN_num_bits
		mov	[esp+1Ch+var_C], eax
		add	esp, 4
		mov	eax, [edi+8]
		mov	eax, [eax+4]
		cmp	eax, [ebx+8]
		jg	short loc_9C8
		mov	eax, ebx
		jmp	short loc_9D2
; ---------------------------------------------------------------------------

loc_9C0:				; CODE XREF: _ubsec_dh_generate_key+38j
					; _ubsec_dh_generate_key+68j ...
		pop	edi
		xor	eax, eax
		pop	esi
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_9C8:				; CODE XREF: _ubsec_dh_generate_key+BEj
		push	eax
		push	ebx
		call	_bn_expand2
		add	esp, 8

loc_9D2:				; CODE XREF: _ubsec_dh_generate_key+C2j
		test	eax, eax
		jnz	short loc_9DF

loc_9D6:				; CODE XREF: _ubsec_dh_generate_key+A4j
		pop	ebx
		pop	edi
		xor	eax, eax
		pop	esi
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_9DF:				; CODE XREF: _ubsec_dh_generate_key+99j
					; _ubsec_dh_generate_key+D8j
		push	ebp
		push	offset ??_C@_0M@IDHLONIG@?1dev?1ubskey?$AA@ ; "/dev/ubskey"
		call	ds:_p_UBSEC_ubsec_open
		mov	ebp, eax
		add	esp, 4
		test	ebp, ebp
		jg	short loc_A31
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_A07
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_A07:				; CODE XREF: _ubsec_dh_generate_key+FFj
		push	3D5h
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	6Ch ; 'l'
		push	6Fh ; 'o'
		push	eax
		call	_ERR_put_error
		call	_DH_OpenSSL
		push	edi
		mov	eax, [eax+4]
		call	eax
		add	esp, 18h
		pop	ebp
		pop	ebx
		pop	edi
		pop	esi
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_A31:				; CODE XREF: _ubsec_dh_generate_key+F6j
		push	[esp+1Ch+var_4]
		push	0
		push	0
		push	dword ptr [edi+8]
		call	_BN_num_bits
		add	esp, 4
		push	eax
		mov	eax, [edi+8]
		push	dword ptr [eax]
		push	dword ptr [edi+0Ch]
		call	_BN_num_bits
		add	esp, 4
		push	eax
		mov	eax, [edi+0Ch]
		push	dword ptr [eax]
		lea	eax, [esp+38h+var_C]
		push	eax
		push	dword ptr [ebx]
		lea	eax, [esp+40h+var_8]
		push	eax
		push	dword ptr [esi]
		push	ebp
		call	ds:_p_UBSEC_diffie_hellman_generate_ioctl
		add	esp, 30h
		test	eax, eax
		jz	short loc_ABB
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_A8A
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_A8A:				; CODE XREF: _ubsec_dh_generate_key+182j
		push	3E8h
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	6Ah ; 'j'
		push	6Fh ; 'o'
		push	eax
		call	_ERR_put_error
		push	ebp
		call	ds:_p_UBSEC_ubsec_close
		call	_DH_OpenSSL
		push	edi
		mov	eax, [eax+4]
		call	eax
		add	esp, 1Ch
		pop	ebp
		pop	ebx
		pop	edi
		pop	esi
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_ABB:				; CODE XREF: _ubsec_dh_generate_key+179j
		push	ebp
		call	ds:_p_UBSEC_ubsec_close
		mov	eax, [esp+20h+var_C]
		add	esp, 4
		add	eax, 1Fh
		mov	[edi+14h], ebx
		cdq
		and	edx, 1Fh
		add	eax, edx
		sar	eax, 5
		mov	[ebx+4], eax
		mov	eax, [esp+1Ch+var_8]
		add	eax, 1Fh
		mov	[edi+18h], esi
		cdq
		and	edx, 1Fh
		add	eax, edx
		sar	eax, 5
		pop	ebp
		mov	[esi+4], eax
		mov	eax, 1
		pop	ebx

$err$40:
		pop	edi
		pop	esi
		add	esp, 0Ch
		retn
_ubsec_dh_generate_key endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B00h
_ubsec_cmd_defns dd offset dword_C8	; DATA XREF: _bind_helper+C5o
		dd offset ??_C@_07EGEBNIPD@SO_PATH?$AA@	; "SO_PATH"
		dd offset ??_C@_0DB@FFBMKMEM@Specifies?5the?5path?5to?5the?5?8ubsec@ ; "Specifies the path to the 'ubsec' share"...
		dd 2, 4	dup(0)
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B20h
; COMDAT (pick any)
		public ??_C@_07EGEBNIPD@SO_PATH?$AA@
; `string'
??_C@_07EGEBNIPD@SO_PATH?$AA@ db 'SO_PATH',0 ; DATA XREF: .rdata:00000B04o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B28h
; COMDAT (pick any)
		public ??_C@_0DB@FFBMKMEM@Specifies?5the?5path?5to?5the?5?8ubsec@
; `string'
??_C@_0DB@FFBMKMEM@Specifies?5the?5path?5to?5the?5?8ubsec@ db 'Specifies the path to the ',27h,'ubsec',27h,' shared library',0
					; DATA XREF: .rdata:00000B08o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B5Ch
; COMDAT (pick any)
		public ??_C@_0BB@CDBDNILJ@UBSEC?5RSA?5method?$AA@
; `string'
??_C@_0BB@CDBDNILJ@UBSEC?5RSA?5method?$AA@ db 'UBSEC RSA method',0
					; DATA XREF: .data:_ubsec_rsao
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B70h
; COMDAT (pick any)
		public ??_C@_0BB@GFFANGDB@UBSEC?5DSA?5method?$AA@
; `string'
??_C@_0BB@GFFANGDB@UBSEC?5DSA?5method?$AA@ db 'UBSEC DSA method',0
					; DATA XREF: .data:_ubsec_dsao
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B84h
; COMDAT (pick any)
		public ??_C@_0BA@PAHPCBBP@UBSEC?5DH?5method?$AA@
; `string'
??_C@_0BA@PAHPCBBP@UBSEC?5DH?5method?$AA@ db 'UBSEC DH method',0
					; DATA XREF: .data:_ubsec_dho
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B94h
; COMDAT (pick any)
		public ??_C@_05IPGGNINO@ubsec?$AA@
; `string'
??_C@_05IPGGNINO@ubsec?$AA@ db 'ubsec',0 ; DATA XREF: .data:_engine_ubsec_ido
					; _get_UBSEC_LIBNAME+6o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0B9Ch
; COMDAT (pick any)
		public ??_C@_0BO@PGABPCJ@UBSEC?5hardware?5engine?5support?$AA@
; `string'
??_C@_0BO@PGABPCJ@UBSEC?5hardware?5engine?5support?$AA@	db 'UBSEC hardware engine support',0
					; DATA XREF: .data:_engine_ubsec_nameo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BBCh
; COMDAT (pick any)
		public ??_C@_0BE@NJOFPNJG@ubsec_bytes_to_bits?$AA@
; `string'
??_C@_0BE@NJOFPNJG@ubsec_bytes_to_bits?$AA@ db 'ubsec_bytes_to_bits',0
					; DATA XREF: .data:_UBSEC_F1o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BD0h
; COMDAT (pick any)
		public ??_C@_0BE@OHJFNGCO@ubsec_bits_to_bytes?$AA@
; `string'
??_C@_0BE@OHJFNGCO@ubsec_bits_to_bytes?$AA@ db 'ubsec_bits_to_bytes',0
					; DATA XREF: .data:_UBSEC_F2o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BE4h
; COMDAT (pick any)
		public ??_C@_0L@BNIDNGJI@ubsec_open?$AA@
; `string'
??_C@_0L@BNIDNGJI@ubsec_open?$AA@ db 'ubsec_open',0 ; DATA XREF: .data:_UBSEC_F3o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BF0h
; COMDAT (pick any)
		public ??_C@_0M@EPNCGNPN@ubsec_close?$AA@
; `string'
??_C@_0M@EPNCGNPN@ubsec_close?$AA@ db 'ubsec_close',0 ; DATA XREF: .data:_UBSEC_F4o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0BFCh
; COMDAT (pick any)
		public ??_C@_0BO@JMBHODEE@diffie_hellman_generate_ioctl?$AA@
; `string'
??_C@_0BO@JMBHODEE@diffie_hellman_generate_ioctl?$AA@ db 'diffie_hellman_generate_ioctl',0
					; DATA XREF: .data:_UBSEC_F5o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C1Ch
; COMDAT (pick any)
		public ??_C@_0BL@LBOPHDHN@diffie_hellman_agree_ioctl?$AA@
; `string'
??_C@_0BL@LBOPHDHN@diffie_hellman_agree_ioctl?$AA@ db 'diffie_hellman_agree_ioctl',0
					; DATA XREF: .data:_UBSEC_F6o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C38h
; COMDAT (pick any)
		public ??_C@_0BC@HODKELEI@rsa_mod_exp_ioctl?$AA@
; `string'
??_C@_0BC@HODKELEI@rsa_mod_exp_ioctl?$AA@ db 'rsa_mod_exp_ioctl',0
					; DATA XREF: .data:_UBSEC_F7o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C4Ch
; COMDAT (pick any)
		public ??_C@_0BG@LJJODNOP@rsa_mod_exp_crt_ioctl?$AA@
; `string'
??_C@_0BG@LJJODNOP@rsa_mod_exp_crt_ioctl?$AA@ db 'rsa_mod_exp_crt_ioctl',0
					; DATA XREF: .data:_UBSEC_F8o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C64h
; COMDAT (pick any)
		public ??_C@_0P@OJMFCJG@dsa_sign_ioctl?$AA@
; `string'
??_C@_0P@OJMFCJG@dsa_sign_ioctl?$AA@ db	'dsa_sign_ioctl',0 ; DATA XREF: .data:_UBSEC_F9o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C74h
; COMDAT (pick any)
		public ??_C@_0BB@KFBEANMO@dsa_verify_ioctl?$AA@
; `string'
??_C@_0BB@KFBEANMO@dsa_verify_ioctl?$AA@ db 'dsa_verify_ioctl',0
					; DATA XREF: .data:_UBSEC_F10o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0C88h
; COMDAT (pick any)
		public ??_C@_0BG@POCKEKBP@math_accelerate_ioctl?$AA@
; `string'
??_C@_0BG@POCKEKBP@math_accelerate_ioctl?$AA@ db 'math_accelerate_ioctl',0
					; DATA XREF: .data:_UBSEC_F11o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CA0h
; COMDAT (pick any)
		public ??_C@_09PCGBKKCC@rng_ioctl?$AA@
; `string'
??_C@_09PCGBKKCC@rng_ioctl?$AA@	db 'rng_ioctl',0 ; DATA XREF: .data:_UBSEC_F12o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CACh
; COMDAT (pick any)
		public ??_C@_0BI@GFLOACB@ubsec_max_key_len_ioctl?$AA@
; `string'
??_C@_0BI@GFLOACB@ubsec_max_key_len_ioctl?$AA@ db 'ubsec_max_key_len_ioctl',0
					; DATA XREF: .data:_UBSEC_F13o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CC4h
; COMDAT (pick any)
		public ??_C@_0L@MNIPMMKP@UBSEC_CTRL?$AA@
; `string'
??_C@_0L@MNIPMMKP@UBSEC_CTRL?$AA@ db 'UBSEC_CTRL',0 ; DATA XREF: .data:00000190o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CD0h
; COMDAT (pick any)
		public ??_C@_0BF@OBJODAOP@UBSEC_DH_COMPUTE_KEY?$AA@
; `string'
??_C@_0BF@OBJODAOP@UBSEC_DH_COMPUTE_KEY?$AA@ db	'UBSEC_DH_COMPUTE_KEY',0
					; DATA XREF: .data:00000198o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CE8h
; COMDAT (pick any)
		public ??_C@_0BG@HKJLNBPK@UBSEC_DH_GENERATE_KEY?$AA@
; `string'
??_C@_0BG@HKJLNBPK@UBSEC_DH_GENERATE_KEY?$AA@ db 'UBSEC_DH_GENERATE_KEY',0
					; DATA XREF: .data:000001A0o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D00h
; COMDAT (pick any)
		public ??_C@_0BC@EODPMEE@UBSEC_DSA_DO_SIGN?$AA@
; `string'
??_C@_0BC@EODPMEE@UBSEC_DSA_DO_SIGN?$AA@ db 'UBSEC_DSA_DO_SIGN',0
					; DATA XREF: .data:000001A8o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D14h
; COMDAT (pick any)
		public ??_C@_0BB@OAENJIDI@UBSEC_DSA_VERIFY?$AA@
; `string'
??_C@_0BB@OAENJIDI@UBSEC_DSA_VERIFY?$AA@ db 'UBSEC_DSA_VERIFY',0
					; DATA XREF: .data:000001B0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D28h
; COMDAT (pick any)
		public ??_C@_0N@JCKJACIF@UBSEC_FINISH?$AA@
; `string'
??_C@_0N@JCKJACIF@UBSEC_FINISH?$AA@ db 'UBSEC_FINISH',0 ; DATA XREF: .data:000001B8o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D38h
; COMDAT (pick any)
		public ??_C@_0L@CKPDLHDN@UBSEC_INIT?$AA@
; `string'
??_C@_0L@CKPDLHDN@UBSEC_INIT?$AA@ db 'UBSEC_INIT',0 ; DATA XREF: .data:000001C0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D44h
; COMDAT (pick any)
		public ??_C@_0O@DOCOEAOC@UBSEC_MOD_EXP?$AA@
; `string'
??_C@_0O@DOCOEAOC@UBSEC_MOD_EXP?$AA@ db	'UBSEC_MOD_EXP',0 ; DATA XREF: .data:000001C8o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D54h
; COMDAT (pick any)
		public ??_C@_0BC@EEIHNNLD@UBSEC_MOD_EXP_CRT?$AA@
; `string'
??_C@_0BC@EEIHNNLD@UBSEC_MOD_EXP_CRT?$AA@ db 'UBSEC_MOD_EXP_CRT',0
					; DATA XREF: .data:000001D0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D68h
; COMDAT (pick any)
		public ??_C@_0BB@NOKKLICC@UBSEC_RAND_BYTES?$AA@
; `string'
??_C@_0BB@NOKKLICC@UBSEC_RAND_BYTES?$AA@ db 'UBSEC_RAND_BYTES',0
					; DATA XREF: .data:000001D8o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D7Ch
; COMDAT (pick any)
		public ??_C@_0BC@NNIFNEAA@UBSEC_RSA_MOD_EXP?$AA@
; `string'
??_C@_0BC@NNIFNEAA@UBSEC_RSA_MOD_EXP?$AA@ db 'UBSEC_RSA_MOD_EXP',0
					; DATA XREF: .data:000001E0o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D90h
; COMDAT (pick any)
		public ??_C@_0BG@LGBLJCMM@UBSEC_RSA_MOD_EXP_CRT?$AA@
; `string'
??_C@_0BG@LGBLJCMM@UBSEC_RSA_MOD_EXP_CRT?$AA@ db 'UBSEC_RSA_MOD_EXP_CRT',0
					; DATA XREF: .data:000001E8o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0DA8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ERR_UBSEC_error proc near		; CODE XREF: _ubsec_dsa_do_sign+BFp
					; _ubsec_dsa_do_sign+EEp ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_DBB
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_DBB:				; CODE XREF: _ERR_UBSEC_error+7j
		push	[esp+arg_C]
		push	[esp+4+arg_8]
		push	[esp+8+arg_4]
		push	[esp+0Ch+arg_0]
		push	eax
		call	_ERR_put_error
		add	esp, 14h
		retn
_ERR_UBSEC_error endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0DD8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ERR_load_UBSEC_strings	proc near	; CODE XREF: _bind_helper+115p
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_DEB
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_DEB:				; CODE XREF: _ERR_load_UBSEC_strings+7j
		cmp	ds:_UBSEC_error_init, 0
		jz	short locret_E37
		push	offset _UBSEC_str_functs
		push	eax
		mov	ds:_UBSEC_error_init, 0
		call	_ERR_load_strings
		push	offset _UBSEC_str_reasons
		push	ds:_UBSEC_lib_error_code
		call	_ERR_load_strings
		movzx	eax, byte ptr ds:_UBSEC_lib_error_code
		shl	eax, 18h
		push	offset _UBSEC_lib_name
		push	0
		mov	ds:_UBSEC_lib_name, eax
		call	_ERR_load_strings
		add	esp, 18h

locret_E37:				; CODE XREF: _ERR_load_UBSEC_strings+1Aj
		retn
_ERR_load_UBSEC_strings	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E38h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ERR_unload_UBSEC_strings proc near
		cmp	ds:_UBSEC_error_init, 0
		jnz	short locret_E7A
		push	offset _UBSEC_str_functs
		push	ds:_UBSEC_lib_error_code
		call	_ERR_unload_strings
		push	offset _UBSEC_str_reasons
		push	ds:_UBSEC_lib_error_code
		call	_ERR_unload_strings
		push	offset _UBSEC_lib_name
		push	0
		call	_ERR_unload_strings
		add	esp, 18h
		mov	ds:_UBSEC_error_init, 1

locret_E7A:				; CODE XREF: _ERR_unload_UBSEC_strings+7j
		retn
_ERR_unload_UBSEC_strings endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E7Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _bind_engine
_bind_engine	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		call	_ENGINE_get_static_state
		mov	esi, [esp+4+arg_8]
		cmp	eax, [esi]
		jz	short $skip_cbs$19
		push	dword ptr [esi+14h]
		push	dword ptr [esi+10h]
		push	dword ptr [esi+0Ch]
		call	_CRYPTO_set_mem_functions
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_EA3

loc_E9F:				; CODE XREF: _bind_engine+5Cj
					; _bind_engine+6Bj ...
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_EA3:				; CODE XREF: _bind_engine+21j
		push	dword ptr [esi+18h]
		call	_CRYPTO_set_locking_callback
		push	dword ptr [esi+1Ch]
		call	_CRYPTO_set_add_lock_callback
		push	dword ptr [esi+20h]
		call	_CRYPTO_set_dynlock_create_callback
		push	dword ptr [esi+24h]
		call	_CRYPTO_set_dynlock_lock_callback
		push	dword ptr [esi+28h]
		call	_CRYPTO_set_dynlock_destroy_callback
		push	dword ptr [esi+8]
		call	_CRYPTO_set_ex_data_implementation
		add	esp, 18h
		test	eax, eax
		jz	short loc_E9F
		push	dword ptr [esi+4]
		call	_ERR_set_implementation
		add	esp, 4
		test	eax, eax
		jz	short loc_E9F

$skip_cbs$19:				; CODE XREF: _bind_engine+Cj
		mov	eax, [esp+4+arg_4]
		test	eax, eax
		jz	short loc_F29
		mov	ecx, ds:_engine_ubsec_id
		nop	dword ptr [eax+eax+00h]

loc_EFC:				; CODE XREF: _bind_engine+9Aj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_F1C
		test	dl, dl
		jz	short loc_F18
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_F1C
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_EFC

loc_F18:				; CODE XREF: _bind_engine+88j
		xor	eax, eax
		jmp	short loc_F21
; ---------------------------------------------------------------------------

loc_F1C:				; CODE XREF: _bind_engine+84j
					; _bind_engine+90j
		sbb	eax, eax
		or	eax, 1

loc_F21:				; CODE XREF: _bind_engine+9Ej
		test	eax, eax
		jnz	loc_E9F

loc_F29:				; CODE XREF: _bind_engine+73j
		push	[esp+4+arg_0]
		call	_bind_helper
		add	esp, 4
		test	eax, eax
		jz	loc_E9F
		mov	eax, 1
		pop	esi
		retn
_bind_engine	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F44h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_bind_fn	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_4]
		test	eax, eax
		jz	short loc_F80
		mov	ecx, ds:_engine_ubsec_id
		xchg	ax, ax

loc_F54:				; CODE XREF: _bind_fn+2Aj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_F74
		test	dl, dl
		jz	short loc_F70
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_F74
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_F54

loc_F70:				; CODE XREF: _bind_fn+18j
		xor	eax, eax
		jmp	short loc_F79
; ---------------------------------------------------------------------------

loc_F74:				; CODE XREF: _bind_fn+14j _bind_fn+20j
		sbb	eax, eax
		or	eax, 1

loc_F79:				; CODE XREF: _bind_fn+2Ej
		test	eax, eax
		jz	short loc_F80
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_F80:				; CODE XREF: _bind_fn+6j _bind_fn+37j
		push	[esp+arg_0]
		call	_bind_helper
		add	esp, 4
		neg	eax
		sbb	eax, eax
		neg	eax
		retn
_bind_fn	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F94h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_bind_helper	proc near		; CODE XREF: _bind_engine+B1p
					; _bind_fn+40p

arg_0		= dword	ptr  4

		push	esi
		push	ds:_engine_ubsec_id
		mov	esi, [esp+8+arg_0]
		push	esi
		call	_ENGINE_set_id
		add	esp, 8
		test	eax, eax
		jz	loc_10B5
		push	ds:_engine_ubsec_name
		push	esi
		call	_ENGINE_set_name
		add	esp, 8
		test	eax, eax
		jz	loc_10B5
		push	offset _ubsec_rsa
		push	esi
		call	_ENGINE_set_RSA
		add	esp, 8
		test	eax, eax
		jz	loc_10B5
		push	offset _ubsec_dsa
		push	esi
		call	_ENGINE_set_DSA
		add	esp, 8
		test	eax, eax
		jz	loc_10B5
		push	offset _ubsec_dh
		push	esi
		call	_ENGINE_set_DH
		add	esp, 8
		test	eax, eax
		jz	loc_10B5
		push	offset _ubsec_destroy
		push	esi
		call	_ENGINE_set_destroy_function
		add	esp, 8
		test	eax, eax
		jz	loc_10B5
		push	offset _ubsec_init
		push	esi
		call	_ENGINE_set_init_function
		add	esp, 8
		test	eax, eax
		jz	loc_10B5
		push	offset _ubsec_finish
		push	esi
		call	_ENGINE_set_finish_function
		add	esp, 8
		test	eax, eax
		jz	short loc_10B5
		push	offset _ubsec_ctrl
		push	esi
		call	_ENGINE_set_ctrl_function
		add	esp, 8
		test	eax, eax
		jz	short loc_10B5
		push	offset _ubsec_cmd_defns
		push	esi
		call	_ENGINE_set_cmd_defns
		add	esp, 8
		test	eax, eax
		jz	short loc_10B5
		call	_RSA_PKCS1_SSLeay
		mov	ecx, [eax+4]
		mov	ds:dword_C4, ecx
		mov	ecx, [eax+8]
		mov	ds:dword_C8, ecx
		mov	ecx, [eax+0Ch]
		mov	ds:dword_CC, ecx
		mov	eax, [eax+10h]
		mov	ds:dword_D0, eax
		call	_DH_OpenSSL
		mov	ecx, [eax+4]
		mov	ds:off_12C, ecx
		mov	eax, [eax+8]
		mov	ds:off_130, eax
		call	_ERR_load_UBSEC_strings
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_10B5:				; CODE XREF: _bind_helper+16j
					; _bind_helper+2Dj ...
		xor	eax, eax
		pop	esi
		retn
_bind_helper	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 10BCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_free_UBSEC_LIBNAME proc near
		mov	eax, ds:_UBSEC_LIBNAME
		test	eax, eax
		jz	short loc_10CE
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_10CE:				; CODE XREF: _free_UBSEC_LIBNAME+7j
		mov	ds:_UBSEC_LIBNAME, 0
		retn
_free_UBSEC_LIBNAME endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 10DCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_get_UBSEC_LIBNAME proc	near
		mov	ecx, ds:_UBSEC_LIBNAME
		mov	eax, offset ??_C@_05IPGGNINO@ubsec?$AA@	; "ubsec"
		test	ecx, ecx
		cmovnz	eax, ecx
		retn
_get_UBSEC_LIBNAME endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 10F0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_set_UBSEC_LIBNAME proc	near		; CODE XREF: _ubsec_ctrl+A9p

arg_0		= dword	ptr  4

		mov	eax, ds:_UBSEC_LIBNAME
		test	eax, eax
		jz	short loc_1102
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_1102:				; CODE XREF: _set_UBSEC_LIBNAME+7j
		push	[esp+arg_0]
		mov	ds:_UBSEC_LIBNAME, 0
		call	_BUF_strdup
		xor	ecx, ecx
		mov	ds:_UBSEC_LIBNAME, eax
		add	esp, 4
		test	eax, eax
		setnz	cl
		mov	eax, ecx
		retn
_set_UBSEC_LIBNAME endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1128h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ubsec_ctrl	proc near		; DATA XREF: _bind_helper+B3o

arg_4		= dword	ptr  8
arg_C		= dword	ptr  10h

		xor	eax, eax
		cmp	ds:_ubsec_dso, eax
		setnz	al
		cmp	[esp+arg_4], 0C8h ; 'È'
		jz	short loc_116A
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_1150
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_1150:				; CODE XREF: _ubsec_ctrl+1Cj
		push	232h
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	66h ; 'f'
		push	64h ; 'd'
		push	eax
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_116A:				; CODE XREF: _ubsec_ctrl+13j
		mov	ecx, [esp+arg_C]
		test	ecx, ecx
		jnz	short loc_119F
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_1185
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_1185:				; CODE XREF: _ubsec_ctrl+51j
		push	227h
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	43h ; 'C'
		push	64h ; 'd'
		push	eax
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_119F:				; CODE XREF: _ubsec_ctrl+48j
		test	eax, eax
		jz	short loc_11D0
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_11B6
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_11B6:				; CODE XREF: _ubsec_ctrl+82j
		push	22Bh
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	64h ; 'd'
		push	64h ; 'd'
		push	eax
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_11D0:				; CODE XREF: _ubsec_ctrl+79j
		push	ecx
		call	_set_UBSEC_LIBNAME
		add	esp, 4
		retn
_ubsec_ctrl	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 11DCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ubsec_destroy	proc near		; DATA XREF: _bind_helper+75o
		mov	eax, ds:_UBSEC_LIBNAME
		test	eax, eax
		jz	short loc_11EE
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_11EE:				; CODE XREF: _ubsec_destroy+7j
		cmp	ds:_UBSEC_error_init, 0
		mov	ds:_UBSEC_LIBNAME, 0
		jnz	short loc_123A
		push	offset _UBSEC_str_functs
		push	ds:_UBSEC_lib_error_code
		call	_ERR_unload_strings
		push	offset _UBSEC_str_reasons
		push	ds:_UBSEC_lib_error_code
		call	_ERR_unload_strings
		push	offset _UBSEC_lib_name
		push	0
		call	_ERR_unload_strings
		add	esp, 18h
		mov	ds:_UBSEC_error_init, 1

loc_123A:				; CODE XREF: _ubsec_destroy+23j
		mov	eax, 1
		retn
_ubsec_destroy	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1240h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ubsec_finish	proc near		; DATA XREF: _bind_helper+A1o
		mov	eax, ds:_UBSEC_LIBNAME
		test	eax, eax
		jz	short loc_1252
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_1252:				; CODE XREF: _ubsec_finish+7j
		mov	eax, ds:_ubsec_dso
		mov	ds:_UBSEC_LIBNAME, 0
		test	eax, eax
		jnz	short loc_1292
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_1278
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_1278:				; CODE XREF: _ubsec_finish+2Cj
		push	203h
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	69h ; 'i'
		push	68h ; 'h'
		push	eax
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1292:				; CODE XREF: _ubsec_finish+23j
		push	eax
		call	_DSO_free
		add	esp, 4
		test	eax, eax
		jnz	short loc_12CC
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_12B2
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_12B2:				; CODE XREF: _ubsec_finish+66j
		push	207h
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	67h ; 'g'
		push	68h ; 'h'
		push	eax
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_12CC:				; CODE XREF: _ubsec_finish+5Dj
		mov	ds:_ubsec_dso, 0
		mov	eax, 1
		mov	ds:_p_UBSEC_ubsec_bytes_to_bits, 0
		mov	ds:_p_UBSEC_ubsec_bits_to_bytes, 0
		mov	ds:_p_UBSEC_ubsec_open,	0
		mov	ds:_p_UBSEC_ubsec_close, 0
		mov	ds:_p_UBSEC_diffie_hellman_generate_ioctl, 0
		mov	ds:_p_UBSEC_diffie_hellman_agree_ioctl,	0
		mov	ds:_p_UBSEC_rsa_mod_exp_ioctl, 0
		mov	ds:_p_UBSEC_rsa_mod_exp_crt_ioctl, 0
		mov	ds:_p_UBSEC_dsa_sign_ioctl, 0
		mov	ds:_p_UBSEC_dsa_verify_ioctl, 0
		mov	ds:_p_UBSEC_math_accelerate_ioctl, 0
		mov	ds:_p_UBSEC_rng_ioctl, 0
		mov	ds:_p_UBSEC_max_key_len_ioctl, 0
		retn
_ubsec_finish	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1360h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ubsec_init	proc near		; DATA XREF: _bind_helper+8Bo

var_20		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4

		mov	eax, 20h ; ' '
		call	__chkstk
		cmp	ds:_ubsec_dso, 0
		push	ebx
		push	ebp
		push	esi
		push	edi
		jz	short loc_139B
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_138A
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_138A:				; CODE XREF: _ubsec_init+1Ej
		push	196h
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	64h ; 'd'
		jmp	loc_1647
; ---------------------------------------------------------------------------

loc_139B:				; CODE XREF: _ubsec_init+15j
		mov	eax, ds:_UBSEC_LIBNAME
		mov	ecx, offset ??_C@_05IPGGNINO@ubsec?$AA@	; "ubsec"
		test	eax, eax
		push	0
		cmovnz	ecx, eax
		push	0
		push	ecx
		push	0
		call	_DSO_load
		add	esp, 10h
		mov	ds:_ubsec_dso, eax
		test	eax, eax
		jnz	short loc_13DF
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_13D5
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_13D5:				; CODE XREF: _ubsec_init+69j
		push	19Eh
		jmp	loc_1640
; ---------------------------------------------------------------------------

loc_13DF:				; CODE XREF: _ubsec_init+60j
		push	ds:_UBSEC_F1
		push	eax
		call	_DSO_bind_func
		mov	edi, eax
		add	esp, 8
		test	edi, edi
		jz	loc_1628
		push	ds:_UBSEC_F2
		push	ds:_ubsec_dso
		call	_DSO_bind_func
		mov	ebx, eax
		add	esp, 8
		test	ebx, ebx
		jz	loc_1628
		push	ds:_UBSEC_F3
		push	ds:_ubsec_dso
		call	_DSO_bind_func
		mov	esi, eax
		add	esp, 8
		test	esi, esi
		jz	loc_1628
		push	ds:_UBSEC_F4
		push	ds:_ubsec_dso
		call	_DSO_bind_func
		mov	ebp, eax
		add	esp, 8
		test	ebp, ebp
		jz	loc_1628
		push	ds:_UBSEC_F5
		push	ds:_ubsec_dso
		call	_DSO_bind_func
		add	esp, 8
		mov	[esp+30h+var_20], eax
		test	eax, eax
		jz	loc_1628
		push	ds:_UBSEC_F6
		push	ds:_ubsec_dso
		call	_DSO_bind_func
		add	esp, 8
		mov	[esp+30h+var_1C], eax
		test	eax, eax
		jz	loc_1628
		push	ds:_UBSEC_F7
		push	ds:_ubsec_dso
		call	_DSO_bind_func
		add	esp, 8
		mov	[esp+30h+var_18], eax
		test	eax, eax
		jz	loc_1628
		push	ds:_UBSEC_F8
		push	ds:_ubsec_dso
		call	_DSO_bind_func
		add	esp, 8
		mov	[esp+30h+var_14], eax
		test	eax, eax
		jz	loc_1628
		push	ds:_UBSEC_F9
		push	ds:_ubsec_dso
		call	_DSO_bind_func
		add	esp, 8
		mov	[esp+30h+var_10], eax
		test	eax, eax
		jz	loc_1628
		push	ds:_UBSEC_F10
		push	ds:_ubsec_dso
		call	_DSO_bind_func
		add	esp, 8
		mov	[esp+30h+var_C], eax
		test	eax, eax
		jz	loc_1628
		push	ds:_UBSEC_F11
		push	ds:_ubsec_dso
		call	_DSO_bind_func
		add	esp, 8
		mov	[esp+30h+var_8], eax
		test	eax, eax
		jz	loc_1628
		push	ds:_UBSEC_F12
		push	ds:_ubsec_dso
		call	_DSO_bind_func
		add	esp, 8
		mov	[esp+30h+var_4], eax
		test	eax, eax
		jz	loc_1628
		push	ds:_UBSEC_F13
		push	ds:_ubsec_dso
		call	_DSO_bind_func
		mov	ecx, eax
		add	esp, 8
		test	ecx, ecx
		jz	loc_1628
		mov	eax, [esp+30h+var_20]
		mov	ds:_p_UBSEC_diffie_hellman_generate_ioctl, eax
		mov	eax, [esp+30h+var_1C]
		mov	ds:_p_UBSEC_diffie_hellman_agree_ioctl,	eax
		mov	eax, [esp+30h+var_18]
		mov	ds:_p_UBSEC_rsa_mod_exp_ioctl, eax
		mov	eax, [esp+30h+var_14]
		mov	ds:_p_UBSEC_rsa_mod_exp_crt_ioctl, eax
		mov	eax, [esp+30h+var_10]
		mov	ds:_p_UBSEC_dsa_sign_ioctl, eax
		mov	eax, [esp+30h+var_C]
		mov	ds:_p_UBSEC_dsa_verify_ioctl, eax
		mov	eax, [esp+30h+var_8]
		mov	ds:_p_UBSEC_math_accelerate_ioctl, eax
		mov	eax, [esp+30h+var_4]
		push	offset ??_C@_0M@IDHLONIG@?1dev?1ubskey?$AA@ ; "/dev/ubskey"
		mov	ds:_p_UBSEC_ubsec_bytes_to_bits, edi
		mov	ds:_p_UBSEC_ubsec_bits_to_bytes, ebx
		mov	ds:_p_UBSEC_ubsec_open,	esi
		mov	ds:_p_UBSEC_ubsec_close, ebp
		mov	ds:_p_UBSEC_rng_ioctl, eax
		mov	ds:_p_UBSEC_max_key_len_ioctl, ecx
		call	esi
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jle	short loc_1610
		push	offset _max_key_len
		push	esi
		call	ds:_p_UBSEC_max_key_len_ioctl
		add	esp, 8
		test	eax, eax
		jnz	short loc_1610
		push	esi
		call	ds:_p_UBSEC_ubsec_close
		add	esp, 4
		mov	eax, 1
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 20h
		retn
; ---------------------------------------------------------------------------

loc_1610:				; CODE XREF: _ubsec_init+284j
					; _ubsec_init+297j
		push	1E1h
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	6Ch ; 'l'
		push	69h ; 'i'
		call	_ERR_UBSEC_error
		add	esp, 10h
		jmp	short $err$25
; ---------------------------------------------------------------------------

loc_1628:				; CODE XREF: _ubsec_init+92j
					; _ubsec_init+B0j ...
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_163B
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_163B:				; CODE XREF: _ubsec_init+2CFj
		push	1C2h

loc_1640:				; CODE XREF: _ubsec_init+7Aj
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	67h ; 'g'

loc_1647:				; CODE XREF: _ubsec_init+36j
		push	69h ; 'i'
		push	eax
		call	_ERR_put_error
		add	esp, 14h

$err$25:				; CODE XREF: _ubsec_init+2C6j
		mov	eax, ds:_ubsec_dso
		test	eax, eax
		jz	short loc_1664
		push	eax
		call	_DSO_free
		add	esp, 4

loc_1664:				; CODE XREF: _ubsec_init+2F9j
		pop	edi
		pop	esi
		pop	ebp
		mov	ds:_ubsec_dso, 0
		xor	eax, eax
		mov	ds:_p_UBSEC_ubsec_bytes_to_bits, 0
		mov	ds:_p_UBSEC_ubsec_bits_to_bytes, 0
		mov	ds:_p_UBSEC_ubsec_open,	0
		mov	ds:_p_UBSEC_ubsec_close, 0
		mov	ds:_p_UBSEC_diffie_hellman_generate_ioctl, 0
		mov	ds:_p_UBSEC_diffie_hellman_agree_ioctl,	0
		mov	ds:_p_UBSEC_rsa_mod_exp_ioctl, 0
		mov	ds:_p_UBSEC_rsa_mod_exp_crt_ioctl, 0
		mov	ds:_p_UBSEC_dsa_sign_ioctl, 0
		mov	ds:_p_UBSEC_dsa_verify_ioctl, 0
		mov	ds:_p_UBSEC_math_accelerate_ioctl, 0
		mov	ds:_p_UBSEC_rng_ioctl, 0
		mov	ds:_p_UBSEC_max_key_len_ioctl, 0
		pop	ebx
		add	esp, 20h
		retn
_ubsec_init	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 16FCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ubsec_mod_exp	proc near		; CODE XREF: _ubsec_mod_exp_mont+4Bp
					; _ubsec_mod_exp_dh+14p

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	eax, 4
		call	__chkstk
		cmp	ds:_ubsec_dso, 0
		mov	[esp+4+var_4], 0
		jnz	short loc_1744
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_1729
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_1729:				; CODE XREF: _ubsec_mod_exp+21j
		push	23Dh
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	69h ; 'i'
		push	6Ah ; 'j'
		push	eax
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_1744:				; CODE XREF: _ubsec_mod_exp+18j
		push	edi
		mov	edi, [esp+8+arg_C]
		push	edi
		call	_BN_num_bits
		add	esp, 4
		mov	[esp+8+var_4], eax
		cmp	eax, ds:_max_key_len
		jle	short loc_17A1
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_1771
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_1771:				; CODE XREF: _ubsec_mod_exp+69j
		push	244h
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	6Bh ; 'k'
		push	6Ah ; 'j'
		push	eax
		call	_ERR_put_error
		push	[esp+1Ch+arg_10]
		push	edi
		push	[esp+24h+arg_8]
		push	[esp+28h+arg_4]
		push	[esp+2Ch+arg_0]
		call	_BN_mod_exp
		add	esp, 28h
		pop	edi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_17A1:				; CODE XREF: _ubsec_mod_exp+60j
		mov	eax, [edi+4]
		push	esi
		mov	esi, [esp+0Ch+arg_0]
		cmp	eax, [esi+8]
		jg	short loc_17B2
		mov	eax, esi
		jmp	short loc_17BC
; ---------------------------------------------------------------------------

loc_17B2:				; CODE XREF: _ubsec_mod_exp+B0j
		push	eax
		push	esi
		call	_bn_expand2
		add	esp, 8

loc_17BC:				; CODE XREF: _ubsec_mod_exp+B4j
		test	eax, eax
		jnz	short loc_17F0
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_17D3
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_17D3:				; CODE XREF: _ubsec_mod_exp+CBj
		push	249h
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	65h ; 'e'
		push	6Ah ; 'j'
		push	eax
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		pop	edi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_17F0:				; CODE XREF: _ubsec_mod_exp+C2j
		push	ebx
		push	offset ??_C@_0M@IDHLONIG@?1dev?1ubskey?$AA@ ; "/dev/ubskey"
		call	ds:_p_UBSEC_ubsec_open
		mov	ebx, eax
		add	esp, 4
		test	ebx, ebx
		jg	short loc_1847
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_1818
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_1818:				; CODE XREF: _ubsec_mod_exp+110j
		push	24Fh
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	6Ch ; 'l'
		push	6Ah ; 'j'
		push	eax
		call	_ERR_put_error
		push	[esp+24h+arg_10]
		push	edi
		push	[esp+2Ch+arg_8]
		push	[esp+30h+arg_4]
		push	esi
		call	_BN_mod_exp
		add	esp, 28h
		pop	ebx
		pop	esi
		pop	edi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_1847:				; CODE XREF: _ubsec_mod_exp+107j
		push	ebp
		mov	ebp, [esp+14h+arg_8]
		lea	eax, [esp+14h+var_4]
		push	eax
		push	dword ptr [esi]
		push	ebp
		call	_BN_num_bits
		add	esp, 4
		push	eax
		push	dword ptr [ebp+0]
		push	edi
		call	_BN_num_bits
		add	esp, 4
		push	eax
		push	dword ptr [edi]
		push	[esp+2Ch+arg_4]
		call	_BN_num_bits
		add	esp, 4
		push	eax
		mov	eax, [esp+30h+arg_4]
		push	dword ptr [eax]
		push	ebx
		call	ds:_p_UBSEC_rsa_mod_exp_ioctl
		add	esp, 24h
		test	eax, eax
		jz	short loc_18C0
		push	257h
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	6Ah ; 'j'
		push	6Ah ; 'j'
		call	_ERR_UBSEC_error
		push	ebx
		call	ds:_p_UBSEC_ubsec_close
		push	[esp+28h+arg_10]
		push	edi
		push	ebp
		push	[esp+34h+arg_4]
		push	esi
		call	_BN_mod_exp
		add	esp, 28h
		pop	ebp
		pop	ebx
		pop	esi
		pop	edi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_18C0:				; CODE XREF: _ubsec_mod_exp+18Fj
		push	ebx
		call	ds:_p_UBSEC_ubsec_close
		push	edi
		call	_BN_num_bits
		add	eax, 1Fh
		add	esp, 8
		cdq
		and	edx, 1Fh
		add	eax, edx
		pop	ebp
		sar	eax, 5
		pop	ebx
		mov	[esi+4], eax
		mov	eax, 1
		pop	esi
		pop	edi
		pop	ecx
		retn
_ubsec_mod_exp	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 18ECh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ubsec_mod_exp_crt proc	near		; CODE XREF: _ubsec_rsa_mod_exp+3Dp

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h
arg_18		= dword	ptr  1Ch

		mov	eax, 4
		call	__chkstk
		push	ebp
		mov	ebp, [esp+8+arg_8]
		push	esi
		push	ebp
		call	_BN_num_bits
		push	[esp+10h+arg_C]
		mov	esi, eax
		call	_BN_num_bits
		add	esi, eax
		add	esp, 8
		mov	[esp+0Ch+var_4], esi
		cmp	esi, ds:_max_key_len
		jle	short loc_1951
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_1931
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_1931:				; CODE XREF: _ubsec_mod_exp_crt+39j
		push	287h
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	6Bh ; 'k'
		push	6Eh ; 'n'
		push	eax
		call	_ERR_put_error
		add	esp, 14h
		mov	eax, 0FFFFFFF1h
		pop	esi
		pop	ebp
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_1951:				; CODE XREF: _ubsec_mod_exp_crt+30j
		mov	esi, [esp+0Ch+arg_C]
		push	edi
		mov	edi, [esp+10h+arg_0]
		mov	eax, [esi+4]
		inc	eax
		add	eax, [ebp+4]
		cmp	eax, [edi+8]
		jg	short loc_196A
		mov	eax, edi
		jmp	short loc_1974
; ---------------------------------------------------------------------------

loc_196A:				; CODE XREF: _ubsec_mod_exp_crt+78j
		push	eax
		push	edi
		call	_bn_expand2
		add	esp, 8

loc_1974:				; CODE XREF: _ubsec_mod_exp_crt+7Cj
		test	eax, eax
		jnz	short loc_19A9
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_198B
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_198B:				; CODE XREF: _ubsec_mod_exp_crt+93j
		push	28Ch
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	65h ; 'e'
		push	6Eh ; 'n'
		push	eax
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_19A9:				; CODE XREF: _ubsec_mod_exp_crt+8Aj
		push	ebx
		push	offset ??_C@_0M@IDHLONIG@?1dev?1ubskey?$AA@ ; "/dev/ubskey"
		call	ds:_p_UBSEC_ubsec_open
		mov	ebx, eax
		add	esp, 4
		test	ebx, ebx
		jg	short loc_19F3
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_19D1
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_19D1:				; CODE XREF: _ubsec_mod_exp_crt+D9j
		push	292h
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	6Ch ; 'l'
		push	6Eh ; 'n'
		push	eax
		call	_ERR_put_error
		add	esp, 14h
		mov	eax, 0FFFFFFF1h
		pop	ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_19F3:				; CODE XREF: _ubsec_mod_exp_crt+D0j
		lea	eax, [esp+14h+var_4]
		push	eax
		push	dword ptr [edi]
		push	esi
		call	_BN_num_bits
		add	esp, 4
		push	eax
		push	dword ptr [esi]
		mov	esi, [esp+24h+arg_14]
		push	esi
		call	_BN_num_bits
		add	esp, 4
		push	eax
		push	dword ptr [esi]
		push	ebp
		call	_BN_num_bits
		mov	esi, [esp+30h+arg_10]
		add	esp, 4
		push	eax
		push	dword ptr [ebp+0]
		push	esi
		call	_BN_num_bits
		add	esp, 4
		push	eax
		push	dword ptr [esi]
		mov	esi, [esp+3Ch+arg_18]
		push	esi
		call	_BN_num_bits
		add	esp, 4
		push	eax
		push	dword ptr [esi]
		mov	esi, [esp+44h+arg_4]
		push	esi
		call	_BN_num_bits
		add	esp, 4
		push	eax
		push	dword ptr [esi]
		push	ebx
		call	ds:_p_UBSEC_rsa_mod_exp_crt_ioctl
		add	esp, 3Ch
		test	eax, eax
		jz	short loc_1A9D
		mov	eax, ds:_UBSEC_lib_error_code
		test	eax, eax
		jnz	short loc_1A74
		call	_ERR_get_next_error_library
		mov	ds:_UBSEC_lib_error_code, eax

loc_1A74:				; CODE XREF: _ubsec_mod_exp_crt+17Cj
		push	29Fh
		push	offset ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@ ; ".\\engines\\e_ubsec.c"
		push	6Ah ; 'j'
		push	6Eh ; 'n'
		push	eax
		call	_ERR_put_error
		push	ebx
		call	ds:_p_UBSEC_ubsec_close
		add	esp, 18h
		mov	eax, 0FFFFFFF1h
		pop	ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_1A9D:				; CODE XREF: _ubsec_mod_exp_crt+173j
		push	ebx
		call	ds:_p_UBSEC_ubsec_close
		push	ebp
		call	_BN_num_bits
		push	[esp+1Ch+arg_C]
		mov	esi, eax
		call	_BN_num_bits
		add	eax, 1Fh
		add	esp, 0Ch
		add	eax, esi
		cdq
		and	edx, 1Fh
		add	eax, edx
		sar	eax, 5
		pop	ebx
		mov	[edi+4], eax
		mov	eax, 1
		pop	edi
		pop	esi
		pop	ebp
		pop	ecx
		retn
_ubsec_mod_exp_crt endp

_text$mn	ends

;
; Exported entry
;
; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1AD4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _v_check
_v_check	proc near

arg_0		= dword	ptr  4

		cmp	[esp+arg_0], 20000h
		sbb	eax, eax
		and	eax, 0FFFE0000h
		add	eax, 20000h
		retn
_v_check	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1AECh
; COMDAT (pick any)
		public ??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@
; `string'
??_C@_0BE@BCALDJJD@?4?2engines?2e_ubsec?4c?$AA@	db '.\engines\e_ubsec.c',0
					; DATA XREF: _ubsec_rsa_mod_exp+7Ao
					; _ubsec_dsa_do_sign:loc_436o ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1B00h
; COMDAT (pick any)
		public ??_C@_0M@IDHLONIG@?1dev?1ubskey?$AA@
; `string'
??_C@_0M@IDHLONIG@?1dev?1ubskey?$AA@ db	'/dev/ubskey',0
					; DATA XREF: _ubsec_dsa_do_sign:loc_44Co
					; _ubsec_dsa_verify+9Ao ...
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _CRYPTO_set_ex_data_implementation:near ;	CODE XREF: _bind_engine+52p
		extrn _CRYPTO_set_locking_callback:near	; CODE XREF: _bind_engine+2Ap
		extrn _CRYPTO_set_add_lock_callback:near ; CODE	XREF: _bind_engine+32p
		extrn _CRYPTO_set_dynlock_create_callback:near ; CODE XREF: _bind_engine+3Ap
		extrn _CRYPTO_set_dynlock_lock_callback:near ; CODE XREF: _bind_engine+42p
		extrn _CRYPTO_set_dynlock_destroy_callback:near
					; CODE XREF: _bind_engine+4Ap
		extrn _CRYPTO_set_mem_functions:near ; CODE XREF: _bind_engine+17p
		extrn _CRYPTO_free:near	; CODE XREF: _free_UBSEC_LIBNAME+Ap
					; _set_UBSEC_LIBNAME+Ap ...
		extrn _BUF_strdup:near	; CODE XREF: _set_UBSEC_LIBNAME+20p
		extrn _DSO_free:near	; CODE XREF: _ubsec_finish+53p
					; _ubsec_init+2FCp
		extrn _DSO_load:near	; CODE XREF: _ubsec_init+51p
		extrn _DSO_bind_func:near ; CODE XREF: _ubsec_init+86p
					; _ubsec_init+A4p ...
		extrn _BN_rand_range:near ; CODE XREF: _ubsec_dh_generate_key+74p
		extrn _BN_num_bits:near	; CODE XREF: _ubsec_mod_exp_mont+6p
					; _ubsec_dsa_do_sign+126p ...
		extrn _BN_new:near	; CODE XREF: _ubsec_dsa_do_sign+2Dp
					; _ubsec_dsa_do_sign+34p ...
		extrn _BN_init:near	; CODE XREF: _ubsec_dsa_do_sign+25p
					; _ubsec_dsa_verify+13p
		extrn _BN_clear_free:near ; CODE XREF: _ubsec_dsa_do_sign+247p
					; _ubsec_dsa_verify+6Cp ...
		extrn _BN_bin2bn:near	; CODE XREF: _ubsec_dsa_do_sign+A5p
		extrn _BN_free:near	; CODE XREF: _ubsec_dsa_do_sign+22Dp
					; _ubsec_dsa_do_sign+23Ap
		extrn _BN_mod_exp:near	; CODE XREF: _ubsec_mod_exp+9Ap
					; _ubsec_mod_exp+13Ep ...
		extrn _bn_expand2:near	; CODE XREF: _ubsec_dsa_do_sign+6Ep
					; _ubsec_dsa_do_sign+8Bp ...
		extrn _RSA_PKCS1_SSLeay:near ; CODE XREF: _ubsec_rsa_mod_exp+4Ap
					; _ubsec_mod_exp_mont+16p ...
		extrn _DH_OpenSSL:near	; CODE XREF: _ubsec_dh_compute_key+4Dp
					; _ubsec_dh_compute_key+DEp ...
		extrn _DSA_SIG_new:near	; CODE XREF: _ubsec_dsa_do_sign+1DEp
		extrn _DSA_OpenSSL:near	; CODE XREF: _ubsec_dsa_do_sign+F3p
					; _ubsec_dsa_do_sign+1AAp ...
		extrn _ERR_put_error:near ; CODE XREF: _ubsec_rsa_mod_exp+84p
					; _ubsec_dsa_do_sign+220p ...
		extrn _ERR_load_strings:near ; CODE XREF: _ERR_load_UBSEC_strings+2Cp
					; _ERR_load_UBSEC_strings+3Cp ...
		extrn _ERR_unload_strings:near ; CODE XREF: _ERR_unload_UBSEC_strings+14p
					; _ERR_unload_UBSEC_strings+24p ...
		extrn _ERR_get_next_error_library:near ; CODE XREF: _ubsec_rsa_mod_exp+6Bp
					; _ubsec_dsa_do_sign+207p ...
		extrn _ERR_set_implementation:near ; CODE XREF:	_bind_engine+61p
		extrn _ENGINE_set_id:near ; CODE XREF: _bind_helper+Cp
		extrn _ENGINE_set_name:near ; CODE XREF: _bind_helper+23p
		extrn _ENGINE_set_RSA:near ; CODE XREF:	_bind_helper+39p
		extrn _ENGINE_set_DSA:near ; CODE XREF:	_bind_helper+4Fp
		extrn _ENGINE_set_DH:near ; CODE XREF: _bind_helper+65p
		extrn _ENGINE_set_destroy_function:near	; CODE XREF: _bind_helper+7Bp
		extrn _ENGINE_set_init_function:near ; CODE XREF: _bind_helper+91p
		extrn _ENGINE_set_finish_function:near ; CODE XREF: _bind_helper+A7p
		extrn _ENGINE_set_ctrl_function:near ; CODE XREF: _bind_helper+B9p
		extrn _ENGINE_set_cmd_defns:near ; CODE	XREF: _bind_helper+CBp
		extrn _ENGINE_get_static_state:near ; CODE XREF: _bind_engine+1p
		extrn __chkstk:near	; CODE XREF: _ubsec_dsa_do_sign+5p
					; _ubsec_dsa_verify+5p	...


		end
