;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	C337CBD80739FB07993A22F3AD623942
; Input	CRC32 :	826EB68A

; File Name   :	C:\compspace\Diff\openssl\obj\bss_sock.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl sock_write(int, char *buf, int len)
_sock_write	proc near		; CODE XREF: _sock_puts+1Fp
					; DATA XREF: .data:00000264o

arg_0		= dword	ptr  4
buf		= dword	ptr  8
len		= dword	ptr  0Ch

		push	esi
		push	edi
		push	0		; iError
		call	dword ptr ds:__imp__WSASetLastError@4 ;	WSASetLastError(x)
		mov	edi, [esp+8+arg_0]
		push	0		; flags
		push	[esp+0Ch+len]	; len
		push	[esp+10h+buf]	; buf
		push	dword ptr [edi+1Ch] ; s
		call	dword ptr ds:__imp__send@16 ; send(x,x,x,x)
		push	0Fh
		push	edi
		mov	esi, eax
		call	_BIO_clear_flags
		add	esp, 8
		test	esi, esi
		jg	short loc_57
		jz	short loc_39
		cmp	esi, 0FFFFFFFFh
		jnz	short loc_57

loc_39:					; CODE XREF: _sock_write+32j
		call	dword ptr ds:__imp__WSAGetLastError@0 ;	WSAGetLastError()
		push	eax
		call	_BIO_sock_non_fatal_error
		add	esp, 4
		test	eax, eax
		jz	short loc_57
		push	0Ah
		push	edi
		call	_BIO_set_flags
		add	esp, 8

loc_57:					; CODE XREF: _sock_write+30j
					; _sock_write+37j ...
		pop	edi
		mov	eax, esi
		pop	esi
		retn
_sock_write	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl sock_read(int, char *buf,	int len)
_sock_read	proc near		; DATA XREF: .data:00000268o

arg_0		= dword	ptr  4
buf		= dword	ptr  8
len		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+buf]
		test	esi, esi
		jz	short loc_BD
		push	edi
		push	0		; iError
		call	dword ptr ds:__imp__WSASetLastError@4 ;	WSASetLastError(x)
		mov	edi, [esp+8+arg_0]
		push	0		; flags
		push	[esp+0Ch+len]	; len
		push	esi		; buf
		push	dword ptr [edi+1Ch] ; s
		call	dword ptr ds:__imp__recv@16 ; recv(x,x,x,x)
		push	0Fh
		push	edi
		mov	esi, eax
		call	_BIO_clear_flags
		add	esp, 8
		test	esi, esi
		jg	short loc_B8
		jz	short loc_9A
		cmp	esi, 0FFFFFFFFh
		jnz	short loc_B8

loc_9A:					; CODE XREF: _sock_read+37j
		call	dword ptr ds:__imp__WSAGetLastError@0 ;	WSAGetLastError()
		push	eax
		call	_BIO_sock_non_fatal_error
		add	esp, 4
		test	eax, eax
		jz	short loc_B8
		push	9
		push	edi
		call	_BIO_set_flags
		add	esp, 8

loc_B8:					; CODE XREF: _sock_read+35j
					; _sock_read+3Cj ...
		pop	edi
		mov	eax, esi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_BD:					; CODE XREF: _sock_read+7j
		xor	eax, eax
		pop	esi
		retn
_sock_read	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl sock_puts(int, char *buf)
_sock_puts	proc near		; DATA XREF: .data:0000026Co

arg_0		= dword	ptr  4
buf		= dword	ptr  8

		mov	edx, [esp+buf]
		mov	eax, edx
		push	esi
		lea	esi, [eax+1]
		nop	word ptr [eax+eax+00h]

loc_D4:					; CODE XREF: _sock_puts+15j
		mov	cl, [eax]
		inc	eax
		test	cl, cl
		jnz	short loc_D4
		sub	eax, esi
		push	eax		; len
		push	edx		; buf
		push	[esp+0Ch+arg_0]	; int
		call	_sock_write
		add	esp, 0Ch
		pop	esi
		retn
_sock_puts	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_sock_ctrl	proc near		; DATA XREF: .data:00000274o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, [esp+arg_4]
		add	eax, 0FFFFFFF8h	; switch 98 cases
		cmp	eax, 61h ; 'a'
		ja	short $LN12	; jumptable 00000103 default case
		movzx	eax, ds:$LN14[eax]
		jmp	ds:$LN16[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN4_0:					; CODE XREF: _sock_ctrl+13j
					; DATA XREF: .text$mn:$LN16o
		push	esi		; jumptable 00000103 case 104
		mov	esi, [esp+4+arg_0]
		push	esi
		call	_sock_free
		mov	ecx, [esp+8+arg_C]
		add	esp, 4
		mov	eax, 1
		mov	ecx, [ecx]
		mov	[esi+1Ch], ecx
		mov	ecx, [esp+4+arg_8]
		mov	[esi+10h], ecx
		mov	dword ptr [esi+0Ch], 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

$LN5_0:					; CODE XREF: _sock_ctrl+13j
					; DATA XREF: .text$mn:$LN16o
		mov	ecx, [esp+arg_0] ; jumptable 00000103 case 105
		cmp	dword ptr [ecx+0Ch], 0
		jz	short loc_151
		mov	edx, [esp+arg_C]
		test	edx, edx
		jz	short loc_14D
		mov	eax, [ecx+1Ch]
		mov	[edx], eax

loc_14D:				; CODE XREF: _sock_ctrl+56j
		mov	eax, [ecx+1Ch]
		retn
; ---------------------------------------------------------------------------

loc_151:				; CODE XREF: _sock_ctrl+4Ej
		or	eax, 0FFFFFFFFh
		retn
; ---------------------------------------------------------------------------

$LN9:					; CODE XREF: _sock_ctrl+13j
					; DATA XREF: .text$mn:$LN16o
		mov	eax, [esp+arg_0] ; jumptable 00000103 case 8
		mov	eax, [eax+10h]
		retn
; ---------------------------------------------------------------------------

$LN10_0:				; CODE XREF: _sock_ctrl+13j
					; DATA XREF: .text$mn:$LN16o
		mov	eax, [esp+arg_0] ; jumptable 00000103 case 9
		mov	ecx, [esp+arg_8]
		mov	[eax+10h], ecx

$LN11:					; CODE XREF: _sock_ctrl+13j
					; DATA XREF: .text$mn:$LN16o
		mov	eax, 1		; jumptable 00000103 cases 11,12
		retn
; ---------------------------------------------------------------------------

$LN12:					; CODE XREF: _sock_ctrl+Aj
					; _sock_ctrl+13j
					; DATA XREF: ...
		xor	eax, eax	; jumptable 00000103 default case
		retn
_sock_ctrl	endp

; ---------------------------------------------------------------------------
		align 4
$LN16		dd offset $LN9,	offset $LN10_0,	offset $LN11, offset $LN4_0
					; DATA XREF: _sock_ctrl+13r
		dd offset $LN5_0, offset $LN12 ; jump table for	switch statement
$LN14		db	0,     1,     5,     2 ; DATA XREF: _sock_ctrl+Cr
		db	2,     5,     5,     5 ; indirect table	for switch statement
		db	5,     5,     5,     5
		db	5,     5,     5,     5
		db	5,     5,     5,     5
		db	5,     5,     5,     5
		db	5,     5,     5,     5
		db	5,     5,     5,     5
		db	5,     5,     5,     5
		db	5,     5,     5,     5
		db	5,     5,     5,     5
		db	5,     5,     5,     5
		db	5,     5,     5,     5
		db	5,     5,     5,     5
		db	5,     5,     5,     5
		db	5,     5,     5,     5
		db	5,     5,     5,     5
		db	5,     5,     5,     5
		db	5,     5,     5,     5
		db	5,     5,     5,     5
		db	5,     5,     5,     5
		db	5,     5,     5,     5
		db	5,     5,     5,     5
		db	5,     5,     5,     5
		db	3,     4
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1F0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_sock_new	proc near		; DATA XREF: .data:00000278o

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	dword ptr [eax+0Ch], 0
		mov	dword ptr [eax+1Ch], 0
		mov	dword ptr [eax+20h], 0
		mov	dword ptr [eax+14h], 0
		mov	eax, 1
		retn
_sock_new	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 218h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_sock_free	proc near		; CODE XREF: _sock_ctrl+20p
					; DATA XREF: .data:0000027Co

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jnz	short loc_225
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_225:				; CODE XREF: _sock_free+7j
		cmp	dword ptr [esi+10h], 0
		jz	short loc_253
		cmp	dword ptr [esi+0Ch], 0
		jz	short loc_245
		push	2		; how
		push	dword ptr [esi+1Ch] ; s
		call	dword ptr ds:__imp__shutdown@8 ; shutdown(x,x)
		push	dword ptr [esi+1Ch] ; s
		call	dword ptr ds:__imp__closesocket@4 ; closesocket(x)

loc_245:				; CODE XREF: _sock_free+17j
		mov	dword ptr [esi+0Ch], 0
		mov	dword ptr [esi+14h], 0

loc_253:				; CODE XREF: _sock_free+11j
		mov	eax, 1
		pop	esi
		retn
_sock_free	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 25Ch
_methods_sockp	dd 505h			; DATA XREF: _BIO_new_socket+1o
					; _BIO_s_socketo
		dd offset ??_C@_06HBELJPBO@socket?$AA@ ; "socket"
		dd offset _sock_write
		dd offset _sock_read
		dd offset _sock_puts
		dd 0
		dd offset _sock_ctrl
		dd offset _sock_new
		dd offset _sock_free
		dd 0
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 284h
; COMDAT (pick any)
		public ??_C@_06HBELJPBO@socket?$AA@
; `string'
??_C@_06HBELJPBO@socket?$AA@ db	'socket',0 ; DATA XREF: .data:00000260o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 28Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_new_socket
_BIO_new_socket	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		push	offset _methods_sockp
		call	_BIO_new
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jnz	short loc_2A2
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_2A2:				; CODE XREF: _BIO_new_socket+12j
		push	[esp+4+arg_0]
		push	[esp+8+arg_4]
		push	68h ; 'h'
		push	esi
		call	_BIO_int_ctrl
		add	esp, 10h
		mov	eax, esi
		pop	esi
		retn
_BIO_new_socket	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2BCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_s_socket
_BIO_s_socket	proc near
		mov	eax, offset _methods_sockp
		retn
_BIO_s_socket	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2C4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_sock_non_fatal_error
_BIO_sock_non_fatal_error proc near	; CODE XREF: _sock_write+40p
					; _sock_read+45p ...

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		cmp	eax, 7Eh ; '~'
		jg	short loc_2E5
		jz	short $LN4	; jumptable 000002DE cases 4,11,103,112
		add	eax, 0FFFFFFFCh	; switch 109 cases
		cmp	eax, 6Ch ; 'l'
		ja	short $LN5	; jumptable 000002DE default case
		movzx	eax, ds:$LN8[eax]
		jmp	ds:$LN10[eax*4]	; switch jump
; ---------------------------------------------------------------------------

loc_2E5:				; CODE XREF: _BIO_sock_non_fatal_error+7j
		sub	eax, 86h ; '†'
		jz	short $LN4	; jumptable 000002DE cases 4,11,103,112
		sub	eax, 6
		jz	short $LN4	; jumptable 000002DE cases 4,11,103,112
		sub	eax, 26A7h
		jz	short $LN4	; jumptable 000002DE cases 4,11,103,112

$LN5:					; CODE XREF: _BIO_sock_non_fatal_error+11j
					; _BIO_sock_non_fatal_error+1Aj
					; DATA XREF: ...
		xor	eax, eax	; jumptable 000002DE default case
		retn
; ---------------------------------------------------------------------------

$LN4:					; CODE XREF: _BIO_sock_non_fatal_error+9j
					; _BIO_sock_non_fatal_error+1Aj ...
		mov	eax, 1		; jumptable 000002DE cases 4,11,103,112
		retn
_BIO_sock_non_fatal_error endp

; ---------------------------------------------------------------------------
		align 4
$LN10		dd offset $LN4,	offset $LN5 ; DATA XREF: _BIO_sock_non_fatal_error+1Ar
					; jump table for switch	statement
$LN8		db	0,     1,     1,     1 ; DATA XREF: _BIO_sock_non_fatal_error+13r
		db	1,     1,     1,     0 ; indirect table	for switch statement
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	1,     1,     1,     0
		db	1,     1,     1,     1
		db	1,     1,     1,     1
		db	0
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 37Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_sock_should_retry
_BIO_sock_should_retry proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short loc_38C
		cmp	eax, 0FFFFFFFFh
		jz	short loc_38C
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_38C:				; CODE XREF: _BIO_sock_should_retry+6j
					; _BIO_sock_should_retry+Bj
		call	dword ptr ds:__imp__WSAGetLastError@0 ;	WSAGetLastError()
		mov	[esp+arg_0], eax
		jmp	_BIO_sock_non_fatal_error
_BIO_sock_should_retry endp

_text$mn	ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; int __stdcall	closesocket(SOCKET s)
		extrn __imp__closesocket@4:near	; CODE XREF: _sock_free+27p
					; DATA XREF: _sock_free+27r
; int __stdcall	recv(SOCKET s, char *buf, int len, int flags)
		extrn __imp__recv@16:near ; CODE XREF: _sock_read+20p
					; DATA XREF: _sock_read+20r
; int __stdcall	send(SOCKET s, const char *buf,	int len, int flags)
		extrn __imp__send@16:near ; CODE XREF: _sock_write+1Bp
					; DATA XREF: _sock_write+1Br
; int __stdcall	shutdown(SOCKET	s, int how)
		extrn __imp__shutdown@8:near ; CODE XREF: _sock_free+1Ep
					; DATA XREF: _sock_free+1Er
; void __stdcall WSASetLastError(int iError)
		extrn __imp__WSASetLastError@4:near ; CODE XREF: _sock_write+4p
					; _sock_read+Cp
					; DATA XREF: ...
; int __stdcall	WSAGetLastError()
		extrn __imp__WSAGetLastError@0:near ; CODE XREF: _sock_write:loc_39p
					; _sock_read:loc_9Ap ...
		extrn _BIO_set_flags:near ; CODE XREF: _sock_write+4Fp
					; _sock_read+54p
		extrn _BIO_clear_flags:near ; CODE XREF: _sock_write+26p
					; _sock_read+2Bp
		extrn _BIO_new:near	; CODE XREF: _BIO_new_socket+6p
		extrn _BIO_int_ctrl:near ; CODE	XREF: _BIO_new_socket+21p


		end
