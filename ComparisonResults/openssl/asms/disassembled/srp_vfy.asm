;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	15147F7F4336A5F94ACD8227176E3513
; Input	CRC32 :	A46BA261

; File Name   :	C:\compspace\Diff\openssl\obj\srp_vfy.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data		segment	para public 'DATA' use32
		assume cs:_data
; char b64table[]
_b64table	db '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz./',0
					; DATA XREF: _t_fromb64+55o
					; _t_fromb64+67o ...
		align 4
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 44h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SRP_VBASE_free
_SRP_VBASE_free	proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		push	offset _SRP_user_pwd_free
		push	dword ptr [esi]
		call	_sk_pop_free
		push	dword ptr [esi+4]
		call	_sk_free
		push	dword ptr [esi+8]
		call	_CRYPTO_free
		push	esi
		call	_CRYPTO_free
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
_SRP_VBASE_free	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 74h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SRP_VBASE_get1_by_user
_SRP_VBASE_get1_by_user	proc near

var_44		= byte ptr -44h
var_2C		= byte ptr -2Ch
var_18		= byte ptr -18h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 44h ; 'D'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+44h+var_4], eax
		push	ebx
		mov	ebx, [esp+48h+arg_4]
		push	esi
		mov	esi, [esp+4Ch+arg_0]
		test	esi, esi
		jnz	short loc_AA

loc_97:					; CODE XREF: _SRP_VBASE_get1_by_user+62j
					; _SRP_VBASE_get1_by_user+68j ...
		pop	esi
		xor	eax, eax
		pop	ebx
		mov	ecx, [esp+44h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 44h
		retn
; ---------------------------------------------------------------------------

loc_AA:					; CODE XREF: _SRP_VBASE_get1_by_user+21j
		push	ebx
		push	esi
		call	_find_user
		add	esp, 8
		test	eax, eax
		jz	short loc_D2
		push	eax
		call	_srp_user_pwd_dup
		add	esp, 4
		pop	esi
		pop	ebx
		mov	ecx, [esp+44h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 44h
		retn
; ---------------------------------------------------------------------------

loc_D2:					; CODE XREF: _SRP_VBASE_get1_by_user+42j
		cmp	dword ptr [esi+8], 0
		jz	short loc_97
		cmp	dword ptr [esi+0Ch], 0
		jz	short loc_97
		cmp	dword ptr [esi+10h], 0
		jz	short loc_97
		push	edi
		call	_SRP_user_pwd_new
		mov	edi, eax
		test	edi, edi
		jz	loc_1F3
		mov	ecx, [esi+0Ch]
		mov	eax, [esi+10h]
		mov	[edi+10h], eax
		mov	[edi+0Ch], ecx
		test	ebx, ebx
		jz	short loc_117
		push	ebx
		call	_BUF_strdup
		add	esp, 4
		mov	[edi], eax
		test	eax, eax
		jz	$err$24

loc_117:				; CODE XREF: _SRP_VBASE_get1_by_user+8Ej
		lea	eax, [esp+50h+var_2C]
		push	14h
		push	eax
		call	_RAND_pseudo_bytes
		add	esp, 8
		test	eax, eax
		js	$err$24
		lea	eax, [esp+50h+var_44]
		push	eax
		call	_EVP_MD_CTX_init
		add	esp, 4
		push	0
		call	_EVP_sha1
		push	eax
		lea	eax, [esp+58h+var_44]
		push	eax
		call	_EVP_DigestInit_ex
		mov	edx, [esi+8]
		add	esp, 0Ch
		mov	ecx, edx
		lea	esi, [ecx+1]

loc_158:				; CODE XREF: _SRP_VBASE_get1_by_user+E9j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_158
		sub	ecx, esi
		lea	eax, [esp+50h+var_44]
		push	ecx
		push	edx
		push	eax
		call	_EVP_DigestUpdate
		mov	ecx, ebx
		add	esp, 0Ch
		lea	edx, [ecx+1]

loc_175:				; CODE XREF: _SRP_VBASE_get1_by_user+106j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_175
		sub	ecx, edx
		lea	eax, [esp+50h+var_44]
		push	ecx
		push	ebx
		push	eax
		call	_EVP_DigestUpdate
		push	0
		lea	eax, [esp+60h+var_18]
		push	eax
		lea	eax, [esp+64h+var_44]
		push	eax
		call	_EVP_DigestFinal_ex
		lea	eax, [esp+68h+var_44]
		push	eax
		call	_EVP_MD_CTX_cleanup
		push	0
		lea	eax, [esp+70h+var_2C]
		push	14h
		push	eax
		call	_BN_bin2bn
		add	esp, 28h
		push	eax
		push	0
		lea	eax, [esp+58h+var_18]
		push	14h
		push	eax
		call	_BN_bin2bn
		add	esp, 0Ch
		push	eax
		push	edi
		call	_SRP_user_pwd_set_sv_BN
		add	esp, 0Ch
		test	eax, eax
		jz	short $err$24
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [esp+44h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 44h
		retn
; ---------------------------------------------------------------------------

$err$24:				; CODE XREF: _SRP_VBASE_get1_by_user+9Dj
					; _SRP_VBASE_get1_by_user+B4j ...
		push	edi
		call	_SRP_user_pwd_free
		add	esp, 4

loc_1F3:				; CODE XREF: _SRP_VBASE_get1_by_user+7Aj
		mov	ecx, [esp+50h+var_4]
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 44h
		retn
_SRP_VBASE_get1_by_user	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 208h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SRP_VBASE_get_by_user
_SRP_VBASE_get_by_user proc near
		jmp	_find_user
_SRP_VBASE_get_by_user endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 210h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SRP_VBASE_init
_SRP_VBASE_init	proc near

var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 18h
		call	__chkstk
		push	ebx
		push	ebp
		push	edi
		call	_sk_new_null
		mov	edi, eax
		xor	eax, eax
		mov	[esp+24h+var_18], edi
		mov	[esp+24h+var_C], eax
		call	_BIO_s_file
		push	eax
		call	_BIO_new
		mov	ebp, eax
		add	esp, 4
		mov	[esp+24h+var_4], ebp
		mov	ebx, 3
		test	ebp, ebp
		jz	loc_4B8
		push	[esp+24h+arg_4]
		push	ebx
		push	6Ch ; 'l'
		push	ebp
		call	_BIO_ctrl
		add	esp, 10h
		test	eax, eax
		jle	loc_4AF
		push	6
		push	ebp
		mov	ebx, 1
		call	_TXT_DB_read
		add	esp, 8
		mov	[esp+24h+var_10], eax
		test	eax, eax
		jz	loc_4AF
		mov	ebp, [esp+24h+arg_0]
		mov	ebx, 4
		mov	[esp+24h+var_14], ebx
		cmp	dword ptr [ebp+8], 0
		jz	short loc_2AA
		push	0
		call	_SRP_get_default_gN
		add	esp, 4
		mov	eax, [eax]
		mov	[esp+24h+var_C], eax
		mov	eax, [esp+24h+var_10]

loc_2AA:				; CODE XREF: _SRP_VBASE_init+84j
		push	esi
		push	dword ptr [eax+4]
		xor	esi, esi
		mov	[esp+2Ch+var_8], esi
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jle	loc_422

loc_2C4:				; CODE XREF: _SRP_VBASE_init+20Cj
		mov	eax, [esp+28h+var_10]
		push	esi
		push	dword ptr [eax+4]
		call	_sk_value
		mov	esi, eax
		add	esp, 8
		mov	ecx, [esi]
		mov	al, [ecx]
		cmp	al, 49h	; 'I'
		jnz	loc_378
		push	19Ch
		push	offset ??_C@_0BH@PMKEIHBK@?4?2crypto?2srp?2srp_vfy?4c?$AA@ ; ".\\crypto\\srp\\srp_vfy.c"
		push	0Ch
		call	_CRYPTO_malloc
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jz	loc_49A
		push	dword ptr [esi+0Ch]
		call	_BUF_strdup
		add	esp, 4
		mov	[edi], eax
		test	eax, eax
		jz	$err$48
		push	dword ptr [esi+4]
		push	dword ptr [ebp+4]
		call	_SRP_gN_place_bn
		add	esp, 8
		mov	[edi+8], eax
		test	eax, eax
		jz	$err$48
		push	dword ptr [esi+8]
		push	dword ptr [ebp+4]
		call	_SRP_gN_place_bn
		add	esp, 8
		mov	[edi+4], eax
		test	eax, eax
		jz	$err$48
		push	0
		push	edi
		push	[esp+30h+var_18]
		call	_sk_insert
		add	esp, 0Ch
		test	eax, eax
		jz	$err$48
		cmp	dword ptr [ebp+8], 0
		mov	edi, [esp+28h+var_18]
		jz	loc_402
		mov	eax, [esi+0Ch]
		mov	[esp+28h+var_C], eax
		jmp	loc_402
; ---------------------------------------------------------------------------

loc_378:				; CODE XREF: _SRP_VBASE_init+CCj
		cmp	al, 56h	; 'V'
		jnz	loc_402
		push	edi
		push	dword ptr [esi+10h]
		call	_SRP_get_gN_by_id
		mov	ebx, eax
		add	esp, 8
		test	ebx, ebx
		jz	loc_43F
		mov	[esp+28h+var_14], 4
		call	_SRP_user_pwd_new
		mov	edi, eax
		test	edi, edi
		jz	loc_495
		mov	edx, [ebx+4]
		mov	ecx, [ebx+8]
		mov	[edi+10h], ecx
		mov	[edi+0Ch], edx
		push	dword ptr [esi+14h]
		push	dword ptr [esi+0Ch]
		push	edi
		call	_SRP_user_pwd_set_ids
		add	esp, 0Ch
		test	eax, eax
		jz	loc_457
		push	dword ptr [esi+4]
		mov	ebx, 2
		push	dword ptr [esi+8]
		mov	[esp+30h+var_14], ebx
		push	edi
		call	_SRP_user_pwd_set_sv
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_45B
		push	0
		push	edi
		push	dword ptr [ebp+0]
		call	_sk_insert
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_45B
		mov	edi, [esp+28h+var_18]

loc_402:				; CODE XREF: _SRP_VBASE_init+156j
					; _SRP_VBASE_init+163j	...
		mov	eax, [esp+28h+var_10]
		mov	esi, [esp+28h+var_8]
		inc	esi
		mov	[esp+28h+var_8], esi
		push	dword ptr [eax+4]
		call	_sk_num
		add	esp, 4
		cmp	esi, eax
		jl	loc_2C4

loc_422:				; CODE XREF: _SRP_VBASE_init+AEj
		mov	eax, [esp+28h+var_C]
		test	eax, eax
		jz	short loc_491
		push	edi
		push	eax
		call	_SRP_get_gN_by_id
		mov	ecx, eax
		add	esp, 8
		test	ecx, ecx
		jnz	short loc_485
		lea	ebx, [eax+2]
		jmp	short loc_49A
; ---------------------------------------------------------------------------

loc_43F:				; CODE XREF: _SRP_VBASE_init+180j
		mov	ebx, [esp+28h+var_14]
		jmp	short loc_402
; ---------------------------------------------------------------------------

$err$48:				; CODE XREF: _SRP_VBASE_init+FFj
					; _SRP_VBASE_init+118j	...
		push	dword ptr [edi]
		call	_CRYPTO_free
		push	edi
		call	_CRYPTO_free
		add	esp, 8
		jmp	short loc_49A
; ---------------------------------------------------------------------------

loc_457:				; CODE XREF: _SRP_VBASE_init+1BAj
		mov	ebx, [esp+28h+var_14]

loc_45B:				; CODE XREF: _SRP_VBASE_init+1DAj
					; _SRP_VBASE_init+1ECj
		push	dword ptr [edi+4]
		call	_BN_free
		push	dword ptr [edi+8]
		call	_BN_clear_free
		push	dword ptr [edi]
		call	_CRYPTO_free
		push	dword ptr [edi+14h]
		call	_CRYPTO_free
		push	edi
		call	_CRYPTO_free
		add	esp, 14h
		jmp	short loc_49A
; ---------------------------------------------------------------------------

loc_485:				; CODE XREF: _SRP_VBASE_init+228j
		mov	eax, [ecx+4]
		mov	[ebp+0Ch], eax
		mov	eax, [ecx+8]
		mov	[ebp+10h], eax

loc_491:				; CODE XREF: _SRP_VBASE_init+218j
		xor	ebx, ebx
		jmp	short loc_49A
; ---------------------------------------------------------------------------

loc_495:				; CODE XREF: _SRP_VBASE_init+197j
		mov	ebx, 4

loc_49A:				; CODE XREF: _SRP_VBASE_init+EAj
					; _SRP_VBASE_init+22Dj	...
		push	[esp+28h+var_10]
		call	_TXT_DB_free
		mov	edi, [esp+2Ch+var_18]
		add	esp, 4
		mov	ebp, [esp+28h+var_4]
		pop	esi

loc_4AF:				; CODE XREF: _SRP_VBASE_init+51j
					; _SRP_VBASE_init+6Dj
		push	ebp
		call	_BIO_free_all
		add	esp, 4

loc_4B8:				; CODE XREF: _SRP_VBASE_init+39j
		push	edi
		call	_sk_free
		add	esp, 4
		mov	eax, ebx
		pop	edi
		pop	ebp
		pop	ebx
		add	esp, 18h
		retn
_SRP_VBASE_init	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4CCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SRP_VBASE_new
_SRP_VBASE_new	proc near

arg_0		= dword	ptr  4

		push	esi
		push	10Eh
		push	offset ??_C@_0BH@PMKEIHBK@?4?2crypto?2srp?2srp_vfy?4c?$AA@ ; ".\\crypto\\srp\\srp_vfy.c"
		push	14h
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jz	short loc_554
		call	_sk_new_null
		mov	[esi], eax
		test	eax, eax
		jz	short loc_54B
		call	_sk_new_null
		mov	[esi+4], eax
		test	eax, eax
		jz	short loc_54B
		mov	eax, [esp+4+arg_0]
		mov	dword ptr [esi+0Ch], 0
		mov	dword ptr [esi+10h], 0
		mov	dword ptr [esi+8], 0
		test	eax, eax
		jz	short loc_547
		push	eax
		call	_BUF_strdup
		add	esp, 4
		mov	[esi+8], eax
		test	eax, eax
		jnz	short loc_547
		push	dword ptr [esi]
		call	_sk_free
		push	dword ptr [esi+4]
		call	_sk_free
		push	esi
		call	_CRYPTO_free
		add	esp, 0Ch
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_547:				; CODE XREF: _SRP_VBASE_new+4Dj
					; _SRP_VBASE_new+5Dj
		mov	eax, esi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_54B:				; CODE XREF: _SRP_VBASE_new+24j
					; _SRP_VBASE_new+30j
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_554:				; CODE XREF: _SRP_VBASE_new+19j
		xor	eax, eax
		pop	esi
		retn
_SRP_VBASE_new	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 558h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SRP_create_verifier
_SRP_create_verifier proc near

var_13B8	= dword	ptr -13B8h
var_13B4	= dword	ptr -13B4h
var_13B0	= dword	ptr -13B0h
var_13AC	= dword	ptr -13ACh
var_13A8	= dword	ptr -13A8h
var_13A4	= dword	ptr -13A4h
var_13A0	= dword	ptr -13A0h
var_139C	= dword	ptr -139Ch
var_1398	= dword	ptr -1398h
var_1394	= dword	ptr -1394h
var_1390	= dword	ptr -1390h
var_138C	= byte ptr -138Ch
var_9C8		= byte ptr -9C8h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	eax, 13B8h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+13B8h+var_4], eax
		mov	eax, [esp+13B8h+arg_0]
		mov	ecx, [esp+13B8h+arg_C]
		mov	edx, [esp+13B8h+arg_10]
		push	ebx
		push	ebp
		push	esi
		mov	[esp+13C4h+var_139C], eax
		xor	ebx, ebx
		mov	eax, [esp+13C4h+arg_4]
		xor	esi, esi
		push	edi
		mov	[esp+13C8h+var_13A0], eax
		xor	edi, edi
		mov	eax, [esp+13C8h+arg_8]
		xor	ebp, ebp
		mov	[esp+13C8h+var_1398], ecx
		mov	ecx, [esp+13C8h+arg_14]
		mov	[esp+13C8h+var_13AC], eax
		mov	[esp+13C8h+var_13B8], edx
		mov	[esp+13C8h+var_13B0], ecx
		mov	[esp+13C8h+var_1390], 0
		mov	[esp+13C8h+var_13B4], esi
		mov	[esp+13C8h+var_13A4], ebx
		mov	[esp+13C8h+var_1394], ebx
		cmp	[esp+13C8h+var_139C], ebx
		jz	$err$36
		cmp	[esp+13C8h+var_13A0], ebx
		jz	$err$36
		test	eax, eax
		jz	$err$36
		cmp	[esp+13C8h+var_1398], ebx
		jz	$err$36
		mov	eax, edx
		test	eax, eax
		jz	short loc_65A
		push	eax
		lea	eax, [esp+13CCh+var_138C]
		push	eax
		call	_t_fromb64
		add	esp, 8
		test	eax, eax
		jz	loc_7B0
		push	ebx
		push	eax
		lea	eax, [esp+13D0h+var_138C]
		push	eax
		call	_BN_bin2bn
		push	[esp+13D4h+var_13B0]
		mov	edi, eax
		lea	eax, [esp+13D8h+var_138C]
		push	eax
		mov	[esp+13DCh+var_13A8], edi
		call	_t_fromb64
		add	esp, 14h
		test	eax, eax
		jz	loc_7B0
		push	ebx
		push	eax
		lea	eax, [esp+13D0h+var_138C]
		push	eax
		call	_BN_bin2bn
		add	esp, 0Ch
		mov	[esp+13C8h+var_13B0], offset ??_C@_01NBENCBCI@?$CK?$AA@	; `string'
		mov	ebp, eax
		jmp	short loc_67B
; ---------------------------------------------------------------------------

loc_65A:				; CODE XREF: _SRP_create_verifier+A4j
		push	ecx
		call	_SRP_get_default_gN
		add	esp, 4
		test	eax, eax
		jz	loc_7C7
		mov	edi, [eax+8]
		mov	ebp, [eax+4]
		mov	eax, [eax]
		mov	[esp+13C8h+var_13A8], edi
		mov	[esp+13C8h+var_13B0], eax

loc_67B:				; CODE XREF: _SRP_create_verifier+100j
		mov	eax, [esp+13C8h+var_13AC]
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_6A5
		lea	eax, [esp+13C8h+var_9C8]
		push	14h
		push	eax
		call	_RAND_pseudo_bytes
		add	esp, 8
		test	eax, eax
		js	loc_7B0
		push	0
		push	14h
		jmp	short loc_6C1
; ---------------------------------------------------------------------------

loc_6A5:				; CODE XREF: _SRP_create_verifier+12Bj
		push	eax
		lea	eax, [esp+13CCh+var_9C8]
		push	eax
		call	_t_fromb64
		add	esp, 8
		test	eax, eax
		jz	loc_7B0
		push	0
		push	eax

loc_6C1:				; CODE XREF: _SRP_create_verifier+14Bj
		lea	eax, [esp+13D0h+var_9C8]
		push	eax
		call	_BN_bin2bn
		add	esp, 0Ch
		mov	[esp+13C8h+var_13B4], eax
		lea	eax, [esp+13C8h+var_13A4]
		push	ebp
		push	edi
		push	eax
		lea	eax, [esp+13D4h+var_13B4]
		push	eax
		push	[esp+13D8h+var_13A0]
		push	[esp+13DCh+var_139C]
		call	_SRP_create_verifier_BN
		mov	ebx, [esp+13E0h+var_13A4]
		add	esp, 18h
		test	eax, eax
		jz	loc_7B0
		lea	eax, [esp+13C8h+var_138C]
		push	eax
		push	ebx
		call	_BN_bn2bin
		push	ebx
		call	_BN_num_bits
		add	eax, 7
		cdq
		and	edx, 7
		add	eax, edx
		sar	eax, 3
		push	267h
		add	eax, eax
		push	offset ??_C@_0BH@PMKEIHBK@?4?2crypto?2srp?2srp_vfy?4c?$AA@ ; ".\\crypto\\srp\\srp_vfy.c"
		push	eax
		mov	[esp+13E0h+var_1394], eax
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 18h
		test	esi, esi
		jz	short loc_7B0
		push	ebx
		call	_BN_num_bits
		add	eax, 7
		cdq
		and	edx, 7
		add	eax, edx
		sar	eax, 3
		push	eax
		lea	eax, [esp+13D0h+var_138C]
		push	eax
		push	esi
		call	_t_tob64
		mov	eax, [esp+13D8h+var_13AC]
		add	esp, 10h
		cmp	dword ptr [eax], 0
		jnz	short loc_79A
		push	26Eh
		push	offset ??_C@_0BH@PMKEIHBK@?4?2crypto?2srp?2srp_vfy?4c?$AA@ ; ".\\crypto\\srp\\srp_vfy.c"
		push	28h ; '('
		call	_CRYPTO_malloc
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jz	short loc_7AC
		push	14h
		lea	eax, [esp+13CCh+var_9C8]
		push	eax
		push	edi
		call	_t_tob64
		mov	eax, [esp+13D4h+var_13AC]
		add	esp, 0Ch
		mov	[eax], edi
		mov	edi, [esp+13C8h+var_13A8]

loc_79A:				; CODE XREF: _SRP_create_verifier+209j
		mov	eax, [esp+13C8h+var_1398]
		mov	[eax], esi
		xor	esi, esi
		mov	eax, [esp+13C8h+var_13B0]
		mov	[esp+13C8h+var_1390], eax
		jmp	short loc_7B0
; ---------------------------------------------------------------------------

loc_7AC:				; CODE XREF: _SRP_create_verifier+223j
		mov	edi, [esp+13C8h+var_13A8]

loc_7B0:				; CODE XREF: _SRP_create_verifier+B6j
					; _SRP_create_verifier+E1j ...
		mov	edx, [esp+13C8h+var_13B8]

$err$36:				; CODE XREF: _SRP_create_verifier+7Ej
					; _SRP_create_verifier+88j ...
		test	edx, edx
		jz	short loc_7C7
		push	edi
		call	_BN_free
		push	ebp
		call	_BN_free
		add	esp, 8

loc_7C7:				; CODE XREF: _SRP_create_verifier+10Dj
					; _SRP_create_verifier+25Ej
		push	[esp+13C8h+var_1394]
		push	esi
		call	_OPENSSL_cleanse
		push	esi
		call	_CRYPTO_free
		push	[esp+13D4h+var_13B4]
		call	_BN_clear_free
		push	ebx
		call	_BN_clear_free
		mov	ecx, [esp+13DCh+var_4]
		add	esp, 14h
		mov	eax, [esp+13C8h+var_1390]
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 13B8h
		retn
_SRP_create_verifier endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 808h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SRP_create_verifier_BN
_SRP_create_verifier_BN	proc near	; CODE XREF: _SRP_create_verifier+191p

var_9E0		= dword	ptr -9E0h
var_9DC		= dword	ptr -9DCh
var_9D8		= dword	ptr -9D8h
var_9D4		= dword	ptr -9D4h
var_9D0		= dword	ptr -9D0h
var_9CC		= dword	ptr -9CCh
var_9C8		= byte ptr -9C8h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	eax, 9E0h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+9E0h+var_4], eax
		mov	eax, [esp+9E0h+arg_0]
		mov	[esp+9E0h+var_9D8], eax
		mov	eax, [esp+9E0h+arg_4]
		push	ebx
		mov	[esp+9E4h+var_9DC], eax
		xor	ebx, ebx
		mov	eax, [esp+9E4h+arg_C]
		push	ebp
		mov	[esp+9E8h+var_9E0], eax
		mov	eax, [esp+9E8h+arg_10]
		push	esi
		mov	[esp+9ECh+var_9D4], eax
		mov	eax, [esp+9ECh+arg_14]
		push	edi
		mov	edi, [esp+9F0h+arg_8]
		mov	[esp+9F0h+var_9D0], eax
		mov	[esp+9F0h+var_9CC], 0
		call	_BN_CTX_new
		xor	esi, esi
		mov	ebp, eax
		cmp	[esp+9F0h+var_9D8], ebx
		jz	$err$12
		cmp	[esp+9F0h+var_9DC], ebx
		jz	$err$12
		test	edi, edi
		jz	$err$12
		cmp	[esp+9F0h+var_9E0], ebx
		jz	$err$12
		cmp	[esp+9F0h+var_9D4], ebx
		jz	short $err$12
		cmp	[esp+9F0h+var_9D0], ebx
		jz	short $err$12
		test	ebp, ebp
		jz	short $err$12
		mov	eax, [edi]
		test	eax, eax
		jnz	short loc_8D4
		lea	eax, [esp+9F0h+var_9C8]
		push	14h
		push	eax
		call	_RAND_pseudo_bytes
		add	esp, 8
		test	eax, eax
		js	short $err$12
		push	esi
		lea	eax, [esp+9F4h+var_9C8]
		push	14h
		push	eax
		call	_BN_bin2bn
		add	esp, 0Ch

loc_8D4:				; CODE XREF: _SRP_create_verifier_BN+A7j
		push	[esp+9F0h+var_9DC]
		mov	esi, eax
		push	[esp+9F4h+var_9D8]
		push	esi
		call	_SRP_Calc_x
		add	esp, 0Ch
		mov	ebx, eax
		call	_BN_new
		mov	ecx, [esp+9F0h+var_9E0]
		mov	[ecx], eax
		test	eax, eax
		jz	short $err$12
		push	ebp
		push	[esp+9F4h+var_9D4]
		push	ebx
		push	[esp+9FCh+var_9D0]
		push	eax
		call	_BN_mod_exp
		add	esp, 14h
		test	eax, eax
		jnz	short loc_956
		mov	eax, [esp+9F0h+var_9E0]
		push	dword ptr [eax]
		call	_BN_clear_free
		add	esp, 4

$err$12:				; CODE XREF: _SRP_create_verifier_BN+71j
					; _SRP_create_verifier_BN+7Bj ...
		cmp	[edi], esi
		jz	short loc_92A
		push	esi
		call	_BN_clear_free
		add	esp, 4

loc_92A:				; CODE XREF: _SRP_create_verifier_BN+117j
					; _SRP_create_verifier_BN+158j
		push	ebx
		call	_BN_clear_free
		push	ebp
		call	_BN_CTX_free
		mov	ecx, [esp+9F8h+var_4]
		add	esp, 8
		mov	eax, [esp+9F0h+var_9CC]
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 9E0h
		retn
; ---------------------------------------------------------------------------

loc_956:				; CODE XREF: _SRP_create_verifier_BN+105j
		mov	[esp+9F0h+var_9CC], 1
		mov	[edi], esi
		jmp	short loc_92A
_SRP_create_verifier_BN	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 964h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_SRP_gN_free	proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	short loc_985
		push	dword ptr [esi]
		call	_CRYPTO_free
		push	dword ptr [esi+4]
		call	_BN_free
		push	esi
		call	_CRYPTO_free
		add	esp, 0Ch

loc_985:				; CODE XREF: _SRP_gN_free+7j
		pop	esi
		retn
_SRP_gN_free	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 988h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_SRP_gN_new_init proc near		; CODE XREF: _SRP_gN_place_bn+70p

var_9C8		= byte ptr -9C8h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 9C8h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+9C8h+var_4], eax
		push	esi
		push	edi
		mov	edi, [esp+9D0h+arg_0]
		push	132h
		push	offset ??_C@_0BH@PMKEIHBK@?4?2crypto?2srp?2srp_vfy?4c?$AA@ ; ".\\crypto\\srp\\srp_vfy.c"
		push	8
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jz	short loc_A20
		push	edi
		call	_BUF_strdup
		add	esp, 4
		mov	[esi], eax
		test	eax, eax
		jz	short $err$8
		lea	eax, [esp+9D0h+var_9C8]
		push	edi
		push	eax
		call	_t_fromb64
		push	0
		push	eax
		lea	eax, [esp+9E0h+var_9C8]
		push	eax
		call	_BN_bin2bn
		add	esp, 14h
		mov	[esi+4], eax
		test	eax, eax
		jz	short loc_A0D
		pop	edi
		mov	eax, esi
		pop	esi
		mov	ecx, [esp+9C8h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 9C8h
		retn
; ---------------------------------------------------------------------------

loc_A0D:				; CODE XREF: _SRP_gN_new_init+6Aj
		push	dword ptr [esi]
		call	_CRYPTO_free
		add	esp, 4

$err$8:					; CODE XREF: _SRP_gN_new_init+48j
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_A20:				; CODE XREF: _SRP_gN_new_init+39j
		mov	ecx, [esp+9D0h+var_4]
		xor	eax, eax
		pop	edi
		pop	esi
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 9C8h
		retn
_SRP_gN_new_init endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A3Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_SRP_gN_place_bn proc near		; CODE XREF: _SRP_VBASE_init+10Bp
					; _SRP_VBASE_init+124p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	edi
		mov	edi, [esp+4+arg_0]
		test	edi, edi
		jnz	short loc_A49
		xor	eax, eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_A49:				; CODE XREF: _SRP_gN_place_bn+7j
		push	ebx
		push	ebp
		push	esi
		push	edi
		xor	esi, esi
		call	_sk_num
		mov	ebx, [esp+14h+arg_4]
		add	esp, 4
		test	eax, eax
		jle	short loc_AAB

loc_A5F:				; CODE XREF: _SRP_gN_place_bn+6Dj
		push	esi
		push	edi
		call	_sk_value
		mov	ebp, eax
		add	esp, 8
		mov	ecx, ebx
		mov	edx, [ebp+0]

loc_A70:				; CODE XREF: _SRP_gN_place_bn+4Ej
		mov	bl, [edx]
		cmp	bl, [ecx]
		jnz	short loc_A90
		test	bl, bl
		jz	short loc_A8C
		mov	al, [edx+1]
		cmp	al, [ecx+1]
		jnz	short loc_A90
		add	edx, 2
		add	ecx, 2
		test	al, al
		jnz	short loc_A70

loc_A8C:				; CODE XREF: _SRP_gN_place_bn+3Cj
		xor	eax, eax
		jmp	short loc_A95
; ---------------------------------------------------------------------------

loc_A90:				; CODE XREF: _SRP_gN_place_bn+38j
					; _SRP_gN_place_bn+44j
		sbb	eax, eax
		or	eax, 1

loc_A95:				; CODE XREF: _SRP_gN_place_bn+52j
		test	eax, eax
		jz	short loc_AD2
		push	edi
		inc	esi
		call	_sk_num
		mov	ebx, [esp+14h+arg_4]
		add	esp, 4
		cmp	esi, eax
		jl	short loc_A5F

loc_AAB:				; CODE XREF: _SRP_gN_place_bn+21j
		push	ebx
		call	_SRP_gN_new_init
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jz	short loc_AF2
		push	0
		push	esi
		push	edi
		call	_sk_insert
		add	esp, 0Ch
		test	eax, eax
		jle	short loc_ADA
		mov	eax, [esi+4]
		pop	esi
		pop	ebp
		pop	ebx
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_AD2:				; CODE XREF: _SRP_gN_place_bn+5Bj
		mov	eax, [ebp+4]
		pop	esi
		pop	ebp
		pop	ebx
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_ADA:				; CODE XREF: _SRP_gN_place_bn+8Cj
		push	dword ptr [esi]
		call	_CRYPTO_free
		push	dword ptr [esi+4]
		call	_BN_free
		push	esi
		call	_CRYPTO_free
		add	esp, 0Ch

loc_AF2:				; CODE XREF: _SRP_gN_place_bn+7Cj
		pop	esi
		pop	ebp
		pop	ebx
		xor	eax, eax
		pop	edi
		retn
_SRP_gN_place_bn endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0AFCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_SRP_get_gN_by_id proc near		; CODE XREF: _SRP_VBASE_init+174p
					; _SRP_VBASE_init+21Cp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		mov	ebx, [esp+4+arg_4]
		push	ebp
		mov	ebp, [esp+8+arg_0]
		push	esi
		push	edi
		test	ebx, ebx
		jz	short loc_B6B
		push	ebx
		xor	esi, esi
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jle	short loc_B6B
		nop

loc_B1C:				; CODE XREF: _SRP_get_gN_by_id+6Dj
		push	esi
		push	ebx
		call	_sk_value
		mov	edi, eax
		add	esp, 8
		test	edi, edi
		jz	short loc_B5D
		test	ebp, ebp
		jz	short loc_B79
		mov	edx, [edi]
		mov	ecx, ebp

loc_B34:				; CODE XREF: _SRP_get_gN_by_id+52j
		mov	al, [edx]
		cmp	al, [ecx]
		jnz	short loc_B54
		test	al, al
		jz	short loc_B50
		mov	al, [edx+1]
		cmp	al, [ecx+1]
		jnz	short loc_B54
		add	edx, 2
		add	ecx, 2
		test	al, al
		jnz	short loc_B34

loc_B50:				; CODE XREF: _SRP_get_gN_by_id+40j
		xor	eax, eax
		jmp	short loc_B59
; ---------------------------------------------------------------------------

loc_B54:				; CODE XREF: _SRP_get_gN_by_id+3Cj
					; _SRP_get_gN_by_id+48j
		sbb	eax, eax
		or	eax, 1

loc_B59:				; CODE XREF: _SRP_get_gN_by_id+56j
		test	eax, eax
		jz	short loc_B79

loc_B5D:				; CODE XREF: _SRP_get_gN_by_id+2Ej
		push	ebx
		inc	esi
		call	_sk_num
		add	esp, 4
		cmp	esi, eax
		jl	short loc_B1C

loc_B6B:				; CODE XREF: _SRP_get_gN_by_id+Ej
					; _SRP_get_gN_by_id+1Dj
		push	ebp
		call	_SRP_get_default_gN
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_B79:				; CODE XREF: _SRP_get_gN_by_id+32j
					; _SRP_get_gN_by_id+5Fj
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_SRP_get_gN_by_id endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B80h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _SRP_user_pwd_free
_SRP_user_pwd_free proc	near		; CODE XREF: _SRP_VBASE_get1_by_user+177p
					; DATA XREF: _SRP_VBASE_free+5o

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	short loc_BB1
		push	dword ptr [esi+4]
		call	_BN_free
		push	dword ptr [esi+8]
		call	_BN_clear_free
		push	dword ptr [esi]
		call	_CRYPTO_free
		push	dword ptr [esi+14h]
		call	_CRYPTO_free
		push	esi
		call	_CRYPTO_free
		add	esp, 14h

loc_BB1:				; CODE XREF: _SRP_user_pwd_free+7j
		pop	esi
		retn
_SRP_user_pwd_free endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0BB4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_SRP_user_pwd_new proc near		; CODE XREF: _SRP_VBASE_get1_by_user+71p
					; _SRP_VBASE_init+18Ep
		push	0C9h ; 'É'
		push	offset ??_C@_0BH@PMKEIHBK@?4?2crypto?2srp?2srp_vfy?4c?$AA@ ; ".\\crypto\\srp\\srp_vfy.c"
		push	18h
		call	_CRYPTO_malloc
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_BCD
		retn
; ---------------------------------------------------------------------------

loc_BCD:				; CODE XREF: _SRP_user_pwd_new+16j
		mov	dword ptr [eax+10h], 0
		mov	dword ptr [eax+0Ch], 0
		mov	dword ptr [eax+4], 0
		mov	dword ptr [eax+8], 0
		mov	dword ptr [eax], 0
		mov	dword ptr [eax+14h], 0
		retn
_SRP_user_pwd_new endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0BF8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_SRP_user_pwd_set_gN proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		mov	eax, [esp+arg_8]
		mov	[ecx+10h], eax
		mov	eax, [esp+arg_4]
		mov	[ecx+0Ch], eax
		retn
_SRP_user_pwd_set_gN endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C0Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_SRP_user_pwd_set_ids proc near		; CODE XREF: _SRP_VBASE_init+1B0p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, [esp+arg_4]
		push	esi
		mov	esi, [esp+4+arg_0]
		test	eax, eax
		jz	short loc_C2C
		push	eax
		call	_BUF_strdup
		add	esp, 4
		mov	[esi], eax
		test	eax, eax
		jnz	short loc_C2C

loc_C28:				; CODE XREF: _SRP_user_pwd_set_ids+36j
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_C2C:				; CODE XREF: _SRP_user_pwd_set_ids+Bj
					; _SRP_user_pwd_set_ids+1Aj
		mov	eax, [esp+4+arg_8]
		test	eax, eax
		jz	short loc_C44
		push	eax
		call	_BUF_strdup
		add	esp, 4
		mov	[esi+14h], eax
		test	eax, eax
		jz	short loc_C28

loc_C44:				; CODE XREF: _SRP_user_pwd_set_ids+26j
		mov	eax, 1
		pop	esi
		retn
_SRP_user_pwd_set_ids endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C4Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_SRP_user_pwd_set_sv proc near		; CODE XREF: _SRP_VBASE_init+1D0p

var_9C8		= byte ptr -9C8h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 9C8h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+9C8h+var_4], eax
		push	ebx
		mov	ebx, [esp+9CCh+arg_0]
		push	esi
		mov	esi, [esp+9D0h+arg_8]
		push	edi
		mov	edi, [esp+9D4h+arg_4]
		mov	ecx, edi
		lea	edx, [ecx+1]

loc_C81:				; CODE XREF: _SRP_user_pwd_set_sv+3Aj
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_C81
		sub	ecx, edx
		cmp	ecx, 9C4h
		ja	short loc_D0E
		mov	ecx, esi
		lea	edx, [ecx+1]
		nop	dword ptr [eax+eax+00h]

loc_C9C:				; CODE XREF: _SRP_user_pwd_set_sv+55j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_C9C
		sub	ecx, edx
		cmp	ecx, 9C4h
		ja	short loc_D0E
		lea	eax, [esp+9D4h+var_9C8]
		push	esi
		push	eax
		call	_t_fromb64
		push	0
		push	eax
		lea	eax, [esp+9E4h+var_9C8]
		push	eax
		call	_BN_bin2bn
		add	esp, 14h
		mov	[ebx+8], eax
		test	eax, eax
		jz	short loc_D0E
		lea	eax, [esp+9D4h+var_9C8]
		push	edi
		push	eax
		call	_t_fromb64
		push	0
		push	eax
		lea	eax, [esp+9E4h+var_9C8]
		push	eax
		call	_BN_bin2bn
		add	esp, 14h
		mov	[ebx+4], eax
		xor	ecx, ecx
		test	eax, eax
		setnz	cl
		pop	edi
		pop	esi
		mov	eax, ecx
		pop	ebx
		mov	ecx, [esp+9C8h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 9C8h
		retn
; ---------------------------------------------------------------------------

loc_D0E:				; CODE XREF: _SRP_user_pwd_set_sv+44j
					; _SRP_user_pwd_set_sv+5Fj ...
		mov	ecx, [esp+9D4h+var_4]
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 9C8h
		retn
_SRP_user_pwd_set_sv endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D28h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_SRP_user_pwd_set_sv_BN	proc near	; CODE XREF: _SRP_VBASE_get1_by_user+156p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_0]
		mov	eax, [esp+arg_4]
		mov	edx, [esp+arg_8]
		mov	[ecx+8], edx
		mov	[ecx+4], eax
		test	eax, eax
		jz	short loc_D48
		test	edx, edx
		jz	short loc_D48
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_D48:				; CODE XREF: _SRP_user_pwd_set_sv_BN+14j
					; _SRP_user_pwd_set_sv_BN+18j
		xor	eax, eax
		retn
_SRP_user_pwd_set_sv_BN	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0D4Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_find_user	proc near		; CODE XREF: _SRP_VBASE_get1_by_user+38p
					; _SRP_VBASE_get_by_userj

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	edi
		mov	edi, [esp+4+arg_0]
		test	edi, edi
		jnz	short loc_D59
		xor	eax, eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_D59:				; CODE XREF: _find_user+7j
		push	ebx
		push	ebp
		push	esi
		push	dword ptr [edi]
		xor	esi, esi
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jle	short loc_DB8

loc_D6C:				; CODE XREF: _find_user+6Aj
		push	esi
		push	dword ptr [edi]
		call	_sk_value
		mov	ecx, [esp+18h+arg_4]
		mov	ebp, eax
		add	esp, 8
		mov	edx, [ebp+0]

loc_D80:				; CODE XREF: _find_user+4Ej
		mov	bl, [edx]
		cmp	bl, [ecx]
		jnz	short loc_DA0
		test	bl, bl
		jz	short loc_D9C
		mov	al, [edx+1]
		cmp	al, [ecx+1]
		jnz	short loc_DA0
		add	edx, 2
		add	ecx, 2
		test	al, al
		jnz	short loc_D80

loc_D9C:				; CODE XREF: _find_user+3Cj
		xor	eax, eax
		jmp	short loc_DA5
; ---------------------------------------------------------------------------

loc_DA0:				; CODE XREF: _find_user+38j
					; _find_user+44j
		sbb	eax, eax
		or	eax, 1

loc_DA5:				; CODE XREF: _find_user+52j
		test	eax, eax
		jz	short loc_DBF
		push	dword ptr [edi]
		inc	esi
		call	_sk_num
		add	esp, 4
		cmp	esi, eax
		jl	short loc_D6C

loc_DB8:				; CODE XREF: _find_user+1Ej
		pop	esi
		pop	ebp
		pop	ebx
		xor	eax, eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_DBF:				; CODE XREF: _find_user+5Bj
		pop	esi
		mov	eax, ebp
		pop	ebp
		pop	ebx
		pop	edi
		retn
_find_user	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0DC8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_srp_user_pwd_dup proc near		; CODE XREF: _SRP_VBASE_get1_by_user+45p

arg_0		= dword	ptr  4

		push	edi
		mov	edi, [esp+4+arg_0]
		test	edi, edi
		jnz	short loc_DD5
		xor	eax, eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_DD5:				; CODE XREF: _srp_user_pwd_dup+7j
		push	esi
		push	0C9h ; 'É'
		push	offset ??_C@_0BH@PMKEIHBK@?4?2crypto?2srp?2srp_vfy?4c?$AA@ ; ".\\crypto\\srp\\srp_vfy.c"
		push	18h
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jz	loc_EAD
		mov	dword ptr [esi+10h], 0
		mov	dword ptr [esi+0Ch], 0
		mov	dword ptr [esi+4], 0
		mov	dword ptr [esi+8], 0
		mov	dword ptr [esi], 0
		mov	dword ptr [esi+14h], 0
		mov	eax, [edi+10h]
		mov	ecx, [edi+0Ch]
		mov	[esi+10h], eax
		mov	[esi+0Ch], ecx
		mov	eax, [edi]
		push	ebx
		mov	ebx, [edi+14h]
		test	eax, eax
		jz	short loc_E42
		push	eax
		call	_BUF_strdup
		add	esp, 4
		mov	[esi], eax
		test	eax, eax
		jz	short loc_E7F

loc_E42:				; CODE XREF: _srp_user_pwd_dup+69j
		test	ebx, ebx
		jz	short loc_E56
		push	ebx
		call	_BUF_strdup
		add	esp, 4
		mov	[esi+14h], eax
		test	eax, eax
		jz	short loc_E7F

loc_E56:				; CODE XREF: _srp_user_pwd_dup+7Cj
		push	dword ptr [edi+8]
		call	_BN_dup
		push	dword ptr [edi+4]
		mov	ebx, eax
		call	_BN_dup
		add	esp, 8
		mov	[esi+8], ebx
		mov	[esi+4], eax
		test	eax, eax
		jz	short loc_E7F
		test	ebx, ebx
		jz	short loc_E7F
		pop	ebx
		mov	eax, esi
		pop	esi
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_E7F:				; CODE XREF: _srp_user_pwd_dup+78j
					; _srp_user_pwd_dup+8Cj ...
		push	dword ptr [esi+4]
		call	_BN_free
		push	dword ptr [esi+8]
		call	_BN_clear_free
		push	dword ptr [esi]
		call	_CRYPTO_free
		push	dword ptr [esi+14h]
		call	_CRYPTO_free
		push	esi
		call	_CRYPTO_free
		add	esp, 14h
		xor	eax, eax
		pop	ebx
		pop	esi
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_EAD:				; CODE XREF: _srp_user_pwd_dup+26j
		pop	esi
		xor	eax, eax
		pop	edi
		retn
_srp_user_pwd_dup endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0EB4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_t_fromb64	proc near		; CODE XREF: _SRP_create_verifier+ACp
					; _SRP_create_verifier+D7p ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		mov	ebx, [esp+4+arg_4]
		push	ebp
		push	esi
		push	edi
		mov	al, [ebx]
		test	al, al
		jz	short loc_ED8
		xchg	ax, ax

loc_EC4:				; CODE XREF: _t_fromb64+22j
		cmp	al, 20h	; ' '
		jz	short loc_ED0
		cmp	al, 9
		jz	short loc_ED0
		cmp	al, 0Ah
		jnz	short loc_ED8

loc_ED0:				; CODE XREF: _t_fromb64+12j
					; _t_fromb64+16j
		mov	al, [ebx+1]
		inc	ebx
		test	al, al
		jnz	short loc_EC4

loc_ED8:				; CODE XREF: _t_fromb64+Cj
					; _t_fromb64+1Aj
		mov	ebp, ebx
		lea	ecx, [ebp+1]
		nop	dword ptr [eax+00000000h]

loc_EE4:				; CODE XREF: _t_fromb64+36j
		mov	al, [ebp+0]
		inc	ebp
		test	al, al
		jnz	short loc_EE4
		sub	ebp, ecx
		xor	esi, esi
		test	ebp, ebp
		jle	loc_FD4
		sub	ebx, [esp+10h+arg_0]
		mov	edi, [esp+10h+arg_0]
		nop	dword ptr [eax+00h]

loc_F04:				; CODE XREF: _t_fromb64+74j
		movsx	eax, byte ptr [ebx+edi]
		push	eax		; Val
		push	offset _b64table ; "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabc"...
		call	dword ptr ds:__imp__strchr
		add	esp, 8
		test	eax, eax
		jz	short loc_F2A
		mov	ecx, offset _b64table ;	"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabc"...
		inc	esi
		sub	al, cl
		mov	[edi], al
		inc	edi
		cmp	esi, ebp
		jl	short loc_F04

loc_F2A:				; CODE XREF: _t_fromb64+65j
		mov	edi, [esp+10h+arg_0]
		test	esi, esi
		jz	loc_FD4
		mov	al, [esi+edi-1]
		mov	ebx, esi
		dec	esi
		mov	[ebx+edi], al
		sub	esi, 1
		lea	edx, [ebx+edi]
		mov	ecx, ebx
		js	short loc_FA1

loc_F4A:				; CODE XREF: _t_fromb64+EBj
		movzx	eax, byte ptr [esi+edi]
		dec	ecx
		shl	al, 6
		or	[edx], al
		movzx	eax, byte ptr [esi+edi]
		shr	al, 2
		and	al, 0Fh
		sub	esi, 1
		mov	[ecx+edi], al
		js	short loc_FA1
		movzx	eax, byte ptr [esi+edi]
		shl	al, 4
		or	[ecx+edi], al
		dec	ecx
		movzx	eax, byte ptr [esi+edi]
		shr	al, 4
		and	al, 3
		sub	esi, 1
		mov	[ecx+edi], al
		js	short loc_FA1
		mov	al, [esi+edi]
		shl	al, 2
		or	[ecx+edi], al
		dec	ecx
		sub	esi, 1
		mov	byte ptr [ecx+edi], 0
		lea	edx, [ecx+edi]
		js	short loc_FA1
		mov	al, [esi+edi]
		sub	esi, 1
		mov	[edx], al
		jns	short loc_F4A

loc_FA1:				; CODE XREF: _t_fromb64+94j
					; _t_fromb64+AFj ...
		cmp	byte ptr [ecx+edi], 0
		jnz	short loc_FB2

loc_FA7:				; CODE XREF: _t_fromb64+FCj
		cmp	ecx, ebx
		jg	short loc_FB2
		inc	ecx
		cmp	byte ptr [ecx+edi], 0
		jz	short loc_FA7

loc_FB2:				; CODE XREF: _t_fromb64+F1j
					; _t_fromb64+F5j
		xor	eax, eax
		cmp	ecx, ebx
		jg	short loc_FD6
		mov	eax, ebx
		mov	esi, edi
		sub	eax, ecx
		sub	esi, ecx
		inc	eax
		nop	dword ptr [eax]

loc_FC4:				; CODE XREF: _t_fromb64+119j
		mov	dl, [ecx+edi]
		mov	[esi+ecx], dl
		inc	ecx
		cmp	ecx, ebx
		jle	short loc_FC4
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_FD4:				; CODE XREF: _t_fromb64+3Ej
					; _t_fromb64+7Cj
		xor	eax, eax

loc_FD6:				; CODE XREF: _t_fromb64+102j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_t_fromb64	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0FDCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_t_tob64	proc near		; CODE XREF: _SRP_create_verifier+1FAp
					; _SRP_create_verifier+230p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	ecx, [esp+arg_8]
		mov	eax, 55555556h
		imul	ecx
		push	ebx
		mov	eax, edx
		xor	bl, bl
		shr	eax, 1Fh
		xor	bh, bh
		add	eax, edx
		mov	edx, ecx
		push	ebp
		mov	ebp, [esp+8+arg_4]
		xor	ch, ch
		push	esi
		lea	eax, [eax+eax*2]
		xor	cl, cl
		sub	edx, eax
		mov	eax, [esp+0Ch+arg_0]
		mov	esi, edx
		mov	[esp+0Ch+arg_0], eax
		push	edi
		sub	esi, 1
		jz	short loc_1021
		sub	esi, 1
		jnz	short loc_1024
		mov	bh, [ebp+0]
		mov	ch, [ebp+1]
		jmp	short loc_1024
; ---------------------------------------------------------------------------

loc_1021:				; CODE XREF: _t_tob64+36j
		mov	ch, [ebp+0]

loc_1024:				; CODE XREF: _t_tob64+3Bj _t_tob64+43j ...
		movzx	edi, bl
		mov	esi, edi
		shr	esi, 2
		test	cl, cl
		jnz	short loc_1034
		test	esi, esi
		jz	short loc_103F

loc_1034:				; CODE XREF: _t_tob64+52j
		mov	cl, byte ptr _b64table[esi] ; "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabc"...
		mov	[eax], cl
		inc	eax
		mov	cl, 1

loc_103F:				; CODE XREF: _t_tob64+56j
		movzx	ebx, bh
		and	edi, 3
		mov	esi, ebx
		shl	edi, 4
		shr	esi, 4
		or	esi, edi
		test	cl, cl
		jnz	short loc_1057
		test	esi, esi
		jz	short loc_1062

loc_1057:				; CODE XREF: _t_tob64+75j
		mov	cl, byte ptr _b64table[esi] ; "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabc"...
		mov	[eax], cl
		inc	eax
		mov	cl, 1

loc_1062:				; CODE XREF: _t_tob64+79j
		movzx	edi, ch
		and	ebx, 0Fh
		mov	esi, edi
		shl	ebx, 2
		shr	esi, 6
		or	esi, ebx
		test	cl, cl
		jnz	short loc_107A
		test	esi, esi
		jz	short loc_1085

loc_107A:				; CODE XREF: _t_tob64+98j
		mov	cl, byte ptr _b64table[esi] ; "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabc"...
		mov	[eax], cl
		inc	eax
		mov	cl, 1

loc_1085:				; CODE XREF: _t_tob64+9Cj
		and	edi, 3Fh
		test	cl, cl
		jnz	short loc_1090
		test	edi, edi
		jz	short loc_109B

loc_1090:				; CODE XREF: _t_tob64+AEj
		mov	cl, byte ptr _b64table[edi] ; "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabc"...
		mov	[eax], cl
		inc	eax
		mov	cl, 1

loc_109B:				; CODE XREF: _t_tob64+B2j
		cmp	edx, [esp+10h+arg_8]
		jge	short loc_10B4
		mov	bl, [edx+ebp]
		mov	bh, [edx+ebp+1]
		mov	ch, [edx+ebp+2]
		add	edx, 3
		jmp	loc_1024
; ---------------------------------------------------------------------------

loc_10B4:				; CODE XREF: _t_tob64+C3j
		pop	edi
		pop	esi
		pop	ebp
		mov	byte ptr [eax],	0
		mov	eax, [esp+4+arg_0]
		pop	ebx
		retn
_t_tob64	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10C0h
; COMDAT (pick any)
		public ??_C@_0BH@PMKEIHBK@?4?2crypto?2srp?2srp_vfy?4c?$AA@
; `string'
??_C@_0BH@PMKEIHBK@?4?2crypto?2srp?2srp_vfy?4c?$AA@ db '.\crypto\srp\srp_vfy.c',0
					; DATA XREF: _SRP_VBASE_init+D7o
					; _SRP_VBASE_new+6o ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 10D8h
; COMDAT (pick any)
		public ??_C@_01NBENCBCI@?$CK?$AA@
; `string'
??_C@_01NBENCBCI@?$CK?$AA@ db 2Ah, 0	; DATA XREF: _SRP_create_verifier+F6o
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; char *__cdecl	_strchr(const char *Str, int Val)
		extrn __imp__strchr:near ; CODE	XREF: _t_fromb64+5Ap
					; DATA XREF: _t_fromb64+5Ar
		extrn _sk_num:near	; CODE XREF: _SRP_VBASE_init+A4p
					; _SRP_VBASE_init+202p	...
		extrn _sk_value:near	; CODE XREF: _SRP_VBASE_init+BCp
					; _SRP_gN_place_bn+25p	...
		extrn _sk_new_null:near	; CODE XREF: _SRP_VBASE_init+Dp
					; _SRP_VBASE_new+1Bp ...
		extrn _sk_free:near	; CODE XREF: _SRP_VBASE_free+14p
					; _SRP_VBASE_init+2A9p	...
		extrn _sk_pop_free:near	; CODE XREF: _SRP_VBASE_free+Cp
		extrn _sk_insert:near	; CODE XREF: _SRP_VBASE_init+13Ep
					; _SRP_VBASE_init+1E2p	...
		extrn _CRYPTO_malloc:near ; CODE XREF: _SRP_VBASE_init+DEp
					; _SRP_VBASE_new+Dp ...
		extrn _CRYPTO_free:near	; CODE XREF: _SRP_VBASE_free+1Cp
					; _SRP_VBASE_free+22p ...
		extrn _OPENSSL_cleanse:near ; CODE XREF: _SRP_create_verifier+274p
		extrn _BUF_strdup:near	; CODE XREF: _SRP_VBASE_get1_by_user+91p
					; _SRP_VBASE_init+F3p ...
		extrn _BIO_s_file:near	; CODE XREF: _SRP_VBASE_init+1Ep
		extrn _BIO_new:near	; CODE XREF: _SRP_VBASE_init+24p
		extrn _BIO_ctrl:near	; CODE XREF: _SRP_VBASE_init+47p
		extrn _BIO_free_all:near ; CODE	XREF: _SRP_VBASE_init+2A0p
		extrn _BN_CTX_new:near	; CODE XREF: _SRP_create_verifier_BN+64p
		extrn _BN_CTX_free:near	; CODE XREF: _SRP_create_verifier_BN+129p
		extrn _BN_num_bits:near	; CODE XREF: _SRP_create_verifier+1B1p
					; _SRP_create_verifier+1E2p
		extrn _BN_new:near	; CODE XREF: _SRP_create_verifier_BN+E1p
		extrn _BN_clear_free:near ; CODE XREF: _SRP_VBASE_init+256p
					; _SRP_create_verifier+283p ...
		extrn _BN_bin2bn:near	; CODE XREF: _SRP_VBASE_get1_by_user+13Ap
					; _SRP_VBASE_get1_by_user+14Cp	...
		extrn _BN_bn2bin:near	; CODE XREF: _SRP_create_verifier+1ABp
		extrn _BN_free:near	; CODE XREF: _SRP_VBASE_init+24Ep
					; _SRP_create_verifier+261p ...
		extrn _BN_mod_exp:near	; CODE XREF: _SRP_create_verifier_BN+FBp
		extrn _BN_dup:near	; CODE XREF: _srp_user_pwd_dup+91p
					; _srp_user_pwd_dup+9Bp
		extrn _SRP_get_default_gN:near ; CODE XREF: _SRP_VBASE_init+88p
					; _SRP_create_verifier+103p ...
		extrn _SRP_Calc_x:near	; CODE XREF: _SRP_create_verifier_BN+D7p
		extrn _EVP_MD_CTX_init:near ; CODE XREF: _SRP_VBASE_get1_by_user+BFp
		extrn _EVP_MD_CTX_cleanup:near ; CODE XREF: _SRP_VBASE_get1_by_user+12Cp
		extrn _EVP_DigestInit_ex:near ;	CODE XREF: _SRP_VBASE_get1_by_user+D4p
		extrn _EVP_DigestUpdate:near ; CODE XREF: _SRP_VBASE_get1_by_user+F4p
					; _SRP_VBASE_get1_by_user+111p
		extrn _EVP_DigestFinal_ex:near ; CODE XREF: _SRP_VBASE_get1_by_user+122p
		extrn _EVP_sha1:near	; CODE XREF: _SRP_VBASE_get1_by_user+C9p
		extrn _RAND_pseudo_bytes:near ;	CODE XREF: _SRP_VBASE_get1_by_user+AAp
					; _SRP_create_verifier+137p ...
		extrn _TXT_DB_read:near	; CODE XREF: _SRP_VBASE_init+5Fp
		extrn _TXT_DB_free:near	; CODE XREF: _SRP_VBASE_init+28Ep
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: _SRP_VBASE_get1_by_user+2Dp
					; _SRP_VBASE_get1_by_user+55p ...
		extrn __chkstk:near	; CODE XREF: _SRP_VBASE_get1_by_user+5p
					; _SRP_VBASE_init+5p ...
		extrn ___security_cookie:near ;	DATA XREF: _SRP_VBASE_get1_by_user+Ar
					; _SRP_create_verifier+Ar ...


		end
