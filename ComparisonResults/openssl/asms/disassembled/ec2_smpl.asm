;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	7D9BBB349FDBB08B1E2FCAE47EC3EFCD
; Input	CRC32 :	5E9D1244

; File Name   :	C:\compspace\Diff\openssl\obj\ec2_smpl.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_is_on_curve
_ec_GF2m_simple_is_on_curve proc near	; DATA XREF: .rdata:000004F4o

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 14h
		call	__chkstk
		push	ebx
		mov	ebx, [esp+18h+arg_0]
		push	ebp
		push	esi
		mov	esi, [esp+20h+arg_4]
		xor	ebp, ebp
		push	esi
		push	ebx
		call	_EC_POINT_is_at_infinity
		add	esp, 8
		test	eax, eax
		jz	short loc_2F
		pop	esi
		lea	eax, [ebp+1]
		pop	ebp
		pop	ebx
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_2F:					; CODE XREF: _ec_GF2m_simple_is_on_curve+23j
		mov	eax, [ebx]
		mov	ecx, [eax+84h]
		mov	eax, [eax+88h]
		mov	[esp+20h+var_10], ecx
		mov	[esp+20h+var_4], eax
		cmp	[esi+40h], ebp
		jnz	short loc_54
		pop	esi
		pop	ebp
		or	eax, 0FFFFFFFFh
		pop	ebx
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_54:					; CODE XREF: _ec_GF2m_simple_is_on_curve+48j
		push	edi
		mov	edi, [esp+24h+arg_8]
		test	edi, edi
		jnz	short loc_75
		call	_BN_CTX_new
		mov	ebp, eax
		mov	edi, ebp
		test	ebp, ebp
		jnz	short loc_75
		pop	edi
		pop	esi
		pop	ebp
		or	eax, 0FFFFFFFFh
		pop	ebx
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_75:					; CODE XREF: _ec_GF2m_simple_is_on_curve+5Bj
					; _ec_GF2m_simple_is_on_curve+68j
		push	edi
		call	_BN_CTX_start
		push	edi
		call	_BN_CTX_get
		push	edi
		mov	[esp+30h+var_C], eax
		call	_BN_CTX_get
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jz	loc_13F
		mov	ecx, [esp+24h+arg_4]
		lea	eax, [ebx+74h]
		add	ecx, 4
		push	eax
		push	ecx
		push	esi
		mov	[esp+30h+var_14], ecx
		call	_BN_GF2m_add
		add	esp, 0Ch
		test	eax, eax
		jz	loc_13F
		push	edi
		push	[esp+28h+var_14]
		push	esi
		push	esi
		push	ebx
		call	[esp+38h+var_10]
		add	esp, 14h
		test	eax, eax
		jz	short loc_13F
		mov	eax, [esp+24h+arg_4]
		add	eax, 18h
		push	eax
		push	esi
		push	esi
		mov	[esp+30h+var_8], eax
		call	_BN_GF2m_add
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_13F
		push	edi
		push	[esp+28h+var_14]
		push	esi
		push	esi
		push	ebx
		call	[esp+38h+var_10]
		add	esp, 14h
		test	eax, eax
		jz	short loc_13F
		lea	eax, [ebx+88h]
		push	eax
		push	esi
		push	esi
		call	_BN_GF2m_add
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_13F
		push	edi
		push	[esp+28h+var_8]
		push	[esp+2Ch+var_C]
		push	ebx
		call	[esp+34h+var_4]
		add	esp, 10h
		test	eax, eax
		jz	short loc_13F
		push	[esp+24h+var_C]
		push	esi
		push	esi
		call	_BN_GF2m_add
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_13F
		xor	ebx, ebx
		cmp	[esi+4], ebx
		setz	bl
		jmp	short $err$28
; ---------------------------------------------------------------------------

loc_13F:				; CODE XREF: _ec_GF2m_simple_is_on_curve+92j
					; _ec_GF2m_simple_is_on_curve+B3j ...
		or	ebx, 0FFFFFFFFh

$err$28:				; CODE XREF: _ec_GF2m_simple_is_on_curve+13Dj
		test	edi, edi
		jz	short loc_14F
		push	edi
		call	_BN_CTX_end
		add	esp, 4

loc_14F:				; CODE XREF: _ec_GF2m_simple_is_on_curve+144j
		test	ebp, ebp
		jz	short loc_15C
		push	ebp
		call	_BN_CTX_free
		add	esp, 4

loc_15C:				; CODE XREF: _ec_GF2m_simple_is_on_curve+151j
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, ebx
		pop	ebx
		add	esp, 14h
		retn
_ec_GF2m_simple_is_on_curve endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 168h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_cmp
_ec_GF2m_simple_cmp proc near		; DATA XREF: .rdata:000004F8o

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, 10h
		call	__chkstk
		push	ebx
		mov	ebx, [esp+14h+arg_4]
		push	esi
		mov	esi, [esp+18h+arg_0]
		push	edi
		push	ebx
		push	esi
		xor	edi, edi
		call	_EC_POINT_is_at_infinity
		add	esp, 8
		test	eax, eax
		jz	short loc_1A6
		push	[esp+1Ch+arg_8]
		push	esi
		call	_EC_POINT_is_at_infinity
		add	esp, 8
		neg	eax
		sbb	eax, eax
		inc	eax
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10h
		retn
; ---------------------------------------------------------------------------

loc_1A6:				; CODE XREF: _ec_GF2m_simple_cmp+23j
		push	ebp
		mov	ebp, [esp+20h+arg_8]
		push	ebp
		push	esi
		call	_EC_POINT_is_at_infinity
		add	esp, 8
		test	eax, eax
		jnz	short loc_1F3
		cmp	[ebx+40h], edi
		jz	short loc_200
		cmp	[ebp+40h], edi
		jz	short loc_200
		lea	eax, [ebp+4]
		push	eax
		lea	eax, [ebx+4]
		push	eax
		call	_BN_cmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_1F3
		lea	eax, [ebp+18h]
		push	eax
		lea	eax, [ebx+18h]
		push	eax
		call	_BN_cmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_1F3
		pop	ebp
		pop	edi
		pop	esi
		pop	ebx
		add	esp, 10h
		retn
; ---------------------------------------------------------------------------

loc_1F3:				; CODE XREF: _ec_GF2m_simple_cmp+4Fj
					; _ec_GF2m_simple_cmp+6Dj ...
		pop	ebp
		pop	edi
		pop	esi
		mov	eax, 1
		pop	ebx
		add	esp, 10h
		retn
; ---------------------------------------------------------------------------

loc_200:				; CODE XREF: _ec_GF2m_simple_cmp+54j
					; _ec_GF2m_simple_cmp+59j
		mov	esi, [esp+20h+arg_C]
		test	esi, esi
		jnz	short loc_220
		call	_BN_CTX_new
		mov	edi, eax
		mov	esi, edi
		test	edi, edi
		jnz	short loc_220
		pop	ebp
		pop	edi
		pop	esi
		or	eax, 0FFFFFFFFh
		pop	ebx
		add	esp, 10h
		retn
; ---------------------------------------------------------------------------

loc_220:				; CODE XREF: _ec_GF2m_simple_cmp+9Ej
					; _ec_GF2m_simple_cmp+ABj
		push	esi
		call	_BN_CTX_start
		push	esi
		call	_BN_CTX_get
		push	esi
		mov	[esp+2Ch+var_C], eax
		call	_BN_CTX_get
		push	esi
		mov	[esp+30h+var_4], eax
		call	_BN_CTX_get
		push	esi
		mov	[esp+34h+var_10], eax
		call	_BN_CTX_get
		add	esp, 14h
		mov	[esp+20h+var_8], eax
		test	eax, eax
		jz	short loc_2BA
		push	esi
		push	[esp+24h+var_4]
		push	[esp+28h+var_C]
		push	ebx
		mov	ebx, [esp+30h+arg_0]
		push	ebx
		call	_EC_POINT_get_affine_coordinates_GF2m
		add	esp, 14h
		test	eax, eax
		jz	short loc_2BA
		push	esi
		push	[esp+24h+var_8]
		push	[esp+28h+var_10]
		push	ebp
		push	ebx
		call	_EC_POINT_get_affine_coordinates_GF2m
		add	esp, 14h
		test	eax, eax
		jz	short loc_2BA
		push	[esp+20h+var_10]
		push	[esp+24h+var_C]
		call	_BN_cmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_2B3
		push	[esp+20h+var_8]
		push	[esp+24h+var_4]
		call	_BN_cmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_2B3
		xor	ebx, ebx
		jmp	short $err$23
; ---------------------------------------------------------------------------

loc_2B3:				; CODE XREF: _ec_GF2m_simple_cmp+131j
					; _ec_GF2m_simple_cmp+145j
		mov	ebx, 1
		jmp	short $err$23
; ---------------------------------------------------------------------------

loc_2BA:				; CODE XREF: _ec_GF2m_simple_cmp+EBj
					; _ec_GF2m_simple_cmp+106j ...
		or	ebx, 0FFFFFFFFh

$err$23:				; CODE XREF: _ec_GF2m_simple_cmp+149j
					; _ec_GF2m_simple_cmp+150j
		test	esi, esi
		jz	short loc_2CA
		push	esi
		call	_BN_CTX_end
		add	esp, 4

loc_2CA:				; CODE XREF: _ec_GF2m_simple_cmp+157j
		test	edi, edi
		jz	short loc_2D7
		push	edi
		call	_BN_CTX_free
		add	esp, 4

loc_2D7:				; CODE XREF: _ec_GF2m_simple_cmp+164j
		pop	ebp
		pop	edi
		pop	esi
		mov	eax, ebx
		pop	ebx
		add	esp, 10h
		retn
_ec_GF2m_simple_cmp endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2E4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_make_affine
_ec_GF2m_simple_make_affine proc near	; DATA XREF: .rdata:000004FCo

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 4
		call	__chkstk
		push	ebx
		push	ebp
		push	edi
		mov	edi, [esp+10h+arg_4]
		xor	ebx, ebx
		xor	ebp, ebp
		cmp	[edi+40h], ebx
		jnz	loc_3D3
		push	edi
		push	[esp+14h+arg_0]
		call	_EC_POINT_is_at_infinity
		add	esp, 8
		test	eax, eax
		jnz	loc_3D3
		push	esi
		mov	esi, [esp+14h+arg_8]
		test	esi, esi
		jnz	short loc_333
		call	_BN_CTX_new
		mov	ebx, eax
		mov	esi, ebx
		test	ebx, ebx
		jnz	short loc_333
		pop	esi
		pop	edi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_333:				; CODE XREF: _ec_GF2m_simple_make_affine+3Aj
					; _ec_GF2m_simple_make_affine+47j
		push	esi
		call	_BN_CTX_start
		push	esi
		call	_BN_CTX_get
		push	esi
		mov	[esp+20h+arg_4], eax
		call	_BN_CTX_get
		add	esp, 0Ch
		mov	[esp+14h+var_4], eax
		test	eax, eax
		jz	short $err$16
		push	esi
		push	eax
		push	[esp+1Ch+arg_4]
		push	edi
		push	[esp+24h+arg_0]
		call	_EC_POINT_get_affine_coordinates_GF2m
		add	esp, 14h
		test	eax, eax
		jz	short $err$16
		push	[esp+14h+arg_4]
		lea	eax, [edi+4]
		push	eax
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jz	short $err$16
		push	[esp+14h+var_4]
		lea	eax, [edi+18h]
		push	eax
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jz	short $err$16
		lea	eax, [edi+2Ch]
		push	1
		push	eax
		call	_BN_set_word
		add	esp, 8
		test	eax, eax
		jz	short $err$16
		mov	dword ptr [edi+40h], 1
		mov	ebp, 1

$err$16:				; CODE XREF: _ec_GF2m_simple_make_affine+6Ej
					; _ec_GF2m_simple_make_affine+85j ...
		test	esi, esi
		jz	short loc_3BE
		push	esi
		call	_BN_CTX_end
		add	esp, 4

loc_3BE:				; CODE XREF: _ec_GF2m_simple_make_affine+CFj
		test	ebx, ebx
		jz	short loc_3CB
		push	ebx
		call	_BN_CTX_free
		add	esp, 4

loc_3CB:				; CODE XREF: _ec_GF2m_simple_make_affine+DCj
		pop	esi
		pop	edi
		mov	eax, ebp
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_3D3:				; CODE XREF: _ec_GF2m_simple_make_affine+18j
					; _ec_GF2m_simple_make_affine+2Dj
		pop	edi
		pop	ebp
		mov	eax, 1
		pop	ebx
		pop	ecx
		retn
_ec_GF2m_simple_make_affine endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 3E0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_points_make_affine
_ec_GF2m_simple_points_make_affine proc	near ; DATA XREF: .rdata:00000500o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	ebx
		push	ebp
		push	esi
		push	edi
		mov	edi, [esp+10h+arg_4]
		xor	esi, esi
		test	edi, edi
		jz	short loc_412
		mov	ebp, [esp+10h+arg_C]
		mov	ebx, [esp+10h+arg_0]

loc_3F6:				; CODE XREF: _ec_GF2m_simple_points_make_affine+30j
		mov	ecx, [esp+10h+arg_8]
		mov	eax, [ebx]
		push	ebp
		push	dword ptr [ecx+esi*4]
		mov	eax, [eax+70h]
		push	ebx
		call	eax
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_41C
		inc	esi
		cmp	esi, edi
		jb	short loc_3F6

loc_412:				; CODE XREF: _ec_GF2m_simple_points_make_affine+Cj
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, 1
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_41C:				; CODE XREF: _ec_GF2m_simple_points_make_affine+2Bj
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
_ec_GF2m_simple_points_make_affine endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 424h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_field_mul
_ec_GF2m_simple_field_mul proc near	; DATA XREF: .rdata:00000510o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		push	[esp+arg_10]
		mov	eax, [esp+4+arg_0]
		add	eax, 5Ch ; '\'
		push	eax
		push	[esp+8+arg_C]
		push	[esp+0Ch+arg_8]
		push	[esp+10h+arg_4]
		call	_BN_GF2m_mod_mul_arr
		add	esp, 14h
		retn
_ec_GF2m_simple_field_mul endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 448h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_field_sqr
_ec_GF2m_simple_field_sqr proc near	; DATA XREF: .rdata:00000514o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	[esp+arg_C]
		mov	eax, [esp+4+arg_0]
		add	eax, 5Ch ; '\'
		push	eax
		push	[esp+8+arg_8]
		push	[esp+0Ch+arg_4]
		call	_BN_GF2m_mod_sqr_arr
		add	esp, 10h
		retn
_ec_GF2m_simple_field_sqr endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 468h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_field_div
_ec_GF2m_simple_field_div proc near	; DATA XREF: .rdata:00000518o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		push	[esp+arg_10]
		mov	eax, [esp+4+arg_0]
		add	eax, 48h ; 'H'
		push	eax
		push	[esp+8+arg_C]
		push	[esp+0Ch+arg_8]
		push	[esp+10h+arg_4]
		call	_BN_GF2m_mod_div
		add	esp, 14h
		retn
_ec_GF2m_simple_field_div endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 48Ch
; `EC_GF2m_simple_method'::`2'::ret
?ret@?1??EC_GF2m_simple_method@@9@9 dd 1, 197h ; DATA XREF: _EC_GF2m_simple_methodo
		dd offset _ec_GF2m_simple_group_init
		dd offset _ec_GF2m_simple_group_finish
		dd offset _ec_GF2m_simple_group_clear_finish
		dd offset _ec_GF2m_simple_group_copy
		dd offset _ec_GF2m_simple_group_set_curve
		dd offset _ec_GF2m_simple_group_get_curve
		dd offset _ec_GF2m_simple_group_get_degree
		dd offset _ec_GF2m_simple_group_check_discriminant
		dd offset _ec_GF2m_simple_point_init
		dd offset _ec_GF2m_simple_point_finish
		dd offset _ec_GF2m_simple_point_clear_finish
		dd offset _ec_GF2m_simple_point_copy
		dd offset _ec_GF2m_simple_point_set_to_infinity
		align 10h
		dd offset _ec_GF2m_simple_point_set_affine_coordinates
		dd offset _ec_GF2m_simple_point_get_affine_coordinates
		dd 3 dup(0)
		dd offset _ec_GF2m_simple_add
		dd offset _ec_GF2m_simple_dbl
		dd offset _ec_GF2m_simple_invert
		dd offset _ec_GF2m_simple_is_at_infinity
		dd offset _ec_GF2m_simple_is_on_curve
		dd offset _ec_GF2m_simple_cmp
		dd offset _ec_GF2m_simple_make_affine
		dd offset _ec_GF2m_simple_points_make_affine
		dd offset _ec_GF2m_simple_mul
		dd offset _ec_GF2m_precompute_mult
		dd offset _ec_GF2m_have_precompute_mult
		dd offset _ec_GF2m_simple_field_mul
		dd offset _ec_GF2m_simple_field_sqr
		dd offset _ec_GF2m_simple_field_div
		dd 3 dup(0)
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 528h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_group_init
_ec_GF2m_simple_group_init proc	near	; DATA XREF: .rdata:00000494o

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		lea	eax, [esi+48h]
		push	eax
		call	_BN_init
		lea	eax, [esi+74h]
		push	eax
		call	_BN_init
		lea	eax, [esi+88h]
		push	eax
		call	_BN_init
		add	esp, 0Ch
		mov	eax, 1
		pop	esi
		retn
_ec_GF2m_simple_group_init endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 558h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_group_finish
_ec_GF2m_simple_group_finish proc near	; DATA XREF: .rdata:00000498o

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		lea	eax, [esi+48h]
		push	eax
		call	_BN_free
		lea	eax, [esi+74h]
		push	eax
		call	_BN_free
		add	esp, 8
		lea	eax, [esi+88h]
		pop	esi
		mov	[esp+arg_0], eax
		jmp	_BN_free
_ec_GF2m_simple_group_finish endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 584h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_group_clear_finish
_ec_GF2m_simple_group_clear_finish proc	near ; DATA XREF: .rdata:0000049Co

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		lea	eax, [esi+48h]
		push	eax
		call	_BN_clear_free
		lea	eax, [esi+74h]
		push	eax
		call	_BN_clear_free
		lea	eax, [esi+88h]
		push	eax
		call	_BN_clear_free
		add	esp, 0Ch
		mov	dword ptr [esi+5Ch], 0
		mov	dword ptr [esi+60h], 0
		mov	dword ptr [esi+64h], 0
		mov	dword ptr [esi+68h], 0
		mov	dword ptr [esi+6Ch], 0
		mov	dword ptr [esi+70h], 0FFFFFFFFh
		pop	esi
		retn
_ec_GF2m_simple_group_clear_finish endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5D8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_group_copy
_ec_GF2m_simple_group_copy proc	near	; DATA XREF: .rdata:000004A0o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebp
		mov	ebp, [esp+4+arg_4]
		push	esi
		mov	esi, [esp+8+arg_0]
		lea	eax, [ebp+48h]
		push	eax
		lea	eax, [esi+48h]
		push	eax
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jnz	short loc_5F9
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_5F9:				; CODE XREF: _ec_GF2m_simple_group_copy+1Cj
		push	ebx
		lea	eax, [ebp+74h]
		push	eax
		lea	ebx, [esi+74h]
		push	ebx
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jnz	short loc_612
		pop	ebx
		pop	esi
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_612:				; CODE XREF: _ec_GF2m_simple_group_copy+34j
		push	edi
		lea	eax, [ebp+88h]
		push	eax
		lea	edi, [esi+88h]
		push	edi
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jz	short loc_6A0
		mov	eax, [ebp+5Ch]
		mov	[esi+5Ch], eax
		mov	eax, [ebp+60h]
		mov	[esi+60h], eax
		mov	eax, [ebp+64h]
		mov	[esi+64h], eax
		mov	eax, [ebp+68h]
		mov	[esi+68h], eax
		mov	eax, [ebp+6Ch]
		mov	[esi+6Ch], eax
		mov	eax, [ebp+70h]
		mov	[esi+70h], eax
		mov	eax, [esi+5Ch]
		add	eax, 1Fh
		cdq
		and	edx, 1Fh
		add	eax, edx
		sar	eax, 5
		cmp	eax, [esi+7Ch]
		jg	short loc_669
		mov	eax, ebx
		jmp	short loc_673
; ---------------------------------------------------------------------------

loc_669:				; CODE XREF: _ec_GF2m_simple_group_copy+8Bj
		push	eax
		push	ebx
		call	_bn_expand2
		add	esp, 8

loc_673:				; CODE XREF: _ec_GF2m_simple_group_copy+8Fj
		test	eax, eax
		jz	short loc_6A0
		mov	eax, [esi+5Ch]
		add	eax, 1Fh
		cdq
		and	edx, 1Fh
		add	eax, edx
		sar	eax, 5
		cmp	eax, [esi+90h]
		jg	short loc_692
		mov	eax, edi
		jmp	short loc_69C
; ---------------------------------------------------------------------------

loc_692:				; CODE XREF: _ec_GF2m_simple_group_copy+B4j
		push	eax
		push	edi
		call	_bn_expand2
		add	esp, 8

loc_69C:				; CODE XREF: _ec_GF2m_simple_group_copy+B8j
		test	eax, eax
		jnz	short loc_6A7

loc_6A0:				; CODE XREF: _ec_GF2m_simple_group_copy+53j
					; _ec_GF2m_simple_group_copy+9Dj
		pop	edi
		pop	ebx
		pop	esi
		xor	eax, eax
		pop	ebp
		retn
; ---------------------------------------------------------------------------

loc_6A7:				; CODE XREF: _ec_GF2m_simple_group_copy+C6j
		mov	ecx, [esi+78h]
		cmp	ecx, [esi+7Ch]
		jge	short loc_6C7
		nop	word ptr [eax+eax+00000000h]

loc_6B8:				; CODE XREF: _ec_GF2m_simple_group_copy+EDj
		mov	eax, [ebx]
		mov	dword ptr [eax+ecx*4], 0
		inc	ecx
		cmp	ecx, [esi+7Ch]
		jl	short loc_6B8

loc_6C7:				; CODE XREF: _ec_GF2m_simple_group_copy+D5j
		mov	eax, [esi+8Ch]
		cmp	eax, [esi+90h]
		jge	short loc_6EA
		nop	dword ptr [eax]

loc_6D8:				; CODE XREF: _ec_GF2m_simple_group_copy+110j
		mov	ecx, [edi]
		mov	dword ptr [ecx+eax*4], 0
		inc	eax
		cmp	eax, [esi+90h]
		jl	short loc_6D8

loc_6EA:				; CODE XREF: _ec_GF2m_simple_group_copy+FBj
		pop	edi
		pop	ebx
		pop	esi
		mov	eax, 1
		pop	ebp
		retn
_ec_GF2m_simple_group_copy endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 6F4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_group_set_curve
_ec_GF2m_simple_group_set_curve	proc near ; DATA XREF: .rdata:000004A4o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		push	[esp+8+arg_4]
		lea	edi, [esi+48h]
		push	edi
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jz	loc_810
		push	ebx
		push	6
		lea	ebx, [esi+5Ch]
		push	ebx
		push	edi
		call	_BN_GF2m_poly2arr
		dec	eax
		add	esp, 0Ch
		cmp	eax, 5
		jz	short loc_751
		cmp	eax, 3
		jz	short loc_751
		push	0DBh ; 'Û'
		push	offset ??_C@_0BH@HFFIPKFF@?4?2crypto?2ec?2ec2_smpl?4c?$AA@ ; ".\\crypto\\ec\\ec2_smpl.c"
		push	83h ; 'ƒ'
		push	0C3h ; 'Ã'
		push	10h
		call	_ERR_put_error
		add	esp, 14h

loc_74B:				; CODE XREF: _ec_GF2m_simple_group_set_curve+70j
					; _ec_GF2m_simple_group_set_curve+95j ...
		xor	eax, eax
		pop	ebx

$err$34:
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_751:				; CODE XREF: _ec_GF2m_simple_group_set_curve+32j
					; _ec_GF2m_simple_group_set_curve+37j
		push	ebx
		push	[esp+10h+arg_8]
		lea	edi, [esi+74h]
		push	edi
		call	_BN_GF2m_mod_arr
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_74B
		mov	eax, [ebx]
		add	eax, 1Fh
		cdq
		and	edx, 1Fh
		add	eax, edx
		sar	eax, 5
		cmp	eax, [esi+7Ch]
		jg	short loc_77D
		mov	eax, edi
		jmp	short loc_787
; ---------------------------------------------------------------------------

loc_77D:				; CODE XREF: _ec_GF2m_simple_group_set_curve+83j
		push	eax
		push	edi
		call	_bn_expand2
		add	esp, 8

loc_787:				; CODE XREF: _ec_GF2m_simple_group_set_curve+87j
		test	eax, eax
		jz	short loc_74B
		mov	ecx, [esi+78h]
		cmp	ecx, [esi+7Ch]
		jge	short loc_7A3
		nop

loc_794:				; CODE XREF: _ec_GF2m_simple_group_set_curve+ADj
		mov	eax, [edi]
		mov	dword ptr [eax+ecx*4], 0
		inc	ecx
		cmp	ecx, [esi+7Ch]
		jl	short loc_794

loc_7A3:				; CODE XREF: _ec_GF2m_simple_group_set_curve+9Dj
		push	ebx
		push	[esp+10h+arg_C]
		lea	edi, [esi+88h]
		push	edi
		call	_BN_GF2m_mod_arr
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_74B
		mov	eax, [ebx]
		add	eax, 1Fh
		cdq
		and	edx, 1Fh
		add	eax, edx
		sar	eax, 5
		cmp	eax, [esi+90h]
		jg	short loc_7D5
		mov	eax, edi
		jmp	short loc_7DF
; ---------------------------------------------------------------------------

loc_7D5:				; CODE XREF: _ec_GF2m_simple_group_set_curve+DBj
		push	eax
		push	edi
		call	_bn_expand2
		add	esp, 8

loc_7DF:				; CODE XREF: _ec_GF2m_simple_group_set_curve+DFj
		test	eax, eax
		jz	loc_74B
		mov	ecx, [esi+8Ch]
		cmp	ecx, [esi+90h]
		jge	short loc_807

loc_7F5:				; CODE XREF: _ec_GF2m_simple_group_set_curve+111j
		mov	eax, [edi]
		mov	dword ptr [eax+ecx*4], 0
		inc	ecx
		cmp	ecx, [esi+90h]
		jl	short loc_7F5

loc_807:				; CODE XREF: _ec_GF2m_simple_group_set_curve+FFj
		pop	ebx
		pop	edi
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_810:				; CODE XREF: _ec_GF2m_simple_group_set_curve+18j
		pop	edi
		xor	eax, eax
		pop	esi
		retn
_ec_GF2m_simple_group_set_curve	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 818h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_group_get_curve
_ec_GF2m_simple_group_get_curve	proc near ; DATA XREF: .rdata:000004A8o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	ecx, [esp+arg_4]
		push	esi
		xor	esi, esi
		push	edi
		mov	edi, [esp+8+arg_0]
		test	ecx, ecx
		jz	short loc_83C
		lea	eax, [edi+48h]
		push	eax
		push	ecx
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jnz	short loc_83C
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_83C:				; CODE XREF: _ec_GF2m_simple_group_get_curve+Ej
					; _ec_GF2m_simple_group_get_curve+1Fj
		mov	ecx, [esp+8+arg_8]
		test	ecx, ecx
		jz	short loc_855
		lea	eax, [edi+74h]
		push	eax
		push	ecx
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jz	short $err$10

loc_855:				; CODE XREF: _ec_GF2m_simple_group_get_curve+2Aj
		mov	ecx, [esp+8+arg_C]
		test	ecx, ecx
		jz	short loc_871
		lea	eax, [edi+88h]
		push	eax
		push	ecx
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jz	short $err$10

loc_871:				; CODE XREF: _ec_GF2m_simple_group_get_curve+43j
		mov	esi, 1

$err$10:				; CODE XREF: _ec_GF2m_simple_group_get_curve+3Bj
					; _ec_GF2m_simple_group_get_curve+57j
		pop	edi
		mov	eax, esi
		pop	esi
		retn
_ec_GF2m_simple_group_get_curve	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 87Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_group_get_degree
_ec_GF2m_simple_group_get_degree proc near ; DATA XREF:	.rdata:000004ACo

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		add	eax, 48h ; 'H'
		push	eax
		call	_BN_num_bits
		add	esp, 4
		dec	eax
		retn
_ec_GF2m_simple_group_get_degree endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 890h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_group_check_discriminant
_ec_GF2m_simple_group_check_discriminant proc near ; DATA XREF:	.rdata:000004B0o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		push	esi
		mov	esi, [esp+8+arg_4]
		xor	ebx, ebx
		push	edi
		xor	edi, edi
		test	esi, esi
		jnz	short loc_8CD
		call	_BN_CTX_new
		mov	ebx, eax
		mov	esi, ebx
		test	ebx, ebx
		jnz	short loc_8CD
		push	12Ch
		push	offset ??_C@_0BH@HFFIPKFF@?4?2crypto?2ec?2ec2_smpl?4c?$AA@ ; ".\\crypto\\ec\\ec2_smpl.c"
		push	41h ; 'A'
		push	9Fh ; 'Ÿ'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_8CD:				; CODE XREF: _ec_GF2m_simple_group_check_discriminant+Dj
					; _ec_GF2m_simple_group_check_discriminant+1Aj
		push	ebp
		push	esi
		call	_BN_CTX_start
		push	esi
		call	_BN_CTX_get
		mov	ebp, eax
		add	esp, 8
		test	ebp, ebp
		jz	short $err$12
		mov	edx, [esp+10h+arg_0]
		lea	ecx, [edx+5Ch]
		push	ecx
		lea	ecx, [edx+88h]
		push	ecx
		push	ebp
		call	_BN_GF2m_mod_arr
		add	esp, 0Ch
		test	eax, eax
		jz	short $err$12
		cmp	[ebp+4], edi
		mov	eax, 1
		cmovnz	edi, eax

$err$12:				; CODE XREF: _ec_GF2m_simple_group_check_discriminant+51j
					; _ec_GF2m_simple_group_check_discriminant+6Dj
		pop	ebp
		test	esi, esi
		jz	short loc_918
		push	esi
		call	_BN_CTX_end
		add	esp, 4

loc_918:				; CODE XREF: _ec_GF2m_simple_group_check_discriminant+7Dj
		test	ebx, ebx
		jz	short loc_925
		push	ebx
		call	_BN_CTX_free
		add	esp, 4

loc_925:				; CODE XREF: _ec_GF2m_simple_group_check_discriminant+8Aj
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebx
		retn
_ec_GF2m_simple_group_check_discriminant endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 92Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_point_init
_ec_GF2m_simple_point_init proc	near	; DATA XREF: .rdata:000004B4o

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		lea	eax, [esi+4]
		push	eax
		call	_BN_init
		lea	eax, [esi+18h]
		push	eax
		call	_BN_init
		lea	eax, [esi+2Ch]
		push	eax
		call	_BN_init
		add	esp, 0Ch
		mov	eax, 1
		pop	esi
		retn
_ec_GF2m_simple_point_init endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 958h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_point_finish
_ec_GF2m_simple_point_finish proc near	; DATA XREF: .rdata:000004B8o

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		lea	eax, [esi+4]
		push	eax
		call	_BN_free
		lea	eax, [esi+18h]
		push	eax
		call	_BN_free
		add	esp, 8
		lea	eax, [esi+2Ch]
		pop	esi
		mov	[esp+arg_0], eax
		jmp	_BN_free
_ec_GF2m_simple_point_finish endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 980h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_point_clear_finish
_ec_GF2m_simple_point_clear_finish proc	near ; DATA XREF: .rdata:000004BCo

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		lea	eax, [esi+4]
		push	eax
		call	_BN_clear_free
		lea	eax, [esi+18h]
		push	eax
		call	_BN_clear_free
		lea	eax, [esi+2Ch]
		push	eax
		call	_BN_clear_free
		add	esp, 0Ch
		mov	dword ptr [esi+40h], 0
		pop	esi
		retn
_ec_GF2m_simple_point_clear_finish endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 9ACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_point_copy
_ec_GF2m_simple_point_copy proc	near	; DATA XREF: .rdata:000004C0o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_4]
		push	edi
		mov	edi, [esp+8+arg_0]
		lea	eax, [esi+4]
		push	eax
		lea	eax, [edi+4]
		push	eax
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jnz	short loc_9CF

loc_9CA:				; CODE XREF: _ec_GF2m_simple_point_copy+35j
					; _ec_GF2m_simple_point_copy+49j
		pop	edi
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_9CF:				; CODE XREF: _ec_GF2m_simple_point_copy+1Cj
		lea	eax, [esi+18h]
		push	eax
		lea	eax, [edi+18h]
		push	eax
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jz	short loc_9CA
		lea	eax, [esi+2Ch]
		push	eax
		lea	eax, [edi+2Ch]
		push	eax
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jz	short loc_9CA
		mov	eax, [esi+40h]
		mov	[edi+40h], eax
		mov	eax, 1
		pop	edi
		pop	esi
		retn
_ec_GF2m_simple_point_copy endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A08h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_point_set_to_infinity
_ec_GF2m_simple_point_set_to_infinity proc near	; DATA XREF: .rdata:000004C4o

arg_4		= dword	ptr  8

		mov	eax, [esp+arg_4]
		push	0
		mov	dword ptr [eax+40h], 0
		add	eax, 2Ch ; ','
		push	eax
		call	_BN_set_word
		add	esp, 8
		mov	eax, 1
		retn
_ec_GF2m_simple_point_set_to_infinity endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A28h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_point_set_affine_coordinates
_ec_GF2m_simple_point_set_affine_coordinates proc near ; DATA XREF: .rdata:000004D0o

arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, [esp+arg_8]
		push	ebx
		push	edi
		xor	edi, edi
		test	eax, eax
		jz	short loc_AA5
		mov	ebx, [esp+8+arg_C]
		test	ebx, ebx
		jz	short loc_AA5
		push	ebp
		push	esi
		mov	esi, [esp+10h+arg_4]
		push	eax
		lea	ebp, [esi+4]
		push	ebp
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jz	short $err$9
		push	edi
		push	ebp
		call	_BN_set_negative
		lea	ebp, [esi+18h]
		push	ebx
		push	ebp
		call	_BN_copy
		add	esp, 10h
		test	eax, eax
		jz	short $err$9
		push	edi
		push	ebp
		call	_BN_set_negative
		lea	ebx, [esi+2Ch]
		call	_BN_value_one
		push	eax
		push	ebx
		call	_BN_copy
		add	esp, 10h
		test	eax, eax
		jz	short $err$9
		push	edi
		push	ebx
		call	_BN_set_negative
		add	esp, 8
		mov	dword ptr [esi+40h], 1
		mov	edi, 1

$err$9:					; CODE XREF: _ec_GF2m_simple_point_set_affine_coordinates+29j
					; _ec_GF2m_simple_point_set_affine_coordinates+41j ...
		pop	esi
		pop	ebp
		mov	eax, edi
		pop	edi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_AA5:				; CODE XREF: _ec_GF2m_simple_point_set_affine_coordinates+Aj
					; _ec_GF2m_simple_point_set_affine_coordinates+12j
		push	18Ch
		push	offset ??_C@_0BH@HFFIPKFF@?4?2crypto?2ec?2ec2_smpl?4c?$AA@ ; ".\\crypto\\ec\\ec2_smpl.c"
		push	43h ; 'C'
		push	0A3h ; '£'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	ebx
		retn
_ec_GF2m_simple_point_set_affine_coordinates endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0AC8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_point_get_affine_coordinates
_ec_GF2m_simple_point_get_affine_coordinates proc near ; DATA XREF: .rdata:000004D4o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	ebx
		push	edi
		mov	edi, [esp+8+arg_4]
		xor	ebx, ebx
		push	edi
		push	[esp+0Ch+arg_0]
		call	_EC_POINT_is_at_infinity
		add	esp, 8
		test	eax, eax
		jz	short loc_B01
		push	1ADh
		push	offset ??_C@_0BH@HFFIPKFF@?4?2crypto?2ec?2ec2_smpl?4c?$AA@ ; ".\\crypto\\ec\\ec2_smpl.c"
		push	6Ah ; 'j'
		push	0A2h ; '¢'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_B01:				; CODE XREF: _ec_GF2m_simple_point_get_affine_coordinates+17j
		call	_BN_value_one
		push	eax
		lea	eax, [edi+2Ch]
		push	eax
		call	_BN_cmp
		add	esp, 8
		test	eax, eax
		jz	short loc_B37
		push	1B3h
		push	offset ??_C@_0BH@HFFIPKFF@?4?2crypto?2ec?2ec2_smpl?4c?$AA@ ; ".\\crypto\\ec\\ec2_smpl.c"
		push	42h ; 'B'
		push	0A2h ; '¢'
		push	10h
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_B37:				; CODE XREF: _ec_GF2m_simple_point_get_affine_coordinates+4Dj
		push	esi
		mov	esi, [esp+0Ch+arg_8]
		test	esi, esi
		jz	short loc_B5C
		lea	eax, [edi+4]
		push	eax
		push	esi
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jz	short $err$11
		push	0
		push	esi
		call	_BN_set_negative
		add	esp, 8

loc_B5C:				; CODE XREF: _ec_GF2m_simple_point_get_affine_coordinates+76j
		mov	esi, [esp+0Ch+arg_C]
		test	esi, esi
		jz	short loc_B80
		lea	eax, [edi+18h]
		push	eax
		push	esi
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jz	short $err$11
		push	0
		push	esi
		call	_BN_set_negative
		add	esp, 8

loc_B80:				; CODE XREF: _ec_GF2m_simple_point_get_affine_coordinates+9Aj
		mov	ebx, 1

$err$11:				; CODE XREF: _ec_GF2m_simple_point_get_affine_coordinates+87j
					; _ec_GF2m_simple_point_get_affine_coordinates+ABj
		pop	esi
		pop	edi
		mov	eax, ebx
		pop	ebx
		retn
_ec_GF2m_simple_point_get_affine_coordinates endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B8Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_add
_ec_GF2m_simple_add proc near		; CODE XREF: _ec_GF2m_simple_dbl+12p
					; DATA XREF: .rdata:000004E4o

var_1C		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	eax, 1Ch
		call	__chkstk
		push	ebx
		mov	ebx, [esp+20h+arg_8]
		push	esi
		mov	esi, [esp+24h+arg_0]
		push	ebx
		push	esi
		mov	[esp+2Ch+var_4], 0
		call	_EC_POINT_is_at_infinity
		add	esp, 8
		test	eax, eax
		jz	short loc_BD2
		push	[esp+24h+arg_C]

loc_BBA:				; CODE XREF: _ec_GF2m_simple_add+59j
		push	[esp+28h+arg_4]
		call	_EC_POINT_copy
		add	esp, 8
		neg	eax
		sbb	eax, eax
		neg	eax
		pop	esi
		pop	ebx
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_BD2:				; CODE XREF: _ec_GF2m_simple_add+28j
		mov	eax, [esp+24h+arg_C]
		push	eax
		push	esi
		call	_EC_POINT_is_at_infinity
		add	esp, 8
		test	eax, eax
		jz	short loc_BE7
		push	ebx
		jmp	short loc_BBA
; ---------------------------------------------------------------------------

loc_BE7:				; CODE XREF: _ec_GF2m_simple_add+56j
		mov	ebx, [esp+24h+arg_10]
		test	ebx, ebx
		jnz	short loc_C04
		call	_BN_CTX_new
		mov	[esp+24h+var_4], eax
		mov	ebx, eax
		test	eax, eax
		jnz	short loc_C04
		pop	esi
		pop	ebx
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_C04:				; CODE XREF: _ec_GF2m_simple_add+61j
					; _ec_GF2m_simple_add+70j
		push	ebp
		push	edi
		push	ebx
		call	_BN_CTX_start
		push	ebx
		call	_BN_CTX_get
		push	ebx
		mov	[esp+38h+var_14], eax
		call	_BN_CTX_get
		push	ebx
		mov	[esp+3Ch+var_10], eax
		call	_BN_CTX_get
		push	ebx
		mov	[esp+40h+var_1C], eax
		call	_BN_CTX_get
		push	ebx
		mov	[esp+44h+var_18], eax
		call	_BN_CTX_get
		push	ebx
		mov	edi, eax
		call	_BN_CTX_get
		push	ebx
		mov	[esp+4Ch+var_8], eax
		call	_BN_CTX_get
		push	ebx
		mov	ebp, eax
		call	_BN_CTX_get
		add	esp, 24h
		mov	[esp+2Ch+var_C], eax
		test	eax, eax
		jz	loc_EDE
		mov	eax, [esp+2Ch+arg_8]
		cmp	dword ptr [eax+40h], 0
		jz	short loc_C9B
		lea	ecx, [eax+4]
		push	ecx
		push	[esp+30h+var_14]
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jz	loc_EDE
		mov	eax, [esp+2Ch+arg_8]
		add	eax, 18h
		push	eax
		push	[esp+30h+var_10]
		call	_BN_copy
		add	esp, 8
		jmp	short loc_CAE
; ---------------------------------------------------------------------------

loc_C9B:				; CODE XREF: _ec_GF2m_simple_add+DFj
		push	ebx
		push	[esp+30h+var_10]
		push	[esp+34h+var_14]
		push	eax
		push	esi
		call	_EC_POINT_get_affine_coordinates_GF2m
		add	esp, 14h

loc_CAE:				; CODE XREF: _ec_GF2m_simple_add+10Dj
		test	eax, eax
		jz	loc_EDE
		mov	eax, [esp+2Ch+arg_C]
		cmp	dword ptr [eax+40h], 0
		jz	short loc_CEE
		add	eax, 4
		push	eax
		push	[esp+30h+var_1C]
		call	_BN_copy
		add	esp, 8
		test	eax, eax
		jz	loc_EDE
		mov	eax, [esp+2Ch+arg_C]
		add	eax, 18h
		push	eax
		push	[esp+30h+var_18]
		call	_BN_copy
		add	esp, 8
		jmp	short loc_D01
; ---------------------------------------------------------------------------

loc_CEE:				; CODE XREF: _ec_GF2m_simple_add+132j
		push	ebx
		push	[esp+30h+var_18]
		push	[esp+34h+var_1C]
		push	eax
		push	esi
		call	_EC_POINT_get_affine_coordinates_GF2m
		add	esp, 14h

loc_D01:				; CODE XREF: _ec_GF2m_simple_add+160j
		test	eax, eax
		jz	loc_EDE
		push	[esp+2Ch+var_1C]
		push	[esp+30h+var_14]
		call	_BN_ucmp
		add	esp, 8
		test	eax, eax
		jz	loc_DBE
		push	[esp+2Ch+var_1C]
		push	[esp+30h+var_14]
		push	[esp+34h+var_C]
		call	_BN_GF2m_add
		add	esp, 0Ch
		test	eax, eax
		jz	loc_EDE
		push	[esp+2Ch+var_18]
		push	[esp+30h+var_10]
		push	ebp
		call	_BN_GF2m_add
		add	esp, 0Ch
		test	eax, eax
		jz	loc_EDE
		mov	eax, [esi]
		push	ebx
		push	[esp+30h+var_C]
		mov	eax, [eax+8Ch]
		push	ebp
		push	ebp
		push	esi
		call	eax
		add	esp, 14h
		test	eax, eax
		jz	loc_EDE
		mov	eax, [esi]
		push	ebx
		push	ebp
		push	edi
		mov	eax, [eax+88h]
		push	esi
		call	eax
		add	esp, 10h
		test	eax, eax
		jz	loc_EDE
		lea	eax, [esi+74h]
		push	eax
		push	edi
		push	edi
		call	_BN_GF2m_add
		add	esp, 0Ch
		test	eax, eax
		jz	loc_EDE
		push	ebp
		push	edi
		push	edi
		call	_BN_GF2m_add
		add	esp, 0Ch
		test	eax, eax
		jz	loc_EDE
		push	[esp+2Ch+var_C]
		jmp	loc_E46
; ---------------------------------------------------------------------------

loc_DBE:				; CODE XREF: _ec_GF2m_simple_add+18Fj
		push	[esp+2Ch+var_18]
		push	[esp+30h+var_10]
		call	_BN_ucmp
		add	esp, 8
		test	eax, eax
		jnz	loc_EC3
		mov	ecx, [esp+2Ch+var_1C]
		cmp	[ecx+4], eax
		jz	loc_EC3
		mov	eax, [esi]
		push	ebx
		push	ecx
		push	[esp+34h+var_18]
		mov	eax, [eax+8Ch]
		push	ebp
		push	esi
		call	eax
		add	esp, 14h
		test	eax, eax
		jz	loc_EDE
		push	[esp+2Ch+var_1C]
		push	ebp
		push	ebp
		call	_BN_GF2m_add
		add	esp, 0Ch
		test	eax, eax
		jz	loc_EDE
		mov	eax, [esi]
		push	ebx
		push	ebp
		push	edi
		mov	eax, [eax+88h]
		push	esi
		call	eax
		add	esp, 10h
		test	eax, eax
		jz	loc_EDE
		push	ebp
		push	edi
		push	edi
		call	_BN_GF2m_add
		add	esp, 0Ch
		test	eax, eax
		jz	loc_EDE
		lea	eax, [esi+74h]
		push	eax

loc_E46:				; CODE XREF: _ec_GF2m_simple_add+22Dj
		push	edi
		push	edi
		call	_BN_GF2m_add
		add	esp, 0Ch
		test	eax, eax
		jz	loc_EDE
		push	edi
		push	[esp+30h+var_1C]
		push	[esp+34h+var_8]
		call	_BN_GF2m_add
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_EDE
		mov	eax, [esi]
		push	ebx
		push	ebp
		mov	ebp, [esp+34h+var_8]
		mov	eax, [eax+84h]
		push	ebp
		push	ebp
		push	esi
		call	eax
		add	esp, 14h
		test	eax, eax
		jz	short loc_EDE
		push	edi
		push	ebp
		push	ebp
		call	_BN_GF2m_add
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_EDE
		push	[esp+2Ch+var_18]
		push	ebp
		push	ebp
		call	_BN_GF2m_add
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_EDE
		push	ebx
		push	ebp
		push	edi
		push	[esp+38h+arg_4]
		push	esi
		call	_EC_POINT_set_affine_coordinates_GF2m
		add	esp, 14h
		test	eax, eax
		jz	short loc_EDE
		mov	ebp, 1
		jmp	short $err$76
; ---------------------------------------------------------------------------

loc_EC3:				; CODE XREF: _ec_GF2m_simple_add+244j
					; _ec_GF2m_simple_add+251j
		push	[esp+2Ch+arg_4]
		push	esi
		call	_EC_POINT_set_to_infinity
		xor	ebp, ebp
		add	esp, 8
		test	eax, eax
		mov	ecx, 1
		cmovnz	ebp, ecx
		jmp	short $err$76
; ---------------------------------------------------------------------------

loc_EDE:				; CODE XREF: _ec_GF2m_simple_add+D1j
					; _ec_GF2m_simple_add+F3j ...
		xor	ebp, ebp

$err$76:				; CODE XREF: _ec_GF2m_simple_add+335j
					; _ec_GF2m_simple_add+350j
		push	ebx
		call	_BN_CTX_end
		mov	eax, [esp+30h+var_4]
		add	esp, 4
		test	eax, eax
		jz	short loc_EFA
		push	eax
		call	_BN_CTX_free
		add	esp, 4

loc_EFA:				; CODE XREF: _ec_GF2m_simple_add+363j
		pop	edi
		mov	eax, ebp
		pop	ebp
		pop	esi
		pop	ebx
		add	esp, 1Ch
		retn
_ec_GF2m_simple_add endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F04h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_dbl
_ec_GF2m_simple_dbl proc near		; DATA XREF: .rdata:000004E8o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	[esp+arg_C]
		mov	eax, [esp+4+arg_8]
		push	eax
		push	eax
		push	[esp+0Ch+arg_4]
		push	[esp+10h+arg_0]
		call	_ec_GF2m_simple_add
		add	esp, 14h
		retn
_ec_GF2m_simple_dbl endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F20h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_invert
_ec_GF2m_simple_invert proc near	; DATA XREF: .rdata:000004ECo

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_4]
		push	esi
		push	[esp+8+arg_0]
		call	_EC_POINT_is_at_infinity
		add	esp, 8
		test	eax, eax
		jnz	short loc_F65
		cmp	[esi+1Ch], eax
		jz	short loc_F65
		push	[esp+4+arg_8]
		push	esi
		push	[esp+0Ch+arg_0]
		call	_EC_POINT_make_affine
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_F52
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_F52:				; CODE XREF: _ec_GF2m_simple_invert+2Ej
		lea	ecx, [esi+18h]
		push	ecx
		lea	eax, [esi+4]
		push	eax
		push	ecx
		call	_BN_GF2m_add
		add	esp, 0Ch
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_F65:				; CODE XREF: _ec_GF2m_simple_invert+14j
					; _ec_GF2m_simple_invert+19j
		mov	eax, 1
		pop	esi
		retn
_ec_GF2m_simple_invert endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F6Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _ec_GF2m_simple_is_at_infinity
_ec_GF2m_simple_is_at_infinity proc near ; DATA	XREF: .rdata:000004F0o

arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_4]
		xor	eax, eax
		cmp	[ecx+30h], eax
		setz	al
		retn
_ec_GF2m_simple_is_at_infinity endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F7Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _EC_GF2m_simple_method
_EC_GF2m_simple_method proc near
		mov	eax, offset ?ret@?1??EC_GF2m_simple_method@@9@9	; `EC_GF2m_simple_method'::`2'::ret
		retn
_EC_GF2m_simple_method endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F84h
; COMDAT (pick any)
		public ??_C@_0BH@HFFIPKFF@?4?2crypto?2ec?2ec2_smpl?4c?$AA@
; `string'
??_C@_0BH@HFFIPKFF@?4?2crypto?2ec?2ec2_smpl?4c?$AA@ db '.\crypto\ec\ec2_smpl.c',0
					; DATA XREF: _ec_GF2m_simple_group_set_curve+3Eo
					; _ec_GF2m_simple_group_check_discriminant+21o	...
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _ec_GF2m_simple_mul:near ; DATA XREF: .rdata:00000504o
		extrn _ec_GF2m_precompute_mult:near ; DATA XREF: .rdata:00000508o
		extrn _ec_GF2m_have_precompute_mult:near ; DATA	XREF: .rdata:0000050Co
		extrn _ERR_put_error:near ; CODE XREF: _ec_GF2m_simple_group_set_curve+4Fp
					; _ec_GF2m_simple_group_check_discriminant+2Fp	...
		extrn _BN_value_one:near
					; CODE XREF: _ec_GF2m_simple_point_set_affine_coordinates+4Dp
					; _ec_GF2m_simple_point_get_affine_coordinates:loc_B01p
		extrn _BN_CTX_new:near	; CODE XREF: _ec_GF2m_simple_is_on_curve+5Dp
					; _ec_GF2m_simple_cmp+A0p ...
		extrn _BN_CTX_free:near	; CODE XREF: _ec_GF2m_simple_is_on_curve+154p
					; _ec_GF2m_simple_cmp+167p ...
		extrn _BN_CTX_start:near ; CODE	XREF: _ec_GF2m_simple_is_on_curve+76p
					; _ec_GF2m_simple_cmp+B9p ...
		extrn _BN_CTX_get:near	; CODE XREF: _ec_GF2m_simple_is_on_curve+7Cp
					; _ec_GF2m_simple_is_on_curve+86p ...
		extrn _BN_CTX_end:near	; CODE XREF: _ec_GF2m_simple_is_on_curve+147p
					; _ec_GF2m_simple_cmp+15Ap ...
		extrn _BN_num_bits:near	; CODE XREF: _ec_GF2m_simple_group_get_degree+8p
		extrn _BN_init:near	; CODE XREF: _ec_GF2m_simple_group_init+9p
					; _ec_GF2m_simple_group_init+12p ...
		extrn _BN_clear_free:near ; CODE XREF: _ec_GF2m_simple_group_clear_finish+9p
					; _ec_GF2m_simple_group_clear_finish+12p ...
		extrn _BN_copy:near	; CODE XREF: _ec_GF2m_simple_make_affine+8Fp
					; _ec_GF2m_simple_make_affine+A3p ...
		extrn _BN_set_negative:near
					; CODE XREF: _ec_GF2m_simple_point_set_affine_coordinates+2Dp
					; _ec_GF2m_simple_point_set_affine_coordinates+45p ...
		extrn _BN_set_word:near	; CODE XREF: _ec_GF2m_simple_make_affine+B5p
					; _ec_GF2m_simple_point_set_to_infinity+11p
		extrn _BN_cmp:near	; CODE XREF: _ec_GF2m_simple_cmp+63p
					; _ec_GF2m_simple_cmp+77p ...
		extrn _BN_free:near	; CODE XREF: _ec_GF2m_simple_group_finish+9p
					; _ec_GF2m_simple_group_finish+12p ...
		extrn _BN_ucmp:near	; CODE XREF: _ec_GF2m_simple_add+185p
					; _ec_GF2m_simple_add+23Ap
		extrn _BN_GF2m_add:near	; CODE XREF: _ec_GF2m_simple_is_on_curve+A9p
					; _ec_GF2m_simple_is_on_curve+DAp ...
		extrn _BN_GF2m_mod_div:near ; CODE XREF: _ec_GF2m_simple_field_div+18p
		extrn _BN_GF2m_mod_arr:near ; CODE XREF: _ec_GF2m_simple_group_set_curve+66p
					; _ec_GF2m_simple_group_set_curve+BBp ...
		extrn _BN_GF2m_mod_mul_arr:near	; CODE XREF: _ec_GF2m_simple_field_mul+18p
		extrn _BN_GF2m_mod_sqr_arr:near	; CODE XREF: _ec_GF2m_simple_field_sqr+14p
		extrn _BN_GF2m_poly2arr:near
					; CODE XREF: _ec_GF2m_simple_group_set_curve+26p
		extrn _bn_expand2:near	; CODE XREF: _ec_GF2m_simple_group_copy+93p
					; _ec_GF2m_simple_group_copy+BCp ...
		extrn _EC_POINT_copy:near ; CODE XREF: _ec_GF2m_simple_add+32p
		extrn _EC_POINT_set_to_infinity:near ; CODE XREF: _ec_GF2m_simple_add+33Cp
		extrn _EC_POINT_set_affine_coordinates_GF2m:near
					; CODE XREF: _ec_GF2m_simple_add+324p
		extrn _EC_POINT_get_affine_coordinates_GF2m:near
					; CODE XREF: _ec_GF2m_simple_cmp+FCp
					; _ec_GF2m_simple_cmp+113p ...
		extrn _EC_POINT_is_at_infinity:near
					; CODE XREF: _ec_GF2m_simple_is_on_curve+19p
					; _ec_GF2m_simple_cmp+19p ...
		extrn _EC_POINT_make_affine:near ; CODE	XREF: _ec_GF2m_simple_invert+24p
		extrn __chkstk:near	; CODE XREF: _ec_GF2m_simple_is_on_curve+5p
					; _ec_GF2m_simple_cmp+5p ...


		end
