;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	E518C932AE1460E6B5D90D0D5D8964BE
; Input	CRC32 :	B77E7831

; File Name   :	C:\compspace\Diff\openssl\obj\mem_dbg.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
_mh_mode	dd ?			; DATA XREF: _CRYPTO_dbg_free+8Cr
					; _CRYPTO_dbg_free+BEw	...
_order		dd ?			; DATA XREF: _CRYPTO_dbg_malloc:loc_201r
					; _CRYPTO_dbg_malloc+101w
_mh		dd ?			; DATA XREF: _CRYPTO_dbg_free+2Fr
					; _CRYPTO_dbg_free+4Cr	...
_amih		dd ?			; DATA XREF: _CRYPTO_dbg_malloc+136r
					; _CRYPTO_mem_leaks+13r ...
_options	dd ?			; DATA XREF: _CRYPTO_dbg_get_optionsr
					; _CRYPTO_dbg_malloc+B3r ...
_num_disable	dd ?			; DATA XREF: _CRYPTO_dbg_free+98r
					; _CRYPTO_dbg_free+A5w	...
_break_order_num dd ?			; DATA XREF: _CRYPTO_dbg_malloc+F2r
_disabling_threadid dd 2 dup(?)		; DATA XREF: _CRYPTO_is_mem_check_on+41o
					; _CRYPTO_mem_ctrl+95o	...
_bss		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 24h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_dbg_free
_CRYPTO_dbg_free proc near

var_30		= dword	ptr -30h
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 30h ; '0'
		call	__chkstk
		cmp	[esp+30h+arg_4], 0
		jnz	loc_106
		push	esi
		mov	esi, [esp+34h+arg_0]
		test	esi, esi
		jz	loc_105
		call	_CRYPTO_is_mem_check_on
		test	eax, eax
		jz	loc_105
		cmp	ds:_mh,	0
		jz	loc_105
		push	3
		call	_CRYPTO_mem_ctrl
		lea	eax, [esp+38h+var_30]
		mov	[esp+38h+var_30], esi
		push	eax
		push	ds:_mh
		call	_lh_delete
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jz	short loc_9D
		mov	eax, [esi+28h]
		test	eax, eax
		jz	short loc_94
		push	eax
		call	_app_info_free
		add	esp, 4

loc_94:					; CODE XREF: _CRYPTO_dbg_free+65j
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_9D:					; CODE XREF: _CRYPTO_dbg_free+5Ej
		push	0D4h ; 'Ô'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_mh_mode
		add	esp, 10h
		test	al, 1
		jz	short loc_EF
		mov	ecx, ds:_num_disable
		test	ecx, ecx
		jz	short loc_EF
		sub	ecx, 1
		mov	ds:_num_disable, ecx
		jnz	short loc_EF
		push	109h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		or	eax, 2
		push	1Bh
		push	0Ah
		mov	ds:_mh_mode, eax
		call	_CRYPTO_lock
		add	esp, 10h

loc_EF:					; CODE XREF: _CRYPTO_dbg_free+96j
					; _CRYPTO_dbg_free+A0j	...
		push	112h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h

loc_105:				; CODE XREF: _CRYPTO_dbg_free+1Cj
					; _CRYPTO_dbg_free+29j	...
		pop	esi

loc_106:				; CODE XREF: _CRYPTO_dbg_free+Fj
		add	esp, 30h
		retn
_CRYPTO_dbg_free endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 10Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_dbg_get_options
_CRYPTO_dbg_get_options	proc near
		mov	eax, ds:_options
		retn
_CRYPTO_dbg_get_options	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 114h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_dbg_malloc
_CRYPTO_dbg_malloc proc	near		; CODE XREF: _CRYPTO_dbg_realloc+3Dp

var_1C		= byte ptr -1Ch
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	eax, 1Ch
		call	__chkstk
		mov	eax, [esp+1Ch+arg_10]
		and	eax, 7Fh
		sub	eax, 1
		jnz	loc_305
		push	edi
		mov	edi, [esp+20h+arg_0]
		test	edi, edi
		jz	loc_304
		call	_CRYPTO_is_mem_check_on
		test	eax, eax
		jz	loc_304
		push	esi
		push	3
		call	_CRYPTO_mem_ctrl
		push	1E1h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	30h ; '0'
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 10h
		test	esi, esi
		jnz	short loc_18B
		push	edi
		call	_CRYPTO_free
		push	0D4h ; 'Ô'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	9
		call	_CRYPTO_lock
		add	esp, 14h
		jmp	loc_2B1
; ---------------------------------------------------------------------------

loc_18B:				; CODE XREF: _CRYPTO_dbg_malloc+54j
		cmp	ds:_mh,	0
		jnz	short loc_1C3
		push	offset _mem_LHASH_COMP
		push	offset _mem_LHASH_HASH
		call	_lh_new
		add	esp, 8
		mov	ds:_mh,	eax
		test	eax, eax
		jnz	short loc_1C3
		push	edi
		call	_CRYPTO_free
		push	esi
		call	_CRYPTO_free
		add	esp, 8
		jmp	$err$60
; ---------------------------------------------------------------------------

loc_1C3:				; CODE XREF: _CRYPTO_dbg_malloc+7Ej
					; _CRYPTO_dbg_malloc+99j
		mov	eax, [esp+24h+arg_8]
		mov	ecx, ds:_options
		mov	[esi+8], eax
		mov	eax, [esp+24h+arg_C]
		mov	[esi+0Ch], eax
		mov	eax, [esp+24h+arg_4]
		mov	[esi], edi
		mov	[esi+4], eax
		test	cl, 2
		jz	short loc_1F9
		lea	eax, [esi+10h]
		push	eax
		call	_CRYPTO_THREADID_current
		mov	ecx, ds:_options
		add	esp, 4
		jmp	short loc_201
; ---------------------------------------------------------------------------

loc_1F9:				; CODE XREF: _CRYPTO_dbg_malloc+CFj
		xorps	xmm0, xmm0
		movq	qword ptr [esi+10h], xmm0

loc_201:				; CODE XREF: _CRYPTO_dbg_malloc+E3j
		mov	eax, ds:_order
		cmp	eax, ds:_break_order_num
		jnz	short loc_211
		mov	[esi+18h], eax

loc_211:				; CODE XREF: _CRYPTO_dbg_malloc+F8j
		mov	[esi+18h], eax
		inc	eax
		mov	ds:_order, eax
		test	cl, 1
		jz	short loc_232
		push	0		; Time
		call	dword ptr ds:__imp___time64
		add	esp, 4
		mov	[esi+20h], eax
		mov	[esi+24h], edx
		jmp	short loc_240
; ---------------------------------------------------------------------------

loc_232:				; CODE XREF: _CRYPTO_dbg_malloc+109j
		mov	dword ptr [esi+20h], 0
		mov	dword ptr [esi+24h], 0

loc_240:				; CODE XREF: _CRYPTO_dbg_malloc+11Cj
		lea	eax, [esp+24h+var_1C]
		push	eax
		call	_CRYPTO_THREADID_current
		mov	eax, ds:_amih
		add	esp, 4
		mov	dword ptr [esi+28h], 0
		test	eax, eax
		jz	short loc_275
		lea	ecx, [esp+24h+var_1C]
		push	ecx
		push	eax
		call	_lh_retrieve
		add	esp, 8
		test	eax, eax
		jz	short loc_275
		mov	[esi+28h], eax
		inc	dword ptr [eax+18h]

loc_275:				; CODE XREF: _CRYPTO_dbg_malloc+147j
					; _CRYPTO_dbg_malloc+159j
		push	esi
		push	ds:_mh
		call	_lh_insert
		add	esp, 8
		test	eax, eax
		jz	short $err$60
		mov	ecx, [eax+28h]
		test	ecx, ecx
		jz	short loc_292
		dec	dword ptr [ecx+18h]

loc_292:				; CODE XREF: _CRYPTO_dbg_malloc+179j
		push	eax
		call	_CRYPTO_free
		add	esp, 4

$err$60:				; CODE XREF: _CRYPTO_dbg_malloc+AAj
					; _CRYPTO_dbg_malloc+172j
		push	0D4h ; 'Ô'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	9
		call	_CRYPTO_lock
		add	esp, 10h

loc_2B1:				; CODE XREF: _CRYPTO_dbg_malloc+72j
		mov	eax, ds:_mh_mode
		test	al, 1
		jz	short loc_2ED
		mov	ecx, ds:_num_disable
		test	ecx, ecx
		jz	short loc_2ED
		sub	ecx, 1
		mov	ds:_num_disable, ecx
		jnz	short loc_2ED
		push	109h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	1Bh
		or	eax, 2
		push	0Ah
		mov	ds:_mh_mode, eax
		call	_CRYPTO_lock
		add	esp, 10h

loc_2ED:				; CODE XREF: _CRYPTO_dbg_malloc+1A4j
					; _CRYPTO_dbg_malloc+1AEj ...
		push	112h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h
		pop	esi

loc_304:				; CODE XREF: _CRYPTO_dbg_malloc+21j
					; _CRYPTO_dbg_malloc+2Ej
		pop	edi

loc_305:				; CODE XREF: _CRYPTO_dbg_malloc+14j
		add	esp, 1Ch
		retn
_CRYPTO_dbg_malloc endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 30Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_dbg_realloc
_CRYPTO_dbg_realloc proc near

var_30		= dword	ptr -30h
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	eax, 30h ; '0'
		call	__chkstk
		sub	[esp+30h+arg_14], 1
		jnz	loc_408
		push	esi
		mov	esi, [esp+34h+arg_4]
		test	esi, esi
		jz	loc_407
		push	edi
		mov	edi, [esp+38h+arg_0]
		test	edi, edi
		jnz	short loc_357
		push	81h ; ''
		push	[esp+3Ch+arg_10]
		push	[esp+40h+arg_C]
		push	[esp+44h+arg_8]
		push	esi
		call	_CRYPTO_dbg_malloc
		add	esp, 14h
		pop	edi
		pop	esi
		add	esp, 30h
		retn
; ---------------------------------------------------------------------------

loc_357:				; CODE XREF: _CRYPTO_dbg_realloc+29j
		call	_CRYPTO_is_mem_check_on
		test	eax, eax
		jz	loc_406
		push	3
		call	_CRYPTO_mem_ctrl
		lea	eax, [esp+3Ch+var_30]
		mov	[esp+3Ch+var_30], edi
		push	eax
		push	ds:_mh
		call	_lh_delete
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_39E
		mov	ecx, [esp+38h+arg_8]
		push	eax
		push	ds:_mh
		mov	[eax], esi
		mov	[eax+4], ecx
		call	_lh_insert
		add	esp, 8

loc_39E:				; CODE XREF: _CRYPTO_dbg_realloc+78j
		push	0D4h ; 'Ô'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_mh_mode
		add	esp, 10h
		test	al, 1
		jz	short loc_3F0
		mov	ecx, ds:_num_disable
		test	ecx, ecx
		jz	short loc_3F0
		sub	ecx, 1
		mov	ds:_num_disable, ecx
		jnz	short loc_3F0
		push	109h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		or	eax, 2
		push	1Bh
		push	0Ah
		mov	ds:_mh_mode, eax
		call	_CRYPTO_lock
		add	esp, 10h

loc_3F0:				; CODE XREF: _CRYPTO_dbg_realloc+AFj
					; _CRYPTO_dbg_realloc+B9j ...
		push	112h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h

loc_406:				; CODE XREF: _CRYPTO_dbg_realloc+52j
		pop	edi

loc_407:				; CODE XREF: _CRYPTO_dbg_realloc+1Cj
		pop	esi

loc_408:				; CODE XREF: _CRYPTO_dbg_realloc+Fj
		add	esp, 30h
		retn
_CRYPTO_dbg_realloc endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 40Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_dbg_set_options
_CRYPTO_dbg_set_options	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	ds:_options, eax
		retn
_CRYPTO_dbg_set_options	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 418h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_is_mem_check_on
_CRYPTO_is_mem_check_on	proc near	; CODE XREF: _CRYPTO_dbg_free+22p
					; _CRYPTO_dbg_malloc+27p ...

var_8		= byte ptr -8

		mov	eax, 8
		call	__chkstk
		test	byte ptr ds:_mh_mode, 1
		jz	short loc_490
		lea	eax, [esp+8+var_8]
		push	esi
		push	eax
		call	_CRYPTO_THREADID_current
		push	11Dh
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	5
		call	_CRYPTO_lock
		add	esp, 14h
		test	byte ptr ds:_mh_mode, 2
		jnz	short loc_46E
		lea	eax, [esp+0Ch+var_8]
		push	eax
		push	offset _disabling_threadid
		call	_CRYPTO_THREADID_cmp
		add	esp, 8
		test	eax, eax
		jnz	short loc_46E
		xor	esi, esi
		jmp	short loc_473
; ---------------------------------------------------------------------------

loc_46E:				; CODE XREF: _CRYPTO_is_mem_check_on+3Aj
					; _CRYPTO_is_mem_check_on+50j
		mov	esi, 1

loc_473:				; CODE XREF: _CRYPTO_is_mem_check_on+54j
		push	122h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	6
		call	_CRYPTO_lock
		add	esp, 10h
		mov	eax, esi
		pop	esi
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_490:				; CODE XREF: _CRYPTO_is_mem_check_on+11j
		xor	eax, eax
		add	esp, 8
		retn
_CRYPTO_is_mem_check_on	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 498h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_mem_ctrl
_CRYPTO_mem_ctrl proc near		; CODE XREF: _CRYPTO_dbg_free+3Ep
					; _CRYPTO_dbg_malloc+37p ...

var_8		= byte ptr -8
arg_0		= dword	ptr  4

		mov	eax, 8
		call	__chkstk
		push	esi
		mov	esi, ds:_mh_mode
		push	0D4h ; 'Ô'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	9
		call	_CRYPTO_lock
		mov	eax, [esp+1Ch+arg_0]
		add	esp, 10h
		cmp	eax, 3		; switch 4 cases
		ja	loc_5D4		; jumptable 000004CC default case
		jmp	ds:$LN17[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN4:					; CODE XREF: _CRYPTO_mem_ctrl+34j
					; DATA XREF: .text$mn:$LN17o
		mov	ds:_mh_mode, 3	; jumptable 000004CC case 1
		mov	ds:_num_disable, 0
		jmp	loc_5D4		; jumptable 000004CC default case
; ---------------------------------------------------------------------------

$LN5:					; CODE XREF: _CRYPTO_mem_ctrl+34j
					; DATA XREF: .text$mn:$LN17o
		mov	ds:_mh_mode, 0	; jumptable 000004CC case 0
		mov	ds:_num_disable, 0
		jmp	loc_5D4		; jumptable 000004CC default case
; ---------------------------------------------------------------------------

$LN6:					; CODE XREF: _CRYPTO_mem_ctrl+34j
					; DATA XREF: .text$mn:$LN17o
		test	byte ptr ds:_mh_mode, 1	; jumptable 000004CC case 3
		jz	loc_5D4		; jumptable 000004CC default case
		lea	eax, [esp+0Ch+var_8]
		push	eax
		call	_CRYPTO_THREADID_current
		add	esp, 4
		cmp	ds:_num_disable, 0
		jz	short loc_53E
		lea	eax, [esp+0Ch+var_8]
		push	eax
		push	offset _disabling_threadid
		call	_CRYPTO_THREADID_cmp
		add	esp, 8
		test	eax, eax
		jz	short loc_590

loc_53E:				; CODE XREF: _CRYPTO_mem_ctrl+8Ej
		push	0F4h ; 'ô'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	0Ah
		call	_CRYPTO_lock
		push	0FBh ; 'û'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	1Bh
		push	9
		call	_CRYPTO_lock
		push	0FCh ; 'ü'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	9
		call	_CRYPTO_lock
		and	ds:_mh_mode, 0FFFFFFFDh
		lea	eax, [esp+3Ch+var_8]
		push	eax
		push	offset _disabling_threadid
		call	_CRYPTO_THREADID_cpy
		add	esp, 38h

loc_590:				; CODE XREF: _CRYPTO_mem_ctrl+A4j
		inc	ds:_num_disable
		jmp	short loc_5D4	; jumptable 000004CC default case
; ---------------------------------------------------------------------------

$LN10:					; CODE XREF: _CRYPTO_mem_ctrl+34j
					; DATA XREF: .text$mn:$LN17o
		mov	eax, ds:_mh_mode ; jumptable 000004CC case 2
		test	al, 1
		jz	short loc_5D4	; jumptable 000004CC default case
		mov	ecx, ds:_num_disable
		test	ecx, ecx
		jz	short loc_5D4	; jumptable 000004CC default case
		sub	ecx, 1
		mov	ds:_num_disable, ecx
		jnz	short loc_5D4	; jumptable 000004CC default case
		push	109h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		or	eax, 2
		push	1Bh
		push	0Ah
		mov	ds:_mh_mode, eax
		call	_CRYPTO_lock
		add	esp, 10h

loc_5D4:				; CODE XREF: _CRYPTO_mem_ctrl+2Ej
					; _CRYPTO_mem_ctrl+4Fj	...
		push	112h		; jumptable 000004CC default case
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h
		mov	eax, esi
		pop	esi
		add	esp, 8
		retn
_CRYPTO_mem_ctrl endp

; ---------------------------------------------------------------------------
		align 4
$LN17		dd offset $LN5		; DATA XREF: _CRYPTO_mem_ctrl+34r
		dd offset $LN4		; jump table for switch	statement
		dd offset $LN10
		dd offset $LN6
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 604h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_mem_leaks
_CRYPTO_mem_leaks proc near		; CODE XREF: _CRYPTO_mem_leaks_fp+158p

var_14		= byte ptr -14h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 14h
		call	__chkstk
		cmp	ds:_mh,	0
		jnz	short loc_624
		cmp	ds:_amih, 0
		jz	loc_826

loc_624:				; CODE XREF: _CRYPTO_mem_leaks+11j
		push	0D4h ; 'Ô'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	9
		call	_CRYPTO_lock
		add	esp, 10h
		test	byte ptr ds:_mh_mode, 1
		jz	loc_6C9
		lea	eax, [esp+14h+var_14]
		push	eax
		call	_CRYPTO_THREADID_current
		add	esp, 4
		cmp	ds:_num_disable, 0
		jz	short loc_671
		lea	eax, [esp+14h+var_14]
		push	eax
		push	offset _disabling_threadid
		call	_CRYPTO_THREADID_cmp
		add	esp, 8
		test	eax, eax
		jz	short loc_6C3

loc_671:				; CODE XREF: _CRYPTO_mem_leaks+56j
		push	0F4h ; 'ô'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	0Ah
		call	_CRYPTO_lock
		push	0FBh ; 'û'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	1Bh
		push	9
		call	_CRYPTO_lock
		push	0FCh ; 'ü'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	9
		call	_CRYPTO_lock
		and	ds:_mh_mode, 0FFFFFFFDh
		lea	eax, [esp+44h+var_14]
		push	eax
		push	offset _disabling_threadid
		call	_CRYPTO_THREADID_cpy
		add	esp, 38h

loc_6C3:				; CODE XREF: _CRYPTO_mem_leaks+6Bj
		inc	ds:_num_disable

loc_6C9:				; CODE XREF: _CRYPTO_mem_leaks+3Dj
		push	esi
		push	112h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	0Ah
		call	_CRYPTO_lock
		mov	eax, ds:_mh
		add	esp, 10h
		mov	esi, [esp+18h+arg_0]
		mov	[esp+18h+var_C], esi
		mov	[esp+18h+var_4], 0
		mov	[esp+18h+var_8], 0
		test	eax, eax
		jz	short loc_731
		lea	ecx, [esp+18h+var_C]
		push	ecx
		push	offset _print_leak_LHASH_DOALL_ARG
		push	eax
		call	_lh_doall_arg
		mov	eax, [esp+24h+var_8]
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_731
		push	eax
		push	[esp+1Ch+var_4]
		push	offset ??_C@_0BP@JOECODN@?$CFld?5bytes?5leaked?5in?5?$CFd?5chunks?6?$AA@ ; "%ld	bytes leaked in	%d chunks\n"
		push	esi
		call	_BIO_printf
		jmp	loc_7BA
; ---------------------------------------------------------------------------

loc_731:				; CODE XREF: _CRYPTO_mem_leaks+FBj
					; _CRYPTO_mem_leaks+116j
		push	2EBh
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_mh
		add	esp, 10h
		mov	esi, ds:_mh_mode
		mov	ds:_mh_mode, 0
		test	eax, eax
		jz	short loc_773
		push	eax
		call	_lh_free
		add	esp, 4
		mov	ds:_mh,	0

loc_773:				; CODE XREF: _CRYPTO_mem_leaks+15Aj
		mov	eax, ds:_amih
		test	eax, eax
		jz	short loc_7A1
		push	eax
		call	_lh_num_items
		add	esp, 4
		test	eax, eax
		jnz	short loc_7A1
		push	ds:_amih
		call	_lh_free
		add	esp, 4
		mov	ds:_amih, 0

loc_7A1:				; CODE XREF: _CRYPTO_mem_leaks+176j
					; _CRYPTO_mem_leaks+183j
		push	300h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	0Ah
		mov	ds:_mh_mode, esi
		call	_CRYPTO_lock

loc_7BA:				; CODE XREF: _CRYPTO_mem_leaks+128j
		add	esp, 10h
		push	0D4h ; 'Ô'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_mh_mode
		add	esp, 10h
		pop	esi
		test	al, 1
		jz	short loc_810
		mov	ecx, ds:_num_disable
		test	ecx, ecx
		jz	short loc_810
		sub	ecx, 1
		mov	ds:_num_disable, ecx
		jnz	short loc_810
		push	109h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		or	eax, 2
		push	1Bh
		push	0Ah
		mov	ds:_mh_mode, eax
		call	_CRYPTO_lock
		add	esp, 10h

loc_810:				; CODE XREF: _CRYPTO_mem_leaks+1D7j
					; _CRYPTO_mem_leaks+1E1j ...
		push	112h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h

loc_826:				; CODE XREF: _CRYPTO_mem_leaks+1Aj
		add	esp, 14h
		retn
_CRYPTO_mem_leaks endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 82Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_mem_leaks_cb
_CRYPTO_mem_leaks_cb proc near

arg_0		= byte ptr  4

		cmp	ds:_mh,	0
		jz	short locret_873
		push	33Ah
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	1Bh
		push	9
		call	_CRYPTO_lock
		lea	eax, [esp+10h+arg_0]
		push	eax
		push	offset _cb_leak_LHASH_DOALL_ARG
		push	ds:_mh
		call	_lh_doall_arg
		push	33Dh
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	1Bh
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 2Ch

locret_873:				; CODE XREF: _CRYPTO_mem_leaks_cb+7j
		retn
_CRYPTO_mem_leaks_cb endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 874h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_mem_leaks_fp
_CRYPTO_mem_leaks_fp proc near

var_8		= byte ptr -8
arg_0		= dword	ptr  4

		mov	eax, 8
		call	__chkstk
		cmp	ds:_mh,	0
		jz	loc_9DB
		push	0D4h ; 'Ô'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	9
		call	_CRYPTO_lock
		add	esp, 10h
		test	byte ptr ds:_mh_mode, 1
		jz	loc_930
		lea	eax, [esp+8+var_8]
		push	eax
		call	_CRYPTO_THREADID_current
		add	esp, 4
		cmp	ds:_num_disable, 0
		jz	short loc_8D8
		lea	eax, [esp+8+var_8]
		push	eax
		push	offset _disabling_threadid
		call	_CRYPTO_THREADID_cmp
		add	esp, 8
		test	eax, eax
		jz	short loc_92A

loc_8D8:				; CODE XREF: _CRYPTO_mem_leaks_fp+4Dj
		push	0F4h ; 'ô'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	0Ah
		call	_CRYPTO_lock
		push	0FBh ; 'û'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	1Bh
		push	9
		call	_CRYPTO_lock
		push	0FCh ; 'ü'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	9
		call	_CRYPTO_lock
		and	ds:_mh_mode, 0FFFFFFFDh
		lea	eax, [esp+38h+var_8]
		push	eax
		push	offset _disabling_threadid
		call	_CRYPTO_THREADID_cpy
		add	esp, 38h

loc_92A:				; CODE XREF: _CRYPTO_mem_leaks_fp+62j
		inc	ds:_num_disable

loc_930:				; CODE XREF: _CRYPTO_mem_leaks_fp+34j
		push	esi
		push	112h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	0Ah
		call	_CRYPTO_lock
		call	_BIO_s_file
		push	eax
		call	_BIO_new
		push	0D4h ; 'Ô'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	9
		mov	esi, eax
		call	_CRYPTO_lock
		mov	eax, ds:_mh_mode
		add	esp, 24h
		test	al, 1
		jz	short loc_9A3
		mov	ecx, ds:_num_disable
		test	ecx, ecx
		jz	short loc_9A3
		sub	ecx, 1
		mov	ds:_num_disable, ecx
		jnz	short loc_9A3
		push	109h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		or	eax, 2
		push	1Bh
		push	0Ah
		mov	ds:_mh_mode, eax
		call	_CRYPTO_lock
		add	esp, 10h

loc_9A3:				; CODE XREF: _CRYPTO_mem_leaks_fp+FAj
					; _CRYPTO_mem_leaks_fp+104j ...
		push	112h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h
		test	esi, esi
		jz	short loc_9DA
		push	[esp+0Ch+arg_0]
		push	0
		push	6Ah ; 'j'
		push	esi
		call	_BIO_ctrl
		push	esi
		call	_CRYPTO_mem_leaks
		push	esi
		call	_BIO_free
		add	esp, 18h

loc_9DA:				; CODE XREF: _CRYPTO_mem_leaks_fp+147j
		pop	esi

loc_9DB:				; CODE XREF: _CRYPTO_mem_leaks_fp+11j
		add	esp, 8
		retn
_CRYPTO_mem_leaks_fp endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 9E0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_pop_info
_CRYPTO_pop_info proc near

var_8		= byte ptr -8

		mov	eax, 8
		call	__chkstk
		call	_CRYPTO_is_mem_check_on
		test	eax, eax
		jz	loc_B2A
		push	0D4h ; 'Ô'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	9
		call	_CRYPTO_lock
		add	esp, 10h
		test	byte ptr ds:_mh_mode, 1
		jz	loc_A9C
		lea	eax, [esp+8+var_8]
		push	eax
		call	_CRYPTO_THREADID_current
		add	esp, 4
		cmp	ds:_num_disable, 0
		jz	short loc_A44
		lea	eax, [esp+8+var_8]
		push	eax
		push	offset _disabling_threadid
		call	_CRYPTO_THREADID_cmp
		add	esp, 8
		test	eax, eax
		jz	short loc_A96

loc_A44:				; CODE XREF: _CRYPTO_pop_info+4Dj
		push	0F4h ; 'ô'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	0Ah
		call	_CRYPTO_lock
		push	0FBh ; 'û'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	1Bh
		push	9
		call	_CRYPTO_lock
		push	0FCh ; 'ü'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	9
		call	_CRYPTO_lock
		and	ds:_mh_mode, 0FFFFFFFDh
		lea	eax, [esp+38h+var_8]
		push	eax
		push	offset _disabling_threadid
		call	_CRYPTO_THREADID_cpy
		add	esp, 38h

loc_A96:				; CODE XREF: _CRYPTO_pop_info+62j
		inc	ds:_num_disable

loc_A9C:				; CODE XREF: _CRYPTO_pop_info+34j
		push	esi
		push	112h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	0Ah
		call	_CRYPTO_lock
		call	_pop_info
		push	0D4h ; 'Ô'
		neg	eax
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		sbb	esi, esi
		push	14h
		push	9
		neg	esi
		call	_CRYPTO_lock
		mov	eax, ds:_mh_mode
		add	esp, 20h
		test	al, 1
		jz	short loc_B0D
		mov	ecx, ds:_num_disable
		test	ecx, ecx
		jz	short loc_B0D
		sub	ecx, 1
		mov	ds:_num_disable, ecx
		jnz	short loc_B0D
		push	109h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		or	eax, 2
		push	1Bh
		push	0Ah
		mov	ds:_mh_mode, eax
		call	_CRYPTO_lock
		add	esp, 10h

loc_B0D:				; CODE XREF: _CRYPTO_pop_info+F8j
					; _CRYPTO_pop_info+102j ...
		push	112h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h
		mov	eax, esi
		pop	esi
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_B2A:				; CODE XREF: _CRYPTO_pop_info+11j
		xor	eax, eax
		add	esp, 8
		retn
_CRYPTO_pop_info endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B30h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_push_info_
_CRYPTO_push_info_ proc	near

var_8		= byte ptr -8
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 8
		call	__chkstk
		call	_CRYPTO_is_mem_check_on
		test	eax, eax
		jz	loc_CF1
		push	0D4h ; 'Ô'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	9
		call	_CRYPTO_lock
		add	esp, 10h
		test	byte ptr ds:_mh_mode, 1
		jz	loc_BEC
		lea	eax, [esp+8+var_8]
		push	eax
		call	_CRYPTO_THREADID_current
		add	esp, 4
		cmp	ds:_num_disable, 0
		jz	short loc_B94
		lea	eax, [esp+8+var_8]
		push	eax
		push	offset _disabling_threadid
		call	_CRYPTO_THREADID_cmp
		add	esp, 8
		test	eax, eax
		jz	short loc_BE6

loc_B94:				; CODE XREF: _CRYPTO_push_info_+4Dj
		push	0F4h ; 'ô'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	0Ah
		call	_CRYPTO_lock
		push	0FBh ; 'û'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	1Bh
		push	9
		call	_CRYPTO_lock
		push	0FCh ; 'ü'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	9
		call	_CRYPTO_lock
		and	ds:_mh_mode, 0FFFFFFFDh
		lea	eax, [esp+38h+var_8]
		push	eax
		push	offset _disabling_threadid
		call	_CRYPTO_THREADID_cpy
		add	esp, 38h

loc_BE6:				; CODE XREF: _CRYPTO_push_info_+62j
		inc	ds:_num_disable

loc_BEC:				; CODE XREF: _CRYPTO_push_info_+34j
		push	esi
		push	112h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	0Ah
		call	_CRYPTO_lock
		push	18Dh
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	1Ch
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 1Ch
		test	esi, esi
		jz	short $err$40
		cmp	ds:_amih, 0
		jnz	short loc_C49
		push	offset _app_info_LHASH_COMP
		push	offset _app_info_LHASH_HASH
		call	_lh_new
		add	esp, 8
		mov	ds:_amih, eax
		test	eax, eax
		jnz	short loc_C49
		push	esi
		call	_CRYPTO_free
		add	esp, 4
		jmp	short $err$40
; ---------------------------------------------------------------------------

loc_C49:				; CODE XREF: _CRYPTO_push_info_+F1j
					; _CRYPTO_push_info_+10Cj
		push	esi
		call	_CRYPTO_THREADID_current
		mov	eax, [esp+10h+arg_4]
		mov	[esi+8], eax
		mov	eax, [esp+10h+arg_8]
		push	esi
		push	ds:_amih
		mov	[esi+0Ch], eax
		mov	eax, [esp+18h+arg_0]
		mov	[esi+10h], eax
		mov	dword ptr [esi+18h], 1
		mov	dword ptr [esi+14h], 0
		call	_lh_insert
		add	esp, 0Ch
		test	eax, eax
		jz	short $err$40
		mov	[esi+14h], eax

$err$40:				; CODE XREF: _CRYPTO_push_info_+E8j
					; _CRYPTO_push_info_+117j ...
		push	0D4h ; 'Ô'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_mh_mode
		add	esp, 10h
		pop	esi
		test	al, 1
		jz	short loc_CDB
		mov	ecx, ds:_num_disable
		test	ecx, ecx
		jz	short loc_CDB
		sub	ecx, 1
		mov	ds:_num_disable, ecx
		jnz	short loc_CDB
		push	109h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		or	eax, 2
		push	1Bh
		push	0Ah
		mov	ds:_mh_mode, eax
		call	_CRYPTO_lock
		add	esp, 10h

loc_CDB:				; CODE XREF: _CRYPTO_push_info_+176j
					; _CRYPTO_push_info_+180j ...
		push	112h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h

loc_CF1:				; CODE XREF: _CRYPTO_push_info_+11j
		xor	eax, eax
		add	esp, 8
		retn
_CRYPTO_push_info_ endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0CF8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _CRYPTO_remove_all_info
_CRYPTO_remove_all_info	proc near

var_24		= byte ptr -24h
var_1C		= byte ptr -1Ch

		mov	eax, 24h ; '$'
		call	__chkstk
		push	ebx
		xor	ebx, ebx
		call	_CRYPTO_is_mem_check_on
		test	eax, eax
		jz	loc_EAA
		push	0D4h ; 'Ô'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	9
		call	_CRYPTO_lock
		add	esp, 10h
		test	byte ptr ds:_mh_mode, 1
		jz	loc_DB8
		lea	eax, [esp+28h+var_24]
		push	eax
		call	_CRYPTO_THREADID_current
		add	esp, 4
		cmp	ds:_num_disable, ebx
		jz	short loc_D60
		lea	eax, [esp+28h+var_24]
		push	eax
		push	offset _disabling_threadid
		call	_CRYPTO_THREADID_cmp
		add	esp, 8
		test	eax, eax
		jz	short loc_DB2

loc_D60:				; CODE XREF: _CRYPTO_remove_all_info+50j
		push	0F4h ; 'ô'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	0Ah
		call	_CRYPTO_lock
		push	0FBh ; 'û'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	1Bh
		push	9
		call	_CRYPTO_lock
		push	0FCh ; 'ü'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	9
		call	_CRYPTO_lock
		and	ds:_mh_mode, 0FFFFFFFDh
		lea	eax, [esp+58h+var_24]
		push	eax
		push	offset _disabling_threadid
		call	_CRYPTO_THREADID_cpy
		add	esp, 38h

loc_DB2:				; CODE XREF: _CRYPTO_remove_all_info+66j
		inc	ds:_num_disable

loc_DB8:				; CODE XREF: _CRYPTO_remove_all_info+37j
		push	112h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h
		push	esi
		push	edi
		nop	dword ptr [eax+eax+00000000h]

loc_DD8:				; CODE XREF: _CRYPTO_remove_all_info+146j
		cmp	ds:_amih, 0
		jz	short loc_E40
		lea	eax, [esp+30h+var_1C]
		push	eax
		call	_CRYPTO_THREADID_current
		lea	eax, [esp+34h+var_1C]
		push	eax
		push	ds:_amih
		call	_lh_delete
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jz	short loc_E40
		mov	esi, [edi+14h]
		test	esi, esi
		jz	short loc_E1D
		inc	dword ptr [esi+18h]
		push	esi
		push	ds:_amih
		call	_lh_insert
		add	esp, 8

loc_E1D:				; CODE XREF: _CRYPTO_remove_all_info+111j
		dec	dword ptr [edi+18h]
		cmp	dword ptr [edi+18h], 0
		jg	short loc_E3D
		mov	dword ptr [edi+14h], 0
		test	esi, esi
		jz	short loc_E34
		dec	dword ptr [esi+18h]

loc_E34:				; CODE XREF: _CRYPTO_remove_all_info+137j
		push	edi
		call	_CRYPTO_free
		add	esp, 4

loc_E3D:				; CODE XREF: _CRYPTO_remove_all_info+12Cj
		inc	ebx
		jmp	short loc_DD8
; ---------------------------------------------------------------------------

loc_E40:				; CODE XREF: _CRYPTO_remove_all_info+E7j
					; _CRYPTO_remove_all_info+10Aj
		push	0D4h ; 'Ô'
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	9
		call	_CRYPTO_lock
		mov	eax, ds:_mh_mode
		add	esp, 10h
		pop	edi
		pop	esi
		test	al, 1
		jz	short loc_E94
		mov	ecx, ds:_num_disable
		test	ecx, ecx
		jz	short loc_E94
		sub	ecx, 1
		mov	ds:_num_disable, ecx
		jnz	short loc_E94
		push	109h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		or	eax, 2
		push	1Bh
		push	0Ah
		mov	ds:_mh_mode, eax
		call	_CRYPTO_lock
		add	esp, 10h

loc_E94:				; CODE XREF: _CRYPTO_remove_all_info+167j
					; _CRYPTO_remove_all_info+171j	...
		push	112h
		push	offset ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ ;	".\\crypto\\mem_dbg.c"
		push	14h
		push	0Ah
		call	_CRYPTO_lock
		add	esp, 10h

loc_EAA:				; CODE XREF: _CRYPTO_remove_all_info+14j
		mov	eax, ebx
		pop	ebx
		add	esp, 24h
		retn
_CRYPTO_remove_all_info	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0EB4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_app_info_LHASH_COMP proc near		; DATA XREF: _CRYPTO_push_info_+F3o
		jmp	_CRYPTO_THREADID_cmp
_app_info_LHASH_COMP endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0EBCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_app_info_LHASH_HASH proc near		; DATA XREF: _CRYPTO_push_info_+F8o

arg_0		= dword	ptr  4

		push	esi
		push	[esp+4+arg_0]
		call	_CRYPTO_THREADID_hash
		mov	esi, eax
		add	esp, 4
		mov	edx, esi
		mov	ecx, esi
		shr	ecx, 4
		shr	edx, 0Eh
		imul	eax, ecx, 0FBh
		lea	ecx, ds:0[edx*8]
		sub	ecx, edx
		add	eax, ecx
		imul	ecx, esi, 45BBh
		pop	esi
		add	eax, ecx
		retn
_app_info_LHASH_HASH endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0EF0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_app_info_cmp	proc near
		jmp	_CRYPTO_THREADID_cmp
_app_info_cmp	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0EF8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_app_info_free	proc near		; CODE XREF: _CRYPTO_dbg_free+68p
					; _app_info_free+16p

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		dec	dword ptr [esi+18h]
		cmp	dword ptr [esi+18h], 0
		jg	short loc_F1F
		mov	eax, [esi+14h]
		test	eax, eax
		jz	short loc_F16
		push	eax
		call	_app_info_free
		add	esp, 4

loc_F16:				; CODE XREF: _app_info_free+13j
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_F1F:				; CODE XREF: _app_info_free+Cj
		pop	esi
		retn
_app_info_free	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F24h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_app_info_hash	proc near

arg_0		= dword	ptr  4

		push	esi
		push	[esp+4+arg_0]
		call	_CRYPTO_THREADID_hash
		mov	esi, eax
		add	esp, 4
		mov	edx, esi
		mov	ecx, esi
		shr	ecx, 4
		shr	edx, 0Eh
		imul	eax, ecx, 0FBh
		lea	ecx, ds:0[edx*8]
		sub	ecx, edx
		add	eax, ecx
		imul	ecx, esi, 45BBh
		pop	esi
		add	eax, ecx
		retn
_app_info_hash	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F58h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_cb_leak_LHASH_DOALL_ARG proc near	; DATA XREF: _CRYPTO_mem_leaks_cb+21o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		push	dword ptr [eax]
		push	dword ptr [eax+4]
		push	dword ptr [eax+0Ch]
		push	dword ptr [eax+8]
		push	dword ptr [eax+18h]
		mov	eax, [esp+14h+arg_4]
		mov	eax, [eax]
		call	eax
		add	esp, 14h
		retn
_cb_leak_LHASH_DOALL_ARG endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F78h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_cb_leak_doall_arg proc	near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		push	dword ptr [eax]
		push	dword ptr [eax+4]
		push	dword ptr [eax+0Ch]
		push	dword ptr [eax+8]
		push	dword ptr [eax+18h]
		mov	eax, [esp+14h+arg_4]
		mov	eax, [eax]
		call	eax
		add	esp, 14h
		retn
_cb_leak_doall_arg endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0F98h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; struct tm *__cdecl static localtime(const time_t *Time)
_localtime	proc near
		jmp	dword ptr ds:__imp___localtime64
_localtime	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0FA0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_mem_LHASH_COMP	proc near		; DATA XREF: _CRYPTO_dbg_malloc+80o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	eax, [eax]
		sub	eax, [ecx]
		retn
_mem_LHASH_COMP	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0FB0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_mem_LHASH_HASH	proc near		; DATA XREF: _CRYPTO_dbg_malloc+85o

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		push	esi
		mov	esi, [eax]
		mov	edx, esi
		mov	eax, esi
		shr	edx, 0Eh
		shr	eax, 4
		imul	eax, 0FBh
		lea	ecx, ds:0[edx*8]
		sub	ecx, edx
		add	eax, ecx
		imul	ecx, esi, 45BBh
		pop	esi
		add	eax, ecx
		retn
_mem_LHASH_HASH	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0FDCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_mem_cmp	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		mov	eax, [eax]
		sub	eax, [ecx]
		retn
_mem_cmp	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0FECh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_mem_hash	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		push	esi
		mov	esi, [eax]
		mov	edx, esi
		mov	eax, esi
		shr	edx, 0Eh
		shr	eax, 4
		imul	eax, 0FBh
		lea	ecx, ds:0[edx*8]
		sub	ecx, edx
		add	eax, ecx
		imul	ecx, esi, 45BBh
		pop	esi
		add	eax, ecx
		retn
_mem_hash	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1018h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_pop_info	proc near		; CODE XREF: _CRYPTO_pop_info+D0p

var_1C		= byte ptr -1Ch

		mov	eax, 1Ch
		call	__chkstk
		cmp	ds:_amih, 0
		jz	short loc_1090
		lea	eax, [esp+1Ch+var_1C]
		push	esi
		push	eax
		call	_CRYPTO_THREADID_current
		lea	eax, [esp+24h+var_1C]
		push	eax
		push	ds:_amih
		call	_lh_delete
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jz	short loc_108B
		push	edi
		mov	edi, [esi+14h]
		test	edi, edi
		jz	short loc_1068
		inc	dword ptr [edi+18h]
		push	edi
		push	ds:_amih
		call	_lh_insert
		add	esp, 8

loc_1068:				; CODE XREF: _pop_info+3Cj
		dec	dword ptr [esi+18h]
		cmp	dword ptr [esi+18h], 0
		jg	short loc_1088
		mov	dword ptr [esi+14h], 0
		test	edi, edi
		jz	short loc_107F
		dec	dword ptr [edi+18h]

loc_107F:				; CODE XREF: _pop_info+62j
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_1088:				; CODE XREF: _pop_info+57j
		mov	eax, esi
		pop	edi

loc_108B:				; CODE XREF: _pop_info+34j
		pop	esi
		add	esp, 1Ch
		retn
; ---------------------------------------------------------------------------

loc_1090:				; CODE XREF: _pop_info+11j
		xor	eax, eax
		add	esp, 1Ch
		retn
_pop_info	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1098h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_print_leak_LHASH_DOALL_ARG proc near	; DATA XREF: _CRYPTO_mem_leaks+102o
		jmp	_print_leak_doall_arg
_print_leak_LHASH_DOALL_ARG endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 10A0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_print_leak_doall_arg proc near		; CODE XREF: _print_leak_LHASH_DOALL_ARGj

var_410		= dword	ptr -410h
var_40C		= byte ptr -40Ch
Dst		= byte ptr -404h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 410h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+410h+var_4], eax
		push	ebx
		mov	ebx, [esp+414h+arg_4]
		push	esi
		push	edi
		mov	edi, [esp+41Ch+arg_0]
		lea	esi, [esp+41Ch+Dst]
		mov	[esp+41Ch+var_410], ebx
		mov	eax, [edi]
		cmp	eax, [ebx]
		jz	loc_12DA
		test	byte ptr ds:_options, 1
		jz	short loc_111F
		lea	eax, [edi+20h]
		push	eax		; Time
		call	dword ptr ds:__imp___localtime64
		push	dword ptr [eax]
		push	dword ptr [eax+4]
		push	dword ptr [eax+8]
		mov	eax, esi
		push	offset ??_C@_0BC@MALIEGMD@?$FL?$CF02d?3?$CF02d?3?$CF02d?$FN?5?$AA@ ; "[%02d:%02d:%02d] "
		push	400h
		push	eax
		call	_BIO_snprintf
		mov	ecx, esi
		add	esp, 1Ch
		lea	edx, [ecx+1]

loc_1110:				; CODE XREF: _print_leak_doall_arg+75j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_1110
		sub	ecx, edx
		lea	esi, [esp+41Ch+Dst]
		add	esi, ecx

loc_111F:				; CODE XREF: _print_leak_doall_arg+42j
		push	dword ptr [edi+0Ch]
		lea	eax, [esp+420h+var_4]
		push	dword ptr [edi+8]
		sub	eax, esi
		push	dword ptr [edi+18h]
		push	offset ??_C@_0BI@OFHOPHMO@?$CF5lu?5file?$DN?$CFs?0?5line?$DN?$CFd?0?5?$AA@ ; "%5lu file=%s, line=%d, "
		push	eax
		push	esi
		call	_BIO_snprintf
		mov	ecx, esi
		add	esp, 18h
		lea	edx, [ecx+1]

loc_1145:				; CODE XREF: _print_leak_doall_arg+AAj
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_1145
		sub	ecx, edx
		add	esi, ecx
		test	byte ptr ds:_options, 2
		jz	short loc_118B
		lea	eax, [edi+10h]
		push	eax
		call	_CRYPTO_THREADID_hash
		push	eax
		lea	eax, [esp+424h+var_4]
		push	offset ??_C@_0N@BAIEKLOK@thread?$DN?$CFlu?0?5?$AA@ ; "thread=%lu, "
		sub	eax, esi
		push	eax
		push	esi
		call	_BIO_snprintf
		mov	ecx, esi
		add	esp, 14h
		lea	edx, [ecx+1]

loc_1180:				; CODE XREF: _print_leak_doall_arg+E5j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_1180
		sub	ecx, edx
		add	esi, ecx

loc_118B:				; CODE XREF: _print_leak_doall_arg+B7j
		push	ebp
		push	dword ptr [edi]
		lea	eax, [esp+424h+var_4]
		push	dword ptr [edi+4]
		sub	eax, esi
		push	offset ??_C@_0BK@MHANPPFK@number?$DN?$CFd?0?5address?$DN?$CF08lX?6?$AA@	; "number=%d, address=%08lX\n"
		push	eax
		push	esi
		call	_BIO_snprintf
		lea	eax, [esp+434h+Dst]
		push	eax
		push	dword ptr [ebx]
		call	_BIO_puts
		inc	dword ptr [ebx+4]
		add	esp, 1Ch
		mov	eax, [edi+4]
		xor	ebp, ebp
		add	[ebx+8], eax
		mov	esi, [edi+28h]
		test	esi, esi
		jz	loc_12D9
		lea	eax, [esp+420h+var_40C]
		push	esi
		push	eax
		call	_CRYPTO_THREADID_cpy
		add	esp, 8
		nop	dword ptr [eax+00000000h]

loc_11E0:				; CODE XREF: _print_leak_doall_arg+233j
		inc	ebp
		lea	eax, [esp+420h+Dst]
		push	ebp		; Size
		push	3Eh ; '>'       ; Val
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch
		push	dword ptr [esi+0Ch]
		push	dword ptr [esi+8]
		push	esi
		call	_CRYPTO_THREADID_hash
		add	esp, 4
		push	eax
		mov	eax, 400h
		sub	eax, ebp
		push	offset ??_C@_0CG@LFPKBHEM@?5thread?$DN?$CFlu?0?5file?$DN?$CFs?0?5line?$DN?$CFd?0?5i@ ; " thread=%lu, file=%s, line=%d, info=\""
		push	eax
		lea	eax, [esp+434h+Dst]
		add	eax, ebp
		push	eax
		call	_BIO_snprintf
		lea	ecx, [esp+438h+Dst]
		add	esp, 18h
		lea	edx, [ecx+1]

loc_1224:				; CODE XREF: _print_leak_doall_arg+189j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_1224
		mov	edi, [esi+10h]
		sub	ecx, edx
		mov	edx, edi
		lea	ebx, [edx+1]

loc_1235:				; CODE XREF: _print_leak_doall_arg+19Aj
		mov	al, [edx]
		inc	edx
		test	al, al
		jnz	short loc_1235
		mov	eax, 7Dh ; '}'
		sub	edx, ebx
		sub	eax, ecx
		cmp	eax, edx
		jge	short loc_1268
		mov	eax, 7Dh ; '}'
		sub	eax, ecx
		push	eax		; Size
		lea	eax, [esp+424h+Dst]
		add	eax, ecx
		push	edi		; Src
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, 7Dh ; '}'
		jmp	short loc_1290
; ---------------------------------------------------------------------------

loc_1268:				; CODE XREF: _print_leak_doall_arg+1A7j
		mov	eax, 400h
		sub	eax, ecx
		push	eax
		lea	eax, [esp+424h+Dst]
		add	eax, ecx
		push	edi
		push	eax
		call	_BUF_strlcpy
		lea	eax, [esp+42Ch+Dst]
		add	esp, 0Ch
		lea	edx, [eax+1]

loc_1287:				; CODE XREF: _print_leak_doall_arg+1ECj
		mov	cl, [eax]
		inc	eax
		test	cl, cl
		jnz	short loc_1287
		sub	eax, edx

loc_1290:				; CODE XREF: _print_leak_doall_arg+1C6j
		mov	ecx, 400h
		sub	ecx, eax
		push	offset ??_C@_02MBJIFMOJ@?$CC?6?$AA@ ; `string'
		push	ecx
		lea	ecx, [esp+428h+Dst]
		add	eax, ecx
		push	eax
		call	_BIO_snprintf
		lea	eax, [esp+42Ch+Dst]
		push	eax
		mov	eax, [esp+430h+var_410]
		push	dword ptr [eax]
		call	_BIO_puts
		mov	esi, [esi+14h]
		add	esp, 14h
		test	esi, esi
		jz	short loc_12D9
		lea	eax, [esp+420h+var_40C]
		push	eax
		push	esi
		call	_CRYPTO_THREADID_cmp
		add	esp, 8
		test	eax, eax
		jz	loc_11E0

loc_12D9:				; CODE XREF: _print_leak_doall_arg+125j
					; _print_leak_doall_arg+221j
		pop	ebp

loc_12DA:				; CODE XREF: _print_leak_doall_arg+35j
		mov	ecx, [esp+41Ch+var_4]
		pop	edi
		pop	esi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 410h
		retn
_print_leak_doall_arg endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 12F4h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; time_t __cdecl static	time(time_t *Time)
_time		proc near
		jmp	dword ptr ds:__imp___time64
_time		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 12FCh
; COMDAT (pick any)
		public ??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@
; `string'
??_C@_0BD@KJPFNPNE@?4?2crypto?2mem_dbg?4c?$AA@ db '.\crypto\mem_dbg.c',0
					; DATA XREF: _CRYPTO_dbg_free+7Eo
					; _CRYPTO_dbg_free+B2o	...
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1310h
; COMDAT (pick any)
		public ??_C@_0BC@MALIEGMD@?$FL?$CF02d?3?$CF02d?3?$CF02d?$FN?5?$AA@
; `string'
??_C@_0BC@MALIEGMD@?$FL?$CF02d?3?$CF02d?3?$CF02d?$FN?5?$AA@ db '[%02d:%02d:%02d] ',0
					; DATA XREF: _print_leak_doall_arg+58o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1324h
; COMDAT (pick any)
		public ??_C@_0BI@OFHOPHMO@?$CF5lu?5file?$DN?$CFs?0?5line?$DN?$CFd?0?5?$AA@
; `string'
??_C@_0BI@OFHOPHMO@?$CF5lu?5file?$DN?$CFs?0?5line?$DN?$CFd?0?5?$AA@ db '%5lu file=%s, line=%d, ',0
					; DATA XREF: _print_leak_doall_arg+91o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 133Ch
; COMDAT (pick any)
		public ??_C@_0N@BAIEKLOK@thread?$DN?$CFlu?0?5?$AA@
; `string'
??_C@_0N@BAIEKLOK@thread?$DN?$CFlu?0?5?$AA@ db 'thread=%lu, ',0
					; DATA XREF: _print_leak_doall_arg+CAo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 134Ch
; COMDAT (pick any)
		public ??_C@_0BK@MHANPPFK@number?$DN?$CFd?0?5address?$DN?$CF08lX?6?$AA@
; `string'
??_C@_0BK@MHANPPFK@number?$DN?$CFd?0?5address?$DN?$CF08lX?6?$AA@ db 'number=%d, address=%08lX',0Ah,0
					; DATA XREF: _print_leak_doall_arg+FAo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1368h
; COMDAT (pick any)
		public ??_C@_0CG@LFPKBHEM@?5thread?$DN?$CFlu?0?5file?$DN?$CFs?0?5line?$DN?$CFd?0?5i@
; `string'
??_C@_0CG@LFPKBHEM@?5thread?$DN?$CFlu?0?5file?$DN?$CFs?0?5line?$DN?$CFd?0?5i@ db ' thread=%lu, file=%s, line=%d, info="',0
					; DATA XREF: _print_leak_doall_arg+168o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1390h
; COMDAT (pick any)
		public ??_C@_02MBJIFMOJ@?$CC?6?$AA@
; `string'
??_C@_02MBJIFMOJ@?$CC?6?$AA@ db	22h, 0Ah, 0 ; DATA XREF: _print_leak_doall_arg+1F7o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1394h
; COMDAT (pick any)
		public ??_C@_0BP@JOECODN@?$CFld?5bytes?5leaked?5in?5?$CFd?5chunks?6?$AA@
; `string'
??_C@_0BP@JOECODN@?$CFld?5bytes?5leaked?5in?5?$CFd?5chunks?6?$AA@ db '%ld bytes leaked in %d chunks',0Ah,0
					; DATA XREF: _CRYPTO_mem_leaks+11Do
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; struct tm *__cdecl __localtime64(const __time64_t *Time)
		extrn __imp___localtime64:near ; CODE XREF: _print_leak_doall_arg+48p
					; DATA XREF: _localtimer ...
; __time64_t __cdecl __time64(__time64_t *Time)
		extrn __imp___time64:near ; CODE XREF: _CRYPTO_dbg_malloc+10Dp
					; DATA XREF: _CRYPTO_dbg_malloc+10Dr ...
		extrn _CRYPTO_lock:near	; CODE XREF: _CRYPTO_dbg_free+87p
					; _CRYPTO_dbg_free+C3p	...
		extrn _CRYPTO_THREADID_current:near ; CODE XREF: _CRYPTO_dbg_malloc+D5p
					; _CRYPTO_dbg_malloc+131p ...
		extrn _CRYPTO_THREADID_cmp:near	; CODE XREF: _CRYPTO_is_mem_check_on+46p
					; _CRYPTO_mem_ctrl+9Ap	...
		extrn _CRYPTO_THREADID_cpy:near	; CODE XREF: _CRYPTO_mem_ctrl+F0p
					; _CRYPTO_mem_leaks+B7p ...
		extrn _CRYPTO_THREADID_hash:near ; CODE	XREF: _app_info_LHASH_HASH+5p
					; _app_info_hash+5p ...
		extrn _CRYPTO_malloc:near ; CODE XREF: _CRYPTO_dbg_malloc+48p
					; _CRYPTO_push_info_+DCp
		extrn _CRYPTO_free:near	; CODE XREF: _CRYPTO_dbg_free+71p
					; _CRYPTO_dbg_malloc+57p ...
		extrn _BUF_strlcpy:near	; CODE XREF: _print_leak_doall_arg+1D8p
		extrn _BIO_s_file:near	; CODE XREF: _CRYPTO_mem_leaks_fp+D0p
		extrn _BIO_new:near	; CODE XREF: _CRYPTO_mem_leaks_fp+D6p
		extrn _BIO_free:near	; CODE XREF: _CRYPTO_mem_leaks_fp+15Ep
		extrn _BIO_puts:near	; CODE XREF: _print_leak_doall_arg+10Dp
					; _print_leak_doall_arg+214p
		extrn _BIO_ctrl:near	; CODE XREF: _CRYPTO_mem_leaks_fp+152p
		extrn _BIO_printf:near	; CODE XREF: _CRYPTO_mem_leaks+123p
		extrn _BIO_snprintf:near ; CODE	XREF: _print_leak_doall_arg+63p
					; _print_leak_doall_arg+98p ...
		extrn _lh_new:near	; CODE XREF: _CRYPTO_dbg_malloc+8Ap
					; _CRYPTO_push_info_+FDp
		extrn _lh_free:near	; CODE XREF: _CRYPTO_mem_leaks+15Dp
					; _CRYPTO_mem_leaks+18Bp
		extrn _lh_insert:near	; CODE XREF: _CRYPTO_dbg_malloc+168p
					; _CRYPTO_dbg_realloc+8Ap ...
		extrn _lh_delete:near	; CODE XREF: _CRYPTO_dbg_free+52p
					; _CRYPTO_dbg_realloc+6Ep ...
		extrn _lh_retrieve:near	; CODE XREF: _CRYPTO_dbg_malloc+14Fp
		extrn _lh_doall_arg:near ; CODE	XREF: _CRYPTO_mem_leaks+108p
					; _CRYPTO_mem_leaks_cb+2Cp
		extrn _lh_num_items:near ; CODE	XREF: _CRYPTO_mem_leaks+179p
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near
					; CODE XREF: _print_leak_doall_arg+246p
		extrn __chkstk:near	; CODE XREF: _CRYPTO_dbg_free+5p
					; _CRYPTO_dbg_malloc+5p ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _print_leak_doall_arg+1B9p
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _print_leak_doall_arg+149p
		extrn ___security_cookie:near ;	DATA XREF: _print_leak_doall_arg+Ar


		end
