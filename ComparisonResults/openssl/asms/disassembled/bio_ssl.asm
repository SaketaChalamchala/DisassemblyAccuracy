;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	6524CC53DE56DA26183ADD856663B770
; Input	CRC32 :	1169DF85

; File Name   :	C:\compspace\Diff\openssl\obj\bio_ssl.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssl_write	proc near		; DATA XREF: .data:000008A4o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx

; __time64_t Time
Time:					; DATA XREF: _ssl_write+7Eo
					; _ssl_read+7Eo
		push	ebp
		mov	ebp, [esp+8+arg_4]
		xor	ebx, ebx
		test	ebp, ebp
		jnz	short loc_11
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_11:					; CODE XREF: _ssl_write+Aj
		push	esi
		push	edi
		mov	edi, [esp+10h+arg_0]
		push	0Fh
		push	edi
		mov	esi, [edi+20h]
		mov	eax, [esi]
		mov	[esp+18h+arg_4], eax
		call	_BIO_clear_flags
		push	[esp+18h+arg_8]
		push	ebp
		push	[esp+20h+arg_4]
		call	_SSL_write
		mov	ebp, eax
		push	ebp
		push	[esp+28h+arg_4]
		call	_SSL_get_error
		add	esp, 1Ch
		cmp	eax, 7		; switch 8 cases
		ja	$LN15		; jumptable 0000004E default case
		jmp	ds:$LN23[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN5:					; CODE XREF: _ssl_write+4Ej
					; DATA XREF: .text$mn:$LN23o
		test	ebp, ebp	; jumptable 0000004E case 0
		jle	$LN15		; jumptable 0000004E default case
		mov	eax, [esi+8]
		test	eax, eax
		jz	short loc_85
		add	[esi+0Ch], ebp
		cmp	[esi+0Ch], eax
		jbe	short loc_85
		push	[esp+10h+arg_4]
		inc	dword ptr [esi+4]
		mov	[esi+0Ch], ebx
		call	_SSL_renegotiate
		add	esp, 4
		mov	eax, offset Time
		jmp	short loc_87
; ---------------------------------------------------------------------------

loc_85:					; CODE XREF: _ssl_write+62j
					; _ssl_write+6Aj
		xor	eax, eax

loc_87:					; CODE XREF: _ssl_write+83j
		cmp	[esi+10h], ebx
		jbe	$LN15		; jumptable 0000004E default case
		test	eax, eax
		jnz	$LN15		; jumptable 0000004E default case
		push	eax		; Time
		call	dword ptr ds:__imp___time64
		mov	ecx, [esi+14h]
		add	esp, 4
		add	ecx, [esi+10h]
		cmp	eax, ecx
		jbe	short $LN15	; jumptable 0000004E default case
		push	[esp+10h+arg_4]
		inc	dword ptr [esi+4]
		mov	[esi+14h], eax
		call	_SSL_renegotiate
		add	esp, 4
		mov	[edi+18h], ebx
		mov	eax, ebp
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN11:					; CODE XREF: _ssl_write+4Ej
					; DATA XREF: .text$mn:$LN23o
		push	0Ah		; jumptable 0000004E case 3
		push	edi
		call	_BIO_set_flags
		add	esp, 8
		mov	[edi+18h], ebx
		mov	eax, ebp
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN12:					; CODE XREF: _ssl_write+4Ej
					; DATA XREF: .text$mn:$LN23o
		push	9		; jumptable 0000004E case 2
		push	edi
		call	_BIO_set_flags
		add	esp, 8
		mov	[edi+18h], ebx
		mov	eax, ebp
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN13:					; CODE XREF: _ssl_write+4Ej
					; DATA XREF: .text$mn:$LN23o
		push	0Ch		; jumptable 0000004E case 4
		push	edi
		call	_BIO_set_flags
		add	esp, 8
		mov	ebx, 1
		mov	[edi+18h], ebx
		mov	eax, ebp
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN14:					; CODE XREF: _ssl_write+4Ej
					; DATA XREF: .text$mn:$LN23o
		push	0Ch		; jumptable 0000004E case 7
		push	edi
		call	_BIO_set_flags
		mov	ebx, 2
		add	esp, 8

$LN15:					; CODE XREF: _ssl_write+48j
					; _ssl_write+4Ej ...
		mov	[edi+18h], ebx	; jumptable 0000004E default case
		mov	eax, ebp
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_ssl_write	endp

; ---------------------------------------------------------------------------
		align 4
$LN23		dd offset $LN5		; DATA XREF: _ssl_write+4Er
		dd offset $LN15		; jump table for switch	statement
		dd offset $LN12
		dd offset $LN11
		dd offset $LN13
		dd offset $LN15
		dd offset $LN15
		dd offset $LN14
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 148h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssl_read	proc near		; DATA XREF: .data:000008A8o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	ebx
		push	ebp
		mov	ebp, [esp+8+arg_4]
		xor	ebx, ebx
		test	ebp, ebp
		jnz	short loc_159
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_159:				; CODE XREF: _ssl_read+Aj
		push	esi
		push	edi
		mov	edi, [esp+10h+arg_0]
		push	0Fh
		push	edi
		mov	esi, [edi+20h]
		mov	eax, [esi]
		mov	[esp+18h+arg_4], eax
		call	_BIO_clear_flags
		push	[esp+18h+arg_8]
		push	ebp
		push	[esp+20h+arg_4]
		call	_SSL_read
		mov	ebp, eax
		push	ebp
		push	[esp+28h+arg_4]
		call	_SSL_get_error
		add	esp, 1Ch
		cmp	eax, 8		; switch 9 cases
		ja	$LN16		; jumptable 00000196 default case
		jmp	ds:$LN24[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN5_0:					; CODE XREF: _ssl_read+4Ej
					; DATA XREF: .text$mn:$LN24o
		test	ebp, ebp	; jumptable 00000196 case 0
		jle	$LN16		; jumptable 00000196 default case
		mov	eax, [esi+8]
		test	eax, eax
		jz	short loc_1CD
		add	[esi+0Ch], ebp
		cmp	[esi+0Ch], eax
		jbe	short loc_1CD
		push	[esp+10h+arg_4]
		inc	dword ptr [esi+4]
		mov	[esi+0Ch], ebx
		call	_SSL_renegotiate
		add	esp, 4
		mov	eax, offset Time
		jmp	short loc_1CF
; ---------------------------------------------------------------------------

loc_1CD:				; CODE XREF: _ssl_read+62j
					; _ssl_read+6Aj
		xor	eax, eax

loc_1CF:				; CODE XREF: _ssl_read+83j
		cmp	[esi+10h], ebx
		jbe	$LN16		; jumptable 00000196 default case
		test	eax, eax
		jnz	$LN16		; jumptable 00000196 default case
		push	eax		; Time
		call	dword ptr ds:__imp___time64
		mov	ecx, [esi+14h]
		add	esp, 4
		add	ecx, [esi+10h]
		cmp	eax, ecx
		jbe	$LN16		; jumptable 00000196 default case
		push	[esp+10h+arg_4]
		inc	dword ptr [esi+4]
		mov	[esi+14h], eax
		call	_SSL_renegotiate

loc_207:				; DATA XREF: .data:_methods_sslpo
		add	esp, 4
		mov	[edi+18h], ebx
		mov	eax, ebp
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN11_0:				; CODE XREF: _ssl_read+4Ej
					; DATA XREF: .text$mn:$LN24o
		push	9		; jumptable 00000196 case 2
		push	edi
		call	_BIO_set_flags
		add	esp, 8
		mov	[edi+18h], ebx
		mov	eax, ebp
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN12_0:				; CODE XREF: _ssl_read+4Ej
					; DATA XREF: .text$mn:$LN24o
		push	0Ah		; jumptable 00000196 case 3
		push	edi
		call	_BIO_set_flags
		add	esp, 8
		mov	[edi+18h], ebx
		mov	eax, ebp
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN13_0:				; CODE XREF: _ssl_read+4Ej
					; DATA XREF: .text$mn:$LN24o
		push	0Ch		; jumptable 00000196 case 4
		push	edi
		call	_BIO_set_flags
		add	esp, 8
		mov	ebx, 1
		mov	[edi+18h], ebx
		mov	eax, ebp
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN14_0:				; CODE XREF: _ssl_read+4Ej
					; DATA XREF: .text$mn:$LN24o
		push	0Ch		; jumptable 00000196 case 8
		push	edi
		call	_BIO_set_flags
		add	esp, 8
		mov	ebx, 3
		mov	[edi+18h], ebx
		mov	eax, ebp
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN15_0:				; CODE XREF: _ssl_read+4Ej
					; DATA XREF: .text$mn:$LN24o
		push	0Ch		; jumptable 00000196 case 7
		push	edi
		call	_BIO_set_flags
		mov	ebx, 2
		add	esp, 8

$LN16:					; CODE XREF: _ssl_read+48j
					; _ssl_read+4Ej ...
		mov	[edi+18h], ebx	; jumptable 00000196 default case
		mov	eax, ebp
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_ssl_read	endp

; ---------------------------------------------------------------------------
$LN24		dd offset $LN5_0	; DATA XREF: _ssl_read+4Er
		dd offset $LN16		; jump table for switch	statement
		dd offset $LN11_0
		dd offset $LN12_0
		dd offset $LN13_0
		dd offset $LN16
		dd offset $LN16
		dd offset $LN15_0
		dd offset $LN14_0
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2B0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssl_puts	proc near		; DATA XREF: .data:000008ACo

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_4]
		mov	eax, edx
		push	esi
		lea	esi, [eax+1]
		nop	word ptr [eax+eax+00h]

loc_2C0:				; CODE XREF: _ssl_puts+15j
		mov	cl, [eax]
		inc	eax
		test	cl, cl
		jnz	short loc_2C0
		sub	eax, esi
		push	eax
		push	edx
		push	[esp+0Ch+arg_0]
		call	_BIO_write
		add	esp, 0Ch
		pop	esi
		retn
_ssl_puts	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2DCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssl_ctrl	proc near		; DATA XREF: .data:000008B4o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	ebx
		push	ebp
		mov	ebp, [esp+8+arg_4]
		mov	ebx, 1
		push	esi
		push	edi
		mov	edi, [esp+10h+arg_0]
		mov	ecx, [edi+20h]
		mov	[esp+10h+arg_0], ecx
		mov	esi, [ecx]
		test	esi, esi
		jnz	short loc_306
		cmp	ebp, 6Dh ; 'm'
		jz	short loc_306

loc_2FF:				; CODE XREF: _ssl_ctrl+13Aj
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_306:				; CODE XREF: _ssl_ctrl+1Cj
					; _ssl_ctrl+21j
		lea	eax, [ebp-1]	; switch 127 cases
		cmp	eax, 7Eh ; '~'
		ja	$LN55		; jumptable 00000319 default case
		movzx	eax, ds:$LN59[eax]
		jmp	ds:$LN67[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN7:					; CODE XREF: _ssl_ctrl+3Dj
					; DATA XREF: .text$mn:$LN67o
		push	esi		; jumptable 00000319 case 1
		call	_SSL_shutdown
		mov	eax, [esi+8]
		add	esp, 4
		mov	ecx, [esi+20h]
		cmp	ecx, [eax+14h]
		jnz	short loc_33C
		push	esi
		call	_SSL_set_connect_state
		jmp	short loc_347
; ---------------------------------------------------------------------------

loc_33C:				; CODE XREF: _ssl_ctrl+56j
		cmp	ecx, [eax+10h]
		jnz	short loc_34A
		push	esi
		call	_SSL_set_accept_state

loc_347:				; CODE XREF: _ssl_ctrl+5Ej
		add	esp, 4

loc_34A:				; CODE XREF: _ssl_ctrl+63j
		push	esi
		call	_SSL_clear
		mov	eax, [edi+24h]
		add	esp, 4
		test	eax, eax
		jnz	short loc_365
		mov	eax, [esi+0Ch]
		test	eax, eax
		jz	$LN2		; jumptable 000005CD default case

loc_365:				; CODE XREF: _ssl_ctrl+7Cj
		push	[esp+10h+arg_C]
		push	[esp+14h+arg_8]
		push	ebp
		push	eax
		call	_BIO_ctrl
		add	esp, 10h
		mov	ebx, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN15_1:				; CODE XREF: _ssl_ctrl+3Dj
					; _ssl_ctrl+19Dj
					; DATA XREF: ...
		pop	edi		; jumptable 00000319 cases 3,14
		pop	esi
		xor	ebx, ebx
		pop	ebp
		mov	eax, ebx
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN16_0:				; CODE XREF: _ssl_ctrl+3Dj
					; DATA XREF: .text$mn:$LN67o
		cmp	[esp+10h+arg_8], 0 ; jumptable 00000319	case 119
		push	esi
		jz	short loc_39E
		call	_SSL_set_connect_state
		add	esp, 4
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_39E:				; CODE XREF: _ssl_ctrl+B1j
		call	_SSL_set_accept_state
		add	esp, 4
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN19:					; CODE XREF: _ssl_ctrl+3Dj
					; DATA XREF: .text$mn:$LN67o
		mov	eax, [esp+10h+arg_8] ; jumptable 00000319 case 127
		mov	edx, 5
		mov	ebx, [ecx+10h]
		cmp	eax, 3Ch ; '<'
		push	0		; Time
		cmovl	eax, edx
		mov	[ecx+10h], eax
		call	dword ptr ds:__imp___time64
		mov	ecx, [esp+14h+arg_0]
		add	esp, 4
		pop	edi
		pop	esi
		mov	[ecx+14h], eax
		mov	eax, ebx
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN21:					; CODE XREF: _ssl_ctrl+3Dj
					; DATA XREF: .text$mn:$LN67o
		mov	eax, [esp+10h+arg_8] ; jumptable 00000319 case 125
		mov	ebx, [ecx+8]
		cmp	eax, 200h
		jl	$LN2		; jumptable 000005CD default case
		pop	edi
		pop	esi
		mov	[ecx+8], eax
		mov	eax, ebx
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN23_0:				; CODE XREF: _ssl_ctrl+3Dj
					; DATA XREF: .text$mn:$LN67o
		mov	ebx, [ecx+4]	; jumptable 00000319 case 126
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN24_0:				; CODE XREF: _ssl_ctrl+3Dj
					; DATA XREF: .text$mn:$LN67o
		test	esi, esi	; jumptable 00000319 case 109
		jz	short loc_41C
		push	edi
		call	_ssl_free
		push	edi
		call	_ssl_new
		add	esp, 8
		test	eax, eax
		jz	loc_2FF

loc_41C:				; CODE XREF: _ssl_ctrl+127j
		mov	eax, [esp+10h+arg_8]
		mov	ecx, [esp+10h+arg_C]
		mov	[edi+10h], eax
		mov	eax, [edi+20h]
		push	ecx
		mov	[eax], ecx
		call	_SSL_get_rbio
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jz	short loc_469
		mov	eax, [edi+24h]
		test	eax, eax
		jz	short loc_44C
		push	eax
		push	esi
		call	_BIO_push
		add	esp, 8

loc_44C:				; CODE XREF: _ssl_ctrl+164j
		push	162h
		push	offset ??_C@_0BA@OGOKKKKK@?4?2ssl?2bio_ssl?4c?$AA@ ; ".\\ssl\\bio_ssl.c"
		push	15h
		lea	eax, [esi+2Ch]
		mov	[edi+24h], esi
		push	1
		push	eax
		call	_CRYPTO_add_lock
		add	esp, 14h

loc_469:				; CODE XREF: _ssl_ctrl+15Dj
		mov	[edi+0Ch], ebx
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN29:					; CODE XREF: _ssl_ctrl+3Dj
					; DATA XREF: .text$mn:$LN67o
		mov	eax, [esp+10h+arg_C] ; jumptable 00000319 case 110
		test	eax, eax
		jz	$LN15_1		; jumptable 00000319 cases 3,14
		pop	edi
		mov	[eax], esi
		mov	eax, ebx
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN32:					; CODE XREF: _ssl_ctrl+3Dj
					; DATA XREF: .text$mn:$LN67o
		mov	ebx, [edi+10h]	; jumptable 00000319 case 8
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN33:					; CODE XREF: _ssl_ctrl+3Dj
					; DATA XREF: .text$mn:$LN67o
		mov	eax, [esp+10h+arg_8] ; jumptable 00000319 case 9
		mov	[edi+10h], eax
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN34:					; CODE XREF: _ssl_ctrl+3Dj
					; DATA XREF: .text$mn:$LN67o
		push	[esp+10h+arg_C]	; jumptable 00000319 case 13
		push	[esp+14h+arg_8]
		push	ebp
		push	dword ptr [esi+10h]
		call	_BIO_ctrl
		add	esp, 10h
		mov	ebx, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN35:					; CODE XREF: _ssl_ctrl+3Dj
					; DATA XREF: .text$mn:$LN67o
		push	esi		; jumptable 00000319 case 10
		call	_SSL_pending
		mov	ebx, eax
		add	esp, 4
		test	ebx, ebx
		jnz	$LN2		; jumptable 000005CD default case
		push	eax
		push	eax
		push	0Ah
		push	dword ptr [esi+0Ch]
		call	_BIO_ctrl
		add	esp, 10h
		mov	ebx, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN37:					; CODE XREF: _ssl_ctrl+3Dj
					; DATA XREF: .text$mn:$LN67o
		push	0Fh		; jumptable 00000319 case 11
		push	edi
		call	_BIO_clear_flags
		push	[esp+18h+arg_C]
		push	[esp+1Ch+arg_8]
		push	ebp
		push	dword ptr [esi+10h]
		call	_BIO_ctrl
		push	edi
		mov	ebx, eax
		call	_BIO_copy_next_retry
		add	esp, 1Ch
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN38:					; CODE XREF: _ssl_ctrl+3Dj
					; DATA XREF: .text$mn:$LN67o
		mov	eax, [edi+24h]	; jumptable 00000319 case 6
		test	eax, eax
		jz	$LN2		; jumptable 000005CD default case
		cmp	eax, [esi+0Ch]
		jz	$LN2		; jumptable 000005CD default case
		push	eax
		push	eax
		push	esi
		call	_SSL_set_bio
		mov	eax, [edi+24h]
		push	183h
		push	offset ??_C@_0BA@OGOKKKKK@?4?2ssl?2bio_ssl?4c?$AA@ ; ".\\ssl\\bio_ssl.c"
		push	15h
		add	eax, 2Ch ; ','
		push	1
		push	eax
		call	_CRYPTO_add_lock
		add	esp, 20h
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN40:					; CODE XREF: _ssl_ctrl+3Dj
					; DATA XREF: .text$mn:$LN67o
		cmp	edi, [esp+10h+arg_C] ; jumptable 00000319 case 7
		jnz	$LN2		; jumptable 000005CD default case
		mov	eax, [esi+10h]
		cmp	[esi+0Ch], eax
		jz	short loc_56A
		push	eax
		call	_BIO_free_all
		add	esp, 4

loc_56A:				; CODE XREF: _ssl_ctrl+283j
		mov	eax, [edi+24h]
		test	eax, eax
		jz	short loc_58B
		push	190h
		push	offset ??_C@_0BA@OGOKKKKK@?4?2ssl?2bio_ssl?4c?$AA@ ; ".\\ssl\\bio_ssl.c"
		push	15h
		add	eax, 2Ch ; ','
		push	0FFFFFFFFh
		push	eax
		call	_CRYPTO_add_lock
		add	esp, 14h

loc_58B:				; CODE XREF: _ssl_ctrl+293j
		pop	edi
		mov	dword ptr [esi+10h], 0
		mov	eax, ebx
		mov	dword ptr [esi+0Ch], 0
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN44:					; CODE XREF: _ssl_ctrl+3Dj
					; DATA XREF: .text$mn:$LN67o
		push	0Fh		; jumptable 00000319 case 101
		push	edi
		call	_BIO_clear_flags
		push	esi
		mov	dword ptr [edi+18h], 0
		call	_SSL_do_handshake
		mov	ebx, eax
		push	ebx
		push	esi
		call	_SSL_get_error
		add	eax, 0FFFFFFFEh
		add	esp, 14h
		cmp	eax, 5		; switch 6 cases
		ja	$LN2		; jumptable 000005CD default case
		jmp	ds:$LN68[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN45:					; CODE XREF: _ssl_ctrl+2F1j
					; DATA XREF: .text$mn:$LN68o
		push	9		; jumptable 000005CD case 0
		push	edi
		call	_BIO_set_flags
		add	esp, 8
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN46:					; CODE XREF: _ssl_ctrl+2F1j
					; DATA XREF: .text$mn:$LN68o
		push	0Ah		; jumptable 000005CD case 1
		push	edi
		call	_BIO_set_flags
		add	esp, 8
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN47:					; CODE XREF: _ssl_ctrl+2F1j
					; DATA XREF: .text$mn:$LN68o
		push	0Ch		; jumptable 000005CD case 5
		push	edi
		call	_BIO_set_flags
		mov	eax, [edi+24h]
		add	esp, 8
		mov	eax, [eax+18h]
		mov	[edi+18h], eax
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN48:					; CODE XREF: _ssl_ctrl+2F1j
					; DATA XREF: .text$mn:$LN68o
		push	0Ch		; jumptable 000005CD case 2
		push	edi
		call	_BIO_set_flags
		add	esp, 8
		mov	dword ptr [edi+18h], 1
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN50:					; CODE XREF: _ssl_ctrl+3Dj
					; DATA XREF: .text$mn:$LN67o
		mov	ebx, [esp+10h+arg_C] ; jumptable 00000319 case 12
		mov	eax, [ebx+20h]
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_642
		push	eax
		call	_SSL_free
		add	esp, 4

loc_642:				; CODE XREF: _ssl_ctrl+35Bj
		push	esi
		call	_SSL_dup
		mov	ecx, [ebx+20h]
		add	esp, 4
		mov	[ecx], eax
		mov	ecx, [ebx+20h]
		mov	eax, [edi+20h]
		mov	eax, [eax+8]
		mov	[ecx+8], eax
		mov	ecx, [ebx+20h]
		mov	eax, [edi+20h]
		mov	eax, [eax+0Ch]
		mov	[ecx+0Ch], eax
		mov	ecx, [ebx+20h]
		mov	eax, [edi+20h]
		mov	eax, [eax+10h]
		mov	[ecx+10h], eax
		mov	eax, [edi+20h]
		mov	ecx, [ebx+20h]
		pop	edi
		pop	esi
		mov	eax, [eax+14h]
		mov	[ecx+14h], eax
		mov	eax, [ebx+20h]
		xor	ebx, ebx
		pop	ebp
		cmp	[eax], ebx
		setnz	bl
		mov	eax, ebx
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN54:					; CODE XREF: _ssl_ctrl+3Dj
					; DATA XREF: .text$mn:$LN67o
		push	esi		; jumptable 00000319 case 15
		call	_SSL_get_info_callback
		mov	ecx, [esp+14h+arg_C]
		add	esp, 4
		pop	edi
		pop	esi
		mov	[ecx], eax
		mov	eax, ebx
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$LN55:					; CODE XREF: _ssl_ctrl+30j
					; _ssl_ctrl+3Dj
					; DATA XREF: ...
		push	[esp+10h+arg_C]	; jumptable 00000319 default case
		push	[esp+14h+arg_8]
		push	ebp
		push	dword ptr [esi+0Ch]
		call	_BIO_ctrl
		mov	ebx, eax
		add	esp, 10h

$LN2:					; CODE XREF: _ssl_ctrl+83j
					; _ssl_ctrl+10Bj ...
		pop	edi		; jumptable 000005CD default case
		pop	esi
		pop	ebp
		mov	eax, ebx
		pop	ebx
		retn
_ssl_ctrl	endp

; ---------------------------------------------------------------------------
$LN67		dd offset $LN7,	offset $LN15_1,	offset $LN38, offset $LN40
					; DATA XREF: _ssl_ctrl+3Dr
		dd offset $LN32, offset	$LN33, offset $LN35, offset $LN37 ; jump table for switch statement
		dd offset $LN50, offset	$LN34, offset $LN54, offset $LN44
		dd offset $LN55, offset	$LN24_0, offset	$LN29, offset $LN16_0
		dd offset $LN21, offset	$LN23_0, offset	$LN19, offset $LN55
$LN59		db	0,   13h,     1,   13h ; DATA XREF: _ssl_ctrl+36r
		db    13h,     2,     3,     4 ; indirect table	for switch statement
		db	5,     6,     7,     8
		db	9,     1,   0Ah,   13h
		db    13h,   13h,   13h,   13h
		db    13h,   13h,   13h,   13h
		db    13h,   13h,   13h,   13h
		db    13h,   13h,   13h,   13h
		db    13h,   13h,   13h,   13h
		db    13h,   13h,   13h,   13h
		db    13h,   13h,   13h,   13h
		db    13h,   13h,   13h,   13h
		db    13h,   13h,   13h,   13h
		db    13h,   13h,   13h,   13h
		db    13h,   13h,   13h,   13h
		db    13h,   13h,   13h,   13h
		db    13h,   13h,   13h,   13h
		db    13h,   13h,   13h,   13h
		db    13h,   13h,   13h,   13h
		db    13h,   13h,   13h,   13h
		db    13h,   13h,   13h,   13h
		db    13h,   13h,   13h,   13h
		db    13h,   13h,   13h,   13h
		db    13h,   13h,   13h,   13h
		db    13h,   13h,   13h,   13h
		db    0Bh,   13h,   13h,   13h
		db    0Ch,   13h,   13h,   13h
		db    0Dh,   0Eh,   13h,   13h
		db    13h,   13h,   13h,   13h
		db    13h,   13h,   0Fh,   13h
		db    13h,   13h,   13h,   13h
		db    10h,   11h,   12h
		align 4
$LN68		dd offset $LN45		; DATA XREF: _ssl_ctrl+2F1r
		dd offset $LN46		; jump table for switch	statement
		dd offset $LN48
		dd offset $LN2
		dd offset $LN2
		dd offset $LN47
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7ACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssl_new	proc near		; CODE XREF: _ssl_ctrl+130p
					; DATA XREF: .data:000008B8o

arg_0		= dword	ptr  4

		push	6Ah ; 'j'
		push	offset ??_C@_0BA@OGOKKKKK@?4?2ssl?2bio_ssl?4c?$AA@ ; ".\\ssl\\bio_ssl.c"
		push	18h
		call	_CRYPTO_malloc
		mov	ecx, eax
		add	esp, 0Ch
		test	ecx, ecx
		jnz	short loc_7DB
		push	6Ch ; 'l'
		push	offset ??_C@_0BA@OGOKKKKK@?4?2ssl?2bio_ssl?4c?$AA@ ; ".\\ssl\\bio_ssl.c"
		push	41h ; 'A'
		push	76h ; 'v'
		push	20h ; ' '
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_7DB:				; CODE XREF: _ssl_new+15j
		mov	eax, [esp+arg_0]
		xorps	xmm0, xmm0
		movups	xmmword	ptr [ecx], xmm0
		movq	qword ptr [ecx+10h], xmm0
		mov	dword ptr [eax+0Ch], 0
		mov	[eax+20h], ecx
		mov	dword ptr [eax+14h], 0
		mov	eax, 1
		retn
_ssl_new	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 804h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssl_free	proc near		; CODE XREF: _ssl_ctrl+12Ap
					; DATA XREF: .data:000008BCo

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jnz	short loc_811
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_811:				; CODE XREF: _ssl_free+7j
		push	edi
		mov	edi, [esi+20h]
		mov	eax, [edi]
		test	eax, eax
		jz	short loc_824
		push	eax
		call	_SSL_shutdown
		add	esp, 4

loc_824:				; CODE XREF: _ssl_free+15j
		cmp	dword ptr [esi+10h], 0
		jz	short loc_84D
		cmp	dword ptr [esi+0Ch], 0
		jz	short loc_83F
		mov	eax, [edi]
		test	eax, eax
		jz	short loc_83F
		push	eax
		call	_SSL_free
		add	esp, 4

loc_83F:				; CODE XREF: _ssl_free+2Aj
					; _ssl_free+30j
		mov	dword ptr [esi+0Ch], 0
		mov	dword ptr [esi+14h], 0

loc_84D:				; CODE XREF: _ssl_free+24j
		mov	eax, [esi+20h]
		pop	edi
		test	eax, eax
		jz	short loc_85E
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_85E:				; CODE XREF: _ssl_free+4Fj
		mov	eax, 1
		pop	esi
		retn
_ssl_free	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 868h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ssl_callback_ctrl proc	near		; DATA XREF: .data:000008C0o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, [esp+arg_0]
		mov	ecx, [esp+arg_4]
		push	[esp+arg_8]
		mov	eax, [eax+20h]
		mov	eax, [eax]
		cmp	ecx, 0Eh
		jz	short loc_88B
		push	ecx
		push	dword ptr [eax+0Ch]
		call	_BIO_callback_ctrl
		add	esp, 0Ch
		retn
; ---------------------------------------------------------------------------

loc_88B:				; CODE XREF: _ssl_callback_ctrl+14j
		push	eax
		call	_SSL_set_info_callback
		add	esp, 8
		mov	eax, 1
		retn
_ssl_callback_ctrl endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 89Ch
_methods_sslp	dd offset loc_207	; DATA XREF: _BIO_f_sslo
					; _BIO_new_ssl+1o ...
		dd offset ??_C@_03DIMONNDD@ssl?$AA@ ; `string'
		dd offset _ssl_write
		dd offset _ssl_read
		dd offset _ssl_puts
		dd 0
		dd offset _ssl_ctrl
		dd offset _ssl_new
		dd offset _ssl_free
		dd offset _ssl_callback_ctrl
_data		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 8C4h
; COMDAT (pick any)
		public ??_C@_03DIMONNDD@ssl?$AA@
; `string'
??_C@_03DIMONNDD@ssl?$AA@ dd 6C7373h	; DATA XREF: .data:000008A0o
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8C8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_f_ssl
_BIO_f_ssl	proc near
		mov	eax, offset _methods_sslp
		retn
_BIO_f_ssl	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8D0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_new_buffer_ssl_connect
_BIO_new_buffer_ssl_connect proc near

arg_0		= dword	ptr  4

		push	edi
		call	_BIO_f_buffer
		push	eax
		call	_BIO_new
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jnz	short loc_8E7
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_8E7:				; CODE XREF: _BIO_new_buffer_ssl_connect+13j
		push	esi
		push	[esp+8+arg_0]
		call	_BIO_new_ssl_connect
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jz	short $err$10
		push	esi
		push	edi
		call	_BIO_push
		add	esp, 8
		test	eax, eax
		jnz	short loc_920

$err$10:				; CODE XREF: _BIO_new_buffer_ssl_connect+28j
		push	edi
		call	_BIO_free
		add	esp, 4
		test	esi, esi
		jz	short loc_91E
		push	esi
		call	_BIO_free
		add	esp, 4

loc_91E:				; CODE XREF: _BIO_new_buffer_ssl_connect+43j
		xor	eax, eax

loc_920:				; CODE XREF: _BIO_new_buffer_ssl_connect+36j
		pop	esi
		pop	edi
		retn
_BIO_new_buffer_ssl_connect endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 924h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_new_ssl
_BIO_new_ssl	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		push	offset _methods_sslp
		call	_BIO_new
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jnz	short loc_93A
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_93A:				; CODE XREF: _BIO_new_ssl+12j
		push	edi
		push	[esp+8+arg_0]
		call	_SSL_new
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jnz	short loc_95B
		push	esi
		call	_BIO_free
		add	esp, 4
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_95B:				; CODE XREF: _BIO_new_ssl+27j
		cmp	[esp+8+arg_4], 0
		push	edi
		jz	short loc_96A
		call	_SSL_set_connect_state
		jmp	short loc_96F
; ---------------------------------------------------------------------------

loc_96A:				; CODE XREF: _BIO_new_ssl+3Dj
		call	_SSL_set_accept_state

loc_96F:				; CODE XREF: _BIO_new_ssl+44j
		add	esp, 4
		push	edi
		push	1
		push	6Dh ; 'm'
		push	esi
		call	_BIO_ctrl
		add	esp, 10h
		mov	eax, esi
		pop	edi
		pop	esi
		retn
_BIO_new_ssl	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 988h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_new_ssl_connect
_BIO_new_ssl_connect proc near		; CODE XREF: _BIO_new_buffer_ssl_connect+1Cp

arg_0		= dword	ptr  4

		push	edi
		call	_BIO_s_connect
		push	eax
		call	_BIO_new
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jnz	short loc_99F
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_99F:				; CODE XREF: _BIO_new_ssl_connect+13j
		push	ebx
		push	esi
		push	offset _methods_sslp
		call	_BIO_new
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jz	short $err$18
		push	[esp+0Ch+arg_0]
		call	_SSL_new
		mov	ebx, eax
		add	esp, 4
		test	ebx, ebx
		jnz	short loc_9DE
		push	esi
		call	_BIO_free
		add	esp, 4
		push	edi
		call	_BIO_free
		add	esp, 4
		xor	eax, eax
		pop	esi
		pop	ebx
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_9DE:				; CODE XREF: _BIO_new_ssl_connect+3Cj
		push	ebx
		call	_SSL_set_connect_state
		push	ebx
		push	1
		push	6Dh ; 'm'
		push	esi
		call	_BIO_ctrl
		push	edi
		push	esi
		call	_BIO_push
		add	esp, 1Ch
		test	eax, eax
		jnz	short loc_A08

$err$18:				; CODE XREF: _BIO_new_ssl_connect+2Aj
		push	edi
		call	_BIO_free
		add	esp, 4
		xor	eax, eax

loc_A08:				; CODE XREF: _BIO_new_ssl_connect+73j
		pop	esi
		pop	ebx
		pop	edi
		retn
_BIO_new_ssl_connect endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A0Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_ssl_copy_session_id
_BIO_ssl_copy_session_id proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		push	207h
		push	[esp+8+arg_0]
		call	_BIO_find_type
		push	207h
		push	[esp+10h+arg_4]
		mov	esi, eax
		call	_BIO_find_type
		add	esp, 10h
		test	esi, esi
		jz	short loc_A59
		test	eax, eax
		jz	short loc_A59
		mov	ecx, [esi+20h]
		mov	ecx, [ecx]
		test	ecx, ecx
		jz	short loc_A59
		mov	eax, [eax+20h]
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_A59
		push	eax
		push	ecx
		call	_SSL_copy_session_id
		add	esp, 8
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_A59:				; CODE XREF: _BIO_ssl_copy_session_id+24j
					; _BIO_ssl_copy_session_id+28j	...
		xor	eax, eax
		pop	esi
		retn
_BIO_ssl_copy_session_id endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A60h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _BIO_ssl_shutdown
_BIO_ssl_shutdown proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short locret_A8D
		nop	dword ptr [eax+eax+00000000h]

loc_A70:				; CODE XREF: _BIO_ssl_shutdown+1Fj
		mov	ecx, [eax]
		cmp	dword ptr [ecx], 207h
		jz	short loc_A82
		mov	eax, [eax+24h]
		test	eax, eax
		jnz	short loc_A70
		retn
; ---------------------------------------------------------------------------

loc_A82:				; CODE XREF: _BIO_ssl_shutdown+18j
		mov	eax, [eax+20h]
		push	dword ptr [eax]
		call	_SSL_shutdown
		pop	ecx

locret_A8D:				; CODE XREF: _BIO_ssl_shutdown+6j
		retn
_BIO_ssl_shutdown endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A90h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; time_t __cdecl static	time(time_t *Time)
_time		proc near
		jmp	dword ptr ds:__imp___time64
_time		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0A98h
; COMDAT (pick any)
		public ??_C@_0BA@OGOKKKKK@?4?2ssl?2bio_ssl?4c?$AA@
; `string'
??_C@_0BA@OGOKKKKK@?4?2ssl?2bio_ssl?4c?$AA@ db '.\ssl\bio_ssl.c',0
					; DATA XREF: _ssl_ctrl+175o
					; _ssl_ctrl+257o ...
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _CRYPTO_add_lock:near ; CODE XREF: _ssl_ctrl+185p
					; _ssl_ctrl+264p ...
		extrn _CRYPTO_malloc:near ; CODE XREF: _ssl_new+9p
		extrn _CRYPTO_free:near	; CODE XREF: _ssl_free+52p
		extrn _BIO_set_flags:near ; CODE XREF: _ssl_write+CBp
					; _ssl_write+E0p ...
		extrn _BIO_clear_flags:near ; CODE XREF: _ssl_write+23p
					; _ssl_read+23p ...
		extrn _BIO_new:near	; CODE XREF: _BIO_new_buffer_ssl_connect+7p
					; _BIO_new_ssl+6p ...
		extrn _BIO_free:near	; CODE XREF: _BIO_new_buffer_ssl_connect+39p
					; _BIO_new_buffer_ssl_connect+46p ...
		extrn _BIO_write:near	; CODE XREF: _ssl_puts+1Fp
		extrn _BIO_ctrl:near	; CODE XREF: _ssl_ctrl+93p
					; _ssl_ctrl+1D0p ...
		extrn _BIO_callback_ctrl:near ;	CODE XREF: _ssl_callback_ctrl+1Ap
		extrn _BIO_push:near	; CODE XREF: _ssl_ctrl+168p
					; _BIO_new_buffer_ssl_connect+2Cp ...
		extrn _BIO_free_all:near ; CODE	XREF: _ssl_ctrl+286p
		extrn _BIO_find_type:near ; CODE XREF: _BIO_ssl_copy_session_id+Ap
					; _BIO_ssl_copy_session_id+1Ap
		extrn _BIO_s_connect:near ; CODE XREF: _BIO_new_ssl_connect+1p
		extrn _BIO_f_buffer:near ; CODE	XREF: _BIO_new_buffer_ssl_connect+1p
		extrn _BIO_copy_next_retry:near	; CODE XREF: _ssl_ctrl+224p
		extrn _ERR_put_error:near ; CODE XREF: _ssl_new+24p
; __time64_t __cdecl __time64(__time64_t *Time)
		extrn __imp___time64:near ; CODE XREF: _ssl_write+99p
					; _ssl_read+99p ...
		extrn _SSL_clear:near	; CODE XREF: _ssl_ctrl+6Fp
		extrn _SSL_pending:near	; CODE XREF: _ssl_ctrl+1E0p
		extrn _SSL_set_bio:near	; CODE XREF: _ssl_ctrl+24Ap
		extrn _SSL_get_rbio:near ; CODE	XREF: _ssl_ctrl+151p
		extrn _SSL_copy_session_id:near	; CODE XREF: _BIO_ssl_copy_session_id+3Ep
		extrn _SSL_new:near	; CODE XREF: _BIO_new_ssl+1Bp
					; _BIO_new_ssl_connect+30p
		extrn _SSL_free:near	; CODE XREF: _ssl_ctrl+35Ep
					; _ssl_free+33p
		extrn _SSL_read:near	; CODE XREF: _ssl_read+31p
		extrn _SSL_write:near	; CODE XREF: _ssl_write+31p
		extrn _SSL_get_error:near ; CODE XREF: _ssl_write+3Dp
					; _ssl_read+3Dp ...
		extrn _SSL_do_handshake:near ; CODE XREF: _ssl_ctrl+2D4p
		extrn _SSL_renegotiate:near ; CODE XREF: _ssl_write+76p
					; _ssl_write+B6p ...
		extrn _SSL_shutdown:near ; CODE	XREF: _ssl_ctrl+45p
					; _ssl_free+18p ...
		extrn _SSL_set_connect_state:near ; CODE XREF: _ssl_ctrl+59p
					; _ssl_ctrl+B3p ...
		extrn _SSL_set_accept_state:near ; CODE	XREF: _ssl_ctrl+66p
					; _ssl_ctrl:loc_39Ep ...
		extrn _SSL_dup:near	; CODE XREF: _ssl_ctrl+367p
		extrn _SSL_set_info_callback:near ; CODE XREF: _ssl_callback_ctrl+24p
		extrn _SSL_get_info_callback:near ; CODE XREF: _ssl_ctrl+3B6p


		end
