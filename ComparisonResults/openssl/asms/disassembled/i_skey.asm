;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	155650CA13E7BDE988149D7AC42EE583
; Input	CRC32 :	8C7B0E6D

; File Name   :	C:\compspace\Diff\openssl\obj\i_skey.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _idea_set_decrypt_key
_idea_set_decrypt_key proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		push	ebp
		mov	ebp, [esp+8+arg_4]
		push	esi
		push	edi
		mov	edi, [esp+10h+arg_0]
		mov	esi, ebp
		add	edi, 0C0h ; 'À'
		xor	ebx, ebx

loc_16:					; CODE XREF: _idea_set_decrypt_key+5Ej
		push	dword ptr [edi]
		call	_inverse
		mov	[esi], eax
		mov	eax, [edi+8]
		neg	eax
		movzx	eax, ax
		mov	[esi+4], eax
		mov	eax, [edi+4]
		neg	eax
		movzx	eax, ax
		mov	[esi+8], eax
		push	dword ptr [edi+0Ch]
		call	_inverse
		add	esp, 8
		mov	[esi+0Ch], eax
		cmp	ebx, 8
		jz	short loc_60
		mov	eax, [edi-8]
		sub	edi, 18h
		mov	[esi+10h], eax
		inc	ebx
		mov	eax, [edi+14h]
		mov	[esi+14h], eax
		add	esi, 18h
		cmp	ebx, 9
		jl	short loc_16

loc_60:					; CODE XREF: _idea_set_decrypt_key+46j
		mov	ecx, [ebp+4]
		mov	eax, [ebp+8]
		pop	edi
		mov	[ebp+4], eax
		mov	eax, [ebp+0C8h]
		mov	[ebp+8], ecx
		mov	ecx, [ebp+0C4h]
		pop	esi
		mov	[ebp+0C4h], eax
		mov	[ebp+0C8h], ecx
		pop	ebp
		pop	ebx
		retn
_idea_set_decrypt_key endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _idea_set_encrypt_key
_idea_set_encrypt_key proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	edx, [esp+arg_0]
		push	ebx
		push	ebp
		push	esi
		movzx	eax, byte ptr [edx]
		mov	esi, [esp+0Ch+arg_4]
		shl	eax, 8
		lea	ebx, [esi+8]
		push	edi
		mov	[esp+10h+arg_0], 0
		mov	[esi], eax
		movzx	eax, byte ptr [edx+1]
		or	[esi], eax
		movzx	eax, byte ptr [edx+2]
		shl	eax, 8
		mov	[esi+4], eax
		movzx	eax, byte ptr [edx+3]
		or	[esi+4], eax
		movzx	eax, byte ptr [edx+4]
		shl	eax, 8
		mov	[ebx], eax
		movzx	eax, byte ptr [edx+5]
		or	[ebx], eax
		movzx	eax, byte ptr [edx+6]
		shl	eax, 8
		mov	[esi+0Ch], eax
		movzx	eax, byte ptr [edx+7]
		or	[esi+0Ch], eax
		movzx	eax, byte ptr [edx+8]
		shl	eax, 8
		mov	[esi+10h], eax
		movzx	eax, byte ptr [edx+9]
		or	[esi+10h], eax
		movzx	eax, byte ptr [edx+0Ah]
		shl	eax, 8
		mov	[esi+14h], eax
		movzx	eax, byte ptr [edx+0Bh]
		or	[esi+14h], eax
		movzx	eax, byte ptr [edx+0Ch]
		shl	eax, 8
		mov	[esi+18h], eax
		movzx	eax, byte ptr [edx+0Dh]
		or	[esi+18h], eax
		movzx	ecx, byte ptr [edx+0Eh]
		shl	ecx, 8
		mov	[esi+1Ch], ecx
		movzx	eax, byte ptr [edx+0Fh]
		or	eax, ecx
		mov	[esi+1Ch], eax
		lea	eax, [esi+20h]
		nop

loc_12C:				; CODE XREF: _idea_set_encrypt_key+14Dj
		mov	esi, [ebx]
		mov	edx, esi
		mov	ebp, [ebx-4]
		mov	ecx, ebp
		shl	ecx, 9
		shr	edx, 7
		or	edx, ecx
		shl	esi, 9
		movzx	ecx, dx
		mov	[eax], ecx
		mov	edi, [ebx+4]
		mov	ecx, edi
		shr	ecx, 7
		or	ecx, esi
		shl	edi, 9
		movzx	ecx, cx
		mov	[eax+4], ecx
		mov	edx, [ebx+8]
		mov	ecx, edx
		shr	ecx, 7
		or	edi, ecx
		shl	edx, 9
		movzx	ecx, di
		mov	[eax+8], ecx
		mov	esi, [ebx+0Ch]
		mov	ecx, esi
		shr	ecx, 7
		or	ecx, edx
		mov	edi, [esp+10h+arg_0]
		movzx	ecx, cx
		mov	[eax+0Ch], ecx
		mov	edx, [ebx+10h]
		mov	ecx, edx
		shr	ecx, 7
		shl	esi, 9
		or	esi, ecx
		shl	edx, 9
		movzx	ecx, si
		mov	[eax+10h], ecx
		mov	esi, [ebx+14h]
		mov	ecx, esi
		shr	ecx, 7
		or	ecx, edx
		movzx	ecx, cx
		mov	[eax+14h], ecx
		mov	edx, [ebx-8]
		cmp	edi, 5
		jge	short loc_1DF
		mov	ecx, edx
		shl	esi, 9
		shr	ecx, 7
		inc	edi
		or	esi, ecx
		shl	edx, 9
		shr	ebp, 7
		add	ebx, 20h ; ' '
		movzx	ecx, si
		or	edx, ebp
		mov	[eax+18h], ecx
		movzx	ecx, dx
		mov	[eax+1Ch], ecx
		add	eax, 20h ; ' '
		mov	[esp+10h+arg_0], edi
		cmp	edi, 6
		jl	loc_12C

loc_1DF:				; CODE XREF: _idea_set_encrypt_key+11Fj
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_idea_set_encrypt_key endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1E4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_inverse	proc near		; CODE XREF: _idea_set_decrypt_key+18p
					; _idea_set_decrypt_key+38p

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jnz	short loc_1F1
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1F1:				; CODE XREF: _inverse+7j
		push	ebx
		push	ebp
		push	edi
		mov	edi, 10001h
		mov	ecx, 1
		xor	ebp, ebp
		nop	dword ptr [eax+00h]

loc_204:				; CODE XREF: _inverse+41j
		mov	eax, edi
		cdq
		idiv	esi
		mov	ebx, edx
		sub	edi, ebx
		mov	eax, edi
		cdq
		idiv	esi
		test	ebx, ebx
		jz	short loc_227
		imul	eax, ecx
		mov	edx, ecx
		mov	ecx, ebp
		mov	edi, esi
		mov	esi, ebx
		mov	ebp, edx
		sub	ecx, eax
		jmp	short loc_204
; ---------------------------------------------------------------------------

loc_227:				; CODE XREF: _inverse+30j
		lea	eax, [ecx+10001h]
		pop	edi
		pop	ebp
		pop	ebx
		test	ecx, ecx
		js	short loc_236
		mov	eax, ecx

loc_236:				; CODE XREF: _inverse+4Ej
		pop	esi
		retn
_inverse	endp

_text$mn	ends


		end
