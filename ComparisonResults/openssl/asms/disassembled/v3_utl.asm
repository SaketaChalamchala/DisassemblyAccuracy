;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	8CE3BE0102188A0988166BC0A1E2772F
; Input	CRC32 :	1ACB38F5

; File Name   :	C:\compspace\Diff\openssl\obj\v3_utl.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
; `hex_to_string'::`2'::hexdig
?hexdig@?1??hex_to_string@@9@9 db 30h	; DATA XREF: _hex_to_string+5Er
					; _hex_to_string+6Er
a123456789abcde	db '123456789ABCDEF',0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 14h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509V3_NAME_from_section
_X509V3_NAME_from_section proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		cmp	[esp+arg_0], 0
		jnz	short loc_1E
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_1E:					; CODE XREF: _X509V3_NAME_from_section+5j
		push	ebx
		mov	ebx, [esp+4+arg_4]
		push	ebp
		push	esi
		push	edi
		push	ebx
		xor	edi, edi
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jle	short loc_A4

loc_35:					; CODE XREF: _X509V3_NAME_from_section+8Ej
		push	edi
		push	ebx
		call	_sk_value
		mov	ebp, eax
		add	esp, 8
		mov	esi, [ebp+4]
		mov	edx, esi
		mov	cl, [esi]
		test	cl, cl
		jz	short loc_6C

loc_4C:					; CODE XREF: _X509V3_NAME_from_section+4Dj
		cmp	cl, 3Ah	; ':'
		jz	short loc_65
		cmp	cl, 2Ch	; ','
		jz	short loc_65
		cmp	cl, 2Eh	; '.'
		jz	short loc_65
		mov	cl, [edx+1]
		inc	edx
		test	cl, cl
		jnz	short loc_4C
		jmp	short loc_6C
; ---------------------------------------------------------------------------

loc_65:					; CODE XREF: _X509V3_NAME_from_section+3Bj
					; _X509V3_NAME_from_section+40j ...
		inc	edx
		cmp	byte ptr [edx],	0
		cmovnz	esi, edx

loc_6C:					; CODE XREF: _X509V3_NAME_from_section+36j
					; _X509V3_NAME_from_section+4Fj
		cmp	byte ptr [esi],	2Bh ; '+'
		jnz	short loc_77
		or	eax, 0FFFFFFFFh
		inc	esi
		jmp	short loc_79
; ---------------------------------------------------------------------------

loc_77:					; CODE XREF: _X509V3_NAME_from_section+5Bj
		xor	eax, eax

loc_79:					; CODE XREF: _X509V3_NAME_from_section+61j
		push	eax
		push	0FFFFFFFFh
		push	0FFFFFFFFh
		push	dword ptr [ebp+8]
		push	[esp+20h+arg_8]
		push	esi
		push	[esp+28h+arg_0]
		call	_X509_NAME_add_entry_by_txt
		add	esp, 1Ch
		test	eax, eax
		jz	short loc_AE
		push	ebx
		inc	edi
		call	_sk_num
		add	esp, 4
		cmp	edi, eax
		jl	short loc_35

loc_A4:					; CODE XREF: _X509V3_NAME_from_section+1Fj
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, 1
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_AE:					; CODE XREF: _X509V3_NAME_from_section+80j
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
_X509V3_NAME_from_section endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509V3_add_value
_X509V3_add_value proc near		; CODE XREF: _X509V3_add_value_bool+Fj
					; _X509V3_add_value_bool+1Cj ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, [esp+arg_0]
		push	ebx
		push	ebp
		push	esi
		push	edi
		xor	esi, esi
		xor	ebx, ebx
		xor	edi, edi
		test	eax, eax
		jz	short loc_D9
		push	eax
		call	_BUF_strdup
		mov	ebx, eax
		add	esp, 4
		test	ebx, ebx
		jz	short $err$12

loc_D9:					; CODE XREF: _X509V3_add_value+10j
		mov	eax, [esp+10h+arg_4]
		test	eax, eax
		jz	short loc_F0
		push	eax
		call	_BUF_strdup
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jz	short $err$12

loc_F0:					; CODE XREF: _X509V3_add_value+27j
		push	5Bh ; '['
		push	offset ??_C@_0BJ@BDGEMPMC@?4?2crypto?2x509v3?2v3_utl?4c?$AA@ ; ".\\crypto\\x509v3\\v3_utl.c"
		push	0Ch
		call	_CRYPTO_malloc
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jz	short $err$12
		mov	ebp, [esp+10h+arg_8]
		cmp	dword ptr [ebp+0], 0
		jnz	short loc_11D
		call	_sk_new_null
		mov	[ebp+0], eax
		test	eax, eax
		jz	short $err$12

loc_11D:				; CODE XREF: _X509V3_add_value+57j
		mov	dword ptr [esi], 0
		mov	[esi+4], ebx
		mov	[esi+8], edi
		push	esi
		push	dword ptr [ebp+0]
		call	_sk_push
		add	esp, 8
		test	eax, eax
		jz	short $err$12
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, 1
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$err$12:				; CODE XREF: _X509V3_add_value+1Fj
					; _X509V3_add_value+36j ...
		push	66h ; 'f'
		push	offset ??_C@_0BJ@BDGEMPMC@?4?2crypto?2x509v3?2v3_utl?4c?$AA@ ; ".\\crypto\\x509v3\\v3_utl.c"
		push	41h ; 'A'
		push	69h ; 'i'
		push	22h ; '"'
		call	_ERR_put_error
		add	esp, 14h
		test	esi, esi
		jz	short loc_165
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_165:				; CODE XREF: _X509V3_add_value+A2j
		test	ebx, ebx
		jz	short loc_172
		push	ebx
		call	_CRYPTO_free
		add	esp, 4

loc_172:				; CODE XREF: _X509V3_add_value+AFj
		test	edi, edi
		jz	short loc_17F
		push	edi
		call	_CRYPTO_free
		add	esp, 4

loc_17F:				; CODE XREF: _X509V3_add_value+BCj
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
_X509V3_add_value endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 188h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509V3_add_value_bool
_X509V3_add_value_bool proc near

arg_4		= dword	ptr  8

		cmp	[esp+arg_4], 0
		jz	short loc_19C
		mov	[esp+arg_4], offset ??_C@_04HCDDPBNL@TRUE?$AA@ ; "TRUE"
		jmp	_X509V3_add_value
; ---------------------------------------------------------------------------

loc_19C:				; CODE XREF: _X509V3_add_value_bool+5j
		mov	[esp+arg_4], offset ??_C@_05MAJJAKPI@FALSE?$AA@	; "FALSE"
		jmp	_X509V3_add_value
_X509V3_add_value_bool endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1ACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509V3_add_value_bool_nf
_X509V3_add_value_bool_nf proc near

arg_4		= dword	ptr  8

		cmp	[esp+arg_4], 0
		jz	short loc_1C0
		mov	[esp+arg_4], offset ??_C@_04HCDDPBNL@TRUE?$AA@ ; "TRUE"
		jmp	_X509V3_add_value
; ---------------------------------------------------------------------------

loc_1C0:				; CODE XREF: _X509V3_add_value_bool_nf+5j
		mov	eax, 1
		retn
_X509V3_add_value_bool_nf endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1C8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509V3_add_value_int
_X509V3_add_value_int proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, [esp+arg_4]
		test	eax, eax
		jnz	short loc_1D6
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_1D6:				; CODE XREF: _X509V3_add_value_int+6j
		push	esi
		push	edi
		xor	edi, edi
		push	edi
		push	eax
		call	_ASN1_INTEGER_to_BN
		mov	esi, eax
		add	esp, 8
		test	esi, esi
		jz	short loc_1F9
		push	esi
		call	_BN_bn2dec
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jnz	short loc_211

loc_1F9:				; CODE XREF: _X509V3_add_value_int+20j
		push	0AAh ; 'ª'
		push	offset ??_C@_0BJ@BDGEMPMC@?4?2crypto?2x509v3?2v3_utl?4c?$AA@ ; ".\\crypto\\x509v3\\v3_utl.c"
		push	41h ; 'A'
		push	78h ; 'x'
		push	22h ; '"'
		call	_ERR_put_error
		add	esp, 14h

loc_211:				; CODE XREF: _X509V3_add_value_int+2Fj
		push	esi
		call	_BN_free
		add	esp, 4
		test	edi, edi
		jnz	short loc_223
		pop	edi
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_223:				; CODE XREF: _X509V3_add_value_int+54j
		push	[esp+8+arg_8]
		push	edi
		push	[esp+10h+arg_0]
		call	_X509V3_add_value
		push	edi
		mov	esi, eax
		call	_CRYPTO_free
		add	esp, 10h
		mov	eax, esi
		pop	edi
		pop	esi
		retn
_X509V3_add_value_int endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 244h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509V3_add_value_uchar
_X509V3_add_value_uchar	proc near
		jmp	_X509V3_add_value
_X509V3_add_value_uchar	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 24Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509V3_conf_free
_X509V3_conf_free proc near		; DATA XREF: _X509V3_parse_list+164o

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jz	short loc_28D
		mov	eax, [esi+4]
		test	eax, eax
		jz	short loc_265
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_265:				; CODE XREF: _X509V3_conf_free+Ej
		mov	eax, [esi+8]
		test	eax, eax
		jz	short loc_275
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_275:				; CODE XREF: _X509V3_conf_free+1Ej
		mov	eax, [esi]
		test	eax, eax
		jz	short loc_284
		push	eax
		call	_CRYPTO_free
		add	esp, 4

loc_284:				; CODE XREF: _X509V3_conf_free+2Dj
		push	esi
		call	_CRYPTO_free
		add	esp, 4

loc_28D:				; CODE XREF: _X509V3_conf_free+7j
		pop	esi
		retn
_X509V3_conf_free endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 290h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509V3_get_value_bool
_X509V3_get_value_bool proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		push	edi
		mov	edi, [esp+8+arg_0]
		mov	esi, [edi+8]
		test	esi, esi
		jz	$err$58
		mov	ecx, offset ??_C@_04HCDDPBNL@TRUE?$AA@ ; "TRUE"
		mov	eax, esi

loc_2A8:				; CODE XREF: _X509V3_get_value_bool+32j
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_2C8
		test	dl, dl
		jz	short loc_2C4
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_2C8
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_2A8

loc_2C4:				; CODE XREF: _X509V3_get_value_bool+20j
		xor	eax, eax
		jmp	short loc_2CD
; ---------------------------------------------------------------------------

loc_2C8:				; CODE XREF: _X509V3_get_value_bool+1Cj
					; _X509V3_get_value_bool+28j
		sbb	eax, eax
		or	eax, 1

loc_2CD:				; CODE XREF: _X509V3_get_value_bool+36j
		test	eax, eax
		jz	loc_521
		mov	ecx, offset ??_C@_04LOAJBDKD@true?$AA@ ; "true"
		mov	eax, esi
		nop	dword ptr [eax+00h]

loc_2E0:				; CODE XREF: _X509V3_get_value_bool+6Aj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_300
		test	dl, dl
		jz	short loc_2FC
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_300
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_2E0

loc_2FC:				; CODE XREF: _X509V3_get_value_bool+58j
		xor	eax, eax
		jmp	short loc_305
; ---------------------------------------------------------------------------

loc_300:				; CODE XREF: _X509V3_get_value_bool+54j
					; _X509V3_get_value_bool+60j
		sbb	eax, eax
		or	eax, 1

loc_305:				; CODE XREF: _X509V3_get_value_bool+6Ej
		test	eax, eax
		jz	loc_521
		mov	ecx, offset ??_C@_01NFFPALBN@Y?$AA@ ; `string'
		mov	eax, esi

loc_314:				; CODE XREF: _X509V3_get_value_bool+9Ej
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_334
		test	dl, dl
		jz	short loc_330
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_334
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_314

loc_330:				; CODE XREF: _X509V3_get_value_bool+8Cj
		xor	eax, eax
		jmp	short loc_339
; ---------------------------------------------------------------------------

loc_334:				; CODE XREF: _X509V3_get_value_bool+88j
					; _X509V3_get_value_bool+94j
		sbb	eax, eax
		or	eax, 1

loc_339:				; CODE XREF: _X509V3_get_value_bool+A2j
		test	eax, eax
		jz	loc_521
		mov	ecx, offset ??_C@_01EANLCPLP@y?$AA@ ; `string'
		mov	eax, esi

loc_348:				; CODE XREF: _X509V3_get_value_bool+D2j
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_368
		test	dl, dl
		jz	short loc_364
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_368
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_348

loc_364:				; CODE XREF: _X509V3_get_value_bool+C0j
		xor	eax, eax
		jmp	short loc_36D
; ---------------------------------------------------------------------------

loc_368:				; CODE XREF: _X509V3_get_value_bool+BCj
					; _X509V3_get_value_bool+C8j
		sbb	eax, eax
		or	eax, 1

loc_36D:				; CODE XREF: _X509V3_get_value_bool+D6j
		test	eax, eax
		jz	loc_521
		mov	ecx, offset ??_C@_03IPHJCBHH@YES?$AA@ ;	`string'
		mov	eax, esi
		nop	dword ptr [eax+00h]

loc_380:				; CODE XREF: _X509V3_get_value_bool+10Aj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_3A0
		test	dl, dl
		jz	short loc_39C
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_3A0
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_380

loc_39C:				; CODE XREF: _X509V3_get_value_bool+F8j
		xor	eax, eax
		jmp	short loc_3A5
; ---------------------------------------------------------------------------

loc_3A0:				; CODE XREF: _X509V3_get_value_bool+F4j
					; _X509V3_get_value_bool+100j
		sbb	eax, eax
		or	eax, 1

loc_3A5:				; CODE XREF: _X509V3_get_value_bool+10Ej
		test	eax, eax
		jz	loc_521
		mov	ecx, offset ??_C@_03ICICOMAL@yes?$AA@ ;	`string'
		mov	eax, esi

loc_3B4:				; CODE XREF: _X509V3_get_value_bool+13Ej
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_3D4
		test	dl, dl
		jz	short loc_3D0
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_3D4
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_3B4

loc_3D0:				; CODE XREF: _X509V3_get_value_bool+12Cj
		xor	eax, eax
		jmp	short loc_3D9
; ---------------------------------------------------------------------------

loc_3D4:				; CODE XREF: _X509V3_get_value_bool+128j
					; _X509V3_get_value_bool+134j
		sbb	eax, eax
		or	eax, 1

loc_3D9:				; CODE XREF: _X509V3_get_value_bool+142j
		test	eax, eax
		jz	loc_521
		mov	ecx, offset ??_C@_05MAJJAKPI@FALSE?$AA@	; "FALSE"
		mov	eax, esi

loc_3E8:				; CODE XREF: _X509V3_get_value_bool+172j
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_408
		test	dl, dl
		jz	short loc_404
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_408
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_3E8

loc_404:				; CODE XREF: _X509V3_get_value_bool+160j
		xor	eax, eax
		jmp	short loc_40D
; ---------------------------------------------------------------------------

loc_408:				; CODE XREF: _X509V3_get_value_bool+15Cj
					; _X509V3_get_value_bool+168j
		sbb	eax, eax
		or	eax, 1

loc_40D:				; CODE XREF: _X509V3_get_value_bool+176j
		test	eax, eax
		jz	loc_50F
		mov	ecx, offset ??_C@_05LAPONLG@false?$AA@ ; "false"
		mov	eax, esi
		nop	dword ptr [eax+00h]

loc_420:				; CODE XREF: _X509V3_get_value_bool+1AAj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_440
		test	dl, dl
		jz	short loc_43C
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_440
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_420

loc_43C:				; CODE XREF: _X509V3_get_value_bool+198j
		xor	eax, eax
		jmp	short loc_445
; ---------------------------------------------------------------------------

loc_440:				; CODE XREF: _X509V3_get_value_bool+194j
					; _X509V3_get_value_bool+1A0j
		sbb	eax, eax
		or	eax, 1

loc_445:				; CODE XREF: _X509V3_get_value_bool+1AEj
		test	eax, eax
		jz	loc_50F
		mov	ecx, offset ??_C@_01NANMIPIL@N?$AA@ ; `string'
		mov	eax, esi

loc_454:				; CODE XREF: _X509V3_get_value_bool+1DEj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_474
		test	dl, dl
		jz	short loc_470
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_474
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_454

loc_470:				; CODE XREF: _X509V3_get_value_bool+1CCj
		xor	eax, eax
		jmp	short loc_479
; ---------------------------------------------------------------------------

loc_474:				; CODE XREF: _X509V3_get_value_bool+1C8j
					; _X509V3_get_value_bool+1D4j
		sbb	eax, eax
		or	eax, 1

loc_479:				; CODE XREF: _X509V3_get_value_bool+1E2j
		test	eax, eax
		jz	loc_50F
		mov	ecx, offset ??_C@_01EFFIKLCJ@n?$AA@ ; `string'
		mov	eax, esi

loc_488:				; CODE XREF: _X509V3_get_value_bool+212j
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_4A8
		test	dl, dl
		jz	short loc_4A4
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_4A8
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_488

loc_4A4:				; CODE XREF: _X509V3_get_value_bool+200j
		xor	eax, eax
		jmp	short loc_4AD
; ---------------------------------------------------------------------------

loc_4A8:				; CODE XREF: _X509V3_get_value_bool+1FCj
					; _X509V3_get_value_bool+208j
		sbb	eax, eax
		or	eax, 1

loc_4AD:				; CODE XREF: _X509V3_get_value_bool+216j
		test	eax, eax
		jz	short loc_50F
		mov	ecx, offset ??_C@_02NFLNFON@NO?$AA@ ; `string'
		mov	eax, esi

loc_4B8:				; CODE XREF: _X509V3_get_value_bool+242j
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_4D8
		test	dl, dl
		jz	short loc_4D4
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_4D8
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_4B8

loc_4D4:				; CODE XREF: _X509V3_get_value_bool+230j
		xor	eax, eax
		jmp	short loc_4DD
; ---------------------------------------------------------------------------

loc_4D8:				; CODE XREF: _X509V3_get_value_bool+22Cj
					; _X509V3_get_value_bool+238j
		sbb	eax, eax
		or	eax, 1

loc_4DD:				; CODE XREF: _X509V3_get_value_bool+246j
		test	eax, eax
		jz	short loc_50F
		mov	eax, offset ??_C@_02KAJCLHKP@no?$AA@ ; `string'

loc_4E6:				; CODE XREF: _X509V3_get_value_bool+270j
		mov	cl, [esi]
		cmp	cl, [eax]
		jnz	short loc_506
		test	cl, cl
		jz	short loc_502
		mov	cl, [esi+1]
		cmp	cl, [eax+1]
		jnz	short loc_506
		add	esi, 2
		add	eax, 2
		test	cl, cl
		jnz	short loc_4E6

loc_502:				; CODE XREF: _X509V3_get_value_bool+25Ej
		xor	eax, eax
		jmp	short loc_50B
; ---------------------------------------------------------------------------

loc_506:				; CODE XREF: _X509V3_get_value_bool+25Aj
					; _X509V3_get_value_bool+266j
		sbb	eax, eax
		or	eax, 1

loc_50B:				; CODE XREF: _X509V3_get_value_bool+274j
		test	eax, eax
		jnz	short $err$58

loc_50F:				; CODE XREF: _X509V3_get_value_bool+17Fj
					; _X509V3_get_value_bool+1B7j ...
		mov	eax, [esp+8+arg_4]
		pop	edi
		pop	esi
		mov	dword ptr [eax], 0
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_521:				; CODE XREF: _X509V3_get_value_bool+3Fj
					; _X509V3_get_value_bool+77j ...
		mov	eax, [esp+8+arg_4]
		pop	edi
		pop	esi
		mov	dword ptr [eax], 0FFh
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

$err$58:				; CODE XREF: _X509V3_get_value_bool+Bj
					; _X509V3_get_value_bool+27Dj
		push	100h
		push	offset ??_C@_0BJ@BDGEMPMC@?4?2crypto?2x509v3?2v3_utl?4c?$AA@ ; ".\\crypto\\x509v3\\v3_utl.c"
		push	68h ; 'h'
		push	6Eh ; 'n'
		push	22h ; '"'
		call	_ERR_put_error
		push	dword ptr [edi+8]
		push	offset ??_C@_07BDICHDDB@?0value?3?$AA@ ; ",value:"
		push	dword ptr [edi+4]
		push	offset ??_C@_06FONLLLNC@?0name?3?$AA@ ;	",name:"
		push	dword ptr [edi]
		push	offset ??_C@_08PCLJGJAL@section?3?$AA@ ; "section:"
		push	6
		call	_ERR_add_error_data
		add	esp, 30h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
_X509V3_get_value_bool endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 570h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509V3_get_value_int
_X509V3_get_value_int proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		push	dword ptr [esi+8]
		push	0
		call	_s2i_ASN1_INTEGER
		mov	ecx, eax
		add	esp, 8
		test	ecx, ecx
		jnz	short loc_5AD
		push	dword ptr [esi+8]
		push	offset ??_C@_07BDICHDDB@?0value?3?$AA@ ; ",value:"
		push	dword ptr [esi+4]
		push	offset ??_C@_06FONLLLNC@?0name?3?$AA@ ;	",name:"
		push	dword ptr [esi]
		push	offset ??_C@_08PCLJGJAL@section?3?$AA@ ; "section:"
		push	6
		call	_ERR_add_error_data
		add	esp, 1Ch
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_5AD:				; CODE XREF: _X509V3_get_value_int+16j
		mov	eax, [esp+4+arg_4]
		pop	esi
		mov	[eax], ecx
		mov	eax, 1
		retn
_X509V3_get_value_int endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 5BCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509V3_parse_list
_X509V3_parse_list proc	near

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 8
		call	__chkstk
		push	ebx
		push	ebp
		push	esi
		push	edi
		push	[esp+18h+arg_0]
		mov	[esp+1Ch+var_8], 0
		call	_BUF_strdup
		add	esp, 4
		mov	[esp+18h+var_4], eax
		test	eax, eax
		jnz	short loc_5F7
		push	121h
		push	offset ??_C@_0BJ@BDGEMPMC@?4?2crypto?2x509v3?2v3_utl?4c?$AA@ ; ".\\crypto\\x509v3\\v3_utl.c"
		push	41h ; 'A'
		jmp	loc_70B
; ---------------------------------------------------------------------------

loc_5F7:				; CODE XREF: _X509V3_parse_list+28j
		mov	esi, eax
		mov	ebx, eax
		mov	al, [eax]
		xor	edi, edi
		mov	ebp, 1
		test	al, al
		jz	loc_6F2

loc_60C:				; CODE XREF: _X509V3_parse_list+EBj
		cmp	al, 0Dh
		jz	loc_6AD
		cmp	al, 0Ah
		jz	loc_6AD
		mov	ecx, ebp
		sub	ecx, 1
		jz	short loc_658
		sub	ecx, 1
		jnz	short loc_6A1
		cmp	al, 2Ch	; ','
		jnz	short loc_6A1
		push	ebx
		lea	ebp, [ecx+1]
		mov	[esi], cl
		call	_strip_spaces
		add	esp, 4
		test	eax, eax
		jz	loc_6CD
		lea	ecx, [esp+18h+var_8]
		push	ecx
		push	eax
		push	edi
		call	_X509V3_add_value
		add	esp, 0Ch
		lea	ebx, [esi+1]
		xor	edi, edi
		jmp	short loc_6A1
; ---------------------------------------------------------------------------

loc_658:				; CODE XREF: _X509V3_parse_list+65j
		cmp	al, 3Ah	; ':'
		jnz	short loc_678
		push	ebx
		mov	ebp, 2
		mov	byte ptr [esi],	0
		call	_strip_spaces
		mov	edi, eax
		add	esp, 4
		test	edi, edi
		jz	short loc_6DB
		lea	ebx, [esi+1]
		jmp	short loc_6A1
; ---------------------------------------------------------------------------

loc_678:				; CODE XREF: _X509V3_parse_list+9Ej
		cmp	al, 2Ch	; ','
		jnz	short loc_6A1
		push	ebx
		mov	byte ptr [esi],	0
		call	_strip_spaces
		mov	edi, eax
		lea	ebx, [esi+1]
		add	esp, 4
		test	edi, edi
		jz	short loc_6E2
		lea	eax, [esp+18h+var_8]
		push	eax
		push	0
		push	edi
		call	_X509V3_add_value
		add	esp, 0Ch

loc_6A1:				; CODE XREF: _X509V3_parse_list+6Aj
					; _X509V3_parse_list+6Ej ...
		mov	al, [esi+1]
		inc	esi
		test	al, al
		jnz	loc_60C

loc_6AD:				; CODE XREF: _X509V3_parse_list+52j
					; _X509V3_parse_list+5Aj
		cmp	ebp, 2
		jnz	short loc_6F2
		push	ebx
		call	_strip_spaces
		add	esp, 4
		test	eax, eax
		jnz	short loc_6E9
		push	162h
		push	offset ??_C@_0BJ@BDGEMPMC@?4?2crypto?2x509v3?2v3_utl?4c?$AA@ ; ".\\crypto\\x509v3\\v3_utl.c"
		push	6Dh ; 'm'
		jmp	short loc_70B
; ---------------------------------------------------------------------------

loc_6CD:				; CODE XREF: _X509V3_parse_list+80j
		push	150h
		push	offset ??_C@_0BJ@BDGEMPMC@?4?2crypto?2x509v3?2v3_utl?4c?$AA@ ; ".\\crypto\\x509v3\\v3_utl.c"
		push	6Dh ; 'm'
		jmp	short loc_70B
; ---------------------------------------------------------------------------

loc_6DB:				; CODE XREF: _X509V3_parse_list+B5j
		push	132h
		jmp	short loc_704
; ---------------------------------------------------------------------------

loc_6E2:				; CODE XREF: _X509V3_parse_list+D3j
		push	13Fh
		jmp	short loc_704
; ---------------------------------------------------------------------------

loc_6E9:				; CODE XREF: _X509V3_parse_list+101j
		lea	ecx, [esp+18h+var_8]
		push	ecx
		push	eax
		push	edi
		jmp	short loc_743
; ---------------------------------------------------------------------------

loc_6F2:				; CODE XREF: _X509V3_parse_list+4Aj
					; _X509V3_parse_list+F4j
		push	ebx
		call	_strip_spaces
		add	esp, 4
		test	eax, eax
		jnz	short loc_73B
		push	16Ch

loc_704:				; CODE XREF: _X509V3_parse_list+124j
					; _X509V3_parse_list+12Bj
		push	offset ??_C@_0BJ@BDGEMPMC@?4?2crypto?2x509v3?2v3_utl?4c?$AA@ ; ".\\crypto\\x509v3\\v3_utl.c"
		push	6Ch ; 'l'

loc_70B:				; CODE XREF: _X509V3_parse_list+36j
					; _X509V3_parse_list+10Fj ...
		push	6Dh ; 'm'
		push	22h ; '"'
		call	_ERR_put_error
		add	esp, 14h

$err$35:
		push	[esp+18h+var_4]
		call	_CRYPTO_free
		push	offset _X509V3_conf_free
		push	[esp+20h+var_8]
		call	_sk_pop_free
		add	esp, 0Ch
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 8
		retn
; ---------------------------------------------------------------------------

loc_73B:				; CODE XREF: _X509V3_parse_list+141j
		lea	ecx, [esp+18h+var_8]
		push	ecx
		push	0
		push	eax

loc_743:				; CODE XREF: _X509V3_parse_list+134j
		call	_X509V3_add_value
		add	esp, 0Ch
		push	[esp+18h+var_4]
		call	_CRYPTO_free
		mov	eax, [esp+1Ch+var_8]
		add	esp, 4
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 8
		retn
_X509V3_parse_list endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 764h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509_REQ_get1_email
_X509_REQ_get1_email proc near

arg_0		= dword	ptr  4

		push	ebx
		push	esi
		push	edi
		mov	edi, [esp+0Ch+arg_0]
		push	edi
		call	_X509_REQ_get_extensions
		push	0
		push	0
		mov	ebx, eax
		push	55h ; 'U'
		push	ebx
		call	_X509V3_get_d2i
		mov	ecx, [edi]
		mov	esi, eax
		push	esi
		push	dword ptr [ecx+10h]
		call	_get_email
		push	offset _GENERAL_NAME_free
		push	esi
		mov	edi, eax
		call	_sk_pop_free
		push	offset _X509_EXTENSION_free
		push	ebx
		call	_sk_pop_free
		add	esp, 2Ch
		mov	eax, edi
		pop	edi
		pop	esi
		pop	ebx
		retn
_X509_REQ_get1_email endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 7B0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl X509_check_email(int, void *Buf, int, int)
		public _X509_check_email
_X509_check_email proc near

arg_0		= dword	ptr  4
Buf		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	edi
		mov	edi, [esp+4+Buf]
		test	edi, edi
		jnz	short loc_7BE
		lea	eax, [edi-2]
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_7BE:				; CODE XREF: _X509_check_email+7j
		push	esi
		mov	esi, [esp+8+arg_8]
		test	esi, esi
		jnz	short loc_7FF
		mov	esi, edi
		lea	ecx, [esi+1]
		nop	dword ptr [eax+00h]

loc_7D0:				; CODE XREF: _X509_check_email+25j
		mov	al, [esi]
		inc	esi
		test	al, al
		jnz	short loc_7D0
		sub	esi, ecx

loc_7D9:				; CODE XREF: _X509_check_email+68j
		cmp	esi, 1
		jbe	short loc_7E6
		cmp	byte ptr [edi+esi-1], 0
		jnz	short loc_7E6
		dec	esi

loc_7E6:				; CODE XREF: _X509_check_email+2Cj
					; _X509_check_email+33j
		push	0
		push	1
		push	[esp+10h+arg_C]
		push	esi
		push	edi
		push	[esp+1Ch+arg_0]
		call	_do_x509_check
		add	esp, 18h
		pop	esi
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_7FF:				; CODE XREF: _X509_check_email+15j
		lea	eax, [esi-1]
		cmp	esi, 1
		ja	short loc_809
		mov	eax, esi

loc_809:				; CODE XREF: _X509_check_email+55j
		push	eax		; MaxCount
		push	0		; Val
		push	edi		; Buf
		call	dword ptr ds:__imp__memchr
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_7D9
		pop	esi
		mov	eax, 0FFFFFFFEh
		pop	edi
		retn
_X509_check_email endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 824h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl X509_check_host(int, void	*Buf, int, int,	int)
		public _X509_check_host
_X509_check_host proc near

arg_0		= dword	ptr  4
Buf		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		push	edi
		mov	edi, [esp+4+Buf]
		test	edi, edi
		jnz	short loc_832
		lea	eax, [edi-2]
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_832:				; CODE XREF: _X509_check_host+7j
		push	esi
		mov	esi, [esp+8+arg_8]
		test	esi, esi
		jnz	short loc_875
		mov	esi, edi
		lea	ecx, [esi+1]
		nop	dword ptr [eax+00h]

loc_844:				; CODE XREF: _X509_check_host+25j
		mov	al, [esi]
		inc	esi
		test	al, al
		jnz	short loc_844
		sub	esi, ecx

loc_84D:				; CODE XREF: _X509_check_host+6Aj
		cmp	esi, 1
		jbe	short loc_85A
		cmp	byte ptr [edi+esi-1], 0
		jnz	short loc_85A
		dec	esi

loc_85A:				; CODE XREF: _X509_check_host+2Cj
					; _X509_check_host+33j
		push	[esp+8+arg_10]
		push	2
		push	[esp+10h+arg_C]
		push	esi
		push	edi
		push	[esp+1Ch+arg_0]
		call	_do_x509_check
		add	esp, 18h
		pop	esi
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_875:				; CODE XREF: _X509_check_host+15j
		lea	eax, [esi-1]
		cmp	esi, 1
		ja	short loc_87F
		mov	eax, esi

loc_87F:				; CODE XREF: _X509_check_host+57j
		push	eax		; MaxCount
		push	0		; Val
		push	edi		; Buf
		call	dword ptr ds:__imp__memchr
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_84D
		pop	esi
		mov	eax, 0FFFFFFFEh
		pop	edi
		retn
_X509_check_host endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 898h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509_check_ip
_X509_check_ip	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		mov	eax, [esp+arg_4]
		test	eax, eax
		jnz	short loc_8A6
		mov	eax, 0FFFFFFFEh
		retn
; ---------------------------------------------------------------------------

loc_8A6:				; CODE XREF: _X509_check_ip+6j
		push	0
		push	7
		push	[esp+8+arg_C]
		push	[esp+0Ch+arg_8]
		push	eax
		push	[esp+14h+arg_0]
		call	_do_x509_check
		add	esp, 18h
		retn
_X509_check_ip	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8C0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl X509_check_ip_asc(int, char *Str,	int)
		public _X509_check_ip_asc
_X509_check_ip_asc proc	near

Dst		= dword	ptr -14h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
Str		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 14h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+14h+var_4], eax
		push	esi
		mov	esi, [esp+18h+Str]
		push	edi
		mov	edi, [esp+1Ch+arg_0]
		test	esi, esi
		jz	short loc_945
		push	3Ah ; ':'       ; Val
		push	esi		; Str
		call	dword ptr ds:__imp__strchr
		add	esp, 8
		test	eax, eax
		lea	eax, [esp+1Ch+Dst]
		push	esi		; Src
		push	eax		; int
		jz	short loc_90C
		call	_ipv6_from_asc
		add	esp, 8
		test	eax, eax
		jz	short loc_945
		mov	eax, 10h
		jmp	short loc_91D
; ---------------------------------------------------------------------------

loc_90C:				; CODE XREF: _X509_check_ip_asc+37j
		call	_ipv4_from_asc
		add	esp, 8
		test	eax, eax
		jz	short loc_945
		mov	eax, 4

loc_91D:				; CODE XREF: _X509_check_ip_asc+4Aj
		push	0
		push	7
		push	[esp+24h+arg_8]
		push	eax
		lea	eax, [esp+2Ch+Dst]
		push	eax
		push	edi
		call	_do_x509_check
		add	esp, 18h
		pop	edi
		pop	esi
		mov	ecx, [esp+14h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_945:				; CODE XREF: _X509_check_ip_asc+21j
					; _X509_check_ip_asc+43j ...
		mov	ecx, [esp+1Ch+var_4]
		mov	eax, 0FFFFFFFEh
		pop	edi
		pop	esi
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
_X509_check_ip_asc endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 95Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509_email_free
_X509_email_free proc near		; CODE XREF: _append_ia5+74p

arg_0		= dword	ptr  4

		push	offset _str_free
		push	[esp+4+arg_0]
		call	_sk_pop_free
		add	esp, 8
		retn
_X509_email_free endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 970h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509_get1_email
_X509_get1_email proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		push	0
		push	0
		push	55h ; 'U'
		push	esi
		call	_X509_get_ext_d2i
		add	esp, 10h
		mov	edi, eax
		push	edi
		push	esi
		call	_X509_get_subject_name
		add	esp, 4
		push	eax
		call	_get_email
		push	offset _GENERAL_NAME_free
		push	edi
		mov	esi, eax
		call	_sk_pop_free
		add	esp, 10h
		mov	eax, esi
		pop	edi
		pop	esi
		retn
_X509_get1_email endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 9ACh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _X509_get1_ocsp
_X509_get1_ocsp	proc near

var_4		= dword	ptr -4
arg_0		= dword	ptr  4

		mov	eax, 4
		call	__chkstk
		push	ebx
		push	edi
		xor	ebx, ebx
		push	ebx
		push	ebx
		push	0B1h ; '±'
		push	[esp+18h+arg_0]
		mov	[esp+1Ch+var_4], ebx
		call	_X509_get_ext_d2i
		mov	edi, eax
		add	esp, 10h
		test	edi, edi
		jnz	short loc_9DB
		pop	edi
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_9DB:				; CODE XREF: _X509_get1_ocsp+29j
		push	esi
		push	edi
		xor	esi, esi
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jle	short loc_A34
		nop

loc_9EC:				; CODE XREF: _X509_get1_ocsp+82j
		push	esi
		push	edi
		call	_sk_value
		mov	ebx, eax
		push	dword ptr [ebx]
		call	_OBJ_obj2nid
		add	esp, 0Ch
		cmp	eax, 0B2h ; '²'
		jnz	short loc_A22
		mov	eax, [ebx+4]
		cmp	dword ptr [eax], 6
		jnz	short loc_A22
		push	dword ptr [eax+4]
		lea	eax, [esp+14h+var_4]
		push	eax
		call	_append_ia5
		add	esp, 8
		test	eax, eax
		jz	short loc_A30

loc_A22:				; CODE XREF: _X509_get1_ocsp+58j
					; _X509_get1_ocsp+60j
		push	edi
		inc	esi
		call	_sk_num
		add	esp, 4
		cmp	esi, eax
		jl	short loc_9EC

loc_A30:				; CODE XREF: _X509_get1_ocsp+74j
		mov	ebx, [esp+10h+var_4]

loc_A34:				; CODE XREF: _X509_get1_ocsp+3Dj
		push	edi
		call	_AUTHORITY_INFO_ACCESS_free
		add	esp, 4
		mov	eax, ebx
		pop	esi
		pop	edi
		pop	ebx
		pop	ecx
		retn
_X509_get1_ocsp	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A44h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public ___local_stdio_scanf_options
___local_stdio_scanf_options proc near	; CODE XREF: __vsscanf_l+12p
					; _sscanf+11p
		mov	eax, offset ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
		retn
___local_stdio_scanf_options endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A4Ch
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public __vsscanf_l
__vsscanf_l	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	[esp+arg_C]
		push	[esp+4+arg_8]
		push	[esp+8+arg_4]
		push	0FFFFFFFFh
		push	[esp+10h+arg_0]
		call	___local_stdio_scanf_options
		push	dword ptr [eax+4]
		push	dword ptr [eax]
		call	dword ptr ds:__imp____stdio_common_vsscanf
		add	esp, 1Ch
		retn
__vsscanf_l	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A74h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl a2i_IPADDRESS(char *Str)
		public _a2i_IPADDRESS
_a2i_IPADDRESS	proc near

Dst		= dword	ptr -14h
var_4		= dword	ptr -4
Str		= dword	ptr  4

		mov	eax, 14h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+14h+var_4], eax
		push	esi
		mov	esi, [esp+18h+Str]
		push	edi
		push	3Ah ; ':'       ; Val
		push	esi		; Str
		call	dword ptr ds:__imp__strchr
		add	esp, 8
		test	eax, eax
		lea	eax, [esp+1Ch+Dst]
		push	esi		; Src
		push	eax		; int
		jz	short loc_AB8
		call	_ipv6_from_asc
		add	esp, 8
		test	eax, eax
		jz	short loc_AF0
		mov	edi, 10h
		jmp	short loc_AC9
; ---------------------------------------------------------------------------

loc_AB8:				; CODE XREF: _a2i_IPADDRESS+2Fj
		call	_ipv4_from_asc
		add	esp, 8
		test	eax, eax
		jz	short loc_AF0
		mov	edi, 4

loc_AC9:				; CODE XREF: _a2i_IPADDRESS+42j
		call	_ASN1_OCTET_STRING_new
		mov	esi, eax
		test	esi, esi
		jz	short loc_AF0
		push	edi
		lea	eax, [esp+20h+Dst]
		push	eax
		push	esi
		call	_ASN1_OCTET_STRING_set
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_B03
		push	esi
		call	_ASN1_OCTET_STRING_free
		add	esp, 4

loc_AF0:				; CODE XREF: _a2i_IPADDRESS+3Bj
					; _a2i_IPADDRESS+4Ej ...
		pop	edi
		xor	eax, eax
		pop	esi
		mov	ecx, [esp+14h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_B03:				; CODE XREF: _a2i_IPADDRESS+71j
		mov	ecx, [esp+1Ch+var_4]
		mov	eax, esi
		pop	edi
		pop	esi
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 14h
		retn
_a2i_IPADDRESS	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0B18h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl a2i_IPADDRESS_NC(char *Str)
		public _a2i_IPADDRESS_NC
_a2i_IPADDRESS_NC proc near

Dst		= dword	ptr -24h
var_4		= dword	ptr -4
Str		= dword	ptr  4

		mov	eax, 24h ; '$'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+24h+var_4], eax
		push	ebx
		mov	ebx, [esp+28h+Str]
		push	edi
		push	2Fh ; '/'       ; Val
		push	ebx		; Str
		call	dword ptr ds:__imp__strchr
		mov	edi, eax
		add	esp, 8
		test	edi, edi
		jnz	short loc_B56
		pop	edi
		pop	ebx
		mov	ecx, [esp+24h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 24h
		retn
; ---------------------------------------------------------------------------

loc_B56:				; CODE XREF: _a2i_IPADDRESS_NC+2Bj
		push	esi
		push	ebx
		call	_BUF_strdup
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jz	loc_C12
		sub	eax, ebx
		add	edi, eax
		push	3Ah ; ':'       ; Val
		push	esi		; Str
		mov	byte ptr [edi],	0
		inc	edi
		call	dword ptr ds:__imp__strchr
		add	esp, 8
		test	eax, eax
		lea	eax, [esp+30h+Dst]
		push	esi		; Src
		push	eax		; int
		jz	short loc_B9B
		call	_ipv6_from_asc
		add	esp, 8
		test	eax, eax
		jz	short $err$22
		mov	ebx, 10h
		jmp	short loc_BAC
; ---------------------------------------------------------------------------

loc_B9B:				; CODE XREF: _a2i_IPADDRESS_NC+6Ej
		call	_ipv4_from_asc
		add	esp, 8
		test	eax, eax
		jz	short $err$22
		mov	ebx, 4

loc_BAC:				; CODE XREF: _a2i_IPADDRESS_NC+81j
		lea	eax, [esp+30h+Dst]
		add	eax, ebx
		push	edi		; Str
		push	eax		; Dst
		call	_a2i_ipadd
		push	esi
		mov	edi, eax
		call	_CRYPTO_free
		add	esp, 0Ch
		test	edi, edi
		jz	short loc_C12
		cmp	ebx, edi
		jnz	short loc_C12
		call	_ASN1_OCTET_STRING_new
		mov	esi, eax
		test	esi, esi
		jz	short loc_C12
		lea	ecx, [edi+ebx]
		push	ecx
		lea	eax, [esp+34h+Dst]
		push	eax
		push	esi
		call	_ASN1_OCTET_STRING_set
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_C01
		mov	eax, esi
		pop	esi
		pop	edi
		pop	ebx
		mov	ecx, [esp+24h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 24h
		retn
; ---------------------------------------------------------------------------

loc_C01:				; CODE XREF: _a2i_IPADDRESS_NC+D3j
		push	esi
		call	_ASN1_OCTET_STRING_free
		jmp	short loc_C0F
; ---------------------------------------------------------------------------

$err$22:				; CODE XREF: _a2i_IPADDRESS_NC+7Aj
					; _a2i_IPADDRESS_NC+8Dj
		push	esi
		call	_CRYPTO_free

loc_C0F:				; CODE XREF: _a2i_IPADDRESS_NC+EFj
		add	esp, 4

loc_C12:				; CODE XREF: _a2i_IPADDRESS_NC+4Cj
					; _a2i_IPADDRESS_NC+AEj ...
		mov	ecx, [esp+30h+var_4]
		xor	eax, eax
		pop	esi
		pop	edi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 24h
		retn
_a2i_IPADDRESS_NC endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C28h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl a2i_ipadd(void *Dst, char	*Str)
		public _a2i_ipadd
_a2i_ipadd	proc near		; CODE XREF: _a2i_IPADDRESS_NC+9Cp

Dst		= dword	ptr  4
Str		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+Str]
		push	3Ah ; ':'       ; Val
		push	esi		; Str
		call	dword ptr ds:__imp__strchr
		add	esp, 8
		push	esi		; Src
		push	[esp+8+Dst]	; int
		test	eax, eax
		jz	short loc_C53
		call	_ipv6_from_asc
		add	esp, 8
		neg	eax
		sbb	eax, eax
		and	eax, 10h
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_C53:				; CODE XREF: _a2i_ipadd+18j
		call	_ipv4_from_asc
		add	esp, 8
		neg	eax
		sbb	eax, eax
		and	eax, 4
		pop	esi
		retn
_a2i_ipadd	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C64h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_append_ia5	proc near		; CODE XREF: _X509_get1_ocsp+6Ap
					; _get_email+E7p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	edi
		mov	edi, [esp+4+arg_4]
		cmp	dword ptr [edi+4], 16h
		jz	short loc_C76

loc_C6F:				; CODE XREF: _append_ia5+16j
					; _append_ia5+1Bj
		mov	eax, 1
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_C76:				; CODE XREF: _append_ia5+9j
		cmp	dword ptr [edi+8], 0
		jz	short loc_C6F
		cmp	dword ptr [edi], 0
		jz	short loc_C6F
		push	esi
		mov	esi, [esp+8+arg_0]
		cmp	dword ptr [esi], 0
		jnz	short loc_C9E
		push	offset _sk_strcmp
		call	_sk_new
		add	esp, 4
		mov	[esi], eax
		test	eax, eax
		jz	short loc_CE6

loc_C9E:				; CODE XREF: _append_ia5+25j
		push	dword ptr [edi+8]
		push	dword ptr [esi]
		call	_sk_find
		add	esp, 8
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_CCE
		push	dword ptr [edi+8]
		call	_BUF_strdup
		add	esp, 4
		test	eax, eax
		jz	short loc_CD6
		push	eax
		push	dword ptr [esi]
		call	_sk_push
		add	esp, 8
		test	eax, eax
		jz	short loc_CD6

loc_CCE:				; CODE XREF: _append_ia5+4Aj
		pop	esi
		mov	eax, 1
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_CD6:				; CODE XREF: _append_ia5+59j
					; _append_ia5+68j
		push	dword ptr [esi]
		call	_X509_email_free
		add	esp, 4
		mov	dword ptr [esi], 0

loc_CE6:				; CODE XREF: _append_ia5+38j
		pop	esi
		xor	eax, eax
		pop	edi
		retn
_append_ia5	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0CECh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_do_check_string proc near		; CODE XREF: _do_x509_check+11Fp
					; _do_x509_check+1AFp

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h
arg_18		= dword	ptr  1Ch

		push	ebx
		push	esi
		push	edi
		mov	edi, [esp+0Ch+arg_0]
		xor	ebx, ebx
		mov	ecx, [edi+8]
		test	ecx, ecx
		jz	loc_E2F
		mov	esi, [edi]
		test	esi, esi
		jz	loc_E2F
		mov	eax, [esp+0Ch+arg_4]
		test	eax, eax
		jle	loc_DCD
		cmp	eax, [edi+4]
		jnz	loc_E2F
		cmp	eax, 16h
		jnz	short loc_D45
		push	[esp+0Ch+arg_C]
		push	[esp+10h+arg_14]
		push	[esp+14h+arg_10]
		push	esi
		push	ecx
		call	[esp+20h+arg_8]
		mov	ebx, eax
		add	esp, 14h
		test	ebx, ebx
		jle	loc_E29
		jmp	short loc_DB0
; ---------------------------------------------------------------------------

loc_D45:				; CODE XREF: _do_check_string+36j
		mov	edx, [esp+0Ch+arg_14]
		cmp	esi, edx
		jnz	loc_E29
		mov	esi, [esp+0Ch+arg_10]
		sub	edx, 4
		jb	short loc_D6D
		xchg	ax, ax

loc_D5C:				; CODE XREF: _do_check_string+7Fj
		mov	eax, [ecx]
		cmp	eax, [esi]
		jnz	short loc_D72
		add	ecx, 4
		add	esi, 4
		sub	edx, 4
		jnb	short loc_D5C

loc_D6D:				; CODE XREF: _do_check_string+6Cj
		cmp	edx, 0FFFFFFFCh
		jz	short loc_DAB

loc_D72:				; CODE XREF: _do_check_string+74j
		mov	al, [ecx]
		cmp	al, [esi]
		jnz	loc_E29
		cmp	edx, 0FFFFFFFDh
		jz	short loc_DAB
		mov	al, [ecx+1]
		cmp	al, [esi+1]
		jnz	loc_E29
		cmp	edx, 0FFFFFFFEh
		jz	short loc_DAB
		mov	al, [ecx+2]
		cmp	al, [esi+2]
		jnz	loc_E29
		cmp	edx, 0FFFFFFFFh
		jz	short loc_DAB
		mov	al, [ecx+3]
		cmp	al, [esi+3]
		jnz	short loc_E29

loc_DAB:				; CODE XREF: _do_check_string+84j
					; _do_check_string+93j	...
		mov	ebx, 1

loc_DB0:				; CODE XREF: _do_check_string+57j
		mov	esi, [esp+0Ch+arg_18]
		test	esi, esi
		jz	short loc_E29
		push	dword ptr [edi]
		push	dword ptr [edi+8]
		call	_BUF_strndup
		add	esp, 8
		mov	[esi], eax
		mov	eax, ebx
		pop	edi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_DCD:				; CODE XREF: _do_check_string+24j
		lea	eax, [esp+0Ch+arg_0]
		push	edi
		push	eax
		call	_ASN1_STRING_to_UTF8
		mov	esi, eax
		add	esp, 8
		test	esi, esi
		jns	short loc_DE8
		pop	edi
		pop	esi
		or	eax, 0FFFFFFFFh
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_DE8:				; CODE XREF: _do_check_string+F3j
		push	[esp+0Ch+arg_C]
		push	[esp+10h+arg_14]
		push	[esp+14h+arg_10]
		push	esi
		push	[esp+1Ch+arg_0]
		call	[esp+20h+arg_8]
		mov	ebx, eax
		add	esp, 14h
		test	ebx, ebx
		jle	short loc_E1D
		mov	edi, [esp+0Ch+arg_18]
		test	edi, edi
		jz	short loc_E1D
		push	esi
		push	[esp+10h+arg_0]
		call	_BUF_strndup
		add	esp, 8
		mov	[edi], eax

loc_E1D:				; CODE XREF: _do_check_string+118j
					; _do_check_string+120j
		push	[esp+0Ch+arg_0]
		call	_CRYPTO_free
		add	esp, 4

loc_E29:				; CODE XREF: _do_check_string+51j
					; _do_check_string+5Fj	...
		pop	edi
		pop	esi
		mov	eax, ebx
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_E2F:				; CODE XREF: _do_check_string+Ej
					; _do_check_string+18j	...
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebx
		retn
_do_check_string endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0E38h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_do_x509_check	proc near		; CODE XREF: _X509_check_email+44p
					; _X509_check_host+46p	...

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	eax, 10h
		call	__chkstk
		mov	eax, [esp+10h+arg_C]
		push	ebx
		push	ebp
		xor	ebx, ebx
		and	eax, 0FFFF7FFFh
		push	esi
		mov	esi, [esp+1Ch+arg_10]
		mov	[esp+1Ch+var_10], ebx
		mov	[esp+1Ch+var_4], ebx
		mov	[esp+1Ch+var_8], ebx
		mov	[esp+1Ch+arg_C], eax
		push	edi
		mov	edi, [esp+20h+arg_8]
		cmp	esi, 1
		jnz	short loc_E89
		mov	ebx, 30h ; '0'
		mov	[esp+20h+arg_8], 16h
		mov	[esp+20h+var_10], ebx
		mov	[esp+20h+arg_10], offset _equal_email
		jmp	short loc_EDB
; ---------------------------------------------------------------------------

loc_E89:				; CODE XREF: _do_x509_check+34j
		cmp	esi, 2
		jnz	short loc_ECB
		mov	ebx, 0Dh
		mov	[esp+20h+var_10], ebx
		cmp	edi, 1
		jbe	short loc_EAE
		mov	ecx, [esp+20h+arg_4]
		cmp	byte ptr [ecx],	2Eh ; '.'
		jnz	short loc_EAE
		or	eax, 8000h
		mov	[esp+20h+arg_C], eax

loc_EAE:				; CODE XREF: _do_x509_check+62j
					; _do_x509_check+6Bj
		test	al, 2
		mov	[esp+20h+arg_8], 16h
		mov	eax, offset _equal_wildcard
		mov	ecx, offset _equal_nocase
		cmovnz	eax, ecx
		mov	[esp+20h+arg_10], eax
		jmp	short loc_EDB
; ---------------------------------------------------------------------------

loc_ECB:				; CODE XREF: _do_x509_check+54j
		mov	[esp+20h+arg_8], 4
		mov	[esp+20h+arg_10], offset _equal_case

loc_EDB:				; CODE XREF: _do_x509_check+4Fj
					; _do_x509_check+91j
		test	edi, edi
		jnz	short loc_EF1
		mov	edi, [esp+20h+arg_4]
		lea	ecx, [edi+1]
		xchg	ax, ax

loc_EE8:				; CODE XREF: _do_x509_check+B5j
		mov	al, [edi]
		inc	edi
		test	al, al
		jnz	short loc_EE8
		sub	edi, ecx

loc_EF1:				; CODE XREF: _do_x509_check+A5j
		push	0
		push	0
		push	55h ; 'U'
		push	[esp+2Ch+arg_0]
		call	_X509_get_ext_d2i
		add	esp, 10h
		mov	[esp+20h+var_C], eax
		test	eax, eax
		jz	loc_FA1
		push	eax
		xor	ebx, ebx
		call	_sk_num
		mov	ebp, [esp+24h+arg_C]
		add	esp, 4
		test	eax, eax
		jle	short loc_F78
		nop	word ptr [eax+eax+00h]

loc_F28:				; CODE XREF: _do_x509_check+13Ej
		push	ebx
		push	[esp+24h+var_C]
		call	_sk_value
		add	esp, 8
		cmp	[eax], esi
		jnz	short loc_F67
		push	[esp+20h+arg_14]
		mov	eax, [eax+4]
		push	edi
		push	[esp+28h+arg_4]
		mov	[esp+2Ch+var_4], 1
		push	ebp
		push	[esp+30h+arg_10]
		push	[esp+34h+arg_8]
		push	eax
		call	_do_check_string
		add	esp, 1Ch
		mov	[esp+20h+var_8], eax
		test	eax, eax
		jnz	short loc_F78

loc_F67:				; CODE XREF: _do_x509_check+FFj
		push	[esp+20h+var_C]
		inc	ebx
		call	_sk_num
		add	esp, 4
		cmp	ebx, eax
		jl	short loc_F28

loc_F78:				; CODE XREF: _do_x509_check+E8j
					; _do_x509_check+12Dj
		push	[esp+20h+var_C]
		call	_GENERAL_NAMES_free
		mov	eax, [esp+24h+var_8]
		add	esp, 4
		test	eax, eax
		jnz	short loc_1009
		mov	ebx, [esp+20h+var_10]
		test	ebx, ebx
		jz	short loc_1007
		cmp	[esp+20h+var_4], eax
		jz	short loc_FA5
		test	byte ptr [esp+20h+arg_C], 1
		jz	short loc_1007

loc_FA1:				; CODE XREF: _do_x509_check+D1j
		mov	ebp, [esp+20h+arg_C]

loc_FA5:				; CODE XREF: _do_x509_check+160j
		test	ebx, ebx
		jz	short loc_1007
		push	[esp+20h+arg_0]
		call	_X509_get_subject_name
		push	0FFFFFFFFh
		push	[esp+28h+var_10]
		mov	ebx, eax
		push	ebx
		call	_X509_NAME_get_index_by_NID
		mov	esi, eax
		add	esp, 10h
		test	esi, esi
		js	short loc_1007

loc_FC9:				; CODE XREF: _do_x509_check+1CDj
		push	esi
		push	ebx
		call	_X509_NAME_get_entry
		push	eax
		call	_X509_NAME_ENTRY_get_data
		push	[esp+2Ch+arg_14]
		push	edi
		push	[esp+34h+arg_4]
		push	ebp
		push	[esp+3Ch+arg_10]
		push	0FFFFFFFFh
		push	eax
		call	_do_check_string
		add	esp, 28h
		test	eax, eax
		jnz	short loc_1009
		push	esi
		push	[esp+24h+var_10]
		push	ebx
		call	_X509_NAME_get_index_by_NID
		mov	esi, eax
		add	esp, 0Ch
		test	esi, esi
		jns	short loc_FC9

loc_1007:				; CODE XREF: _do_x509_check+15Aj
					; _do_x509_check+167j ...
		xor	eax, eax

loc_1009:				; CODE XREF: _do_x509_check+152j
					; _do_x509_check+1B9j
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 10h
		retn
_do_x509_check	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1014h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_equal_case	proc near		; CODE XREF: _equal_email+46p
					; DATA XREF: _do_x509_check+9Bo

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		test	[esp+arg_10], 8000h
		mov	ecx, [esp+arg_4]
		mov	eax, ecx
		push	esi
		mov	esi, [esp+4+arg_0]
		mov	edx, esi
		push	edi
		mov	edi, [esp+8+arg_C]
		jz	short loc_1056
		cmp	ecx, edi
		jbe	short loc_104E
		push	ebx

loc_1035:				; CODE XREF: _equal_case+37j
		mov	bl, [edx]
		test	bl, bl
		jz	short loc_104D
		test	byte ptr [esp+0Ch+arg_10], 10h
		jz	short loc_1047
		cmp	bl, 2Eh	; '.'
		jz	short loc_104D

loc_1047:				; CODE XREF: _equal_case+2Cj
		dec	eax
		inc	edx
		cmp	eax, edi
		ja	short loc_1035

loc_104D:				; CODE XREF: _equal_case+25j
					; _equal_case+31j
		pop	ebx

loc_104E:				; CODE XREF: _equal_case+1Ej
		cmp	eax, edi
		jnz	short loc_1056
		mov	esi, edx
		mov	ecx, eax

loc_1056:				; CODE XREF: _equal_case+1Aj
					; _equal_case+3Cj
		cmp	ecx, edi
		jz	short loc_105F

loc_105A:				; CODE XREF: _equal_case+6Ej
					; _equal_case+7Bj ...
		pop	edi
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_105F:				; CODE XREF: _equal_case+44j
		mov	edx, [esp+8+arg_8]
		sub	ecx, 4
		jb	short loc_1079

loc_1068:				; CODE XREF: _equal_case+63j
		mov	eax, [esi]
		cmp	eax, [edx]
		jnz	short loc_107E
		add	esi, 4
		add	edx, 4
		sub	ecx, 4
		jnb	short loc_1068

loc_1079:				; CODE XREF: _equal_case+52j
		cmp	ecx, 0FFFFFFFCh
		jz	short loc_10AB

loc_107E:				; CODE XREF: _equal_case+58j
		mov	al, [esi]
		cmp	al, [edx]
		jnz	short loc_105A
		cmp	ecx, 0FFFFFFFDh
		jz	short loc_10AB
		mov	al, [esi+1]
		cmp	al, [edx+1]
		jnz	short loc_105A
		cmp	ecx, 0FFFFFFFEh
		jz	short loc_10AB
		mov	al, [esi+2]
		cmp	al, [edx+2]
		jnz	short loc_105A
		cmp	ecx, 0FFFFFFFFh
		jz	short loc_10AB
		mov	al, [esi+3]
		cmp	al, [edx+3]
		jnz	short loc_105A

loc_10AB:				; CODE XREF: _equal_case+68j
					; _equal_case+73j ...
		pop	edi
		mov	eax, 1
		pop	esi
		retn
_equal_case	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 10B4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_equal_email	proc near		; DATA XREF: _do_x509_check+47o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		push	esi
		push	edi
		mov	edi, [esp+8+arg_4]
		mov	esi, edi
		cmp	edi, [esp+8+arg_C]
		jz	short loc_10C7
		pop	edi
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_10C7:				; CODE XREF: _equal_email+Cj
		push	ebx
		mov	ebx, [esp+0Ch+arg_8]
		push	ebp
		mov	ebp, [esp+10h+arg_0]
		test	edi, edi
		jz	short loc_10EF
		mov	ecx, ebp
		lea	eax, [edi+ebx]
		sub	ecx, ebx

loc_10DC:				; CODE XREF: _equal_email+39j
		lea	eax, [eax-1]
		dec	esi
		cmp	byte ptr [ecx+eax], 40h	; '@'
		jz	short loc_1107
		cmp	byte ptr [eax],	40h ; '@'
		jz	short loc_1107
		test	esi, esi
		jnz	short loc_10DC

loc_10EF:				; CODE XREF: _equal_email+1Fj
					; _equal_email+6Dj
		test	esi, esi
		push	0
		cmovz	esi, edi
		push	esi
		push	ebx
		push	esi
		push	ebp
		call	_equal_case
		add	esp, 14h
		pop	ebp
		pop	ebx
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1107:				; CODE XREF: _equal_email+30j
					; _equal_email+35j
		push	0
		mov	ecx, edi
		lea	eax, [esi+ebx]
		sub	ecx, esi
		push	ecx
		push	eax
		push	ecx
		lea	eax, [esi+ebp]
		push	eax
		call	_equal_nocase
		add	esp, 14h
		test	eax, eax
		jnz	short loc_10EF
		pop	ebp
		pop	ebx
		pop	edi
		pop	esi
		retn
_equal_email	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1128h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_equal_nocase	proc near		; CODE XREF: _equal_email+63p
					; _equal_wildcard+3Ap ...

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		test	[esp+arg_10], 8000h
		push	ebx
		mov	ebx, [esp+4+arg_0]
		mov	ecx, ebx
		push	esi
		mov	esi, [esp+8+arg_C]
		push	edi
		mov	edi, [esp+0Ch+arg_4]
		mov	eax, edi
		jz	short loc_1169
		cmp	edi, esi
		jbe	short loc_1161

loc_1149:				; CODE XREF: _equal_nocase+37j
		mov	dl, [ecx]
		test	dl, dl
		jz	short loc_1161
		test	byte ptr [esp+0Ch+arg_10], 10h
		jz	short loc_115B
		cmp	dl, 2Eh	; '.'
		jz	short loc_1161

loc_115B:				; CODE XREF: _equal_nocase+2Cj
		dec	eax
		inc	ecx
		cmp	eax, esi
		ja	short loc_1149

loc_1161:				; CODE XREF: _equal_nocase+1Fj
					; _equal_nocase+25j ...
		cmp	eax, esi
		jnz	short loc_1169
		mov	ebx, ecx
		mov	edi, eax

loc_1169:				; CODE XREF: _equal_nocase+1Bj
					; _equal_nocase+3Bj
		cmp	edi, esi
		jz	short loc_1173

loc_116D:				; CODE XREF: _equal_nocase+5Cj
					; _equal_nocase+78j
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1173:				; CODE XREF: _equal_nocase+43j
		test	edi, edi
		jz	short loc_11A8
		mov	esi, [esp+0Ch+arg_8]
		sub	ebx, esi

loc_117D:				; CODE XREF: _equal_nocase+7Ej
		mov	cl, [ebx+esi]
		mov	dl, [esi]
		test	cl, cl
		jz	short loc_116D
		cmp	cl, dl
		jz	short loc_11A2
		lea	eax, [ecx-41h]
		cmp	al, 19h
		ja	short loc_1194
		add	cl, 20h	; ' '

loc_1194:				; CODE XREF: _equal_nocase+67j
		lea	eax, [edx-41h]
		cmp	al, 19h
		ja	short loc_119E
		add	dl, 20h	; ' '

loc_119E:				; CODE XREF: _equal_nocase+71j
		cmp	cl, dl
		jnz	short loc_116D

loc_11A2:				; CODE XREF: _equal_nocase+60j
		inc	esi
		sub	edi, 1
		jnz	short loc_117D

loc_11A8:				; CODE XREF: _equal_nocase+4Dj
		pop	edi
		pop	esi
		mov	eax, 1
		pop	ebx
		retn
_equal_nocase	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 11B4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl equal_wildcard(char *, int, char *Str1, int, char)
_equal_wildcard	proc near		; DATA XREF: _do_x509_check+80o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
Str1		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= byte ptr  14h

		push	ebx
		mov	ebx, [esp+4+arg_C]
		push	ebp
		mov	ebp, dword ptr [esp+8+arg_10]
		push	esi
		mov	esi, [esp+0Ch+arg_0]
		push	edi
		mov	edi, [esp+10h+Str1]
		cmp	ebx, 1
		jbe	short loc_11D2
		cmp	byte ptr [edi],	2Eh ; '.'
		jz	short loc_11E6

loc_11D2:				; CODE XREF: _equal_wildcard+17j
		push	ebp		; char
		push	[esp+14h+arg_4]	; int
		push	esi		; Str1
		call	_valid_star
		mov	ecx, eax
		add	esp, 0Ch
		test	ecx, ecx
		jnz	short loc_11FB

loc_11E6:				; CODE XREF: _equal_wildcard+1Cj
		push	ebp
		push	ebx
		push	edi
		push	[esp+1Ch+arg_4]
		push	esi
		call	_equal_nocase
		add	esp, 14h
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_11FB:				; CODE XREF: _equal_wildcard+30j
		mov	edx, [esp+10h+arg_4]
		mov	eax, esi
		push	ebp		; int
		push	ebx		; int
		sub	eax, ecx
		dec	edx
		push	edi		; Str1
		add	eax, edx
		push	eax		; int
		lea	eax, [ecx+1]
		sub	ecx, esi
		push	eax		; int
		push	ecx		; int
		push	esi		; int
		call	_wildcard_match
		add	esp, 1Ch
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		retn
_equal_wildcard	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1220h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_get_email	proc near		; CODE XREF: _X509_REQ_get1_email+23p
					; _X509_get1_email+22p

var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 4
		call	__chkstk
		push	ebx
		push	ebp
		mov	ebp, [esp+0Ch+arg_0]
		push	esi
		push	edi
		push	0FFFFFFFFh
		push	30h ; '0'
		xor	esi, esi
		push	ebp
		mov	[esp+20h+var_4], esi
		call	_X509_NAME_get_index_by_NID
		mov	ebx, eax
		add	esp, 0Ch
		test	ebx, ebx
		js	loc_12D6
		nop

loc_1250:				; CODE XREF: _get_email+B0j
		push	ebx
		push	ebp
		call	_X509_NAME_get_entry
		push	eax
		call	_X509_NAME_ENTRY_get_data
		mov	edi, eax
		add	esp, 0Ch
		cmp	dword ptr [edi+4], 16h
		jnz	short loc_12C0
		cmp	dword ptr [edi+8], 0
		jz	short loc_12C0
		cmp	dword ptr [edi], 0
		jz	short loc_12C0
		test	esi, esi
		jnz	short loc_1292
		push	offset _sk_strcmp
		call	_sk_new
		mov	esi, eax
		add	esp, 4
		mov	[esp+14h+var_4], esi
		test	esi, esi
		jz	loc_133B

loc_1292:				; CODE XREF: _get_email+55j
		push	dword ptr [edi+8]
		push	esi
		call	_sk_find
		add	esp, 8
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_12C0
		push	dword ptr [edi+8]
		call	_BUF_strdup
		add	esp, 4
		test	eax, eax
		jz	short loc_132D
		push	eax
		push	esi
		call	_sk_push
		add	esp, 8
		test	eax, eax
		jz	short loc_132D

loc_12C0:				; CODE XREF: _get_email+46j
					; _get_email+4Cj ...
		push	ebx
		push	30h ; '0'
		push	ebp
		call	_X509_NAME_get_index_by_NID
		mov	ebx, eax
		add	esp, 0Ch
		test	ebx, ebx
		jns	loc_1250

loc_12D6:				; CODE XREF: _get_email+29j
		mov	ebx, [esp+14h+arg_4]
		xor	edi, edi
		push	ebx
		call	_sk_num
		add	esp, 4
		test	eax, eax
		jle	short loc_1325
		nop	dword ptr [eax+00000000h]

loc_12F0:				; CODE XREF: _get_email+FFj
		push	edi
		push	ebx
		call	_sk_value
		add	esp, 8
		cmp	dword ptr [eax], 1
		jnz	short loc_1313
		push	dword ptr [eax+4]
		lea	eax, [esp+18h+var_4]
		push	eax
		call	_append_ia5
		add	esp, 8
		test	eax, eax
		jz	short loc_133B

loc_1313:				; CODE XREF: _get_email+DDj
		push	ebx
		inc	edi
		call	_sk_num
		add	esp, 4
		cmp	edi, eax
		jl	short loc_12F0
		mov	esi, [esp+14h+var_4]

loc_1325:				; CODE XREF: _get_email+C7j
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_132D:				; CODE XREF: _get_email+90j
					; _get_email+9Ej
		push	offset _str_free
		push	esi
		call	_sk_pop_free
		add	esp, 8

loc_133B:				; CODE XREF: _get_email+6Cj
					; _get_email+F1j
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		pop	ecx
		retn
_get_email	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1344h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _hex_to_string
_hex_to_string	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		test	esi, esi
		jz	short loc_1390
		mov	edi, [esp+8+arg_4]
		test	edi, edi
		jz	short loc_1390
		push	19Fh
		lea	eax, ds:1[edi*2]
		add	eax, edi
		push	offset ??_C@_0BJ@BDGEMPMC@?4?2crypto?2x509v3?2v3_utl?4c?$AA@ ; ".\\crypto\\x509v3\\v3_utl.c"
		push	eax
		call	_CRYPTO_malloc
		mov	edx, eax
		add	esp, 0Ch
		test	edx, edx
		jnz	short loc_1395
		push	1A0h
		push	offset ??_C@_0BJ@BDGEMPMC@?4?2crypto?2x509v3?2v3_utl?4c?$AA@ ; ".\\crypto\\x509v3\\v3_utl.c"
		push	41h ; 'A'
		push	6Fh ; 'o'
		push	22h ; '"'
		call	_ERR_put_error
		add	esp, 14h

loc_1390:				; CODE XREF: _hex_to_string+8j
					; _hex_to_string+10j
		pop	edi
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1395:				; CODE XREF: _hex_to_string+32j
		test	edi, edi
		jle	short loc_13C8

loc_1399:				; CODE XREF: _hex_to_string+82j
		movzx	ecx, byte ptr [esi]
		lea	esi, [esi+1]
		shr	ecx, 4
		movzx	ecx, ?hexdig@?1??hex_to_string@@9@9[ecx] ; `hex_to_string'::`2'::hexdig
		mov	[eax], cl
		movzx	ecx, byte ptr [esi-1]
		and	ecx, 0Fh
		movzx	ecx, ?hexdig@?1??hex_to_string@@9@9[ecx] ; `hex_to_string'::`2'::hexdig
		mov	[eax+1], cl
		mov	byte ptr [eax+2], 3Ah ;	':'
		add	eax, 3
		sub	edi, 1
		jnz	short loc_1399

loc_13C8:				; CODE XREF: _hex_to_string+53j
		pop	edi
		mov	byte ptr [eax-1], 0
		mov	eax, edx
		pop	esi
		retn
_hex_to_string	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 13D4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _i2s_ASN1_ENUMERATED
_i2s_ASN1_ENUMERATED proc near

arg_4		= dword	ptr  8

		mov	eax, [esp+arg_4]
		push	esi
		xor	esi, esi
		test	eax, eax
		jnz	short loc_13E1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_13E1:				; CODE XREF: _i2s_ASN1_ENUMERATED+9j
		push	edi
		push	0
		push	eax
		call	_ASN1_ENUMERATED_to_BN
		mov	edi, eax
		add	esp, 8
		test	edi, edi
		jz	short loc_1402
		push	edi
		call	_BN_bn2dec
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jnz	short loc_141A

loc_1402:				; CODE XREF: _i2s_ASN1_ENUMERATED+1Dj
		push	9Dh ; ''
		push	offset ??_C@_0BJ@BDGEMPMC@?4?2crypto?2x509v3?2v3_utl?4c?$AA@ ; ".\\crypto\\x509v3\\v3_utl.c"
		push	41h ; 'A'
		push	79h ; 'y'
		push	22h ; '"'
		call	_ERR_put_error
		add	esp, 14h

loc_141A:				; CODE XREF: _i2s_ASN1_ENUMERATED+2Cj
		push	edi
		call	_BN_free
		add	esp, 4
		mov	eax, esi
		pop	edi
		pop	esi
		retn
_i2s_ASN1_ENUMERATED endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1428h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _i2s_ASN1_INTEGER
_i2s_ASN1_INTEGER proc near

arg_4		= dword	ptr  8

		mov	eax, [esp+arg_4]
		push	esi
		xor	esi, esi
		test	eax, eax
		jnz	short loc_1435
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1435:				; CODE XREF: _i2s_ASN1_INTEGER+9j
		push	edi
		push	0
		push	eax
		call	_ASN1_INTEGER_to_BN
		mov	edi, eax
		add	esp, 8
		test	edi, edi
		jz	short loc_1456
		push	edi
		call	_BN_bn2dec
		mov	esi, eax
		add	esp, 4
		test	esi, esi
		jnz	short loc_146E

loc_1456:				; CODE XREF: _i2s_ASN1_INTEGER+1Dj
		push	0AAh ; 'ª'
		push	offset ??_C@_0BJ@BDGEMPMC@?4?2crypto?2x509v3?2v3_utl?4c?$AA@ ; ".\\crypto\\x509v3\\v3_utl.c"
		push	41h ; 'A'
		push	78h ; 'x'
		push	22h ; '"'
		call	_ERR_put_error
		add	esp, 14h

loc_146E:				; CODE XREF: _i2s_ASN1_INTEGER+2Cj
		push	edi
		call	_BN_free
		add	esp, 4
		mov	eax, esi
		pop	edi
		pop	esi
		retn
_i2s_ASN1_INTEGER endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 147Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl ipv4_from_asc(int, char *Src)
_ipv4_from_asc	proc near		; CODE XREF: _X509_check_ip_asc:loc_90Cp
					; _a2i_IPADDRESS:loc_AB8p ...

var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
Src		= dword	ptr  8

		mov	eax, 10h
		call	__chkstk
		lea	eax, [esp+10h+var_10]
		push	eax
		lea	eax, [esp+14h+var_4]
		push	eax
		lea	eax, [esp+18h+var_8]
		push	eax
		lea	eax, [esp+1Ch+var_C]
		push	eax
		push	offset ??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@ ; "%d.%d.%d.%d"
		push	[esp+24h+Src]	; Src
		call	_sscanf
		add	esp, 18h
		cmp	eax, 4
		jz	short loc_14B5
		xor	eax, eax
		add	esp, 10h
		retn
; ---------------------------------------------------------------------------

loc_14B5:				; CODE XREF: _ipv4_from_asc+31j
		mov	ecx, [esp+10h+var_C]
		push	ebx
		cmp	ecx, 0FFh
		ja	short loc_1501
		mov	edx, [esp+14h+var_8]
		cmp	edx, 0FFh
		ja	short loc_1501
		mov	ebx, [esp+14h+var_4]
		cmp	ebx, 0FFh
		ja	short loc_1501
		cmp	[esp+14h+var_10], 0FFh
		ja	short loc_1501
		mov	eax, [esp+14h+arg_0]
		mov	[eax], cl
		mov	ecx, [esp+14h+var_10]
		mov	[eax+2], bl
		mov	[eax+1], dl
		mov	[eax+3], cl
		mov	eax, 1
		pop	ebx
		add	esp, 10h
		retn
; ---------------------------------------------------------------------------

loc_1501:				; CODE XREF: _ipv4_from_asc+44j
					; _ipv4_from_asc+50j ...
		xor	eax, eax
		pop	ebx
		add	esp, 10h
		retn
_ipv4_from_asc	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1508h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl ipv6_cb(char *Src, int, int)
_ipv6_cb	proc near		; DATA XREF: _ipv6_from_asc+22o

Src		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_8]
		mov	eax, [esi+10h]
		cmp	eax, 10h
		jnz	short loc_1519

loc_1515:				; CODE XREF: _ipv6_cb+30j _ipv6_cb+44j ...
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1519:				; CODE XREF: _ipv6_cb+Bj
		mov	ecx, [esp+4+arg_4]
		test	ecx, ecx
		jnz	short loc_1544
		mov	ecx, [esi+14h]
		cmp	ecx, 0FFFFFFFFh
		jnz	short loc_1536
		inc	dword ptr [esi+18h]
		mov	[esi+14h], eax
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1536:				; CODE XREF: _ipv6_cb+1Fj
		cmp	ecx, eax
		jnz	short loc_1515
		inc	dword ptr [esi+18h]
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1544:				; CODE XREF: _ipv6_cb+17j
		cmp	ecx, 4
		jle	short loc_1573
		cmp	eax, 0Ch
		jg	short loc_1515
		mov	edx, [esp+4+Src]
		cmp	byte ptr [edx+ecx], 0
		jnz	short loc_1515
		push	edx		; Src
		add	eax, esi
		push	eax		; int
		call	_ipv4_from_asc
		add	esp, 8
		test	eax, eax
		jz	short loc_1515
		add	dword ptr [esi+10h], 4
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1573:				; CODE XREF: _ipv6_cb+3Fj
		push	ecx
		push	[esp+8+Src]
		add	eax, esi
		push	eax
		call	_ipv6_hex
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_1515
		add	dword ptr [esi+10h], 2
		mov	eax, 1
		pop	esi
		retn
_ipv6_cb	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1594h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl ipv6_from_asc(void *Dst, int)
_ipv6_from_asc	proc near		; CODE XREF: _X509_check_ip_asc+39p
					; _a2i_IPADDRESS+31p ...

Src		= xmmword ptr -20h
var_10		= dword	ptr -10h
Size		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
Dst		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 20h ; ' '
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+20h+var_4], eax
		mov	eax, [esp+20h+arg_4]
		lea	ecx, [esp+20h+Src]
		push	ebx
		mov	ebx, [esp+24h+Dst]
		push	ecx
		push	offset _ipv6_cb
		push	0
		push	3Ah ; ':'
		push	eax
		mov	[esp+38h+var_10], 0
		mov	[esp+38h+Size],	0FFFFFFFFh
		mov	[esp+38h+var_8], 0
		call	_CONF_parse_list
		add	esp, 14h
		test	eax, eax
		jnz	short loc_15F4
		pop	ebx
		mov	ecx, [esp+20h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 20h
		retn
; ---------------------------------------------------------------------------

loc_15F4:				; CODE XREF: _ipv6_from_asc+4Ej
		push	esi
		mov	esi, [esp+28h+Size]
		push	edi
		cmp	esi, 0FFFFFFFFh
		jnz	short loc_161E
		cmp	[esp+2Ch+var_10], 10h
		jz	loc_16D8

loc_160A:				; CODE XREF: _ipv6_from_asc+91j
					; _ipv6_from_asc+9Aj ...
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebx
		mov	ecx, [esp+20h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 20h
		retn
; ---------------------------------------------------------------------------

loc_161E:				; CODE XREF: _ipv6_from_asc+69j
		mov	edi, [esp+2Ch+var_10]
		cmp	edi, 10h
		jz	short loc_160A
		mov	eax, [esp+2Ch+var_8]
		cmp	eax, 3
		jg	short loc_160A
		jnz	short loc_164A
		test	edi, edi
		jle	short loc_1673
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebx
		mov	ecx, [esp+20h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 20h
		retn
; ---------------------------------------------------------------------------

loc_164A:				; CODE XREF: _ipv6_from_asc+9Cj
		cmp	eax, 2
		jnz	short loc_166B
		test	esi, esi
		jz	short loc_1675
		cmp	esi, edi
		jz	short loc_1673
		pop	edi
		pop	esi
		xor	eax, eax
		pop	ebx
		mov	ecx, [esp+20h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 20h
		retn
; ---------------------------------------------------------------------------

loc_166B:				; CODE XREF: _ipv6_from_asc+B9j
		test	esi, esi
		jz	short loc_160A
		cmp	esi, edi
		jz	short loc_160A

loc_1673:				; CODE XREF: _ipv6_from_asc+A0j
					; _ipv6_from_asc+C1j
		test	esi, esi

loc_1675:				; CODE XREF: _ipv6_from_asc+BDj
		js	short loc_16D8
		push	esi		; Size
		lea	eax, [esp+30h+Src]
		push	eax		; Src
		push	ebx		; Dst
		call	_memcpy
		mov	eax, 10h
		sub	eax, edi
		push	eax		; Size
		lea	eax, [ebx+esi]
		push	0		; Val
		push	eax		; Dst
		call	_memset
		mov	edx, [esp+44h+var_10]
		add	esp, 18h
		mov	ecx, [esp+2Ch+Size]
		cmp	edx, ecx
		jz	short loc_16E0
		mov	eax, edx
		sub	ebx, edx
		sub	eax, ecx
		push	eax		; Size
		lea	eax, [esp+30h+Src]
		add	eax, ecx
		push	eax		; Src
		lea	eax, [ecx+10h]
		add	eax, ebx
		push	eax		; Dst
		call	_memcpy
		add	esp, 0Ch
		mov	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [esp+20h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 20h
		retn
; ---------------------------------------------------------------------------

loc_16D8:				; CODE XREF: _ipv6_from_asc+70j
					; _ipv6_from_asc:loc_1675j
		movups	xmm0, [esp+2Ch+Src]
		movups	xmmword	ptr [ebx], xmm0

loc_16E0:				; CODE XREF: _ipv6_from_asc+10Fj
		mov	ecx, [esp+2Ch+var_4]
		mov	eax, 1
		pop	edi
		pop	esi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 20h
		retn
_ipv6_from_asc	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 16F8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_ipv6_hex	proc near		; CODE XREF: _ipv6_cb+73p

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		push	esi
		mov	esi, [esp+4+arg_8]
		xor	edx, edx
		cmp	esi, 4
		jle	short loc_1708
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1708:				; CODE XREF: _ipv6_hex+Aj
		push	edi
		test	esi, esi
		jz	short loc_1752
		mov	edi, [esp+8+arg_4]
		nop	dword ptr [eax+00000000h]

loc_1718:				; CODE XREF: _ipv6_hex+58j
		mov	cl, [edi]
		lea	edi, [edi+1]
		dec	esi
		shl	edx, 4
		lea	eax, [ecx-30h]
		cmp	al, 9
		ja	short loc_1730
		movzx	eax, cl
		sub	eax, 30h ; '0'
		jmp	short loc_174C
; ---------------------------------------------------------------------------

loc_1730:				; CODE XREF: _ipv6_hex+2Ej
		lea	eax, [ecx-41h]
		cmp	al, 5
		ja	short loc_173F
		movzx	eax, cl
		sub	eax, 37h ; '7'
		jmp	short loc_174C
; ---------------------------------------------------------------------------

loc_173F:				; CODE XREF: _ipv6_hex+3Dj
		lea	eax, [ecx-61h]
		cmp	al, 5
		ja	short loc_1768
		movzx	eax, cl
		sub	eax, 57h ; 'W'

loc_174C:				; CODE XREF: _ipv6_hex+36j
					; _ipv6_hex+45j
		or	edx, eax
		test	esi, esi
		jnz	short loc_1718

loc_1752:				; CODE XREF: _ipv6_hex+13j
		mov	eax, [esp+8+arg_0]
		mov	ecx, edx
		shr	ecx, 8
		pop	edi
		pop	esi
		mov	[eax], cl
		mov	[eax+1], dl
		mov	eax, 1
		retn
; ---------------------------------------------------------------------------

loc_1768:				; CODE XREF: _ipv6_hex+4Cj
		pop	edi
		xor	eax, eax
		pop	esi
		retn
_ipv6_hex	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1770h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl name_cmp(char *Str1, char	*Str2)
		public _name_cmp
_name_cmp	proc near

Str1		= dword	ptr  4
Str2		= dword	ptr  8

		mov	ecx, [esp+Str2]
		push	esi
		mov	esi, ecx
		push	edi
		lea	edx, [esi+1]
		nop	dword ptr [eax+eax+00h]

loc_1780:				; CODE XREF: _name_cmp+15j
		mov	al, [esi]
		inc	esi
		test	al, al
		jnz	short loc_1780
		mov	edi, [esp+8+Str1]
		sub	esi, edx
		push	esi		; MaxCount
		push	ecx		; Str2
		push	edi		; Str1
		call	dword ptr ds:__imp__strncmp
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_17B2
		mov	al, [esi+edi]
		test	al, al
		jz	short loc_17B0
		cmp	al, 2Eh	; '.'
		jz	short loc_17B0
		pop	edi
		mov	eax, 1
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_17B0:				; CODE XREF: _name_cmp+32j
					; _name_cmp+36j
		xor	eax, eax

loc_17B2:				; CODE XREF: _name_cmp+2Bj
		pop	edi
		pop	esi
		retn
_name_cmp	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 17B8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _s2i_ASN1_INTEGER
_s2i_ASN1_INTEGER proc near		; CODE XREF: _X509V3_get_value_int+Ap

var_4		= dword	ptr -4
arg_4		= dword	ptr  8

		mov	eax, 4
		call	__chkstk
		push	esi
		mov	esi, [esp+8+arg_4]
		mov	[esp+8+var_4], 0
		test	esi, esi
		jnz	short loc_17F0
		push	0B6h ; '¶'
		push	offset ??_C@_0BJ@BDGEMPMC@?4?2crypto?2x509v3?2v3_utl?4c?$AA@ ; ".\\crypto\\x509v3\\v3_utl.c"
		push	6Dh ; 'm'
		push	6Ch ; 'l'
		push	22h ; '"'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_17F0:				; CODE XREF: _s2i_ASN1_INTEGER+19j
		push	edi
		call	_BN_new
		cmp	byte ptr [esi],	2Dh ; '-'
		mov	[esp+0Ch+var_4], eax
		jnz	short loc_1807
		inc	esi
		mov	edi, 1
		jmp	short loc_1809
; ---------------------------------------------------------------------------

loc_1807:				; CODE XREF: _s2i_ASN1_INTEGER+45j
		xor	edi, edi

loc_1809:				; CODE XREF: _s2i_ASN1_INTEGER+4Dj
		cmp	byte ptr [esi],	30h ; '0'
		jnz	short loc_1829
		mov	al, [esi+1]
		cmp	al, 78h	; 'x'
		jz	short loc_1819
		cmp	al, 58h	; 'X'
		jnz	short loc_1829

loc_1819:				; CODE XREF: _s2i_ASN1_INTEGER+5Bj
		add	esi, 2
		lea	eax, [esp+0Ch+var_4]
		push	esi
		push	eax
		call	_BN_hex2bn
		jmp	short loc_1834
; ---------------------------------------------------------------------------

loc_1829:				; CODE XREF: _s2i_ASN1_INTEGER+54j
					; _s2i_ASN1_INTEGER+5Fj
		lea	eax, [esp+0Ch+var_4]
		push	esi
		push	eax
		call	_BN_dec2bn

loc_1834:				; CODE XREF: _s2i_ASN1_INTEGER+6Fj
		add	esp, 8
		test	eax, eax
		jz	short loc_189A
		cmp	byte ptr [eax+esi], 0
		jnz	short loc_189A
		mov	eax, [esp+0Ch+var_4]
		test	edi, edi
		jz	short loc_1851
		xor	ecx, ecx
		cmp	[eax+4], ecx
		cmovz	edi, ecx

loc_1851:				; CODE XREF: _s2i_ASN1_INTEGER+8Fj
		push	0
		push	eax
		call	_BN_to_ASN1_INTEGER
		push	[esp+14h+var_4]
		mov	esi, eax
		call	_BN_free
		add	esp, 0Ch
		test	esi, esi
		jnz	short loc_1889
		push	0D8h ; 'Ø'
		push	offset ??_C@_0BJ@BDGEMPMC@?4?2crypto?2x509v3?2v3_utl?4c?$AA@ ; ".\\crypto\\x509v3\\v3_utl.c"
		push	65h ; 'e'
		push	6Ch ; 'l'
		push	22h ; '"'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_1889:				; CODE XREF: _s2i_ASN1_INTEGER+B1j
		test	edi, edi
		jz	short loc_1894
		or	dword ptr [esi+4], 100h

loc_1894:				; CODE XREF: _s2i_ASN1_INTEGER+D3j
		pop	edi
		mov	eax, esi
		pop	esi
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_189A:				; CODE XREF: _s2i_ASN1_INTEGER+81j
					; _s2i_ASN1_INTEGER+87j
		push	[esp+0Ch+var_4]
		call	_BN_free
		push	0CDh ; 'Í'
		push	offset ??_C@_0BJ@BDGEMPMC@?4?2crypto?2x509v3?2v3_utl?4c?$AA@ ; ".\\crypto\\x509v3\\v3_utl.c"
		push	64h ; 'd'
		push	6Ch ; 'l'
		push	22h ; '"'
		call	_ERR_put_error
		add	esp, 18h
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ecx
		retn
_s2i_ASN1_INTEGER endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 18C4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_sk_strcmp	proc near		; DATA XREF: _append_ia5+27o
					; _get_email+57o

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_4]
		mov	ecx, [eax]
		mov	eax, [esp+arg_0]
		mov	eax, [eax]
		nop	dword ptr [eax+00h]

loc_18D4:				; CODE XREF: _sk_strcmp+2Aj
		mov	dl, [eax]
		cmp	dl, [ecx]
		jnz	short loc_18F3
		test	dl, dl
		jz	short loc_18F0
		mov	dl, [eax+1]
		cmp	dl, [ecx+1]
		jnz	short loc_18F3
		add	eax, 2
		add	ecx, 2
		test	dl, dl
		jnz	short loc_18D4

loc_18F0:				; CODE XREF: _sk_strcmp+18j
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_18F3:				; CODE XREF: _sk_strcmp+14j
					; _sk_strcmp+20j
		sbb	eax, eax
		or	eax, 1
		retn
_sk_strcmp	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 18FCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_skip_prefix	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		push	ebx
		mov	ebx, [esp+4+arg_10]
		push	ebp
		mov	ebp, [esp+8+arg_4]
		push	edi
		mov	edi, [esp+0Ch+arg_0]
		mov	eax, [ebp+0]
		mov	ecx, [edi]
		test	ebx, 8000h
		jz	short loc_1941
		push	esi
		mov	esi, [esp+10h+arg_C]
		cmp	eax, esi
		jbe	short loc_1939

loc_1921:				; CODE XREF: _skip_prefix+39j
		mov	dl, [ecx]
		test	dl, dl
		jz	short loc_1937
		test	bl, 10h
		jz	short loc_1931
		cmp	dl, 2Eh	; '.'
		jz	short loc_1937

loc_1931:				; CODE XREF: _skip_prefix+2Ej
		dec	eax
		inc	ecx
		cmp	eax, esi
		ja	short loc_1921

loc_1937:				; CODE XREF: _skip_prefix+29j
					; _skip_prefix+33j
		cmp	eax, esi

loc_1939:				; CODE XREF: _skip_prefix+23j
		pop	esi
		jnz	short loc_1941
		mov	[edi], ecx
		mov	[ebp+0], eax

loc_1941:				; CODE XREF: _skip_prefix+1Aj
					; _skip_prefix+3Ej
		pop	edi
		pop	ebp
		pop	ebx
		retn
_skip_prefix	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1948h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int sscanf(const char	*Src, const char *Format, ...)
		public _sscanf
_sscanf		proc near		; CODE XREF: _ipv4_from_asc+26p

Src		= dword	ptr  4
Format		= dword	ptr  8
arg_8		= byte ptr  0Ch

		lea	eax, [esp+arg_8]
		push	eax
		push	0
		push	[esp+8+Format]
		push	0FFFFFFFFh
		push	[esp+10h+Src]
		call	___local_stdio_scanf_options
		push	dword ptr [eax+4]
		push	dword ptr [eax]
		call	dword ptr ds:__imp____stdio_common_vsscanf
		add	esp, 1Ch
		retn
_sscanf		endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1970h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_str_free	proc near		; DATA XREF: _X509_email_freeo
					; _get_email:loc_132Do
		jmp	_CRYPTO_free
_str_free	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1978h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _string_to_hex
_string_to_hex	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		test	esi, esi
		jnz	short loc_199D
		push	1BAh
		push	offset ??_C@_0BJ@BDGEMPMC@?4?2crypto?2x509v3?2v3_utl?4c?$AA@ ; ".\\crypto\\x509v3\\v3_utl.c"
		push	6Bh ; 'k'
		push	71h ; 'q'
		push	22h ; '"'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_199D:				; CODE XREF: _string_to_hex+7j
		mov	ecx, esi
		lea	edx, [ecx+1]
		nop	word ptr [eax+eax+00h]

loc_19A8:				; CODE XREF: _string_to_hex+35j
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_19A8
		push	edi
		sub	ecx, edx
		push	1BDh
		sar	ecx, 1
		push	offset ??_C@_0BJ@BDGEMPMC@?4?2crypto?2x509v3?2v3_utl?4c?$AA@ ; ".\\crypto\\x509v3\\v3_utl.c"
		push	ecx
		call	_CRYPTO_malloc
		mov	edi, eax
		add	esp, 0Ch
		mov	[esp+8+arg_0], edi
		test	edi, edi
		jnz	short loc_19EE

$err$34:
		push	1EDh
		push	offset ??_C@_0BJ@BDGEMPMC@?4?2crypto?2x509v3?2v3_utl?4c?$AA@ ; ".\\crypto\\x509v3\\v3_utl.c"
		push	41h ; 'A'
		push	71h ; 'q'
		push	22h ; '"'
		call	_ERR_put_error
		add	esp, 14h
		xor	eax, eax
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_19EE:				; CODE XREF: _string_to_hex+57j
		cmp	byte ptr [esi],	0
		push	ebx
		push	ebp
		mov	ebp, edi
		jz	loc_1A8A

loc_19FB:				; CODE XREF: _string_to_hex+108j
		mov	bl, [esi]
		inc	esi
		cmp	bl, 3Ah	; ':'
		jz	short loc_1A7D
		mov	bh, [esi]
		inc	esi
		test	bh, bh
		jz	loc_1AC5
		movzx	edi, bl
		push	edi		; C
		call	dword ptr ds:__imp__isupper
		add	esp, 4
		test	eax, eax
		jz	short loc_1A2B
		push	edi		; C
		call	dword ptr ds:__imp__tolower
		add	esp, 4
		mov	bl, al

loc_1A2B:				; CODE XREF: _string_to_hex+A5j
		movzx	edi, bh
		push	edi		; C
		call	dword ptr ds:__imp__isupper
		add	esp, 4
		test	eax, eax
		jz	short loc_1A48
		push	edi		; C
		call	dword ptr ds:__imp__tolower
		add	esp, 4
		mov	bh, al

loc_1A48:				; CODE XREF: _string_to_hex+C2j
		lea	eax, [ebx-30h]
		cmp	al, 9
		ja	short loc_1A53
		mov	bl, al
		jmp	short loc_1A5D
; ---------------------------------------------------------------------------

loc_1A53:				; CODE XREF: _string_to_hex+D5j
		lea	eax, [ebx-61h]
		cmp	al, 5
		ja	short $badhex$35
		add	bl, 0A9h ; '©'

loc_1A5D:				; CODE XREF: _string_to_hex+D9j
		mov	al, bh
		sub	al, 30h	; '0'
		cmp	al, 9
		ja	short loc_1A69
		mov	bh, al
		jmp	short loc_1A74
; ---------------------------------------------------------------------------

loc_1A69:				; CODE XREF: _string_to_hex+EBj
		mov	al, bh
		sub	al, 61h	; 'a'
		cmp	al, 5
		ja	short $badhex$35
		add	bh, 0A9h ; '©'

loc_1A74:				; CODE XREF: _string_to_hex+EFj
		shl	bl, 4
		or	bl, bh
		mov	[ebp+0], bl
		inc	ebp

loc_1A7D:				; CODE XREF: _string_to_hex+89j
		cmp	byte ptr [esi],	0
		jnz	loc_19FB
		mov	edi, [esp+10h+arg_0]

loc_1A8A:				; CODE XREF: _string_to_hex+7Dj
		mov	eax, [esp+10h+arg_4]
		test	eax, eax
		jz	short loc_1A96
		sub	ebp, edi
		mov	[eax], ebp

loc_1A96:				; CODE XREF: _string_to_hex+118j
		pop	ebp
		pop	ebx
		mov	eax, edi
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

$badhex$35:				; CODE XREF: _string_to_hex+E0j
					; _string_to_hex+F7j
		push	[esp+10h+arg_0]
		call	_CRYPTO_free
		push	1F2h
		push	offset ??_C@_0BJ@BDGEMPMC@?4?2crypto?2x509v3?2v3_utl?4c?$AA@ ; ".\\crypto\\x509v3\\v3_utl.c"
		push	71h ; 'q'
		push	71h ; 'q'
		push	22h ; '"'
		call	_ERR_put_error
		add	esp, 18h
		xor	eax, eax
		pop	ebp
		pop	ebx
		pop	edi
		pop	esi
		retn
; ---------------------------------------------------------------------------

loc_1AC5:				; CODE XREF: _string_to_hex+90j
		push	1CBh
		push	offset ??_C@_0BJ@BDGEMPMC@?4?2crypto?2x509v3?2v3_utl?4c?$AA@ ; ".\\crypto\\x509v3\\v3_utl.c"
		push	70h ; 'p'
		push	71h ; 'q'
		push	22h ; '"'
		call	_ERR_put_error
		push	[esp+24h+arg_0]
		call	_CRYPTO_free
		add	esp, 18h
		xor	eax, eax
		pop	ebp
		pop	ebx
		pop	edi
		pop	esi
		retn
_string_to_hex	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1AF0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_strip_spaces	proc near		; CODE XREF: _X509V3_parse_list+76p
					; _X509V3_parse_list+A9p ...

arg_0		= dword	ptr  4

		push	ebx
		mov	ebx, dword ptr ds:__imp__isspace
		push	esi
		mov	esi, [esp+8+arg_0]
		cmp	byte ptr [esi],	0
		jz	short loc_1B1E

loc_1B01:				; CODE XREF: _strip_spaces+22j
		movzx	eax, byte ptr [esi]
		push	eax		; C
		call	ebx ; __imp__isspace
		add	esp, 4
		test	eax, eax
		jz	short loc_1B19
		inc	esi
		cmp	byte ptr [esi],	0
		jnz	short loc_1B01
		pop	esi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1B19:				; CODE XREF: _strip_spaces+1Cj
		cmp	byte ptr [esi],	0
		jnz	short loc_1B23

loc_1B1E:				; CODE XREF: _strip_spaces+Fj
		pop	esi
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1B23:				; CODE XREF: _strip_spaces+2Cj
		mov	ecx, esi
		lea	edx, [ecx+1]

loc_1B28:				; CODE XREF: _strip_spaces+3Dj
		mov	al, [ecx]
		inc	ecx
		test	al, al
		jnz	short loc_1B28
		push	edi
		sub	ecx, edx
		lea	edi, [esi-1]
		add	edi, ecx
		cmp	edi, esi
		jz	short loc_1B67
		nop	dword ptr [eax+eax+00h]

loc_1B40:				; CODE XREF: _strip_spaces+60j
		movzx	eax, byte ptr [edi]
		push	eax		; C
		call	ebx ; __imp__isspace
		add	esp, 4
		test	eax, eax
		jz	short loc_1B5F
		dec	edi
		cmp	edi, esi
		jnz	short loc_1B40
		xor	eax, eax
		cmp	[esi], al
		pop	edi
		cmovz	esi, eax
		mov	eax, esi
		pop	esi
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1B5F:				; CODE XREF: _strip_spaces+5Bj
		cmp	esi, edi
		jz	short loc_1B67
		mov	byte ptr [edi+1], 0

loc_1B67:				; CODE XREF: _strip_spaces+49j
					; _strip_spaces+71j
		xor	eax, eax
		cmp	[esi], al
		pop	edi
		cmovz	esi, eax
		mov	eax, esi
		pop	esi
		pop	ebx
		retn
_strip_spaces	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1B74h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl valid_star(char *Str1, int, char)
_valid_star	proc near		; CODE XREF: _equal_wildcard+24p

var_4		= dword	ptr -4
Str1		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= byte ptr  0Ch

		mov	eax, 4
		call	__chkstk
		mov	ecx, [esp+4+arg_4]
		xor	edx, edx
		push	ebx
		push	ebp
		xor	ebp, ebp
		mov	[esp+0Ch+var_4], edx
		push	esi
		xor	esi, esi
		push	edi
		lea	ebx, [ebp+1]
		test	ecx, ecx
		jz	loc_1C89
		mov	edi, [esp+14h+Str1]
		nop	dword ptr [eax+eax+00h]

loc_1BA4:				; CODE XREF: _valid_star+10Fj
		mov	al, [edi]
		cmp	al, 2Ah	; '*'
		jnz	short loc_1C13
		mov	eax, [esp+14h+arg_4]
		mov	ecx, ebx
		dec	eax
		and	ecx, 1
		cmp	esi, eax
		jz	short loc_1BC7
		mov	eax, [esp+14h+Str1]
		cmp	byte ptr [esi+eax+1], 2Eh ; '.'
		jz	short loc_1BC7
		xor	eax, eax
		jmp	short loc_1BCC
; ---------------------------------------------------------------------------

loc_1BC7:				; CODE XREF: _valid_star+42j
					; _valid_star+4Dj
		mov	eax, 1

loc_1BCC:				; CODE XREF: _valid_star+51j
		test	ebp, ebp
		jnz	loc_1C9B
		test	bl, 8
		jnz	loc_1C9B
		test	edx, edx
		jnz	loc_1C9B
		test	[esp+14h+arg_8], 4
		jz	short loc_1BFC
		test	ecx, ecx
		jz	loc_1C9B
		test	eax, eax
		jz	loc_1C9B

loc_1BFC:				; CODE XREF: _valid_star+76j
		test	ecx, ecx
		jnz	short loc_1C08
		test	eax, eax
		jz	loc_1C9B

loc_1C08:				; CODE XREF: _valid_star+8Aj
		mov	ecx, [esp+14h+arg_4]
		mov	ebp, edi
		and	ebx, 0FFFFFFFEh
		jmp	short loc_1C7F
; ---------------------------------------------------------------------------

loc_1C13:				; CODE XREF: _valid_star+34j
		cmp	al, 61h	; 'a'
		jb	short loc_1C1B
		cmp	al, 7Ah	; 'z'
		jbe	short loc_1C2B

loc_1C1B:				; CODE XREF: _valid_star+A1j
		cmp	al, 41h	; 'A'
		jb	short loc_1C23
		cmp	al, 5Ah	; 'Z'
		jbe	short loc_1C2B

loc_1C23:				; CODE XREF: _valid_star+A9j
		cmp	al, 30h	; '0'
		jb	short loc_1C5E
		cmp	al, 39h	; '9'
		ja	short loc_1C5E

loc_1C2B:				; CODE XREF: _valid_star+A5j
					; _valid_star+ADj
		test	bl, 1
		jz	short loc_1C59
		mov	eax, ecx
		sub	eax, esi
		cmp	eax, 4
		jb	short loc_1C59
		push	4		; MaxCount
		push	offset ??_C@_04DLDJKMIA@xn?9?9?$AA@ ; "xn--"
		push	edi		; Str1
		call	dword ptr ds:__imp___strnicmp
		mov	edx, [esp+20h+var_4]
		add	esp, 0Ch
		mov	ecx, [esp+14h+arg_4]
		test	eax, eax
		jnz	short loc_1C59
		or	ebx, 8

loc_1C59:				; CODE XREF: _valid_star+BAj
					; _valid_star+C3j ...
		and	ebx, 0FFFFFFFAh
		jmp	short loc_1C7F
; ---------------------------------------------------------------------------

loc_1C5E:				; CODE XREF: _valid_star+B1j
					; _valid_star+B5j
		cmp	al, 2Eh	; '.'
		jnz	short loc_1C73
		test	bl, 5
		jnz	short loc_1C9B
		inc	edx
		mov	ebx, 1
		mov	[esp+14h+var_4], edx
		jmp	short loc_1C7F
; ---------------------------------------------------------------------------

loc_1C73:				; CODE XREF: _valid_star+ECj
		cmp	al, 2Dh	; '-'
		jnz	short loc_1C9B
		test	bl, 1
		jnz	short loc_1C9B
		or	ebx, 4

loc_1C7F:				; CODE XREF: _valid_star+9Dj
					; _valid_star+E8j ...
		inc	esi
		inc	edi
		cmp	esi, ecx
		jb	loc_1BA4

loc_1C89:				; CODE XREF: _valid_star+21j
		test	bl, 5
		jnz	short loc_1C9B
		cmp	edx, 2
		jl	short loc_1C9B
		pop	edi
		pop	esi
		mov	eax, ebp
		pop	ebp
		pop	ebx
		pop	ecx
		retn
; ---------------------------------------------------------------------------

loc_1C9B:				; CODE XREF: _valid_star+5Aj
					; _valid_star+63j ...
		pop	edi
		pop	esi
		pop	ebp
		xor	eax, eax
		pop	ebx
		pop	ecx
		retn
_valid_star	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1CA4h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl wildcard_match(int, int, int, int, char *Str1, int, int)
_wildcard_match	proc near		; CODE XREF: _equal_wildcard+5Ep

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
Str1		= dword	ptr  14h
arg_14		= dword	ptr  18h
arg_18		= dword	ptr  1Ch

		mov	eax, [esp+arg_C]
		push	ebx
		mov	ebx, [esp+4+arg_4]
		add	eax, ebx
		push	ebp
		xor	ebp, ebp
		cmp	[esp+8+arg_14],	eax
		jnb	short loc_1CBD
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1CBD:				; CODE XREF: _wildcard_match+12j
		push	edi
		push	[esp+0Ch+arg_18]
		mov	edi, [esp+10h+Str1]
		push	ebx
		push	edi
		push	ebx
		push	[esp+1Ch+arg_0]
		call	_equal_nocase
		add	esp, 14h
		test	eax, eax
		jnz	short loc_1CDD
		pop	edi
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1CDD:				; CODE XREF: _wildcard_match+33j
		mov	eax, [esp+0Ch+arg_C]
		push	esi
		push	[esp+10h+arg_18]
		lea	esi, [ebx+edi]
		sub	edi, eax
		add	edi, [esp+14h+arg_14]
		push	eax
		push	[esp+18h+arg_8]
		push	eax
		push	edi
		call	_equal_nocase
		add	esp, 14h
		test	eax, eax
		jz	loc_1D89
		test	ebx, ebx
		jnz	short loc_1D23
		mov	eax, [esp+10h+arg_8]
		cmp	byte ptr [eax],	2Eh ; '.'
		jnz	short loc_1D23
		cmp	esi, edi
		jz	short loc_1D89
		test	byte ptr [esp+10h+arg_18], 8
		jz	short loc_1D42
		lea	ebp, [ebx+1]
		jmp	short loc_1D42
; ---------------------------------------------------------------------------

loc_1D23:				; CODE XREF: _wildcard_match+64j
					; _wildcard_match+6Dj
		cmp	[esp+10h+arg_14], 4
		jb	short loc_1D42
		push	4		; MaxCount
		push	offset ??_C@_04DLDJKMIA@xn?9?9?$AA@ ; "xn--"
		push	[esp+18h+Str1]	; Str1
		call	dword ptr ds:__imp___strnicmp
		add	esp, 0Ch
		test	eax, eax
		jz	short loc_1D89

loc_1D42:				; CODE XREF: _wildcard_match+78j
					; _wildcard_match+7Dj ...
		lea	eax, [esi+1]
		cmp	edi, eax
		jnz	short loc_1D4E
		cmp	byte ptr [esi],	2Ah ; '*'
		jz	short loc_1D7F

loc_1D4E:				; CODE XREF: _wildcard_match+A3j
		cmp	esi, edi
		jz	short loc_1D7F
		xchg	ax, ax

loc_1D54:				; CODE XREF: _wildcard_match+D9j
		mov	al, [esi]
		cmp	al, 30h	; '0'
		jb	short loc_1D5E
		cmp	al, 39h	; '9'
		jbe	short loc_1D7A

loc_1D5E:				; CODE XREF: _wildcard_match+B4j
		cmp	al, 41h	; 'A'
		jb	short loc_1D66
		cmp	al, 5Ah	; 'Z'
		jbe	short loc_1D7A

loc_1D66:				; CODE XREF: _wildcard_match+BCj
		cmp	al, 61h	; 'a'
		jb	short loc_1D6E
		cmp	al, 7Ah	; 'z'
		jbe	short loc_1D7A

loc_1D6E:				; CODE XREF: _wildcard_match+C4j
		cmp	al, 2Dh	; '-'
		jz	short loc_1D7A
		test	ebp, ebp
		jz	short loc_1D89
		cmp	al, 2Eh	; '.'
		jnz	short loc_1D89

loc_1D7A:				; CODE XREF: _wildcard_match+B8j
					; _wildcard_match+C0j ...
		inc	esi
		cmp	esi, edi
		jnz	short loc_1D54

loc_1D7F:				; CODE XREF: _wildcard_match+A8j
					; _wildcard_match+ACj
		pop	esi
		pop	edi
		pop	ebp
		mov	eax, 1
		pop	ebx
		retn
; ---------------------------------------------------------------------------

loc_1D89:				; CODE XREF: _wildcard_match+5Cj
					; _wildcard_match+71j ...
		pop	esi
		pop	edi
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
_wildcard_match	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1D90h
; COMDAT (pick any)
		public ??_C@_0BJ@BDGEMPMC@?4?2crypto?2x509v3?2v3_utl?4c?$AA@
; `string'
??_C@_0BJ@BDGEMPMC@?4?2crypto?2x509v3?2v3_utl?4c?$AA@ db '.\crypto\x509v3\v3_utl.c',0
					; DATA XREF: _X509V3_add_value+3Ao
					; _X509V3_add_value+8Do ...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1DACh
; COMDAT (pick any)
		public ??_C@_04HCDDPBNL@TRUE?$AA@
; `string'
??_C@_04HCDDPBNL@TRUE?$AA@ db 'TRUE',0  ; DATA XREF: _X509V3_add_value_bool+7o
					; _X509V3_add_value_bool_nf+7o	...
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1DB4h
; COMDAT (pick any)
		public ??_C@_05MAJJAKPI@FALSE?$AA@
; `string'
??_C@_05MAJJAKPI@FALSE?$AA@ db 'FALSE',0 ; DATA XREF: _X509V3_add_value_bool:loc_19Co
					; _X509V3_get_value_bool+151o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1DBCh
; COMDAT (pick any)
		public ??_C@_04LOAJBDKD@true?$AA@
; `string'
??_C@_04LOAJBDKD@true?$AA@ db 'true',0  ; DATA XREF: _X509V3_get_value_bool+45o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1DC4h
; COMDAT (pick any)
		public ??_C@_01NFFPALBN@Y?$AA@
; `string'
??_C@_01NFFPALBN@Y?$AA@	db 59h,	0	; DATA XREF: _X509V3_get_value_bool+7Do
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1DC8h
; COMDAT (pick any)
		public ??_C@_01EANLCPLP@y?$AA@
; `string'
??_C@_01EANLCPLP@y?$AA@	db 79h,	0	; DATA XREF: _X509V3_get_value_bool+B1o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1DCCh
; COMDAT (pick any)
		public ??_C@_03IPHJCBHH@YES?$AA@
; `string'
??_C@_03IPHJCBHH@YES?$AA@ dd 534559h	; DATA XREF: _X509V3_get_value_bool+E5o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1DD0h
; COMDAT (pick any)
		public ??_C@_03ICICOMAL@yes?$AA@
; `string'
??_C@_03ICICOMAL@yes?$AA@ dd 736579h	; DATA XREF: _X509V3_get_value_bool+11Do
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1DD4h
; COMDAT (pick any)
		public ??_C@_05LAPONLG@false?$AA@
; `string'
??_C@_05LAPONLG@false?$AA@ db 'false',0 ; DATA XREF: _X509V3_get_value_bool+185o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1DDCh
; COMDAT (pick any)
		public ??_C@_01NANMIPIL@N?$AA@
; `string'
??_C@_01NANMIPIL@N?$AA@	db 4Eh,	0	; DATA XREF: _X509V3_get_value_bool+1BDo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1DE0h
; COMDAT (pick any)
		public ??_C@_01EFFIKLCJ@n?$AA@
; `string'
??_C@_01EFFIKLCJ@n?$AA@	db 6Eh,	0	; DATA XREF: _X509V3_get_value_bool+1F1o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1DE4h
; COMDAT (pick any)
		public ??_C@_02NFLNFON@NO?$AA@
; `string'
??_C@_02NFLNFON@NO?$AA@	db 4Eh,	4Fh, 0	; DATA XREF: _X509V3_get_value_bool+221o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1DE8h
; COMDAT (pick any)
		public ??_C@_02KAJCLHKP@no?$AA@
; `string'
??_C@_02KAJCLHKP@no?$AA@ db 6Eh, 6Fh, 0	; DATA XREF: _X509V3_get_value_bool+251o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1DECh
; COMDAT (pick any)
		public ??_C@_07BDICHDDB@?0value?3?$AA@
; `string'
??_C@_07BDICHDDB@?0value?3?$AA@	db ',value:',0 ; DATA XREF: _X509V3_get_value_bool+2BBo
					; _X509V3_get_value_int+1Bo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1DF4h
; COMDAT (pick any)
		public ??_C@_06FONLLLNC@?0name?3?$AA@
; `string'
??_C@_06FONLLLNC@?0name?3?$AA@ db ',name:',0 ; DATA XREF: _X509V3_get_value_bool+2C3o
					; _X509V3_get_value_int+23o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1DFCh
; COMDAT (pick any)
		public ??_C@_08PCLJGJAL@section?3?$AA@
; `string'
??_C@_08PCLJGJAL@section?3?$AA@	db 'section:',0 ; DATA XREF: _X509V3_get_value_bool+2CAo
					; _X509V3_get_value_int+2Ao
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1E08h
; COMDAT (pick any)
		public ??_C@_04DLDJKMIA@xn?9?9?$AA@
; char `string'[]
??_C@_04DLDJKMIA@xn?9?9?$AA@ db	'xn--',0 ; DATA XREF: _valid_star+C7o
					; _wildcard_match+88o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 1E10h
; COMDAT (pick any)
		public ??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@
; char `string'[]
??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@ db '%d.%d.%d.%d',0
					; DATA XREF: _ipv4_from_asc+1Do
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __imp____stdio_common_vsscanf:near ; CODE	XREF: __vsscanf_l+1Cp
					; _sscanf+1Bp
					; DATA XREF: ...
; int __cdecl _isupper(int C)
		extrn __imp__isupper:near ; CODE XREF: _string_to_hex+9Ap
					; _string_to_hex+B7p
					; DATA XREF: ...
; int __cdecl _isspace(int C)
		extrn __imp__isspace:near ; CODE XREF: _strip_spaces+15p
					; _strip_spaces+54p
					; DATA XREF: ...
; int __cdecl _tolower(int C)
		extrn __imp__tolower:near ; CODE XREF: _string_to_hex+A8p
					; _string_to_hex+C5p
					; DATA XREF: ...
; void *__cdecl	_memchr(const void *Buf, int Val, size_t MaxCount)
		extrn __imp__memchr:near ; CODE	XREF: _X509_check_email+5Dp
					; _X509_check_host+5Fp
					; DATA XREF: ...
; char *__cdecl	_strchr(const char *Str, int Val)
		extrn __imp__strchr:near ; CODE	XREF: _X509_check_ip_asc+26p
					; _a2i_IPADDRESS+1Ep ...
; int __cdecl _strncmp(const char *Str1, const char *Str2, size_t MaxCount)
		extrn __imp__strncmp:near ; CODE XREF: _name_cmp+20p
					; DATA XREF: _name_cmp+20r
; int __cdecl __strnicmp(const char *Str1, const char *Str2, size_t MaxCount)
		extrn __imp___strnicmp:near ; CODE XREF: _valid_star+CDp
					; _wildcard_match+91p
					; DATA XREF: ...
		extrn _sk_num:near	; CODE XREF: _X509V3_NAME_from_section+15p
					; _X509V3_NAME_from_section+84p ...
		extrn _sk_value:near	; CODE XREF: _X509V3_NAME_from_section+23p
					; _X509_get1_ocsp+42p ...
		extrn _sk_new:near	; CODE XREF: _append_ia5+2Cp
					; _get_email+5Cp
		extrn _sk_new_null:near	; CODE XREF: _X509V3_add_value+59p
		extrn _sk_pop_free:near	; CODE XREF: _X509V3_parse_list+16Dp
					; _X509_REQ_get1_email+30p ...
		extrn _sk_find:near	; CODE XREF: _append_ia5+3Fp
					; _get_email+76p
		extrn _sk_push:near	; CODE XREF: _X509V3_add_value+75p
					; _append_ia5+5Ep ...
		extrn _CRYPTO_malloc:near ; CODE XREF: _X509V3_add_value+41p
					; _hex_to_string+26p ...
		extrn _CRYPTO_free:near	; CODE XREF: _X509V3_add_value+A5p
					; _X509V3_add_value+B2p ...
		extrn _BUF_strdup:near	; CODE XREF: _X509V3_add_value+13p
					; _X509V3_add_value+2Ap ...
		extrn _BUF_strndup:near	; CODE XREF: _do_check_string+D1p
					; _do_check_string+127p
		extrn _ERR_put_error:near ; CODE XREF: _X509V3_add_value+98p
					; _X509V3_add_value_int+41p ...
		extrn _ERR_add_error_data:near ; CODE XREF: _X509V3_get_value_bool+2D1p
					; _X509V3_get_value_int+31p
		extrn _CONF_parse_list:near ; CODE XREF: _ipv6_from_asc+44p
		extrn _BN_new:near	; CODE XREF: _s2i_ASN1_INTEGER+39p
		extrn _BN_free:near	; CODE XREF: _X509V3_add_value_int+4Ap
					; _i2s_ASN1_ENUMERATED+47p ...
		extrn _BN_bn2dec:near	; CODE XREF: _X509V3_add_value_int+23p
					; _i2s_ASN1_ENUMERATED+20p ...
		extrn _BN_hex2bn:near	; CODE XREF: _s2i_ASN1_INTEGER+6Ap
		extrn _BN_dec2bn:near	; CODE XREF: _s2i_ASN1_INTEGER+77p
		extrn _ASN1_OCTET_STRING_new:near ; CODE XREF: _a2i_IPADDRESS:loc_AC9p
					; _a2i_IPADDRESS_NC+B4p
		extrn _ASN1_OCTET_STRING_free:near ; CODE XREF:	_a2i_IPADDRESS+74p
					; _a2i_IPADDRESS_NC+EAp
		extrn _ASN1_OCTET_STRING_set:near ; CODE XREF: _a2i_IPADDRESS+67p
					; _a2i_IPADDRESS_NC+C9p
		extrn _BN_to_ASN1_INTEGER:near ; CODE XREF: _s2i_ASN1_INTEGER+9Cp
		extrn _ASN1_INTEGER_to_BN:near ; CODE XREF: _X509V3_add_value_int+14p
					; _i2s_ASN1_INTEGER+11p
		extrn _ASN1_ENUMERATED_to_BN:near ; CODE XREF: _i2s_ASN1_ENUMERATED+11p
		extrn _ASN1_STRING_to_UTF8:near	; CODE XREF: _do_check_string+E7p
		extrn _OBJ_obj2nid:near	; CODE XREF: _X509_get1_ocsp+4Bp
		extrn _X509_EXTENSION_free:near	; DATA XREF: _X509_REQ_get1_email+35o
		extrn _X509_get_subject_name:near ; CODE XREF: _X509_get1_email+19p
					; _do_x509_check+175p
		extrn _X509_REQ_get_extensions:near ; CODE XREF: _X509_REQ_get1_email+8p
		extrn _X509_NAME_get_index_by_NID:near ; CODE XREF: _do_x509_check+183p
					; _do_x509_check+1C1p ...
		extrn _X509_NAME_get_entry:near	; CODE XREF: _do_x509_check+193p
					; _get_email+32p
		extrn _X509_NAME_add_entry_by_txt:near
					; CODE XREF: _X509V3_NAME_from_section+76p
		extrn _X509_NAME_ENTRY_get_data:near ; CODE XREF: _do_x509_check+199p
					; _get_email+38p
		extrn _X509_get_ext_d2i:near ; CODE XREF: _X509_get1_email+Dp
					; _X509_get1_ocsp+1Dp ...
		extrn _GENERAL_NAME_free:near ;	DATA XREF: _X509_REQ_get1_email+28o
					; _X509_get1_email+27o
		extrn _GENERAL_NAMES_free:near ; CODE XREF: _do_x509_check+144p
		extrn _AUTHORITY_INFO_ACCESS_free:near ; CODE XREF: _X509_get1_ocsp+89p
		extrn _X509V3_get_d2i:near ; CODE XREF:	_X509_REQ_get1_email+16p
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _X509_check_ip_asc+7Cp
					; _X509_check_ip_asc+92p ...
		extrn __chkstk:near	; CODE XREF: _X509V3_parse_list+5p
					; _X509_check_ip_asc+5p ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _ipv6_from_asc+EAp
					; _ipv6_from_asc+125p
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _ipv6_from_asc+FDp
; `__local_stdio_scanf_options'::`2'::_OptionsStorage
		extrn ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:near
					; DATA XREF: ___local_stdio_scanf_optionso
		extrn ___security_cookie:near ;	DATA XREF: _X509_check_ip_asc+Ar
					; _a2i_IPADDRESS+Ar ...


		end
