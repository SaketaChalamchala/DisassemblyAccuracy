;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	6F8561DF6998FA2D96706BDDC4B2DBF6
; Input	CRC32 :	3B6997E9

; File Name   :	C:\compspace\Diff\openssl\obj\rand_win.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
; `readtimer'::`2'::have_perfc
?have_perfc@?1??readtimer@@9@9 dd 1	; DATA XREF: _readtimer+Ar
					; _readtimer+22w ...
_data		ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _RAND_event
_RAND_event	proc near

var_10		= qword	ptr -10h
var_8		= qword	ptr -8
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 8
		call	__chkstk
		mov	eax, [esp+8+arg_0]
		xorps	xmm0, xmm0
		movsd	[esp+8+var_8], xmm0
		cmp	eax, 100h
		jz	short loc_88
		cmp	eax, 200h
		jnz	short loc_A6
		mov	ecx, ds:?lasty@?4??RAND_event@@9@9 ; `RAND_event'::`5'::lasty
		mov	edx, ds:?lastx@?4??RAND_event@@9@9 ; `RAND_event'::`5'::lastx
		push	esi
		mov	esi, [esp+0Ch+arg_8]
		push	edi
		movzx	edi, si
		shr	esi, 10h
		sub	ecx, esi
		sub	edx, edi
		jz	short loc_6C
		test	ecx, ecx
		jz	short loc_6C
		mov	eax, edx
		sub	eax, ds:?lastdx@?4??RAND_event@@9@9 ; `RAND_event'::`5'::lastdx
		jz	short loc_6C
		mov	eax, ecx
		sub	eax, ds:?lastdy@?4??RAND_event@@9@9 ; `RAND_event'::`5'::lastdy
		jz	short loc_6C
		movsd	xmm0, ds:__real@3fc999999999999a
		movsd	[esp+10h+var_8], xmm0

loc_6C:					; CODE XREF: _RAND_event+40j
					; _RAND_event+44j ...
		mov	ds:?lastx@?4??RAND_event@@9@9, edi ; `RAND_event'::`5'::lastx
		pop	edi
		mov	ds:?lasty@?4??RAND_event@@9@9, esi ; `RAND_event'::`5'::lasty
		mov	ds:?lastdx@?4??RAND_event@@9@9,	edx ; `RAND_event'::`5'::lastdx
		mov	ds:?lastdy@?4??RAND_event@@9@9,	ecx ; `RAND_event'::`5'::lastdy
		pop	esi
		jmp	short loc_A6
; ---------------------------------------------------------------------------

loc_88:					; CODE XREF: _RAND_event+1Bj
		mov	eax, [esp+8+arg_4]
		cmp	ds:?key@?3??RAND_event@@9@9, eax ; `RAND_event'::`4'::key
		jz	short loc_A1
		movsd	xmm0, ds:__real@3fa999999999999a
		movsd	[esp+8+var_8], xmm0

loc_A1:					; CODE XREF: _RAND_event+8Ej
		mov	ds:?key@?3??RAND_event@@9@9, eax ; `RAND_event'::`4'::key

loc_A6:					; CODE XREF: _RAND_event+22j
					; _RAND_event+82j
		call	_readtimer
		mov	eax, 8
		call	__chkstk
		movsd	xmm0, [esp+10h+var_8]
		lea	eax, [esp+10h+arg_0]
		movsd	[esp+10h+var_10], xmm0
		push	4
		push	eax
		call	_RAND_add
		add	esp, 10h
		mov	eax, 8
		call	__chkstk
		xorps	xmm0, xmm0
		lea	eax, [esp+10h+arg_4]
		movsd	[esp+10h+var_10], xmm0
		push	4
		push	eax
		call	_RAND_add
		add	esp, 10h
		mov	eax, 8
		call	__chkstk
		xorps	xmm0, xmm0
		lea	eax, [esp+10h+arg_8]
		movsd	[esp+10h+var_10], xmm0
		push	4
		push	eax
		call	_RAND_add
		add	esp, 18h
		jmp	_RAND_status
_RAND_event	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 118h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

		public _RAND_poll
_RAND_poll	proc near		; CODE XREF: _RAND_screenp

var_484		= qword	ptr -484h
var_47C		= qword	ptr -47Ch
var_46C		= xmmword ptr -46Ch
var_45C		= xmmword ptr -45Ch
var_44C		= dword	ptr -44Ch
var_448		= dword	ptr -448h
var_444		= dword	ptr -444h
var_440		= dword	ptr -440h
var_43C		= dword	ptr -43Ch
var_438		= dword	ptr -438h
var_434		= dword	ptr -434h
var_430		= dword	ptr -430h
var_42C		= dword	ptr -42Ch
var_428		= dword	ptr -428h
hModule		= dword	ptr -424h
var_420		= dword	ptr -420h
var_41C		= dword	ptr -41Ch
var_418		= dword	ptr -418h
var_414		= dword	ptr -414h
var_410		= dword	ptr -410h
hLibModule	= dword	ptr -40Ch
var_408		= dword	ptr -408h
var_404		= dword	ptr -404h
hObject		= dword	ptr -400h
var_3FC		= dword	ptr -3FCh
var_3F8		= dword	ptr -3F8h
var_1D4		= dword	ptr -1D4h
Buffer		= _MEMORYSTATUS	ptr -0ACh
var_8C		= dword	ptr -8Ch
var_70		= dword	ptr -70h
var_6C		= xmmword ptr -6Ch
var_5C		= byte ptr -5Ch
var_1C		= dword	ptr -1Ch
ms_exc		= CPPEH_RECORD ptr -18h

		push	ebp
		mov	ebp, esp
		push	0FFFFFFFEh
		push	offset __sehtable$_RAND_poll
		push	offset __except_handler4
		mov	eax, large fs:0
		push	eax
		sub	esp, 8
		mov	eax, 454h
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	[ebp+ms_exc.registration.ScopeTable], eax
		xor	eax, ebp
		mov	[ebp+var_1C], eax
		push	ebx
		push	esi
		push	edi
		push	eax
		lea	eax, [ebp+ms_exc.registration]
		mov	large fs:0, eax
		mov	[ebp+ms_exc.old_esp], esp
		mov	[ebp+var_410], 0
		xor	edi, edi
		mov	[ebp+var_42C], edi
		push	offset ??_C@_0N@JJPEKNFO@ADVAPI32?4DLL?$AA@ ; "ADVAPI32.DLL"
		mov	esi, dword ptr ds:__imp__LoadLibraryA@4	; LoadLibraryA(x)
		call	esi ; LoadLibraryA(x) ;	LoadLibraryA(x)
		mov	[ebp+hLibModule], eax
		push	offset ??_C@_0N@NHGLKGEC@KERNEL32?4DLL?$AA@ ; "KERNEL32.DLL"
		call	esi ; LoadLibraryA(x) ;	LoadLibraryA(x)
		mov	[ebp+var_404], eax
		push	offset ??_C@_0N@HNENINMF@NETAPI32?4DLL?$AA@ ; "NETAPI32.DLL"
		call	esi ; LoadLibraryA(x) ;	LoadLibraryA(x)
		mov	[ebp+hModule], eax
		xor	ecx, ecx
		mov	[ebp+var_41C], ecx
		mov	[ebp+var_3FC], ecx
		mov	[ebp+var_408], ecx
		mov	[ebp+var_414], ecx
		xor	edx, edx
		mov	[ebp+var_418], edx
		mov	esi, dword ptr ds:__imp__GetProcAddress@8 ; GetProcAddress(x,x)
		test	eax, eax
		jz	short loc_1EC
		push	offset ??_C@_0BB@NIBHPBJM@NetStatisticsGet?$AA@	; "NetStatisticsGet"
		push	eax		; hModule
		call	esi ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	[ebp+var_414], eax
		push	offset ??_C@_0BB@EODNGDFL@NetApiBufferFree?$AA@	; "NetApiBufferFree"
		push	[ebp+hModule]	; hModule
		call	esi ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	edx, eax
		mov	[ebp+var_418], edx
		mov	ecx, [ebp+var_414]

loc_1EC:				; CODE XREF: _RAND_poll+A9j
		test	ecx, ecx
		jz	loc_29B
		test	edx, edx
		jz	loc_29B
		lea	eax, [ebp+hObject]
		push	eax
		push	0
		push	0
		push	offset ??_C@_1CE@MINGJEKI@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAW?$AAo?$AAr?$AAk?$AAs?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ ; "LanmanWorkstation"
		push	0
		call	ecx
		test	eax, eax
		jnz	short loc_24A
		mov	eax, 8
		call	__chkstk
		movsd	xmm0, ds:__real@4046800000000000
		movsd	qword ptr [esp], xmm0
		push	0D8h ; 'Ø'
		push	[ebp+hObject]
		call	_RAND_add
		add	esp, 10h
		push	[ebp+hObject]
		call	[ebp+var_418]

loc_24A:				; CODE XREF: _RAND_poll+FAj
		lea	eax, [ebp+hObject]
		push	eax
		push	0
		push	0
		push	offset ??_C@_1BK@FJCAAMNP@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAS?$AAe?$AAr?$AAv?$AAe?$AAr?$AA?$AA@	; "LanmanServer"
		push	0
		mov	eax, [ebp+var_414]
		call	eax
		test	eax, eax
		jnz	short loc_29B
		mov	eax, 8
		call	__chkstk
		movsd	xmm0, ds:__real@4031000000000000
		movsd	[esp+484h+var_484], xmm0
		push	44h ; 'D'
		push	[ebp+hObject]
		call	_RAND_add
		add	esp, 10h
		push	[ebp+hObject]
		call	[ebp+var_418]

loc_29B:				; CODE XREF: _RAND_poll+D6j
					; _RAND_poll+DEj ...
		mov	eax, [ebp+hModule]
		test	eax, eax
		jz	short loc_2AC
		push	eax		; hLibModule
		call	dword ptr ds:__imp__FreeLibrary@4 ; FreeLibrary(x)

loc_2AC:				; CODE XREF: _RAND_poll+18Bj
		mov	eax, [ebp+hLibModule]
		test	eax, eax
		jz	short loc_2EE
		push	offset ??_C@_0BF@JHHBLAOM@CryptAcquireContextW?$AA@ ; "CryptAcquireContextW"
		push	eax		; hModule
		call	esi ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	[ebp+var_41C], eax
		push	offset ??_C@_0P@HGPEDCEI@CryptGenRandom?$AA@ ; "CryptGenRandom"
		push	[ebp+hLibModule] ; hModule
		call	esi ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	[ebp+var_3FC], eax
		push	offset ??_C@_0BE@FBIJLPPP@CryptReleaseContext?$AA@ ; "CryptReleaseContext"
		push	[ebp+hLibModule] ; hModule
		call	esi ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	ecx, eax
		mov	[ebp+var_408], ecx
		jmp	short loc_2F0
; ---------------------------------------------------------------------------

loc_2EE:				; CODE XREF: _RAND_poll+19Cj
		xor	ecx, ecx

loc_2F0:				; CODE XREF: _RAND_poll+1D4j
		mov	eax, [ebp+var_41C]
		test	eax, eax
		jz	loc_3EB
		cmp	[ebp+var_3FC], edi
		jz	loc_3EB
		test	ecx, ecx
		jz	loc_3EB
		push	0F0000000h
		push	1
		push	0
		push	0
		lea	ecx, [ebp+var_410]
		push	ecx
		call	eax
		test	eax, eax
		jz	short loc_379
		lea	eax, [ebp+var_5C]
		push	eax
		push	40h ; '@'
		push	[ebp+var_410]
		call	[ebp+var_3FC]
		test	eax, eax
		jz	short loc_36B
		mov	eax, 8
		call	__chkstk
		xorps	xmm0, xmm0
		movsd	qword ptr [esp+468h+var_46C+4],	xmm0
		push	40h ; '@'
		lea	eax, [ebp+var_5C]
		push	eax
		call	_RAND_add
		add	esp, 10h
		mov	edi, 1
		mov	[ebp+var_42C], edi

loc_36B:				; CODE XREF: _RAND_poll+226j
		push	0
		push	[ebp+var_410]
		call	[ebp+var_408]

loc_379:				; CODE XREF: _RAND_poll+210j
		push	0
		push	16h
		push	offset ??_C@_1FM@ELACHIDN@?$AAI?$AAn?$AAt?$AAe?$AAl?$AA?5?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?5?$AAC?$AAr?$AAy?$AAp?$AAt?$AAo?$AAg?$AAr?$AAa?$AAp?$AAh?$AAi?$AAc?$AA?5?$AAS?$AAe?$AAr@ ; "Intel	Hardware Cryptographic Service Pr"...
		push	0
		lea	eax, [ebp+var_410]
		push	eax
		mov	ecx, [ebp+var_41C]
		call	ecx
		test	eax, eax
		jz	short loc_3EB
		lea	eax, [ebp+var_5C]
		push	eax
		push	40h ; '@'
		push	[ebp+var_410]
		call	[ebp+var_3FC]
		test	eax, eax
		jz	short loc_3DD
		mov	eax, 8
		call	__chkstk
		movsd	xmm0, ds:__real@4050000000000000
		movsd	[esp+47Ch+var_47C], xmm0
		push	40h ; '@'
		lea	eax, [ebp+var_5C]
		push	eax
		call	_RAND_add
		add	esp, 10h
		mov	edi, 1
		mov	[ebp+var_42C], edi

loc_3DD:				; CODE XREF: _RAND_poll+293j
		push	0
		push	[ebp+var_410]
		call	[ebp+var_408]

loc_3EB:				; CODE XREF: _RAND_poll+1E0j
					; _RAND_poll+1ECj ...
		mov	eax, [ebp+hLibModule]
		test	eax, eax
		jz	short loc_3FC
		push	eax		; hLibModule
		call	dword ptr ds:__imp__FreeLibrary@4 ; FreeLibrary(x)

loc_3FC:				; CODE XREF: _RAND_poll+2DBj
		call	_OPENSSL_isservice
		test	eax, eax
		jnz	loc_50D
		push	offset ??_C@_0L@NDEGIDAG@USER32?4DLL?$AA@ ; "USER32.DLL"
		call	dword ptr ds:__imp__LoadLibraryA@4 ; LoadLibraryA(x)
		mov	[ebp+var_408], eax
		test	eax, eax
		jz	loc_50D
		push	offset ??_C@_0BE@IIKKNMMA@GetForegroundWindow?$AA@ ; "GetForegroundWindow"
		push	eax		; hModule
		call	esi ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	[ebp+var_420], eax
		push	offset ??_C@_0O@IGNBKOOJ@GetCursorInfo?$AA@ ; "GetCursorInfo"
		push	[ebp+var_408]	; hModule
		call	esi ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	[ebp+var_428], eax
		push	offset ??_C@_0P@KCBGCFMP@GetQueueStatus?$AA@ ; "GetQueueStatus"
		push	[ebp+var_408]	; hModule
		call	esi ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	esi, eax
		mov	eax, [ebp+var_420]
		test	eax, eax
		jz	short loc_487
		call	eax
		mov	[ebp+var_420], eax
		mov	eax, 8
		call	__chkstk
		xorps	xmm0, xmm0
		movsd	qword ptr [esp], xmm0
		push	4
		lea	eax, [ebp+var_420]
		push	eax
		call	_RAND_add
		add	esp, 10h

loc_487:				; CODE XREF: _RAND_poll+342j
		mov	eax, [ebp+var_428]
		test	eax, eax
		jz	short loc_4C8
		mov	[ebp+var_70], 14h
		lea	ecx, [ebp+var_70]
		push	ecx
		call	eax
		test	eax, eax
		jz	short loc_4C8
		mov	eax, 8
		call	__chkstk
		movsd	xmm0, ds:__real@4000000000000000
		movsd	qword ptr [esp], xmm0
		push	[ebp+var_70]
		lea	eax, [ebp+var_70]
		push	eax
		call	_RAND_add
		add	esp, 10h

loc_4C8:				; CODE XREF: _RAND_poll+377j
					; _RAND_poll+388j
		test	esi, esi
		jz	short loc_501
		push	0BFh ; '¿'
		call	esi
		mov	[ebp+var_430], eax
		mov	eax, 8
		call	__chkstk
		movsd	xmm0, ds:__real@3ff0000000000000
		movsd	qword ptr [esp], xmm0
		push	4
		lea	eax, [ebp+var_430]
		push	eax
		call	_RAND_add
		add	esp, 10h

loc_501:				; CODE XREF: _RAND_poll+3B2j
		push	[ebp+var_408]	; hLibModule
		call	dword ptr ds:__imp__FreeLibrary@4 ; FreeLibrary(x)

loc_50D:				; CODE XREF: _RAND_poll+2EBj
					; _RAND_poll+304j
		mov	eax, [ebp+var_404]
		test	eax, eax
		jz	loc_9FA
		xor	esi, esi
		mov	[ebp+var_3FC], esi
		mov	[ebp+var_414], esi
		push	offset ??_C@_0BJ@JEFKDHMD@CreateToolhelp32Snapshot?$AA@	; "CreateToolhelp32Snapshot"
		push	eax		; hModule
		mov	esi, dword ptr ds:__imp__GetProcAddress@8 ; GetProcAddress(x,x)
		call	esi ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	[ebp+var_408], eax
		push	offset ??_C@_0BI@GJJDGJIM@CloseToolhelp32Snapshot?$AA@ ; "CloseToolhelp32Snapshot"
		push	[ebp+var_404]	; hModule
		call	esi ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	[ebp+var_448], eax
		push	offset ??_C@_0M@PIAPHADL@Heap32First?$AA@ ; "Heap32First"
		push	[ebp+var_404]	; hModule
		call	esi ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	[ebp+var_41C], eax
		push	offset ??_C@_0L@CMGAAJA@Heap32Next?$AA@	; "Heap32Next"
		push	[ebp+var_404]	; hModule
		call	esi ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	[ebp+var_418], eax
		push	offset ??_C@_0BA@FIEIGOLO@Heap32ListFirst?$AA@ ; "Heap32ListFirst"
		push	[ebp+var_404]	; hModule
		call	esi ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	[ebp+hModule], eax
		push	offset ??_C@_0P@EPDKPNHA@Heap32ListNext?$AA@ ; "Heap32ListNext"
		push	[ebp+var_404]	; hModule
		call	esi ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	[ebp+hLibModule], eax
		push	offset ??_C@_0P@ILGHDLOE@Process32First?$AA@ ; "Process32First"
		push	[ebp+var_404]	; hModule
		call	esi ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	[ebp+var_434], eax
		push	offset ??_C@_0O@LGJLFMBH@Process32Next?$AA@ ; "Process32Next"
		push	[ebp+var_404]	; hModule
		call	esi ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	[ebp+var_438], eax
		push	offset ??_C@_0O@DHAEEPDO@Thread32First?$AA@ ; "Thread32First"
		push	[ebp+var_404]	; hModule
		call	esi ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	[ebp+var_43C], eax
		push	offset ??_C@_0N@LDGMJMKG@Thread32Next?$AA@ ; "Thread32Next"
		push	[ebp+var_404]	; hModule
		call	esi ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	[ebp+var_428], eax
		push	offset ??_C@_0O@CNMFJJGO@Module32First?$AA@ ; "Module32First"
		push	[ebp+var_404]	; hModule
		call	esi ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	[ebp+var_420], eax
		push	offset ??_C@_0N@KIGOLBLC@Module32Next?$AA@ ; "Module32Next"
		push	[ebp+var_404]	; hModule
		call	esi ; GetProcAddress(x,x) ; GetProcAddress(x,x)
		mov	ecx, eax
		mov	[ebp+var_444], ecx
		mov	eax, [ebp+var_408]
		test	eax, eax
		jz	loc_9EE
		cmp	[ebp+var_41C], 0
		jz	loc_9EE
		cmp	[ebp+var_418], 0
		jz	loc_9EE
		cmp	[ebp+hModule], 0
		jz	loc_9EE
		cmp	[ebp+hLibModule], 0
		jz	loc_9EE
		cmp	[ebp+var_434], 0
		jz	loc_9EE
		cmp	[ebp+var_438], 0
		jz	loc_9EE
		cmp	[ebp+var_43C], 0
		jz	loc_9EE
		cmp	[ebp+var_428], 0
		jz	loc_9EE
		cmp	[ebp+var_420], 0
		jz	loc_9EE
		test	ecx, ecx
		jz	loc_9EE
		push	0
		push	0Fh
		call	eax
		mov	esi, eax
		mov	[ebp+hObject], esi
		cmp	esi, 0FFFFFFFFh
		jz	loc_9EE
		xorps	xmm0, xmm0
		movups	[ebp+var_6C], xmm0
		mov	dword ptr [ebp+var_6C],	10h
		test	edi, edi
		jz	short loc_6D6
		call	dword ptr ds:__imp__GetTickCount@0 ; GetTickCount()
		mov	[ebp+var_3FC], eax
		mov	[ebp+var_414], eax

loc_6D6:				; CODE XREF: _RAND_poll+5AAj
		lea	eax, [ebp+var_6C]
		push	eax
		push	esi
		call	[ebp+hModule]
		test	eax, eax
		jz	loc_83E
		mov	esi, 2Ah ; '*'
		mov	[ebp+var_408], esi
		nop	dword ptr [eax+00h]

loc_6F8:				; CODE XREF: _RAND_poll+720j
		mov	eax, 8
		call	__chkstk
		movsd	xmm0, ds:__real@4008000000000000
		movsd	qword ptr [esp], xmm0
		push	dword ptr [ebp+var_6C]
		lea	eax, [ebp+var_6C]
		push	eax
		call	_RAND_add
		add	esp, 10h
		wait
		mov	[ebp+ms_exc.registration.TryLevel], 0
		xorps	xmm0, xmm0
		movups	[ebp+var_46C], xmm0
		movups	[ebp+var_45C], xmm0
		mov	[ebp+var_44C], 0
		mov	dword ptr [ebp+var_46C], 24h ; '$'
		push	dword ptr [ebp+var_6C+8]
		push	dword ptr [ebp+var_6C+4]
		lea	eax, [ebp+var_46C]
		push	eax
		call	[ebp+var_41C]
		test	eax, eax
		jz	short loc_7D2
		mov	esi, 50h ; 'P'
		mov	[ebp+var_440], esi

loc_76D:				; CODE XREF: _RAND_poll+6B2j
		mov	eax, 8
		call	__chkstk
		movsd	xmm0, ds:__real@4014000000000000
		movsd	qword ptr [esp], xmm0
		push	dword ptr [ebp+var_46C]
		lea	eax, [ebp+var_46C]
		push	eax
		call	_RAND_add
		add	esp, 10h
		lea	eax, [ebp+var_46C]
		push	eax
		call	[ebp+var_418]
		test	eax, eax
		jz	short loc_7CC
		test	edi, edi
		jz	short loc_7C1
		call	dword ptr ds:__imp__GetTickCount@0 ; GetTickCount()
		sub	eax, [ebp+var_3FC]
		cmp	eax, 3E8h
		jnb	short loc_7CC

loc_7C1:				; CODE XREF: _RAND_poll+694j
		dec	esi
		mov	[ebp+var_440], esi
		test	esi, esi
		jg	short loc_76D

loc_7CC:				; CODE XREF: _RAND_poll+690j
					; _RAND_poll+6A7j
		mov	esi, [ebp+var_408]

loc_7D2:				; CODE XREF: _RAND_poll+648j
		wait
		mov	[ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh
		jmp	short loc_80B
; ---------------------------------------------------------------------------

$LN60:					; DATA XREF: .xdata$x:__sehtable$_RAND_pollo
		mov	eax, 1		; $LN91

$LN90:
		retn
; ---------------------------------------------------------------------------

$LN61:					; DATA XREF: .xdata$x:__sehtable$_RAND_pollo
		mov	esp, [ebp+ms_exc.old_esp] ; Exception handler 0	for function 118
		mov	esi, [ebp+var_408]
		dec	esi
		mov	[ebp+var_408], esi
		mov	[ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh
		mov	edi, [ebp+var_42C]
		mov	eax, [ebp+var_414]
		mov	[ebp+var_3FC], eax

loc_80B:				; CODE XREF: _RAND_poll+6C2j
		lea	eax, [ebp+var_6C]
		push	eax
		push	[ebp+hObject]
		call	[ebp+hLibModule]
		test	eax, eax
		jz	short loc_83E
		test	edi, edi
		jz	short loc_836
		call	dword ptr ds:__imp__GetTickCount@0 ; GetTickCount()
		sub	eax, [ebp+var_3FC]
		cmp	eax, 3E8h
		jnb	short loc_83E

loc_836:				; CODE XREF: _RAND_poll+709j
		test	esi, esi
		jg	loc_6F8

loc_83E:				; CODE XREF: _RAND_poll+5CBj
					; _RAND_poll+705j ...
		mov	[ebp+var_1D4], 128h
		mov	esi, dword ptr ds:__imp__GetTickCount@0	; GetTickCount()
		test	edi, edi
		jz	short loc_85A
		call	esi ; GetTickCount() ; GetTickCount()
		mov	[ebp+var_3FC], eax

loc_85A:				; CODE XREF: _RAND_poll+738j
		lea	eax, [ebp+var_1D4]
		push	eax
		push	[ebp+hObject]
		call	[ebp+var_434]
		test	eax, eax
		jz	short loc_8CE
		nop	dword ptr [eax+00000000h]

loc_878:				; CODE XREF: _RAND_poll+7A5j
					; _RAND_poll+7B4j
		mov	eax, 8
		call	__chkstk
		movsd	xmm0, ds:__real@4022000000000000
		movsd	qword ptr [esp+10h+ms_exc.registration.Next], xmm0
		push	[ebp+var_1D4]
		lea	eax, [ebp+var_1D4]
		push	eax
		call	_RAND_add
		add	esp, 10h
		lea	eax, [ebp+var_1D4]
		push	eax
		push	[ebp+hObject]
		call	[ebp+var_438]
		test	eax, eax
		jz	short loc_8CE
		test	edi, edi
		jz	short loc_878
		call	esi ; GetTickCount() ; GetTickCount()
		sub	eax, [ebp+var_3FC]
		cmp	eax, 3E8h
		jb	short loc_878

loc_8CE:				; CODE XREF: _RAND_poll+757j
					; _RAND_poll+7A1j
		mov	[ebp+var_8C], 1Ch
		test	edi, edi
		jz	short loc_8E4
		call	esi ; GetTickCount() ; GetTickCount()
		mov	[ebp+var_3FC], eax

loc_8E4:				; CODE XREF: _RAND_poll+7C2j
		lea	eax, [ebp+var_8C]
		push	eax
		push	[ebp+hObject]
		call	[ebp+var_43C]
		test	eax, eax
		jz	short loc_951

loc_8FB:				; CODE XREF: _RAND_poll+828j
					; _RAND_poll+837j
		mov	eax, 8
		call	__chkstk
		movsd	xmm0, ds:__real@4018000000000000
		movsd	qword ptr [esp+18h+ms_exc.old_esp], xmm0
		push	[ebp+var_8C]
		lea	eax, [ebp+var_8C]
		push	eax
		call	_RAND_add
		add	esp, 10h
		lea	eax, [ebp+var_8C]
		push	eax
		push	[ebp+hObject]
		call	[ebp+var_428]
		test	eax, eax
		jz	short loc_951
		test	edi, edi
		jz	short loc_8FB
		call	esi ; GetTickCount() ; GetTickCount()
		sub	eax, [ebp+var_3FC]
		cmp	eax, 3E8h
		jb	short loc_8FB

loc_951:				; CODE XREF: _RAND_poll+7E1j
					; _RAND_poll+824j
		mov	[ebp+var_3F8], 224h
		test	edi, edi
		jz	short loc_967
		call	esi ; GetTickCount() ; GetTickCount()
		mov	[ebp+var_3FC], eax

loc_967:				; CODE XREF: _RAND_poll+845j
		lea	eax, [ebp+var_3F8]
		push	eax
		push	[ebp+hObject]
		call	[ebp+var_420]
		test	eax, eax
		jz	short loc_9D4

loc_97E:				; CODE XREF: _RAND_poll+8ABj
					; _RAND_poll+8BAj
		mov	eax, 8
		call	__chkstk
		movsd	xmm0, ds:__real@4022000000000000
		movsd	qword ptr [esp], xmm0
		push	[ebp+var_3F8]
		lea	eax, [ebp+var_3F8]
		push	eax
		call	_RAND_add
		add	esp, 10h
		lea	eax, [ebp+var_3F8]
		push	eax
		push	[ebp+hObject]
		call	[ebp+var_444]
		test	eax, eax
		jz	short loc_9D4
		test	edi, edi
		jz	short loc_97E
		call	esi ; GetTickCount() ; GetTickCount()
		sub	eax, [ebp+var_3FC]
		cmp	eax, 3E8h
		jb	short loc_97E

loc_9D4:				; CODE XREF: _RAND_poll+864j
					; _RAND_poll+8A7j
		mov	eax, [ebp+var_448]
		push	[ebp+hObject]	; hObject
		test	eax, eax
		jz	short loc_9E8
		call	eax
		jmp	short loc_9EE
; ---------------------------------------------------------------------------

loc_9E8:				; CODE XREF: _RAND_poll+8CAj
		call	dword ptr ds:__imp__CloseHandle@4 ; CloseHandle(x)

loc_9EE:				; CODE XREF: _RAND_poll+500j
					; _RAND_poll+50Dj ...
		push	[ebp+var_404]	; hLibModule
		call	dword ptr ds:__imp__FreeLibrary@4 ; FreeLibrary(x)

loc_9FA:				; CODE XREF: _RAND_poll+3FDj
		call	_readtimer
		lea	eax, [ebp+Buffer]
		push	eax		; lpBuffer
		call	dword ptr ds:__imp__GlobalMemoryStatus@4 ; GlobalMemoryStatus(x)
		mov	eax, 8
		call	__chkstk
		movsd	xmm0, ds:__real@3ff0000000000000
		movsd	qword ptr [esp], xmm0
		push	20h ; ' '
		lea	eax, [ebp+Buffer]
		push	eax
		call	_RAND_add
		add	esp, 10h
		call	dword ptr ds:__imp__GetCurrentProcessId@0 ; GetCurrentProcessId()
		mov	[ebp+var_430], eax
		mov	eax, 8
		call	__chkstk
		movsd	xmm0, ds:__real@3ff0000000000000
		movsd	qword ptr [esp], xmm0
		push	4
		lea	eax, [ebp+var_430]
		push	eax
		call	_RAND_add
		add	esp, 10h
		mov	eax, 1
		mov	ecx, [ebp+ms_exc.registration.Next]
		mov	large fs:0, ecx
		pop	ecx
		pop	edi
		pop	esi
		pop	ebx
		mov	ecx, [ebp+var_1C]
		xor	ecx, ebp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
_RAND_poll	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A8Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _RAND_screen
_RAND_screen	proc near
		call	_RAND_poll
		jmp	_readscreen
_RAND_screen	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0A98h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

_readscreen	proc near		; CODE XREF: _RAND_screen+5j

var_88		= qword	ptr -88h
var_64		= dword	ptr -64h
hbm		= dword	ptr -60h
var_5C		= dword	ptr -5Ch
pv		= byte ptr -58h
var_54		= dword	ptr -54h
var_50		= dword	ptr -50h
var_4C		= dword	ptr -4Ch
var_48		= word ptr -48h
var_46		= word ptr -46h
bmi		= tagBITMAPINFO	ptr -40h
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		and	esp, 0FFFFFFC0h
		mov	eax, 74h ; 't'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+74h+var_4], eax
		push	ebx
		push	esi
		push	edi
		call	_OPENSSL_isservice
		test	eax, eax
		jg	loc_C0D
		push	0		; hWnd
		call	dword ptr ds:__imp__GetDC@4 ; GetDC(x)
		mov	esi, dword ptr ds:__imp__GetDeviceCaps@8 ; GetDeviceCaps(x,x)
		mov	ebx, eax
		push	8		; index
		push	ebx		; hdc
		call	esi ; GetDeviceCaps(x,x) ; GetDeviceCaps(x,x)
		push	0Ah		; index
		push	ebx		; hdc
		mov	edi, eax
		call	esi ; GetDeviceCaps(x,x) ; GetDeviceCaps(x,x)
		push	10h		; cy
		push	edi		; cx
		push	ebx		; hdc
		mov	[esp+8Ch+var_64], eax
		call	dword ptr ds:__imp__CreateCompatibleBitmap@12 ;	CreateCompatibleBitmap(x,x,x)
		lea	ecx, [esp+80h+pv]
		mov	[esp+80h+hbm], eax
		push	ecx		; pv
		push	18h		; c
		push	eax		; h
		call	dword ptr ds:__imp__GetObjectA@12 ; GetObjectA(x,x,x)
		mov	dx, [esp+80h+var_48]
		mov	ecx, [esp+80h+var_50]
		mov	eax, [esp+80h+var_54]
		movzx	esi, dx
		imul	esi, ecx
		push	2D6h
		mov	[esp+84h+bmi.bmiHeader.biWidth], eax
		mov	ax, [esp+84h+var_46]
		push	offset ??_C@_0BJ@OIDOBJG@?4?2crypto?2rand?2rand_win?4c?$AA@ ; ".\\crypto\\rand\\rand_win.c"
		imul	esi, [esp+88h+var_4C]
		mov	[esp+88h+bmi.bmiHeader.biSize],	28h ; '('
		mov	[esp+88h+bmi.bmiHeader.biHeight], ecx
		mov	[esp+88h+bmi.bmiHeader.biPlanes], dx
		mov	[esp+88h+bmi.bmiHeader.biBitCount], ax
		push	esi
		mov	[esp+8Ch+var_5C], esi
		mov	[esp+8Ch+bmi.bmiHeader.biCompression], 0
		mov	[esp+8Ch+bmi.bmiHeader.biSizeImage], 0
		mov	[esp+8Ch+bmi.bmiHeader.biXPelsPerMeter], 0
		mov	[esp+8Ch+bmi.bmiHeader.biYPelsPerMeter], 0
		mov	[esp+8Ch+bmi.bmiHeader.biClrUsed], 0
		mov	[esp+8Ch+bmi.bmiHeader.biClrImportant],	0
		call	_CRYPTO_malloc
		mov	edi, eax
		add	esp, 0Ch
		test	edi, edi
		jz	short loc_BFA
		mov	eax, [esp+80h+var_64]
		xor	esi, esi
		add	eax, 0FFFFFFF0h
		test	eax, eax
		jle	short loc_BF1

loc_B90:				; CODE XREF: _readscreen+157j
		push	0		; usage
		lea	eax, [esp+84h+bmi]
		push	eax		; lpbmi
		push	edi		; lpvBits
		push	10h		; cLines
		push	esi		; start
		push	[esp+94h+hbm]	; hbm
		push	ebx		; hdc
		call	dword ptr ds:__imp__GetDIBits@28 ; GetDIBits(x,x,x,x,x,x,x)
		push	0
		call	_EVP_sha1
		push	eax
		push	0
		lea	eax, [esp+8Ch+bmi.bmiColors]
		push	eax
		push	[esp+90h+var_5C]
		push	edi
		call	_EVP_Digest
		add	esp, 18h
		mov	eax, 8
		call	__chkstk
		xorps	xmm0, xmm0
		lea	eax, [esp+88h+bmi.bmiColors]
		movsd	[esp+88h+var_88], xmm0
		push	14h
		push	eax
		call	_RAND_add
		mov	eax, [esp+90h+var_64]
		add	esi, 10h
		add	eax, 0FFFFFFF0h
		add	esp, 10h
		cmp	esi, eax
		jl	short loc_B90

loc_BF1:				; CODE XREF: _readscreen+F6j
		push	edi
		call	_CRYPTO_free
		add	esp, 4

loc_BFA:				; CODE XREF: _readscreen+E9j
		push	[esp+80h+hbm]	; ho
		call	dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
		push	ebx		; hDC
		push	0		; hWnd
		call	dword ptr ds:__imp__ReleaseDC@8	; ReleaseDC(x,x)

loc_C0D:				; CODE XREF: _readscreen+25j
		mov	ecx, [esp+80h+var_4]
		pop	edi
		pop	esi
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		mov	esp, ebp
		pop	ebp
		retn
_readscreen	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C20h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


_readtimer	proc near		; CODE XREF: _RAND_event:loc_A6p
					; _RAND_poll:loc_9FAp

var_14		= qword	ptr -14h
var_C		= dword	ptr -0Ch
PerformanceCount= LARGE_INTEGER	ptr -8

		mov	eax, 0Ch
		call	__chkstk
		cmp	?have_perfc@?1??readtimer@@9@9,	0 ; `readtimer'::`2'::have_perfc
		jz	short loc_C73
		lea	eax, [esp+0Ch+PerformanceCount]
		push	eax		; lpPerformanceCount
		call	dword ptr ds:__imp__QueryPerformanceCounter@4 ;	QueryPerformanceCounter(x)
		test	eax, eax
		jnz	short loc_C49
		mov	?have_perfc@?1??readtimer@@9@9,	eax ; `readtimer'::`2'::have_perfc
		jmp	short loc_C73
; ---------------------------------------------------------------------------

loc_C49:				; CODE XREF: _readtimer+20j
		mov	eax, 8
		call	__chkstk
		xorps	xmm0, xmm0
		lea	eax, [esp+14h+PerformanceCount]
		movsd	[esp+14h+var_14], xmm0
		push	8
		push	eax
		call	_RAND_add
		add	esp, 10h
		cmp	?have_perfc@?1??readtimer@@9@9,	0 ; `readtimer'::`2'::have_perfc
		jnz	short loc_C9D

loc_C73:				; CODE XREF: _readtimer+11j
					; _readtimer+27j
		call	dword ptr ds:__imp__GetTickCount@0 ; GetTickCount()
		mov	[esp+0Ch+var_C], eax
		mov	eax, 8
		call	__chkstk
		xorps	xmm0, xmm0
		lea	eax, [esp+14h+var_C]
		movsd	[esp+14h+var_14], xmm0
		push	4
		push	eax
		call	_RAND_add
		add	esp, 10h

loc_C9D:				; CODE XREF: _readtimer+51j
		add	esp, 0Ch
		retn
_readtimer	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_xdata$x	segment	para public 'DATA' use32
		assume cs:_xdata$x
		;org 0CA4h
; COMDAT (pick associative to section at 118)
__sehtable$_RAND_poll dd 0FFFFFFE4h	      ;	GSCookieOffset ; DATA XREF: _RAND_poll+5o
		dd 0			; GSCookieXOROffset ; SEH scope	table for function 118
		dd 0FFFFFB84h		; EHCookieOffset
		dd 0			; EHCookieXOROffset
		dd 0FFFFFFFEh		; ScopeRecord.EnclosingLevel
		dd offset $LN60		; ScopeRecord.FilterFunc
		dd offset $LN61		; ScopeRecord.HandlerFunc
_xdata$x	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CC0h
; COMDAT (pick any)
		public ??_C@_0N@JJPEKNFO@ADVAPI32?4DLL?$AA@
; CHAR `string'[]
??_C@_0N@JJPEKNFO@ADVAPI32?4DLL?$AA@ db	'ADVAPI32.DLL',0 ; DATA XREF: _RAND_poll+52o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CD0h
; COMDAT (pick any)
		public ??_C@_0N@NHGLKGEC@KERNEL32?4DLL?$AA@
; CHAR `string'[]
??_C@_0N@NHGLKGEC@KERNEL32?4DLL?$AA@ db	'KERNEL32.DLL',0 ; DATA XREF: _RAND_poll+65o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CE0h
; COMDAT (pick any)
		public ??_C@_0N@HNENINMF@NETAPI32?4DLL?$AA@
; CHAR `string'[]
??_C@_0N@HNENINMF@NETAPI32?4DLL?$AA@ db	'NETAPI32.DLL',0 ; DATA XREF: _RAND_poll+72o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0CF0h
; COMDAT (pick any)
		public ??_C@_0BB@NIBHPBJM@NetStatisticsGet?$AA@
; CHAR `string'[]
??_C@_0BB@NIBHPBJM@NetStatisticsGet?$AA@ db 'NetStatisticsGet',0 ; DATA XREF: _RAND_poll+ABo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D04h
; COMDAT (pick any)
		public ??_C@_0BB@EODNGDFL@NetApiBufferFree?$AA@
; CHAR `string'[]
??_C@_0BB@EODNGDFL@NetApiBufferFree?$AA@ db 'NetApiBufferFree',0 ; DATA XREF: _RAND_poll+B9o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D18h
; COMDAT (pick any)
		public ??_C@_1CE@MINGJEKI@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAW?$AAo?$AAr?$AAk?$AAs?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
; `string'
??_C@_1CE@MINGJEKI@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAW?$AAo?$AAr?$AAk?$AAs?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$AA@:
					; DATA XREF: _RAND_poll+EFo
		unicode	0, <LanmanWorkstation>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D3Ch
; COMDAT (pick any)
		public ??_C@_1BK@FJCAAMNP@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAS?$AAe?$AAr?$AAv?$AAe?$AAr?$AA?$AA@
; `string'
??_C@_1BK@FJCAAMNP@?$AAL?$AAa?$AAn?$AAm?$AAa?$AAn?$AAS?$AAe?$AAr?$AAv?$AAe?$AAr?$AA?$AA@:
					; DATA XREF: _RAND_poll+13Do
		unicode	0, <LanmanServer>,0
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D58h
; COMDAT (pick any)
		public ??_C@_0BF@JHHBLAOM@CryptAcquireContextW?$AA@
; CHAR `string'[]
??_C@_0BF@JHHBLAOM@CryptAcquireContextW?$AA@ db	'CryptAcquireContextW',0
					; DATA XREF: _RAND_poll+19Eo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D70h
; COMDAT (pick any)
		public ??_C@_0P@HGPEDCEI@CryptGenRandom?$AA@
; CHAR `string'[]
??_C@_0P@HGPEDCEI@CryptGenRandom?$AA@ db 'CryptGenRandom',0 ; DATA XREF: _RAND_poll+1ACo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0D80h
; COMDAT (pick any)
		public ??_C@_0BE@FBIJLPPP@CryptReleaseContext?$AA@
; CHAR `string'[]
??_C@_0BE@FBIJLPPP@CryptReleaseContext?$AA@ db 'CryptReleaseContext',0
					; DATA XREF: _RAND_poll+1BFo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0D94h
; COMDAT (pick any)
		public ??_C@_1FM@ELACHIDN@?$AAI?$AAn?$AAt?$AAe?$AAl?$AA?5?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?5?$AAC?$AAr?$AAy?$AAp?$AAt?$AAo?$AAg?$AAr?$AAa?$AAp?$AAh?$AAi?$AAc?$AA?5?$AAS?$AAe?$AAr@
; `string'
??_C@_1FM@ELACHIDN@?$AAI?$AAn?$AAt?$AAe?$AAl?$AA?5?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?5?$AAC?$AAr?$AAy?$AAp?$AAt?$AAo?$AAg?$AAr?$AAa?$AAp?$AAh?$AAi?$AAc?$AA?5?$AAS?$AAe?$AAr@:
					; DATA XREF: _RAND_poll+265o
		unicode	0, <Intel Hardware Cryptographic Service Provider>,0
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DF0h
; COMDAT (pick any)
		public ??_C@_0L@NDEGIDAG@USER32?4DLL?$AA@
; CHAR `string'[]
??_C@_0L@NDEGIDAG@USER32?4DLL?$AA@ db 'USER32.DLL',0 ; DATA XREF: _RAND_poll+2F1o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0DFCh
; COMDAT (pick any)
		public ??_C@_0BE@IIKKNMMA@GetForegroundWindow?$AA@
; CHAR `string'[]
??_C@_0BE@IIKKNMMA@GetForegroundWindow?$AA@ db 'GetForegroundWindow',0
					; DATA XREF: _RAND_poll+30Ao
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E10h
; COMDAT (pick any)
		public ??_C@_0O@IGNBKOOJ@GetCursorInfo?$AA@
; CHAR `string'[]
??_C@_0O@IGNBKOOJ@GetCursorInfo?$AA@ db	'GetCursorInfo',0 ; DATA XREF: _RAND_poll+318o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E20h
; COMDAT (pick any)
		public ??_C@_0P@KCBGCFMP@GetQueueStatus?$AA@
; CHAR `string'[]
??_C@_0P@KCBGCFMP@GetQueueStatus?$AA@ db 'GetQueueStatus',0 ; DATA XREF: _RAND_poll+32Bo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E30h
; COMDAT (pick any)
		public ??_C@_0BJ@JEFKDHMD@CreateToolhelp32Snapshot?$AA@
; CHAR `string'[]
??_C@_0BJ@JEFKDHMD@CreateToolhelp32Snapshot?$AA@ db 'CreateToolhelp32Snapshot',0
					; DATA XREF: _RAND_poll+411o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E4Ch
; COMDAT (pick any)
		public ??_C@_0BI@GJJDGJIM@CloseToolhelp32Snapshot?$AA@
; CHAR `string'[]
??_C@_0BI@GJJDGJIM@CloseToolhelp32Snapshot?$AA@	db 'CloseToolhelp32Snapshot',0
					; DATA XREF: _RAND_poll+425o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E64h
; COMDAT (pick any)
		public ??_C@_0M@PIAPHADL@Heap32First?$AA@
; CHAR `string'[]
??_C@_0M@PIAPHADL@Heap32First?$AA@ db 'Heap32First',0 ; DATA XREF: _RAND_poll+438o
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E70h
; COMDAT (pick any)
		public ??_C@_0L@CMGAAJA@Heap32Next?$AA@
; CHAR `string'[]
??_C@_0L@CMGAAJA@Heap32Next?$AA@ db 'Heap32Next',0 ; DATA XREF: _RAND_poll+44Bo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E7Ch
; COMDAT (pick any)
		public ??_C@_0BA@FIEIGOLO@Heap32ListFirst?$AA@
; CHAR `string'[]
??_C@_0BA@FIEIGOLO@Heap32ListFirst?$AA@	db 'Heap32ListFirst',0 ; DATA XREF: _RAND_poll+45Eo
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E8Ch
; COMDAT (pick any)
		public ??_C@_0P@EPDKPNHA@Heap32ListNext?$AA@
; CHAR `string'[]
??_C@_0P@EPDKPNHA@Heap32ListNext?$AA@ db 'Heap32ListNext',0 ; DATA XREF: _RAND_poll+471o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0E9Ch
; COMDAT (pick any)
		public ??_C@_0P@ILGHDLOE@Process32First?$AA@
; CHAR `string'[]
??_C@_0P@ILGHDLOE@Process32First?$AA@ db 'Process32First',0 ; DATA XREF: _RAND_poll+484o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0EACh
; COMDAT (pick any)
		public ??_C@_0O@LGJLFMBH@Process32Next?$AA@
; CHAR `string'[]
??_C@_0O@LGJLFMBH@Process32Next?$AA@ db	'Process32Next',0 ; DATA XREF: _RAND_poll+497o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0EBCh
; COMDAT (pick any)
		public ??_C@_0O@DHAEEPDO@Thread32First?$AA@
; CHAR `string'[]
??_C@_0O@DHAEEPDO@Thread32First?$AA@ db	'Thread32First',0 ; DATA XREF: _RAND_poll+4AAo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0ECCh
; COMDAT (pick any)
		public ??_C@_0N@LDGMJMKG@Thread32Next?$AA@
; CHAR `string'[]
??_C@_0N@LDGMJMKG@Thread32Next?$AA@ db 'Thread32Next',0 ; DATA XREF: _RAND_poll+4BDo
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0EDCh
; COMDAT (pick any)
		public ??_C@_0O@CNMFJJGO@Module32First?$AA@
; CHAR `string'[]
??_C@_0O@CNMFJJGO@Module32First?$AA@ db	'Module32First',0 ; DATA XREF: _RAND_poll+4D0o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0EECh
; COMDAT (pick any)
		public ??_C@_0N@KIGOLBLC@Module32Next?$AA@
; CHAR `string'[]
??_C@_0N@KIGOLBLC@Module32Next?$AA@ db 'Module32Next',0 ; DATA XREF: _RAND_poll+4E3o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 0EFCh
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; `RAND_event'::`4'::key
?key@?3??RAND_event@@9@9 dd ?		; DATA XREF: _RAND_event+88r
					; _RAND_event:loc_A1w
; `RAND_event'::`5'::lastx
?lastx@?4??RAND_event@@9@9 dd ?		; DATA XREF: _RAND_event+2Ar
					; _RAND_event:loc_6Cw
; `RAND_event'::`5'::lasty
?lasty@?4??RAND_event@@9@9 dd ?		; DATA XREF: _RAND_event+24r
					; _RAND_event+6Fw
; `RAND_event'::`5'::lastdx
?lastdx@?4??RAND_event@@9@9 dd ?	; DATA XREF: _RAND_event+48r
					; _RAND_event+75w
; `RAND_event'::`5'::lastdy
?lastdy@?4??RAND_event@@9@9 dd ?	; DATA XREF: _RAND_event+52r
					; _RAND_event+7Bw
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 0F10h
; COMDAT (pick any)
		public ??_C@_0BJ@OIDOBJG@?4?2crypto?2rand?2rand_win?4c?$AA@
; `string'
??_C@_0BJ@OIDOBJG@?4?2crypto?2rand?2rand_win?4c?$AA@ db	'.\crypto\rand\rand_win.c',0
					; DATA XREF: _readscreen+88o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0F2Ch
; COMDAT (pick any)
		public __real@3fa999999999999a
__real@3fa999999999999a	dq 3FA999999999999Ah ; DATA XREF: _RAND_event+90r
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0F34h
; COMDAT (pick any)
		public __real@3fc999999999999a
__real@3fc999999999999a	dq 3FC999999999999Ah ; DATA XREF: _RAND_event+5Ar
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0F3Ch
; COMDAT (pick any)
		public __real@3ff0000000000000
__real@3ff0000000000000	dq 3FF0000000000000h ; DATA XREF: _RAND_poll+3CBr
					; _RAND_poll+8FEr ...
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0F44h
; COMDAT (pick any)
		public __real@4000000000000000
__real@4000000000000000	dq 4000000000000000h ; DATA XREF: _RAND_poll+394r
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0F4Ch
; COMDAT (pick any)
		public __real@4008000000000000
__real@4008000000000000	dq 4008000000000000h ; DATA XREF: _RAND_poll+5EAr
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0F54h
; COMDAT (pick any)
		public __real@4014000000000000
__real@4014000000000000	dq 4014000000000000h ; DATA XREF: _RAND_poll+65Fr
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0F5Ch
; COMDAT (pick any)
		public __real@4018000000000000
__real@4018000000000000	dq 4018000000000000h ; DATA XREF: _RAND_poll+7EDr
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0F64h
; COMDAT (pick any)
		public __real@4022000000000000
__real@4022000000000000	dq 4022000000000000h ; DATA XREF: _RAND_poll+76Ar
					; _RAND_poll+870r
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0F6Ch
; COMDAT (pick any)
		public __real@4031000000000000
__real@4031000000000000	dq 4031000000000000h ; DATA XREF: _RAND_poll+15Ar
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0F74h
; COMDAT (pick any)
		public __real@4046800000000000
__real@4046800000000000	dq 4046800000000000h ; DATA XREF: _RAND_poll+106r
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment 'qword' can not be represented in assembly
_rdata		segment	para public 'DATA' use32
		assume cs:_rdata
		;org 0F7Ch
; COMDAT (pick any)
		public __real@4050000000000000
__real@4050000000000000	dq 4050000000000000h ; DATA XREF: _RAND_poll+29Fr
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
; BOOL __stdcall CloseHandle(HANDLE hObject)
		extrn __imp__CloseHandle@4:near	; CODE XREF: _RAND_poll:loc_9E8p
					; DATA XREF: _RAND_poll:loc_9E8r
; BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
		extrn __imp__QueryPerformanceCounter@4:near ; CODE XREF: _readtimer+18p
					; DATA XREF: _readtimer+18r
; DWORD	__stdcall GetCurrentProcessId()
		extrn __imp__GetCurrentProcessId@0:near	; CODE XREF: _RAND_poll+91Cp
					; DATA XREF: _RAND_poll+91Cr
; DWORD	__stdcall GetTickCount()
		extrn __imp__GetTickCount@0:near ; CODE	XREF: _RAND_poll+5ACp
					; _RAND_poll+696p ...
; BOOL __stdcall FreeLibrary(HMODULE hLibModule)
		extrn __imp__FreeLibrary@4:near	; CODE XREF: _RAND_poll+18Ep
					; _RAND_poll+2DEp ...
; FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName)
		extrn __imp__GetProcAddress@8:near ; CODE XREF:	_RAND_poll+B1p
					; _RAND_poll+C4p ...
; HMODULE __stdcall LoadLibraryA(LPCSTR	lpLibFileName)
		extrn __imp__LoadLibraryA@4:near ; CODE	XREF: _RAND_poll+5Dp
					; _RAND_poll+6Ap ...
; void __stdcall GlobalMemoryStatus(LPMEMORYSTATUS lpBuffer)
		extrn __imp__GlobalMemoryStatus@4:near ; CODE XREF: _RAND_poll+8EEp
					; DATA XREF: _RAND_poll+8EEr
; HBITMAP __stdcall CreateCompatibleBitmap(HDC hdc, int	cx, int	cy)
		extrn __imp__CreateCompatibleBitmap@12:near ; CODE XREF: _readscreen+4Fp
					; DATA XREF: _readscreen+4Fr
; BOOL __stdcall DeleteObject(HGDIOBJ ho)
		extrn __imp__DeleteObject@4:near ; CODE	XREF: _readscreen+166p
					; DATA XREF: _readscreen+166r
; int __stdcall	GetDeviceCaps(HDC hdc, int index)
		extrn __imp__GetDeviceCaps@8:near ; CODE XREF: _readscreen+3Ep
					; _readscreen+45p
					; DATA XREF: ...
; int __stdcall	GetDIBits(HDC hdc, HBITMAP hbm,	UINT start, UINT cLines, LPVOID	lpvBits, LPBITMAPINFO lpbmi, UINT usage)
		extrn __imp__GetDIBits@28:near ; CODE XREF: _readscreen+108p
					; DATA XREF: _readscreen+108r
; int __stdcall	GetObjectA(HANDLE h, int c, LPVOID pv)
		extrn __imp__GetObjectA@12:near	; CODE XREF: _readscreen+61p
					; DATA XREF: _readscreen+61r
; HDC __stdcall	GetDC(HWND hWnd)
		extrn __imp__GetDC@4:near ; CODE XREF: _readscreen+2Dp
					; DATA XREF: _readscreen+2Dr
; int __stdcall	ReleaseDC(HWND hWnd, HDC hDC)
		extrn __imp__ReleaseDC@8:near ;	CODE XREF: _readscreen+16Fp
					; DATA XREF: _readscreen+16Fr
		extrn _CRYPTO_malloc:near ; CODE XREF: _readscreen+DDp
		extrn _CRYPTO_free:near	; CODE XREF: _readscreen+15Ap
		extrn _OPENSSL_isservice:near ;	CODE XREF: _RAND_poll:loc_3FCp
					; _readscreen+1Ep
		extrn _RAND_add:near	; CODE XREF: _RAND_event+C3p
					; _RAND_event+E4p ...
		extrn _RAND_status:near	; CODE XREF: _RAND_event+10Dj
		extrn _EVP_Digest:near	; CODE XREF: _readscreen+122p
		extrn _EVP_sha1:near	; CODE XREF: _readscreen+110p
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _RAND_poll+968p
					; _readscreen+17Ep
		extrn __chkstk:near	; CODE XREF: _RAND_event+5p
					; _RAND_event+ACp ...
		extrn __except_handler4:near ; DATA XREF: _RAND_poll+Ao
		extrn ___security_cookie:near ;	DATA XREF: _RAND_poll+23r
					; _readscreen+10r
		extrn __fltused:near


		end
