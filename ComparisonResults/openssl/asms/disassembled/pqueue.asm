;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	624497A8C70F6E6027EB7781B65C5334
; Input	CRC32 :	54372537

; File Name   :	C:\compspace\Diff\openssl\obj\pqueue.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public ___local_stdio_printf_options
___local_stdio_printf_options proc near	; CODE XREF: __vfprintf_l+10p
					; _printf+19p
		mov	eax, offset ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage
		retn
___local_stdio_printf_options endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 8
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl _vfprintf_l(FILE *File, const char *Format, _locale_t Locale, va_list ArgList)
		public __vfprintf_l
__vfprintf_l	proc near

File		= dword	ptr  4
Format		= dword	ptr  8
Locale		= dword	ptr  0Ch
ArgList		= dword	ptr  10h

		push	[esp+ArgList]
		push	[esp+4+Locale]
		push	[esp+8+Format]
		push	[esp+0Ch+File]
		call	___local_stdio_printf_options
		push	dword ptr [eax+4]
		push	dword ptr [eax]
		call	dword ptr ds:__imp____stdio_common_vfprintf
		add	esp, 18h
		retn
__vfprintf_l	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _pitem_free
_pitem_free	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short locret_3D
		mov	[esp+arg_0], eax
		jmp	_CRYPTO_free
; ---------------------------------------------------------------------------

locret_3D:				; CODE XREF: _pitem_free+6j
		retn
_pitem_free	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 40h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _pitem_new
_pitem_new	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	47h ; 'G'
		push	offset ??_C@_0BJ@KBJOCCHL@?4?2crypto?2pqueue?2pqueue?4c?$AA@ ; ".\\crypto\\pqueue\\pqueue.c"
		push	10h
		call	_CRYPTO_malloc
		mov	edx, eax
		add	esp, 0Ch
		test	edx, edx
		jnz	short loc_58
		retn
; ---------------------------------------------------------------------------

loc_58:					; CODE XREF: _pitem_new+15j
		mov	ecx, [esp+arg_0]
		mov	eax, [ecx]
		mov	[edx], eax
		mov	eax, [ecx+4]
		mov	[edx+4], eax
		mov	eax, [esp+arg_4]
		mov	[edx+8], eax
		mov	eax, edx
		mov	dword ptr [edx+0Ch], 0
		retn
_pitem_new	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 78h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _pqueue_find
_pqueue_find	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, [esp+arg_0]
		push	edi
		xor	edi, edi
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_87
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_87:					; CODE XREF: _pqueue_find+Bj
		mov	edx, [eax+0Ch]
		push	esi
		mov	esi, [esp+8+arg_4]
		test	edx, edx
		jz	short loc_B3
		nop	dword ptr [eax+eax+00h]

loc_98:					; CODE XREF: _pqueue_find+35j
		mov	ecx, [eax]
		cmp	ecx, [esi]
		jnz	short loc_A6
		mov	ecx, [eax+4]
		cmp	ecx, [esi+4]
		jz	short loc_B1

loc_A6:					; CODE XREF: _pqueue_find+24j
		mov	eax, edx
		mov	edx, [eax+0Ch]
		test	edx, edx
		jnz	short loc_98
		jmp	short loc_B3
; ---------------------------------------------------------------------------

loc_B1:					; CODE XREF: _pqueue_find+2Cj
		mov	edi, eax

loc_B3:					; CODE XREF: _pqueue_find+19j
					; _pqueue_find+37j
		mov	ecx, [eax]
		cmp	ecx, [esi]
		jnz	short loc_C1
		mov	ecx, [eax+4]
		cmp	ecx, [esi+4]
		jz	short loc_C3

loc_C1:					; CODE XREF: _pqueue_find+3Fj
		mov	eax, edi

loc_C3:					; CODE XREF: _pqueue_find+47j
		pop	esi
		pop	edi
		retn
_pqueue_find	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0C8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _pqueue_free
_pqueue_free	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		test	eax, eax
		jz	short locret_D9
		mov	[esp+arg_0], eax
		jmp	_CRYPTO_free
; ---------------------------------------------------------------------------

locret_D9:				; CODE XREF: _pqueue_free+6j
		retn
_pqueue_free	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 0DCh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _pqueue_insert
_pqueue_insert	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	ecx, [esp+arg_0]
		push	edi
		mov	edi, [ecx]
		test	edi, edi
		jnz	short loc_EF
		mov	eax, [esp+4+arg_4]
		mov	[ecx], eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_EF:					; CODE XREF: _pqueue_insert+9j
		push	ebx
		mov	ebx, [esp+8+arg_4]
		push	ebp
		xor	ebp, ebp
		push	esi
		nop	dword ptr [eax+00h]

loc_FC:					; CODE XREF: _pqueue_insert+77j
		mov	edx, edi
		mov	eax, ebx
		mov	esi, 4
		nop	dword ptr [eax+00000000h]

loc_10C:				; CODE XREF: _pqueue_insert+3Fj
		mov	ecx, [edx]
		cmp	ecx, [eax]
		jnz	short loc_121
		add	edx, 4
		add	eax, 4
		sub	esi, 4
		jnb	short loc_10C
		xor	eax, eax
		jmp	short loc_146
; ---------------------------------------------------------------------------

loc_121:				; CODE XREF: _pqueue_insert+34j
		cmp	cl, [eax]
		jnz	short loc_141
		mov	cl, [edx+1]
		cmp	cl, [eax+1]
		jnz	short loc_141
		mov	cl, [edx+2]
		cmp	cl, [eax+2]
		jnz	short loc_141
		mov	cl, [edx+3]
		cmp	cl, [eax+3]
		jnz	short loc_141
		xor	eax, eax
		jmp	short loc_146
; ---------------------------------------------------------------------------

loc_141:				; CODE XREF: _pqueue_insert+47j
					; _pqueue_insert+4Fj ...
		sbb	eax, eax
		or	eax, 1

loc_146:				; CODE XREF: _pqueue_insert+43j
					; _pqueue_insert+63j
		test	eax, eax
		jg	short loc_169
		jz	short loc_162
		mov	ebp, edi
		mov	edi, [edi+0Ch]
		test	edi, edi
		jnz	short loc_FC
		mov	[ebx+0Ch], edi

loc_158:				; CODE XREF: _pqueue_insert+92j
		pop	esi
		mov	[ebp+0Ch], ebx
		mov	eax, ebx
		pop	ebp
		pop	ebx
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_162:				; CODE XREF: _pqueue_insert+6Ej
		pop	esi
		pop	ebp
		pop	ebx
		xor	eax, eax
		pop	edi
		retn
; ---------------------------------------------------------------------------

loc_169:				; CODE XREF: _pqueue_insert+6Cj
		mov	[ebx+0Ch], edi
		test	ebp, ebp
		jnz	short loc_158
		mov	eax, [esp+10h+arg_0]
		pop	esi
		pop	ebp
		mov	[eax], ebx
		mov	eax, ebx
		pop	ebx
		pop	edi
		retn
_pqueue_insert	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 180h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _pqueue_iterator
_pqueue_iterator proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax]
		retn
_pqueue_iterator endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 188h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _pqueue_new
_pqueue_new	proc near
		push	5Dh ; ']'
		push	offset ??_C@_0BJ@KBJOCCHL@?4?2crypto?2pqueue?2pqueue?4c?$AA@ ; ".\\crypto\\pqueue\\pqueue.c"
		push	8
		call	_CRYPTO_malloc
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_19E
		retn
; ---------------------------------------------------------------------------

loc_19E:				; CODE XREF: _pqueue_new+13j
		xorps	xmm0, xmm0
		movq	qword ptr [eax], xmm0
		retn
_pqueue_new	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1A8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _pqueue_next
_pqueue_next	proc near

arg_0		= dword	ptr  4

		mov	edx, [esp+arg_0]
		test	edx, edx
		jz	short loc_1BC
		mov	eax, [edx]
		test	eax, eax
		jz	short loc_1BC
		mov	ecx, [eax+0Ch]
		mov	[edx], ecx
		retn
; ---------------------------------------------------------------------------

loc_1BC:				; CODE XREF: _pqueue_next+6j
					; _pqueue_next+Cj
		xor	eax, eax
		retn
_pqueue_next	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1C0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _pqueue_peek
_pqueue_peek	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		mov	eax, [eax]
		retn
_pqueue_peek	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1C8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _pqueue_pop
_pqueue_pop	proc near

arg_0		= dword	ptr  4

		mov	edx, [esp+arg_0]
		mov	eax, [edx]
		test	eax, eax
		jz	short locret_1D7
		mov	ecx, [eax+0Ch]
		mov	[edx], ecx

locret_1D7:				; CODE XREF: _pqueue_pop+8j
		retn
_pqueue_pop	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1D8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _pqueue_print
_pqueue_print	proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		mov	esi, [esi]
		test	esi, esi
		jz	short loc_223
		nop	dword ptr [eax+eax+00h]

loc_1E8:				; CODE XREF: _pqueue_print+49j
		movzx	eax, byte ptr [esi+7]
		push	eax
		movzx	eax, byte ptr [esi+6]
		push	eax
		movzx	eax, byte ptr [esi+5]
		push	eax
		movzx	eax, byte ptr [esi+4]
		push	eax
		movzx	eax, byte ptr [esi+3]
		push	eax
		movzx	eax, byte ptr [esi+2]
		push	eax
		movzx	eax, byte ptr [esi+1]
		push	eax
		movzx	eax, byte ptr [esi]
		push	eax
		push	offset ??_C@_0CH@JCLNLEP@item?7?$CF02x?$CF02x?$CF02x?$CF02x?$CF02x?$CF02x?$CF02@ ; "item\t%02x%02x%02x%02x%02x%02x%02x%02x\"...
		call	_printf
		mov	esi, [esi+0Ch]
		add	esp, 24h
		test	esi, esi
		jnz	short loc_1E8

loc_223:				; CODE XREF: _pqueue_print+9j
		pop	esi
		retn
_pqueue_print	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 228h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _pqueue_size
_pqueue_size	proc near

arg_0		= dword	ptr  4

		mov	ecx, [esp+arg_0]
		xor	eax, eax
		mov	ecx, [ecx]
		test	ecx, ecx
		jz	short locret_240
		nop	dword ptr [eax+00h]

loc_238:				; CODE XREF: _pqueue_size+16j
		mov	ecx, [ecx+0Ch]
		inc	eax
		test	ecx, ecx
		jnz	short loc_238

locret_240:				; CODE XREF: _pqueue_size+Aj
		retn
_pqueue_size	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 244h
; COMDAT (pick any)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int printf(const char	*Format, ...)
		public _printf
_printf		proc near		; CODE XREF: _pqueue_print+3Cp

Format		= dword	ptr  4
arg_4		= byte ptr  8

		push	esi
		mov	esi, [esp+4+Format]
		push	1
		call	dword ptr ds:__imp____acrt_iob_func
		add	esp, 4
		lea	ecx, [esp+4+arg_4]
		push	ecx
		push	0
		push	esi
		push	eax
		call	___local_stdio_printf_options
		push	dword ptr [eax+4]
		push	dword ptr [eax]
		call	dword ptr ds:__imp____stdio_common_vfprintf
		add	esp, 18h
		pop	esi
		retn
_printf		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 274h
; COMDAT (pick any)
		public ??_C@_0BJ@KBJOCCHL@?4?2crypto?2pqueue?2pqueue?4c?$AA@
; `string'
??_C@_0BJ@KBJOCCHL@?4?2crypto?2pqueue?2pqueue?4c?$AA@ db '.\crypto\pqueue\pqueue.c',0
					; DATA XREF: _pitem_new+2o
					; _pqueue_new+2o
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 290h
; COMDAT (pick any)
		public ??_C@_0CH@JCLNLEP@item?7?$CF02x?$CF02x?$CF02x?$CF02x?$CF02x?$CF02x?$CF02@
; char `string'[]
??_C@_0CH@JCLNLEP@item?7?$CF02x?$CF02x?$CF02x?$CF02x?$CF02x?$CF02x?$CF02@ db 'item',9,'%02x%02x%02x%02x%02x%02x%02x%02x',0Ah,0
					; DATA XREF: _pqueue_print+37o
_rdata		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __imp____acrt_iob_func:near ; CODE XREF: _printf+7p
					; DATA XREF: _printf+7r
		extrn __imp____stdio_common_vfprintf:near ; CODE XREF: __vfprintf_l+1Ap
					; _printf+23p
					; DATA XREF: ...
		extrn _CRYPTO_malloc:near ; CODE XREF: _pitem_new+9p
					; _pqueue_new+9p
		extrn _CRYPTO_free:near	; CODE XREF: _pitem_free+Cj
					; _pqueue_free+Cj
; `__local_stdio_printf_options'::`2'::_OptionsStorage
		extrn ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:near
					; DATA XREF: ___local_stdio_printf_optionso


		end
