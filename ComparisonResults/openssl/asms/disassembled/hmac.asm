;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	4C1E64435B4E36ED9F941278D1E4DCF6
; Input	CRC32 :	A847FCD7

; File Name   :	C:\compspace\Diff\openssl\obj\hmac.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl HMAC(int,	void *Src, size_t Size,	int, int, int, int)
		public _HMAC
_HMAC		proc near

var_D8		= dword	ptr -0D8h
Dst		= dword	ptr -0D4h
var_D0		= byte ptr -0D0h
var_B8		= byte ptr -0B8h
var_A0		= byte ptr -0A0h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
Src		= dword	ptr  8
Size		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h
arg_18		= dword	ptr  1Ch

		mov	eax, 0D8h ; 'Ø'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+0D8h+var_4], eax
		mov	eax, [esp+0D8h+arg_C]
		push	ebx
		mov	ebx, [esp+0DCh+Src]
		push	ebp
		mov	ebp, [esp+0E0h+arg_18]
		mov	[esp+0E0h+var_D8], eax
		mov	eax, [esp+0E0h+arg_14]
		test	eax, eax
		push	esi
		mov	esi, offset ?m@?1??HMAC@@9@9 ; `HMAC'::`2'::m
		cmovnz	esi, eax
		lea	eax, [esp+0E4h+var_B8]
		push	edi
		mov	edi, [esp+0E8h+arg_0]
		push	eax
		call	_EVP_MD_CTX_init
		lea	eax, [esp+0ECh+var_A0]
		push	eax
		call	_EVP_MD_CTX_init
		lea	eax, [esp+0F0h+var_D0]
		push	eax
		call	_EVP_MD_CTX_init
		add	esp, 0Ch
		mov	[esp+0E8h+Dst],	0
		test	ebx, ebx
		jz	short loc_A7
		test	edi, edi
		jz	short loc_A7
		lea	eax, [esp+0E8h+var_B8]
		push	eax
		call	_EVP_MD_CTX_init
		lea	eax, [esp+0ECh+var_A0]
		push	eax
		call	_EVP_MD_CTX_init
		lea	eax, [esp+0F0h+var_D0]
		push	eax
		call	_EVP_MD_CTX_init
		add	esp, 0Ch
		mov	[esp+0E8h+Dst],	0

loc_A7:					; CODE XREF: _HMAC+78j	_HMAC+7Cj
		push	0		; int
		push	edi		; int
		push	[esp+0F0h+Size]	; Size
		lea	eax, [esp+0F4h+Dst]
		push	ebx		; Src
		push	eax		; int
		call	_HMAC_Init_ex
		add	esp, 14h
		test	eax, eax
		jz	short $err$20
		cmp	[esp+0E8h+Dst],	0
		jz	short $err$20
		push	[esp+0E8h+arg_10]
		lea	eax, [esp+0ECh+var_D0]
		push	[esp+0ECh+var_D8]
		push	eax
		call	_EVP_DigestUpdate
		add	esp, 0Ch
		test	eax, eax
		jz	short $err$20
		push	ebp
		lea	eax, [esp+0ECh+Dst]
		push	esi
		push	eax
		call	_HMAC_Final
		add	esp, 0Ch
		test	eax, eax
		jz	short $err$20
		lea	eax, [esp+0E8h+Dst]
		push	eax		; Dst
		call	_HMAC_CTX_cleanup
		add	esp, 4
		mov	eax, esi
		jmp	short loc_12D
; ---------------------------------------------------------------------------

$err$20:				; CODE XREF: _HMAC+C1j	_HMAC+C8j ...
		lea	eax, [esp+0E8h+var_B8]
		push	eax
		call	_EVP_MD_CTX_cleanup
		lea	eax, [esp+0ECh+var_A0]
		push	eax
		call	_EVP_MD_CTX_cleanup
		lea	eax, [esp+0F0h+var_D0]
		push	eax
		call	_EVP_MD_CTX_cleanup
		add	esp, 0Ch
		xor	eax, eax

loc_12D:				; CODE XREF: _HMAC+108j
		mov	ecx, [esp+0E8h+var_4]
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 0D8h
		retn
_HMAC		endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 148h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl HMAC_CTX_cleanup(void *Dst)
		public _HMAC_CTX_cleanup
_HMAC_CTX_cleanup proc near		; CODE XREF: _HMAC+FEp

Dst		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+Dst]
		lea	eax, [esi+1Ch]
		push	eax
		call	_EVP_MD_CTX_cleanup
		lea	eax, [esi+34h]
		push	eax
		call	_EVP_MD_CTX_cleanup
		lea	eax, [esi+4]
		push	eax
		call	_EVP_MD_CTX_cleanup
		push	0D0h ; 'Ð'      ; Size
		push	0		; Val
		push	esi		; Dst
		call	_memset
		add	esp, 18h
		pop	esi
		retn
_HMAC_CTX_cleanup endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 17Ch
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _HMAC_CTX_copy
_HMAC_CTX_copy	proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	ebx
		mov	ebx, [esp+4+arg_4]
		push	ebp
		mov	ebp, [esp+8+arg_0]
		lea	eax, [ebx+1Ch]
		push	eax
		lea	eax, [ebp+1Ch]
		push	eax
		call	_EVP_MD_CTX_copy
		add	esp, 8
		test	eax, eax
		jz	short $err$7
		lea	eax, [ebx+34h]
		push	eax
		lea	eax, [ebp+34h]
		push	eax
		call	_EVP_MD_CTX_copy
		add	esp, 8
		test	eax, eax
		jz	short $err$7
		lea	eax, [ebx+4]
		push	eax
		lea	eax, [ebp+4]
		push	eax
		call	_EVP_MD_CTX_copy
		add	esp, 8
		test	eax, eax
		jz	short $err$7
		push	esi
		push	edi
		lea	esi, [ebx+50h]
		mov	ecx, 20h ; ' '
		lea	edi, [ebp+50h]
		rep movsd
		mov	eax, [ebx+4Ch]
		pop	edi
		mov	[ebp+4Ch], eax
		mov	eax, [ebx]
		pop	esi
		mov	[ebp+0], eax
		mov	eax, 1
		pop	ebp
		pop	ebx
		retn
; ---------------------------------------------------------------------------

$err$7:					; CODE XREF: _HMAC_CTX_copy+1Cj
					; _HMAC_CTX_copy+30j ...
		pop	ebp
		xor	eax, eax
		pop	ebx
		retn
_HMAC_CTX_copy	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 1ECh
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _HMAC_CTX_init
_HMAC_CTX_init	proc near

arg_0		= dword	ptr  4

		push	esi
		mov	esi, [esp+4+arg_0]
		lea	eax, [esi+1Ch]
		push	eax
		call	_EVP_MD_CTX_init
		lea	eax, [esi+34h]
		push	eax
		call	_EVP_MD_CTX_init
		lea	eax, [esi+4]
		push	eax
		call	_EVP_MD_CTX_init
		add	esp, 0Ch
		mov	dword ptr [esi], 0
		pop	esi
		retn
_HMAC_CTX_init	endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 218h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _HMAC_CTX_set_flags
_HMAC_CTX_set_flags proc near

arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		push	esi
		mov	esi, [esp+4+arg_0]
		push	edi
		mov	edi, [esp+8+arg_4]
		push	edi
		lea	eax, [esi+1Ch]
		push	eax
		call	_EVP_MD_CTX_set_flags
		lea	eax, [esi+34h]
		push	edi
		push	eax
		call	_EVP_MD_CTX_set_flags
		lea	eax, [esi+4]
		push	edi
		push	eax
		call	_EVP_MD_CTX_set_flags
		add	esp, 18h
		pop	edi
		pop	esi
		retn
_HMAC_CTX_set_flags endp

; ---------------------------------------------------------------------------
		align 4
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 248h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _HMAC_Final
_HMAC_Final	proc near		; CODE XREF: _HMAC+EDp

var_48		= dword	ptr -48h
var_44		= byte ptr -44h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch

		mov	eax, 48h ; 'H'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+48h+var_4], eax
		push	ebx
		mov	ebx, [esp+4Ch+arg_4]
		push	ebp
		mov	ebp, [esp+50h+arg_8]
		push	esi
		mov	esi, [esp+54h+arg_0]
		push	edi
		cmp	dword ptr [esi], 0
		jz	short $err$9
		lea	eax, [esp+58h+var_48]
		push	eax
		lea	eax, [esp+5Ch+var_44]
		push	eax
		lea	edi, [esi+4]
		push	edi
		call	_EVP_DigestFinal_ex
		add	esp, 0Ch
		test	eax, eax
		jz	short $err$9
		lea	eax, [esi+34h]
		push	eax
		push	edi
		call	_EVP_MD_CTX_copy_ex
		add	esp, 8
		test	eax, eax
		jz	short $err$9
		push	[esp+58h+var_48]
		lea	eax, [esp+5Ch+var_44]
		push	eax
		push	edi
		call	_EVP_DigestUpdate
		add	esp, 0Ch
		test	eax, eax
		jz	short $err$9
		push	ebp
		push	ebx
		push	edi
		call	_EVP_DigestFinal_ex
		add	esp, 0Ch
		test	eax, eax
		jz	short $err$9
		pop	edi
		pop	esi
		pop	ebp
		mov	eax, 1
		pop	ebx
		mov	ecx, [esp+48h+var_4]
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 48h
		retn
; ---------------------------------------------------------------------------

$err$9:					; CODE XREF: _HMAC_Final+28j
					; _HMAC_Final+42j ...
		mov	ecx, [esp+58h+var_4]
		xor	eax, eax
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 48h
		retn
_HMAC_Final	endp

; ---------------------------------------------------------------------------
		align 10h
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 2F0h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl HMAC_Init(int, void *Src,	size_t Size, int)
		public _HMAC_Init
_HMAC_Init	proc near

arg_0		= dword	ptr  4
Src		= dword	ptr  8
Size		= dword	ptr  0Ch
arg_C		= dword	ptr  10h

		cmp	[esp+Src], 0
		push	esi
		mov	esi, [esp+4+arg_0]
		jz	short loc_327
		cmp	[esp+4+arg_C], 0
		jz	short loc_327
		lea	eax, [esi+1Ch]
		push	eax
		call	_EVP_MD_CTX_init
		lea	eax, [esi+34h]
		push	eax
		call	_EVP_MD_CTX_init
		lea	eax, [esi+4]
		push	eax
		call	_EVP_MD_CTX_init
		add	esp, 0Ch
		mov	dword ptr [esi], 0

loc_327:				; CODE XREF: _HMAC_Init+Aj
					; _HMAC_Init+11j
		push	0		; int
		push	[esp+8+arg_C]	; int
		push	[esp+0Ch+Size]	; Size
		push	[esp+10h+Src]	; Src
		push	esi		; int
		call	_HMAC_Init_ex
		add	esp, 14h
		pop	esi
		retn
_HMAC_Init	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 340h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


; int __cdecl HMAC_Init_ex(int,	void *Src, size_t Size,	int, int)
		public _HMAC_Init_ex
_HMAC_Init_ex	proc near		; CODE XREF: _HMAC+B7p	_HMAC_Init+46p

var_8C		= dword	ptr -8Ch
var_88		= dword	ptr -88h
var_84		= byte ptr -84h
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
Src		= dword	ptr  8
Size		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h

		mov	eax, 8Ch ; 'Œ'
		call	__chkstk
		mov	eax, dword ptr ds:___security_cookie
		xor	eax, esp
		mov	[esp+8Ch+var_4], eax
		mov	edx, [esp+8Ch+arg_10]
		xor	eax, eax
		push	ebx
		mov	ebx, [esp+90h+Size]
		push	ebp
		mov	ebp, [esp+94h+Src]
		push	esi
		mov	esi, [esp+98h+arg_0]
		push	edi
		mov	edi, [esp+9Ch+arg_C]
		mov	[esp+9Ch+var_8C], edx
		test	edi, edi
		jz	short loc_3A6
		cmp	edi, [esi]
		jz	short loc_39D
		test	ebp, ebp
		jz	$err$43
		test	ebx, ebx
		js	$err$43

loc_39D:				; CODE XREF: _HMAC_Init_ex+4Bj
		mov	eax, 1
		mov	[esi], edi
		jmp	short loc_3AC
; ---------------------------------------------------------------------------

loc_3A6:				; CODE XREF: _HMAC_Init_ex+47j
		mov	edi, [esi]
		test	edi, edi
		jz	short $err$43

loc_3AC:				; CODE XREF: _HMAC_Init_ex+64j
		test	ebp, ebp
		jz	loc_53B
		push	edi
		call	_EVP_MD_block_size
		add	esp, 4
		mov	[esp+9Ch+var_88], eax
		cmp	eax, 80h ; '€'
		jle	short loc_3E0
		push	offset ??_C@_0BL@OKHNPHMK@j?5?$DM?$DN?5?$CIint?$CJsizeof?$CIctx?9?$DOkey?$CJ?$AA@ ; "j <= (int)sizeof(ctx->key)"
		push	74h ; 't'
		push	offset ??_C@_0BF@PGACILEA@?4?2crypto?2hmac?2hmac?4c?$AA@ ; ".\\crypto\\hmac\\hmac.c"
		call	_OpenSSLDie
		mov	eax, [esp+0A8h+var_88]
		add	esp, 0Ch

loc_3E0:				; CODE XREF: _HMAC_Init_ex+86j
		cmp	eax, ebx
		jge	short loc_43B
		push	[esp+9Ch+var_8C]
		lea	eax, [esi+4]
		push	edi
		push	eax
		call	_EVP_DigestInit_ex
		add	esp, 0Ch
		test	eax, eax
		jz	short $err$43
		push	ebx
		push	ebp
		lea	ebx, [esi+4]
		push	ebx
		call	_EVP_DigestUpdate
		add	esp, 0Ch
		test	eax, eax
		jz	short $err$43
		lea	ebp, [esi+4Ch]
		push	ebp
		lea	eax, [esi+50h]
		push	eax
		push	ebx
		call	_EVP_DigestFinal_ex
		add	esp, 0Ch
		test	eax, eax
		jnz	short loc_457

$err$43:				; CODE XREF: _HMAC_Init_ex+4Fj
					; _HMAC_Init_ex+57j ...
		xor	eax, eax

loc_422:				; CODE XREF: _HMAC_Init_ex+1F6j
		mov	ecx, [esp+9Ch+var_4]
		pop	edi
		pop	esi
		pop	ebp
		pop	ebx
		xor	ecx, esp
		call	@__security_check_cookie@4 ; __security_check_cookie(x)
		add	esp, 8Ch
		retn
; ---------------------------------------------------------------------------

loc_43B:				; CODE XREF: _HMAC_Init_ex+A2j
		cmp	ebx, 80h ; '€'
		ja	short $err$43
		push	ebx		; Size
		lea	eax, [esi+50h]
		push	ebp		; Src
		push	eax		; Dst
		call	_memcpy
		lea	ebp, [esi+4Ch]
		add	esp, 0Ch
		mov	[ebp+0], ebx

loc_457:				; CODE XREF: _HMAC_Init_ex+DEj
		mov	ecx, [ebp+0]
		cmp	ecx, 80h ; '€'
		jz	short loc_47A
		mov	eax, 80h ; '€'
		sub	eax, ecx
		push	eax		; Size
		lea	eax, [esi+50h]
		add	eax, ecx
		push	0		; Val
		push	eax		; Dst
		call	_memset
		add	esp, 0Ch

loc_47A:				; CODE XREF: _HMAC_Init_ex+120j
		mov	edx, [esp+9Ch+var_8C]

loc_47E:				; CODE XREF: _HMAC_Init_ex+1FFj
		xor	ecx, ecx

loc_480:				; CODE XREF: _HMAC_Init_ex+151j
		mov	al, [esi+ecx+50h]
		xor	al, 36h
		mov	[esp+ecx+9Ch+var_84], al
		inc	ecx
		cmp	ecx, 80h ; '€'
		jl	short loc_480
		push	edx
		lea	ebx, [esi+1Ch]
		push	edi
		push	ebx
		call	_EVP_DigestInit_ex
		add	esp, 0Ch
		test	eax, eax
		jz	$err$43
		push	edi
		call	_EVP_MD_block_size
		push	eax
		lea	eax, [esp+0A4h+var_84]
		push	eax
		push	ebx
		call	_EVP_DigestUpdate
		add	esp, 10h
		test	eax, eax
		jz	$err$43
		xor	ecx, ecx
		nop	dword ptr [eax+eax+00000000h]

loc_4D0:				; CODE XREF: _HMAC_Init_ex+1A1j
		mov	al, [esi+ecx+50h]
		xor	al, 5Ch
		mov	[esp+ecx+9Ch+var_84], al
		inc	ecx
		cmp	ecx, 80h ; '€'
		jl	short loc_4D0
		push	[esp+9Ch+var_8C]
		lea	ebx, [esi+34h]
		push	edi
		push	ebx
		call	_EVP_DigestInit_ex
		add	esp, 0Ch
		test	eax, eax
		jz	$err$43
		push	edi
		call	_EVP_MD_block_size
		push	eax
		lea	eax, [esp+0A4h+var_84]
		push	eax
		push	ebx
		call	_EVP_DigestUpdate
		add	esp, 10h
		test	eax, eax
		jz	$err$43

loc_519:				; CODE XREF: _HMAC_Init_ex+1FDj
		lea	eax, [esi+1Ch]
		push	eax
		lea	eax, [esi+4]
		push	eax
		call	_EVP_MD_CTX_copy_ex
		add	esp, 8
		test	eax, eax
		jz	$err$43
		mov	eax, 1
		jmp	loc_422
; ---------------------------------------------------------------------------

loc_53B:				; CODE XREF: _HMAC_Init_ex+6Ej
		test	eax, eax
		jz	short loc_519
		jmp	loc_47E
_HMAC_Init_ex	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 544h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _HMAC_Update
_HMAC_Update	proc near

arg_0		= dword	ptr  4

		mov	eax, [esp+arg_0]
		cmp	dword ptr [eax], 0
		jnz	short loc_550
		xor	eax, eax
		retn
; ---------------------------------------------------------------------------

loc_550:				; CODE XREF: _HMAC_Update+7j
		add	eax, 4
		mov	[esp+arg_0], eax
		jmp	_EVP_DigestUpdate
_HMAC_Update	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 55Ch
; COMDAT (pick any)
		public ??_C@_0BL@OKHNPHMK@j?5?$DM?$DN?5?$CIint?$CJsizeof?$CIctx?9?$DOkey?$CJ?$AA@
; `string'
??_C@_0BL@OKHNPHMK@j?5?$DM?$DN?5?$CIint?$CJsizeof?$CIctx?9?$DOkey?$CJ?$AA@ db 'j <= (int)sizeof(ctx->key)',0
					; DATA XREF: _HMAC_Init_ex+88o
		align 4
_rdata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rdata		segment	dword public 'DATA' use32
		assume cs:_rdata
		;org 578h
; COMDAT (pick any)
		public ??_C@_0BF@PGACILEA@?4?2crypto?2hmac?2hmac?4c?$AA@
; `string'
??_C@_0BF@PGACILEA@?4?2crypto?2hmac?2hmac?4c?$AA@ db '.\crypto\hmac\hmac.c',0
					; DATA XREF: _HMAC_Init_ex+8Fo
		align 10h
_rdata		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_bss		segment	para public 'BSS' use32
		assume cs:_bss
		;org 590h
		assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
; `HMAC'::`2'::m
?m@?1??HMAC@@9@9 dd 10h	dup(?)		; DATA XREF: _HMAC+3Do
_bss		ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn _OpenSSLDie:near	; CODE XREF: _HMAC_Init_ex+94p
		extrn _EVP_MD_block_size:near ;	CODE XREF: _HMAC_Init_ex+75p
					; _HMAC_Init_ex+16Ap ...
		extrn _EVP_MD_CTX_init:near ; CODE XREF: _HMAC+52p _HMAC+5Cp ...
		extrn _EVP_MD_CTX_cleanup:near ; CODE XREF: _HMAC+10Fp
					; _HMAC+119p ...
		extrn _EVP_MD_CTX_copy_ex:near ; CODE XREF: _HMAC_Final+49p
					; _HMAC_Init_ex+1E1p
		extrn _EVP_MD_CTX_set_flags:near ; CODE	XREF: _HMAC_CTX_set_flags+Fp
					; _HMAC_CTX_set_flags+19p ...
		extrn _EVP_DigestInit_ex:near ;	CODE XREF: _HMAC_Init_ex+ADp
					; _HMAC_Init_ex+159p ...
		extrn _EVP_DigestUpdate:near ; CODE XREF: _HMAC+DAp
					; _HMAC_Final+5Fp ...
		extrn _EVP_DigestFinal_ex:near ; CODE XREF: _HMAC_Final+38p
					; _HMAC_Final+6Ep ...
		extrn _EVP_MD_CTX_copy:near ; CODE XREF: _HMAC_CTX_copy+12p
					; _HMAC_CTX_copy+26p ...
; __fastcall __security_check_cookie(x)
		extrn @__security_check_cookie@4:near ;	CODE XREF: _HMAC+13Ap
					; _HMAC_Final+89p ...
		extrn __chkstk:near	; CODE XREF: _HMAC+5p _HMAC_Final+5p ...
; void *__cdecl	memcpy(void *Dst, const	void *Src, size_t Size)
		extrn _memcpy:near	; CODE XREF: _HMAC_Init_ex+109p
; void *__cdecl	memset(void *Dst, int Val, size_t Size)
		extrn _memset:near	; CODE XREF: _HMAC_CTX_cleanup+28p
					; _HMAC_Init_ex+132p
		extrn ___security_cookie:near ;	DATA XREF: _HMAC+Ar
					; _HMAC_Final+Ar ...


		end
