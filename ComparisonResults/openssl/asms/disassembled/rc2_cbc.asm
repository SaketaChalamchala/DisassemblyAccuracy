;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-3677-7074-51			    |
; |		Michalis Polychronakis,	Stony Brook University		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	02118A3CB82A35A18FD1C97AFF5B5342
; Input	CRC32 :	A7077B0D

; File Name   :	C:\compspace\Diff\openssl\obj\rc2_cbc.obj
; Format      :	COFF (X386MAGIC)
; includelib "MSVCRT"
; includelib "OLDNAMES"

		.686p
		.mmx
		.model flat

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _RC2_cbc_encrypt
_RC2_cbc_encrypt proc near

var_14		= dword	ptr -14h
var_10		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8
arg_8		= dword	ptr  0Ch
arg_C		= dword	ptr  10h
arg_10		= dword	ptr  14h
arg_14		= dword	ptr  18h

		mov	eax, 14h
		call	__chkstk
		cmp	[esp+14h+arg_14], 0
		push	ebx
		push	ebp
		push	esi
		push	edi
		jz	loc_248
		mov	esi, [esp+24h+arg_10]
		mov	ebp, [esp+24h+arg_8]
		mov	edi, [esp+24h+arg_4]
		mov	ebx, [esp+24h+arg_0]
		movzx	eax, byte ptr [esi+1]
		movzx	edx, byte ptr [esi]
		movzx	ecx, byte ptr [esi+4]
		shl	eax, 8
		or	edx, eax
		movzx	eax, byte ptr [esi+2]
		shl	eax, 10h
		or	edx, eax
		movzx	eax, byte ptr [esi+3]
		shl	eax, 18h
		or	edx, eax
		movzx	eax, byte ptr [esi+5]
		shl	eax, 8
		or	ecx, eax
		mov	[esp+24h+var_14], edx
		movzx	eax, byte ptr [esi+6]
		shl	eax, 10h
		or	ecx, eax
		movzx	eax, byte ptr [esi+7]
		shl	eax, 18h
		or	ecx, eax
		add	ebp, 0FFFFFFF8h
		mov	[esp+24h+arg_14], ecx
		mov	[esp+24h+arg_8], ebp
		js	loc_149
		lea	eax, [ebp+8]
		shr	eax, 3
		mov	[esp+24h+var_10], eax
		neg	eax
		lea	ebp, [ebp+eax*8+0]
		mov	[esp+24h+arg_8], ebp
		mov	ebp, [esp+24h+var_10]

loc_93:					; CODE XREF: _RC2_cbc_encrypt+13Fj
		movzx	eax, byte ptr [ebx+1]
		movzx	edx, byte ptr [ebx]
		movzx	ecx, byte ptr [ebx+4]
		shl	eax, 8
		or	edx, eax
		movzx	eax, byte ptr [ebx+2]
		shl	eax, 10h
		push	[esp+24h+arg_C]
		or	edx, eax
		movzx	eax, byte ptr [ebx+3]
		shl	eax, 18h
		or	edx, eax
		movzx	eax, byte ptr [ebx+5]
		xor	edx, [esp+28h+var_14]
		shl	eax, 8
		or	ecx, eax
		mov	[esp+28h+var_8], edx
		movzx	eax, byte ptr [ebx+6]
		shl	eax, 10h
		or	ecx, eax
		movzx	eax, byte ptr [ebx+7]
		shl	eax, 18h
		add	ebx, 8
		or	ecx, eax
		lea	eax, [esp+28h+var_8]
		xor	ecx, [esp+28h+arg_14]
		push	eax
		mov	[esp+2Ch+var_4], ecx
		call	_RC2_encrypt
		mov	edx, [esp+2Ch+var_8]
		add	esp, 8
		mov	ecx, [esp+24h+var_4]
		mov	eax, edx
		shr	eax, 8
		mov	[edi], dl
		mov	[edi+1], al
		mov	eax, edx
		shr	eax, 10h
		mov	[edi+2], al
		mov	eax, edx
		shr	eax, 18h
		mov	[edi+3], al
		mov	eax, ecx
		shr	eax, 8
		mov	[edi+4], cl
		mov	[edi+5], al
		mov	eax, ecx
		shr	eax, 10h
		mov	[edi+6], al
		mov	eax, ecx
		shr	eax, 18h
		mov	[edi+7], al
		add	edi, 8
		mov	[esp+24h+var_14], edx
		mov	[esp+24h+arg_14], ecx
		sub	ebp, 1
		jnz	loc_93
		mov	ebp, [esp+24h+arg_8]

loc_149:				; CODE XREF: _RC2_cbc_encrypt+75j
		cmp	ebp, 0FFFFFFF8h
		jz	loc_20F
		mov	eax, [esp+24h+arg_8]
		lea	ecx, [ebp+8]
		add	ecx, ebx
		add	eax, 7
		xor	ebx, ebx
		xor	ebp, ebp
		cmp	eax, 7		; switch 8 cases
		ja	short loc_1B3	; jumptable 00000167 default case
		jmp	ds:$LN44[eax*4]	; switch jump
; ---------------------------------------------------------------------------

$LN15:					; CODE XREF: _RC2_cbc_encrypt+167j
					; DATA XREF: .text$mn:$LN44o
		movzx	ebx, byte ptr [ecx-1] ;	jumptable 00000167 case	7
		dec	ecx
		shl	ebx, 18h

$LN16:					; CODE XREF: _RC2_cbc_encrypt+167j
					; DATA XREF: .text$mn:$LN44o
		movzx	eax, byte ptr [ecx-1] ;	jumptable 00000167 case	6
		dec	ecx
		shl	eax, 10h
		or	ebx, eax

$LN17:					; CODE XREF: _RC2_cbc_encrypt+167j
					; DATA XREF: .text$mn:$LN44o
		movzx	eax, byte ptr [ecx-1] ;	jumptable 00000167 case	5
		dec	ecx
		shl	eax, 8
		or	ebx, eax

$LN18:					; CODE XREF: _RC2_cbc_encrypt+167j
					; DATA XREF: .text$mn:$LN44o
		movzx	eax, byte ptr [ecx-1] ;	jumptable 00000167 case	4
		dec	ecx
		or	ebx, eax

$LN19:					; CODE XREF: _RC2_cbc_encrypt+167j
					; DATA XREF: .text$mn:$LN44o
		movzx	ebp, byte ptr [ecx-1] ;	jumptable 00000167 case	3
		dec	ecx
		shl	ebp, 18h

$LN20:					; CODE XREF: _RC2_cbc_encrypt+167j
					; DATA XREF: .text$mn:$LN44o
		movzx	eax, byte ptr [ecx-1] ;	jumptable 00000167 case	2
		dec	ecx
		shl	eax, 10h
		or	ebp, eax

$LN21:					; CODE XREF: _RC2_cbc_encrypt+167j
					; DATA XREF: .text$mn:$LN44o
		movzx	eax, byte ptr [ecx-1] ;	jumptable 00000167 case	1
		dec	ecx
		shl	eax, 8
		or	ebp, eax

$LN22:					; CODE XREF: _RC2_cbc_encrypt+167j
					; DATA XREF: .text$mn:$LN44o
		movzx	eax, byte ptr [ecx-1] ;	jumptable 00000167 case	0
		or	ebp, eax

loc_1B3:				; CODE XREF: _RC2_cbc_encrypt+165j
		push	[esp+24h+arg_C]	; jumptable 00000167 default case
		xor	ebx, [esp+28h+arg_14]
		lea	eax, [esp+28h+var_8]
		xor	ebp, edx
		mov	[esp+28h+var_4], ebx
		push	eax
		mov	[esp+2Ch+var_8], ebp
		call	_RC2_encrypt
		mov	edx, [esp+2Ch+var_8]
		add	esp, 8
		mov	ecx, [esp+24h+var_4]
		mov	eax, edx
		shr	eax, 8
		mov	[edi], dl
		mov	[edi+1], al
		mov	eax, edx
		shr	eax, 10h
		mov	[edi+2], al
		mov	eax, edx
		shr	eax, 18h
		mov	[edi+3], al
		mov	eax, ecx
		shr	eax, 8
		mov	[edi+4], cl
		mov	[edi+5], al
		mov	eax, ecx
		shr	eax, 10h
		mov	[edi+6], al
		mov	eax, ecx
		shr	eax, 18h
		mov	[edi+7], al

loc_20F:				; CODE XREF: _RC2_cbc_encrypt+14Cj
		mov	[esi], dl
		mov	eax, edx
		shr	eax, 8
		mov	[esi+1], al
		mov	eax, edx
		shr	eax, 10h
		mov	[esi+2], al
		mov	eax, ecx
		shr	edx, 18h
		mov	[esi+3], dl
		mov	[esi+4], cl
		shr	eax, 8
		mov	[esi+5], al
		mov	eax, ecx
		shr	eax, 10h
		pop	edi
		mov	[esi+6], al
		shr	ecx, 18h
		mov	[esi+7], cl
		pop	esi
		pop	ebp
		pop	ebx
		add	esp, 14h
		retn
; ---------------------------------------------------------------------------

loc_248:				; CODE XREF: _RC2_cbc_encrypt+13j
		mov	ebx, [esp+24h+arg_10]
		mov	edi, [esp+24h+arg_8]
		mov	ebp, [esp+24h+arg_0]
		mov	[esp+24h+var_10], ebx
		movzx	eax, byte ptr [ebx+1]
		movzx	ecx, byte ptr [ebx]
		movzx	edx, byte ptr [ebx+4]
		shl	eax, 8
		or	ecx, eax
		movzx	eax, byte ptr [ebx+2]
		shl	eax, 10h
		or	ecx, eax
		movzx	eax, byte ptr [ebx+3]
		shl	eax, 18h
		or	ecx, eax
		movzx	eax, byte ptr [ebx+5]
		shl	eax, 8
		or	edx, eax
		mov	[esp+24h+arg_14], ecx
		movzx	eax, byte ptr [ebx+6]
		shl	eax, 10h
		or	edx, eax
		movzx	eax, byte ptr [ebx+7]
		shl	eax, 18h
		or	edx, eax
		add	edi, 0FFFFFFF8h
		mov	[esp+24h+var_14], edx
		js	loc_387
		mov	ebx, [esp+24h+arg_4]
		lea	eax, [edi+8]
		shr	eax, 3
		mov	[esp+24h+arg_8], eax
		neg	eax
		lea	edi, [edi+eax*8]
		mov	[esp+24h+var_C], edi
		nop	dword ptr [eax]

loc_2C0:				; CODE XREF: _RC2_cbc_encrypt+36Fj
		movzx	eax, byte ptr [ebp+1]
		movzx	edi, byte ptr [ebp+0]
		movzx	esi, byte ptr [ebp+4]
		shl	eax, 8
		or	edi, eax
		movzx	eax, byte ptr [ebp+2]
		shl	eax, 10h
		push	[esp+24h+arg_C]
		or	edi, eax
		movzx	eax, byte ptr [ebp+3]
		shl	eax, 18h
		or	edi, eax
		movzx	eax, byte ptr [ebp+5]
		shl	eax, 8
		or	esi, eax
		mov	[esp+28h+var_8], edi
		movzx	eax, byte ptr [ebp+6]
		shl	eax, 10h
		or	esi, eax
		movzx	eax, byte ptr [ebp+7]
		shl	eax, 18h
		add	ebp, 8
		or	esi, eax
		lea	eax, [esp+28h+var_8]
		push	eax
		mov	[esp+2Ch+var_4], esi
		call	_RC2_decrypt
		mov	ecx, [esp+2Ch+var_8]
		add	esp, 8
		xor	ecx, [esp+24h+arg_14]
		mov	edx, [esp+24h+var_4]
		mov	eax, ecx
		xor	edx, [esp+24h+var_14]
		mov	[ebx], cl
		shr	eax, 8
		mov	[ebx+1], al
		mov	eax, ecx
		shr	eax, 10h
		mov	[ebx+2], al
		mov	eax, edx
		shr	ecx, 18h
		mov	[ebx+3], cl
		mov	ecx, edi
		mov	[ebx+4], dl
		shr	eax, 8
		mov	[ebx+5], al
		mov	eax, edx
		shr	eax, 10h
		shr	edx, 18h
		mov	[ebx+6], al
		mov	[ebx+7], dl
		add	ebx, 8
		sub	[esp+24h+arg_8], 1
		mov	edx, esi
		mov	[esp+24h+arg_14], ecx
		mov	[esp+24h+var_14], edx
		jnz	loc_2C0
		mov	edi, [esp+24h+var_C]
		mov	[esp+24h+arg_8], ebx
		mov	ebx, [esp+24h+var_10]
		mov	esi, [esp+24h+arg_8]
		jmp	short loc_38B
; ---------------------------------------------------------------------------

loc_387:				; CODE XREF: _RC2_cbc_encrypt+2A0j
		mov	esi, [esp+24h+arg_4]

loc_38B:				; CODE XREF: _RC2_cbc_encrypt+385j
		cmp	edi, 0FFFFFFF8h
		jz	loc_45F
		movzx	eax, byte ptr [ebp+1]
		movzx	ecx, byte ptr [ebp+0]
		movzx	edx, byte ptr [ebp+4]
		push	[esp+24h+arg_C]
		shl	eax, 8
		or	ecx, eax
		movzx	eax, byte ptr [ebp+2]
		shl	eax, 10h
		or	ecx, eax
		movzx	eax, byte ptr [ebp+3]
		shl	eax, 18h
		or	ecx, eax
		movzx	eax, byte ptr [ebp+5]
		mov	[esp+28h+var_C], ecx
		mov	[esp+28h+var_8], ecx
		movzx	ecx, byte ptr [ebp+7]
		shl	eax, 8
		or	edx, eax
		shl	ecx, 8
		movzx	eax, byte ptr [ebp+6]
		or	ecx, eax
		lea	eax, [esp+28h+var_8]
		shl	ecx, 10h
		or	edx, ecx
		push	eax
		mov	[esp+2Ch+var_10], edx
		mov	[esp+2Ch+var_4], edx
		call	_RC2_decrypt
		mov	edx, [esp+2Ch+var_8]
		lea	ecx, [edi+8]
		mov	eax, [esp+2Ch+var_4]
		add	edi, 7
		xor	eax, [esp+2Ch+var_14]
		add	esp, 8
		xor	edx, [esp+24h+arg_14]
		add	ecx, esi
		mov	[esp+24h+arg_8], eax
		cmp	edi, 7		; switch 8 cases
		ja	short loc_457	; jumptable 00000414 default case
		jmp	ds:$LN45[edi*4]	; switch jump
; ---------------------------------------------------------------------------

$LN24:					; CODE XREF: _RC2_cbc_encrypt+414j
					; DATA XREF: .text$mn:$LN45o
		dec	ecx		; jumptable 00000414 case 7
		shr	eax, 18h
		mov	[ecx], al
		mov	eax, [esp+24h+arg_8]

$LN25:					; CODE XREF: _RC2_cbc_encrypt+414j
					; DATA XREF: .text$mn:$LN45o
		dec	ecx		; jumptable 00000414 case 6
		shr	eax, 10h
		mov	[ecx], al
		mov	eax, [esp+24h+arg_8]

$LN26:					; CODE XREF: _RC2_cbc_encrypt+414j
					; DATA XREF: .text$mn:$LN45o
		dec	ecx		; jumptable 00000414 case 5
		shr	eax, 8
		mov	[ecx], al
		mov	eax, [esp+24h+arg_8]

$LN27:					; CODE XREF: _RC2_cbc_encrypt+414j
					; DATA XREF: .text$mn:$LN45o
		dec	ecx		; jumptable 00000414 case 4
		mov	[ecx], al

$LN28:					; CODE XREF: _RC2_cbc_encrypt+414j
					; DATA XREF: .text$mn:$LN45o
		dec	ecx		; jumptable 00000414 case 3
		mov	eax, edx
		shr	eax, 18h
		mov	[ecx], al

$LN29:					; CODE XREF: _RC2_cbc_encrypt+414j
					; DATA XREF: .text$mn:$LN45o
		dec	ecx		; jumptable 00000414 case 2
		mov	eax, edx
		shr	eax, 10h
		mov	[ecx], al

$LN30:					; CODE XREF: _RC2_cbc_encrypt+414j
					; DATA XREF: .text$mn:$LN45o
		dec	ecx		; jumptable 00000414 case 1
		mov	eax, edx
		shr	eax, 8
		mov	[ecx], al

$LN31:					; CODE XREF: _RC2_cbc_encrypt+414j
					; DATA XREF: .text$mn:$LN45o
		mov	[ecx-1], dl	; jumptable 00000414 case 0

loc_457:				; CODE XREF: _RC2_cbc_encrypt+412j
		mov	ecx, [esp+24h+var_C] ; jumptable 00000414 default case
		mov	edx, [esp+24h+var_10]

loc_45F:				; CODE XREF: _RC2_cbc_encrypt+38Ej
		mov	[ebx], cl
		mov	eax, ecx
		shr	eax, 8
		mov	[ebx+1], al
		mov	eax, ecx
		shr	eax, 10h
		mov	[ebx+2], al
		mov	eax, edx
		shr	ecx, 18h
		mov	[ebx+3], cl
		mov	[ebx+4], dl
		shr	eax, 8
		mov	[ebx+5], al
		mov	eax, edx
		pop	edi
		shr	eax, 10h
		pop	esi
		mov	[ebx+6], al
		shr	edx, 18h
		pop	ebp
		mov	[ebx+7], dl
		pop	ebx
		add	esp, 14h
		retn
_RC2_cbc_encrypt endp

; ---------------------------------------------------------------------------
$LN44		dd offset $LN22		; DATA XREF: _RC2_cbc_encrypt+167r
		dd offset $LN21		; jump table for switch	statement
		dd offset $LN20
		dd offset $LN19
		dd offset $LN18
		dd offset $LN17
		dd offset $LN16
		dd offset $LN15
$LN45		dd offset $LN31		; DATA XREF: _RC2_cbc_encrypt+414r
		dd offset $LN30		; jump table for switch	statement
		dd offset $LN29
		dd offset $LN28
		dd offset $LN27
		dd offset $LN26
		dd offset $LN25
		dd offset $LN24
_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 4D8h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _RC2_decrypt
_RC2_decrypt	proc near		; CODE XREF: _RC2_cbc_encrypt+312p
					; _RC2_cbc_encrypt+3EBp

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 8
		call	__chkstk
		mov	eax, [esp+8+arg_0]
		mov	edx, [esp+8+arg_4]
		push	ebx
		push	ebp
		push	esi
		mov	esi, [eax]
		mov	ebp, 3
		mov	eax, [eax+4]
		push	edi
		movzx	edi, si
		movzx	ebx, ax
		shr	esi, 10h
		shr	eax, 10h
		add	edx, 0FCh ; 'ü'
		mov	[esp+18h+var_4], 5
		nop	word ptr [eax+eax+00h]

loc_518:				; CODE XREF: _RC2_decrypt+E2j
					; _RC2_decrypt+130j
		mov	ecx, eax
		shr	eax, 5
		shl	ecx, 0Bh
		or	ecx, eax
		mov	eax, ebx
		not	eax
		and	eax, edi
		sub	ecx, eax
		mov	eax, ebx
		and	eax, esi
		sub	ecx, eax
		sub	ecx, [edx]
		sub	edx, 4
		mov	[esp+18h+var_8], edx
		mov	edx, ebx
		movzx	eax, cx
		mov	ecx, esi
		shl	edx, 0Dh
		not	ecx
		and	ecx, eax
		shr	ebx, 3
		or	edx, ebx
		sub	edx, ecx
		mov	ecx, esi
		and	ecx, edi
		sub	edx, ecx
		mov	ecx, [esp+18h+var_8]
		sub	edx, [ecx]
		sub	ecx, 4
		movzx	ebx, dx
		mov	edx, esi
		mov	[esp+18h+var_8], ecx
		mov	ecx, edi
		shl	edx, 0Eh
		not	ecx
		and	ecx, ebx
		shr	esi, 2
		or	edx, esi
		sub	edx, ecx
		mov	ecx, eax
		and	ecx, edi
		sub	edx, ecx
		mov	ecx, [esp+18h+var_8]
		sub	edx, [ecx]
		sub	ecx, 4
		movzx	esi, dx
		mov	edx, edi
		mov	[esp+18h+var_8], ecx
		mov	ecx, eax
		shl	edx, 0Fh
		not	ecx
		shr	edi, 1
		and	ecx, esi
		or	edx, edi
		sub	edx, ecx
		mov	ecx, eax
		and	ecx, ebx
		sub	edx, ecx
		mov	ecx, [esp+18h+var_8]
		sub	edx, [ecx]
		movzx	edi, dx
		mov	edx, ecx
		sub	edx, 4
		sub	[esp+18h+var_4], 1
		mov	[esp+18h+var_8], edx
		jnz	loc_518
		sub	ebp, 1
		jz	short loc_60D
		mov	edx, [esp+18h+arg_4]
		xor	ecx, ecx
		cmp	ebp, 2
		setz	cl
		add	ecx, 5
		mov	[esp+18h+var_4], ecx
		mov	ecx, ebx
		and	ecx, 3Fh
		sub	eax, [edx+ecx*4]
		mov	ecx, esi
		and	ecx, 3Fh
		movzx	eax, ax
		sub	ebx, [edx+ecx*4]
		mov	ecx, edi
		and	ecx, 3Fh
		movzx	ebx, bx
		sub	esi, [edx+ecx*4]
		mov	ecx, eax
		and	ecx, 3Fh
		movzx	esi, si
		sub	edi, [edx+ecx*4]
		mov	edx, [esp+18h+var_8]
		movzx	edi, di
		jmp	loc_518
; ---------------------------------------------------------------------------

loc_60D:				; CODE XREF: _RC2_decrypt+EBj
		mov	edx, [esp+18h+arg_0]
		shl	esi, 10h
		or	esi, edi
		shl	eax, 10h
		pop	edi
		mov	[edx], esi
		or	eax, ebx
		pop	esi
		pop	ebp
		mov	[edx+4], eax
		pop	ebx
		add	esp, 8
		retn
_RC2_decrypt	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text$mn	segment	para public 'CODE' use32
		assume cs:_text$mn
		;org 628h
; COMDAT (pick no duplicate)
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================


		public _RC2_encrypt
_RC2_encrypt	proc near		; CODE XREF: _RC2_cbc_encrypt+ECp
					; _RC2_cbc_encrypt+1CAp

var_8		= dword	ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  4
arg_4		= dword	ptr  8

		mov	eax, 8
		call	__chkstk
		mov	eax, [esp+8+arg_0]
		mov	ecx, [esp+8+arg_4]
		push	ebx
		push	ebp
		push	esi
		mov	esi, [eax]
		mov	ebx, 5
		mov	eax, [eax+4]
		push	edi
		movzx	edi, si
		shr	esi, 10h
		movzx	ebp, ax
		shr	eax, 10h
		mov	[esp+18h+var_4], 3
		mov	[esp+18h+var_8], ecx

loc_660:				; CODE XREF: _RC2_encrypt+D2j
					; _RC2_encrypt+112j
		mov	edx, eax
		mov	ecx, eax
		not	edx
		and	ecx, ebp
		and	edx, esi
		add	edx, ecx
		mov	ecx, [esp+18h+var_8]
		add	[esp+18h+var_8], 4
		add	edx, [ecx]
		add	edx, edi
		movzx	ecx, dx
		mov	edi, ecx
		add	ecx, ecx
		shr	edi, 0Fh
		or	edi, ecx
		mov	ecx, eax
		and	ecx, edi
		mov	edx, edi
		not	edx
		and	edx, ebp
		add	edx, ecx
		mov	ecx, [esp+18h+var_8]
		add	[esp+18h+var_8], 4
		add	edx, [ecx]
		add	edx, esi
		movzx	ecx, dx
		mov	esi, ecx
		shl	ecx, 2
		shr	esi, 0Eh
		or	esi, ecx
		mov	edx, esi
		mov	ecx, esi
		not	edx
		and	ecx, edi
		and	edx, eax
		add	edx, ecx
		mov	ecx, [esp+18h+var_8]
		add	[esp+18h+var_8], 4
		add	edx, [ecx]
		add	edx, ebp
		movzx	ecx, dx
		mov	ebp, ecx
		shl	ecx, 3
		shr	ebp, 0Dh
		or	ebp, ecx
		mov	edx, ebp
		mov	ecx, ebp
		not	edx
		and	ecx, esi
		and	edx, edi
		add	edx, ecx
		mov	ecx, [esp+18h+var_8]
		add	[esp+18h+var_8], 4
		add	edx, [ecx]
		add	edx, eax
		movzx	ecx, dx
		mov	eax, ecx
		shl	ecx, 5
		shr	eax, 0Bh
		or	eax, ecx
		sub	ebx, 1
		jnz	loc_660
		mov	ecx, [esp+18h+var_4]
		sub	ecx, 1
		mov	[esp+18h+var_4], ecx
		jz	short loc_73F
		mov	edx, [esp+18h+arg_4]
		cmp	ecx, 2
		mov	ecx, eax
		setz	bl
		and	ecx, 3Fh
		add	ebx, 5
		add	edi, [edx+ecx*4]
		mov	ecx, edi
		and	ecx, 3Fh
		add	esi, [edx+ecx*4]
		mov	ecx, esi
		and	ecx, 3Fh
		add	ebp, [edx+ecx*4]
		mov	ecx, ebp
		and	ecx, 3Fh
		add	eax, [edx+ecx*4]
		jmp	loc_660
; ---------------------------------------------------------------------------

loc_73F:				; CODE XREF: _RC2_encrypt+E3j
		mov	edx, [esp+18h+arg_0]
		shl	esi, 10h
		movzx	ecx, di
		or	esi, ecx
		shl	eax, 10h
		pop	edi
		mov	[edx], esi
		movzx	ecx, bp
		pop	esi
		or	eax, ecx
		pop	ebp
		mov	[edx+4], eax
		pop	ebx
		add	esp, 8
		retn
_RC2_encrypt	endp

_text$mn	ends

; ===========================================================================

; Segment type:	Externs
; UNDEF
		extrn __chkstk:near	; CODE XREF: _RC2_cbc_encrypt+5p
					; _RC2_decrypt+5p ...


		end
