; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23918.0 

	TITLE	C:\workpace\openssl\openssl-1.0.2h\crypto\modes\ctr128.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_CRYPTO_ctr128_encrypt
PUBLIC	_CRYPTO_ctr128_encrypt_ctr32
EXTRN	__chkstk:PROC
; Function compile flags: /Ogtpy
;	COMDAT _ctr96_inc
_TEXT	SEGMENT
_counter$ = 8						; size = 4
_ctr96_inc PROC						; COMDAT
; File c:\workpace\openssl\openssl-1.0.2h\crypto\modes\ctr128.c
; Line 187
	push	esi
; Line 188
	mov	esi, DWORD PTR _counter$[esp]
	mov	edx, 12					; 0000000cH
	mov	eax, 1
	npad	1
$LL4@ctr96_inc:
; Line 192
	movzx	ecx, BYTE PTR [edx+esi-1]
	dec	edx
	add	eax, ecx
; Line 193
	mov	BYTE PTR [edx+esi], al
; Line 194
	shr	eax, 8
; Line 195
	test	edx, edx
	jne	SHORT $LL4@ctr96_inc
	pop	esi
; Line 196
	ret	0
_ctr96_inc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT _ctr128_inc_aligned
_TEXT	SEGMENT
_counter$ = 8						; size = 4
_ctr128_inc_aligned PROC				; COMDAT
; File c:\workpace\openssl\openssl-1.0.2h\crypto\modes\ctr128.c
; Line 82
	push	esi
; Line 70
	mov	esi, DWORD PTR _counter$[esp]
	mov	edx, 16					; 00000010H
	mov	eax, 1
	npad	1
$LL11@ctr128_inc:
; Line 74
	movzx	ecx, BYTE PTR [edx+esi-1]
	dec	edx
	add	eax, ecx
; Line 75
	mov	BYTE PTR [edx+esi], al
; Line 76
	shr	eax, 8
; Line 77
	test	edx, edx
	jne	SHORT $LL11@ctr128_inc
	pop	esi
; Line 105
	ret	0
_ctr128_inc_aligned ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT _ctr128_inc
_TEXT	SEGMENT
_counter$ = 8						; size = 4
_ctr128_inc PROC					; COMDAT
; File c:\workpace\openssl\openssl-1.0.2h\crypto\modes\ctr128.c
; Line 69
	push	esi
; Line 70
	mov	esi, DWORD PTR _counter$[esp]
	mov	edx, 16					; 00000010H
	mov	eax, 1
	npad	1
$LL4@ctr128_inc:
; Line 74
	movzx	ecx, BYTE PTR [edx+esi-1]
	dec	edx
	add	eax, ecx
; Line 75
	mov	BYTE PTR [edx+esi], al
; Line 76
	shr	eax, 8
; Line 77
	test	edx, edx
	jne	SHORT $LL4@ctr128_inc
	pop	esi
; Line 78
	ret	0
_ctr128_inc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT _CRYPTO_ctr128_encrypt_ctr32
_TEXT	SEGMENT
_len$1$ = -8						; size = 4
_n$1$ = -4						; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
_ctr32$1$ = 16						; size = 4
_len$ = 16						; size = 4
_key$ = 20						; size = 4
_ivec$ = 24						; size = 4
_ecount_buf$ = 28					; size = 4
_num$ = 32						; size = 4
_func$ = 36						; size = 4
_CRYPTO_ctr128_encrypt_ctr32 PROC			; COMDAT
; File c:\workpace\openssl\openssl-1.0.2h\crypto\modes\ctr128.c
; Line 203
	mov	eax, 8
	call	__chkstk
; Line 209
	mov	edx, DWORD PTR _num$[esp+4]
	push	ebx
; Line 211
	mov	ebx, DWORD PTR _out$[esp+8]
	push	ebp
	mov	ebp, DWORD PTR _in$[esp+12]
	push	esi
	mov	esi, DWORD PTR _len$[esp+16]
	push	edi
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR _n$1$[esp+24], edi
	mov	DWORD PTR _len$1$[esp+24], esi
	test	edi, edi
	je	SHORT $LN3@CRYPTO_ctr
	mov	ecx, DWORD PTR _ecount_buf$[esp+20]
$LL2@CRYPTO_ctr:
	test	esi, esi
	je	SHORT $LN3@CRYPTO_ctr
; Line 212
	mov	al, BYTE PTR [edi+ecx]
; Line 213
	dec	esi
	xor	al, BYTE PTR [ebp]
; Line 214
	inc	edi
	mov	BYTE PTR [ebx], al
	inc	ebp
	inc	ebx
	mov	DWORD PTR _len$1$[esp+24], esi
	and	edi, 15					; 0000000fH
	mov	DWORD PTR _n$1$[esp+24], edi
	jne	SHORT $LL2@CRYPTO_ctr
$LN3@CRYPTO_ctr:
; Line 217
	mov	eax, DWORD PTR _ivec$[esp+20]
	mov	ecx, DWORD PTR [eax+12]
	bswap	ecx
	mov	DWORD PTR _ctr32$1$[esp+20], ecx
; Line 218
	cmp	esi, 16					; 00000010H
	jb	$LN5@CRYPTO_ctr
$LL4@CRYPTO_ctr:
; Line 219
	mov	edi, esi
	shr	edi, 4
; Line 233
	add	ecx, edi
	mov	DWORD PTR _ctr32$1$[esp+20], ecx
; Line 234
	cmp	ecx, edi
	jae	SHORT $LN9@CRYPTO_ctr
; Line 235
	sub	edi, ecx
; Line 236
	xor	ecx, ecx
	mov	DWORD PTR _ctr32$1$[esp+20], ecx
$LN9@CRYPTO_ctr:
; Line 238
	push	eax
	push	DWORD PTR _key$[esp+24]
	push	edi
	push	ebx
	push	ebp
	call	DWORD PTR _func$[esp+40]
; Line 240
	mov	ecx, DWORD PTR _ctr32$1$[esp+40]
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _ivec$[esp+20]
	mov	eax, ecx
	bswap	eax
	mov	DWORD PTR [edx+12], eax
; Line 242
	test	ecx, ecx
	jne	SHORT $LN16@CRYPTO_ctr
	mov	esi, DWORD PTR _ivec$[esp+20]
; Line 188
	mov	edx, 12					; 0000000cH
	mov	ecx, 1
	npad	6
$LL17@CRYPTO_ctr:
; Line 192
	movzx	eax, BYTE PTR [edx+esi-1]
	dec	edx
	add	ecx, eax
; Line 193
	mov	BYTE PTR [edx+esi], cl
; Line 194
	shr	ecx, 8
; Line 195
	test	edx, edx
	jne	SHORT $LL17@CRYPTO_ctr
	mov	esi, DWORD PTR _len$1$[esp+24]
	mov	ecx, DWORD PTR _ctr32$1$[esp+20]
$LN16@CRYPTO_ctr:
; Line 218
	mov	eax, DWORD PTR _ivec$[esp+20]
; Line 244
	shl	edi, 4
; Line 245
	sub	esi, edi
; Line 246
	add	ebx, edi
; Line 247
	add	ebp, edi
	mov	DWORD PTR _len$1$[esp+24], esi
	cmp	esi, 16					; 00000010H
	jae	SHORT $LL4@CRYPTO_ctr
	mov	edi, DWORD PTR _n$1$[esp+24]
	mov	edx, DWORD PTR _num$[esp+20]
$LN5@CRYPTO_ctr:
; Line 249
	test	esi, esi
	je	SHORT $LN36@CRYPTO_ctr
; Line 250
	mov	ecx, DWORD PTR _ecount_buf$[esp+20]
	xorps	xmm0, xmm0
; Line 251
	push	eax
	push	DWORD PTR _key$[esp+24]
	push	1
	push	ecx
	push	ecx
	movups	XMMWORD PTR [ecx], xmm0
	call	DWORD PTR _func$[esp+40]
; Line 252
	mov	eax, DWORD PTR _ctr32$1$[esp+40]
	add	esp, 20					; 00000014H
; Line 253
	mov	edx, DWORD PTR _ivec$[esp+20]
	add	eax, 1
	bswap	eax
	mov	DWORD PTR [edx+12], eax
; Line 254
	jne	SHORT $LN35@CRYPTO_ctr
; Line 255
	push	edx
	call	_ctr96_inc
	add	esp, 4
$LN35@CRYPTO_ctr:
; Line 256
	mov	eax, DWORD PTR _ecount_buf$[esp+20]
	sub	ebp, eax
	sub	ebx, eax
	lea	ecx, DWORD PTR [edi+eax]
	add	edi, esi
	npad	2
$LL6@CRYPTO_ctr:
; Line 257
	mov	al, BYTE PTR [ecx+ebp]
; Line 258
	lea	ecx, DWORD PTR [ecx+1]
	xor	al, BYTE PTR [ecx-1]
	mov	BYTE PTR [ebx+ecx-1], al
	sub	esi, 1
	jne	SHORT $LL6@CRYPTO_ctr
; Line 262
	mov	eax, DWORD PTR _num$[esp+20]
	mov	DWORD PTR [eax], edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
; Line 263
	add	esp, 8
	ret	0
$LN36@CRYPTO_ctr:
; Line 262
	mov	DWORD PTR [edx], edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
; Line 263
	add	esp, 8
	ret	0
_CRYPTO_ctr128_encrypt_ctr32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT _CRYPTO_ctr128_encrypt
_TEXT	SEGMENT
tv504 = -16						; size = 4
_n$1$ = -12						; size = 4
_out$1$ = -8						; size = 4
_in$1$ = -4						; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
tv502 = 16						; size = 4
_len$ = 16						; size = 4
_key$ = 20						; size = 4
_ivec$ = 24						; size = 4
_ecount_buf$ = 28					; size = 4
_num$ = 32						; size = 4
_block$ = 36						; size = 4
_CRYPTO_ctr128_encrypt PROC				; COMDAT
; File c:\workpace\openssl\openssl-1.0.2h\crypto\modes\ctr128.c
; Line 124
	mov	eax, 16					; 00000010H
	call	__chkstk
	mov	ecx, DWORD PTR _ecount_buf$[esp+12]
	push	ebx
; Line 136
	mov	ebx, DWORD PTR _out$[esp+16]
	push	ebp
	mov	ebp, DWORD PTR _in$[esp+20]
	push	esi
	mov	esi, DWORD PTR _len$[esp+24]
	push	edi
	mov	edi, DWORD PTR _num$[esp+28]
	mov	edi, DWORD PTR [edi]
	test	edi, edi
	je	SHORT $LN26@CRYPTO_ctr
$LL5@CRYPTO_ctr:
	test	esi, esi
	je	SHORT $LN26@CRYPTO_ctr
; Line 137
	mov	al, BYTE PTR [edi+ecx]
; Line 138
	dec	esi
	xor	al, BYTE PTR [ebp]
; Line 139
	inc	edi
	mov	BYTE PTR [ebx], al
	inc	ebp
	inc	ebx
	and	edi, 15					; 0000000fH
	jne	SHORT $LL5@CRYPTO_ctr
$LN26@CRYPTO_ctr:
; Line 147
	mov	edx, DWORD PTR _ivec$[esp+28]
	cmp	esi, 16					; 00000010H
	jb	$LN8@CRYPTO_ctr
	mov	eax, ebp
; Line 156
	xor	edi, edi
	sub	eax, ecx
	mov	DWORD PTR _n$1$[esp+32], edi
	mov	DWORD PTR tv504[esp+32], eax
	mov	edi, ebx
	mov	eax, esi
	sub	edi, ecx
	shr	eax, 4
	mov	DWORD PTR tv502[esp+28], eax
	shl	eax, 4
	add	ebx, eax
	add	ebp, eax
	mov	DWORD PTR _out$1$[esp+32], ebx
	mov	ebx, DWORD PTR tv504[esp+32]
	mov	DWORD PTR _in$1$[esp+32], ebp
	mov	ebp, DWORD PTR _ecount_buf$[esp+28]
	npad	4
$LL7@CRYPTO_ctr:
; Line 148
	push	DWORD PTR _key$[esp+28]
	push	ebp
	push	edx
	call	DWORD PTR _block$[esp+40]
; Line 149
	mov	eax, DWORD PTR _ivec$[esp+40]
	push	eax
	call	_ctr128_inc_aligned
	add	esp, 16					; 00000010H
	mov	eax, ebp
	mov	edx, 4
	npad	2
$LL11@CRYPTO_ctr:
; Line 151
	mov	ecx, DWORD PTR [ebx+eax]
	lea	eax, DWORD PTR [eax+4]
	xor	ecx, DWORD PTR [eax-4]
	mov	DWORD PTR [edi+eax-4], ecx
	sub	edx, 1
	jne	SHORT $LL11@CRYPTO_ctr
; Line 153
	mov	edx, DWORD PTR _ivec$[esp+28]
	sub	esi, 16					; 00000010H
; Line 154
	add	edi, 16					; 00000010H
; Line 155
	add	ebx, 16					; 00000010H
	sub	DWORD PTR tv502[esp+28], 1
	jne	SHORT $LL7@CRYPTO_ctr
	mov	edi, DWORD PTR _n$1$[esp+32]
	mov	ebx, DWORD PTR _out$1$[esp+32]
	mov	ebp, DWORD PTR _in$1$[esp+32]
	mov	ecx, DWORD PTR _ecount_buf$[esp+28]
$LN8@CRYPTO_ctr:
; Line 158
	test	esi, esi
	je	SHORT $LN42@CRYPTO_ctr
; Line 159
	push	DWORD PTR _key$[esp+28]
	push	ecx
	push	edx
	call	DWORD PTR _block$[esp+40]
; Line 160
	mov	eax, DWORD PTR _ivec$[esp+40]
	push	eax
	call	_ctr128_inc_aligned
	mov	eax, DWORD PTR _ecount_buf$[esp+44]
	add	esp, 16					; 00000010H
; Line 161
	sub	ebp, eax
	sub	ebx, eax
	lea	ecx, DWORD PTR [edi+eax]
	add	edi, esi
	npad	2
$LL12@CRYPTO_ctr:
; Line 162
	mov	al, BYTE PTR [ecx+ebp]
; Line 163
	lea	ecx, DWORD PTR [ecx+1]
	xor	al, BYTE PTR [ecx-1]
	mov	BYTE PTR [ecx+ebx-1], al
	sub	esi, 1
	jne	SHORT $LL12@CRYPTO_ctr
$LN42@CRYPTO_ctr:
; Line 166
	mov	eax, DWORD PTR _num$[esp+28]
	mov	DWORD PTR [eax], edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
; Line 183
	add	esp, 16					; 00000010H
	ret	0
_CRYPTO_ctr128_encrypt ENDP
_TEXT	ENDS
END
