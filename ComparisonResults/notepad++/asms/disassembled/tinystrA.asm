.text$mn:00000000 ;
.text$mn:00000000 ; +-------------------------------------------------------------------------+
.text$mn:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.text$mn:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.text$mn:00000000 ; |                      License info: 48-3677-7074-51                      |
.text$mn:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.text$mn:00000000 ; +-------------------------------------------------------------------------+
.text$mn:00000000 ;
.text$mn:00000000 ; Input MD5   : 5FDD6790BF4167E08ECCE58075DC8000
.text$mn:00000000 ; Input CRC32 : 72003FB0
.text$mn:00000000
.text$mn:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\tinystrA.obj
.text$mn:00000000 ; Format      : COFF (X386MAGIC)
.text$mn:00000000 ; includelib "uuid.lib"
.text$mn:00000000 ; includelib "libcpmtd"
.text$mn:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.text$mn:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.text$mn:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.text$mn:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.text$mn:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.text$mn:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.text$mn:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.text$mn:00000000 ; includelib "LIBCMTD"
.text$mn:00000000 ; includelib "OLDNAMES"
.text$mn:00000000
.text$mn:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.text$mn:00000000
.text$mn:00000000                 .686p
.text$mn:00000000                 .mmx
.text$mn:00000000                 .model flat
.text$mn:00000000
.text$mn:00000000 ; ===========================================================================
.text$mn:00000000
.text$mn:00000000 ; Segment type: Pure code
.text$mn:00000000 ; Segment permissions: Read/Execute
.text$mn:00000000 _text$mn        segment para public 'CODE' use32
.text$mn:00000000                 assume cs:_text$mn
.text$mn:00000000 ; COMDAT (pick any)
.text$mn:00000000                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000000
.text$mn:00000000 ; =============== S U B R O U T I N E =======================================
.text$mn:00000000
.text$mn:00000000 ; Attributes: bp-based frame
.text$mn:00000000
.text$mn:00000000 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00000000                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00000000 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00000000                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00000000
.text$mn:00000000 var_4           = dword ptr -4
.text$mn:00000000 arg_0           = dword ptr  8
.text$mn:00000000
.text$mn:00000000                 push    ebp
.text$mn:00000001                 mov     ebp, esp
.text$mn:00000003                 push    ecx
.text$mn:00000004                 mov     [ebp+var_4], 0
.text$mn:0000000B                 cmp     [ebp+arg_0], 0
.text$mn:0000000F                 jnz     short loc_13
.text$mn:00000011                 jmp     short loc_33
.text$mn:00000013 ; ---------------------------------------------------------------------------
.text$mn:00000013
.text$mn:00000013 loc_13:                                 ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00000013                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00000017                 ja      short loc_2E
.text$mn:00000019                 mov     eax, [ebp+arg_0]
.text$mn:0000001C                 push    eax             ; unsigned int
.text$mn:0000001D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000022                 add     esp, 4
.text$mn:00000025                 mov     [ebp+var_4], eax
.text$mn:00000028                 cmp     [ebp+var_4], 0
.text$mn:0000002C                 jnz     short loc_33
.text$mn:0000002E
.text$mn:0000002E loc_2E:                                 ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:0000002E                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000033
.text$mn:00000033 loc_33:                                 ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00000033                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00000033                 mov     eax, [ebp+var_4]
.text$mn:00000036                 mov     esp, ebp
.text$mn:00000038                 pop     ebp
.text$mn:00000039                 retn
.text$mn:00000039 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00000039
.text$mn:00000039 ; ---------------------------------------------------------------------------
.text$mn:0000003A                 align 4
.text$mn:0000003A _text$mn        ends
.text$mn:0000003A
.text$mn:0000003C ; ===========================================================================
.text$mn:0000003C
.text$mn:0000003C ; Segment type: Pure code
.text$mn:0000003C ; Segment permissions: Read/Execute
.text$mn:0000003C _text$mn        segment para public 'CODE' use32
.text$mn:0000003C                 assume cs:_text$mn
.text$mn:0000003C                 ;org 3Ch
.text$mn:0000003C ; COMDAT (pick any)
.text$mn:0000003C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000003C
.text$mn:0000003C ; =============== S U B R O U T I N E =======================================
.text$mn:0000003C
.text$mn:0000003C ; Attributes: bp-based frame
.text$mn:0000003C
.text$mn:0000003C ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:0000003C                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:0000003C ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:0000003C                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:0000003C
.text$mn:0000003C var_4           = dword ptr -4
.text$mn:0000003C arg_0           = dword ptr  8
.text$mn:0000003C
.text$mn:0000003C                 push    ebp
.text$mn:0000003D                 mov     ebp, esp
.text$mn:0000003F                 push    ecx
.text$mn:00000040                 mov     [ebp+var_4], 0
.text$mn:00000047                 cmp     [ebp+arg_0], 0
.text$mn:0000004B                 jnz     short loc_4F
.text$mn:0000004D                 jmp     short loc_75
.text$mn:0000004F ; ---------------------------------------------------------------------------
.text$mn:0000004F
.text$mn:0000004F loc_4F:                                 ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:0000004F                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:00000056                 ja      short loc_70
.text$mn:00000058                 mov     eax, [ebp+arg_0]
.text$mn:0000005B                 shl     eax, 3
.text$mn:0000005E                 push    eax             ; unsigned int
.text$mn:0000005F                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000064                 add     esp, 4
.text$mn:00000067                 mov     [ebp+var_4], eax
.text$mn:0000006A                 cmp     [ebp+var_4], 0
.text$mn:0000006E                 jnz     short loc_75
.text$mn:00000070
.text$mn:00000070 loc_70:                                 ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00000070                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000075
.text$mn:00000075 loc_75:                                 ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00000075                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00000075                 mov     eax, [ebp+var_4]
.text$mn:00000078                 mov     esp, ebp
.text$mn:0000007A                 pop     ebp
.text$mn:0000007B                 retn
.text$mn:0000007B ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:0000007B
.text$mn:0000007B _text$mn        ends
.text$mn:0000007B
.text$mn:0000007C ; ===========================================================================
.text$mn:0000007C
.text$mn:0000007C ; Segment type: Pure code
.text$mn:0000007C ; Segment permissions: Read/Execute
.text$mn:0000007C _text$mn        segment para public 'CODE' use32
.text$mn:0000007C                 assume cs:_text$mn
.text$mn:0000007C                 ;org 7Ch
.text$mn:0000007C ; COMDAT (pick any)
.text$mn:0000007C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000007C
.text$mn:0000007C ; =============== S U B R O U T I N E =======================================
.text$mn:0000007C
.text$mn:0000007C ; Attributes: bp-based frame
.text$mn:0000007C
.text$mn:0000007C ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:0000007C                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:0000007C ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:0000007C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:0000007C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:0000007C
.text$mn:0000007C arg_0           = dword ptr  8
.text$mn:0000007C arg_4           = dword ptr  0Ch
.text$mn:0000007C arg_8           = dword ptr  10h
.text$mn:0000007C
.text$mn:0000007C                 push    ebp
.text$mn:0000007D                 mov     ebp, esp
.text$mn:0000007F                 cmp     [ebp+arg_0], 0
.text$mn:00000083                 jnz     short loc_9A
.text$mn:00000085                 mov     eax, [ebp+arg_8]
.text$mn:00000088                 push    eax             ; unsigned int
.text$mn:00000089                 mov     ecx, [ebp+arg_4]
.text$mn:0000008C                 push    ecx             ; wchar_t *
.text$mn:0000008D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00000092                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00000097                 add     esp, 0Ch
.text$mn:0000009A
.text$mn:0000009A loc_9A:                                 ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:0000009A                 pop     ebp
.text$mn:0000009B                 retn
.text$mn:0000009B ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:0000009B
.text$mn:0000009B _text$mn        ends
.text$mn:0000009B
.text$mn:0000009C ; ===========================================================================
.text$mn:0000009C
.text$mn:0000009C ; Segment type: Pure code
.text$mn:0000009C ; Segment permissions: Read/Execute
.text$mn:0000009C _text$mn        segment para public 'CODE' use32
.text$mn:0000009C                 assume cs:_text$mn
.text$mn:0000009C                 ;org 9Ch
.text$mn:0000009C ; COMDAT (pick any)
.text$mn:0000009C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000009C
.text$mn:0000009C ; =============== S U B R O U T I N E =======================================
.text$mn:0000009C
.text$mn:0000009C ; Attributes: bp-based frame
.text$mn:0000009C
.text$mn:0000009C ; char * __cdecl std::addressof<char>(char &)
.text$mn:0000009C                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:0000009C ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:0000009C                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:0000009C                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:0000009C
.text$mn:0000009C arg_0           = dword ptr  8
.text$mn:0000009C
.text$mn:0000009C                 push    ebp
.text$mn:0000009D                 mov     ebp, esp
.text$mn:0000009F                 mov     eax, [ebp+arg_0]
.text$mn:000000A2                 pop     ebp
.text$mn:000000A3                 retn
.text$mn:000000A3 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:000000A3
.text$mn:000000A3 _text$mn        ends
.text$mn:000000A3
.text$mn:000000A4 ; ===========================================================================
.text$mn:000000A4
.text$mn:000000A4 ; Segment type: Pure code
.text$mn:000000A4 ; Segment permissions: Read/Execute
.text$mn:000000A4 _text$mn        segment para public 'CODE' use32
.text$mn:000000A4                 assume cs:_text$mn
.text$mn:000000A4                 ;org 0A4h
.text$mn:000000A4 ; COMDAT (pick any)
.text$mn:000000A4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000000A4
.text$mn:000000A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000000A4
.text$mn:000000A4 ; Attributes: bp-based frame
.text$mn:000000A4
.text$mn:000000A4 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:000000A4                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:000000A4 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000000A4                                         ; CODE XREF: $LN19+4Bp
.text$mn:000000A4
.text$mn:000000A4 var_4           = dword ptr -4
.text$mn:000000A4 arg_0           = dword ptr  8
.text$mn:000000A4 arg_4           = dword ptr  0Ch
.text$mn:000000A4
.text$mn:000000A4                 push    ebp
.text$mn:000000A5                 mov     ebp, esp
.text$mn:000000A7                 push    ecx
.text$mn:000000A8                 mov     [ebp+var_4], ecx
.text$mn:000000AB                 mov     eax, [ebp+arg_4]
.text$mn:000000AE                 push    eax
.text$mn:000000AF                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000000B4                 add     esp, 4
.text$mn:000000B7                 push    eax             ; int
.text$mn:000000B8                 mov     ecx, [ebp+arg_0]
.text$mn:000000BB                 push    ecx             ; void *
.text$mn:000000BC                 mov     edx, [ebp+var_4]
.text$mn:000000BF                 push    edx             ; int
.text$mn:000000C0                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:000000C5                 add     esp, 0Ch
.text$mn:000000C8                 mov     esp, ebp
.text$mn:000000CA                 pop     ebp
.text$mn:000000CB                 retn    8
.text$mn:000000CB ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000000CB
.text$mn:000000CB ; ---------------------------------------------------------------------------
.text$mn:000000CE                 align 10h
.text$mn:000000CE _text$mn        ends
.text$mn:000000CE
.text$mn:000000D0 ; ===========================================================================
.text$mn:000000D0
.text$mn:000000D0 ; Segment type: Pure code
.text$mn:000000D0 ; Segment permissions: Read/Execute
.text$mn:000000D0 _text$mn        segment para public 'CODE' use32
.text$mn:000000D0                 assume cs:_text$mn
.text$mn:000000D0                 ;org 0D0h
.text$mn:000000D0 ; COMDAT (pick any)
.text$mn:000000D0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000000D0
.text$mn:000000D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000000D0
.text$mn:000000D0 ; Attributes: bp-based frame
.text$mn:000000D0
.text$mn:000000D0 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:000000D0                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000000D0 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000000D0                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:000000D0
.text$mn:000000D0 var_1C          = dword ptr -1Ch
.text$mn:000000D0 var_18          = dword ptr -18h
.text$mn:000000D0 var_14          = dword ptr -14h
.text$mn:000000D0 var_10          = dword ptr -10h
.text$mn:000000D0 var_C           = dword ptr -0Ch
.text$mn:000000D0 var_4           = dword ptr -4
.text$mn:000000D0 arg_0           = dword ptr  8
.text$mn:000000D0 arg_4           = dword ptr  0Ch
.text$mn:000000D0
.text$mn:000000D0                 push    ebp
.text$mn:000000D1                 mov     ebp, esp
.text$mn:000000D3                 push    0FFFFFFFFh
.text$mn:000000D5                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000000DA                 mov     eax, large fs:0
.text$mn:000000E0                 push    eax
.text$mn:000000E1                 sub     esp, 10h
.text$mn:000000E4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000000E9                 xor     eax, ebp
.text$mn:000000EB                 push    eax
.text$mn:000000EC                 lea     eax, [ebp+var_C]
.text$mn:000000EF                 mov     large fs:0, eax
.text$mn:000000F5                 mov     [ebp+var_18], ecx
.text$mn:000000F8                 mov     eax, [ebp+arg_0]
.text$mn:000000FB                 push    eax             ; void *
.text$mn:000000FC                 push    4               ; unsigned int
.text$mn:000000FE                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000103                 add     esp, 8
.text$mn:00000106                 mov     [ebp+var_10], eax
.text$mn:00000109                 mov     [ebp+var_4], 0
.text$mn:00000110                 cmp     [ebp+var_10], 0
.text$mn:00000114                 jz      short loc_131
.text$mn:00000116                 mov     ecx, [ebp+arg_4]
.text$mn:00000119                 push    ecx
.text$mn:0000011A                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000011F                 add     esp, 4
.text$mn:00000122                 mov     edx, [ebp+var_10]
.text$mn:00000125                 mov     eax, [eax]
.text$mn:00000127                 mov     [edx], eax
.text$mn:00000129                 mov     ecx, [ebp+var_10]
.text$mn:0000012C                 mov     [ebp+var_14], ecx
.text$mn:0000012F                 jmp     short loc_138
.text$mn:00000131 ; ---------------------------------------------------------------------------
.text$mn:00000131
.text$mn:00000131 loc_131:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00000131                 mov     [ebp+var_14], 0
.text$mn:00000138
.text$mn:00000138 loc_138:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00000138                 mov     edx, [ebp+var_14]
.text$mn:0000013B                 mov     [ebp+var_1C], edx
.text$mn:0000013E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000145                 mov     ecx, [ebp+var_C]
.text$mn:00000148                 mov     large fs:0, ecx
.text$mn:0000014F                 pop     ecx
.text$mn:00000150                 mov     esp, ebp
.text$mn:00000152                 pop     ebp
.text$mn:00000153                 retn    8
.text$mn:00000153 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00000153
.text$mn:00000153 ; ---------------------------------------------------------------------------
.text$mn:00000156                 align 4
.text$mn:00000156 _text$mn        ends
.text$mn:00000156
.text$x:00000158 ; ===========================================================================
.text$x:00000158
.text$x:00000158 ; Segment type: Pure code
.text$x:00000158 ; Segment permissions: Read/Execute
.text$x:00000158 _text$x         segment para public 'CODE' use32
.text$x:00000158                 assume cs:_text$x
.text$x:00000158                 ;org 158h
.text$x:00000158 ; COMDAT (pick associative to section at D0)
.text$x:00000158                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000158
.text$x:00000158 ; =============== S U B R O U T I N E =======================================
.text$x:00000158
.text$x:00000158
.text$x:00000158 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00000158                                         ; DATA XREF: .xdata$x:00001C90o
.text$x:00000158                 mov     eax, [ebp+8]
.text$x:0000015B                 push    eax
.text$x:0000015C                 mov     eax, [ebp-10h]
.text$x:0000015F                 push    eax             ; void *
.text$x:00000160                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000165                 add     esp, 8
.text$x:00000168                 retn
.text$x:00000168 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00000168
.text$x:00000169
.text$x:00000169 ; =============== S U B R O U T I N E =======================================
.text$x:00000169
.text$x:00000169
.text$x:00000169 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00000169                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00000169
.text$x:00000169 arg_4           = dword ptr  8
.text$x:00000169
.text$x:00000169                 mov     edx, [esp+arg_4]
.text$x:0000016D                 lea     eax, [edx+0Ch]
.text$x:00000170                 mov     ecx, [edx-14h]
.text$x:00000173                 xor     ecx, eax
.text$x:00000175                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000017A                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:0000017F                 jmp     ___CxxFrameHandler3
.text$x:0000017F __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:0000017F
.text$x:0000017F _text$x         ends
.text$x:0000017F
.text$mn:00000184 ; ===========================================================================
.text$mn:00000184
.text$mn:00000184 ; Segment type: Pure code
.text$mn:00000184 ; Segment permissions: Read/Execute
.text$mn:00000184 _text$mn        segment para public 'CODE' use32
.text$mn:00000184                 assume cs:_text$mn
.text$mn:00000184                 ;org 184h
.text$mn:00000184 ; COMDAT (pick any)
.text$mn:00000184                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000184
.text$mn:00000184 ; =============== S U B R O U T I N E =======================================
.text$mn:00000184
.text$mn:00000184 ; Attributes: bp-based frame
.text$mn:00000184
.text$mn:00000184 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00000184                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00000184 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00000184                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00000184
.text$mn:00000184 arg_0           = dword ptr  8
.text$mn:00000184 arg_4           = dword ptr  0Ch
.text$mn:00000184 arg_8           = dword ptr  10h
.text$mn:00000184
.text$mn:00000184                 push    ebp
.text$mn:00000185                 mov     ebp, esp
.text$mn:00000187                 mov     eax, [ebp+arg_8]
.text$mn:0000018A                 push    eax
.text$mn:0000018B                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000190                 add     esp, 4
.text$mn:00000193                 push    eax             ; int
.text$mn:00000194                 mov     ecx, [ebp+arg_4]
.text$mn:00000197                 push    ecx             ; void *
.text$mn:00000198                 mov     ecx, [ebp+arg_0]
.text$mn:0000019B                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:000001A0                 pop     ebp
.text$mn:000001A1                 retn
.text$mn:000001A1 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:000001A1
.text$mn:000001A1 ; ---------------------------------------------------------------------------
.text$mn:000001A2                 align 4
.text$mn:000001A2 _text$mn        ends
.text$mn:000001A2
.text$mn:000001A4 ; ===========================================================================
.text$mn:000001A4
.text$mn:000001A4 ; Segment type: Pure code
.text$mn:000001A4 ; Segment permissions: Read/Execute
.text$mn:000001A4 _text$mn        segment para public 'CODE' use32
.text$mn:000001A4                 assume cs:_text$mn
.text$mn:000001A4                 ;org 1A4h
.text$mn:000001A4 ; COMDAT (pick any)
.text$mn:000001A4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000001A4
.text$mn:000001A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000001A4
.text$mn:000001A4 ; Attributes: bp-based frame
.text$mn:000001A4
.text$mn:000001A4 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:000001A4                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000001A4 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:000001A4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:000001A4
.text$mn:000001A4 var_1C          = dword ptr -1Ch
.text$mn:000001A4 var_18          = dword ptr -18h
.text$mn:000001A4 var_14          = dword ptr -14h
.text$mn:000001A4 var_10          = dword ptr -10h
.text$mn:000001A4 var_C           = dword ptr -0Ch
.text$mn:000001A4 var_4           = dword ptr -4
.text$mn:000001A4 arg_0           = dword ptr  8
.text$mn:000001A4 arg_4           = dword ptr  0Ch
.text$mn:000001A4
.text$mn:000001A4                 push    ebp
.text$mn:000001A5                 mov     ebp, esp
.text$mn:000001A7                 push    0FFFFFFFFh
.text$mn:000001A9                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000001AE                 mov     eax, large fs:0
.text$mn:000001B4                 push    eax
.text$mn:000001B5                 sub     esp, 10h
.text$mn:000001B8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000001BD                 xor     eax, ebp
.text$mn:000001BF                 push    eax
.text$mn:000001C0                 lea     eax, [ebp+var_C]
.text$mn:000001C3                 mov     large fs:0, eax
.text$mn:000001C9                 mov     [ebp+var_18], ecx
.text$mn:000001CC                 mov     eax, [ebp+arg_0]
.text$mn:000001CF                 push    eax             ; void *
.text$mn:000001D0                 push    8               ; unsigned int
.text$mn:000001D2                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000001D7                 add     esp, 8
.text$mn:000001DA                 mov     [ebp+var_10], eax
.text$mn:000001DD                 mov     [ebp+var_4], 0
.text$mn:000001E4                 cmp     [ebp+var_10], 0
.text$mn:000001E8                 jz      short loc_20B
.text$mn:000001EA                 mov     ecx, [ebp+arg_4]
.text$mn:000001ED                 push    ecx
.text$mn:000001EE                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:000001F3                 add     esp, 4
.text$mn:000001F6                 mov     edx, [eax]
.text$mn:000001F8                 mov     eax, [eax+4]
.text$mn:000001FB                 mov     ecx, [ebp+var_10]
.text$mn:000001FE                 mov     [ecx], edx
.text$mn:00000200                 mov     [ecx+4], eax
.text$mn:00000203                 mov     edx, [ebp+var_10]
.text$mn:00000206                 mov     [ebp+var_14], edx
.text$mn:00000209                 jmp     short loc_212
.text$mn:0000020B ; ---------------------------------------------------------------------------
.text$mn:0000020B
.text$mn:0000020B loc_20B:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:0000020B                 mov     [ebp+var_14], 0
.text$mn:00000212
.text$mn:00000212 loc_212:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00000212                 mov     eax, [ebp+var_14]
.text$mn:00000215                 mov     [ebp+var_1C], eax
.text$mn:00000218                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000021F                 mov     ecx, [ebp+var_C]
.text$mn:00000222                 mov     large fs:0, ecx
.text$mn:00000229                 pop     ecx
.text$mn:0000022A                 mov     esp, ebp
.text$mn:0000022C                 pop     ebp
.text$mn:0000022D                 retn    8
.text$mn:0000022D ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:0000022D
.text$mn:0000022D _text$mn        ends
.text$mn:0000022D
.text$x:00000230 ; ===========================================================================
.text$x:00000230
.text$x:00000230 ; Segment type: Pure code
.text$x:00000230 ; Segment permissions: Read/Execute
.text$x:00000230 _text$x         segment para public 'CODE' use32
.text$x:00000230                 assume cs:_text$x
.text$x:00000230                 ;org 230h
.text$x:00000230 ; COMDAT (pick associative to section at 1A4)
.text$x:00000230                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000230
.text$x:00000230 ; =============== S U B R O U T I N E =======================================
.text$x:00000230
.text$x:00000230
.text$x:00000230 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00000230                                         ; DATA XREF: .xdata$x:00001C64o
.text$x:00000230                 mov     eax, [ebp+8]
.text$x:00000233                 push    eax
.text$x:00000234                 mov     eax, [ebp-10h]
.text$x:00000237                 push    eax             ; void *
.text$x:00000238                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:0000023D                 add     esp, 8
.text$x:00000240                 retn
.text$x:00000240 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00000240
.text$x:00000241
.text$x:00000241 ; =============== S U B R O U T I N E =======================================
.text$x:00000241
.text$x:00000241
.text$x:00000241 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00000241                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00000241
.text$x:00000241 arg_4           = dword ptr  8
.text$x:00000241
.text$x:00000241                 mov     edx, [esp+arg_4]
.text$x:00000245                 lea     eax, [edx+0Ch]
.text$x:00000248                 mov     ecx, [edx-14h]
.text$x:0000024B                 xor     ecx, eax
.text$x:0000024D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000252                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00000257                 jmp     ___CxxFrameHandler3
.text$x:00000257 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00000257
.text$x:00000257 _text$x         ends
.text$x:00000257
.text$mn:0000025C ; ===========================================================================
.text$mn:0000025C
.text$mn:0000025C ; Segment type: Pure code
.text$mn:0000025C ; Segment permissions: Read/Execute
.text$mn:0000025C _text$mn        segment para public 'CODE' use32
.text$mn:0000025C                 assume cs:_text$mn
.text$mn:0000025C                 ;org 25Ch
.text$mn:0000025C ; COMDAT (pick any)
.text$mn:0000025C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000025C
.text$mn:0000025C ; =============== S U B R O U T I N E =======================================
.text$mn:0000025C
.text$mn:0000025C ; Attributes: bp-based frame
.text$mn:0000025C
.text$mn:0000025C ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:0000025C                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:0000025C ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:0000025C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:0000025C
.text$mn:0000025C var_4           = dword ptr -4
.text$mn:0000025C arg_0           = dword ptr  8
.text$mn:0000025C
.text$mn:0000025C                 push    ebp
.text$mn:0000025D                 mov     ebp, esp
.text$mn:0000025F                 push    ecx
.text$mn:00000260                 mov     [ebp+var_4], ecx
.text$mn:00000263                 mov     eax, [ebp+arg_0]
.text$mn:00000266                 push    eax
.text$mn:00000267                 mov     ecx, [ebp+var_4]
.text$mn:0000026A                 push    ecx
.text$mn:0000026B                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00000270                 add     esp, 8
.text$mn:00000273                 mov     esp, ebp
.text$mn:00000275                 pop     ebp
.text$mn:00000276                 retn    4
.text$mn:00000276 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00000276
.text$mn:00000276 ; ---------------------------------------------------------------------------
.text$mn:00000279                 align 4
.text$mn:00000279 _text$mn        ends
.text$mn:00000279
.text$mn:0000027C ; ===========================================================================
.text$mn:0000027C
.text$mn:0000027C ; Segment type: Pure code
.text$mn:0000027C ; Segment permissions: Read/Execute
.text$mn:0000027C _text$mn        segment para public 'CODE' use32
.text$mn:0000027C                 assume cs:_text$mn
.text$mn:0000027C                 ;org 27Ch
.text$mn:0000027C ; COMDAT (pick any)
.text$mn:0000027C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000027C
.text$mn:0000027C ; =============== S U B R O U T I N E =======================================
.text$mn:0000027C
.text$mn:0000027C ; Attributes: bp-based frame
.text$mn:0000027C
.text$mn:0000027C ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:0000027C                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:0000027C ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:0000027C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:0000027C
.text$mn:0000027C var_4           = dword ptr -4
.text$mn:0000027C
.text$mn:0000027C                 push    ebp
.text$mn:0000027D                 mov     ebp, esp
.text$mn:0000027F                 push    ecx
.text$mn:00000280                 mov     [ebp+var_4], ecx
.text$mn:00000283                 mov     esp, ebp
.text$mn:00000285                 pop     ebp
.text$mn:00000286                 retn    4
.text$mn:00000286 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00000286
.text$mn:00000286 ; ---------------------------------------------------------------------------
.text$mn:00000289                 align 4
.text$mn:00000289 _text$mn        ends
.text$mn:00000289
.text$mn:0000028C ; ===========================================================================
.text$mn:0000028C
.text$mn:0000028C ; Segment type: Pure code
.text$mn:0000028C ; Segment permissions: Read/Execute
.text$mn:0000028C _text$mn        segment para public 'CODE' use32
.text$mn:0000028C                 assume cs:_text$mn
.text$mn:0000028C                 ;org 28Ch
.text$mn:0000028C ; COMDAT (pick any)
.text$mn:0000028C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000028C
.text$mn:0000028C ; =============== S U B R O U T I N E =======================================
.text$mn:0000028C
.text$mn:0000028C ; Attributes: bp-based frame
.text$mn:0000028C
.text$mn:0000028C ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:0000028C                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:0000028C ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:0000028C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:0000028C
.text$mn:0000028C arg_0           = dword ptr  8
.text$mn:0000028C arg_4           = dword ptr  0Ch
.text$mn:0000028C
.text$mn:0000028C                 push    ebp
.text$mn:0000028D                 mov     ebp, esp
.text$mn:0000028F                 mov     eax, [ebp+arg_4]
.text$mn:00000292                 push    eax
.text$mn:00000293                 mov     ecx, [ebp+arg_0]
.text$mn:00000296                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:0000029B                 pop     ebp
.text$mn:0000029C                 retn
.text$mn:0000029C ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:0000029C
.text$mn:0000029C ; ---------------------------------------------------------------------------
.text$mn:0000029D                 align 10h
.text$mn:0000029D _text$mn        ends
.text$mn:0000029D
.text$mn:000002A0 ; ===========================================================================
.text$mn:000002A0
.text$mn:000002A0 ; Segment type: Pure code
.text$mn:000002A0 ; Segment permissions: Read/Execute
.text$mn:000002A0 _text$mn        segment para public 'CODE' use32
.text$mn:000002A0                 assume cs:_text$mn
.text$mn:000002A0                 ;org 2A0h
.text$mn:000002A0 ; COMDAT (pick any)
.text$mn:000002A0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000002A0
.text$mn:000002A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000002A0
.text$mn:000002A0 ; Attributes: bp-based frame
.text$mn:000002A0
.text$mn:000002A0 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:000002A0                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:000002A0 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:000002A0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:000002A0
.text$mn:000002A0 var_4           = dword ptr -4
.text$mn:000002A0
.text$mn:000002A0                 push    ebp
.text$mn:000002A1                 mov     ebp, esp
.text$mn:000002A3                 push    ecx
.text$mn:000002A4                 mov     [ebp+var_4], ecx
.text$mn:000002A7                 mov     esp, ebp
.text$mn:000002A9                 pop     ebp
.text$mn:000002AA                 retn    4
.text$mn:000002AA ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:000002AA
.text$mn:000002AA ; ---------------------------------------------------------------------------
.text$mn:000002AD                 align 10h
.text$mn:000002AD _text$mn        ends
.text$mn:000002AD
.text$mn:000002B0 ; ===========================================================================
.text$mn:000002B0
.text$mn:000002B0 ; Segment type: Pure code
.text$mn:000002B0 ; Segment permissions: Read/Execute
.text$mn:000002B0 _text$mn        segment para public 'CODE' use32
.text$mn:000002B0                 assume cs:_text$mn
.text$mn:000002B0                 ;org 2B0h
.text$mn:000002B0 ; COMDAT (pick any)
.text$mn:000002B0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000002B0
.text$mn:000002B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000002B0
.text$mn:000002B0 ; Attributes: bp-based frame
.text$mn:000002B0
.text$mn:000002B0 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:000002B0                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:000002B0 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:000002B0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:000002B0                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:000002B0
.text$mn:000002B0 arg_0           = dword ptr  8
.text$mn:000002B0
.text$mn:000002B0                 push    ebp
.text$mn:000002B1                 mov     ebp, esp
.text$mn:000002B3                 mov     eax, [ebp+arg_0]
.text$mn:000002B6                 pop     ebp
.text$mn:000002B7                 retn
.text$mn:000002B7 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:000002B7
.text$mn:000002B7 _text$mn        ends
.text$mn:000002B7
.text$mn:000002B8 ; ===========================================================================
.text$mn:000002B8
.text$mn:000002B8 ; Segment type: Pure code
.text$mn:000002B8 ; Segment permissions: Read/Execute
.text$mn:000002B8 _text$mn        segment para public 'CODE' use32
.text$mn:000002B8                 assume cs:_text$mn
.text$mn:000002B8                 ;org 2B8h
.text$mn:000002B8 ; COMDAT (pick any)
.text$mn:000002B8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000002B8
.text$mn:000002B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000002B8
.text$mn:000002B8 ; Attributes: bp-based frame
.text$mn:000002B8
.text$mn:000002B8 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:000002B8                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:000002B8 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:000002B8                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:000002B8
.text$mn:000002B8 arg_0           = dword ptr  8
.text$mn:000002B8
.text$mn:000002B8                 push    ebp
.text$mn:000002B9                 mov     ebp, esp
.text$mn:000002BB                 mov     eax, [ebp+arg_0]
.text$mn:000002BE                 pop     ebp
.text$mn:000002BF                 retn
.text$mn:000002BF ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:000002BF
.text$mn:000002BF _text$mn        ends
.text$mn:000002BF
.text$mn:000002C0 ; ===========================================================================
.text$mn:000002C0
.text$mn:000002C0 ; Segment type: Pure code
.text$mn:000002C0 ; Segment permissions: Read/Execute
.text$mn:000002C0 _text$mn        segment para public 'CODE' use32
.text$mn:000002C0                 assume cs:_text$mn
.text$mn:000002C0                 ;org 2C0h
.text$mn:000002C0 ; COMDAT (pick any)
.text$mn:000002C0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000002C0
.text$mn:000002C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000002C0
.text$mn:000002C0 ; Attributes: bp-based frame
.text$mn:000002C0
.text$mn:000002C0 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:000002C0                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:000002C0 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:000002C0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:000002C0
.text$mn:000002C0 var_10          = dword ptr -10h
.text$mn:000002C0 var_C           = dword ptr -0Ch
.text$mn:000002C0 var_4           = dword ptr -4
.text$mn:000002C0
.text$mn:000002C0                 push    ebp
.text$mn:000002C1                 mov     ebp, esp
.text$mn:000002C3                 push    0FFFFFFFFh
.text$mn:000002C5                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:000002CA                 mov     eax, large fs:0
.text$mn:000002D0                 push    eax
.text$mn:000002D1                 push    ecx
.text$mn:000002D2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000002D7                 xor     eax, ebp
.text$mn:000002D9                 push    eax
.text$mn:000002DA                 lea     eax, [ebp+var_C]
.text$mn:000002DD                 mov     large fs:0, eax
.text$mn:000002E3                 mov     [ebp+var_10], ecx
.text$mn:000002E6                 mov     ecx, [ebp+var_10]
.text$mn:000002E9                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:000002EE                 mov     [ebp+var_4], 0
.text$mn:000002F5                 mov     ecx, [ebp+var_10]
.text$mn:000002F8                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000002FD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000304                 mov     eax, [ebp+var_10]
.text$mn:00000307                 mov     ecx, [ebp+var_C]
.text$mn:0000030A                 mov     large fs:0, ecx
.text$mn:00000311                 pop     ecx
.text$mn:00000312                 mov     esp, ebp
.text$mn:00000314                 pop     ebp
.text$mn:00000315                 retn    4
.text$mn:00000315 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00000315
.text$mn:00000315 _text$mn        ends
.text$mn:00000315
.text$x:00000318 ; ===========================================================================
.text$x:00000318
.text$x:00000318 ; Segment type: Pure code
.text$x:00000318 ; Segment permissions: Read/Execute
.text$x:00000318 _text$x         segment para public 'CODE' use32
.text$x:00000318                 assume cs:_text$x
.text$x:00000318                 ;org 318h
.text$x:00000318 ; COMDAT (pick associative to section at 2C0)
.text$x:00000318                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000318
.text$x:00000318 ; =============== S U B R O U T I N E =======================================
.text$x:00000318
.text$x:00000318
.text$x:00000318 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00000318                                         ; DATA XREF: .xdata$x:0000199Co
.text$x:00000318                 mov     ecx, [ebp-10h]
.text$x:0000031B                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:0000031B __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:0000031B
.text$x:00000320
.text$x:00000320 ; =============== S U B R O U T I N E =======================================
.text$x:00000320
.text$x:00000320
.text$x:00000320 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00000320                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00000320
.text$x:00000320 arg_4           = dword ptr  8
.text$x:00000320
.text$x:00000320                 mov     edx, [esp+arg_4]
.text$x:00000324                 lea     eax, [edx+0Ch]
.text$x:00000327                 mov     ecx, [edx-8]
.text$x:0000032A                 xor     ecx, eax
.text$x:0000032C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000331                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00000336                 jmp     ___CxxFrameHandler3
.text$x:00000336 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00000336
.text$x:00000336 ; ---------------------------------------------------------------------------
.text$x:0000033B                 align 4
.text$x:0000033B _text$x         ends
.text$x:0000033B
.text$mn:0000033C ; ===========================================================================
.text$mn:0000033C
.text$mn:0000033C ; Segment type: Pure code
.text$mn:0000033C ; Segment permissions: Read/Execute
.text$mn:0000033C _text$mn        segment para public 'CODE' use32
.text$mn:0000033C                 assume cs:_text$mn
.text$mn:0000033C                 ;org 33Ch
.text$mn:0000033C ; COMDAT (pick any)
.text$mn:0000033C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000033C
.text$mn:0000033C ; =============== S U B R O U T I N E =======================================
.text$mn:0000033C
.text$mn:0000033C ; Attributes: bp-based frame
.text$mn:0000033C
.text$mn:0000033C ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:0000033C                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000033C ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:0000033C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:0000033C
.text$mn:0000033C var_10          = dword ptr -10h
.text$mn:0000033C var_C           = dword ptr -0Ch
.text$mn:0000033C var_4           = dword ptr -4
.text$mn:0000033C
.text$mn:0000033C                 push    ebp
.text$mn:0000033D                 mov     ebp, esp
.text$mn:0000033F                 push    0FFFFFFFFh
.text$mn:00000341                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000346                 mov     eax, large fs:0
.text$mn:0000034C                 push    eax
.text$mn:0000034D                 push    ecx
.text$mn:0000034E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000353                 xor     eax, ebp
.text$mn:00000355                 push    eax
.text$mn:00000356                 lea     eax, [ebp+var_C]
.text$mn:00000359                 mov     large fs:0, eax
.text$mn:0000035F                 mov     [ebp+var_10], ecx
.text$mn:00000362                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000365                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000036A                 mov     [ebp+var_4], 0
.text$mn:00000371                 mov     eax, [ebp+var_10]
.text$mn:00000374                 mov     dword ptr [eax+14h], 0
.text$mn:0000037B                 mov     ecx, [ebp+var_10]
.text$mn:0000037E                 mov     dword ptr [ecx+18h], 0
.text$mn:00000385                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000038C                 mov     eax, [ebp+var_10]
.text$mn:0000038F                 mov     ecx, [ebp+var_C]
.text$mn:00000392                 mov     large fs:0, ecx
.text$mn:00000399                 pop     ecx
.text$mn:0000039A                 mov     esp, ebp
.text$mn:0000039C                 pop     ebp
.text$mn:0000039D                 retn
.text$mn:0000039D ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:0000039D
.text$mn:0000039D ; ---------------------------------------------------------------------------
.text$mn:0000039E                 align 10h
.text$mn:0000039E _text$mn        ends
.text$mn:0000039E
.text$x:000003A0 ; ===========================================================================
.text$x:000003A0
.text$x:000003A0 ; Segment type: Pure code
.text$x:000003A0 ; Segment permissions: Read/Execute
.text$x:000003A0 _text$x         segment para public 'CODE' use32
.text$x:000003A0                 assume cs:_text$x
.text$x:000003A0                 ;org 3A0h
.text$x:000003A0 ; COMDAT (pick associative to section at 33C)
.text$x:000003A0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000003A0
.text$x:000003A0 ; =============== S U B R O U T I N E =======================================
.text$x:000003A0
.text$x:000003A0
.text$x:000003A0 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:000003A0                                         ; DATA XREF: .xdata$x:00001944o
.text$x:000003A0                 mov     ecx, [ebp-10h]  ; this
.text$x:000003A3                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000003A3 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:000003A3
.text$x:000003A8
.text$x:000003A8 ; =============== S U B R O U T I N E =======================================
.text$x:000003A8
.text$x:000003A8
.text$x:000003A8 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:000003A8                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:000003A8
.text$x:000003A8 arg_4           = dword ptr  8
.text$x:000003A8
.text$x:000003A8                 mov     edx, [esp+arg_4]
.text$x:000003AC                 lea     eax, [edx+0Ch]
.text$x:000003AF                 mov     ecx, [edx-8]
.text$x:000003B2                 xor     ecx, eax
.text$x:000003B4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000003B9                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000003BE                 jmp     ___CxxFrameHandler3
.text$x:000003BE __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000003BE
.text$x:000003BE ; ---------------------------------------------------------------------------
.text$x:000003C3                 align 4
.text$x:000003C3 _text$x         ends
.text$x:000003C3
.text$mn:000003C4 ; ===========================================================================
.text$mn:000003C4
.text$mn:000003C4 ; Segment type: Pure code
.text$mn:000003C4 ; Segment permissions: Read/Execute
.text$mn:000003C4 _text$mn        segment para public 'CODE' use32
.text$mn:000003C4                 assume cs:_text$mn
.text$mn:000003C4                 ;org 3C4h
.text$mn:000003C4 ; COMDAT (pick any)
.text$mn:000003C4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000003C4
.text$mn:000003C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000003C4
.text$mn:000003C4 ; Attributes: bp-based frame
.text$mn:000003C4
.text$mn:000003C4 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:000003C4                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:000003C4 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:000003C4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:000003C4
.text$mn:000003C4 var_4           = dword ptr -4
.text$mn:000003C4
.text$mn:000003C4                 push    ebp
.text$mn:000003C5                 mov     ebp, esp
.text$mn:000003C7                 push    ecx
.text$mn:000003C8                 mov     [ebp+var_4], ecx
.text$mn:000003CB                 mov     ecx, [ebp+var_4]
.text$mn:000003CE                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000003D3                 mov     eax, [ebp+var_4]
.text$mn:000003D6                 mov     esp, ebp
.text$mn:000003D8                 pop     ebp
.text$mn:000003D9                 retn
.text$mn:000003D9 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:000003D9
.text$mn:000003D9 ; ---------------------------------------------------------------------------
.text$mn:000003DA                 align 4
.text$mn:000003DA _text$mn        ends
.text$mn:000003DA
.text$mn:000003DC ; ===========================================================================
.text$mn:000003DC
.text$mn:000003DC ; Segment type: Pure code
.text$mn:000003DC ; Segment permissions: Read/Execute
.text$mn:000003DC _text$mn        segment para public 'CODE' use32
.text$mn:000003DC                 assume cs:_text$mn
.text$mn:000003DC                 ;org 3DCh
.text$mn:000003DC ; COMDAT (pick any)
.text$mn:000003DC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000003DC
.text$mn:000003DC ; =============== S U B R O U T I N E =======================================
.text$mn:000003DC
.text$mn:000003DC ; Attributes: bp-based frame
.text$mn:000003DC
.text$mn:000003DC ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:000003DC                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:000003DC ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:000003DC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:000003DC
.text$mn:000003DC var_4           = dword ptr -4
.text$mn:000003DC
.text$mn:000003DC                 push    ebp
.text$mn:000003DD                 mov     ebp, esp
.text$mn:000003DF                 push    ecx
.text$mn:000003E0                 mov     [ebp+var_4], ecx
.text$mn:000003E3                 mov     eax, [ebp+var_4]
.text$mn:000003E6                 mov     esp, ebp
.text$mn:000003E8                 pop     ebp
.text$mn:000003E9                 retn
.text$mn:000003E9 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:000003E9
.text$mn:000003E9 ; ---------------------------------------------------------------------------
.text$mn:000003EA                 align 4
.text$mn:000003EA _text$mn        ends
.text$mn:000003EA
.text$mn:000003EC ; ===========================================================================
.text$mn:000003EC
.text$mn:000003EC ; Segment type: Pure code
.text$mn:000003EC ; Segment permissions: Read/Execute
.text$mn:000003EC _text$mn        segment para public 'CODE' use32
.text$mn:000003EC                 assume cs:_text$mn
.text$mn:000003EC                 ;org 3ECh
.text$mn:000003EC ; COMDAT (pick any)
.text$mn:000003EC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000003EC
.text$mn:000003EC ; =============== S U B R O U T I N E =======================================
.text$mn:000003EC
.text$mn:000003EC ; Attributes: bp-based frame
.text$mn:000003EC
.text$mn:000003EC ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:000003EC                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:000003EC ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:000003EC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:000003EC                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:000003EC
.text$mn:000003EC var_4           = dword ptr -4
.text$mn:000003EC
.text$mn:000003EC                 push    ebp
.text$mn:000003ED                 mov     ebp, esp
.text$mn:000003EF                 push    ecx
.text$mn:000003F0                 mov     [ebp+var_4], ecx
.text$mn:000003F3                 mov     eax, [ebp+var_4]
.text$mn:000003F6                 mov     esp, ebp
.text$mn:000003F8                 pop     ebp
.text$mn:000003F9                 retn
.text$mn:000003F9 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:000003F9
.text$mn:000003F9 ; ---------------------------------------------------------------------------
.text$mn:000003FA                 align 4
.text$mn:000003FA _text$mn        ends
.text$mn:000003FA
.text$mn:000003FC ; ===========================================================================
.text$mn:000003FC
.text$mn:000003FC ; Segment type: Pure code
.text$mn:000003FC ; Segment permissions: Read/Execute
.text$mn:000003FC _text$mn        segment para public 'CODE' use32
.text$mn:000003FC                 assume cs:_text$mn
.text$mn:000003FC                 ;org 3FCh
.text$mn:000003FC ; COMDAT (pick any)
.text$mn:000003FC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000003FC
.text$mn:000003FC ; =============== S U B R O U T I N E =======================================
.text$mn:000003FC
.text$mn:000003FC ; Attributes: bp-based frame
.text$mn:000003FC
.text$mn:000003FC ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:000003FC                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:000003FC ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:000003FC                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:000003FC                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:000003FC
.text$mn:000003FC var_14          = dword ptr -14h
.text$mn:000003FC var_D           = byte ptr -0Dh
.text$mn:000003FC var_C           = dword ptr -0Ch
.text$mn:000003FC var_4           = dword ptr -4
.text$mn:000003FC Str             = dword ptr  8
.text$mn:000003FC
.text$mn:000003FC                 push    ebp
.text$mn:000003FD                 mov     ebp, esp
.text$mn:000003FF                 push    0FFFFFFFFh
.text$mn:00000401                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00000406                 mov     eax, large fs:0
.text$mn:0000040C                 push    eax
.text$mn:0000040D                 sub     esp, 8
.text$mn:00000410                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000415                 xor     eax, ebp
.text$mn:00000417                 push    eax
.text$mn:00000418                 lea     eax, [ebp+var_C]
.text$mn:0000041B                 mov     large fs:0, eax
.text$mn:00000421                 mov     [ebp+var_14], ecx
.text$mn:00000424                 lea     ecx, [ebp+var_D]
.text$mn:00000427                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:0000042C                 push    eax
.text$mn:0000042D                 mov     ecx, [ebp+var_14]
.text$mn:00000430                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00000435                 mov     [ebp+var_4], 0
.text$mn:0000043C                 push    0               ; Size
.text$mn:0000043E                 push    0               ; char
.text$mn:00000440                 mov     ecx, [ebp+var_14]
.text$mn:00000443                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000448                 mov     eax, [ebp+Str]
.text$mn:0000044B                 push    eax             ; Str
.text$mn:0000044C                 mov     ecx, [ebp+var_14]
.text$mn:0000044F                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00000454                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000045B                 mov     eax, [ebp+var_14]
.text$mn:0000045E                 mov     ecx, [ebp+var_C]
.text$mn:00000461                 mov     large fs:0, ecx
.text$mn:00000468                 pop     ecx
.text$mn:00000469                 mov     esp, ebp
.text$mn:0000046B                 pop     ebp
.text$mn:0000046C                 retn    4
.text$mn:0000046C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:0000046C
.text$mn:0000046C ; ---------------------------------------------------------------------------
.text$mn:0000046F                 align 10h
.text$mn:0000046F _text$mn        ends
.text$mn:0000046F
.text$x:00000470 ; ===========================================================================
.text$x:00000470
.text$x:00000470 ; Segment type: Pure code
.text$x:00000470 ; Segment permissions: Read/Execute
.text$x:00000470 _text$x         segment para public 'CODE' use32
.text$x:00000470                 assume cs:_text$x
.text$x:00000470                 ;org 470h
.text$x:00000470 ; COMDAT (pick associative to section at 3FC)
.text$x:00000470                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000470
.text$x:00000470 ; =============== S U B R O U T I N E =======================================
.text$x:00000470
.text$x:00000470
.text$x:00000470 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00000470                                         ; DATA XREF: .xdata$x:000019F4o
.text$x:00000470                 mov     ecx, [ebp-14h]
.text$x:00000473                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000473 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00000473
.text$x:00000478
.text$x:00000478 ; =============== S U B R O U T I N E =======================================
.text$x:00000478
.text$x:00000478
.text$x:00000478 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00000478                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00000478
.text$x:00000478 arg_4           = dword ptr  8
.text$x:00000478
.text$x:00000478                 mov     edx, [esp+arg_4]
.text$x:0000047C                 lea     eax, [edx+0Ch]
.text$x:0000047F                 mov     ecx, [edx-0Ch]
.text$x:00000482                 xor     ecx, eax
.text$x:00000484                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000489                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:0000048E                 jmp     ___CxxFrameHandler3
.text$x:0000048E __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:0000048E
.text$x:0000048E ; ---------------------------------------------------------------------------
.text$x:00000493                 align 4
.text$x:00000493 _text$x         ends
.text$x:00000493
.text$mn:00000494 ; ===========================================================================
.text$mn:00000494
.text$mn:00000494 ; Segment type: Pure code
.text$mn:00000494 ; Segment permissions: Read/Execute
.text$mn:00000494 _text$mn        segment para public 'CODE' use32
.text$mn:00000494                 assume cs:_text$mn
.text$mn:00000494                 ;org 494h
.text$mn:00000494 ; COMDAT (pick any)
.text$mn:00000494                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000494
.text$mn:00000494 ; =============== S U B R O U T I N E =======================================
.text$mn:00000494
.text$mn:00000494 ; Attributes: bp-based frame
.text$mn:00000494
.text$mn:00000494 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000494                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00000494 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00000494                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00000494
.text$mn:00000494 var_4           = dword ptr -4
.text$mn:00000494
.text$mn:00000494                 push    ebp
.text$mn:00000495                 mov     ebp, esp
.text$mn:00000497                 push    ecx
.text$mn:00000498                 mov     [ebp+var_4], ecx
.text$mn:0000049B                 mov     eax, [ebp+var_4]
.text$mn:0000049E                 mov     dword ptr [eax], 0
.text$mn:000004A4                 mov     eax, [ebp+var_4]
.text$mn:000004A7                 mov     esp, ebp
.text$mn:000004A9                 pop     ebp
.text$mn:000004AA                 retn
.text$mn:000004AA ??0_Container_base12@std@@QAE@XZ endp
.text$mn:000004AA
.text$mn:000004AA ; ---------------------------------------------------------------------------
.text$mn:000004AB                 align 4
.text$mn:000004AB _text$mn        ends
.text$mn:000004AB
.text$mn:000004AC ; ===========================================================================
.text$mn:000004AC
.text$mn:000004AC ; Segment type: Pure code
.text$mn:000004AC ; Segment permissions: Read/Execute
.text$mn:000004AC _text$mn        segment para public 'CODE' use32
.text$mn:000004AC                 assume cs:_text$mn
.text$mn:000004AC                 ;org 4ACh
.text$mn:000004AC ; COMDAT (pick any)
.text$mn:000004AC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000004AC
.text$mn:000004AC ; =============== S U B R O U T I N E =======================================
.text$mn:000004AC
.text$mn:000004AC ; Attributes: bp-based frame
.text$mn:000004AC
.text$mn:000004AC ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:000004AC                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:000004AC ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:000004AC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:000004AC
.text$mn:000004AC var_4           = dword ptr -4
.text$mn:000004AC
.text$mn:000004AC                 push    ebp
.text$mn:000004AD                 mov     ebp, esp
.text$mn:000004AF                 push    ecx
.text$mn:000004B0                 mov     [ebp+var_4], ecx
.text$mn:000004B3                 mov     eax, [ebp+var_4]
.text$mn:000004B6                 mov     dword ptr [eax], 0
.text$mn:000004BC                 mov     ecx, [ebp+var_4]
.text$mn:000004BF                 mov     dword ptr [ecx+4], 0
.text$mn:000004C6                 mov     eax, [ebp+var_4]
.text$mn:000004C9                 mov     esp, ebp
.text$mn:000004CB                 pop     ebp
.text$mn:000004CC                 retn
.text$mn:000004CC ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:000004CC
.text$mn:000004CC ; ---------------------------------------------------------------------------
.text$mn:000004CD                 align 10h
.text$mn:000004CD _text$mn        ends
.text$mn:000004CD
.text$mn:000004D0 ; ===========================================================================
.text$mn:000004D0
.text$mn:000004D0 ; Segment type: Pure code
.text$mn:000004D0 ; Segment permissions: Read/Execute
.text$mn:000004D0 _text$mn        segment para public 'CODE' use32
.text$mn:000004D0                 assume cs:_text$mn
.text$mn:000004D0                 ;org 4D0h
.text$mn:000004D0 ; COMDAT (pick any)
.text$mn:000004D0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000004D0
.text$mn:000004D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000004D0
.text$mn:000004D0 ; Attributes: bp-based frame
.text$mn:000004D0
.text$mn:000004D0 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:000004D0                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:000004D0 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:000004D0                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:000004D0                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:000004D0
.text$mn:000004D0 var_10          = dword ptr -10h
.text$mn:000004D0 var_C           = dword ptr -0Ch
.text$mn:000004D0 var_4           = dword ptr -4
.text$mn:000004D0
.text$mn:000004D0                 push    ebp
.text$mn:000004D1                 mov     ebp, esp
.text$mn:000004D3                 push    0FFFFFFFFh
.text$mn:000004D5                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:000004DA                 mov     eax, large fs:0
.text$mn:000004E0                 push    eax
.text$mn:000004E1                 push    ecx
.text$mn:000004E2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000004E7                 xor     eax, ebp
.text$mn:000004E9                 push    eax
.text$mn:000004EA                 lea     eax, [ebp+var_C]
.text$mn:000004ED                 mov     large fs:0, eax
.text$mn:000004F3                 mov     [ebp+var_10], ecx
.text$mn:000004F6                 mov     ecx, [ebp+var_10] ; this
.text$mn:000004F9                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:000004FE                 mov     [ebp+var_4], 0
.text$mn:00000505                 mov     eax, [ebp+var_10]
.text$mn:00000508                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:0000050E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000515                 mov     eax, [ebp+var_10]
.text$mn:00000518                 mov     ecx, [ebp+var_C]
.text$mn:0000051B                 mov     large fs:0, ecx
.text$mn:00000522                 pop     ecx
.text$mn:00000523                 mov     esp, ebp
.text$mn:00000525                 pop     ebp
.text$mn:00000526                 retn
.text$mn:00000526 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00000526
.text$mn:00000526 ; ---------------------------------------------------------------------------
.text$mn:00000527                 align 4
.text$mn:00000527 _text$mn        ends
.text$mn:00000527
.text$x:00000528 ; ===========================================================================
.text$x:00000528
.text$x:00000528 ; Segment type: Pure code
.text$x:00000528 ; Segment permissions: Read/Execute
.text$x:00000528 _text$x         segment para public 'CODE' use32
.text$x:00000528                 assume cs:_text$x
.text$x:00000528                 ;org 528h
.text$x:00000528 ; COMDAT (pick associative to section at 4D0)
.text$x:00000528                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000528
.text$x:00000528 ; =============== S U B R O U T I N E =======================================
.text$x:00000528
.text$x:00000528
.text$x:00000528 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00000528                                         ; DATA XREF: .xdata$x:00001AD8o
.text$x:00000528                 mov     ecx, [ebp-10h]  ; this
.text$x:0000052B                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:0000052B __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:0000052B
.text$x:00000530
.text$x:00000530 ; =============== S U B R O U T I N E =======================================
.text$x:00000530
.text$x:00000530
.text$x:00000530 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00000530                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00000530
.text$x:00000530 arg_4           = dword ptr  8
.text$x:00000530
.text$x:00000530                 mov     edx, [esp+arg_4]
.text$x:00000534                 lea     eax, [edx+0Ch]
.text$x:00000537                 mov     ecx, [edx-8]
.text$x:0000053A                 xor     ecx, eax
.text$x:0000053C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000541                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00000546                 jmp     ___CxxFrameHandler3
.text$x:00000546 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00000546
.text$x:00000546 ; ---------------------------------------------------------------------------
.text$x:0000054B                 align 4
.text$x:0000054B _text$x         ends
.text$x:0000054B
.text$mn:0000054C ; ===========================================================================
.text$mn:0000054C
.text$mn:0000054C ; Segment type: Pure code
.text$mn:0000054C ; Segment permissions: Read/Execute
.text$mn:0000054C _text$mn        segment para public 'CODE' use32
.text$mn:0000054C                 assume cs:_text$mn
.text$mn:0000054C                 ;org 54Ch
.text$mn:0000054C ; COMDAT (pick any)
.text$mn:0000054C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000054C
.text$mn:0000054C ; =============== S U B R O U T I N E =======================================
.text$mn:0000054C
.text$mn:0000054C ; Attributes: bp-based frame
.text$mn:0000054C
.text$mn:0000054C ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:0000054C                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:0000054C ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:0000054C                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:0000054C
.text$mn:0000054C var_10          = dword ptr -10h
.text$mn:0000054C var_C           = dword ptr -0Ch
.text$mn:0000054C var_4           = dword ptr -4
.text$mn:0000054C
.text$mn:0000054C                 push    ebp
.text$mn:0000054D                 mov     ebp, esp
.text$mn:0000054F                 push    0FFFFFFFFh
.text$mn:00000551                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00000556                 mov     eax, large fs:0
.text$mn:0000055C                 push    eax
.text$mn:0000055D                 push    ecx
.text$mn:0000055E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000563                 xor     eax, ebp
.text$mn:00000565                 push    eax
.text$mn:00000566                 lea     eax, [ebp+var_C]
.text$mn:00000569                 mov     large fs:0, eax
.text$mn:0000056F                 mov     [ebp+var_10], ecx
.text$mn:00000572                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000575                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:0000057A                 mov     [ebp+var_4], 0
.text$mn:00000581                 mov     eax, [ebp+var_10]
.text$mn:00000584                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:0000058A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000591                 mov     eax, [ebp+var_10]
.text$mn:00000594                 mov     ecx, [ebp+var_C]
.text$mn:00000597                 mov     large fs:0, ecx
.text$mn:0000059E                 pop     ecx
.text$mn:0000059F                 mov     esp, ebp
.text$mn:000005A1                 pop     ebp
.text$mn:000005A2                 retn
.text$mn:000005A2 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:000005A2
.text$mn:000005A2 ; ---------------------------------------------------------------------------
.text$mn:000005A3                 align 4
.text$mn:000005A3 _text$mn        ends
.text$mn:000005A3
.text$x:000005A4 ; ===========================================================================
.text$x:000005A4
.text$x:000005A4 ; Segment type: Pure code
.text$x:000005A4 ; Segment permissions: Read/Execute
.text$x:000005A4 _text$x         segment para public 'CODE' use32
.text$x:000005A4                 assume cs:_text$x
.text$x:000005A4                 ;org 5A4h
.text$x:000005A4 ; COMDAT (pick associative to section at 54C)
.text$x:000005A4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000005A4
.text$x:000005A4 ; =============== S U B R O U T I N E =======================================
.text$x:000005A4
.text$x:000005A4
.text$x:000005A4 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:000005A4                                         ; DATA XREF: .xdata$x:00001B5Co
.text$x:000005A4                 mov     ecx, [ebp-10h]  ; this
.text$x:000005A7                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000005A7 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:000005A7
.text$x:000005AC
.text$x:000005AC ; =============== S U B R O U T I N E =======================================
.text$x:000005AC
.text$x:000005AC
.text$x:000005AC __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:000005AC                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:000005AC
.text$x:000005AC arg_4           = dword ptr  8
.text$x:000005AC
.text$x:000005AC                 mov     edx, [esp+arg_4]
.text$x:000005B0                 lea     eax, [edx+0Ch]
.text$x:000005B3                 mov     ecx, [edx-8]
.text$x:000005B6                 xor     ecx, eax
.text$x:000005B8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000005BD                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:000005C2                 jmp     ___CxxFrameHandler3
.text$x:000005C2 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:000005C2
.text$x:000005C2 ; ---------------------------------------------------------------------------
.text$x:000005C7                 align 4
.text$x:000005C7 _text$x         ends
.text$x:000005C7
.text$mn:000005C8 ; ===========================================================================
.text$mn:000005C8
.text$mn:000005C8 ; Segment type: Pure code
.text$mn:000005C8 ; Segment permissions: Read/Execute
.text$mn:000005C8 _text$mn        segment para public 'CODE' use32
.text$mn:000005C8                 assume cs:_text$mn
.text$mn:000005C8                 ;org 5C8h
.text$mn:000005C8 ; COMDAT (pick any)
.text$mn:000005C8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000005C8
.text$mn:000005C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000005C8
.text$mn:000005C8 ; Attributes: bp-based frame
.text$mn:000005C8
.text$mn:000005C8 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:000005C8                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:000005C8 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:000005C8                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:000005C8
.text$mn:000005C8 var_10          = dword ptr -10h
.text$mn:000005C8 var_C           = dword ptr -0Ch
.text$mn:000005C8 var_4           = dword ptr -4
.text$mn:000005C8
.text$mn:000005C8                 push    ebp
.text$mn:000005C9                 mov     ebp, esp
.text$mn:000005CB                 push    0FFFFFFFFh
.text$mn:000005CD                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:000005D2                 mov     eax, large fs:0
.text$mn:000005D8                 push    eax
.text$mn:000005D9                 push    ecx
.text$mn:000005DA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000005DF                 xor     eax, ebp
.text$mn:000005E1                 push    eax
.text$mn:000005E2                 lea     eax, [ebp+var_C]
.text$mn:000005E5                 mov     large fs:0, eax
.text$mn:000005EB                 mov     [ebp+var_10], ecx
.text$mn:000005EE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000005F1                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:000005F6                 mov     [ebp+var_4], 0
.text$mn:000005FD                 mov     eax, [ebp+var_10]
.text$mn:00000600                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00000606                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000060D                 mov     eax, [ebp+var_10]
.text$mn:00000610                 mov     ecx, [ebp+var_C]
.text$mn:00000613                 mov     large fs:0, ecx
.text$mn:0000061A                 pop     ecx
.text$mn:0000061B                 mov     esp, ebp
.text$mn:0000061D                 pop     ebp
.text$mn:0000061E                 retn
.text$mn:0000061E ??0_System_error_category@std@@QAE@XZ endp
.text$mn:0000061E
.text$mn:0000061E ; ---------------------------------------------------------------------------
.text$mn:0000061F                 align 10h
.text$mn:0000061F _text$mn        ends
.text$mn:0000061F
.text$x:00000620 ; ===========================================================================
.text$x:00000620
.text$x:00000620 ; Segment type: Pure code
.text$x:00000620 ; Segment permissions: Read/Execute
.text$x:00000620 _text$x         segment para public 'CODE' use32
.text$x:00000620                 assume cs:_text$x
.text$x:00000620                 ;org 620h
.text$x:00000620 ; COMDAT (pick associative to section at 5C8)
.text$x:00000620                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000620
.text$x:00000620 ; =============== S U B R O U T I N E =======================================
.text$x:00000620
.text$x:00000620
.text$x:00000620 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00000620                                         ; DATA XREF: .xdata$x:00001BE0o
.text$x:00000620                 mov     ecx, [ebp-10h]  ; this
.text$x:00000623                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000623 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00000623
.text$x:00000628
.text$x:00000628 ; =============== S U B R O U T I N E =======================================
.text$x:00000628
.text$x:00000628
.text$x:00000628 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00000628                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00000628
.text$x:00000628 arg_4           = dword ptr  8
.text$x:00000628
.text$x:00000628                 mov     edx, [esp+arg_4]
.text$x:0000062C                 lea     eax, [edx+0Ch]
.text$x:0000062F                 mov     ecx, [edx-8]
.text$x:00000632                 xor     ecx, eax
.text$x:00000634                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000639                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:0000063E                 jmp     ___CxxFrameHandler3
.text$x:0000063E __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:0000063E
.text$x:0000063E ; ---------------------------------------------------------------------------
.text$x:00000643                 align 4
.text$x:00000643 _text$x         ends
.text$x:00000643
.text$mn:00000644 ; ===========================================================================
.text$mn:00000644
.text$mn:00000644 ; Segment type: Pure code
.text$mn:00000644 ; Segment permissions: Read/Execute
.text$mn:00000644 _text$mn        segment para public 'CODE' use32
.text$mn:00000644                 assume cs:_text$mn
.text$mn:00000644                 ;org 644h
.text$mn:00000644 ; COMDAT (pick any)
.text$mn:00000644                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000644
.text$mn:00000644 ; =============== S U B R O U T I N E =======================================
.text$mn:00000644
.text$mn:00000644 ; Attributes: bp-based frame
.text$mn:00000644
.text$mn:00000644 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00000644                 public ??0error_category@std@@QAE@XZ
.text$mn:00000644 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00000644
.text$mn:00000644 var_4           = dword ptr -4
.text$mn:00000644
.text$mn:00000644                 push    ebp
.text$mn:00000645                 mov     ebp, esp
.text$mn:00000647                 push    ecx
.text$mn:00000648                 mov     [ebp+var_4], ecx
.text$mn:0000064B                 mov     eax, [ebp+var_4]
.text$mn:0000064E                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00000654                 mov     eax, [ebp+var_4]
.text$mn:00000657                 mov     esp, ebp
.text$mn:00000659                 pop     ebp
.text$mn:0000065A                 retn
.text$mn:0000065A ??0error_category@std@@QAE@XZ endp
.text$mn:0000065A
.text$mn:0000065A ; ---------------------------------------------------------------------------
.text$mn:0000065B                 align 4
.text$mn:0000065B _text$mn        ends
.text$mn:0000065B
.text$mn:0000065C ; ===========================================================================
.text$mn:0000065C
.text$mn:0000065C ; Segment type: Pure code
.text$mn:0000065C ; Segment permissions: Read/Execute
.text$mn:0000065C _text$mn        segment para public 'CODE' use32
.text$mn:0000065C                 assume cs:_text$mn
.text$mn:0000065C                 ;org 65Ch
.text$mn:0000065C ; COMDAT (pick any)
.text$mn:0000065C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000065C
.text$mn:0000065C ; =============== S U B R O U T I N E =======================================
.text$mn:0000065C
.text$mn:0000065C ; Attributes: bp-based frame
.text$mn:0000065C
.text$mn:0000065C ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:0000065C                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:0000065C ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:0000065C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:0000065C                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:0000065C
.text$mn:0000065C var_4           = dword ptr -4
.text$mn:0000065C arg_0           = dword ptr  8
.text$mn:0000065C arg_4           = dword ptr  0Ch
.text$mn:0000065C
.text$mn:0000065C                 push    ebp
.text$mn:0000065D                 mov     ebp, esp
.text$mn:0000065F                 push    ecx
.text$mn:00000660                 mov     [ebp+var_4], ecx
.text$mn:00000663                 mov     eax, [ebp+var_4]
.text$mn:00000666                 mov     ecx, [ebp+arg_0]
.text$mn:00000669                 mov     [eax], ecx
.text$mn:0000066B                 mov     edx, [ebp+var_4]
.text$mn:0000066E                 mov     eax, [ebp+arg_4]
.text$mn:00000671                 mov     [edx+4], eax
.text$mn:00000674                 mov     eax, [ebp+var_4]
.text$mn:00000677                 mov     esp, ebp
.text$mn:00000679                 pop     ebp
.text$mn:0000067A                 retn    8
.text$mn:0000067A ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:0000067A
.text$mn:0000067A ; ---------------------------------------------------------------------------
.text$mn:0000067D                 align 10h
.text$mn:0000067D _text$mn        ends
.text$mn:0000067D
.text$mn:00000680 ; ===========================================================================
.text$mn:00000680
.text$mn:00000680 ; Segment type: Pure code
.text$mn:00000680 ; Segment permissions: Read/Execute
.text$mn:00000680 _text$mn        segment para public 'CODE' use32
.text$mn:00000680                 assume cs:_text$mn
.text$mn:00000680                 ;org 680h
.text$mn:00000680 ; COMDAT (pick any)
.text$mn:00000680                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000680
.text$mn:00000680 ; =============== S U B R O U T I N E =======================================
.text$mn:00000680
.text$mn:00000680 ; Attributes: bp-based frame
.text$mn:00000680
.text$mn:00000680 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00000680                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00000680 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00000680                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00000680
.text$mn:00000680 var_4           = dword ptr -4
.text$mn:00000680 arg_0           = dword ptr  8
.text$mn:00000680
.text$mn:00000680                 push    ebp
.text$mn:00000681                 mov     ebp, esp
.text$mn:00000683                 push    ecx
.text$mn:00000684                 mov     [ebp+var_4], ecx
.text$mn:00000687                 mov     eax, [ebp+var_4]
.text$mn:0000068A                 mov     ecx, [ebp+arg_0]
.text$mn:0000068D                 mov     [eax], ecx
.text$mn:0000068F                 mov     eax, [ebp+var_4]
.text$mn:00000692                 mov     esp, ebp
.text$mn:00000694                 pop     ebp
.text$mn:00000695                 retn    4
.text$mn:00000695 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00000695
.text$mn:00000695 _text$mn        ends
.text$mn:00000695
.text$mn:00000698 ; ===========================================================================
.text$mn:00000698
.text$mn:00000698 ; Segment type: Pure code
.text$mn:00000698 ; Segment permissions: Read/Execute
.text$mn:00000698 _text$mn        segment para public 'CODE' use32
.text$mn:00000698                 assume cs:_text$mn
.text$mn:00000698                 ;org 698h
.text$mn:00000698 ; COMDAT (pick any)
.text$mn:00000698                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000698
.text$mn:00000698 ; =============== S U B R O U T I N E =======================================
.text$mn:00000698
.text$mn:00000698 ; Attributes: bp-based frame
.text$mn:00000698
.text$mn:00000698 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00000698                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00000698 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00000698                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00000698                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00000698
.text$mn:00000698 var_10          = dword ptr -10h
.text$mn:00000698 var_C           = dword ptr -0Ch
.text$mn:00000698 var_4           = dword ptr -4
.text$mn:00000698
.text$mn:00000698                 push    ebp
.text$mn:00000699                 mov     ebp, esp
.text$mn:0000069B                 push    0FFFFFFFFh
.text$mn:0000069D                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:000006A2                 mov     eax, large fs:0
.text$mn:000006A8                 push    eax
.text$mn:000006A9                 push    ecx
.text$mn:000006AA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000006AF                 xor     eax, ebp
.text$mn:000006B1                 push    eax
.text$mn:000006B2                 lea     eax, [ebp+var_C]
.text$mn:000006B5                 mov     large fs:0, eax
.text$mn:000006BB                 mov     [ebp+var_10], ecx
.text$mn:000006BE                 mov     [ebp+var_4], 0
.text$mn:000006C5                 mov     ecx, [ebp+var_10]
.text$mn:000006C8                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:000006CD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000006D4                 mov     ecx, [ebp+var_10]
.text$mn:000006D7                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:000006DC                 mov     ecx, [ebp+var_C]
.text$mn:000006DF                 mov     large fs:0, ecx
.text$mn:000006E6                 pop     ecx
.text$mn:000006E7                 mov     esp, ebp
.text$mn:000006E9                 pop     ebp
.text$mn:000006EA                 retn
.text$mn:000006EA ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:000006EA
.text$mn:000006EA ; ---------------------------------------------------------------------------
.text$mn:000006EB                 align 4
.text$mn:000006EB _text$mn        ends
.text$mn:000006EB
.text$x:000006EC ; ===========================================================================
.text$x:000006EC
.text$x:000006EC ; Segment type: Pure code
.text$x:000006EC ; Segment permissions: Read/Execute
.text$x:000006EC _text$x         segment para public 'CODE' use32
.text$x:000006EC                 assume cs:_text$x
.text$x:000006EC                 ;org 6ECh
.text$x:000006EC ; COMDAT (pick associative to section at 698)
.text$x:000006EC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000006EC
.text$x:000006EC ; =============== S U B R O U T I N E =======================================
.text$x:000006EC
.text$x:000006EC
.text$x:000006EC __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000006EC                                         ; DATA XREF: .xdata$x:000019C8o
.text$x:000006EC                 mov     ecx, [ebp-10h]
.text$x:000006EF                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:000006EF __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000006EF
.text$x:000006F4
.text$x:000006F4 ; =============== S U B R O U T I N E =======================================
.text$x:000006F4
.text$x:000006F4
.text$x:000006F4 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:000006F4                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:000006F4
.text$x:000006F4 arg_4           = dword ptr  8
.text$x:000006F4
.text$x:000006F4                 mov     edx, [esp+arg_4]
.text$x:000006F8                 lea     eax, [edx+0Ch]
.text$x:000006FB                 mov     ecx, [edx-8]
.text$x:000006FE                 xor     ecx, eax
.text$x:00000700                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000705                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:0000070A                 jmp     ___CxxFrameHandler3
.text$x:0000070A __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:0000070A
.text$x:0000070A ; ---------------------------------------------------------------------------
.text$x:0000070F                 align 10h
.text$x:0000070F _text$x         ends
.text$x:0000070F
.text$mn:00000710 ; ===========================================================================
.text$mn:00000710
.text$mn:00000710 ; Segment type: Pure code
.text$mn:00000710 ; Segment permissions: Read/Execute
.text$mn:00000710 _text$mn        segment para public 'CODE' use32
.text$mn:00000710                 assume cs:_text$mn
.text$mn:00000710                 ;org 710h
.text$mn:00000710 ; COMDAT (pick any)
.text$mn:00000710                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000710
.text$mn:00000710 ; =============== S U B R O U T I N E =======================================
.text$mn:00000710
.text$mn:00000710 ; Attributes: bp-based frame
.text$mn:00000710
.text$mn:00000710 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00000710                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000710 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00000710                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00000710                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00000710
.text$mn:00000710 var_10          = dword ptr -10h
.text$mn:00000710 var_C           = dword ptr -0Ch
.text$mn:00000710 var_4           = dword ptr -4
.text$mn:00000710
.text$mn:00000710                 push    ebp
.text$mn:00000711                 mov     ebp, esp
.text$mn:00000713                 push    0FFFFFFFFh
.text$mn:00000715                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000071A                 mov     eax, large fs:0
.text$mn:00000720                 push    eax
.text$mn:00000721                 push    ecx
.text$mn:00000722                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000727                 xor     eax, ebp
.text$mn:00000729                 push    eax
.text$mn:0000072A                 lea     eax, [ebp+var_C]
.text$mn:0000072D                 mov     large fs:0, eax
.text$mn:00000733                 mov     [ebp+var_10], ecx
.text$mn:00000736                 mov     [ebp+var_4], 0
.text$mn:0000073D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000744                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000747                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:0000074C                 mov     ecx, [ebp+var_C]
.text$mn:0000074F                 mov     large fs:0, ecx
.text$mn:00000756                 pop     ecx
.text$mn:00000757                 mov     esp, ebp
.text$mn:00000759                 pop     ebp
.text$mn:0000075A                 retn
.text$mn:0000075A ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:0000075A
.text$mn:0000075A ; ---------------------------------------------------------------------------
.text$mn:0000075B                 align 4
.text$mn:0000075B _text$mn        ends
.text$mn:0000075B
.text$x:0000075C ; ===========================================================================
.text$x:0000075C
.text$x:0000075C ; Segment type: Pure code
.text$x:0000075C ; Segment permissions: Read/Execute
.text$x:0000075C _text$x         segment para public 'CODE' use32
.text$x:0000075C                 assume cs:_text$x
.text$x:0000075C                 ;org 75Ch
.text$x:0000075C ; COMDAT (pick associative to section at 710)
.text$x:0000075C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:0000075C
.text$x:0000075C ; =============== S U B R O U T I N E =======================================
.text$x:0000075C
.text$x:0000075C
.text$x:0000075C __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:0000075C                                         ; DATA XREF: .xdata$x:00001970o
.text$x:0000075C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000075F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000075F __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:0000075F
.text$x:00000764
.text$x:00000764 ; =============== S U B R O U T I N E =======================================
.text$x:00000764
.text$x:00000764
.text$x:00000764 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000764                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000764
.text$x:00000764 arg_4           = dword ptr  8
.text$x:00000764
.text$x:00000764                 mov     edx, [esp+arg_4]
.text$x:00000768                 lea     eax, [edx+0Ch]
.text$x:0000076B                 mov     ecx, [edx-8]
.text$x:0000076E                 xor     ecx, eax
.text$x:00000770                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000775                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000077A                 jmp     ___CxxFrameHandler3
.text$x:0000077A __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000077A
.text$x:0000077A ; ---------------------------------------------------------------------------
.text$x:0000077F                 align 10h
.text$x:0000077F _text$x         ends
.text$x:0000077F
.text$mn:00000780 ; ===========================================================================
.text$mn:00000780
.text$mn:00000780 ; Segment type: Pure code
.text$mn:00000780 ; Segment permissions: Read/Execute
.text$mn:00000780 _text$mn        segment para public 'CODE' use32
.text$mn:00000780                 assume cs:_text$mn
.text$mn:00000780                 ;org 780h
.text$mn:00000780 ; COMDAT (pick any)
.text$mn:00000780                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000780
.text$mn:00000780 ; =============== S U B R O U T I N E =======================================
.text$mn:00000780
.text$mn:00000780 ; Attributes: bp-based frame
.text$mn:00000780
.text$mn:00000780 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00000780                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000780 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00000780                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00000780                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00000780
.text$mn:00000780 var_10          = dword ptr -10h
.text$mn:00000780 var_C           = dword ptr -0Ch
.text$mn:00000780 var_4           = dword ptr -4
.text$mn:00000780
.text$mn:00000780                 push    ebp
.text$mn:00000781                 mov     ebp, esp
.text$mn:00000783                 push    0FFFFFFFFh
.text$mn:00000785                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:0000078A                 mov     eax, large fs:0
.text$mn:00000790                 push    eax
.text$mn:00000791                 push    ecx
.text$mn:00000792                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000797                 xor     eax, ebp
.text$mn:00000799                 push    eax
.text$mn:0000079A                 lea     eax, [ebp+var_C]
.text$mn:0000079D                 mov     large fs:0, eax
.text$mn:000007A3                 mov     [ebp+var_10], ecx
.text$mn:000007A6                 mov     [ebp+var_4], 0
.text$mn:000007AD                 push    0               ; Size
.text$mn:000007AF                 push    1               ; char
.text$mn:000007B1                 mov     ecx, [ebp+var_10]
.text$mn:000007B4                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000007B9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000007C0                 mov     ecx, [ebp+var_10]
.text$mn:000007C3                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:000007C8                 mov     ecx, [ebp+var_C]
.text$mn:000007CB                 mov     large fs:0, ecx
.text$mn:000007D2                 pop     ecx
.text$mn:000007D3                 mov     esp, ebp
.text$mn:000007D5                 pop     ebp
.text$mn:000007D6                 retn
.text$mn:000007D6 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:000007D6
.text$mn:000007D6 ; ---------------------------------------------------------------------------
.text$mn:000007D7                 align 4
.text$mn:000007D7 _text$mn        ends
.text$mn:000007D7
.text$x:000007D8 ; ===========================================================================
.text$x:000007D8
.text$x:000007D8 ; Segment type: Pure code
.text$x:000007D8 ; Segment permissions: Read/Execute
.text$x:000007D8 _text$x         segment para public 'CODE' use32
.text$x:000007D8                 assume cs:_text$x
.text$x:000007D8                 ;org 7D8h
.text$x:000007D8 ; COMDAT (pick associative to section at 780)
.text$x:000007D8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000007D8
.text$x:000007D8 ; =============== S U B R O U T I N E =======================================
.text$x:000007D8
.text$x:000007D8
.text$x:000007D8 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:000007D8                                         ; DATA XREF: .xdata$x:00001A20o
.text$x:000007D8                 mov     ecx, [ebp-10h]
.text$x:000007DB                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:000007DB __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:000007DB
.text$x:000007E0
.text$x:000007E0 ; =============== S U B R O U T I N E =======================================
.text$x:000007E0
.text$x:000007E0
.text$x:000007E0 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:000007E0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:000007E0
.text$x:000007E0 arg_4           = dword ptr  8
.text$x:000007E0
.text$x:000007E0                 mov     edx, [esp+arg_4]
.text$x:000007E4                 lea     eax, [edx+0Ch]
.text$x:000007E7                 mov     ecx, [edx-8]
.text$x:000007EA                 xor     ecx, eax
.text$x:000007EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000007F1                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:000007F6                 jmp     ___CxxFrameHandler3
.text$x:000007F6 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:000007F6
.text$x:000007F6 ; ---------------------------------------------------------------------------
.text$x:000007FB                 align 4
.text$x:000007FB _text$x         ends
.text$x:000007FB
.text$mn:000007FC ; ===========================================================================
.text$mn:000007FC
.text$mn:000007FC ; Segment type: Pure code
.text$mn:000007FC ; Segment permissions: Read/Execute
.text$mn:000007FC _text$mn        segment para public 'CODE' use32
.text$mn:000007FC                 assume cs:_text$mn
.text$mn:000007FC                 ;org 7FCh
.text$mn:000007FC ; COMDAT (pick any)
.text$mn:000007FC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000007FC
.text$mn:000007FC ; =============== S U B R O U T I N E =======================================
.text$mn:000007FC
.text$mn:000007FC ; Attributes: bp-based frame
.text$mn:000007FC
.text$mn:000007FC ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:000007FC                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:000007FC ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:000007FC                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:000007FC                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:000007FC
.text$mn:000007FC var_4           = dword ptr -4
.text$mn:000007FC
.text$mn:000007FC                 push    ebp
.text$mn:000007FD                 mov     ebp, esp
.text$mn:000007FF                 push    ecx
.text$mn:00000800                 mov     [ebp+var_4], ecx
.text$mn:00000803                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000806                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000080B                 mov     esp, ebp
.text$mn:0000080D                 pop     ebp
.text$mn:0000080E                 retn
.text$mn:0000080E ??1_Container_base12@std@@QAE@XZ endp
.text$mn:0000080E
.text$mn:0000080E ; ---------------------------------------------------------------------------
.text$mn:0000080F                 align 10h
.text$mn:0000080F _text$mn        ends
.text$mn:0000080F
.text$mn:00000810 ; ===========================================================================
.text$mn:00000810
.text$mn:00000810 ; Segment type: Pure code
.text$mn:00000810 ; Segment permissions: Read/Execute
.text$mn:00000810 _text$mn        segment para public 'CODE' use32
.text$mn:00000810                 assume cs:_text$mn
.text$mn:00000810                 ;org 810h
.text$mn:00000810 ; COMDAT (pick any)
.text$mn:00000810                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000810
.text$mn:00000810 ; =============== S U B R O U T I N E =======================================
.text$mn:00000810
.text$mn:00000810 ; Attributes: bp-based frame
.text$mn:00000810
.text$mn:00000810 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00000810                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00000810 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00000810                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00000810                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00000810
.text$mn:00000810 var_10          = dword ptr -10h
.text$mn:00000810 var_C           = dword ptr -0Ch
.text$mn:00000810 var_4           = dword ptr -4
.text$mn:00000810
.text$mn:00000810                 push    ebp
.text$mn:00000811                 mov     ebp, esp
.text$mn:00000813                 push    0FFFFFFFFh
.text$mn:00000815                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:0000081A                 mov     eax, large fs:0
.text$mn:00000820                 push    eax
.text$mn:00000821                 push    ecx
.text$mn:00000822                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000827                 xor     eax, ebp
.text$mn:00000829                 push    eax
.text$mn:0000082A                 lea     eax, [ebp+var_C]
.text$mn:0000082D                 mov     large fs:0, eax
.text$mn:00000833                 mov     [ebp+var_10], ecx
.text$mn:00000836                 mov     [ebp+var_4], 0
.text$mn:0000083D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000844                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000847                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:0000084C                 mov     ecx, [ebp+var_C]
.text$mn:0000084F                 mov     large fs:0, ecx
.text$mn:00000856                 pop     ecx
.text$mn:00000857                 mov     esp, ebp
.text$mn:00000859                 pop     ebp
.text$mn:0000085A                 retn
.text$mn:0000085A ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:0000085A
.text$mn:0000085A ; ---------------------------------------------------------------------------
.text$mn:0000085B                 align 4
.text$mn:0000085B _text$mn        ends
.text$mn:0000085B
.text$x:0000085C ; ===========================================================================
.text$x:0000085C
.text$x:0000085C ; Segment type: Pure code
.text$x:0000085C ; Segment permissions: Read/Execute
.text$x:0000085C _text$x         segment para public 'CODE' use32
.text$x:0000085C                 assume cs:_text$x
.text$x:0000085C                 ;org 85Ch
.text$x:0000085C ; COMDAT (pick associative to section at 810)
.text$x:0000085C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:0000085C
.text$x:0000085C ; =============== S U B R O U T I N E =======================================
.text$x:0000085C
.text$x:0000085C
.text$x:0000085C __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:0000085C                                         ; DATA XREF: .xdata$x:00001B30o
.text$x:0000085C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000085F                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:0000085F __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:0000085F
.text$x:00000864
.text$x:00000864 ; =============== S U B R O U T I N E =======================================
.text$x:00000864
.text$x:00000864
.text$x:00000864 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00000864                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00000864
.text$x:00000864 arg_4           = dword ptr  8
.text$x:00000864
.text$x:00000864                 mov     edx, [esp+arg_4]
.text$x:00000868                 lea     eax, [edx+0Ch]
.text$x:0000086B                 mov     ecx, [edx-8]
.text$x:0000086E                 xor     ecx, eax
.text$x:00000870                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000875                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:0000087A                 jmp     ___CxxFrameHandler3
.text$x:0000087A __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:0000087A
.text$x:0000087A ; ---------------------------------------------------------------------------
.text$x:0000087F                 align 10h
.text$x:0000087F _text$x         ends
.text$x:0000087F
.text$mn:00000880 ; ===========================================================================
.text$mn:00000880
.text$mn:00000880 ; Segment type: Pure code
.text$mn:00000880 ; Segment permissions: Read/Execute
.text$mn:00000880 _text$mn        segment para public 'CODE' use32
.text$mn:00000880                 assume cs:_text$mn
.text$mn:00000880                 ;org 880h
.text$mn:00000880 ; COMDAT (pick any)
.text$mn:00000880                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000880
.text$mn:00000880 ; =============== S U B R O U T I N E =======================================
.text$mn:00000880
.text$mn:00000880 ; Attributes: bp-based frame
.text$mn:00000880
.text$mn:00000880 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00000880                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00000880 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00000880                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00000880                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00000880
.text$mn:00000880 var_10          = dword ptr -10h
.text$mn:00000880 var_C           = dword ptr -0Ch
.text$mn:00000880 var_4           = dword ptr -4
.text$mn:00000880
.text$mn:00000880                 push    ebp
.text$mn:00000881                 mov     ebp, esp
.text$mn:00000883                 push    0FFFFFFFFh
.text$mn:00000885                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:0000088A                 mov     eax, large fs:0
.text$mn:00000890                 push    eax
.text$mn:00000891                 push    ecx
.text$mn:00000892                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000897                 xor     eax, ebp
.text$mn:00000899                 push    eax
.text$mn:0000089A                 lea     eax, [ebp+var_C]
.text$mn:0000089D                 mov     large fs:0, eax
.text$mn:000008A3                 mov     [ebp+var_10], ecx
.text$mn:000008A6                 mov     [ebp+var_4], 0
.text$mn:000008AD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000008B4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000008B7                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000008BC                 mov     ecx, [ebp+var_C]
.text$mn:000008BF                 mov     large fs:0, ecx
.text$mn:000008C6                 pop     ecx
.text$mn:000008C7                 mov     esp, ebp
.text$mn:000008C9                 pop     ebp
.text$mn:000008CA                 retn
.text$mn:000008CA ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:000008CA
.text$mn:000008CA ; ---------------------------------------------------------------------------
.text$mn:000008CB                 align 4
.text$mn:000008CB _text$mn        ends
.text$mn:000008CB
.text$x:000008CC ; ===========================================================================
.text$x:000008CC
.text$x:000008CC ; Segment type: Pure code
.text$x:000008CC ; Segment permissions: Read/Execute
.text$x:000008CC _text$x         segment para public 'CODE' use32
.text$x:000008CC                 assume cs:_text$x
.text$x:000008CC                 ;org 8CCh
.text$x:000008CC ; COMDAT (pick associative to section at 880)
.text$x:000008CC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000008CC
.text$x:000008CC ; =============== S U B R O U T I N E =======================================
.text$x:000008CC
.text$x:000008CC
.text$x:000008CC __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:000008CC                                         ; DATA XREF: .xdata$x:00001BB4o
.text$x:000008CC                 mov     ecx, [ebp-10h]  ; this
.text$x:000008CF                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000008CF __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:000008CF
.text$x:000008D4
.text$x:000008D4 ; =============== S U B R O U T I N E =======================================
.text$x:000008D4
.text$x:000008D4
.text$x:000008D4 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:000008D4                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:000008D4
.text$x:000008D4 arg_4           = dword ptr  8
.text$x:000008D4
.text$x:000008D4                 mov     edx, [esp+arg_4]
.text$x:000008D8                 lea     eax, [edx+0Ch]
.text$x:000008DB                 mov     ecx, [edx-8]
.text$x:000008DE                 xor     ecx, eax
.text$x:000008E0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000008E5                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:000008EA                 jmp     ___CxxFrameHandler3
.text$x:000008EA __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:000008EA
.text$x:000008EA ; ---------------------------------------------------------------------------
.text$x:000008EF                 align 10h
.text$x:000008EF _text$x         ends
.text$x:000008EF
.text$mn:000008F0 ; ===========================================================================
.text$mn:000008F0
.text$mn:000008F0 ; Segment type: Pure code
.text$mn:000008F0 ; Segment permissions: Read/Execute
.text$mn:000008F0 _text$mn        segment para public 'CODE' use32
.text$mn:000008F0                 assume cs:_text$mn
.text$mn:000008F0                 ;org 8F0h
.text$mn:000008F0 ; COMDAT (pick any)
.text$mn:000008F0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000008F0
.text$mn:000008F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000008F0
.text$mn:000008F0 ; Attributes: bp-based frame
.text$mn:000008F0
.text$mn:000008F0 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:000008F0                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:000008F0 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:000008F0                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:000008F0                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:000008F0
.text$mn:000008F0 var_10          = dword ptr -10h
.text$mn:000008F0 var_C           = dword ptr -0Ch
.text$mn:000008F0 var_4           = dword ptr -4
.text$mn:000008F0
.text$mn:000008F0                 push    ebp
.text$mn:000008F1                 mov     ebp, esp
.text$mn:000008F3                 push    0FFFFFFFFh
.text$mn:000008F5                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:000008FA                 mov     eax, large fs:0
.text$mn:00000900                 push    eax
.text$mn:00000901                 push    ecx
.text$mn:00000902                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000907                 xor     eax, ebp
.text$mn:00000909                 push    eax
.text$mn:0000090A                 lea     eax, [ebp+var_C]
.text$mn:0000090D                 mov     large fs:0, eax
.text$mn:00000913                 mov     [ebp+var_10], ecx
.text$mn:00000916                 mov     [ebp+var_4], 0
.text$mn:0000091D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000924                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000927                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:0000092C                 mov     ecx, [ebp+var_C]
.text$mn:0000092F                 mov     large fs:0, ecx
.text$mn:00000936                 pop     ecx
.text$mn:00000937                 mov     esp, ebp
.text$mn:00000939                 pop     ebp
.text$mn:0000093A                 retn
.text$mn:0000093A ??1_System_error_category@std@@UAE@XZ endp
.text$mn:0000093A
.text$mn:0000093A ; ---------------------------------------------------------------------------
.text$mn:0000093B                 align 4
.text$mn:0000093B _text$mn        ends
.text$mn:0000093B
.text$x:0000093C ; ===========================================================================
.text$x:0000093C
.text$x:0000093C ; Segment type: Pure code
.text$x:0000093C ; Segment permissions: Read/Execute
.text$x:0000093C _text$x         segment para public 'CODE' use32
.text$x:0000093C                 assume cs:_text$x
.text$x:0000093C                 ;org 93Ch
.text$x:0000093C ; COMDAT (pick associative to section at 8F0)
.text$x:0000093C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:0000093C
.text$x:0000093C ; =============== S U B R O U T I N E =======================================
.text$x:0000093C
.text$x:0000093C
.text$x:0000093C __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:0000093C                                         ; DATA XREF: .xdata$x:00001C38o
.text$x:0000093C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000093F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000093F __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:0000093F
.text$x:00000944
.text$x:00000944 ; =============== S U B R O U T I N E =======================================
.text$x:00000944
.text$x:00000944
.text$x:00000944 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00000944                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00000944
.text$x:00000944 arg_4           = dword ptr  8
.text$x:00000944
.text$x:00000944                 mov     edx, [esp+arg_4]
.text$x:00000948                 lea     eax, [edx+0Ch]
.text$x:0000094B                 mov     ecx, [edx-8]
.text$x:0000094E                 xor     ecx, eax
.text$x:00000950                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000955                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:0000095A                 jmp     ___CxxFrameHandler3
.text$x:0000095A __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:0000095A
.text$x:0000095A ; ---------------------------------------------------------------------------
.text$x:0000095F                 align 10h
.text$x:0000095F _text$x         ends
.text$x:0000095F
.text$mn:00000960 ; ===========================================================================
.text$mn:00000960
.text$mn:00000960 ; Segment type: Pure code
.text$mn:00000960 ; Segment permissions: Read/Execute
.text$mn:00000960 _text$mn        segment para public 'CODE' use32
.text$mn:00000960                 assume cs:_text$mn
.text$mn:00000960                 ;org 960h
.text$mn:00000960 ; COMDAT (pick any)
.text$mn:00000960                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000960
.text$mn:00000960 ; =============== S U B R O U T I N E =======================================
.text$mn:00000960
.text$mn:00000960 ; Attributes: bp-based frame
.text$mn:00000960
.text$mn:00000960 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00000960                 public ??1error_category@std@@UAE@XZ
.text$mn:00000960 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00000960                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00000960
.text$mn:00000960 var_4           = dword ptr -4
.text$mn:00000960
.text$mn:00000960                 push    ebp
.text$mn:00000961                 mov     ebp, esp
.text$mn:00000963                 push    ecx
.text$mn:00000964                 mov     [ebp+var_4], ecx
.text$mn:00000967                 mov     eax, [ebp+var_4]
.text$mn:0000096A                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00000970                 mov     esp, ebp
.text$mn:00000972                 pop     ebp
.text$mn:00000973                 retn
.text$mn:00000973 ??1error_category@std@@UAE@XZ endp
.text$mn:00000973
.text$mn:00000973 _text$mn        ends
.text$mn:00000973
.text$mn:00000974 ; ===========================================================================
.text$mn:00000974
.text$mn:00000974 ; Segment type: Pure code
.text$mn:00000974 ; Segment permissions: Read/Execute
.text$mn:00000974 _text$mn        segment para public 'CODE' use32
.text$mn:00000974                 assume cs:_text$mn
.text$mn:00000974                 ;org 974h
.text$mn:00000974 ; COMDAT (pick any)
.text$mn:00000974                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000974
.text$mn:00000974 ; =============== S U B R O U T I N E =======================================
.text$mn:00000974
.text$mn:00000974 ; Attributes: bp-based frame
.text$mn:00000974
.text$mn:00000974 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00000974                 public ??2@YAPAXIPAX@Z
.text$mn:00000974 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00000974                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:00000974
.text$mn:00000974 arg_4           = dword ptr  0Ch
.text$mn:00000974
.text$mn:00000974                 push    ebp
.text$mn:00000975                 mov     ebp, esp
.text$mn:00000977                 mov     eax, [ebp+arg_4]
.text$mn:0000097A                 pop     ebp
.text$mn:0000097B                 retn
.text$mn:0000097B ??2@YAPAXIPAX@Z endp
.text$mn:0000097B
.text$mn:0000097B _text$mn        ends
.text$mn:0000097B
.text$mn:0000097C ; ===========================================================================
.text$mn:0000097C
.text$mn:0000097C ; Segment type: Pure code
.text$mn:0000097C ; Segment permissions: Read/Execute
.text$mn:0000097C _text$mn        segment para public 'CODE' use32
.text$mn:0000097C                 assume cs:_text$mn
.text$mn:0000097C                 ;org 97Ch
.text$mn:0000097C ; COMDAT (pick any)
.text$mn:0000097C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000097C
.text$mn:0000097C ; =============== S U B R O U T I N E =======================================
.text$mn:0000097C
.text$mn:0000097C ; Attributes: bp-based frame
.text$mn:0000097C
.text$mn:0000097C ; void __cdecl operator delete(void *)
.text$mn:0000097C                 public ??3@YAXPAX0@Z
.text$mn:0000097C ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:0000097C                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:0000097C                 push    ebp
.text$mn:0000097D                 mov     ebp, esp
.text$mn:0000097F                 pop     ebp
.text$mn:00000980                 retn
.text$mn:00000980 ??3@YAXPAX0@Z   endp
.text$mn:00000980
.text$mn:00000980 ; ---------------------------------------------------------------------------
.text$mn:00000981                 align 4
.text$mn:00000981 _text$mn        ends
.text$mn:00000981
.text$mn:00000984 ; ===========================================================================
.text$mn:00000984
.text$mn:00000984 ; Segment type: Pure code
.text$mn:00000984 ; Segment permissions: Read/Execute
.text$mn:00000984 _text$mn        segment para public 'CODE' use32
.text$mn:00000984                 assume cs:_text$mn
.text$mn:00000984                 ;org 984h
.text$mn:00000984 ; COMDAT (pick any)
.text$mn:00000984                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000984
.text$mn:00000984 ; =============== S U B R O U T I N E =======================================
.text$mn:00000984
.text$mn:00000984 ; Attributes: bp-based frame
.text$mn:00000984
.text$mn:00000984 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00000984                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00000984 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00000984                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00000984                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00000984
.text$mn:00000984 var_8           = dword ptr -8
.text$mn:00000984 var_4           = dword ptr -4
.text$mn:00000984 arg_0           = dword ptr  8
.text$mn:00000984
.text$mn:00000984                 push    ebp
.text$mn:00000985                 mov     ebp, esp
.text$mn:00000987                 sub     esp, 8
.text$mn:0000098A                 mov     [ebp+var_8], ecx
.text$mn:0000098D                 mov     eax, [ebp+var_8]
.text$mn:00000990                 cmp     eax, [ebp+arg_0]
.text$mn:00000993                 jnz     short loc_99E
.text$mn:00000995                 mov     [ebp+var_4], 1
.text$mn:0000099C                 jmp     short loc_9A5
.text$mn:0000099E ; ---------------------------------------------------------------------------
.text$mn:0000099E
.text$mn:0000099E loc_99E:                                ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:0000099E                 mov     [ebp+var_4], 0
.text$mn:000009A5
.text$mn:000009A5 loc_9A5:                                ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:000009A5                 mov     al, byte ptr [ebp+var_4]
.text$mn:000009A8                 mov     esp, ebp
.text$mn:000009AA                 pop     ebp
.text$mn:000009AB                 retn    4
.text$mn:000009AB ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:000009AB
.text$mn:000009AB ; ---------------------------------------------------------------------------
.text$mn:000009AE                 align 10h
.text$mn:000009AE _text$mn        ends
.text$mn:000009AE
.text$mn:000009B0 ; ===========================================================================
.text$mn:000009B0
.text$mn:000009B0 ; Segment type: Pure code
.text$mn:000009B0 ; Segment permissions: Read/Execute
.text$mn:000009B0 _text$mn        segment para public 'CODE' use32
.text$mn:000009B0                 assume cs:_text$mn
.text$mn:000009B0                 ;org 9B0h
.text$mn:000009B0 ; COMDAT (pick any)
.text$mn:000009B0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000009B0
.text$mn:000009B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000009B0
.text$mn:000009B0 ; Attributes: bp-based frame
.text$mn:000009B0
.text$mn:000009B0 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:000009B0                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:000009B0 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:000009B0                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:000009B0
.text$mn:000009B0 var_8           = dword ptr -8
.text$mn:000009B0 var_4           = dword ptr -4
.text$mn:000009B0 arg_0           = dword ptr  8
.text$mn:000009B0
.text$mn:000009B0                 push    ebp
.text$mn:000009B1                 mov     ebp, esp
.text$mn:000009B3                 sub     esp, 8
.text$mn:000009B6                 push    esi
.text$mn:000009B7                 mov     [ebp+var_4], ecx
.text$mn:000009BA                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000009BD                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:000009C2                 push    eax
.text$mn:000009C3                 mov     ecx, [ebp+var_4] ; this
.text$mn:000009C6                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:000009CB                 mov     ecx, eax
.text$mn:000009CD                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:000009D2                 movzx   eax, al
.text$mn:000009D5                 test    eax, eax
.text$mn:000009D7                 jz      short loc_9F8
.text$mn:000009D9                 mov     ecx, [ebp+var_4] ; this
.text$mn:000009DC                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000009E1                 mov     esi, eax
.text$mn:000009E3                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000009E6                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000009EB                 cmp     esi, eax
.text$mn:000009ED                 jnz     short loc_9F8
.text$mn:000009EF                 mov     [ebp+var_8], 1
.text$mn:000009F6                 jmp     short loc_9FF
.text$mn:000009F8 ; ---------------------------------------------------------------------------
.text$mn:000009F8
.text$mn:000009F8 loc_9F8:                                ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:000009F8                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:000009F8                 mov     [ebp+var_8], 0
.text$mn:000009FF
.text$mn:000009FF loc_9FF:                                ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:000009FF                 mov     al, byte ptr [ebp+var_8]
.text$mn:00000A02                 pop     esi
.text$mn:00000A03                 mov     esp, ebp
.text$mn:00000A05                 pop     ebp
.text$mn:00000A06                 retn    4
.text$mn:00000A06 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00000A06
.text$mn:00000A06 ; ---------------------------------------------------------------------------
.text$mn:00000A09                 align 4
.text$mn:00000A09 _text$mn        ends
.text$mn:00000A09
.text$mn:00000A0C ; ===========================================================================
.text$mn:00000A0C
.text$mn:00000A0C ; Segment type: Pure code
.text$mn:00000A0C ; Segment permissions: Read/Execute
.text$mn:00000A0C _text$mn        segment para public 'CODE' use32
.text$mn:00000A0C                 assume cs:_text$mn
.text$mn:00000A0C                 ;org 0A0Ch
.text$mn:00000A0C ; COMDAT (pick any)
.text$mn:00000A0C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000A0C
.text$mn:00000A0C ; =============== S U B R O U T I N E =======================================
.text$mn:00000A0C
.text$mn:00000A0C ; Attributes: bp-based frame
.text$mn:00000A0C
.text$mn:00000A0C ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000A0C                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00000A0C ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000A0C
.text$mn:00000A0C var_4           = dword ptr -4
.text$mn:00000A0C arg_0           = dword ptr  8
.text$mn:00000A0C
.text$mn:00000A0C                 push    ebp
.text$mn:00000A0D                 mov     ebp, esp
.text$mn:00000A0F                 push    ecx
.text$mn:00000A10                 mov     [ebp+var_4], ecx
.text$mn:00000A13                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000A16                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000A1B                 mov     eax, [ebp+arg_0]
.text$mn:00000A1E                 and     eax, 1
.text$mn:00000A21                 jz      short loc_A2F
.text$mn:00000A23                 mov     ecx, [ebp+var_4]
.text$mn:00000A26                 push    ecx             ; void *
.text$mn:00000A27                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000A2C                 add     esp, 4
.text$mn:00000A2F
.text$mn:00000A2F loc_A2F:                                ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000A2F                 mov     eax, [ebp+var_4]
.text$mn:00000A32                 mov     esp, ebp
.text$mn:00000A34                 pop     ebp
.text$mn:00000A35                 retn    4
.text$mn:00000A35 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00000A35
.text$mn:00000A35 _text$mn        ends
.text$mn:00000A35
.text$mn:00000A38 ; ===========================================================================
.text$mn:00000A38
.text$mn:00000A38 ; Segment type: Pure code
.text$mn:00000A38 ; Segment permissions: Read/Execute
.text$mn:00000A38 _text$mn        segment para public 'CODE' use32
.text$mn:00000A38                 assume cs:_text$mn
.text$mn:00000A38                 ;org 0A38h
.text$mn:00000A38 ; COMDAT (pick any)
.text$mn:00000A38                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000A38
.text$mn:00000A38 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A38
.text$mn:00000A38 ; Attributes: bp-based frame
.text$mn:00000A38
.text$mn:00000A38 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000A38                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00000A38 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000A38
.text$mn:00000A38 var_4           = dword ptr -4
.text$mn:00000A38 arg_0           = dword ptr  8
.text$mn:00000A38
.text$mn:00000A38                 push    ebp
.text$mn:00000A39                 mov     ebp, esp
.text$mn:00000A3B                 push    ecx
.text$mn:00000A3C                 mov     [ebp+var_4], ecx
.text$mn:00000A3F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000A42                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00000A47                 mov     eax, [ebp+arg_0]
.text$mn:00000A4A                 and     eax, 1
.text$mn:00000A4D                 jz      short loc_A5B
.text$mn:00000A4F                 mov     ecx, [ebp+var_4]
.text$mn:00000A52                 push    ecx             ; void *
.text$mn:00000A53                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000A58                 add     esp, 4
.text$mn:00000A5B
.text$mn:00000A5B loc_A5B:                                ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000A5B                 mov     eax, [ebp+var_4]
.text$mn:00000A5E                 mov     esp, ebp
.text$mn:00000A60                 pop     ebp
.text$mn:00000A61                 retn    4
.text$mn:00000A61 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00000A61
.text$mn:00000A61 _text$mn        ends
.text$mn:00000A61
.text$mn:00000A64 ; ===========================================================================
.text$mn:00000A64
.text$mn:00000A64 ; Segment type: Pure code
.text$mn:00000A64 ; Segment permissions: Read/Execute
.text$mn:00000A64 _text$mn        segment para public 'CODE' use32
.text$mn:00000A64                 assume cs:_text$mn
.text$mn:00000A64                 ;org 0A64h
.text$mn:00000A64 ; COMDAT (pick any)
.text$mn:00000A64                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000A64
.text$mn:00000A64 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A64
.text$mn:00000A64 ; Attributes: bp-based frame
.text$mn:00000A64
.text$mn:00000A64 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000A64                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00000A64 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000A64
.text$mn:00000A64 var_4           = dword ptr -4
.text$mn:00000A64 arg_0           = dword ptr  8
.text$mn:00000A64
.text$mn:00000A64                 push    ebp
.text$mn:00000A65                 mov     ebp, esp
.text$mn:00000A67                 push    ecx
.text$mn:00000A68                 mov     [ebp+var_4], ecx
.text$mn:00000A6B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000A6E                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00000A73                 mov     eax, [ebp+arg_0]
.text$mn:00000A76                 and     eax, 1
.text$mn:00000A79                 jz      short loc_A87
.text$mn:00000A7B                 mov     ecx, [ebp+var_4]
.text$mn:00000A7E                 push    ecx             ; void *
.text$mn:00000A7F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000A84                 add     esp, 4
.text$mn:00000A87
.text$mn:00000A87 loc_A87:                                ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000A87                 mov     eax, [ebp+var_4]
.text$mn:00000A8A                 mov     esp, ebp
.text$mn:00000A8C                 pop     ebp
.text$mn:00000A8D                 retn    4
.text$mn:00000A8D ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00000A8D
.text$mn:00000A8D _text$mn        ends
.text$mn:00000A8D
.text$mn:00000A90 ; ===========================================================================
.text$mn:00000A90
.text$mn:00000A90 ; Segment type: Pure code
.text$mn:00000A90 ; Segment permissions: Read/Execute
.text$mn:00000A90 _text$mn        segment para public 'CODE' use32
.text$mn:00000A90                 assume cs:_text$mn
.text$mn:00000A90                 ;org 0A90h
.text$mn:00000A90 ; COMDAT (pick any)
.text$mn:00000A90                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000A90
.text$mn:00000A90 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A90
.text$mn:00000A90 ; Attributes: bp-based frame
.text$mn:00000A90
.text$mn:00000A90 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000A90                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00000A90 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00000A90
.text$mn:00000A90 var_4           = dword ptr -4
.text$mn:00000A90 arg_0           = dword ptr  8
.text$mn:00000A90
.text$mn:00000A90                 push    ebp
.text$mn:00000A91                 mov     ebp, esp
.text$mn:00000A93                 push    ecx
.text$mn:00000A94                 mov     [ebp+var_4], ecx
.text$mn:00000A97                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000A9A                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00000A9F                 mov     eax, [ebp+arg_0]
.text$mn:00000AA2                 and     eax, 1
.text$mn:00000AA5                 jz      short loc_AB3
.text$mn:00000AA7                 mov     ecx, [ebp+var_4]
.text$mn:00000AAA                 push    ecx             ; void *
.text$mn:00000AAB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000AB0                 add     esp, 4
.text$mn:00000AB3
.text$mn:00000AB3 loc_AB3:                                ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000AB3                 mov     eax, [ebp+var_4]
.text$mn:00000AB6                 mov     esp, ebp
.text$mn:00000AB8                 pop     ebp
.text$mn:00000AB9                 retn    4
.text$mn:00000AB9 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00000AB9
.text$mn:00000AB9 _text$mn        ends
.text$mn:00000AB9
.text$di:00000ABC ; ===========================================================================
.text$di:00000ABC
.text$di:00000ABC ; Segment type: Pure code
.text$di:00000ABC ; Segment permissions: Read/Execute
.text$di:00000ABC _text$di        segment para public 'CODE' use32
.text$di:00000ABC                 assume cs:_text$di
.text$di:00000ABC                 ;org 0ABCh
.text$di:00000ABC ; COMDAT (pick any)
.text$di:00000ABC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000ABC
.text$di:00000ABC ; =============== S U B R O U T I N E =======================================
.text$di:00000ABC
.text$di:00000ABC ; Attributes: bp-based frame
.text$di:00000ABC
.text$di:00000ABC ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00000ABC ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00000ABC                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00000ABC                 push    ebp
.text$di:00000ABD                 mov     ebp, esp
.text$di:00000ABF                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00000AC4                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00000AC9                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000ACE                 call    _atexit
.text$di:00000AD3                 add     esp, 4
.text$di:00000AD6                 pop     ebp
.text$di:00000AD7                 retn
.text$di:00000AD7 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00000AD7
.text$di:00000AD7 _text$di        ends
.text$di:00000AD7
.text$di:00000AD8 ; ===========================================================================
.text$di:00000AD8
.text$di:00000AD8 ; Segment type: Pure code
.text$di:00000AD8 ; Segment permissions: Read/Execute
.text$di:00000AD8 _text$di        segment para public 'CODE' use32
.text$di:00000AD8                 assume cs:_text$di
.text$di:00000AD8                 ;org 0AD8h
.text$di:00000AD8 ; COMDAT (pick any)
.text$di:00000AD8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000AD8
.text$di:00000AD8 ; =============== S U B R O U T I N E =======================================
.text$di:00000AD8
.text$di:00000AD8 ; Attributes: bp-based frame
.text$di:00000AD8
.text$di:00000AD8 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00000AD8 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00000AD8                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00000AD8                 push    ebp
.text$di:00000AD9                 mov     ebp, esp
.text$di:00000ADB                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00000AE0                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00000AE5                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000AEA                 call    _atexit
.text$di:00000AEF                 add     esp, 4
.text$di:00000AF2                 pop     ebp
.text$di:00000AF3                 retn
.text$di:00000AF3 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00000AF3
.text$di:00000AF3 _text$di        ends
.text$di:00000AF3
.text$di:00000AF4 ; ===========================================================================
.text$di:00000AF4
.text$di:00000AF4 ; Segment type: Pure code
.text$di:00000AF4 ; Segment permissions: Read/Execute
.text$di:00000AF4 _text$di        segment para public 'CODE' use32
.text$di:00000AF4                 assume cs:_text$di
.text$di:00000AF4                 ;org 0AF4h
.text$di:00000AF4 ; COMDAT (pick any)
.text$di:00000AF4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000AF4
.text$di:00000AF4 ; =============== S U B R O U T I N E =======================================
.text$di:00000AF4
.text$di:00000AF4 ; Attributes: bp-based frame
.text$di:00000AF4
.text$di:00000AF4 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00000AF4 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00000AF4                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00000AF4                 push    ebp
.text$di:00000AF5                 mov     ebp, esp
.text$di:00000AF7                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00000AFC                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00000B01                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000B06                 call    _atexit
.text$di:00000B0B                 add     esp, 4
.text$di:00000B0E                 pop     ebp
.text$di:00000B0F                 retn
.text$di:00000B0F ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00000B0F
.text$di:00000B0F _text$di        ends
.text$di:00000B0F
.text$di:00000B10 ; ===========================================================================
.text$di:00000B10
.text$di:00000B10 ; Segment type: Pure code
.text$di:00000B10 ; Segment permissions: Read/Execute
.text$di:00000B10 _text$di        segment para public 'CODE' use32
.text$di:00000B10                 assume cs:_text$di
.text$di:00000B10                 ;org 0B10h
.text$di:00000B10 ; COMDAT (pick any)
.text$di:00000B10                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000B10
.text$di:00000B10 ; =============== S U B R O U T I N E =======================================
.text$di:00000B10
.text$di:00000B10 ; Attributes: bp-based frame
.text$di:00000B10
.text$di:00000B10 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00000B10 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000B10                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00000B10                 push    ebp
.text$di:00000B11                 mov     ebp, esp
.text$di:00000B13                 push    0               ; unsigned int
.text$di:00000B15                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00000B1A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000B1F                 pop     ebp
.text$di:00000B20                 retn
.text$di:00000B20 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000B20
.text$di:00000B20 ; ---------------------------------------------------------------------------
.text$di:00000B21                 align 4
.text$di:00000B21 _text$di        ends
.text$di:00000B21
.text$di:00000B24 ; ===========================================================================
.text$di:00000B24
.text$di:00000B24 ; Segment type: Pure code
.text$di:00000B24 ; Segment permissions: Read/Execute
.text$di:00000B24 _text$di        segment para public 'CODE' use32
.text$di:00000B24                 assume cs:_text$di
.text$di:00000B24                 ;org 0B24h
.text$di:00000B24 ; COMDAT (pick any)
.text$di:00000B24                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000B24
.text$di:00000B24 ; =============== S U B R O U T I N E =======================================
.text$di:00000B24
.text$di:00000B24 ; Attributes: bp-based frame
.text$di:00000B24
.text$di:00000B24 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00000B24 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000B24                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00000B24                 push    ebp
.text$di:00000B25                 mov     ebp, esp
.text$di:00000B27                 push    0               ; unsigned int
.text$di:00000B29                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00000B2E                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000B33                 pop     ebp
.text$di:00000B34                 retn
.text$di:00000B34 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000B34
.text$di:00000B34 ; ---------------------------------------------------------------------------
.text$di:00000B35                 align 4
.text$di:00000B35 _text$di        ends
.text$di:00000B35
.text$di:00000B38 ; ===========================================================================
.text$di:00000B38
.text$di:00000B38 ; Segment type: Pure code
.text$di:00000B38 ; Segment permissions: Read/Execute
.text$di:00000B38 _text$di        segment para public 'CODE' use32
.text$di:00000B38                 assume cs:_text$di
.text$di:00000B38                 ;org 0B38h
.text$di:00000B38 ; COMDAT (pick any)
.text$di:00000B38                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000B38
.text$di:00000B38 ; =============== S U B R O U T I N E =======================================
.text$di:00000B38
.text$di:00000B38 ; Attributes: bp-based frame
.text$di:00000B38
.text$di:00000B38 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00000B38 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000B38                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00000B38                 push    ebp
.text$di:00000B39                 mov     ebp, esp
.text$di:00000B3B                 push    0               ; unsigned int
.text$di:00000B3D                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00000B42                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000B47                 pop     ebp
.text$di:00000B48                 retn
.text$di:00000B48 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000B48
.text$di:00000B48 ; ---------------------------------------------------------------------------
.text$di:00000B49                 align 4
.text$di:00000B49 _text$di        ends
.text$di:00000B49
.text$di:00000B4C ; ===========================================================================
.text$di:00000B4C
.text$di:00000B4C ; Segment type: Pure code
.text$di:00000B4C ; Segment permissions: Read/Execute
.text$di:00000B4C _text$di        segment para public 'CODE' use32
.text$di:00000B4C                 assume cs:_text$di
.text$di:00000B4C                 ;org 0B4Ch
.text$di:00000B4C ; COMDAT (pick any)
.text$di:00000B4C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000B4C
.text$di:00000B4C ; =============== S U B R O U T I N E =======================================
.text$di:00000B4C
.text$di:00000B4C ; Attributes: bp-based frame
.text$di:00000B4C
.text$di:00000B4C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00000B4C ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000B4C                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00000B4C                 push    ebp
.text$di:00000B4D                 mov     ebp, esp
.text$di:00000B4F                 push    0               ; unsigned int
.text$di:00000B51                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00000B56                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000B5B                 pop     ebp
.text$di:00000B5C                 retn
.text$di:00000B5C ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000B5C
.text$di:00000B5C ; ---------------------------------------------------------------------------
.text$di:00000B5D                 align 10h
.text$di:00000B5D _text$di        ends
.text$di:00000B5D
.text$di:00000B60 ; ===========================================================================
.text$di:00000B60
.text$di:00000B60 ; Segment type: Pure code
.text$di:00000B60 ; Segment permissions: Read/Execute
.text$di:00000B60 _text$di        segment para public 'CODE' use32
.text$di:00000B60                 assume cs:_text$di
.text$di:00000B60                 ;org 0B60h
.text$di:00000B60 ; COMDAT (pick any)
.text$di:00000B60                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000B60
.text$di:00000B60 ; =============== S U B R O U T I N E =======================================
.text$di:00000B60
.text$di:00000B60 ; Attributes: bp-based frame
.text$di:00000B60
.text$di:00000B60 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00000B60 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00000B60
.text$di:00000B60 var_1           = byte ptr -1
.text$di:00000B60
.text$di:00000B60                 push    ebp
.text$di:00000B61                 mov     ebp, esp
.text$di:00000B63                 push    ecx
.text$di:00000B64                 xor     eax, eax
.text$di:00000B66                 mov     [ebp+var_1], al
.text$di:00000B69                 mov     esp, ebp
.text$di:00000B6B                 pop     ebp
.text$di:00000B6C                 retn
.text$di:00000B6C ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00000B6C
.text$di:00000B6C ; ---------------------------------------------------------------------------
.text$di:00000B6D                 align 10h
.text$di:00000B6D _text$di        ends
.text$di:00000B6D
.text$di:00000B70 ; ===========================================================================
.text$di:00000B70
.text$di:00000B70 ; Segment type: Pure code
.text$di:00000B70 ; Segment permissions: Read/Execute
.text$di:00000B70 _text$di        segment para public 'CODE' use32
.text$di:00000B70                 assume cs:_text$di
.text$di:00000B70                 ;org 0B70h
.text$di:00000B70 ; COMDAT (pick any)
.text$di:00000B70                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000B70
.text$di:00000B70 ; =============== S U B R O U T I N E =======================================
.text$di:00000B70
.text$di:00000B70 ; Attributes: bp-based frame
.text$di:00000B70
.text$di:00000B70 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00000B70 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00000B70                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00000B70
.text$di:00000B70 var_1           = byte ptr -1
.text$di:00000B70
.text$di:00000B70                 push    ebp
.text$di:00000B71                 mov     ebp, esp
.text$di:00000B73                 push    ecx
.text$di:00000B74                 xor     eax, eax
.text$di:00000B76                 mov     [ebp+var_1], al
.text$di:00000B79                 mov     esp, ebp
.text$di:00000B7B                 pop     ebp
.text$di:00000B7C                 retn
.text$di:00000B7C ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00000B7C
.text$di:00000B7C ; ---------------------------------------------------------------------------
.text$di:00000B7D                 align 10h
.text$di:00000B7D _text$di        ends
.text$di:00000B7D
.text$yd:00000B80 ; ===========================================================================
.text$yd:00000B80
.text$yd:00000B80 ; Segment type: Pure code
.text$yd:00000B80 ; Segment permissions: Read/Execute
.text$yd:00000B80 _text$yd        segment para public 'CODE' use32
.text$yd:00000B80                 assume cs:_text$yd
.text$yd:00000B80                 ;org 0B80h
.text$yd:00000B80 ; COMDAT (pick any)
.text$yd:00000B80                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$yd:00000B80
.text$yd:00000B80 ; =============== S U B R O U T I N E =======================================
.text$yd:00000B80
.text$yd:00000B80 ; Attributes: bp-based frame
.text$yd:00000B80
.text$yd:00000B80 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00000B80 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00000B80                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00000B80                 push    ebp
.text$yd:00000B81                 mov     ebp, esp
.text$yd:00000B83                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00000B88                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00000B8D                 pop     ebp
.text$yd:00000B8E                 retn
.text$yd:00000B8E ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00000B8E
.text$yd:00000B8E ; ---------------------------------------------------------------------------
.text$yd:00000B8F                 align 10h
.text$yd:00000B8F _text$yd        ends
.text$yd:00000B8F
.text$yd:00000B90 ; ===========================================================================
.text$yd:00000B90
.text$yd:00000B90 ; Segment type: Pure code
.text$yd:00000B90 ; Segment permissions: Read/Execute
.text$yd:00000B90 _text$yd        segment para public 'CODE' use32
.text$yd:00000B90                 assume cs:_text$yd
.text$yd:00000B90                 ;org 0B90h
.text$yd:00000B90 ; COMDAT (pick any)
.text$yd:00000B90                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$yd:00000B90
.text$yd:00000B90 ; =============== S U B R O U T I N E =======================================
.text$yd:00000B90
.text$yd:00000B90 ; Attributes: bp-based frame
.text$yd:00000B90
.text$yd:00000B90 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00000B90 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00000B90                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00000B90                 push    ebp
.text$yd:00000B91                 mov     ebp, esp
.text$yd:00000B93                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00000B98                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00000B9D                 pop     ebp
.text$yd:00000B9E                 retn
.text$yd:00000B9E ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00000B9E
.text$yd:00000B9E ; ---------------------------------------------------------------------------
.text$yd:00000B9F                 align 10h
.text$yd:00000B9F _text$yd        ends
.text$yd:00000B9F
.text$yd:00000BA0 ; ===========================================================================
.text$yd:00000BA0
.text$yd:00000BA0 ; Segment type: Pure code
.text$yd:00000BA0 ; Segment permissions: Read/Execute
.text$yd:00000BA0 _text$yd        segment para public 'CODE' use32
.text$yd:00000BA0                 assume cs:_text$yd
.text$yd:00000BA0                 ;org 0BA0h
.text$yd:00000BA0 ; COMDAT (pick any)
.text$yd:00000BA0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$yd:00000BA0
.text$yd:00000BA0 ; =============== S U B R O U T I N E =======================================
.text$yd:00000BA0
.text$yd:00000BA0 ; Attributes: bp-based frame
.text$yd:00000BA0
.text$yd:00000BA0 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00000BA0 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00000BA0                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00000BA0                 push    ebp
.text$yd:00000BA1                 mov     ebp, esp
.text$yd:00000BA3                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00000BA8                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00000BAD                 pop     ebp
.text$yd:00000BAE                 retn
.text$yd:00000BAE ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00000BAE
.text$yd:00000BAE ; ---------------------------------------------------------------------------
.text$yd:00000BAF                 align 10h
.text$yd:00000BAF _text$yd        ends
.text$yd:00000BAF
.text$mn:00000BB0 ; ===========================================================================
.text$mn:00000BB0
.text$mn:00000BB0 ; Segment type: Pure code
.text$mn:00000BB0 ; Segment permissions: Read/Execute
.text$mn:00000BB0 _text$mn        segment para public 'CODE' use32
.text$mn:00000BB0                 assume cs:_text$mn
.text$mn:00000BB0                 ;org 0BB0h
.text$mn:00000BB0 ; COMDAT (pick any)
.text$mn:00000BB0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000BB0
.text$mn:00000BB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000BB0
.text$mn:00000BB0 ; Attributes: bp-based frame
.text$mn:00000BB0
.text$mn:00000BB0 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00000BB0                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00000BB0 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00000BB0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00000BB0
.text$mn:00000BB0 var_10          = byte ptr -10h
.text$mn:00000BB0 var_8           = dword ptr -8
.text$mn:00000BB0 var_1           = byte ptr -1
.text$mn:00000BB0
.text$mn:00000BB0                 push    ebp
.text$mn:00000BB1                 mov     ebp, esp
.text$mn:00000BB3                 sub     esp, 10h
.text$mn:00000BB6                 mov     [ebp+var_8], ecx
.text$mn:00000BB9                 lea     ecx, [ebp+var_1]
.text$mn:00000BBC                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00000BC1                 push    1
.text$mn:00000BC3                 lea     ecx, [ebp+var_1]
.text$mn:00000BC6                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00000BCB                 mov     ecx, [ebp+var_8]
.text$mn:00000BCE                 mov     [ecx], eax
.text$mn:00000BD0                 lea     ecx, [ebp+var_10] ; this
.text$mn:00000BD3                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00000BD8                 push    eax             ; int
.text$mn:00000BD9                 mov     edx, [ebp+var_8]
.text$mn:00000BDC                 mov     eax, [edx]
.text$mn:00000BDE                 push    eax             ; void *
.text$mn:00000BDF                 lea     ecx, [ebp+var_1]
.text$mn:00000BE2                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00000BE7                 mov     ecx, [ebp+var_8]
.text$mn:00000BEA                 mov     edx, [ecx]
.text$mn:00000BEC                 mov     eax, [ebp+var_8]
.text$mn:00000BEF                 mov     [edx], eax
.text$mn:00000BF1                 mov     esp, ebp
.text$mn:00000BF3                 pop     ebp
.text$mn:00000BF4                 retn
.text$mn:00000BF4 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00000BF4
.text$mn:00000BF4 ; ---------------------------------------------------------------------------
.text$mn:00000BF5                 align 4
.text$mn:00000BF5 _text$mn        ends
.text$mn:00000BF5
.text$mn:00000BF8 ; ===========================================================================
.text$mn:00000BF8
.text$mn:00000BF8 ; Segment type: Pure code
.text$mn:00000BF8 ; Segment permissions: Read/Execute
.text$mn:00000BF8 _text$mn        segment para public 'CODE' use32
.text$mn:00000BF8                 assume cs:_text$mn
.text$mn:00000BF8                 ;org 0BF8h
.text$mn:00000BF8 ; COMDAT (pick any)
.text$mn:00000BF8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000BF8
.text$mn:00000BF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000BF8
.text$mn:00000BF8 ; Attributes: bp-based frame
.text$mn:00000BF8
.text$mn:00000BF8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00000BF8                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00000BF8 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00000BF8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00000BF8
.text$mn:00000BF8 var_20          = dword ptr -20h
.text$mn:00000BF8 var_1C          = dword ptr -1Ch
.text$mn:00000BF8 var_18          = dword ptr -18h
.text$mn:00000BF8 var_11          = byte ptr -11h
.text$mn:00000BF8 var_10          = dword ptr -10h
.text$mn:00000BF8 var_C           = byte ptr -0Ch
.text$mn:00000BF8 var_4           = dword ptr -4
.text$mn:00000BF8 arg_0           = dword ptr  8
.text$mn:00000BF8
.text$mn:00000BF8 ; FUNCTION CHUNK AT .text$mn:00000D1A SIZE 00000009 BYTES
.text$mn:00000BF8
.text$mn:00000BF8                 push    ebp
.text$mn:00000BF9                 mov     ebp, esp
.text$mn:00000BFB                 push    0FFFFFFFFh
.text$mn:00000BFD                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00000C02                 mov     eax, large fs:0
.text$mn:00000C08                 push    eax
.text$mn:00000C09                 push    ecx
.text$mn:00000C0A                 sub     esp, 10h
.text$mn:00000C0D                 push    ebx
.text$mn:00000C0E                 push    esi
.text$mn:00000C0F                 push    edi
.text$mn:00000C10                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000C15                 xor     eax, ebp
.text$mn:00000C17                 push    eax
.text$mn:00000C18                 lea     eax, [ebp+var_C]
.text$mn:00000C1B                 mov     large fs:0, eax
.text$mn:00000C21                 mov     [ebp+var_10], esp
.text$mn:00000C24                 mov     [ebp+var_18], ecx
.text$mn:00000C27                 mov     eax, [ebp+arg_0]
.text$mn:00000C2A                 or      eax, 0Fh
.text$mn:00000C2D                 mov     [ebp+var_1C], eax
.text$mn:00000C30                 mov     ecx, [ebp+var_18]
.text$mn:00000C33                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00000C38                 cmp     eax, [ebp+var_1C]
.text$mn:00000C3B                 jnb     short loc_C45
.text$mn:00000C3D                 mov     ecx, [ebp+arg_0]
.text$mn:00000C40                 mov     [ebp+var_1C], ecx
.text$mn:00000C43                 jmp     short loc_C97
.text$mn:00000C45 ; ---------------------------------------------------------------------------
.text$mn:00000C45
.text$mn:00000C45 loc_C45:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00000C45                 mov     edx, [ebp+var_18]
.text$mn:00000C48                 mov     ecx, [edx+18h]
.text$mn:00000C4B                 shr     ecx, 1
.text$mn:00000C4D                 mov     eax, [ebp+var_1C]
.text$mn:00000C50                 xor     edx, edx
.text$mn:00000C52                 mov     esi, 3
.text$mn:00000C57                 div     esi
.text$mn:00000C59                 cmp     ecx, eax
.text$mn:00000C5B                 ja      short loc_C5F
.text$mn:00000C5D                 jmp     short loc_C97
.text$mn:00000C5F ; ---------------------------------------------------------------------------
.text$mn:00000C5F
.text$mn:00000C5F loc_C5F:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00000C5F                 mov     ecx, [ebp+var_18]
.text$mn:00000C62                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00000C67                 mov     edx, [ebp+var_18]
.text$mn:00000C6A                 mov     ecx, [edx+18h]
.text$mn:00000C6D                 shr     ecx, 1
.text$mn:00000C6F                 sub     eax, ecx
.text$mn:00000C71                 mov     edx, [ebp+var_18]
.text$mn:00000C74                 cmp     [edx+18h], eax
.text$mn:00000C77                 ja      short loc_C8C
.text$mn:00000C79                 mov     eax, [ebp+var_18]
.text$mn:00000C7C                 mov     ecx, [eax+18h]
.text$mn:00000C7F                 shr     ecx, 1
.text$mn:00000C81                 mov     edx, [ebp+var_18]
.text$mn:00000C84                 add     ecx, [edx+18h]
.text$mn:00000C87                 mov     [ebp+var_1C], ecx
.text$mn:00000C8A                 jmp     short loc_C97
.text$mn:00000C8C ; ---------------------------------------------------------------------------
.text$mn:00000C8C
.text$mn:00000C8C loc_C8C:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00000C8C                 mov     ecx, [ebp+var_18]
.text$mn:00000C8F                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00000C94                 mov     [ebp+var_1C], eax
.text$mn:00000C97
.text$mn:00000C97 loc_C97:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00000C97                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00000C97                 mov     [ebp+var_4], 0
.text$mn:00000C9E                 mov     eax, [ebp+var_1C]
.text$mn:00000CA1                 add     eax, 1
.text$mn:00000CA4                 push    eax
.text$mn:00000CA5                 lea     ecx, [ebp+var_11]
.text$mn:00000CA8                 push    ecx
.text$mn:00000CA9                 mov     ecx, [ebp+var_18]
.text$mn:00000CAC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00000CB1                 mov     ecx, eax
.text$mn:00000CB3                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00000CB8                 mov     [ebp+var_20], eax
.text$mn:00000CBB                 jmp     short loc_D1A
.text$mn:00000CBB ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00000CBB
.text$mn:00000CBD
.text$mn:00000CBD ; =============== S U B R O U T I N E =======================================
.text$mn:00000CBD
.text$mn:00000CBD
.text$mn:00000CBD __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00000CBD                                         ; DATA XREF: .xdata$x:00001A54o
.text$mn:00000CBD
.text$mn:00000CBD ; FUNCTION CHUNK AT .text$mn:00000D04 SIZE 00000009 BYTES
.text$mn:00000CBD ; FUNCTION CHUNK AT .text$mn:00000D14 SIZE 00000006 BYTES
.text$mn:00000CBD
.text$mn:00000CBD                 mov     [ebp-10h], esp
.text$mn:00000CC0                 mov     edx, [ebp+8]
.text$mn:00000CC3                 mov     [ebp-1Ch], edx
.text$mn:00000CC6                 mov     byte ptr [ebp-4], 2
.text$mn:00000CCA                 mov     eax, [ebp-1Ch]
.text$mn:00000CCD                 add     eax, 1
.text$mn:00000CD0                 push    eax
.text$mn:00000CD1                 lea     ecx, [ebp-12h]
.text$mn:00000CD4                 push    ecx
.text$mn:00000CD5                 mov     ecx, [ebp-18h]
.text$mn:00000CD8                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00000CDD                 mov     ecx, eax
.text$mn:00000CDF                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00000CE4                 mov     [ebp-20h], eax
.text$mn:00000CE7                 jmp     short loc_D04
.text$mn:00000CE7 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00000CE7
.text$mn:00000CE9
.text$mn:00000CE9 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CE9
.text$mn:00000CE9 ; Attributes: noreturn
.text$mn:00000CE9
.text$mn:00000CE9 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00000CE9                                         ; DATA XREF: .xdata$x:00001A64o
.text$mn:00000CE9                 push    0               ; Size
.text$mn:00000CEB                 push    1               ; char
.text$mn:00000CED                 mov     ecx, [ebp-18h]
.text$mn:00000CF0                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000CF5                 push    0
.text$mn:00000CF7                 push    0
.text$mn:00000CF9                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000CF9 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00000CF9
.text$mn:00000CFE ; ---------------------------------------------------------------------------
.text$mn:00000CFE                 mov     eax, offset $LN17
.text$mn:00000D03                 retn
.text$mn:00000D04 ; ---------------------------------------------------------------------------
.text$mn:00000D04 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00000D04
.text$mn:00000D04 loc_D04:                                ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00000D04                 mov     dword ptr [ebp-4], 1
.text$mn:00000D0B                 jmp     short loc_D14
.text$mn:00000D0B ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00000D0D
.text$mn:00000D0D ; =============== S U B R O U T I N E =======================================
.text$mn:00000D0D
.text$mn:00000D0D
.text$mn:00000D0D $LN17           proc near               ; DATA XREF: .text$mn:00000CFEo
.text$mn:00000D0D                 mov     dword ptr [ebp-4], 1
.text$mn:00000D0D $LN17           endp ; sp-analysis failed
.text$mn:00000D0D
.text$mn:00000D14 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00000D14
.text$mn:00000D14 loc_D14:                                ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00000D14                 mov     eax, offset $LN19
.text$mn:00000D19                 retn
.text$mn:00000D19 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00000D1A ; ---------------------------------------------------------------------------
.text$mn:00000D1A ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00000D1A
.text$mn:00000D1A loc_D1A:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00000D1A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000D21                 jmp     short loc_D2A
.text$mn:00000D21 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00000D23
.text$mn:00000D23 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D23
.text$mn:00000D23
.text$mn:00000D23 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_D14o
.text$mn:00000D23                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00000D2A
.text$mn:00000D2A loc_D2A:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00000D2A                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00000D2E                 jbe     short loc_D49
.text$mn:00000D30                 mov     edx, [ebp+0Ch]
.text$mn:00000D33                 push    edx             ; Size
.text$mn:00000D34                 mov     ecx, [ebp-18h]
.text$mn:00000D37                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00000D3C                 push    eax             ; Src
.text$mn:00000D3D                 mov     eax, [ebp-20h]
.text$mn:00000D40                 push    eax             ; Dst
.text$mn:00000D41                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00000D46                 add     esp, 0Ch
.text$mn:00000D49
.text$mn:00000D49 loc_D49:                                ; CODE XREF: $LN19+Bj
.text$mn:00000D49                 push    0               ; Size
.text$mn:00000D4B                 push    1               ; char
.text$mn:00000D4D                 mov     ecx, [ebp-18h]
.text$mn:00000D50                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000D55                 lea     ecx, [ebp-20h]
.text$mn:00000D58                 push    ecx             ; int
.text$mn:00000D59                 mov     edx, [ebp-18h]
.text$mn:00000D5C                 add     edx, 4
.text$mn:00000D5F                 push    edx             ; void *
.text$mn:00000D60                 lea     eax, [ebp-13h]
.text$mn:00000D63                 push    eax
.text$mn:00000D64                 mov     ecx, [ebp-18h]
.text$mn:00000D67                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00000D6C                 mov     ecx, eax
.text$mn:00000D6E                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00000D73                 mov     ecx, [ebp-18h]
.text$mn:00000D76                 mov     edx, [ebp-1Ch]
.text$mn:00000D79                 mov     [ecx+18h], edx
.text$mn:00000D7C                 mov     eax, [ebp+0Ch]
.text$mn:00000D7F                 push    eax
.text$mn:00000D80                 mov     ecx, [ebp-18h]
.text$mn:00000D83                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00000D88                 mov     ecx, [ebp-0Ch]
.text$mn:00000D8B                 mov     large fs:0, ecx
.text$mn:00000D92                 pop     ecx
.text$mn:00000D93                 pop     edi
.text$mn:00000D94                 pop     esi
.text$mn:00000D95                 pop     ebx
.text$mn:00000D96                 mov     esp, ebp
.text$mn:00000D98                 pop     ebp
.text$mn:00000D99                 retn    8
.text$mn:00000D99 $LN19           endp ; sp-analysis failed
.text$mn:00000D99
.text$mn:00000D99 _text$mn        ends
.text$mn:00000D99
.text$x:00000D9C ; ===========================================================================
.text$x:00000D9C
.text$x:00000D9C ; Segment type: Pure code
.text$x:00000D9C ; Segment permissions: Read/Execute
.text$x:00000D9C _text$x         segment para public 'CODE' use32
.text$x:00000D9C                 assume cs:_text$x
.text$x:00000D9C                 ;org 0D9Ch
.text$x:00000D9C ; COMDAT (pick associative to section at BF8)
.text$x:00000D9C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000D9C
.text$x:00000D9C ; =============== S U B R O U T I N E =======================================
.text$x:00000D9C
.text$x:00000D9C
.text$x:00000D9C __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00000D9C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00000D9C
.text$x:00000D9C arg_4           = dword ptr  8
.text$x:00000D9C
.text$x:00000D9C                 mov     edx, [esp+arg_4]
.text$x:00000DA0                 lea     eax, [edx+0Ch]
.text$x:00000DA3                 mov     ecx, [edx-24h]
.text$x:00000DA6                 xor     ecx, eax
.text$x:00000DA8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000DAD                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00000DB2                 jmp     ___CxxFrameHandler3
.text$x:00000DB2 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00000DB2
.text$x:00000DB2 ; ---------------------------------------------------------------------------
.text$x:00000DB7                 align 4
.text$x:00000DB7 _text$x         ends
.text$x:00000DB7
.text$mn:00000DB8 ; ===========================================================================
.text$mn:00000DB8
.text$mn:00000DB8 ; Segment type: Pure code
.text$mn:00000DB8 ; Segment permissions: Read/Execute
.text$mn:00000DB8 _text$mn        segment para public 'CODE' use32
.text$mn:00000DB8                 assume cs:_text$mn
.text$mn:00000DB8                 ;org 0DB8h
.text$mn:00000DB8 ; COMDAT (pick any)
.text$mn:00000DB8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000DB8
.text$mn:00000DB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000DB8
.text$mn:00000DB8 ; Attributes: bp-based frame
.text$mn:00000DB8
.text$mn:00000DB8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00000DB8                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00000DB8 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00000DB8                                         ; CODE XREF: $LN19+60p
.text$mn:00000DB8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00000DB8
.text$mn:00000DB8 var_8           = dword ptr -8
.text$mn:00000DB8 var_1           = byte ptr -1
.text$mn:00000DB8 arg_0           = dword ptr  8
.text$mn:00000DB8
.text$mn:00000DB8                 push    ebp
.text$mn:00000DB9                 mov     ebp, esp
.text$mn:00000DBB                 sub     esp, 8
.text$mn:00000DBE                 mov     [ebp+var_8], ecx
.text$mn:00000DC1                 mov     [ebp+var_1], 0
.text$mn:00000DC5                 mov     eax, [ebp+var_8]
.text$mn:00000DC8                 mov     ecx, [ebp+arg_0]
.text$mn:00000DCB                 mov     [eax+14h], ecx
.text$mn:00000DCE                 lea     edx, [ebp+var_1]
.text$mn:00000DD1                 push    edx
.text$mn:00000DD2                 mov     ecx, [ebp+var_8]
.text$mn:00000DD5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00000DDA                 add     eax, [ebp+arg_0]
.text$mn:00000DDD                 push    eax
.text$mn:00000DDE                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00000DE3                 add     esp, 8
.text$mn:00000DE6                 mov     esp, ebp
.text$mn:00000DE8                 pop     ebp
.text$mn:00000DE9                 retn    4
.text$mn:00000DE9 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00000DE9
.text$mn:00000DE9 _text$mn        ends
.text$mn:00000DE9
.text$mn:00000DEC ; ===========================================================================
.text$mn:00000DEC
.text$mn:00000DEC ; Segment type: Pure code
.text$mn:00000DEC ; Segment permissions: Read/Execute
.text$mn:00000DEC _text$mn        segment para public 'CODE' use32
.text$mn:00000DEC                 assume cs:_text$mn
.text$mn:00000DEC                 ;org 0DECh
.text$mn:00000DEC ; COMDAT (pick any)
.text$mn:00000DEC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000DEC
.text$mn:00000DEC ; =============== S U B R O U T I N E =======================================
.text$mn:00000DEC
.text$mn:00000DEC ; Attributes: bp-based frame
.text$mn:00000DEC
.text$mn:00000DEC ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00000DEC                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00000DEC ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00000DEC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00000DEC
.text$mn:00000DEC var_8           = dword ptr -8
.text$mn:00000DEC var_1           = byte ptr -1
.text$mn:00000DEC
.text$mn:00000DEC                 push    ebp
.text$mn:00000DED                 mov     ebp, esp
.text$mn:00000DEF                 sub     esp, 8
.text$mn:00000DF2                 mov     [ebp+var_8], ecx
.text$mn:00000DF5                 lea     ecx, [ebp+var_1]
.text$mn:00000DF8                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00000DFD                 mov     ecx, [ebp+var_8] ; this
.text$mn:00000E00                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00000E05                 mov     eax, [ebp+var_8]
.text$mn:00000E08                 mov     ecx, [eax]
.text$mn:00000E0A                 push    ecx
.text$mn:00000E0B                 lea     ecx, [ebp+var_1]
.text$mn:00000E0E                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00000E13                 push    1               ; int
.text$mn:00000E15                 mov     edx, [ebp+var_8]
.text$mn:00000E18                 mov     eax, [edx]
.text$mn:00000E1A                 push    eax             ; void *
.text$mn:00000E1B                 lea     ecx, [ebp+var_1]
.text$mn:00000E1E                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00000E23                 mov     ecx, [ebp+var_8]
.text$mn:00000E26                 mov     dword ptr [ecx], 0
.text$mn:00000E2C                 mov     esp, ebp
.text$mn:00000E2E                 pop     ebp
.text$mn:00000E2F                 retn
.text$mn:00000E2F ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00000E2F
.text$mn:00000E2F _text$mn        ends
.text$mn:00000E2F
.text$mn:00000E30 ; ===========================================================================
.text$mn:00000E30
.text$mn:00000E30 ; Segment type: Pure code
.text$mn:00000E30 ; Segment permissions: Read/Execute
.text$mn:00000E30 _text$mn        segment para public 'CODE' use32
.text$mn:00000E30                 assume cs:_text$mn
.text$mn:00000E30                 ;org 0E30h
.text$mn:00000E30 ; COMDAT (pick any)
.text$mn:00000E30                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000E30
.text$mn:00000E30 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E30
.text$mn:00000E30 ; Attributes: bp-based frame
.text$mn:00000E30
.text$mn:00000E30 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00000E30                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00000E30 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00000E30                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00000E30                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00000E30
.text$mn:00000E30 var_4           = dword ptr -4
.text$mn:00000E30 arg_0           = dword ptr  8
.text$mn:00000E30
.text$mn:00000E30                 push    ebp
.text$mn:00000E31                 mov     ebp, esp
.text$mn:00000E33                 push    ecx
.text$mn:00000E34                 mov     [ebp+var_4], ecx
.text$mn:00000E37                 mov     ecx, [ebp+arg_0]
.text$mn:00000E3A                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00000E3F                 mov     eax, [ebp+arg_0]
.text$mn:00000E42                 mov     esp, ebp
.text$mn:00000E44                 pop     ebp
.text$mn:00000E45                 retn    4
.text$mn:00000E45 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00000E45
.text$mn:00000E45 _text$mn        ends
.text$mn:00000E45
.text$mn:00000E48 ; ===========================================================================
.text$mn:00000E48
.text$mn:00000E48 ; Segment type: Pure code
.text$mn:00000E48 ; Segment permissions: Read/Execute
.text$mn:00000E48 _text$mn        segment para public 'CODE' use32
.text$mn:00000E48                 assume cs:_text$mn
.text$mn:00000E48                 ;org 0E48h
.text$mn:00000E48 ; COMDAT (pick any)
.text$mn:00000E48                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000E48
.text$mn:00000E48 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E48
.text$mn:00000E48 ; Attributes: bp-based frame
.text$mn:00000E48
.text$mn:00000E48 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00000E48                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00000E48 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00000E48                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00000E48                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00000E48
.text$mn:00000E48 var_C           = dword ptr -0Ch
.text$mn:00000E48 Size            = dword ptr -8
.text$mn:00000E48 var_4           = dword ptr -4
.text$mn:00000E48 arg_0           = dword ptr  8
.text$mn:00000E48 arg_4           = byte ptr  0Ch
.text$mn:00000E48
.text$mn:00000E48                 push    ebp
.text$mn:00000E49                 mov     ebp, esp
.text$mn:00000E4B                 sub     esp, 0Ch
.text$mn:00000E4E                 mov     [ebp+var_4], ecx
.text$mn:00000E51                 mov     ecx, [ebp+var_4]
.text$mn:00000E54                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00000E59                 cmp     eax, [ebp+arg_0]
.text$mn:00000E5C                 jnb     short loc_E66
.text$mn:00000E5E                 mov     ecx, [ebp+var_4]
.text$mn:00000E61                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00000E66
.text$mn:00000E66 loc_E66:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00000E66                 mov     eax, [ebp+var_4]
.text$mn:00000E69                 mov     ecx, [eax+18h]
.text$mn:00000E6C                 cmp     ecx, [ebp+arg_0]
.text$mn:00000E6F                 jnb     short loc_E86
.text$mn:00000E71                 mov     edx, [ebp+var_4]
.text$mn:00000E74                 mov     eax, [edx+14h]
.text$mn:00000E77                 push    eax
.text$mn:00000E78                 mov     ecx, [ebp+arg_0]
.text$mn:00000E7B                 push    ecx
.text$mn:00000E7C                 mov     ecx, [ebp+var_4]
.text$mn:00000E7F                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00000E84                 jmp     short loc_ED0
.text$mn:00000E86 ; ---------------------------------------------------------------------------
.text$mn:00000E86
.text$mn:00000E86 loc_E86:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00000E86                 movzx   edx, [ebp+arg_4]
.text$mn:00000E8A                 test    edx, edx
.text$mn:00000E8C                 jz      short loc_EC0
.text$mn:00000E8E                 cmp     [ebp+arg_0], 10h
.text$mn:00000E92                 jnb     short loc_EC0
.text$mn:00000E94                 mov     eax, [ebp+var_4]
.text$mn:00000E97                 mov     ecx, [ebp+arg_0]
.text$mn:00000E9A                 cmp     ecx, [eax+14h]
.text$mn:00000E9D                 jnb     short loc_EA7
.text$mn:00000E9F                 mov     edx, [ebp+arg_0]
.text$mn:00000EA2                 mov     [ebp+Size], edx
.text$mn:00000EA5                 jmp     short loc_EB0
.text$mn:00000EA7 ; ---------------------------------------------------------------------------
.text$mn:00000EA7
.text$mn:00000EA7 loc_EA7:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00000EA7                 mov     eax, [ebp+var_4]
.text$mn:00000EAA                 mov     ecx, [eax+14h]
.text$mn:00000EAD                 mov     [ebp+Size], ecx
.text$mn:00000EB0
.text$mn:00000EB0 loc_EB0:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00000EB0                 mov     edx, [ebp+Size]
.text$mn:00000EB3                 push    edx             ; Size
.text$mn:00000EB4                 push    1               ; char
.text$mn:00000EB6                 mov     ecx, [ebp+var_4]
.text$mn:00000EB9                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000EBE                 jmp     short loc_ED0
.text$mn:00000EC0 ; ---------------------------------------------------------------------------
.text$mn:00000EC0
.text$mn:00000EC0 loc_EC0:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00000EC0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00000EC0                 cmp     [ebp+arg_0], 0
.text$mn:00000EC4                 jnz     short loc_ED0
.text$mn:00000EC6                 push    0
.text$mn:00000EC8                 mov     ecx, [ebp+var_4]
.text$mn:00000ECB                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00000ED0
.text$mn:00000ED0 loc_ED0:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00000ED0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00000ED0                 cmp     [ebp+arg_0], 0
.text$mn:00000ED4                 jbe     short loc_EDF
.text$mn:00000ED6                 mov     [ebp+var_C], 1
.text$mn:00000EDD                 jmp     short loc_EE6
.text$mn:00000EDF ; ---------------------------------------------------------------------------
.text$mn:00000EDF
.text$mn:00000EDF loc_EDF:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00000EDF                 mov     [ebp+var_C], 0
.text$mn:00000EE6
.text$mn:00000EE6 loc_EE6:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00000EE6                 mov     al, byte ptr [ebp+var_C]
.text$mn:00000EE9                 mov     esp, ebp
.text$mn:00000EEB                 pop     ebp
.text$mn:00000EEC                 retn    8
.text$mn:00000EEC ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00000EEC
.text$mn:00000EEC ; ---------------------------------------------------------------------------
.text$mn:00000EEF                 align 10h
.text$mn:00000EEF _text$mn        ends
.text$mn:00000EEF
.text$mn:00000EF0 ; ===========================================================================
.text$mn:00000EF0
.text$mn:00000EF0 ; Segment type: Pure code
.text$mn:00000EF0 ; Segment permissions: Read/Execute
.text$mn:00000EF0 _text$mn        segment para public 'CODE' use32
.text$mn:00000EF0                 assume cs:_text$mn
.text$mn:00000EF0                 ;org 0EF0h
.text$mn:00000EF0 ; COMDAT (pick any)
.text$mn:00000EF0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000EF0
.text$mn:00000EF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000EF0
.text$mn:00000EF0 ; Attributes: bp-based frame
.text$mn:00000EF0
.text$mn:00000EF0 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00000EF0                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00000EF0 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00000EF0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00000EF0
.text$mn:00000EF0 var_4           = dword ptr -4
.text$mn:00000EF0 arg_0           = dword ptr  8
.text$mn:00000EF0
.text$mn:00000EF0                 push    ebp
.text$mn:00000EF1                 mov     ebp, esp
.text$mn:00000EF3                 push    ecx
.text$mn:00000EF4                 mov     [ebp+var_4], ecx
.text$mn:00000EF7                 cmp     [ebp+arg_0], 0
.text$mn:00000EFB                 jz      short loc_F1D
.text$mn:00000EFD                 mov     ecx, [ebp+var_4]
.text$mn:00000F00                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00000F05                 cmp     [ebp+arg_0], eax
.text$mn:00000F08                 jb      short loc_F1D
.text$mn:00000F0A                 mov     ecx, [ebp+var_4]
.text$mn:00000F0D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00000F12                 mov     ecx, [ebp+var_4]
.text$mn:00000F15                 add     eax, [ecx+14h]
.text$mn:00000F18                 cmp     eax, [ebp+arg_0]
.text$mn:00000F1B                 ja      short loc_F23
.text$mn:00000F1D
.text$mn:00000F1D loc_F1D:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00000F1D                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00000F1D                 xor     al, al
.text$mn:00000F1F                 jmp     short loc_F25
.text$mn:00000F21 ; ---------------------------------------------------------------------------
.text$mn:00000F21                 jmp     short loc_F25
.text$mn:00000F23 ; ---------------------------------------------------------------------------
.text$mn:00000F23
.text$mn:00000F23 loc_F23:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:00000F23                 mov     al, 1
.text$mn:00000F25
.text$mn:00000F25 loc_F25:                                ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00000F25                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00000F25                 mov     esp, ebp
.text$mn:00000F27                 pop     ebp
.text$mn:00000F28                 retn    4
.text$mn:00000F28 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00000F28
.text$mn:00000F28 ; ---------------------------------------------------------------------------
.text$mn:00000F2B                 align 4
.text$mn:00000F2B _text$mn        ends
.text$mn:00000F2B
.text$mn:00000F2C ; ===========================================================================
.text$mn:00000F2C
.text$mn:00000F2C ; Segment type: Pure code
.text$mn:00000F2C ; Segment permissions: Read/Execute
.text$mn:00000F2C _text$mn        segment para public 'CODE' use32
.text$mn:00000F2C                 assume cs:_text$mn
.text$mn:00000F2C                 ;org 0F2Ch
.text$mn:00000F2C ; COMDAT (pick any)
.text$mn:00000F2C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000F2C
.text$mn:00000F2C ; =============== S U B R O U T I N E =======================================
.text$mn:00000F2C
.text$mn:00000F2C ; Attributes: bp-based frame
.text$mn:00000F2C
.text$mn:00000F2C ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00000F2C                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00000F2C ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00000F2C                                         ; CODE XREF: $LN19+14p
.text$mn:00000F2C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00000F2C
.text$mn:00000F2C var_8           = dword ptr -8
.text$mn:00000F2C var_4           = dword ptr -4
.text$mn:00000F2C
.text$mn:00000F2C                 push    ebp
.text$mn:00000F2D                 mov     ebp, esp
.text$mn:00000F2F                 sub     esp, 8
.text$mn:00000F32                 mov     [ebp+var_4], ecx
.text$mn:00000F35                 mov     eax, [ebp+var_4]
.text$mn:00000F38                 cmp     dword ptr [eax+18h], 10h
.text$mn:00000F3C                 jb      short loc_F52
.text$mn:00000F3E                 mov     ecx, [ebp+var_4]
.text$mn:00000F41                 mov     edx, [ecx+4]
.text$mn:00000F44                 push    edx
.text$mn:00000F45                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00000F4A                 add     esp, 4
.text$mn:00000F4D                 mov     [ebp+var_8], eax
.text$mn:00000F50                 jmp     short loc_F5B
.text$mn:00000F52 ; ---------------------------------------------------------------------------
.text$mn:00000F52
.text$mn:00000F52 loc_F52:                                ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00000F52                 mov     eax, [ebp+var_4]
.text$mn:00000F55                 add     eax, 4
.text$mn:00000F58                 mov     [ebp+var_8], eax
.text$mn:00000F5B
.text$mn:00000F5B loc_F5B:                                ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00000F5B                 mov     eax, [ebp+var_8]
.text$mn:00000F5E                 mov     esp, ebp
.text$mn:00000F60                 pop     ebp
.text$mn:00000F61                 retn
.text$mn:00000F61 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00000F61
.text$mn:00000F61 ; ---------------------------------------------------------------------------
.text$mn:00000F62                 align 4
.text$mn:00000F62 _text$mn        ends
.text$mn:00000F62
.text$mn:00000F64 ; ===========================================================================
.text$mn:00000F64
.text$mn:00000F64 ; Segment type: Pure code
.text$mn:00000F64 ; Segment permissions: Read/Execute
.text$mn:00000F64 _text$mn        segment para public 'CODE' use32
.text$mn:00000F64                 assume cs:_text$mn
.text$mn:00000F64                 ;org 0F64h
.text$mn:00000F64 ; COMDAT (pick any)
.text$mn:00000F64                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000F64
.text$mn:00000F64 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F64
.text$mn:00000F64 ; Attributes: bp-based frame
.text$mn:00000F64
.text$mn:00000F64 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00000F64                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00000F64 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00000F64                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00000F64
.text$mn:00000F64 var_8           = dword ptr -8
.text$mn:00000F64 var_4           = dword ptr -4
.text$mn:00000F64
.text$mn:00000F64                 push    ebp
.text$mn:00000F65                 mov     ebp, esp
.text$mn:00000F67                 sub     esp, 8
.text$mn:00000F6A                 mov     [ebp+var_4], ecx
.text$mn:00000F6D                 mov     eax, [ebp+var_4]
.text$mn:00000F70                 cmp     dword ptr [eax+18h], 10h
.text$mn:00000F74                 jb      short loc_F8A
.text$mn:00000F76                 mov     ecx, [ebp+var_4]
.text$mn:00000F79                 mov     edx, [ecx+4]
.text$mn:00000F7C                 push    edx
.text$mn:00000F7D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00000F82                 add     esp, 4
.text$mn:00000F85                 mov     [ebp+var_8], eax
.text$mn:00000F88                 jmp     short loc_F93
.text$mn:00000F8A ; ---------------------------------------------------------------------------
.text$mn:00000F8A
.text$mn:00000F8A loc_F8A:                                ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00000F8A                 mov     eax, [ebp+var_4]
.text$mn:00000F8D                 add     eax, 4
.text$mn:00000F90                 mov     [ebp+var_8], eax
.text$mn:00000F93
.text$mn:00000F93 loc_F93:                                ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00000F93                 mov     eax, [ebp+var_8]
.text$mn:00000F96                 mov     esp, ebp
.text$mn:00000F98                 pop     ebp
.text$mn:00000F99                 retn
.text$mn:00000F99 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00000F99
.text$mn:00000F99 ; ---------------------------------------------------------------------------
.text$mn:00000F9A                 align 4
.text$mn:00000F9A _text$mn        ends
.text$mn:00000F9A
.text$mn:00000F9C ; ===========================================================================
.text$mn:00000F9C
.text$mn:00000F9C ; Segment type: Pure code
.text$mn:00000F9C ; Segment permissions: Read/Execute
.text$mn:00000F9C _text$mn        segment para public 'CODE' use32
.text$mn:00000F9C                 assume cs:_text$mn
.text$mn:00000F9C                 ;org 0F9Ch
.text$mn:00000F9C ; COMDAT (pick any)
.text$mn:00000F9C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000F9C
.text$mn:00000F9C ; =============== S U B R O U T I N E =======================================
.text$mn:00000F9C
.text$mn:00000F9C ; Attributes: bp-based frame
.text$mn:00000F9C
.text$mn:00000F9C ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00000F9C                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00000F9C ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00000F9C                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00000F9C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:00000F9C
.text$mn:00000F9C var_18          = byte ptr -18h
.text$mn:00000F9C var_14          = dword ptr -14h
.text$mn:00000F9C var_10          = dword ptr -10h
.text$mn:00000F9C var_C           = dword ptr -0Ch
.text$mn:00000F9C var_4           = dword ptr -4
.text$mn:00000F9C
.text$mn:00000F9C                 push    ebp
.text$mn:00000F9D                 mov     ebp, esp
.text$mn:00000F9F                 push    0FFFFFFFFh
.text$mn:00000FA1                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00000FA6                 mov     eax, large fs:0
.text$mn:00000FAC                 push    eax
.text$mn:00000FAD                 sub     esp, 0Ch
.text$mn:00000FB0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000FB5                 xor     eax, ebp
.text$mn:00000FB7                 push    eax
.text$mn:00000FB8                 lea     eax, [ebp+var_C]
.text$mn:00000FBB                 mov     large fs:0, eax
.text$mn:00000FC1                 mov     [ebp+var_14], ecx
.text$mn:00000FC4                 mov     eax, [ebp+var_14]
.text$mn:00000FC7                 cmp     dword ptr [eax], 0
.text$mn:00000FCA                 jz      short loc_1027
.text$mn:00000FCC                 push    3               ; int
.text$mn:00000FCE                 lea     ecx, [ebp+var_18] ; this
.text$mn:00000FD1                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00000FD6                 mov     [ebp+var_4], 0
.text$mn:00000FDD                 mov     ecx, [ebp+var_14]
.text$mn:00000FE0                 mov     edx, [ecx]
.text$mn:00000FE2                 add     edx, 4
.text$mn:00000FE5                 mov     [ebp+var_10], edx
.text$mn:00000FE8                 jmp     short loc_FF7
.text$mn:00000FEA ; ---------------------------------------------------------------------------
.text$mn:00000FEA
.text$mn:00000FEA loc_FEA:                                ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:00000FEA                 mov     eax, [ebp+var_10]
.text$mn:00000FED                 mov     ecx, [eax]
.text$mn:00000FEF                 mov     edx, [ebp+var_10]
.text$mn:00000FF2                 mov     eax, [ecx+4]
.text$mn:00000FF5                 mov     [edx], eax
.text$mn:00000FF7
.text$mn:00000FF7 loc_FF7:                                ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00000FF7                 mov     ecx, [ebp+var_10]
.text$mn:00000FFA                 cmp     dword ptr [ecx], 0
.text$mn:00000FFD                 jz      short loc_100C
.text$mn:00000FFF                 mov     edx, [ebp+var_10]
.text$mn:00001002                 mov     eax, [edx]
.text$mn:00001004                 mov     dword ptr [eax], 0
.text$mn:0000100A                 jmp     short loc_FEA
.text$mn:0000100C ; ---------------------------------------------------------------------------
.text$mn:0000100C
.text$mn:0000100C loc_100C:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:0000100C                 mov     ecx, [ebp+var_14]
.text$mn:0000100F                 mov     edx, [ecx]
.text$mn:00001011                 mov     dword ptr [edx+4], 0
.text$mn:00001018                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000101F                 lea     ecx, [ebp+var_18] ; this
.text$mn:00001022                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00001027
.text$mn:00001027 loc_1027:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00001027                 mov     ecx, [ebp+var_C]
.text$mn:0000102A                 mov     large fs:0, ecx
.text$mn:00001031                 pop     ecx
.text$mn:00001032                 mov     esp, ebp
.text$mn:00001034                 pop     ebp
.text$mn:00001035                 retn
.text$mn:00001035 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00001035
.text$mn:00001035 ; ---------------------------------------------------------------------------
.text$mn:00001036                 align 4
.text$mn:00001036 _text$mn        ends
.text$mn:00001036
.text$x:00001038 ; ===========================================================================
.text$x:00001038
.text$x:00001038 ; Segment type: Pure code
.text$x:00001038 ; Segment permissions: Read/Execute
.text$x:00001038 _text$x         segment para public 'CODE' use32
.text$x:00001038                 assume cs:_text$x
.text$x:00001038                 ;org 1038h
.text$x:00001038 ; COMDAT (pick associative to section at F9C)
.text$x:00001038                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001038
.text$x:00001038 ; =============== S U B R O U T I N E =======================================
.text$x:00001038
.text$x:00001038
.text$x:00001038 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00001038                                         ; DATA XREF: .xdata$x:00001918o
.text$x:00001038                 lea     ecx, [ebp-18h]  ; this
.text$x:0000103B                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000103B __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:0000103B
.text$x:00001040
.text$x:00001040 ; =============== S U B R O U T I N E =======================================
.text$x:00001040
.text$x:00001040
.text$x:00001040 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00001040                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00001040
.text$x:00001040 arg_4           = dword ptr  8
.text$x:00001040
.text$x:00001040                 mov     edx, [esp+arg_4]
.text$x:00001044                 lea     eax, [edx+0Ch]
.text$x:00001047                 mov     ecx, [edx-10h]
.text$x:0000104A                 xor     ecx, eax
.text$x:0000104C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001051                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00001056                 jmp     ___CxxFrameHandler3
.text$x:00001056 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00001056
.text$x:00001056 ; ---------------------------------------------------------------------------
.text$x:0000105B                 align 4
.text$x:0000105B _text$x         ends
.text$x:0000105B
.text$mn:0000105C ; ===========================================================================
.text$mn:0000105C
.text$mn:0000105C ; Segment type: Pure code
.text$mn:0000105C ; Segment permissions: Read/Execute
.text$mn:0000105C _text$mn        segment para public 'CODE' use32
.text$mn:0000105C                 assume cs:_text$mn
.text$mn:0000105C                 ;org 105Ch
.text$mn:0000105C ; COMDAT (pick any)
.text$mn:0000105C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000105C
.text$mn:0000105C ; =============== S U B R O U T I N E =======================================
.text$mn:0000105C
.text$mn:0000105C ; Attributes: bp-based frame
.text$mn:0000105C
.text$mn:0000105C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:0000105C                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:0000105C ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:0000105C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:0000105C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:0000105C
.text$mn:0000105C var_C           = dword ptr -0Ch
.text$mn:0000105C var_8           = dword ptr -8
.text$mn:0000105C var_2           = byte ptr -2
.text$mn:0000105C var_1           = byte ptr -1
.text$mn:0000105C arg_0           = byte ptr  8
.text$mn:0000105C Size            = dword ptr  0Ch
.text$mn:0000105C
.text$mn:0000105C                 push    ebp
.text$mn:0000105D                 mov     ebp, esp
.text$mn:0000105F                 sub     esp, 0Ch
.text$mn:00001062                 mov     [ebp+var_8], ecx
.text$mn:00001065                 movzx   eax, [ebp+arg_0]
.text$mn:00001069                 test    eax, eax
.text$mn:0000106B                 jnz     short loc_106F
.text$mn:0000106D                 jmp     short loc_10E2
.text$mn:0000106F ; ---------------------------------------------------------------------------
.text$mn:0000106F
.text$mn:0000106F loc_106F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:0000106F                 mov     ecx, [ebp+var_8]
.text$mn:00001072                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00001076                 jb      short loc_10E2
.text$mn:00001078                 mov     edx, [ebp+var_8]
.text$mn:0000107B                 mov     eax, [edx+4]
.text$mn:0000107E                 mov     [ebp+var_C], eax
.text$mn:00001081                 mov     ecx, [ebp+var_8]
.text$mn:00001084                 add     ecx, 4
.text$mn:00001087                 push    ecx
.text$mn:00001088                 lea     edx, [ebp+var_1]
.text$mn:0000108B                 push    edx
.text$mn:0000108C                 mov     ecx, [ebp+var_8]
.text$mn:0000108F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001094                 mov     ecx, eax
.text$mn:00001096                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:0000109B                 cmp     [ebp+Size], 0
.text$mn:0000109F                 jbe     short loc_10C1
.text$mn:000010A1                 mov     eax, [ebp+Size]
.text$mn:000010A4                 push    eax             ; Size
.text$mn:000010A5                 mov     ecx, [ebp+var_C]
.text$mn:000010A8                 push    ecx
.text$mn:000010A9                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000010AE                 add     esp, 4
.text$mn:000010B1                 push    eax             ; Src
.text$mn:000010B2                 mov     edx, [ebp+var_8]
.text$mn:000010B5                 add     edx, 4
.text$mn:000010B8                 push    edx             ; Dst
.text$mn:000010B9                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000010BE                 add     esp, 0Ch
.text$mn:000010C1
.text$mn:000010C1 loc_10C1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:000010C1                 mov     eax, [ebp+var_8]
.text$mn:000010C4                 mov     ecx, [eax+18h]
.text$mn:000010C7                 add     ecx, 1
.text$mn:000010CA                 push    ecx             ; int
.text$mn:000010CB                 mov     edx, [ebp+var_C]
.text$mn:000010CE                 push    edx             ; void *
.text$mn:000010CF                 lea     eax, [ebp+var_2]
.text$mn:000010D2                 push    eax
.text$mn:000010D3                 mov     ecx, [ebp+var_8]
.text$mn:000010D6                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000010DB                 mov     ecx, eax
.text$mn:000010DD                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:000010E2
.text$mn:000010E2 loc_10E2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:000010E2                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:000010E2                 mov     ecx, [ebp+var_8]
.text$mn:000010E5                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:000010EC                 mov     edx, [ebp+Size]
.text$mn:000010EF                 push    edx
.text$mn:000010F0                 mov     ecx, [ebp+var_8]
.text$mn:000010F3                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000010F8                 mov     esp, ebp
.text$mn:000010FA                 pop     ebp
.text$mn:000010FB                 retn    8
.text$mn:000010FB ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:000010FB
.text$mn:000010FB ; ---------------------------------------------------------------------------
.text$mn:000010FE                 align 10h
.text$mn:000010FE _text$mn        ends
.text$mn:000010FE
.text$mn:00001100 ; ===========================================================================
.text$mn:00001100
.text$mn:00001100 ; Segment type: Pure code
.text$mn:00001100 ; Segment permissions: Read/Execute
.text$mn:00001100 _text$mn        segment para public 'CODE' use32
.text$mn:00001100                 assume cs:_text$mn
.text$mn:00001100                 ;org 1100h
.text$mn:00001100 ; COMDAT (pick any)
.text$mn:00001100                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001100
.text$mn:00001100 ; =============== S U B R O U T I N E =======================================
.text$mn:00001100
.text$mn:00001100 ; Attributes: bp-based frame
.text$mn:00001100
.text$mn:00001100 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00001100                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00001100 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00001100                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00001100
.text$mn:00001100 var_4           = dword ptr -4
.text$mn:00001100
.text$mn:00001100                 push    ebp
.text$mn:00001101                 mov     ebp, esp
.text$mn:00001103                 push    ecx
.text$mn:00001104                 mov     [ebp+var_4], ecx
.text$mn:00001107                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:0000110C                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00001111                 mov     esp, ebp
.text$mn:00001113                 pop     ebp
.text$mn:00001114                 retn
.text$mn:00001114 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00001114
.text$mn:00001114 ; ---------------------------------------------------------------------------
.text$mn:00001115                 align 4
.text$mn:00001115 _text$mn        ends
.text$mn:00001115
.text$mn:00001118 ; ===========================================================================
.text$mn:00001118
.text$mn:00001118 ; Segment type: Pure code
.text$mn:00001118 ; Segment permissions: Read/Execute
.text$mn:00001118 _text$mn        segment para public 'CODE' use32
.text$mn:00001118                 assume cs:_text$mn
.text$mn:00001118                 ;org 1118h
.text$mn:00001118 ; COMDAT (pick any)
.text$mn:00001118                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001118
.text$mn:00001118 ; =============== S U B R O U T I N E =======================================
.text$mn:00001118
.text$mn:00001118 ; Attributes: bp-based frame
.text$mn:00001118
.text$mn:00001118 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00001118                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00001118 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00001118                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00001118                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00001118
.text$mn:00001118 var_4           = dword ptr -4
.text$mn:00001118
.text$mn:00001118                 push    ebp
.text$mn:00001119                 mov     ebp, esp
.text$mn:0000111B                 push    ecx
.text$mn:0000111C                 mov     [ebp+var_4], ecx
.text$mn:0000111F                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00001124                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00001129                 mov     esp, ebp
.text$mn:0000112B                 pop     ebp
.text$mn:0000112C                 retn
.text$mn:0000112C ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:0000112C
.text$mn:0000112C ; ---------------------------------------------------------------------------
.text$mn:0000112D                 align 10h
.text$mn:0000112D _text$mn        ends
.text$mn:0000112D
.text$mn:00001130 ; ===========================================================================
.text$mn:00001130
.text$mn:00001130 ; Segment type: Pure code
.text$mn:00001130 ; Segment permissions: Read/Execute
.text$mn:00001130 _text$mn        segment para public 'CODE' use32
.text$mn:00001130                 assume cs:_text$mn
.text$mn:00001130                 ;org 1130h
.text$mn:00001130 ; COMDAT (pick any)
.text$mn:00001130                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001130
.text$mn:00001130 ; =============== S U B R O U T I N E =======================================
.text$mn:00001130
.text$mn:00001130 ; Attributes: bp-based frame
.text$mn:00001130
.text$mn:00001130 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00001130                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00001130 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00001130                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00001130                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00001130
.text$mn:00001130 var_4           = dword ptr -4
.text$mn:00001130 arg_0           = dword ptr  8
.text$mn:00001130
.text$mn:00001130                 push    ebp
.text$mn:00001131                 mov     ebp, esp
.text$mn:00001133                 push    ecx
.text$mn:00001134                 mov     [ebp+var_4], ecx
.text$mn:00001137                 mov     eax, [ebp+arg_0]
.text$mn:0000113A                 push    eax
.text$mn:0000113B                 mov     ecx, [ebp+var_4]
.text$mn:0000113E                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:00001143                 mov     esp, ebp
.text$mn:00001145                 pop     ebp
.text$mn:00001146                 retn    4
.text$mn:00001146 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00001146
.text$mn:00001146 ; ---------------------------------------------------------------------------
.text$mn:00001149                 align 4
.text$mn:00001149 _text$mn        ends
.text$mn:00001149
.text$mn:0000114C ; ===========================================================================
.text$mn:0000114C
.text$mn:0000114C ; Segment type: Pure code
.text$mn:0000114C ; Segment permissions: Read/Execute
.text$mn:0000114C _text$mn        segment para public 'CODE' use32
.text$mn:0000114C                 assume cs:_text$mn
.text$mn:0000114C                 ;org 114Ch
.text$mn:0000114C ; COMDAT (pick any)
.text$mn:0000114C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000114C
.text$mn:0000114C ; =============== S U B R O U T I N E =======================================
.text$mn:0000114C
.text$mn:0000114C ; Attributes: bp-based frame
.text$mn:0000114C
.text$mn:0000114C ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:0000114C                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:0000114C ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:0000114C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:0000114C
.text$mn:0000114C var_4           = dword ptr -4
.text$mn:0000114C arg_0           = dword ptr  8
.text$mn:0000114C
.text$mn:0000114C                 push    ebp
.text$mn:0000114D                 mov     ebp, esp
.text$mn:0000114F                 push    ecx
.text$mn:00001150                 mov     [ebp+var_4], ecx
.text$mn:00001153                 push    0
.text$mn:00001155                 mov     eax, [ebp+arg_0]
.text$mn:00001158                 push    eax
.text$mn:00001159                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:0000115E                 add     esp, 8
.text$mn:00001161                 mov     esp, ebp
.text$mn:00001163                 pop     ebp
.text$mn:00001164                 retn    4
.text$mn:00001164 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00001164
.text$mn:00001164 ; ---------------------------------------------------------------------------
.text$mn:00001167                 align 4
.text$mn:00001167 _text$mn        ends
.text$mn:00001167
.text$mn:00001168 ; ===========================================================================
.text$mn:00001168
.text$mn:00001168 ; Segment type: Pure code
.text$mn:00001168 ; Segment permissions: Read/Execute
.text$mn:00001168 _text$mn        segment para public 'CODE' use32
.text$mn:00001168                 assume cs:_text$mn
.text$mn:00001168                 ;org 1168h
.text$mn:00001168 ; COMDAT (pick any)
.text$mn:00001168                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001168
.text$mn:00001168 ; =============== S U B R O U T I N E =======================================
.text$mn:00001168
.text$mn:00001168 ; Attributes: bp-based frame
.text$mn:00001168
.text$mn:00001168 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00001168                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00001168 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00001168                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00001168
.text$mn:00001168 var_4           = dword ptr -4
.text$mn:00001168 arg_0           = dword ptr  8
.text$mn:00001168
.text$mn:00001168                 push    ebp
.text$mn:00001169                 mov     ebp, esp
.text$mn:0000116B                 push    ecx
.text$mn:0000116C                 mov     [ebp+var_4], ecx
.text$mn:0000116F                 push    0
.text$mn:00001171                 mov     eax, [ebp+arg_0]
.text$mn:00001174                 push    eax
.text$mn:00001175                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:0000117A                 add     esp, 8
.text$mn:0000117D                 mov     esp, ebp
.text$mn:0000117F                 pop     ebp
.text$mn:00001180                 retn    4
.text$mn:00001180 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00001180
.text$mn:00001180 ; ---------------------------------------------------------------------------
.text$mn:00001183                 align 4
.text$mn:00001183 _text$mn        ends
.text$mn:00001183
.text$mn:00001184 ; ===========================================================================
.text$mn:00001184
.text$mn:00001184 ; Segment type: Pure code
.text$mn:00001184 ; Segment permissions: Read/Execute
.text$mn:00001184 _text$mn        segment para public 'CODE' use32
.text$mn:00001184                 assume cs:_text$mn
.text$mn:00001184                 ;org 1184h
.text$mn:00001184 ; COMDAT (pick any)
.text$mn:00001184                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001184
.text$mn:00001184 ; =============== S U B R O U T I N E =======================================
.text$mn:00001184
.text$mn:00001184 ; Attributes: bp-based frame
.text$mn:00001184
.text$mn:00001184 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00001184                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00001184 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00001184                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00001184
.text$mn:00001184 Size            = dword ptr -8
.text$mn:00001184 var_4           = dword ptr -4
.text$mn:00001184 arg_0           = dword ptr  8
.text$mn:00001184 arg_4           = dword ptr  0Ch
.text$mn:00001184 arg_8           = dword ptr  10h
.text$mn:00001184
.text$mn:00001184                 push    ebp
.text$mn:00001185                 mov     ebp, esp
.text$mn:00001187                 sub     esp, 8
.text$mn:0000118A                 mov     [ebp+var_4], ecx
.text$mn:0000118D                 mov     ecx, [ebp+arg_0]
.text$mn:00001190                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00001195                 cmp     eax, [ebp+arg_4]
.text$mn:00001198                 jnb     short loc_11A2
.text$mn:0000119A                 mov     ecx, [ebp+var_4]
.text$mn:0000119D                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000011A2
.text$mn:000011A2 loc_11A2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:000011A2                 mov     ecx, [ebp+arg_0]
.text$mn:000011A5                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:000011AA                 sub     eax, [ebp+arg_4]
.text$mn:000011AD                 mov     [ebp+Size], eax
.text$mn:000011B0                 mov     eax, [ebp+arg_8]
.text$mn:000011B3                 cmp     eax, [ebp+Size]
.text$mn:000011B6                 jnb     short loc_11BE
.text$mn:000011B8                 mov     ecx, [ebp+arg_8]
.text$mn:000011BB                 mov     [ebp+Size], ecx
.text$mn:000011BE
.text$mn:000011BE loc_11BE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:000011BE                 mov     edx, [ebp+var_4]
.text$mn:000011C1                 cmp     edx, [ebp+arg_0]
.text$mn:000011C4                 jnz     short loc_11E5
.text$mn:000011C6                 mov     eax, [ebp+arg_4]
.text$mn:000011C9                 add     eax, [ebp+Size]
.text$mn:000011CC                 push    eax
.text$mn:000011CD                 mov     ecx, [ebp+var_4]
.text$mn:000011D0                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:000011D5                 mov     ecx, [ebp+arg_4]
.text$mn:000011D8                 push    ecx
.text$mn:000011D9                 push    0
.text$mn:000011DB                 mov     ecx, [ebp+var_4]
.text$mn:000011DE                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:000011E3                 jmp     short loc_1227
.text$mn:000011E5 ; ---------------------------------------------------------------------------
.text$mn:000011E5
.text$mn:000011E5 loc_11E5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:000011E5                 push    0
.text$mn:000011E7                 mov     edx, [ebp+Size]
.text$mn:000011EA                 push    edx
.text$mn:000011EB                 mov     ecx, [ebp+var_4]
.text$mn:000011EE                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000011F3                 movzx   eax, al
.text$mn:000011F6                 test    eax, eax
.text$mn:000011F8                 jz      short loc_1227
.text$mn:000011FA                 mov     ecx, [ebp+Size]
.text$mn:000011FD                 push    ecx             ; Size
.text$mn:000011FE                 mov     ecx, [ebp+arg_0]
.text$mn:00001201                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001206                 add     eax, [ebp+arg_4]
.text$mn:00001209                 push    eax             ; Src
.text$mn:0000120A                 mov     ecx, [ebp+var_4]
.text$mn:0000120D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001212                 push    eax             ; Dst
.text$mn:00001213                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001218                 add     esp, 0Ch
.text$mn:0000121B                 mov     edx, [ebp+Size]
.text$mn:0000121E                 push    edx
.text$mn:0000121F                 mov     ecx, [ebp+var_4]
.text$mn:00001222                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001227
.text$mn:00001227 loc_1227:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00001227                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00001227                 mov     eax, [ebp+var_4]
.text$mn:0000122A                 mov     esp, ebp
.text$mn:0000122C                 pop     ebp
.text$mn:0000122D                 retn    0Ch
.text$mn:0000122D ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:0000122D
.text$mn:0000122D _text$mn        ends
.text$mn:0000122D
.text$mn:00001230 ; ===========================================================================
.text$mn:00001230
.text$mn:00001230 ; Segment type: Pure code
.text$mn:00001230 ; Segment permissions: Read/Execute
.text$mn:00001230 _text$mn        segment para public 'CODE' use32
.text$mn:00001230                 assume cs:_text$mn
.text$mn:00001230                 ;org 1230h
.text$mn:00001230 ; COMDAT (pick any)
.text$mn:00001230                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001230
.text$mn:00001230 ; =============== S U B R O U T I N E =======================================
.text$mn:00001230
.text$mn:00001230 ; Attributes: bp-based frame
.text$mn:00001230
.text$mn:00001230 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00001230                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00001230 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00001230                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00001230
.text$mn:00001230 var_4           = dword ptr -4
.text$mn:00001230 Str             = dword ptr  8
.text$mn:00001230
.text$mn:00001230                 push    ebp
.text$mn:00001231                 mov     ebp, esp
.text$mn:00001233                 push    ecx
.text$mn:00001234                 mov     [ebp+var_4], ecx
.text$mn:00001237                 push    490h            ; unsigned int
.text$mn:0000123C                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001241                 mov     eax, [ebp+Str]
.text$mn:00001244                 push    eax             ; int
.text$mn:00001245                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000124A                 add     esp, 0Ch
.text$mn:0000124D                 mov     ecx, [ebp+Str]
.text$mn:00001250                 push    ecx             ; Str
.text$mn:00001251                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00001256                 add     esp, 4
.text$mn:00001259                 push    eax             ; Size
.text$mn:0000125A                 mov     edx, [ebp+Str]
.text$mn:0000125D                 push    edx             ; Src
.text$mn:0000125E                 mov     ecx, [ebp+var_4]
.text$mn:00001261                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00001266                 mov     esp, ebp
.text$mn:00001268                 pop     ebp
.text$mn:00001269                 retn    4
.text$mn:00001269 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00001269
.text$mn:00001269 _text$mn        ends
.text$mn:00001269
.text$mn:0000126C ; ===========================================================================
.text$mn:0000126C
.text$mn:0000126C ; Segment type: Pure code
.text$mn:0000126C ; Segment permissions: Read/Execute
.text$mn:0000126C _text$mn        segment para public 'CODE' use32
.text$mn:0000126C                 assume cs:_text$mn
.text$mn:0000126C                 ;org 126Ch
.text$mn:0000126C ; COMDAT (pick any)
.text$mn:0000126C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000126C
.text$mn:0000126C ; =============== S U B R O U T I N E =======================================
.text$mn:0000126C
.text$mn:0000126C ; Attributes: bp-based frame
.text$mn:0000126C
.text$mn:0000126C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:0000126C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:0000126C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:0000126C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:0000126C
.text$mn:0000126C var_4           = dword ptr -4
.text$mn:0000126C Src             = dword ptr  8
.text$mn:0000126C Size            = dword ptr  0Ch
.text$mn:0000126C
.text$mn:0000126C                 push    ebp
.text$mn:0000126D                 mov     ebp, esp
.text$mn:0000126F                 push    ecx
.text$mn:00001270                 mov     [ebp+var_4], ecx
.text$mn:00001273                 cmp     [ebp+Size], 0
.text$mn:00001277                 jz      short loc_128F
.text$mn:00001279                 push    47Fh            ; unsigned int
.text$mn:0000127E                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001283                 mov     eax, [ebp+Src]
.text$mn:00001286                 push    eax             ; int
.text$mn:00001287                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000128C                 add     esp, 0Ch
.text$mn:0000128F
.text$mn:0000128F loc_128F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:0000128F                 mov     ecx, [ebp+Src]
.text$mn:00001292                 push    ecx
.text$mn:00001293                 mov     ecx, [ebp+var_4]
.text$mn:00001296                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:0000129B                 movzx   edx, al
.text$mn:0000129E                 test    edx, edx
.text$mn:000012A0                 jz      short loc_12C2
.text$mn:000012A2                 mov     eax, [ebp+Size]
.text$mn:000012A5                 push    eax
.text$mn:000012A6                 mov     ecx, [ebp+var_4]
.text$mn:000012A9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000012AE                 mov     ecx, [ebp+Src]
.text$mn:000012B1                 sub     ecx, eax
.text$mn:000012B3                 push    ecx
.text$mn:000012B4                 mov     edx, [ebp+var_4]
.text$mn:000012B7                 push    edx
.text$mn:000012B8                 mov     ecx, [ebp+var_4]
.text$mn:000012BB                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:000012C0                 jmp     short loc_12FF
.text$mn:000012C2 ; ---------------------------------------------------------------------------
.text$mn:000012C2
.text$mn:000012C2 loc_12C2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:000012C2                 push    0
.text$mn:000012C4                 mov     eax, [ebp+Size]
.text$mn:000012C7                 push    eax
.text$mn:000012C8                 mov     ecx, [ebp+var_4]
.text$mn:000012CB                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000012D0                 movzx   ecx, al
.text$mn:000012D3                 test    ecx, ecx
.text$mn:000012D5                 jz      short loc_12FC
.text$mn:000012D7                 mov     edx, [ebp+Size]
.text$mn:000012DA                 push    edx             ; Size
.text$mn:000012DB                 mov     eax, [ebp+Src]
.text$mn:000012DE                 push    eax             ; Src
.text$mn:000012DF                 mov     ecx, [ebp+var_4]
.text$mn:000012E2                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000012E7                 push    eax             ; Dst
.text$mn:000012E8                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000012ED                 add     esp, 0Ch
.text$mn:000012F0                 mov     ecx, [ebp+Size]
.text$mn:000012F3                 push    ecx
.text$mn:000012F4                 mov     ecx, [ebp+var_4]
.text$mn:000012F7                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000012FC
.text$mn:000012FC loc_12FC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:000012FC                 mov     eax, [ebp+var_4]
.text$mn:000012FF
.text$mn:000012FF loc_12FF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:000012FF                 mov     esp, ebp
.text$mn:00001301                 pop     ebp
.text$mn:00001302                 retn    8
.text$mn:00001302 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00001302
.text$mn:00001302 ; ---------------------------------------------------------------------------
.text$mn:00001305                 align 4
.text$mn:00001305 _text$mn        ends
.text$mn:00001305
.text$mn:00001308 ; ===========================================================================
.text$mn:00001308
.text$mn:00001308 ; Segment type: Pure code
.text$mn:00001308 ; Segment permissions: Read/Execute
.text$mn:00001308 _text$mn        segment para public 'CODE' use32
.text$mn:00001308                 assume cs:_text$mn
.text$mn:00001308                 ;org 1308h
.text$mn:00001308 ; COMDAT (pick any)
.text$mn:00001308                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001308
.text$mn:00001308 ; =============== S U B R O U T I N E =======================================
.text$mn:00001308
.text$mn:00001308 ; Attributes: bp-based frame
.text$mn:00001308
.text$mn:00001308 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00001308                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00001308 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00001308                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00001308
.text$mn:00001308 arg_0           = dword ptr  8
.text$mn:00001308 arg_4           = dword ptr  0Ch
.text$mn:00001308
.text$mn:00001308                 push    ebp
.text$mn:00001309                 mov     ebp, esp
.text$mn:0000130B                 mov     eax, [ebp+arg_0]
.text$mn:0000130E                 mov     ecx, [ebp+arg_4]
.text$mn:00001311                 mov     dl, [ecx]
.text$mn:00001313                 mov     [eax], dl
.text$mn:00001315                 pop     ebp
.text$mn:00001316                 retn
.text$mn:00001316 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00001316
.text$mn:00001316 ; ---------------------------------------------------------------------------
.text$mn:00001317                 align 4
.text$mn:00001317 _text$mn        ends
.text$mn:00001317
.text$mn:00001318 ; ===========================================================================
.text$mn:00001318
.text$mn:00001318 ; Segment type: Pure code
.text$mn:00001318 ; Segment permissions: Read/Execute
.text$mn:00001318 _text$mn        segment para public 'CODE' use32
.text$mn:00001318                 assume cs:_text$mn
.text$mn:00001318                 ;org 1318h
.text$mn:00001318 ; COMDAT (pick any)
.text$mn:00001318                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001318
.text$mn:00001318 ; =============== S U B R O U T I N E =======================================
.text$mn:00001318
.text$mn:00001318 ; Attributes: bp-based frame
.text$mn:00001318
.text$mn:00001318 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00001318                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00001318 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00001318                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00001318
.text$mn:00001318 var_4           = dword ptr -4
.text$mn:00001318
.text$mn:00001318                 push    ebp
.text$mn:00001319                 mov     ebp, esp
.text$mn:0000131B                 push    ecx
.text$mn:0000131C                 mov     [ebp+var_4], ecx
.text$mn:0000131F                 mov     eax, [ebp+var_4]
.text$mn:00001322                 mov     eax, [eax+4]
.text$mn:00001325                 mov     esp, ebp
.text$mn:00001327                 pop     ebp
.text$mn:00001328                 retn
.text$mn:00001328 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00001328
.text$mn:00001328 ; ---------------------------------------------------------------------------
.text$mn:00001329                 align 4
.text$mn:00001329 _text$mn        ends
.text$mn:00001329
.text$mn:0000132C ; ===========================================================================
.text$mn:0000132C
.text$mn:0000132C ; Segment type: Pure code
.text$mn:0000132C ; Segment permissions: Read/Execute
.text$mn:0000132C _text$mn        segment para public 'CODE' use32
.text$mn:0000132C                 assume cs:_text$mn
.text$mn:0000132C                 ;org 132Ch
.text$mn:0000132C ; COMDAT (pick any)
.text$mn:0000132C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000132C
.text$mn:0000132C ; =============== S U B R O U T I N E =======================================
.text$mn:0000132C
.text$mn:0000132C ; Attributes: bp-based frame
.text$mn:0000132C
.text$mn:0000132C ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:0000132C                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:0000132C ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:0000132C                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:0000132C                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:0000132C
.text$mn:0000132C var_4           = dword ptr -4
.text$mn:0000132C
.text$mn:0000132C                 push    ebp
.text$mn:0000132D                 mov     ebp, esp
.text$mn:0000132F                 push    ecx
.text$mn:00001330                 mov     [ebp+var_4], ecx
.text$mn:00001333                 mov     eax, [ebp+var_4]
.text$mn:00001336                 mov     eax, [eax+4]
.text$mn:00001339                 mov     esp, ebp
.text$mn:0000133B                 pop     ebp
.text$mn:0000133C                 retn
.text$mn:0000133C ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:0000133C
.text$mn:0000133C ; ---------------------------------------------------------------------------
.text$mn:0000133D                 align 10h
.text$mn:0000133D _text$mn        ends
.text$mn:0000133D
.text$mn:00001340 ; ===========================================================================
.text$mn:00001340
.text$mn:00001340 ; Segment type: Pure code
.text$mn:00001340 ; Segment permissions: Read/Execute
.text$mn:00001340 _text$mn        segment para public 'CODE' use32
.text$mn:00001340                 assume cs:_text$mn
.text$mn:00001340                 ;org 1340h
.text$mn:00001340 ; COMDAT (pick any)
.text$mn:00001340                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001340
.text$mn:00001340 ; =============== S U B R O U T I N E =======================================
.text$mn:00001340
.text$mn:00001340 ; Attributes: bp-based frame
.text$mn:00001340
.text$mn:00001340 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00001340                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00001340 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00001340                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00001340
.text$mn:00001340 var_4           = dword ptr -4
.text$mn:00001340 Dst             = dword ptr  8
.text$mn:00001340 Src             = dword ptr  0Ch
.text$mn:00001340 Size            = dword ptr  10h
.text$mn:00001340
.text$mn:00001340                 push    ebp
.text$mn:00001341                 mov     ebp, esp
.text$mn:00001343                 push    ecx
.text$mn:00001344                 cmp     [ebp+Size], 0
.text$mn:00001348                 jnz     short loc_1352
.text$mn:0000134A                 mov     eax, [ebp+Dst]
.text$mn:0000134D                 mov     [ebp+var_4], eax
.text$mn:00001350                 jmp     short loc_1369
.text$mn:00001352 ; ---------------------------------------------------------------------------
.text$mn:00001352
.text$mn:00001352 loc_1352:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00001352                 mov     ecx, [ebp+Size]
.text$mn:00001355                 push    ecx             ; Size
.text$mn:00001356                 mov     edx, [ebp+Src]
.text$mn:00001359                 push    edx             ; Src
.text$mn:0000135A                 mov     eax, [ebp+Dst]
.text$mn:0000135D                 push    eax             ; Dst
.text$mn:0000135E                 call    _memcpy
.text$mn:00001363                 add     esp, 0Ch
.text$mn:00001366                 mov     [ebp+var_4], eax
.text$mn:00001369
.text$mn:00001369 loc_1369:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00001369                 mov     eax, [ebp+var_4]
.text$mn:0000136C                 mov     esp, ebp
.text$mn:0000136E                 pop     ebp
.text$mn:0000136F                 retn
.text$mn:0000136F ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000136F
.text$mn:0000136F _text$mn        ends
.text$mn:0000136F
.text$mn:00001370 ; ===========================================================================
.text$mn:00001370
.text$mn:00001370 ; Segment type: Pure code
.text$mn:00001370 ; Segment permissions: Read/Execute
.text$mn:00001370 _text$mn        segment para public 'CODE' use32
.text$mn:00001370                 assume cs:_text$mn
.text$mn:00001370                 ;org 1370h
.text$mn:00001370 ; COMDAT (pick any)
.text$mn:00001370                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001370
.text$mn:00001370 ; =============== S U B R O U T I N E =======================================
.text$mn:00001370
.text$mn:00001370 ; Attributes: bp-based frame
.text$mn:00001370
.text$mn:00001370 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00001370                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00001370 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00001370                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00001370
.text$mn:00001370 var_4           = dword ptr -4
.text$mn:00001370 arg_0           = dword ptr  8
.text$mn:00001370 arg_4           = dword ptr  0Ch
.text$mn:00001370
.text$mn:00001370                 push    ebp
.text$mn:00001371                 mov     ebp, esp
.text$mn:00001373                 push    ecx
.text$mn:00001374                 mov     [ebp+var_4], ecx
.text$mn:00001377                 mov     eax, [ebp+arg_4]
.text$mn:0000137A                 push    eax             ; int
.text$mn:0000137B                 mov     ecx, [ebp+arg_0]
.text$mn:0000137E                 push    ecx             ; void *
.text$mn:0000137F                 mov     ecx, [ebp+var_4]
.text$mn:00001382                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00001387                 mov     esp, ebp
.text$mn:00001389                 pop     ebp
.text$mn:0000138A                 retn    8
.text$mn:0000138A ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:0000138A
.text$mn:0000138A ; ---------------------------------------------------------------------------
.text$mn:0000138D                 align 10h
.text$mn:0000138D _text$mn        ends
.text$mn:0000138D
.text$mn:00001390 ; ===========================================================================
.text$mn:00001390
.text$mn:00001390 ; Segment type: Pure code
.text$mn:00001390 ; Segment permissions: Read/Execute
.text$mn:00001390 _text$mn        segment para public 'CODE' use32
.text$mn:00001390                 assume cs:_text$mn
.text$mn:00001390                 ;org 1390h
.text$mn:00001390 ; COMDAT (pick any)
.text$mn:00001390                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001390
.text$mn:00001390 ; =============== S U B R O U T I N E =======================================
.text$mn:00001390
.text$mn:00001390 ; Attributes: bp-based frame
.text$mn:00001390
.text$mn:00001390 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00001390                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00001390 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00001390                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00001390
.text$mn:00001390 var_4           = dword ptr -4
.text$mn:00001390 arg_0           = dword ptr  8
.text$mn:00001390
.text$mn:00001390                 push    ebp
.text$mn:00001391                 mov     ebp, esp
.text$mn:00001393                 push    ecx
.text$mn:00001394                 mov     [ebp+var_4], ecx
.text$mn:00001397                 mov     eax, [ebp+arg_0]
.text$mn:0000139A                 push    eax             ; void *
.text$mn:0000139B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000013A0                 add     esp, 4
.text$mn:000013A3                 mov     esp, ebp
.text$mn:000013A5                 pop     ebp
.text$mn:000013A6                 retn    8
.text$mn:000013A6 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:000013A6
.text$mn:000013A6 ; ---------------------------------------------------------------------------
.text$mn:000013A9                 align 4
.text$mn:000013A9 _text$mn        ends
.text$mn:000013A9
.text$mn:000013AC ; ===========================================================================
.text$mn:000013AC
.text$mn:000013AC ; Segment type: Pure code
.text$mn:000013AC ; Segment permissions: Read/Execute
.text$mn:000013AC _text$mn        segment para public 'CODE' use32
.text$mn:000013AC                 assume cs:_text$mn
.text$mn:000013AC                 ;org 13ACh
.text$mn:000013AC ; COMDAT (pick any)
.text$mn:000013AC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000013AC
.text$mn:000013AC ; =============== S U B R O U T I N E =======================================
.text$mn:000013AC
.text$mn:000013AC ; Attributes: bp-based frame
.text$mn:000013AC
.text$mn:000013AC ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:000013AC                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:000013AC ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:000013AC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:000013AC
.text$mn:000013AC var_4           = dword ptr -4
.text$mn:000013AC arg_0           = dword ptr  8
.text$mn:000013AC
.text$mn:000013AC                 push    ebp
.text$mn:000013AD                 mov     ebp, esp
.text$mn:000013AF                 push    ecx
.text$mn:000013B0                 mov     [ebp+var_4], ecx
.text$mn:000013B3                 mov     eax, [ebp+arg_0]
.text$mn:000013B6                 push    eax             ; void *
.text$mn:000013B7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000013BC                 add     esp, 4
.text$mn:000013BF                 mov     esp, ebp
.text$mn:000013C1                 pop     ebp
.text$mn:000013C2                 retn    8
.text$mn:000013C2 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:000013C2
.text$mn:000013C2 ; ---------------------------------------------------------------------------
.text$mn:000013C5                 align 4
.text$mn:000013C5 _text$mn        ends
.text$mn:000013C5
.text$mn:000013C8 ; ===========================================================================
.text$mn:000013C8
.text$mn:000013C8 ; Segment type: Pure code
.text$mn:000013C8 ; Segment permissions: Read/Execute
.text$mn:000013C8 _text$mn        segment para public 'CODE' use32
.text$mn:000013C8                 assume cs:_text$mn
.text$mn:000013C8                 ;org 13C8h
.text$mn:000013C8 ; COMDAT (pick any)
.text$mn:000013C8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000013C8
.text$mn:000013C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000013C8
.text$mn:000013C8 ; Attributes: bp-based frame
.text$mn:000013C8
.text$mn:000013C8 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:000013C8                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:000013C8 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:000013C8                                         ; DATA XREF: .rdata:00001D5Co
.text$mn:000013C8
.text$mn:000013C8 var_4           = dword ptr -4
.text$mn:000013C8 arg_0           = dword ptr  8
.text$mn:000013C8 arg_4           = dword ptr  0Ch
.text$mn:000013C8
.text$mn:000013C8                 push    ebp
.text$mn:000013C9                 mov     ebp, esp
.text$mn:000013CB                 push    ecx
.text$mn:000013CC                 mov     [ebp+var_4], ecx
.text$mn:000013CF                 mov     eax, [ebp+arg_4]
.text$mn:000013D2                 push    eax             ; int
.text$mn:000013D3                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000013D8                 add     esp, 4
.text$mn:000013DB                 test    eax, eax
.text$mn:000013DD                 jz      short loc_13F8
.text$mn:000013DF                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:000013E4                 push    eax             ; struct std::error_category *
.text$mn:000013E5                 mov     ecx, [ebp+arg_4]
.text$mn:000013E8                 push    ecx             ; int
.text$mn:000013E9                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000013EC                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000013F1                 mov     eax, [ebp+arg_0]
.text$mn:000013F4                 jmp     short loc_140D
.text$mn:000013F6 ; ---------------------------------------------------------------------------
.text$mn:000013F6                 jmp     short loc_140D
.text$mn:000013F8 ; ---------------------------------------------------------------------------
.text$mn:000013F8
.text$mn:000013F8 loc_13F8:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:000013F8                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:000013FD                 push    eax             ; struct std::error_category *
.text$mn:000013FE                 mov     edx, [ebp+arg_4]
.text$mn:00001401                 push    edx             ; int
.text$mn:00001402                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001405                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000140A                 mov     eax, [ebp+arg_0]
.text$mn:0000140D
.text$mn:0000140D loc_140D:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:0000140D                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:0000140D                 mov     esp, ebp
.text$mn:0000140F                 pop     ebp
.text$mn:00001410                 retn    8
.text$mn:00001410 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00001410
.text$mn:00001410 ; ---------------------------------------------------------------------------
.text$mn:00001413                 align 4
.text$mn:00001413 _text$mn        ends
.text$mn:00001413
.text$mn:00001414 ; ===========================================================================
.text$mn:00001414
.text$mn:00001414 ; Segment type: Pure code
.text$mn:00001414 ; Segment permissions: Read/Execute
.text$mn:00001414 _text$mn        segment para public 'CODE' use32
.text$mn:00001414                 assume cs:_text$mn
.text$mn:00001414                 ;org 1414h
.text$mn:00001414 ; COMDAT (pick any)
.text$mn:00001414                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001414
.text$mn:00001414 ; =============== S U B R O U T I N E =======================================
.text$mn:00001414
.text$mn:00001414 ; Attributes: bp-based frame
.text$mn:00001414
.text$mn:00001414 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00001414                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00001414 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00001414                                         ; DATA XREF: .rdata:00001CCCo
.text$mn:00001414                                         ; .rdata:00001CE8o ...
.text$mn:00001414
.text$mn:00001414 var_4           = dword ptr -4
.text$mn:00001414 arg_0           = dword ptr  8
.text$mn:00001414 arg_4           = dword ptr  0Ch
.text$mn:00001414
.text$mn:00001414                 push    ebp
.text$mn:00001415                 mov     ebp, esp
.text$mn:00001417                 push    ecx
.text$mn:00001418                 mov     [ebp+var_4], ecx
.text$mn:0000141B                 mov     eax, [ebp+var_4]
.text$mn:0000141E                 push    eax             ; struct std::error_category *
.text$mn:0000141F                 mov     ecx, [ebp+arg_4]
.text$mn:00001422                 push    ecx             ; int
.text$mn:00001423                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001426                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000142B                 mov     eax, [ebp+arg_0]
.text$mn:0000142E                 mov     esp, ebp
.text$mn:00001430                 pop     ebp
.text$mn:00001431                 retn    8
.text$mn:00001431 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00001431
.text$mn:00001431 _text$mn        ends
.text$mn:00001431
.text$mn:00001434 ; ===========================================================================
.text$mn:00001434
.text$mn:00001434 ; Segment type: Pure code
.text$mn:00001434 ; Segment permissions: Read/Execute
.text$mn:00001434 _text$mn        segment para public 'CODE' use32
.text$mn:00001434                 assume cs:_text$mn
.text$mn:00001434                 ;org 1434h
.text$mn:00001434 ; COMDAT (pick any)
.text$mn:00001434                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001434
.text$mn:00001434 ; =============== S U B R O U T I N E =======================================
.text$mn:00001434
.text$mn:00001434 ; Attributes: bp-based frame
.text$mn:00001434
.text$mn:00001434 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00001434                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00001434 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00001434                                         ; DATA XREF: .rdata:00001CD0o
.text$mn:00001434                                         ; .rdata:00001CECo ...
.text$mn:00001434
.text$mn:00001434 var_8           = dword ptr -8
.text$mn:00001434 var_4           = dword ptr -4
.text$mn:00001434 arg_0           = dword ptr  8
.text$mn:00001434 arg_4           = dword ptr  0Ch
.text$mn:00001434
.text$mn:00001434                 push    ebp
.text$mn:00001435                 mov     ebp, esp
.text$mn:00001437                 sub     esp, 8
.text$mn:0000143A                 mov     [ebp+var_8], ecx
.text$mn:0000143D                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001440                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00001445                 push    eax
.text$mn:00001446                 mov     ecx, [ebp+var_8]
.text$mn:00001449                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000144E                 movzx   eax, al
.text$mn:00001451                 test    eax, eax
.text$mn:00001453                 jz      short loc_146B
.text$mn:00001455                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001458                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:0000145D                 cmp     eax, [ebp+arg_4]
.text$mn:00001460                 jnz     short loc_146B
.text$mn:00001462                 mov     [ebp+var_4], 1
.text$mn:00001469                 jmp     short loc_1472
.text$mn:0000146B ; ---------------------------------------------------------------------------
.text$mn:0000146B
.text$mn:0000146B loc_146B:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:0000146B                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:0000146B                 mov     [ebp+var_4], 0
.text$mn:00001472
.text$mn:00001472 loc_1472:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00001472                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001475                 mov     esp, ebp
.text$mn:00001477                 pop     ebp
.text$mn:00001478                 retn    8
.text$mn:00001478 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00001478
.text$mn:00001478 ; ---------------------------------------------------------------------------
.text$mn:0000147B                 align 4
.text$mn:0000147B _text$mn        ends
.text$mn:0000147B
.text$mn:0000147C ; ===========================================================================
.text$mn:0000147C
.text$mn:0000147C ; Segment type: Pure code
.text$mn:0000147C ; Segment permissions: Read/Execute
.text$mn:0000147C _text$mn        segment para public 'CODE' use32
.text$mn:0000147C                 assume cs:_text$mn
.text$mn:0000147C                 ;org 147Ch
.text$mn:0000147C ; COMDAT (pick any)
.text$mn:0000147C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000147C
.text$mn:0000147C ; =============== S U B R O U T I N E =======================================
.text$mn:0000147C
.text$mn:0000147C ; Attributes: bp-based frame
.text$mn:0000147C
.text$mn:0000147C ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:0000147C                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:0000147C ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:0000147C                                         ; DATA XREF: .rdata:00001CD4o
.text$mn:0000147C                                         ; .rdata:00001CF0o ...
.text$mn:0000147C
.text$mn:0000147C var_C           = byte ptr -0Ch
.text$mn:0000147C var_4           = dword ptr -4
.text$mn:0000147C arg_0           = dword ptr  8
.text$mn:0000147C arg_4           = dword ptr  0Ch
.text$mn:0000147C
.text$mn:0000147C                 push    ebp
.text$mn:0000147D                 mov     ebp, esp
.text$mn:0000147F                 sub     esp, 0Ch
.text$mn:00001482                 mov     [ebp+var_4], ecx
.text$mn:00001485                 mov     eax, [ebp+arg_4]
.text$mn:00001488                 push    eax             ; std::error_condition *
.text$mn:00001489                 mov     ecx, [ebp+arg_0]
.text$mn:0000148C                 push    ecx
.text$mn:0000148D                 lea     edx, [ebp+var_C]
.text$mn:00001490                 push    edx
.text$mn:00001491                 mov     eax, [ebp+var_4]
.text$mn:00001494                 mov     edx, [eax]
.text$mn:00001496                 mov     ecx, [ebp+var_4]
.text$mn:00001499                 mov     eax, [edx+0Ch]
.text$mn:0000149C                 call    eax
.text$mn:0000149E                 mov     ecx, eax
.text$mn:000014A0                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:000014A5                 mov     esp, ebp
.text$mn:000014A7                 pop     ebp
.text$mn:000014A8                 retn    8
.text$mn:000014A8 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:000014A8
.text$mn:000014A8 ; ---------------------------------------------------------------------------
.text$mn:000014AB                 align 4
.text$mn:000014AB _text$mn        ends
.text$mn:000014AB
.text$mn:000014AC ; ===========================================================================
.text$mn:000014AC
.text$mn:000014AC ; Segment type: Pure code
.text$mn:000014AC ; Segment permissions: Read/Execute
.text$mn:000014AC _text$mn        segment para public 'CODE' use32
.text$mn:000014AC                 assume cs:_text$mn
.text$mn:000014AC                 ;org 14ACh
.text$mn:000014AC ; COMDAT (pick any)
.text$mn:000014AC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000014AC
.text$mn:000014AC ; =============== S U B R O U T I N E =======================================
.text$mn:000014AC
.text$mn:000014AC ; Attributes: bp-based frame
.text$mn:000014AC
.text$mn:000014AC ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:000014AC                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:000014AC ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:000014AC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:000014AC
.text$mn:000014AC var_4           = dword ptr -4
.text$mn:000014AC arg_0           = dword ptr  8
.text$mn:000014AC
.text$mn:000014AC                 push    ebp
.text$mn:000014AD                 mov     ebp, esp
.text$mn:000014AF                 push    ecx
.text$mn:000014B0                 mov     [ebp+var_4], ecx
.text$mn:000014B3                 mov     eax, [ebp+var_4]
.text$mn:000014B6                 mov     ecx, [eax+14h]
.text$mn:000014B9                 cmp     ecx, [ebp+arg_0]
.text$mn:000014BC                 jnb     short loc_14C6
.text$mn:000014BE                 mov     ecx, [ebp+var_4]
.text$mn:000014C1                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000014C6
.text$mn:000014C6 loc_14C6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:000014C6                 mov     edx, [ebp+arg_0]
.text$mn:000014C9                 push    edx
.text$mn:000014CA                 mov     ecx, [ebp+var_4]
.text$mn:000014CD                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000014D2                 mov     eax, [ebp+var_4]
.text$mn:000014D5                 mov     esp, ebp
.text$mn:000014D7                 pop     ebp
.text$mn:000014D8                 retn    4
.text$mn:000014D8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:000014D8
.text$mn:000014D8 ; ---------------------------------------------------------------------------
.text$mn:000014DB                 align 4
.text$mn:000014DB _text$mn        ends
.text$mn:000014DB
.text$mn:000014DC ; ===========================================================================
.text$mn:000014DC
.text$mn:000014DC ; Segment type: Pure code
.text$mn:000014DC ; Segment permissions: Read/Execute
.text$mn:000014DC _text$mn        segment para public 'CODE' use32
.text$mn:000014DC                 assume cs:_text$mn
.text$mn:000014DC                 ;org 14DCh
.text$mn:000014DC ; COMDAT (pick any)
.text$mn:000014DC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000014DC
.text$mn:000014DC ; =============== S U B R O U T I N E =======================================
.text$mn:000014DC
.text$mn:000014DC ; Attributes: bp-based frame
.text$mn:000014DC
.text$mn:000014DC ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:000014DC                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:000014DC ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:000014DC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:000014DC
.text$mn:000014DC var_C           = dword ptr -0Ch
.text$mn:000014DC Dst             = dword ptr -8
.text$mn:000014DC var_4           = dword ptr -4
.text$mn:000014DC arg_0           = dword ptr  8
.text$mn:000014DC arg_4           = dword ptr  0Ch
.text$mn:000014DC
.text$mn:000014DC                 push    ebp
.text$mn:000014DD                 mov     ebp, esp
.text$mn:000014DF                 sub     esp, 0Ch
.text$mn:000014E2                 mov     [ebp+var_4], ecx
.text$mn:000014E5                 mov     eax, [ebp+var_4]
.text$mn:000014E8                 mov     ecx, [eax+14h]
.text$mn:000014EB                 cmp     ecx, [ebp+arg_0]
.text$mn:000014EE                 jnb     short loc_14F8
.text$mn:000014F0                 mov     ecx, [ebp+var_4]
.text$mn:000014F3                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000014F8
.text$mn:000014F8 loc_14F8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:000014F8                 mov     edx, [ebp+var_4]
.text$mn:000014FB                 mov     eax, [edx+14h]
.text$mn:000014FE                 sub     eax, [ebp+arg_0]
.text$mn:00001501                 cmp     eax, [ebp+arg_4]
.text$mn:00001504                 ja      short loc_1514
.text$mn:00001506                 mov     ecx, [ebp+arg_0]
.text$mn:00001509                 push    ecx
.text$mn:0000150A                 mov     ecx, [ebp+var_4]
.text$mn:0000150D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001512                 jmp     short loc_155A
.text$mn:00001514 ; ---------------------------------------------------------------------------
.text$mn:00001514
.text$mn:00001514 loc_1514:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00001514                 cmp     [ebp+arg_4], 0
.text$mn:00001518                 jbe     short loc_155A
.text$mn:0000151A                 mov     ecx, [ebp+var_4]
.text$mn:0000151D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001522                 add     eax, [ebp+arg_0]
.text$mn:00001525                 mov     [ebp+Dst], eax
.text$mn:00001528                 mov     edx, [ebp+var_4]
.text$mn:0000152B                 mov     eax, [edx+14h]
.text$mn:0000152E                 sub     eax, [ebp+arg_4]
.text$mn:00001531                 mov     [ebp+var_C], eax
.text$mn:00001534                 mov     ecx, [ebp+var_C]
.text$mn:00001537                 sub     ecx, [ebp+arg_0]
.text$mn:0000153A                 push    ecx             ; Size
.text$mn:0000153B                 mov     edx, [ebp+Dst]
.text$mn:0000153E                 add     edx, [ebp+arg_4]
.text$mn:00001541                 push    edx             ; Src
.text$mn:00001542                 mov     eax, [ebp+Dst]
.text$mn:00001545                 push    eax             ; Dst
.text$mn:00001546                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:0000154B                 add     esp, 0Ch
.text$mn:0000154E                 mov     ecx, [ebp+var_C]
.text$mn:00001551                 push    ecx
.text$mn:00001552                 mov     ecx, [ebp+var_4]
.text$mn:00001555                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000155A
.text$mn:0000155A loc_155A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:0000155A                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:0000155A                 mov     eax, [ebp+var_4]
.text$mn:0000155D                 mov     esp, ebp
.text$mn:0000155F                 pop     ebp
.text$mn:00001560                 retn    8
.text$mn:00001560 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00001560
.text$mn:00001560 ; ---------------------------------------------------------------------------
.text$mn:00001563                 align 4
.text$mn:00001563 _text$mn        ends
.text$mn:00001563
.text$mn:00001564 ; ===========================================================================
.text$mn:00001564
.text$mn:00001564 ; Segment type: Pure code
.text$mn:00001564 ; Segment permissions: Read/Execute
.text$mn:00001564 _text$mn        segment para public 'CODE' use32
.text$mn:00001564                 assume cs:_text$mn
.text$mn:00001564                 ;org 1564h
.text$mn:00001564 ; COMDAT (pick any)
.text$mn:00001564                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001564
.text$mn:00001564 ; =============== S U B R O U T I N E =======================================
.text$mn:00001564
.text$mn:00001564 ; Attributes: bp-based frame
.text$mn:00001564
.text$mn:00001564 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00001564                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00001564 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00001564                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00001564                 push    ebp
.text$mn:00001565                 mov     ebp, esp
.text$mn:00001567                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:0000156C                 pop     ebp
.text$mn:0000156D                 retn
.text$mn:0000156D ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:0000156D
.text$mn:0000156D ; ---------------------------------------------------------------------------
.text$mn:0000156E                 align 10h
.text$mn:0000156E _text$mn        ends
.text$mn:0000156E
.text$mn:00001570 ; ===========================================================================
.text$mn:00001570
.text$mn:00001570 ; Segment type: Pure code
.text$mn:00001570 ; Segment permissions: Read/Execute
.text$mn:00001570 _text$mn        segment para public 'CODE' use32
.text$mn:00001570                 assume cs:_text$mn
.text$mn:00001570                 ;org 1570h
.text$mn:00001570 ; COMDAT (pick any)
.text$mn:00001570                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001570
.text$mn:00001570 ; =============== S U B R O U T I N E =======================================
.text$mn:00001570
.text$mn:00001570 ; Attributes: bp-based frame
.text$mn:00001570
.text$mn:00001570 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00001570                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00001570 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00001570                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00001570
.text$mn:00001570 var_4           = dword ptr -4
.text$mn:00001570 Str             = dword ptr  8
.text$mn:00001570
.text$mn:00001570                 push    ebp
.text$mn:00001571                 mov     ebp, esp
.text$mn:00001573                 push    ecx
.text$mn:00001574                 mov     eax, [ebp+Str]
.text$mn:00001577                 movsx   ecx, byte ptr [eax]
.text$mn:0000157A                 test    ecx, ecx
.text$mn:0000157C                 jnz     short loc_1587
.text$mn:0000157E                 mov     [ebp+var_4], 0
.text$mn:00001585                 jmp     short loc_1596
.text$mn:00001587 ; ---------------------------------------------------------------------------
.text$mn:00001587
.text$mn:00001587 loc_1587:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00001587                 mov     edx, [ebp+Str]
.text$mn:0000158A                 push    edx             ; Str
.text$mn:0000158B                 call    _strlen
.text$mn:00001590                 add     esp, 4
.text$mn:00001593                 mov     [ebp+var_4], eax
.text$mn:00001596
.text$mn:00001596 loc_1596:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00001596                 mov     eax, [ebp+var_4]
.text$mn:00001599                 mov     esp, ebp
.text$mn:0000159B                 pop     ebp
.text$mn:0000159C                 retn
.text$mn:0000159C ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:0000159C
.text$mn:0000159C ; ---------------------------------------------------------------------------
.text$mn:0000159D                 align 10h
.text$mn:0000159D _text$mn        ends
.text$mn:0000159D
.text$mn:000015A0 ; ===========================================================================
.text$mn:000015A0
.text$mn:000015A0 ; Segment type: Pure code
.text$mn:000015A0 ; Segment permissions: Read/Execute
.text$mn:000015A0 _text$mn        segment para public 'CODE' use32
.text$mn:000015A0                 assume cs:_text$mn
.text$mn:000015A0                 ;org 15A0h
.text$mn:000015A0 ; COMDAT (pick any)
.text$mn:000015A0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000015A0
.text$mn:000015A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000015A0
.text$mn:000015A0 ; Attributes: bp-based frame
.text$mn:000015A0
.text$mn:000015A0 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:000015A0                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:000015A0 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:000015A0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:000015A0
.text$mn:000015A0 var_4           = dword ptr -4
.text$mn:000015A0
.text$mn:000015A0                 push    ebp
.text$mn:000015A1                 mov     ebp, esp
.text$mn:000015A3                 push    ecx
.text$mn:000015A4                 mov     [ebp+var_4], ecx
.text$mn:000015A7                 mov     eax, [ebp+var_4]
.text$mn:000015AA                 push    eax
.text$mn:000015AB                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:000015B0                 add     esp, 4
.text$mn:000015B3                 mov     esp, ebp
.text$mn:000015B5                 pop     ebp
.text$mn:000015B6                 retn
.text$mn:000015B6 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:000015B6
.text$mn:000015B6 ; ---------------------------------------------------------------------------
.text$mn:000015B7                 align 4
.text$mn:000015B7 _text$mn        ends
.text$mn:000015B7
.text$mn:000015B8 ; ===========================================================================
.text$mn:000015B8
.text$mn:000015B8 ; Segment type: Pure code
.text$mn:000015B8 ; Segment permissions: Read/Execute
.text$mn:000015B8 _text$mn        segment para public 'CODE' use32
.text$mn:000015B8                 assume cs:_text$mn
.text$mn:000015B8                 ;org 15B8h
.text$mn:000015B8 ; COMDAT (pick any)
.text$mn:000015B8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000015B8
.text$mn:000015B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000015B8
.text$mn:000015B8 ; Attributes: bp-based frame
.text$mn:000015B8
.text$mn:000015B8 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:000015B8                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:000015B8 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:000015B8                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:000015B8
.text$mn:000015B8 var_4           = dword ptr -4
.text$mn:000015B8
.text$mn:000015B8                 push    ebp
.text$mn:000015B9                 mov     ebp, esp
.text$mn:000015BB                 push    ecx
.text$mn:000015BC                 mov     [ebp+var_4], ecx
.text$mn:000015BF                 or      eax, 0FFFFFFFFh
.text$mn:000015C2                 mov     esp, ebp
.text$mn:000015C4                 pop     ebp
.text$mn:000015C5                 retn
.text$mn:000015C5 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:000015C5
.text$mn:000015C5 ; ---------------------------------------------------------------------------
.text$mn:000015C6                 align 4
.text$mn:000015C6 _text$mn        ends
.text$mn:000015C6
.text$mn:000015C8 ; ===========================================================================
.text$mn:000015C8
.text$mn:000015C8 ; Segment type: Pure code
.text$mn:000015C8 ; Segment permissions: Read/Execute
.text$mn:000015C8 _text$mn        segment para public 'CODE' use32
.text$mn:000015C8                 assume cs:_text$mn
.text$mn:000015C8                 ;org 15C8h
.text$mn:000015C8 ; COMDAT (pick any)
.text$mn:000015C8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000015C8
.text$mn:000015C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000015C8
.text$mn:000015C8 ; Attributes: bp-based frame
.text$mn:000015C8
.text$mn:000015C8 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:000015C8                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:000015C8 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:000015C8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:000015C8
.text$mn:000015C8 arg_0           = dword ptr  8
.text$mn:000015C8
.text$mn:000015C8                 push    ebp
.text$mn:000015C9                 mov     ebp, esp
.text$mn:000015CB                 mov     ecx, [ebp+arg_0]
.text$mn:000015CE                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:000015D3                 pop     ebp
.text$mn:000015D4                 retn
.text$mn:000015D4 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:000015D4
.text$mn:000015D4 ; ---------------------------------------------------------------------------
.text$mn:000015D5                 align 4
.text$mn:000015D5 _text$mn        ends
.text$mn:000015D5
.text$mn:000015D8 ; ===========================================================================
.text$mn:000015D8
.text$mn:000015D8 ; Segment type: Pure code
.text$mn:000015D8 ; Segment permissions: Read/Execute
.text$mn:000015D8 _text$mn        segment para public 'CODE' use32
.text$mn:000015D8                 assume cs:_text$mn
.text$mn:000015D8                 ;org 15D8h
.text$mn:000015D8 ; COMDAT (pick any)
.text$mn:000015D8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000015D8
.text$mn:000015D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000015D8
.text$mn:000015D8 ; Attributes: bp-based frame
.text$mn:000015D8
.text$mn:000015D8 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:000015D8                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:000015D8 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:000015D8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:000015D8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:000015D8
.text$mn:000015D8 var_10          = dword ptr -10h
.text$mn:000015D8 var_C           = dword ptr -0Ch
.text$mn:000015D8 var_8           = dword ptr -8
.text$mn:000015D8 var_1           = byte ptr -1
.text$mn:000015D8
.text$mn:000015D8                 push    ebp
.text$mn:000015D9                 mov     ebp, esp
.text$mn:000015DB                 sub     esp, 10h
.text$mn:000015DE                 mov     [ebp+var_10], ecx
.text$mn:000015E1                 lea     eax, [ebp+var_1]
.text$mn:000015E4                 push    eax
.text$mn:000015E5                 mov     ecx, [ebp+var_10]
.text$mn:000015E8                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000015ED                 mov     ecx, eax
.text$mn:000015EF                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:000015F4                 mov     [ebp+var_8], eax
.text$mn:000015F7                 cmp     [ebp+var_8], 1
.text$mn:000015FB                 ja      short loc_1606
.text$mn:000015FD                 mov     [ebp+var_C], 1
.text$mn:00001604                 jmp     short loc_160F
.text$mn:00001606 ; ---------------------------------------------------------------------------
.text$mn:00001606
.text$mn:00001606 loc_1606:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:00001606                 mov     ecx, [ebp+var_8]
.text$mn:00001609                 sub     ecx, 1
.text$mn:0000160C                 mov     [ebp+var_C], ecx
.text$mn:0000160F
.text$mn:0000160F loc_160F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:0000160F                 mov     eax, [ebp+var_C]
.text$mn:00001612                 mov     esp, ebp
.text$mn:00001614                 pop     ebp
.text$mn:00001615                 retn
.text$mn:00001615 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00001615
.text$mn:00001615 ; ---------------------------------------------------------------------------
.text$mn:00001616                 align 4
.text$mn:00001616 _text$mn        ends
.text$mn:00001616
.text$mn:00001618 ; ===========================================================================
.text$mn:00001618
.text$mn:00001618 ; Segment type: Pure code
.text$mn:00001618 ; Segment permissions: Read/Execute
.text$mn:00001618 _text$mn        segment para public 'CODE' use32
.text$mn:00001618                 assume cs:_text$mn
.text$mn:00001618                 ;org 1618h
.text$mn:00001618 ; COMDAT (pick any)
.text$mn:00001618                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001618
.text$mn:00001618 ; =============== S U B R O U T I N E =======================================
.text$mn:00001618
.text$mn:00001618 ; Attributes: bp-based frame
.text$mn:00001618
.text$mn:00001618 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00001618                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001618 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001618                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00001618                                         ; DATA XREF: .rdata:00001CE4o
.text$mn:00001618
.text$mn:00001618 var_1C          = dword ptr -1Ch
.text$mn:00001618 var_18          = dword ptr -18h
.text$mn:00001618 Str             = dword ptr -14h
.text$mn:00001618 var_10          = dword ptr -10h
.text$mn:00001618 var_C           = dword ptr -0Ch
.text$mn:00001618 var_4           = dword ptr -4
.text$mn:00001618 arg_0           = dword ptr  8
.text$mn:00001618 arg_4           = dword ptr  0Ch
.text$mn:00001618
.text$mn:00001618                 push    ebp
.text$mn:00001619                 mov     ebp, esp
.text$mn:0000161B                 push    0FFFFFFFFh
.text$mn:0000161D                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001622                 mov     eax, large fs:0
.text$mn:00001628                 push    eax
.text$mn:00001629                 sub     esp, 10h
.text$mn:0000162C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001631                 xor     eax, ebp
.text$mn:00001633                 push    eax
.text$mn:00001634                 lea     eax, [ebp+var_C]
.text$mn:00001637                 mov     large fs:0, eax
.text$mn:0000163D                 mov     [ebp+var_1C], ecx
.text$mn:00001640                 mov     [ebp+var_18], 0
.text$mn:00001647                 mov     eax, [ebp+arg_4]
.text$mn:0000164A                 push    eax             ; int
.text$mn:0000164B                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00001650                 add     esp, 4
.text$mn:00001653                 mov     [ebp+var_10], eax
.text$mn:00001656                 cmp     [ebp+var_10], 0
.text$mn:0000165A                 jz      short loc_1664
.text$mn:0000165C                 mov     ecx, [ebp+var_10]
.text$mn:0000165F                 mov     [ebp+Str], ecx
.text$mn:00001662                 jmp     short loc_166B
.text$mn:00001664 ; ---------------------------------------------------------------------------
.text$mn:00001664
.text$mn:00001664 loc_1664:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00001664                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000166B
.text$mn:0000166B loc_166B:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:0000166B                 mov     edx, [ebp+Str]
.text$mn:0000166E                 push    edx             ; Str
.text$mn:0000166F                 mov     ecx, [ebp+arg_0]
.text$mn:00001672                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001677                 mov     [ebp+var_4], 0
.text$mn:0000167E                 mov     eax, [ebp+var_18]
.text$mn:00001681                 or      eax, 1
.text$mn:00001684                 mov     [ebp+var_18], eax
.text$mn:00001687                 mov     eax, [ebp+arg_0]
.text$mn:0000168A                 mov     ecx, [ebp+var_C]
.text$mn:0000168D                 mov     large fs:0, ecx
.text$mn:00001694                 pop     ecx
.text$mn:00001695                 mov     esp, ebp
.text$mn:00001697                 pop     ebp
.text$mn:00001698                 retn    8
.text$mn:00001698 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001698
.text$mn:00001698 ; ---------------------------------------------------------------------------
.text$mn:0000169B                 align 4
.text$mn:0000169B _text$mn        ends
.text$mn:0000169B
.text$x:0000169C ; ===========================================================================
.text$x:0000169C
.text$x:0000169C ; Segment type: Pure code
.text$x:0000169C ; Segment permissions: Read/Execute
.text$x:0000169C _text$x         segment para public 'CODE' use32
.text$x:0000169C                 assume cs:_text$x
.text$x:0000169C                 ;org 169Ch
.text$x:0000169C ; COMDAT (pick associative to section at 1618)
.text$x:0000169C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:0000169C
.text$x:0000169C ; =============== S U B R O U T I N E =======================================
.text$x:0000169C
.text$x:0000169C
.text$x:0000169C __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000169C                                         ; DATA XREF: .xdata$x:00001B04o
.text$x:0000169C                 mov     eax, [ebp-18h]
.text$x:0000169F                 and     eax, 1
.text$x:000016A2                 jz      $LN6
.text$x:000016A8                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:000016AC                 mov     ecx, [ebp+8]
.text$x:000016AF                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000016B4 ; ---------------------------------------------------------------------------
.text$x:000016B4
.text$x:000016B4 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000016B4                 retn
.text$x:000016B4 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000016B4
.text$x:000016B5
.text$x:000016B5 ; =============== S U B R O U T I N E =======================================
.text$x:000016B5
.text$x:000016B5
.text$x:000016B5 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000016B5                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:000016B5
.text$x:000016B5 arg_4           = dword ptr  8
.text$x:000016B5
.text$x:000016B5                 mov     edx, [esp+arg_4]
.text$x:000016B9                 lea     eax, [edx+0Ch]
.text$x:000016BC                 mov     ecx, [edx-14h]
.text$x:000016BF                 xor     ecx, eax
.text$x:000016C1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000016C6                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000016CB                 jmp     ___CxxFrameHandler3
.text$x:000016CB __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000016CB
.text$x:000016CB _text$x         ends
.text$x:000016CB
.text$mn:000016D0 ; ===========================================================================
.text$mn:000016D0
.text$mn:000016D0 ; Segment type: Pure code
.text$mn:000016D0 ; Segment permissions: Read/Execute
.text$mn:000016D0 _text$mn        segment para public 'CODE' use32
.text$mn:000016D0                 assume cs:_text$mn
.text$mn:000016D0                 ;org 16D0h
.text$mn:000016D0 ; COMDAT (pick any)
.text$mn:000016D0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000016D0
.text$mn:000016D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000016D0
.text$mn:000016D0 ; Attributes: bp-based frame
.text$mn:000016D0
.text$mn:000016D0 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:000016D0                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000016D0 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000016D0                                         ; DATA XREF: .rdata:00001D18o
.text$mn:000016D0
.text$mn:000016D0 var_14          = dword ptr -14h
.text$mn:000016D0 var_10          = dword ptr -10h
.text$mn:000016D0 var_C           = dword ptr -0Ch
.text$mn:000016D0 var_4           = dword ptr -4
.text$mn:000016D0 arg_0           = dword ptr  8
.text$mn:000016D0 arg_4           = dword ptr  0Ch
.text$mn:000016D0
.text$mn:000016D0                 push    ebp
.text$mn:000016D1                 mov     ebp, esp
.text$mn:000016D3                 push    0FFFFFFFFh
.text$mn:000016D5                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000016DA                 mov     eax, large fs:0
.text$mn:000016E0                 push    eax
.text$mn:000016E1                 sub     esp, 8
.text$mn:000016E4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000016E9                 xor     eax, ebp
.text$mn:000016EB                 push    eax
.text$mn:000016EC                 lea     eax, [ebp+var_C]
.text$mn:000016EF                 mov     large fs:0, eax
.text$mn:000016F5                 mov     [ebp+var_14], ecx
.text$mn:000016F8                 mov     [ebp+var_10], 0
.text$mn:000016FF                 cmp     [ebp+arg_4], 1
.text$mn:00001703                 jnz     short loc_1729
.text$mn:00001705                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:0000170A                 mov     ecx, [ebp+arg_0]
.text$mn:0000170D                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001712                 mov     [ebp+var_4], 0
.text$mn:00001719                 mov     eax, [ebp+var_10]
.text$mn:0000171C                 or      eax, 1
.text$mn:0000171F                 mov     [ebp+var_10], eax
.text$mn:00001722                 mov     eax, [ebp+arg_0]
.text$mn:00001725                 jmp     short loc_174C
.text$mn:00001727 ; ---------------------------------------------------------------------------
.text$mn:00001727                 jmp     short loc_174C
.text$mn:00001729 ; ---------------------------------------------------------------------------
.text$mn:00001729
.text$mn:00001729 loc_1729:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00001729                 mov     ecx, [ebp+arg_4]
.text$mn:0000172C                 push    ecx
.text$mn:0000172D                 mov     edx, [ebp+arg_0]
.text$mn:00001730                 push    edx
.text$mn:00001731                 mov     ecx, [ebp+var_14]
.text$mn:00001734                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00001739                 mov     [ebp+var_4], 0
.text$mn:00001740                 mov     eax, [ebp+var_10]
.text$mn:00001743                 or      eax, 1
.text$mn:00001746                 mov     [ebp+var_10], eax
.text$mn:00001749                 mov     eax, [ebp+arg_0]
.text$mn:0000174C
.text$mn:0000174C loc_174C:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:0000174C                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:0000174C                 mov     ecx, [ebp+var_C]
.text$mn:0000174F                 mov     large fs:0, ecx
.text$mn:00001756                 pop     ecx
.text$mn:00001757                 mov     esp, ebp
.text$mn:00001759                 pop     ebp
.text$mn:0000175A                 retn    8
.text$mn:0000175A ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000175A
.text$mn:0000175A ; ---------------------------------------------------------------------------
.text$mn:0000175D                 align 10h
.text$mn:0000175D _text$mn        ends
.text$mn:0000175D
.text$x:00001760 ; ===========================================================================
.text$x:00001760
.text$x:00001760 ; Segment type: Pure code
.text$x:00001760 ; Segment permissions: Read/Execute
.text$x:00001760 _text$x         segment para public 'CODE' use32
.text$x:00001760                 assume cs:_text$x
.text$x:00001760                 ;org 1760h
.text$x:00001760 ; COMDAT (pick associative to section at 16D0)
.text$x:00001760                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001760
.text$x:00001760 ; =============== S U B R O U T I N E =======================================
.text$x:00001760
.text$x:00001760
.text$x:00001760 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001760                                         ; DATA XREF: .xdata$x:00001B88o
.text$x:00001760                 mov     eax, [ebp-10h]
.text$x:00001763                 and     eax, 1
.text$x:00001766                 jz      $LN6_0
.text$x:0000176C                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00001770                 mov     ecx, [ebp+8]
.text$x:00001773                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001778 ; ---------------------------------------------------------------------------
.text$x:00001778
.text$x:00001778 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001778                 retn
.text$x:00001778 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001778
.text$x:00001779
.text$x:00001779 ; =============== S U B R O U T I N E =======================================
.text$x:00001779
.text$x:00001779
.text$x:00001779 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001779                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00001779
.text$x:00001779 arg_4           = dword ptr  8
.text$x:00001779
.text$x:00001779                 mov     edx, [esp+arg_4]
.text$x:0000177D                 lea     eax, [edx+0Ch]
.text$x:00001780                 mov     ecx, [edx-0Ch]
.text$x:00001783                 xor     ecx, eax
.text$x:00001785                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000178A                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000178F                 jmp     ___CxxFrameHandler3
.text$x:0000178F __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000178F
.text$x:0000178F _text$x         ends
.text$x:0000178F
.text$mn:00001794 ; ===========================================================================
.text$mn:00001794
.text$mn:00001794 ; Segment type: Pure code
.text$mn:00001794 ; Segment permissions: Read/Execute
.text$mn:00001794 _text$mn        segment para public 'CODE' use32
.text$mn:00001794                 assume cs:_text$mn
.text$mn:00001794                 ;org 1794h
.text$mn:00001794 ; COMDAT (pick any)
.text$mn:00001794                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001794
.text$mn:00001794 ; =============== S U B R O U T I N E =======================================
.text$mn:00001794
.text$mn:00001794 ; Attributes: bp-based frame
.text$mn:00001794
.text$mn:00001794 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00001794                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001794 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001794                                         ; DATA XREF: .rdata:00001D58o
.text$mn:00001794
.text$mn:00001794 var_1C          = dword ptr -1Ch
.text$mn:00001794 var_18          = dword ptr -18h
.text$mn:00001794 Str             = dword ptr -14h
.text$mn:00001794 var_10          = dword ptr -10h
.text$mn:00001794 var_C           = dword ptr -0Ch
.text$mn:00001794 var_4           = dword ptr -4
.text$mn:00001794 arg_0           = dword ptr  8
.text$mn:00001794 arg_4           = dword ptr  0Ch
.text$mn:00001794
.text$mn:00001794                 push    ebp
.text$mn:00001795                 mov     ebp, esp
.text$mn:00001797                 push    0FFFFFFFFh
.text$mn:00001799                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000179E                 mov     eax, large fs:0
.text$mn:000017A4                 push    eax
.text$mn:000017A5                 sub     esp, 10h
.text$mn:000017A8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000017AD                 xor     eax, ebp
.text$mn:000017AF                 push    eax
.text$mn:000017B0                 lea     eax, [ebp+var_C]
.text$mn:000017B3                 mov     large fs:0, eax
.text$mn:000017B9                 mov     [ebp+var_1C], ecx
.text$mn:000017BC                 mov     [ebp+var_18], 0
.text$mn:000017C3                 mov     eax, [ebp+arg_4]
.text$mn:000017C6                 push    eax             ; int
.text$mn:000017C7                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:000017CC                 add     esp, 4
.text$mn:000017CF                 mov     [ebp+var_10], eax
.text$mn:000017D2                 cmp     [ebp+var_10], 0
.text$mn:000017D6                 jz      short loc_17E0
.text$mn:000017D8                 mov     ecx, [ebp+var_10]
.text$mn:000017DB                 mov     [ebp+Str], ecx
.text$mn:000017DE                 jmp     short loc_17E7
.text$mn:000017E0 ; ---------------------------------------------------------------------------
.text$mn:000017E0
.text$mn:000017E0 loc_17E0:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:000017E0                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:000017E7
.text$mn:000017E7 loc_17E7:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:000017E7                 mov     edx, [ebp+Str]
.text$mn:000017EA                 push    edx             ; Str
.text$mn:000017EB                 mov     ecx, [ebp+arg_0]
.text$mn:000017EE                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000017F3                 mov     [ebp+var_4], 0
.text$mn:000017FA                 mov     eax, [ebp+var_18]
.text$mn:000017FD                 or      eax, 1
.text$mn:00001800                 mov     [ebp+var_18], eax
.text$mn:00001803                 mov     eax, [ebp+arg_0]
.text$mn:00001806                 mov     ecx, [ebp+var_C]
.text$mn:00001809                 mov     large fs:0, ecx
.text$mn:00001810                 pop     ecx
.text$mn:00001811                 mov     esp, ebp
.text$mn:00001813                 pop     ebp
.text$mn:00001814                 retn    8
.text$mn:00001814 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001814
.text$mn:00001814 ; ---------------------------------------------------------------------------
.text$mn:00001817                 align 4
.text$mn:00001817 _text$mn        ends
.text$mn:00001817
.text$x:00001818 ; ===========================================================================
.text$x:00001818
.text$x:00001818 ; Segment type: Pure code
.text$x:00001818 ; Segment permissions: Read/Execute
.text$x:00001818 _text$x         segment para public 'CODE' use32
.text$x:00001818                 assume cs:_text$x
.text$x:00001818                 ;org 1818h
.text$x:00001818 ; COMDAT (pick associative to section at 1794)
.text$x:00001818                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001818
.text$x:00001818 ; =============== S U B R O U T I N E =======================================
.text$x:00001818
.text$x:00001818
.text$x:00001818 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001818                                         ; DATA XREF: .xdata$x:00001C0Co
.text$x:00001818                 mov     eax, [ebp-18h]
.text$x:0000181B                 and     eax, 1
.text$x:0000181E                 jz      $LN6_1
.text$x:00001824                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00001828                 mov     ecx, [ebp+8]
.text$x:0000182B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001830 ; ---------------------------------------------------------------------------
.text$x:00001830
.text$x:00001830 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001830                 retn
.text$x:00001830 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001830
.text$x:00001831
.text$x:00001831 ; =============== S U B R O U T I N E =======================================
.text$x:00001831
.text$x:00001831
.text$x:00001831 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001831                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00001831
.text$x:00001831 arg_4           = dword ptr  8
.text$x:00001831
.text$x:00001831                 mov     edx, [esp+arg_4]
.text$x:00001835                 lea     eax, [edx+0Ch]
.text$x:00001838                 mov     ecx, [edx-14h]
.text$x:0000183B                 xor     ecx, eax
.text$x:0000183D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001842                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001847                 jmp     ___CxxFrameHandler3
.text$x:00001847 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001847
.text$x:00001847 _text$x         ends
.text$x:00001847
.text$mn:0000184C ; ===========================================================================
.text$mn:0000184C
.text$mn:0000184C ; Segment type: Pure code
.text$mn:0000184C ; Segment permissions: Read/Execute
.text$mn:0000184C _text$mn        segment para public 'CODE' use32
.text$mn:0000184C                 assume cs:_text$mn
.text$mn:0000184C                 ;org 184Ch
.text$mn:0000184C ; COMDAT (pick any)
.text$mn:0000184C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000184C
.text$mn:0000184C ; =============== S U B R O U T I N E =======================================
.text$mn:0000184C
.text$mn:0000184C ; Attributes: bp-based frame
.text$mn:0000184C
.text$mn:0000184C ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:0000184C                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:0000184C ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:0000184C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:0000184C
.text$mn:0000184C var_4           = dword ptr -4
.text$mn:0000184C Dst             = dword ptr  8
.text$mn:0000184C Src             = dword ptr  0Ch
.text$mn:0000184C Size            = dword ptr  10h
.text$mn:0000184C
.text$mn:0000184C                 push    ebp
.text$mn:0000184D                 mov     ebp, esp
.text$mn:0000184F                 push    ecx
.text$mn:00001850                 cmp     [ebp+Size], 0
.text$mn:00001854                 jnz     short loc_185E
.text$mn:00001856                 mov     eax, [ebp+Dst]
.text$mn:00001859                 mov     [ebp+var_4], eax
.text$mn:0000185C                 jmp     short loc_1875
.text$mn:0000185E ; ---------------------------------------------------------------------------
.text$mn:0000185E
.text$mn:0000185E loc_185E:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:0000185E                 mov     ecx, [ebp+Size]
.text$mn:00001861                 push    ecx             ; Size
.text$mn:00001862                 mov     edx, [ebp+Src]
.text$mn:00001865                 push    edx             ; Src
.text$mn:00001866                 mov     eax, [ebp+Dst]
.text$mn:00001869                 push    eax             ; Dst
.text$mn:0000186A                 call    _memmove
.text$mn:0000186F                 add     esp, 0Ch
.text$mn:00001872                 mov     [ebp+var_4], eax
.text$mn:00001875
.text$mn:00001875 loc_1875:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00001875                 mov     eax, [ebp+var_4]
.text$mn:00001878                 mov     esp, ebp
.text$mn:0000187A                 pop     ebp
.text$mn:0000187B                 retn
.text$mn:0000187B ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000187B
.text$mn:0000187B _text$mn        ends
.text$mn:0000187B
.text$mn:0000187C ; ===========================================================================
.text$mn:0000187C
.text$mn:0000187C ; Segment type: Pure code
.text$mn:0000187C ; Segment permissions: Read/Execute
.text$mn:0000187C _text$mn        segment para public 'CODE' use32
.text$mn:0000187C                 assume cs:_text$mn
.text$mn:0000187C                 ;org 187Ch
.text$mn:0000187C ; COMDAT (pick any)
.text$mn:0000187C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000187C
.text$mn:0000187C ; =============== S U B R O U T I N E =======================================
.text$mn:0000187C
.text$mn:0000187C ; Attributes: bp-based frame
.text$mn:0000187C
.text$mn:0000187C ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:0000187C                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:0000187C ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:0000187C                                         ; DATA XREF: .rdata:00001CE0o
.text$mn:0000187C
.text$mn:0000187C var_4           = dword ptr -4
.text$mn:0000187C
.text$mn:0000187C                 push    ebp
.text$mn:0000187D                 mov     ebp, esp
.text$mn:0000187F                 push    ecx
.text$mn:00001880                 mov     [ebp+var_4], ecx
.text$mn:00001883                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00001888                 mov     esp, ebp
.text$mn:0000188A                 pop     ebp
.text$mn:0000188B                 retn
.text$mn:0000188B ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:0000188B
.text$mn:0000188B _text$mn        ends
.text$mn:0000188B
.text$mn:0000188C ; ===========================================================================
.text$mn:0000188C
.text$mn:0000188C ; Segment type: Pure code
.text$mn:0000188C ; Segment permissions: Read/Execute
.text$mn:0000188C _text$mn        segment para public 'CODE' use32
.text$mn:0000188C                 assume cs:_text$mn
.text$mn:0000188C                 ;org 188Ch
.text$mn:0000188C ; COMDAT (pick any)
.text$mn:0000188C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000188C
.text$mn:0000188C ; =============== S U B R O U T I N E =======================================
.text$mn:0000188C
.text$mn:0000188C ; Attributes: bp-based frame
.text$mn:0000188C
.text$mn:0000188C ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:0000188C                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:0000188C ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:0000188C                                         ; DATA XREF: .rdata:00001D14o
.text$mn:0000188C
.text$mn:0000188C var_4           = dword ptr -4
.text$mn:0000188C
.text$mn:0000188C                 push    ebp
.text$mn:0000188D                 mov     ebp, esp
.text$mn:0000188F                 push    ecx
.text$mn:00001890                 mov     [ebp+var_4], ecx
.text$mn:00001893                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00001898                 mov     esp, ebp
.text$mn:0000189A                 pop     ebp
.text$mn:0000189B                 retn
.text$mn:0000189B ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:0000189B
.text$mn:0000189B _text$mn        ends
.text$mn:0000189B
.text$mn:0000189C ; ===========================================================================
.text$mn:0000189C
.text$mn:0000189C ; Segment type: Pure code
.text$mn:0000189C ; Segment permissions: Read/Execute
.text$mn:0000189C _text$mn        segment para public 'CODE' use32
.text$mn:0000189C                 assume cs:_text$mn
.text$mn:0000189C                 ;org 189Ch
.text$mn:0000189C ; COMDAT (pick any)
.text$mn:0000189C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000189C
.text$mn:0000189C ; =============== S U B R O U T I N E =======================================
.text$mn:0000189C
.text$mn:0000189C ; Attributes: bp-based frame
.text$mn:0000189C
.text$mn:0000189C ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:0000189C                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:0000189C ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:0000189C                                         ; DATA XREF: .rdata:00001D54o
.text$mn:0000189C
.text$mn:0000189C var_4           = dword ptr -4
.text$mn:0000189C
.text$mn:0000189C                 push    ebp
.text$mn:0000189D                 mov     ebp, esp
.text$mn:0000189F                 push    ecx
.text$mn:000018A0                 mov     [ebp+var_4], ecx
.text$mn:000018A3                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:000018A8                 mov     esp, ebp
.text$mn:000018AA                 pop     ebp
.text$mn:000018AB                 retn
.text$mn:000018AB ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:000018AB
.text$mn:000018AB _text$mn        ends
.text$mn:000018AB
.text$mn:000018AC ; ===========================================================================
.text$mn:000018AC
.text$mn:000018AC ; Segment type: Pure code
.text$mn:000018AC ; Segment permissions: Read/Execute
.text$mn:000018AC _text$mn        segment para public 'CODE' use32
.text$mn:000018AC                 assume cs:_text$mn
.text$mn:000018AC                 ;org 18ACh
.text$mn:000018AC ; COMDAT (pick any)
.text$mn:000018AC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000018AC
.text$mn:000018AC ; =============== S U B R O U T I N E =======================================
.text$mn:000018AC
.text$mn:000018AC ; Attributes: bp-based frame
.text$mn:000018AC
.text$mn:000018AC ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:000018AC                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:000018AC ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:000018AC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:000018AC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:000018AC
.text$mn:000018AC var_4           = dword ptr -4
.text$mn:000018AC
.text$mn:000018AC                 push    ebp
.text$mn:000018AD                 mov     ebp, esp
.text$mn:000018AF                 push    ecx
.text$mn:000018B0                 mov     [ebp+var_4], ecx
.text$mn:000018B3                 mov     eax, [ebp+var_4]
.text$mn:000018B6                 mov     eax, [eax+14h]
.text$mn:000018B9                 mov     esp, ebp
.text$mn:000018BB                 pop     ebp
.text$mn:000018BC                 retn
.text$mn:000018BC ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:000018BC
.text$mn:000018BC ; ---------------------------------------------------------------------------
.text$mn:000018BD                 align 10h
.text$mn:000018BD _text$mn        ends
.text$mn:000018BD
.text$mn:000018C0 ; ===========================================================================
.text$mn:000018C0
.text$mn:000018C0 ; Segment type: Pure code
.text$mn:000018C0 ; Segment permissions: Read/Execute
.text$mn:000018C0 _text$mn        segment para public 'CODE' use32
.text$mn:000018C0                 assume cs:_text$mn
.text$mn:000018C0                 ;org 18C0h
.text$mn:000018C0 ; COMDAT (pick any)
.text$mn:000018C0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000018C0
.text$mn:000018C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000018C0
.text$mn:000018C0 ; Attributes: bp-based frame
.text$mn:000018C0
.text$mn:000018C0 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:000018C0                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:000018C0 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000018C0                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_13F8p
.text$mn:000018C0                 push    ebp
.text$mn:000018C1                 mov     ebp, esp
.text$mn:000018C3                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:000018C8                 pop     ebp
.text$mn:000018C9                 retn
.text$mn:000018C9 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000018C9
.text$mn:000018C9 ; ---------------------------------------------------------------------------
.text$mn:000018CA                 align 4
.text$mn:000018CA _text$mn        ends
.text$mn:000018CA
.text$mn:000018CC ; ===========================================================================
.text$mn:000018CC
.text$mn:000018CC ; Segment type: Pure code
.text$mn:000018CC ; Segment permissions: Read/Execute
.text$mn:000018CC _text$mn        segment para public 'CODE' use32
.text$mn:000018CC                 assume cs:_text$mn
.text$mn:000018CC                 ;org 18CCh
.text$mn:000018CC ; COMDAT (pick any)
.text$mn:000018CC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000018CC
.text$mn:000018CC ; =============== S U B R O U T I N E =======================================
.text$mn:000018CC
.text$mn:000018CC ; Attributes: bp-based frame
.text$mn:000018CC
.text$mn:000018CC ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:000018CC                 public ?value@error_code@std@@QBEHXZ
.text$mn:000018CC ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:000018CC
.text$mn:000018CC var_4           = dword ptr -4
.text$mn:000018CC
.text$mn:000018CC                 push    ebp
.text$mn:000018CD                 mov     ebp, esp
.text$mn:000018CF                 push    ecx
.text$mn:000018D0                 mov     [ebp+var_4], ecx
.text$mn:000018D3                 mov     eax, [ebp+var_4]
.text$mn:000018D6                 mov     eax, [eax]
.text$mn:000018D8                 mov     esp, ebp
.text$mn:000018DA                 pop     ebp
.text$mn:000018DB                 retn
.text$mn:000018DB ?value@error_code@std@@QBEHXZ endp
.text$mn:000018DB
.text$mn:000018DB _text$mn        ends
.text$mn:000018DB
.text$mn:000018DC ; ===========================================================================
.text$mn:000018DC
.text$mn:000018DC ; Segment type: Pure code
.text$mn:000018DC ; Segment permissions: Read/Execute
.text$mn:000018DC _text$mn        segment para public 'CODE' use32
.text$mn:000018DC                 assume cs:_text$mn
.text$mn:000018DC                 ;org 18DCh
.text$mn:000018DC ; COMDAT (pick any)
.text$mn:000018DC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000018DC
.text$mn:000018DC ; =============== S U B R O U T I N E =======================================
.text$mn:000018DC
.text$mn:000018DC ; Attributes: bp-based frame
.text$mn:000018DC
.text$mn:000018DC ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:000018DC                 public ?value@error_condition@std@@QBEHXZ
.text$mn:000018DC ?value@error_condition@std@@QBEHXZ proc near
.text$mn:000018DC                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:000018DC                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:000018DC
.text$mn:000018DC var_4           = dword ptr -4
.text$mn:000018DC
.text$mn:000018DC                 push    ebp
.text$mn:000018DD                 mov     ebp, esp
.text$mn:000018DF                 push    ecx
.text$mn:000018E0                 mov     [ebp+var_4], ecx
.text$mn:000018E3                 mov     eax, [ebp+var_4]
.text$mn:000018E6                 mov     eax, [eax]
.text$mn:000018E8                 mov     esp, ebp
.text$mn:000018EA                 pop     ebp
.text$mn:000018EB                 retn
.text$mn:000018EB ?value@error_condition@std@@QBEHXZ endp
.text$mn:000018EB
.text$mn:000018EB _text$mn        ends
.text$mn:000018EB
.text$mn:000018EC ; ===========================================================================
.text$mn:000018EC
.text$mn:000018EC ; Segment type: Pure code
.text$mn:000018EC ; Segment permissions: Read/Execute
.text$mn:000018EC _text$mn        segment para public 'CODE' use32
.text$mn:000018EC                 assume cs:_text$mn
.text$mn:000018EC                 ;org 18ECh
.text$mn:000018EC ; COMDAT (pick any)
.text$mn:000018EC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000018EC
.text$mn:000018EC ; =============== S U B R O U T I N E =======================================
.text$mn:000018EC
.text$mn:000018EC ; Attributes: bp-based frame
.text$mn:000018EC
.text$mn:000018EC                 public _hypot
.text$mn:000018EC _hypot          proc near
.text$mn:000018EC
.text$mn:000018EC var_10          = qword ptr -10h
.text$mn:000018EC var_8           = qword ptr -8
.text$mn:000018EC arg_0           = qword ptr  8
.text$mn:000018EC arg_8           = qword ptr  10h
.text$mn:000018EC
.text$mn:000018EC                 push    ebp
.text$mn:000018ED                 mov     ebp, esp
.text$mn:000018EF                 sub     esp, 8
.text$mn:000018F2                 movsd   xmm0, [ebp+arg_8]
.text$mn:000018F7                 movsd   [esp+8+var_8], xmm0
.text$mn:000018FC                 sub     esp, 8
.text$mn:000018FF                 movsd   xmm0, [ebp+arg_0]
.text$mn:00001904                 movsd   [esp+10h+var_10], xmm0
.text$mn:00001909                 call    __hypot
.text$mn:0000190E                 add     esp, 10h
.text$mn:00001911                 pop     ebp
.text$mn:00001912                 retn
.text$mn:00001912 _hypot          endp
.text$mn:00001912
.text$mn:00001912 ; ---------------------------------------------------------------------------
.text$mn:00001913                 align 4
.text$mn:00001913 _text$mn        ends
.text$mn:00001913
.xdata$x:00001914 ; ===========================================================================
.xdata$x:00001914
.xdata$x:00001914 ; Segment type: Pure data
.xdata$x:00001914 ; Segment permissions: Read
.xdata$x:00001914 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001914                 assume cs:_xdata$x
.xdata$x:00001914                 ;org 1914h
.xdata$x:00001914 ; COMDAT (pick associative to section at F9C)
.xdata$x:00001914 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00001914                                         ; DATA XREF: .xdata$x:00001924o
.xdata$x:00001915                 db 0FFh
.xdata$x:00001916                 db 0FFh
.xdata$x:00001917                 db 0FFh
.xdata$x:00001918                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:0000191C __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:0000191C                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:0000191D                 db    5
.xdata$x:0000191E                 db  93h ; ô
.xdata$x:0000191F                 db  19h
.xdata$x:00001920                 db    1
.xdata$x:00001921                 db    0
.xdata$x:00001922                 db    0
.xdata$x:00001923                 db    0
.xdata$x:00001924                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00001928                 align 20h
.xdata$x:00001928 _xdata$x        ends
.xdata$x:00001928
.xdata$x:00001940 ; ===========================================================================
.xdata$x:00001940
.xdata$x:00001940 ; Segment type: Pure data
.xdata$x:00001940 ; Segment permissions: Read
.xdata$x:00001940 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001940                 assume cs:_xdata$x
.xdata$x:00001940                 ;org 1940h
.xdata$x:00001940 ; COMDAT (pick associative to section at 33C)
.xdata$x:00001940 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00001940                                         ; DATA XREF: .xdata$x:00001950o
.xdata$x:00001941                 db 0FFh
.xdata$x:00001942                 db 0FFh
.xdata$x:00001943                 db 0FFh
.xdata$x:00001944                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00001948 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00001948                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00001949                 db    5
.xdata$x:0000194A                 db  93h ; ô
.xdata$x:0000194B                 db  19h
.xdata$x:0000194C                 db    1
.xdata$x:0000194D                 db    0
.xdata$x:0000194E                 db    0
.xdata$x:0000194F                 db    0
.xdata$x:00001950                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00001954                 db    0
.xdata$x:00001955                 db    0
.xdata$x:00001956                 db    0
.xdata$x:00001957                 db    0
.xdata$x:00001958                 db    0
.xdata$x:00001959                 db    0
.xdata$x:0000195A                 db    0
.xdata$x:0000195B                 db    0
.xdata$x:0000195C                 db    0
.xdata$x:0000195D                 db    0
.xdata$x:0000195E                 db    0
.xdata$x:0000195F                 db    0
.xdata$x:00001960                 db    0
.xdata$x:00001961                 db    0
.xdata$x:00001962                 db    0
.xdata$x:00001963                 db    0
.xdata$x:00001964                 db    0
.xdata$x:00001965                 db    0
.xdata$x:00001966                 db    0
.xdata$x:00001967                 db    0
.xdata$x:00001968                 db    0
.xdata$x:00001969                 db    0
.xdata$x:0000196A                 db    0
.xdata$x:0000196B                 db    0
.xdata$x:0000196B _xdata$x        ends
.xdata$x:0000196B
.xdata$x:0000196C ; ===========================================================================
.xdata$x:0000196C
.xdata$x:0000196C ; Segment type: Pure data
.xdata$x:0000196C ; Segment permissions: Read
.xdata$x:0000196C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000196C                 assume cs:_xdata$x
.xdata$x:0000196C                 ;org 196Ch
.xdata$x:0000196C ; COMDAT (pick associative to section at 710)
.xdata$x:0000196C __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000196C                                         ; DATA XREF: .xdata$x:0000197Co
.xdata$x:0000196D                 db 0FFh
.xdata$x:0000196E                 db 0FFh
.xdata$x:0000196F                 db 0FFh
.xdata$x:00001970                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00001974 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00001974                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00001975                 db    5
.xdata$x:00001976                 db  93h ; ô
.xdata$x:00001977                 db  19h
.xdata$x:00001978                 db    1
.xdata$x:00001979                 db    0
.xdata$x:0000197A                 db    0
.xdata$x:0000197B                 db    0
.xdata$x:0000197C                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00001980                 db    0
.xdata$x:00001981                 db    0
.xdata$x:00001982                 db    0
.xdata$x:00001983                 db    0
.xdata$x:00001984                 db    0
.xdata$x:00001985                 db    0
.xdata$x:00001986                 db    0
.xdata$x:00001987                 db    0
.xdata$x:00001988                 db    0
.xdata$x:00001989                 db    0
.xdata$x:0000198A                 db    0
.xdata$x:0000198B                 db    0
.xdata$x:0000198C                 db    0
.xdata$x:0000198D                 db    0
.xdata$x:0000198E                 db    0
.xdata$x:0000198F                 db    0
.xdata$x:00001990                 db    0
.xdata$x:00001991                 db    0
.xdata$x:00001992                 db    0
.xdata$x:00001993                 db    0
.xdata$x:00001994                 db    0
.xdata$x:00001995                 db    0
.xdata$x:00001996                 db    0
.xdata$x:00001997                 db    0
.xdata$x:00001997 _xdata$x        ends
.xdata$x:00001997
.xdata$x:00001998 ; ===========================================================================
.xdata$x:00001998
.xdata$x:00001998 ; Segment type: Pure data
.xdata$x:00001998 ; Segment permissions: Read
.xdata$x:00001998 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001998                 assume cs:_xdata$x
.xdata$x:00001998                 ;org 1998h
.xdata$x:00001998 ; COMDAT (pick associative to section at 2C0)
.xdata$x:00001998 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00001998                                         ; DATA XREF: .xdata$x:000019A8o
.xdata$x:00001999                 db 0FFh
.xdata$x:0000199A                 db 0FFh
.xdata$x:0000199B                 db 0FFh
.xdata$x:0000199C                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:000019A0 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:000019A0                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:000019A1                 db    5
.xdata$x:000019A2                 db  93h ; ô
.xdata$x:000019A3                 db  19h
.xdata$x:000019A4                 db    1
.xdata$x:000019A5                 db    0
.xdata$x:000019A6                 db    0
.xdata$x:000019A7                 db    0
.xdata$x:000019A8                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:000019AC                 db    0
.xdata$x:000019AD                 db    0
.xdata$x:000019AE                 db    0
.xdata$x:000019AF                 db    0
.xdata$x:000019B0                 db    0
.xdata$x:000019B1                 db    0
.xdata$x:000019B2                 db    0
.xdata$x:000019B3                 db    0
.xdata$x:000019B4                 db    0
.xdata$x:000019B5                 db    0
.xdata$x:000019B6                 db    0
.xdata$x:000019B7                 db    0
.xdata$x:000019B8                 db    0
.xdata$x:000019B9                 db    0
.xdata$x:000019BA                 db    0
.xdata$x:000019BB                 db    0
.xdata$x:000019BC                 db    0
.xdata$x:000019BD                 db    0
.xdata$x:000019BE                 db    0
.xdata$x:000019BF                 db    0
.xdata$x:000019C0                 db    0
.xdata$x:000019C1                 db    0
.xdata$x:000019C2                 db    0
.xdata$x:000019C3                 db    0
.xdata$x:000019C3 _xdata$x        ends
.xdata$x:000019C3
.xdata$x:000019C4 ; ===========================================================================
.xdata$x:000019C4
.xdata$x:000019C4 ; Segment type: Pure data
.xdata$x:000019C4 ; Segment permissions: Read
.xdata$x:000019C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000019C4                 assume cs:_xdata$x
.xdata$x:000019C4                 ;org 19C4h
.xdata$x:000019C4 ; COMDAT (pick associative to section at 698)
.xdata$x:000019C4 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000019C4                                         ; DATA XREF: .xdata$x:000019D4o
.xdata$x:000019C5                 db 0FFh
.xdata$x:000019C6                 db 0FFh
.xdata$x:000019C7                 db 0FFh
.xdata$x:000019C8                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000019CC __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000019CC                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000019CD                 db    5
.xdata$x:000019CE                 db  93h ; ô
.xdata$x:000019CF                 db  19h
.xdata$x:000019D0                 db    1
.xdata$x:000019D1                 db    0
.xdata$x:000019D2                 db    0
.xdata$x:000019D3                 db    0
.xdata$x:000019D4                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:000019D8                 db    0
.xdata$x:000019D9                 db    0
.xdata$x:000019DA                 db    0
.xdata$x:000019DB                 db    0
.xdata$x:000019DC                 db    0
.xdata$x:000019DD                 db    0
.xdata$x:000019DE                 db    0
.xdata$x:000019DF                 db    0
.xdata$x:000019E0                 db    0
.xdata$x:000019E1                 db    0
.xdata$x:000019E2                 db    0
.xdata$x:000019E3                 db    0
.xdata$x:000019E4                 db    0
.xdata$x:000019E5                 db    0
.xdata$x:000019E6                 db    0
.xdata$x:000019E7                 db    0
.xdata$x:000019E8                 db    0
.xdata$x:000019E9                 db    0
.xdata$x:000019EA                 db    0
.xdata$x:000019EB                 db    0
.xdata$x:000019EC                 db    0
.xdata$x:000019ED                 db    0
.xdata$x:000019EE                 db    0
.xdata$x:000019EF                 db    0
.xdata$x:000019EF _xdata$x        ends
.xdata$x:000019EF
.xdata$x:000019F0 ; ===========================================================================
.xdata$x:000019F0
.xdata$x:000019F0 ; Segment type: Pure data
.xdata$x:000019F0 ; Segment permissions: Read
.xdata$x:000019F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000019F0                 assume cs:_xdata$x
.xdata$x:000019F0                 ;org 19F0h
.xdata$x:000019F0 ; COMDAT (pick associative to section at 3FC)
.xdata$x:000019F0 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:000019F0                                         ; DATA XREF: .xdata$x:00001A00o
.xdata$x:000019F1                 db 0FFh
.xdata$x:000019F2                 db 0FFh
.xdata$x:000019F3                 db 0FFh
.xdata$x:000019F4                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:000019F8 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:000019F8                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:000019F9                 db    5
.xdata$x:000019FA                 db  93h ; ô
.xdata$x:000019FB                 db  19h
.xdata$x:000019FC                 db    1
.xdata$x:000019FD                 db    0
.xdata$x:000019FE                 db    0
.xdata$x:000019FF                 db    0
.xdata$x:00001A00                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00001A04                 db    0
.xdata$x:00001A05                 db    0
.xdata$x:00001A06                 db    0
.xdata$x:00001A07                 db    0
.xdata$x:00001A08                 db    0
.xdata$x:00001A09                 db    0
.xdata$x:00001A0A                 db    0
.xdata$x:00001A0B                 db    0
.xdata$x:00001A0C                 db    0
.xdata$x:00001A0D                 db    0
.xdata$x:00001A0E                 db    0
.xdata$x:00001A0F                 db    0
.xdata$x:00001A10                 db    0
.xdata$x:00001A11                 db    0
.xdata$x:00001A12                 db    0
.xdata$x:00001A13                 db    0
.xdata$x:00001A14                 db    0
.xdata$x:00001A15                 db    0
.xdata$x:00001A16                 db    0
.xdata$x:00001A17                 db    0
.xdata$x:00001A18                 db    0
.xdata$x:00001A19                 db    0
.xdata$x:00001A1A                 db    0
.xdata$x:00001A1B                 db    0
.xdata$x:00001A1B _xdata$x        ends
.xdata$x:00001A1B
.xdata$x:00001A1C ; ===========================================================================
.xdata$x:00001A1C
.xdata$x:00001A1C ; Segment type: Pure data
.xdata$x:00001A1C ; Segment permissions: Read
.xdata$x:00001A1C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001A1C                 assume cs:_xdata$x
.xdata$x:00001A1C                 ;org 1A1Ch
.xdata$x:00001A1C ; COMDAT (pick associative to section at 780)
.xdata$x:00001A1C __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00001A1C                                         ; DATA XREF: .xdata$x:00001A2Co
.xdata$x:00001A1D                 db 0FFh
.xdata$x:00001A1E                 db 0FFh
.xdata$x:00001A1F                 db 0FFh
.xdata$x:00001A20                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00001A24 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00001A24                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00001A25                 db    5
.xdata$x:00001A26                 db  93h ; ô
.xdata$x:00001A27                 db  19h
.xdata$x:00001A28                 db    1
.xdata$x:00001A29                 db    0
.xdata$x:00001A2A                 db    0
.xdata$x:00001A2B                 db    0
.xdata$x:00001A2C                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00001A30                 db    0
.xdata$x:00001A31                 db    0
.xdata$x:00001A32                 db    0
.xdata$x:00001A33                 db    0
.xdata$x:00001A34                 db    0
.xdata$x:00001A35                 db    0
.xdata$x:00001A36                 db    0
.xdata$x:00001A37                 db    0
.xdata$x:00001A38                 db    0
.xdata$x:00001A39                 db    0
.xdata$x:00001A3A                 db    0
.xdata$x:00001A3B                 db    0
.xdata$x:00001A3C                 db    0
.xdata$x:00001A3D                 db    0
.xdata$x:00001A3E                 db    0
.xdata$x:00001A3F                 db    0
.xdata$x:00001A40                 db    0
.xdata$x:00001A41                 db    0
.xdata$x:00001A42                 db    0
.xdata$x:00001A43                 db    0
.xdata$x:00001A44                 db    0
.xdata$x:00001A45                 db    0
.xdata$x:00001A46                 db    0
.xdata$x:00001A47                 db    0
.xdata$x:00001A47 _xdata$x        ends
.xdata$x:00001A47
.xdata$x:00001A48 ; ===========================================================================
.xdata$x:00001A48
.xdata$x:00001A48 ; Segment type: Pure data
.xdata$x:00001A48 ; Segment permissions: Read
.xdata$x:00001A48 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001A48                 assume cs:_xdata$x
.xdata$x:00001A48                 ;org 1A48h
.xdata$x:00001A48 ; COMDAT (pick associative to section at BF8)
.xdata$x:00001A48 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00001A48                                         ; DATA XREF: .xdata$x:00001AD0o
.xdata$x:00001A49                 db    0
.xdata$x:00001A4A                 db    0
.xdata$x:00001A4B                 db    0
.xdata$x:00001A4C                 db    0
.xdata$x:00001A4D                 db    0
.xdata$x:00001A4E                 db    0
.xdata$x:00001A4F                 db    0
.xdata$x:00001A50                 db    0
.xdata$x:00001A51                 db    0
.xdata$x:00001A52                 db    0
.xdata$x:00001A53                 db    0
.xdata$x:00001A54                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00001A58 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00001A58                                         ; DATA XREF: .xdata$x:00001ABCo
.xdata$x:00001A59                 db    0
.xdata$x:00001A5A                 db    0
.xdata$x:00001A5B                 db    0
.xdata$x:00001A5C                 db    0
.xdata$x:00001A5D                 db    0
.xdata$x:00001A5E                 db    0
.xdata$x:00001A5F                 db    0
.xdata$x:00001A60                 db    0
.xdata$x:00001A61                 db    0
.xdata$x:00001A62                 db    0
.xdata$x:00001A63                 db    0
.xdata$x:00001A64                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00001A68 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00001A68                                         ; DATA XREF: .xdata$x:00001A90o
.xdata$x:00001A69                 db 0FFh
.xdata$x:00001A6A                 db 0FFh
.xdata$x:00001A6B                 db 0FFh
.xdata$x:00001A6C                 db    0
.xdata$x:00001A6D                 db    0
.xdata$x:00001A6E                 db    0
.xdata$x:00001A6F                 db    0
.xdata$x:00001A70                 db 0FFh
.xdata$x:00001A71                 db 0FFh
.xdata$x:00001A72                 db 0FFh
.xdata$x:00001A73                 db 0FFh
.xdata$x:00001A74                 db    0
.xdata$x:00001A75                 db    0
.xdata$x:00001A76                 db    0
.xdata$x:00001A77                 db    0
.xdata$x:00001A78                 db    1
.xdata$x:00001A79                 db    0
.xdata$x:00001A7A                 db    0
.xdata$x:00001A7B                 db    0
.xdata$x:00001A7C                 db    0
.xdata$x:00001A7D                 db    0
.xdata$x:00001A7E                 db    0
.xdata$x:00001A7F                 db    0
.xdata$x:00001A80                 db    1
.xdata$x:00001A81                 db    0
.xdata$x:00001A82                 db    0
.xdata$x:00001A83                 db    0
.xdata$x:00001A84                 db    0
.xdata$x:00001A85                 db    0
.xdata$x:00001A86                 db    0
.xdata$x:00001A87                 db    0
.xdata$x:00001A88 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00001A88                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00001A89                 db    5
.xdata$x:00001A8A                 db  93h ; ô
.xdata$x:00001A8B                 db  19h
.xdata$x:00001A8C                 db    4
.xdata$x:00001A8D                 db    0
.xdata$x:00001A8E                 db    0
.xdata$x:00001A8F                 db    0
.xdata$x:00001A90                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00001A94                 db    2
.xdata$x:00001A95                 db    0
.xdata$x:00001A96                 db    0
.xdata$x:00001A97                 db    0
.xdata$x:00001A98                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00001A9C                 db    0
.xdata$x:00001A9D                 db    0
.xdata$x:00001A9E                 db    0
.xdata$x:00001A9F                 db    0
.xdata$x:00001AA0                 db    0
.xdata$x:00001AA1                 db    0
.xdata$x:00001AA2                 db    0
.xdata$x:00001AA3                 db    0
.xdata$x:00001AA4                 db    0
.xdata$x:00001AA5                 db    0
.xdata$x:00001AA6                 db    0
.xdata$x:00001AA7                 db    0
.xdata$x:00001AA8                 db    0
.xdata$x:00001AA9                 db    0
.xdata$x:00001AAA                 db    0
.xdata$x:00001AAB                 db    0
.xdata$x:00001AAC __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00001AAC                                         ; DATA XREF: .xdata$x:00001A98o
.xdata$x:00001AAD                 db    0
.xdata$x:00001AAE                 db    0
.xdata$x:00001AAF                 db    0
.xdata$x:00001AB0                 db    2
.xdata$x:00001AB1                 db    0
.xdata$x:00001AB2                 db    0
.xdata$x:00001AB3                 db    0
.xdata$x:00001AB4                 db    3
.xdata$x:00001AB5                 db    0
.xdata$x:00001AB6                 db    0
.xdata$x:00001AB7                 db    0
.xdata$x:00001AB8                 db    1
.xdata$x:00001AB9                 db    0
.xdata$x:00001ABA                 db    0
.xdata$x:00001ABB                 db    0
.xdata$x:00001ABC                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00001AC0                 db    0
.xdata$x:00001AC1                 db    0
.xdata$x:00001AC2                 db    0
.xdata$x:00001AC3                 db    0
.xdata$x:00001AC4                 db    0
.xdata$x:00001AC5                 db    0
.xdata$x:00001AC6                 db    0
.xdata$x:00001AC7                 db    0
.xdata$x:00001AC8                 db    3
.xdata$x:00001AC9                 db    0
.xdata$x:00001ACA                 db    0
.xdata$x:00001ACB                 db    0
.xdata$x:00001ACC                 db    1
.xdata$x:00001ACD                 db    0
.xdata$x:00001ACE                 db    0
.xdata$x:00001ACF                 db    0
.xdata$x:00001AD0                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00001AD0 _xdata$x        ends
.xdata$x:00001AD0
.xdata$x:00001AD4 ; ===========================================================================
.xdata$x:00001AD4
.xdata$x:00001AD4 ; Segment type: Pure data
.xdata$x:00001AD4 ; Segment permissions: Read
.xdata$x:00001AD4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001AD4                 assume cs:_xdata$x
.xdata$x:00001AD4                 ;org 1AD4h
.xdata$x:00001AD4 ; COMDAT (pick associative to section at 4D0)
.xdata$x:00001AD4 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00001AD4                                         ; DATA XREF: .xdata$x:00001AE4o
.xdata$x:00001AD5                 db 0FFh
.xdata$x:00001AD6                 db 0FFh
.xdata$x:00001AD7                 db 0FFh
.xdata$x:00001AD8                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00001ADC __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00001ADC                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00001ADD                 db    5
.xdata$x:00001ADE                 db  93h ; ô
.xdata$x:00001ADF                 db  19h
.xdata$x:00001AE0                 db    1
.xdata$x:00001AE1                 db    0
.xdata$x:00001AE2                 db    0
.xdata$x:00001AE3                 db    0
.xdata$x:00001AE4                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00001AE8                 align 20h
.xdata$x:00001AE8 _xdata$x        ends
.xdata$x:00001AE8
.xdata$x:00001B00 ; ===========================================================================
.xdata$x:00001B00
.xdata$x:00001B00 ; Segment type: Pure data
.xdata$x:00001B00 ; Segment permissions: Read
.xdata$x:00001B00 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001B00                 assume cs:_xdata$x
.xdata$x:00001B00                 ;org 1B00h
.xdata$x:00001B00 ; COMDAT (pick associative to section at 1618)
.xdata$x:00001B00 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00001B00                                         ; DATA XREF: .xdata$x:00001B10o
.xdata$x:00001B01                 db 0FFh
.xdata$x:00001B02                 db 0FFh
.xdata$x:00001B03                 db 0FFh
.xdata$x:00001B04                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00001B08 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00001B08                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00001B09                 db    5
.xdata$x:00001B0A                 db  93h ; ô
.xdata$x:00001B0B                 db  19h
.xdata$x:00001B0C                 db    1
.xdata$x:00001B0D                 db    0
.xdata$x:00001B0E                 db    0
.xdata$x:00001B0F                 db    0
.xdata$x:00001B10                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00001B14                 db    0
.xdata$x:00001B15                 db    0
.xdata$x:00001B16                 db    0
.xdata$x:00001B17                 db    0
.xdata$x:00001B18                 db    0
.xdata$x:00001B19                 db    0
.xdata$x:00001B1A                 db    0
.xdata$x:00001B1B                 db    0
.xdata$x:00001B1C                 db    0
.xdata$x:00001B1D                 db    0
.xdata$x:00001B1E                 db    0
.xdata$x:00001B1F                 db    0
.xdata$x:00001B20                 db    0
.xdata$x:00001B21                 db    0
.xdata$x:00001B22                 db    0
.xdata$x:00001B23                 db    0
.xdata$x:00001B24                 db    0
.xdata$x:00001B25                 db    0
.xdata$x:00001B26                 db    0
.xdata$x:00001B27                 db    0
.xdata$x:00001B28                 db    0
.xdata$x:00001B29                 db    0
.xdata$x:00001B2A                 db    0
.xdata$x:00001B2B                 db    0
.xdata$x:00001B2B _xdata$x        ends
.xdata$x:00001B2B
.xdata$x:00001B2C ; ===========================================================================
.xdata$x:00001B2C
.xdata$x:00001B2C ; Segment type: Pure data
.xdata$x:00001B2C ; Segment permissions: Read
.xdata$x:00001B2C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001B2C                 assume cs:_xdata$x
.xdata$x:00001B2C                 ;org 1B2Ch
.xdata$x:00001B2C ; COMDAT (pick associative to section at 810)
.xdata$x:00001B2C __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00001B2C                                         ; DATA XREF: .xdata$x:00001B3Co
.xdata$x:00001B2D                 db 0FFh
.xdata$x:00001B2E                 db 0FFh
.xdata$x:00001B2F                 db 0FFh
.xdata$x:00001B30                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00001B34 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00001B34                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00001B35                 db    5
.xdata$x:00001B36                 db  93h ; ô
.xdata$x:00001B37                 db  19h
.xdata$x:00001B38                 db    1
.xdata$x:00001B39                 db    0
.xdata$x:00001B3A                 db    0
.xdata$x:00001B3B                 db    0
.xdata$x:00001B3C                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00001B40                 db    0
.xdata$x:00001B41                 db    0
.xdata$x:00001B42                 db    0
.xdata$x:00001B43                 db    0
.xdata$x:00001B44                 db    0
.xdata$x:00001B45                 db    0
.xdata$x:00001B46                 db    0
.xdata$x:00001B47                 db    0
.xdata$x:00001B48                 db    0
.xdata$x:00001B49                 db    0
.xdata$x:00001B4A                 db    0
.xdata$x:00001B4B                 db    0
.xdata$x:00001B4C                 db    0
.xdata$x:00001B4D                 db    0
.xdata$x:00001B4E                 db    0
.xdata$x:00001B4F                 db    0
.xdata$x:00001B50                 db    0
.xdata$x:00001B51                 db    0
.xdata$x:00001B52                 db    0
.xdata$x:00001B53                 db    0
.xdata$x:00001B54                 db    0
.xdata$x:00001B55                 db    0
.xdata$x:00001B56                 db    0
.xdata$x:00001B57                 db    0
.xdata$x:00001B57 _xdata$x        ends
.xdata$x:00001B57
.xdata$x:00001B58 ; ===========================================================================
.xdata$x:00001B58
.xdata$x:00001B58 ; Segment type: Pure data
.xdata$x:00001B58 ; Segment permissions: Read
.xdata$x:00001B58 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001B58                 assume cs:_xdata$x
.xdata$x:00001B58                 ;org 1B58h
.xdata$x:00001B58 ; COMDAT (pick associative to section at 54C)
.xdata$x:00001B58 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00001B58                                         ; DATA XREF: .xdata$x:00001B68o
.xdata$x:00001B59                 db 0FFh
.xdata$x:00001B5A                 db 0FFh
.xdata$x:00001B5B                 db 0FFh
.xdata$x:00001B5C                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00001B60 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00001B60                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00001B61                 db    5
.xdata$x:00001B62                 db  93h ; ô
.xdata$x:00001B63                 db  19h
.xdata$x:00001B64                 db    1
.xdata$x:00001B65                 db    0
.xdata$x:00001B66                 db    0
.xdata$x:00001B67                 db    0
.xdata$x:00001B68                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00001B6C                 db    0
.xdata$x:00001B6D                 db    0
.xdata$x:00001B6E                 db    0
.xdata$x:00001B6F                 db    0
.xdata$x:00001B70                 db    0
.xdata$x:00001B71                 db    0
.xdata$x:00001B72                 db    0
.xdata$x:00001B73                 db    0
.xdata$x:00001B74                 db    0
.xdata$x:00001B75                 db    0
.xdata$x:00001B76                 db    0
.xdata$x:00001B77                 db    0
.xdata$x:00001B78                 db    0
.xdata$x:00001B79                 db    0
.xdata$x:00001B7A                 db    0
.xdata$x:00001B7B                 db    0
.xdata$x:00001B7C                 db    0
.xdata$x:00001B7D                 db    0
.xdata$x:00001B7E                 db    0
.xdata$x:00001B7F                 db    0
.xdata$x:00001B80                 db    0
.xdata$x:00001B81                 db    0
.xdata$x:00001B82                 db    0
.xdata$x:00001B83                 db    0
.xdata$x:00001B83 _xdata$x        ends
.xdata$x:00001B83
.xdata$x:00001B84 ; ===========================================================================
.xdata$x:00001B84
.xdata$x:00001B84 ; Segment type: Pure data
.xdata$x:00001B84 ; Segment permissions: Read
.xdata$x:00001B84 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001B84                 assume cs:_xdata$x
.xdata$x:00001B84                 ;org 1B84h
.xdata$x:00001B84 ; COMDAT (pick associative to section at 16D0)
.xdata$x:00001B84 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00001B84                                         ; DATA XREF: .xdata$x:00001B94o
.xdata$x:00001B85                 db 0FFh
.xdata$x:00001B86                 db 0FFh
.xdata$x:00001B87                 db 0FFh
.xdata$x:00001B88                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00001B8C __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00001B8C                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00001B8D                 db    5
.xdata$x:00001B8E                 db  93h ; ô
.xdata$x:00001B8F                 db  19h
.xdata$x:00001B90                 db    1
.xdata$x:00001B91                 db    0
.xdata$x:00001B92                 db    0
.xdata$x:00001B93                 db    0
.xdata$x:00001B94                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00001B98                 db    0
.xdata$x:00001B99                 db    0
.xdata$x:00001B9A                 db    0
.xdata$x:00001B9B                 db    0
.xdata$x:00001B9C                 db    0
.xdata$x:00001B9D                 db    0
.xdata$x:00001B9E                 db    0
.xdata$x:00001B9F                 db    0
.xdata$x:00001BA0                 db    0
.xdata$x:00001BA1                 db    0
.xdata$x:00001BA2                 db    0
.xdata$x:00001BA3                 db    0
.xdata$x:00001BA4                 db    0
.xdata$x:00001BA5                 db    0
.xdata$x:00001BA6                 db    0
.xdata$x:00001BA7                 db    0
.xdata$x:00001BA8                 db    0
.xdata$x:00001BA9                 db    0
.xdata$x:00001BAA                 db    0
.xdata$x:00001BAB                 db    0
.xdata$x:00001BAC                 db    0
.xdata$x:00001BAD                 db    0
.xdata$x:00001BAE                 db    0
.xdata$x:00001BAF                 db    0
.xdata$x:00001BAF _xdata$x        ends
.xdata$x:00001BAF
.xdata$x:00001BB0 ; ===========================================================================
.xdata$x:00001BB0
.xdata$x:00001BB0 ; Segment type: Pure data
.xdata$x:00001BB0 ; Segment permissions: Read
.xdata$x:00001BB0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001BB0                 assume cs:_xdata$x
.xdata$x:00001BB0                 ;org 1BB0h
.xdata$x:00001BB0 ; COMDAT (pick associative to section at 880)
.xdata$x:00001BB0 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00001BB0                                         ; DATA XREF: .xdata$x:00001BC0o
.xdata$x:00001BB1                 db 0FFh
.xdata$x:00001BB2                 db 0FFh
.xdata$x:00001BB3                 db 0FFh
.xdata$x:00001BB4                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00001BB8 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00001BB8                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00001BB9                 db    5
.xdata$x:00001BBA                 db  93h ; ô
.xdata$x:00001BBB                 db  19h
.xdata$x:00001BBC                 db    1
.xdata$x:00001BBD                 db    0
.xdata$x:00001BBE                 db    0
.xdata$x:00001BBF                 db    0
.xdata$x:00001BC0                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00001BC4                 db    0
.xdata$x:00001BC5                 db    0
.xdata$x:00001BC6                 db    0
.xdata$x:00001BC7                 db    0
.xdata$x:00001BC8                 db    0
.xdata$x:00001BC9                 db    0
.xdata$x:00001BCA                 db    0
.xdata$x:00001BCB                 db    0
.xdata$x:00001BCC                 db    0
.xdata$x:00001BCD                 db    0
.xdata$x:00001BCE                 db    0
.xdata$x:00001BCF                 db    0
.xdata$x:00001BD0                 db    0
.xdata$x:00001BD1                 db    0
.xdata$x:00001BD2                 db    0
.xdata$x:00001BD3                 db    0
.xdata$x:00001BD4                 db    0
.xdata$x:00001BD5                 db    0
.xdata$x:00001BD6                 db    0
.xdata$x:00001BD7                 db    0
.xdata$x:00001BD8                 db    0
.xdata$x:00001BD9                 db    0
.xdata$x:00001BDA                 db    0
.xdata$x:00001BDB                 db    0
.xdata$x:00001BDB _xdata$x        ends
.xdata$x:00001BDB
.xdata$x:00001BDC ; ===========================================================================
.xdata$x:00001BDC
.xdata$x:00001BDC ; Segment type: Pure data
.xdata$x:00001BDC ; Segment permissions: Read
.xdata$x:00001BDC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001BDC                 assume cs:_xdata$x
.xdata$x:00001BDC                 ;org 1BDCh
.xdata$x:00001BDC ; COMDAT (pick associative to section at 5C8)
.xdata$x:00001BDC __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00001BDC                                         ; DATA XREF: .xdata$x:00001BECo
.xdata$x:00001BDD                 db 0FFh
.xdata$x:00001BDE                 db 0FFh
.xdata$x:00001BDF                 db 0FFh
.xdata$x:00001BE0                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00001BE4 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00001BE4                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00001BE5                 db    5
.xdata$x:00001BE6                 db  93h ; ô
.xdata$x:00001BE7                 db  19h
.xdata$x:00001BE8                 db    1
.xdata$x:00001BE9                 db    0
.xdata$x:00001BEA                 db    0
.xdata$x:00001BEB                 db    0
.xdata$x:00001BEC                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00001BF0                 db    0
.xdata$x:00001BF1                 db    0
.xdata$x:00001BF2                 db    0
.xdata$x:00001BF3                 db    0
.xdata$x:00001BF4                 db    0
.xdata$x:00001BF5                 db    0
.xdata$x:00001BF6                 db    0
.xdata$x:00001BF7                 db    0
.xdata$x:00001BF8                 db    0
.xdata$x:00001BF9                 db    0
.xdata$x:00001BFA                 db    0
.xdata$x:00001BFB                 db    0
.xdata$x:00001BFC                 db    0
.xdata$x:00001BFD                 db    0
.xdata$x:00001BFE                 db    0
.xdata$x:00001BFF                 db    0
.xdata$x:00001C00                 db    0
.xdata$x:00001C01                 db    0
.xdata$x:00001C02                 db    0
.xdata$x:00001C03                 db    0
.xdata$x:00001C04                 db    0
.xdata$x:00001C05                 db    0
.xdata$x:00001C06                 db    0
.xdata$x:00001C07                 db    0
.xdata$x:00001C07 _xdata$x        ends
.xdata$x:00001C07
.xdata$x:00001C08 ; ===========================================================================
.xdata$x:00001C08
.xdata$x:00001C08 ; Segment type: Pure data
.xdata$x:00001C08 ; Segment permissions: Read
.xdata$x:00001C08 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001C08                 assume cs:_xdata$x
.xdata$x:00001C08                 ;org 1C08h
.xdata$x:00001C08 ; COMDAT (pick associative to section at 1794)
.xdata$x:00001C08 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00001C08                                         ; DATA XREF: .xdata$x:00001C18o
.xdata$x:00001C09                 db 0FFh
.xdata$x:00001C0A                 db 0FFh
.xdata$x:00001C0B                 db 0FFh
.xdata$x:00001C0C                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00001C10 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00001C10                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00001C11                 db    5
.xdata$x:00001C12                 db  93h ; ô
.xdata$x:00001C13                 db  19h
.xdata$x:00001C14                 db    1
.xdata$x:00001C15                 db    0
.xdata$x:00001C16                 db    0
.xdata$x:00001C17                 db    0
.xdata$x:00001C18                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00001C1C                 db    0
.xdata$x:00001C1D                 db    0
.xdata$x:00001C1E                 db    0
.xdata$x:00001C1F                 db    0
.xdata$x:00001C20                 db    0
.xdata$x:00001C21                 db    0
.xdata$x:00001C22                 db    0
.xdata$x:00001C23                 db    0
.xdata$x:00001C24                 db    0
.xdata$x:00001C25                 db    0
.xdata$x:00001C26                 db    0
.xdata$x:00001C27                 db    0
.xdata$x:00001C28                 db    0
.xdata$x:00001C29                 db    0
.xdata$x:00001C2A                 db    0
.xdata$x:00001C2B                 db    0
.xdata$x:00001C2C                 db    0
.xdata$x:00001C2D                 db    0
.xdata$x:00001C2E                 db    0
.xdata$x:00001C2F                 db    0
.xdata$x:00001C30                 db    0
.xdata$x:00001C31                 db    0
.xdata$x:00001C32                 db    0
.xdata$x:00001C33                 db    0
.xdata$x:00001C33 _xdata$x        ends
.xdata$x:00001C33
.xdata$x:00001C34 ; ===========================================================================
.xdata$x:00001C34
.xdata$x:00001C34 ; Segment type: Pure data
.xdata$x:00001C34 ; Segment permissions: Read
.xdata$x:00001C34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001C34                 assume cs:_xdata$x
.xdata$x:00001C34                 ;org 1C34h
.xdata$x:00001C34 ; COMDAT (pick associative to section at 8F0)
.xdata$x:00001C34 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00001C34                                         ; DATA XREF: .xdata$x:00001C44o
.xdata$x:00001C35                 db 0FFh
.xdata$x:00001C36                 db 0FFh
.xdata$x:00001C37                 db 0FFh
.xdata$x:00001C38                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00001C3C __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00001C3C                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00001C3D                 db    5
.xdata$x:00001C3E                 db  93h ; ô
.xdata$x:00001C3F                 db  19h
.xdata$x:00001C40                 db    1
.xdata$x:00001C41                 db    0
.xdata$x:00001C42                 db    0
.xdata$x:00001C43                 db    0
.xdata$x:00001C44                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00001C48                 align 20h
.xdata$x:00001C48 _xdata$x        ends
.xdata$x:00001C48
.xdata$x:00001C60 ; ===========================================================================
.xdata$x:00001C60
.xdata$x:00001C60 ; Segment type: Pure data
.xdata$x:00001C60 ; Segment permissions: Read
.xdata$x:00001C60 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001C60                 assume cs:_xdata$x
.xdata$x:00001C60                 ;org 1C60h
.xdata$x:00001C60 ; COMDAT (pick associative to section at 1A4)
.xdata$x:00001C60 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00001C60                                         ; DATA XREF: .xdata$x:00001C70o
.xdata$x:00001C61                 db 0FFh
.xdata$x:00001C62                 db 0FFh
.xdata$x:00001C63                 db 0FFh
.xdata$x:00001C64                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00001C68 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00001C68                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00001C69                 db    5
.xdata$x:00001C6A                 db  93h ; ô
.xdata$x:00001C6B                 db  19h
.xdata$x:00001C6C                 db    1
.xdata$x:00001C6D                 db    0
.xdata$x:00001C6E                 db    0
.xdata$x:00001C6F                 db    0
.xdata$x:00001C70                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00001C74                 db    0
.xdata$x:00001C75                 db    0
.xdata$x:00001C76                 db    0
.xdata$x:00001C77                 db    0
.xdata$x:00001C78                 db    0
.xdata$x:00001C79                 db    0
.xdata$x:00001C7A                 db    0
.xdata$x:00001C7B                 db    0
.xdata$x:00001C7C                 db    0
.xdata$x:00001C7D                 db    0
.xdata$x:00001C7E                 db    0
.xdata$x:00001C7F                 db    0
.xdata$x:00001C80                 db    0
.xdata$x:00001C81                 db    0
.xdata$x:00001C82                 db    0
.xdata$x:00001C83                 db    0
.xdata$x:00001C84                 db    0
.xdata$x:00001C85                 db    0
.xdata$x:00001C86                 db    0
.xdata$x:00001C87                 db    0
.xdata$x:00001C88                 db    0
.xdata$x:00001C89                 db    0
.xdata$x:00001C8A                 db    0
.xdata$x:00001C8B                 db    0
.xdata$x:00001C8B _xdata$x        ends
.xdata$x:00001C8B
.xdata$x:00001C8C ; ===========================================================================
.xdata$x:00001C8C
.xdata$x:00001C8C ; Segment type: Pure data
.xdata$x:00001C8C ; Segment permissions: Read
.xdata$x:00001C8C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001C8C                 assume cs:_xdata$x
.xdata$x:00001C8C                 ;org 1C8Ch
.xdata$x:00001C8C ; COMDAT (pick associative to section at D0)
.xdata$x:00001C8C __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00001C8C                                         ; DATA XREF: .xdata$x:00001C9Co
.xdata$x:00001C8D                 db 0FFh
.xdata$x:00001C8E                 db 0FFh
.xdata$x:00001C8F                 db 0FFh
.xdata$x:00001C90                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00001C94 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00001C94                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00001C95                 db    5
.xdata$x:00001C96                 db  93h ; ô
.xdata$x:00001C97                 db  19h
.xdata$x:00001C98                 db    1
.xdata$x:00001C99                 db    0
.xdata$x:00001C9A                 db    0
.xdata$x:00001C9B                 db    0
.xdata$x:00001C9C                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00001CA0                 db    0
.xdata$x:00001CA1                 db    0
.xdata$x:00001CA2                 db    0
.xdata$x:00001CA3                 db    0
.xdata$x:00001CA4                 db    0
.xdata$x:00001CA5                 db    0
.xdata$x:00001CA6                 db    0
.xdata$x:00001CA7                 db    0
.xdata$x:00001CA8                 db    0
.xdata$x:00001CA9                 db    0
.xdata$x:00001CAA                 db    0
.xdata$x:00001CAB                 db    0
.xdata$x:00001CAC                 db    0
.xdata$x:00001CAD                 db    0
.xdata$x:00001CAE                 db    0
.xdata$x:00001CAF                 db    0
.xdata$x:00001CB0                 db    0
.xdata$x:00001CB1                 db    0
.xdata$x:00001CB2                 db    0
.xdata$x:00001CB3                 db    0
.xdata$x:00001CB4                 db    0
.xdata$x:00001CB5                 db    0
.xdata$x:00001CB6                 db    0
.xdata$x:00001CB7                 db    0
.xdata$x:00001CB7 _xdata$x        ends
.xdata$x:00001CB7
.bss:00001CB8 ; ===========================================================================
.bss:00001CB8
.bss:00001CB8 ; Segment type: Uninitialized
.bss:00001CB8 ; Segment permissions: Read/Write
.bss:00001CB8 _bss            segment byte public 'BSS' use32
.bss:00001CB8                 assume cs:_bss
.bss:00001CB8                 ;org 1CB8h
.bss:00001CB8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00001CB8 _allocator_arg  db    ? ;
.bss:00001CB9 _piecewise_construct db    ? ;
.bss:00001CBA                 align 4
.bss:00001CBA _bss            ends
.bss:00001CBA
.rdata:00001CBC ; ===========================================================================
.rdata:00001CBC
.rdata:00001CBC ; Segment type: Pure data
.rdata:00001CBC ; Segment permissions: Read
.rdata:00001CBC _rdata          segment dword public 'DATA' use32
.rdata:00001CBC                 assume cs:_rdata
.rdata:00001CBC                 ;org 1CBCh
.rdata:00001CBC ; COMDAT (pick largest)
.rdata:00001CBC                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00001CC0                 public ??_7error_category@std@@6B@
.rdata:00001CC0 ; const std::error_category::`vftable'
.rdata:00001CC0 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00001CC0                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00001CC0                                         ; std::error_category::~error_category(void)+Ao
.rdata:00001CC0                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00001CC4                 dd offset __purecall
.rdata:00001CC8                 dd offset __purecall
.rdata:00001CCC                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00001CD0                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00001CD4                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00001CD4 _rdata          ends
.rdata:00001CD4
.rdata:00001CD8 ; ===========================================================================
.rdata:00001CD8
.rdata:00001CD8 ; Segment type: Pure data
.rdata:00001CD8 ; Segment permissions: Read
.rdata:00001CD8 _rdata          segment dword public 'DATA' use32
.rdata:00001CD8                 assume cs:_rdata
.rdata:00001CD8                 ;org 1CD8h
.rdata:00001CD8 ; COMDAT (pick largest)
.rdata:00001CD8                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00001CDC                 public ??_7_Generic_error_category@std@@6B@
.rdata:00001CDC ; const std::_Generic_error_category::`vftable'
.rdata:00001CDC ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00001CDC                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00001CDC                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00001CE0                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00001CE4                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00001CE8                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00001CEC                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00001CF0                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00001CF0 _rdata          ends
.rdata:00001CF0
.rdata:00001CF4 ; ===========================================================================
.rdata:00001CF4
.rdata:00001CF4 ; Segment type: Pure data
.rdata:00001CF4 ; Segment permissions: Read
.rdata:00001CF4 _rdata          segment dword public 'DATA' use32
.rdata:00001CF4                 assume cs:_rdata
.rdata:00001CF4                 ;org 1CF4h
.rdata:00001CF4 ; COMDAT (pick any)
.rdata:00001CF4                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00001CF4 ; `string'
.rdata:00001CF4 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00001CF4                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00001CF4 _rdata          ends
.rdata:00001CF4
.rdata:00001CFC ; ===========================================================================
.rdata:00001CFC
.rdata:00001CFC ; Segment type: Pure data
.rdata:00001CFC ; Segment permissions: Read
.rdata:00001CFC _rdata          segment dword public 'DATA' use32
.rdata:00001CFC                 assume cs:_rdata
.rdata:00001CFC                 ;org 1CFCh
.rdata:00001CFC ; COMDAT (pick any)
.rdata:00001CFC                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00001CFC ; `string'
.rdata:00001CFC ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00001CFC                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_1664o
.rdata:00001CFC                                         ; std::_System_error_category::message(int):loc_17E0o
.rdata:00001D0A                 align 4
.rdata:00001D0A _rdata          ends
.rdata:00001D0A
.rdata:00001D0C ; ===========================================================================
.rdata:00001D0C
.rdata:00001D0C ; Segment type: Pure data
.rdata:00001D0C ; Segment permissions: Read
.rdata:00001D0C _rdata          segment dword public 'DATA' use32
.rdata:00001D0C                 assume cs:_rdata
.rdata:00001D0C                 ;org 1D0Ch
.rdata:00001D0C ; COMDAT (pick largest)
.rdata:00001D0C                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00001D10                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00001D10 ; const std::_Iostream_error_category::`vftable'
.rdata:00001D10 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00001D10                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00001D10                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00001D14                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00001D18                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00001D1C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00001D20                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00001D24                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00001D24 _rdata          ends
.rdata:00001D24
.rdata:00001D28 ; ===========================================================================
.rdata:00001D28
.rdata:00001D28 ; Segment type: Pure data
.rdata:00001D28 ; Segment permissions: Read
.rdata:00001D28 _rdata          segment dword public 'DATA' use32
.rdata:00001D28                 assume cs:_rdata
.rdata:00001D28                 ;org 1D28h
.rdata:00001D28 ; COMDAT (pick any)
.rdata:00001D28                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00001D28 ; `string'
.rdata:00001D28 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00001D28                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00001D31                 align 4
.rdata:00001D31 _rdata          ends
.rdata:00001D31
.rdata:00001D34 ; ===========================================================================
.rdata:00001D34
.rdata:00001D34 ; Segment type: Pure data
.rdata:00001D34 ; Segment permissions: Read
.rdata:00001D34 _rdata          segment dword public 'DATA' use32
.rdata:00001D34                 assume cs:_rdata
.rdata:00001D34                 ;org 1D34h
.rdata:00001D34 ; COMDAT (pick any)
.rdata:00001D34                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00001D34 ; char `string'[]
.rdata:00001D34 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00001D34                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00001D4A                 align 4
.rdata:00001D4A _rdata          ends
.rdata:00001D4A
.rdata:00001D4C ; ===========================================================================
.rdata:00001D4C
.rdata:00001D4C ; Segment type: Pure data
.rdata:00001D4C ; Segment permissions: Read
.rdata:00001D4C _rdata          segment dword public 'DATA' use32
.rdata:00001D4C                 assume cs:_rdata
.rdata:00001D4C                 ;org 1D4Ch
.rdata:00001D4C ; COMDAT (pick largest)
.rdata:00001D4C                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00001D50                 public ??_7_System_error_category@std@@6B@
.rdata:00001D50 ; const std::_System_error_category::`vftable'
.rdata:00001D50 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00001D50                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00001D50                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00001D54                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00001D58                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00001D5C                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00001D60                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00001D64                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00001D64 _rdata          ends
.rdata:00001D64
.rdata:00001D68 ; ===========================================================================
.rdata:00001D68
.rdata:00001D68 ; Segment type: Pure data
.rdata:00001D68 ; Segment permissions: Read
.rdata:00001D68 _rdata          segment dword public 'DATA' use32
.rdata:00001D68                 assume cs:_rdata
.rdata:00001D68                 ;org 1D68h
.rdata:00001D68 ; COMDAT (pick any)
.rdata:00001D68                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00001D68 ; `string'
.rdata:00001D68 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00001D68                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00001D6F                 align 10h
.rdata:00001D6F _rdata          ends
.rdata:00001D6F
.bss:00001D70 ; ===========================================================================
.bss:00001D70
.bss:00001D70 ; Segment type: Uninitialized
.bss:00001D70 ; Segment permissions: Read/Write
.bss:00001D70 _bss            segment dword public 'BSS' use32
.bss:00001D70                 assume cs:_bss
.bss:00001D70                 ;org 1D70h
.bss:00001D70 ; COMDAT (pick any)
.bss:00001D70                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00001D70                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00001D70 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00001D70 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00001D70                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00001D70                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00001D71                 db    ? ;
.bss:00001D72                 db    ? ;
.bss:00001D73                 db    ? ;
.bss:00001D73 _bss            ends
.bss:00001D73
.bss:00001D74 ; ===========================================================================
.bss:00001D74
.bss:00001D74 ; Segment type: Uninitialized
.bss:00001D74 ; Segment permissions: Read/Write
.bss:00001D74 _bss            segment dword public 'BSS' use32
.bss:00001D74                 assume cs:_bss
.bss:00001D74                 ;org 1D74h
.bss:00001D74 ; COMDAT (pick any)
.bss:00001D74                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00001D74                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00001D74 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00001D74 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00001D74                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00001D74                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00001D75                 db    ? ;
.bss:00001D76                 db    ? ;
.bss:00001D77                 db    ? ;
.bss:00001D77 _bss            ends
.bss:00001D77
.bss:00001D78 ; ===========================================================================
.bss:00001D78
.bss:00001D78 ; Segment type: Uninitialized
.bss:00001D78 ; Segment permissions: Read/Write
.bss:00001D78 _bss            segment dword public 'BSS' use32
.bss:00001D78                 assume cs:_bss
.bss:00001D78                 ;org 1D78h
.bss:00001D78 ; COMDAT (pick any)
.bss:00001D78                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00001D78                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00001D78 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00001D78 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00001D78                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00001D78                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00001D79                 db    ? ;
.bss:00001D7A                 db    ? ;
.bss:00001D7B                 db    ? ;
.bss:00001D7B _bss            ends
.bss:00001D7B
.bss:00001D7C ; ===========================================================================
.bss:00001D7C
.bss:00001D7C ; Segment type: Uninitialized
.bss:00001D7C ; Segment permissions: Read/Write
.bss:00001D7C _bss            segment dword public 'BSS' use32
.bss:00001D7C                 assume cs:_bss
.bss:00001D7C                 ;org 1D7Ch
.bss:00001D7C ; COMDAT (pick any)
.bss:00001D7C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00001D7C                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00001D7C ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00001D7C ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00001D7C                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00001D7D                 db    ? ;
.bss:00001D7E                 db    ? ;
.bss:00001D7F                 db    ? ;
.bss:00001D7F _bss            ends
.bss:00001D7F
.bss:00001D80 ; ===========================================================================
.bss:00001D80
.bss:00001D80 ; Segment type: Uninitialized
.bss:00001D80 ; Segment permissions: Read/Write
.bss:00001D80 _bss            segment dword public 'BSS' use32
.bss:00001D80                 assume cs:_bss
.bss:00001D80                 ;org 1D80h
.bss:00001D80 ; COMDAT (pick any)
.bss:00001D80                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00001D80                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00001D80 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00001D80 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00001D80                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00001D81                 db    ? ;
.bss:00001D82                 db    ? ;
.bss:00001D83                 db    ? ;
.bss:00001D83 _bss            ends
.bss:00001D83
.rdata:00001D84 ; ===========================================================================
.rdata:00001D84
.rdata:00001D84 ; Segment type: Pure data
.rdata:00001D84 ; Segment permissions: Read
.rdata:00001D84 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00001D84 _rdata          segment para public 'DATA' use32
.rdata:00001D84                 assume cs:_rdata
.rdata:00001D84                 ;org 1D84h
.rdata:00001D84 ; COMDAT (pick any)
.rdata:00001D84                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00001D84 ; wchar_t `string'
.rdata:00001D84 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00001D84                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00001D84                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:00001D84                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00001D84                 unicode 0, <clude\xstring>,0
.rdata:00001E12                 align 4
.rdata:00001E12 _rdata          ends
.rdata:00001E12
.bss:00001E14 ; ===========================================================================
.bss:00001E14
.bss:00001E14 ; Segment type: Uninitialized
.bss:00001E14 ; Segment permissions: Read/Write
.bss:00001E14 _bss            segment dword public 'BSS' use32
.bss:00001E14                 assume cs:_bss
.bss:00001E14                 ;org 1E14h
.bss:00001E14 ; COMDAT (pick any)
.bss:00001E14                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00001E14                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00001E14 ; std::locale::id std::numpunct<char>::id
.bss:00001E14 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00001E14                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00001E15                 db    ? ;
.bss:00001E16                 db    ? ;
.bss:00001E17                 db    ? ;
.bss:00001E17 _bss            ends
.bss:00001E17
.bss:00001E18 ; ===========================================================================
.bss:00001E18
.bss:00001E18 ; Segment type: Uninitialized
.bss:00001E18 ; Segment permissions: Read/Write
.bss:00001E18 _bss            segment dword public 'BSS' use32
.bss:00001E18                 assume cs:_bss
.bss:00001E18                 ;org 1E18h
.bss:00001E18 ; COMDAT (pick any)
.bss:00001E18                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00001E18                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00001E18 ; std::locale::id std::numpunct<wchar_t>::id
.bss:00001E18 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00001E18                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00001E19                 db    ? ;
.bss:00001E1A                 db    ? ;
.bss:00001E1B                 db    ? ;
.bss:00001E1B _bss            ends
.bss:00001E1B
.rdata:00001E1C ; ===========================================================================
.rdata:00001E1C
.rdata:00001E1C ; Segment type: Pure data
.rdata:00001E1C ; Segment permissions: Read
.rdata:00001E1C _rdata          segment dword public 'DATA' use32
.rdata:00001E1C                 assume cs:_rdata
.rdata:00001E1C                 ;org 1E1Ch
.rdata:00001E1C ; COMDAT (pick any)
.rdata:00001E1C                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00001E1C ; char `string'[]
.rdata:00001E1C ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00001E1C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00001E1C _rdata          ends
.rdata:00001E1C
.rdata:00001E2C ; ===========================================================================
.rdata:00001E2C
.rdata:00001E2C ; Segment type: Pure data
.rdata:00001E2C ; Segment permissions: Read
.rdata:00001E2C _rdata          segment dword public 'DATA' use32
.rdata:00001E2C                 assume cs:_rdata
.rdata:00001E2C                 ;org 1E2Ch
.rdata:00001E2C ; COMDAT (pick any)
.rdata:00001E2C                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00001E2C ; char `string'[]
.rdata:00001E2C ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00001E2C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00001E2C _rdata          ends
.rdata:00001E2C
.rdata:00001E44 ; ===========================================================================
.rdata:00001E44
.rdata:00001E44 ; Segment type: Pure data
.rdata:00001E44 ; Segment permissions: Read
.rdata:00001E44 _rdata          segment dword public 'DATA' use32
.rdata:00001E44                 assume cs:_rdata
.rdata:00001E44                 ;org 1E44h
.rdata:00001E44 ; COMDAT (pick any)
.rdata:00001E44                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00001E44 ; wchar_t `string'
.rdata:00001E44 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00001E44                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00001E44                 unicode 0, <invalid null pointer>,0
.rdata:00001E6E                 align 10h
.rdata:00001E6E _rdata          ends
.rdata:00001E6E
.rdata$r:00001E70 ; ===========================================================================
.rdata$r:00001E70
.rdata$r:00001E70 ; Segment type: Pure data
.rdata$r:00001E70 ; Segment permissions: Read
.rdata$r:00001E70 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001E70                 assume cs:_rdata$r
.rdata$r:00001E70                 ;org 1E70h
.rdata$r:00001E70 ; COMDAT (pick any)
.rdata$r:00001E70                 public ??_R4error_category@std@@6B@
.rdata$r:00001E70 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00001E70 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00001CBCo
.rdata$r:00001E71                 db    0
.rdata$r:00001E72                 db    0
.rdata$r:00001E73                 db    0
.rdata$r:00001E74                 db    0
.rdata$r:00001E75                 db    0
.rdata$r:00001E76                 db    0
.rdata$r:00001E77                 db    0
.rdata$r:00001E78                 db    0
.rdata$r:00001E79                 db    0
.rdata$r:00001E7A                 db    0
.rdata$r:00001E7B                 db    0
.rdata$r:00001E7C                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00001E80                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001E80 _rdata$r        ends
.rdata$r:00001E80
.data$r:00001E84 ; ===========================================================================
.data$r:00001E84
.data$r:00001E84 ; Segment type: Pure data
.data$r:00001E84 ; Segment permissions: Read/Write
.data$r:00001E84 _data$r         segment dword public 'DATA' use32
.data$r:00001E84                 assume cs:_data$r
.data$r:00001E84                 ;org 1E84h
.data$r:00001E84 ; COMDAT (pick any)
.data$r:00001E84                 public ??_R0?AVerror_category@std@@@8
.data$r:00001E84 ; class std::error_category `RTTI Type Descriptor'
.data$r:00001E84 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00001E84                                         ; DATA XREF: .rdata$r:00001E7Co
.data$r:00001E84                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00001E84                                         ; const type_info::`vftable'
.data$r:00001E88                 db    0
.data$r:00001E89                 db    0
.data$r:00001E8A                 db    0
.data$r:00001E8B                 db    0
.data$r:00001E8C                 db  2Eh ; .
.data$r:00001E8D                 db  3Fh ; ?
.data$r:00001E8E                 db  41h ; A
.data$r:00001E8F                 db  56h ; V
.data$r:00001E90                 db  65h ; e
.data$r:00001E91                 db  72h ; r
.data$r:00001E92                 db  72h ; r
.data$r:00001E93                 db  6Fh ; o
.data$r:00001E94                 db  72h ; r
.data$r:00001E95                 db  5Fh ; _
.data$r:00001E96                 db  63h ; c
.data$r:00001E97                 db  61h ; a
.data$r:00001E98                 db  74h ; t
.data$r:00001E99                 db  65h ; e
.data$r:00001E9A                 db  67h ; g
.data$r:00001E9B                 db  6Fh ; o
.data$r:00001E9C                 db  72h ; r
.data$r:00001E9D                 db  79h ; y
.data$r:00001E9E                 db  40h ; @
.data$r:00001E9F                 db  73h ; s
.data$r:00001EA0                 db  74h ; t
.data$r:00001EA1                 db  64h ; d
.data$r:00001EA2                 db  40h ; @
.data$r:00001EA3                 db  40h ; @
.data$r:00001EA4                 db    0
.data$r:00001EA5                 align 4
.data$r:00001EA5 _data$r         ends
.data$r:00001EA5
.rdata$r:00001EA8 ; ===========================================================================
.rdata$r:00001EA8
.rdata$r:00001EA8 ; Segment type: Pure data
.rdata$r:00001EA8 ; Segment permissions: Read
.rdata$r:00001EA8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001EA8                 assume cs:_rdata$r
.rdata$r:00001EA8                 ;org 1EA8h
.rdata$r:00001EA8 ; COMDAT (pick any)
.rdata$r:00001EA8                 public ??_R3error_category@std@@8
.rdata$r:00001EA8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001EA8 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00001E80o
.rdata$r:00001EA8                                         ; .rdata$r:00001ED8o
.rdata$r:00001EA9                 db    0
.rdata$r:00001EAA                 db    0
.rdata$r:00001EAB                 db    0
.rdata$r:00001EAC                 db    0
.rdata$r:00001EAD                 db    0
.rdata$r:00001EAE                 db    0
.rdata$r:00001EAF                 db    0
.rdata$r:00001EB0                 db    1
.rdata$r:00001EB1                 db    0
.rdata$r:00001EB2                 db    0
.rdata$r:00001EB3                 db    0
.rdata$r:00001EB4                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00001EB4 _rdata$r        ends
.rdata$r:00001EB4
.rdata$r:00001EB8 ; ===========================================================================
.rdata$r:00001EB8
.rdata$r:00001EB8 ; Segment type: Pure data
.rdata$r:00001EB8 ; Segment permissions: Read
.rdata$r:00001EB8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001EB8                 assume cs:_rdata$r
.rdata$r:00001EB8                 ;org 1EB8h
.rdata$r:00001EB8 ; COMDAT (pick any)
.rdata$r:00001EB8                 public ??_R2error_category@std@@8
.rdata$r:00001EB8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00001EB8 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00001EB8                                         ; DATA XREF: .rdata$r:00001EB4o
.rdata$r:00001EB8                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001EBC                 db    0
.rdata$r:00001EBD                 align 10h
.rdata$r:00001EBD _rdata$r        ends
.rdata$r:00001EBD
.rdata$r:00001EC0 ; ===========================================================================
.rdata$r:00001EC0
.rdata$r:00001EC0 ; Segment type: Pure data
.rdata$r:00001EC0 ; Segment permissions: Read
.rdata$r:00001EC0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001EC0                 assume cs:_rdata$r
.rdata$r:00001EC0                 ;org 1EC0h
.rdata$r:00001EC0 ; COMDAT (pick any)
.rdata$r:00001EC0                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00001EC0 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00001EC0 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00001EC0                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00001EC0                                         ; .rdata$r:00001F30o ...
.rdata$r:00001EC0                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00001EC4                 db    0
.rdata$r:00001EC5                 db    0
.rdata$r:00001EC6                 db    0
.rdata$r:00001EC7                 db    0
.rdata$r:00001EC8                 db    0
.rdata$r:00001EC9                 db    0
.rdata$r:00001ECA                 db    0
.rdata$r:00001ECB                 db    0
.rdata$r:00001ECC                 db 0FFh
.rdata$r:00001ECD                 db 0FFh
.rdata$r:00001ECE                 db 0FFh
.rdata$r:00001ECF                 db 0FFh
.rdata$r:00001ED0                 db    0
.rdata$r:00001ED1                 db    0
.rdata$r:00001ED2                 db    0
.rdata$r:00001ED3                 db    0
.rdata$r:00001ED4                 db  40h ; @
.rdata$r:00001ED5                 db    0
.rdata$r:00001ED6                 db    0
.rdata$r:00001ED7                 db    0
.rdata$r:00001ED8                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001ED8 _rdata$r        ends
.rdata$r:00001ED8
.rdata$r:00001EDC ; ===========================================================================
.rdata$r:00001EDC
.rdata$r:00001EDC ; Segment type: Pure data
.rdata$r:00001EDC ; Segment permissions: Read
.rdata$r:00001EDC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001EDC                 assume cs:_rdata$r
.rdata$r:00001EDC                 ;org 1EDCh
.rdata$r:00001EDC ; COMDAT (pick any)
.rdata$r:00001EDC                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00001EDC ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00001EDC ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00001EDC                                         ; DATA XREF: .rdata:00001CD8o
.rdata$r:00001EDD                 db    0
.rdata$r:00001EDE                 db    0
.rdata$r:00001EDF                 db    0
.rdata$r:00001EE0                 db    0
.rdata$r:00001EE1                 db    0
.rdata$r:00001EE2                 db    0
.rdata$r:00001EE3                 db    0
.rdata$r:00001EE4                 db    0
.rdata$r:00001EE5                 db    0
.rdata$r:00001EE6                 db    0
.rdata$r:00001EE7                 db    0
.rdata$r:00001EE8                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00001EEC                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001EEC _rdata$r        ends
.rdata$r:00001EEC
.data$r:00001EF0 ; ===========================================================================
.data$r:00001EF0
.data$r:00001EF0 ; Segment type: Pure data
.data$r:00001EF0 ; Segment permissions: Read/Write
.data$r:00001EF0 _data$r         segment dword public 'DATA' use32
.data$r:00001EF0                 assume cs:_data$r
.data$r:00001EF0                 ;org 1EF0h
.data$r:00001EF0 ; COMDAT (pick any)
.data$r:00001EF0                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00001EF0 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00001EF0 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00001EF0                                         ; DATA XREF: .rdata$r:00001EE8o
.data$r:00001EF0                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00001EF0                                         ; const type_info::`vftable'
.data$r:00001EF4                 align 8
.data$r:00001EF8 a_?av_generic_e db '.?AV_Generic_error_category@std@@',0
.data$r:00001F1A                 align 4
.data$r:00001F1A _data$r         ends
.data$r:00001F1A
.rdata$r:00001F1C ; ===========================================================================
.rdata$r:00001F1C
.rdata$r:00001F1C ; Segment type: Pure data
.rdata$r:00001F1C ; Segment permissions: Read
.rdata$r:00001F1C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001F1C                 assume cs:_rdata$r
.rdata$r:00001F1C                 ;org 1F1Ch
.rdata$r:00001F1C ; COMDAT (pick any)
.rdata$r:00001F1C                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00001F1C ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001F1C ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00001F1C                                         ; DATA XREF: .rdata$r:00001EECo
.rdata$r:00001F1C                                         ; .rdata$r:00001F50o
.rdata$r:00001F1D                 db    0
.rdata$r:00001F1E                 db    0
.rdata$r:00001F1F                 db    0
.rdata$r:00001F20                 db    0
.rdata$r:00001F21                 db    0
.rdata$r:00001F22                 db    0
.rdata$r:00001F23                 db    0
.rdata$r:00001F24                 db    2
.rdata$r:00001F25                 db    0
.rdata$r:00001F26                 db    0
.rdata$r:00001F27                 db    0
.rdata$r:00001F28                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00001F28 _rdata$r        ends
.rdata$r:00001F28
.rdata$r:00001F2C ; ===========================================================================
.rdata$r:00001F2C
.rdata$r:00001F2C ; Segment type: Pure data
.rdata$r:00001F2C ; Segment permissions: Read
.rdata$r:00001F2C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001F2C                 assume cs:_rdata$r
.rdata$r:00001F2C                 ;org 1F2Ch
.rdata$r:00001F2C ; COMDAT (pick any)
.rdata$r:00001F2C                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00001F2C ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00001F2C ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00001F2C                                         ; DATA XREF: .rdata$r:00001F28o
.rdata$r:00001F2C                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001F30                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001F34                 db    0
.rdata$r:00001F35                 align 4
.rdata$r:00001F35 _rdata$r        ends
.rdata$r:00001F35
.rdata$r:00001F38 ; ===========================================================================
.rdata$r:00001F38
.rdata$r:00001F38 ; Segment type: Pure data
.rdata$r:00001F38 ; Segment permissions: Read
.rdata$r:00001F38 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001F38                 assume cs:_rdata$r
.rdata$r:00001F38                 ;org 1F38h
.rdata$r:00001F38 ; COMDAT (pick any)
.rdata$r:00001F38                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00001F38 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00001F38 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00001F38                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00001F38                                         ; .rdata$r:00001FA8o ...
.rdata$r:00001F38                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00001F3C                 db    1
.rdata$r:00001F3D                 db    0
.rdata$r:00001F3E                 db    0
.rdata$r:00001F3F                 db    0
.rdata$r:00001F40                 db    0
.rdata$r:00001F41                 db    0
.rdata$r:00001F42                 db    0
.rdata$r:00001F43                 db    0
.rdata$r:00001F44                 db 0FFh
.rdata$r:00001F45                 db 0FFh
.rdata$r:00001F46                 db 0FFh
.rdata$r:00001F47                 db 0FFh
.rdata$r:00001F48                 db    0
.rdata$r:00001F49                 db    0
.rdata$r:00001F4A                 db    0
.rdata$r:00001F4B                 db    0
.rdata$r:00001F4C                 db  40h ; @
.rdata$r:00001F4D                 db    0
.rdata$r:00001F4E                 db    0
.rdata$r:00001F4F                 db    0
.rdata$r:00001F50                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001F50 _rdata$r        ends
.rdata$r:00001F50
.rdata$r:00001F54 ; ===========================================================================
.rdata$r:00001F54
.rdata$r:00001F54 ; Segment type: Pure data
.rdata$r:00001F54 ; Segment permissions: Read
.rdata$r:00001F54 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001F54                 assume cs:_rdata$r
.rdata$r:00001F54                 ;org 1F54h
.rdata$r:00001F54 ; COMDAT (pick any)
.rdata$r:00001F54                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00001F54 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00001F54 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00001F54                                         ; DATA XREF: .rdata:00001D0Co
.rdata$r:00001F55                 db    0
.rdata$r:00001F56                 db    0
.rdata$r:00001F57                 db    0
.rdata$r:00001F58                 db    0
.rdata$r:00001F59                 db    0
.rdata$r:00001F5A                 db    0
.rdata$r:00001F5B                 db    0
.rdata$r:00001F5C                 db    0
.rdata$r:00001F5D                 db    0
.rdata$r:00001F5E                 db    0
.rdata$r:00001F5F                 db    0
.rdata$r:00001F60                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00001F64                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001F64 _rdata$r        ends
.rdata$r:00001F64
.data$r:00001F68 ; ===========================================================================
.data$r:00001F68
.data$r:00001F68 ; Segment type: Pure data
.data$r:00001F68 ; Segment permissions: Read/Write
.data$r:00001F68 _data$r         segment dword public 'DATA' use32
.data$r:00001F68                 assume cs:_data$r
.data$r:00001F68                 ;org 1F68h
.data$r:00001F68 ; COMDAT (pick any)
.data$r:00001F68                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:00001F68 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:00001F68 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00001F68                                         ; DATA XREF: .rdata$r:00001F60o
.data$r:00001F68                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00001F68                                         ; const type_info::`vftable'
.data$r:00001F6C                 align 10h
.data$r:00001F70 a_?av_iostream_ db '.?AV_Iostream_error_category@std@@',0
.data$r:00001F93                 align 4
.data$r:00001F93 _data$r         ends
.data$r:00001F93
.rdata$r:00001F94 ; ===========================================================================
.rdata$r:00001F94
.rdata$r:00001F94 ; Segment type: Pure data
.rdata$r:00001F94 ; Segment permissions: Read
.rdata$r:00001F94 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001F94                 assume cs:_rdata$r
.rdata$r:00001F94                 ;org 1F94h
.rdata$r:00001F94 ; COMDAT (pick any)
.rdata$r:00001F94                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00001F94 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001F94 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00001F94                                         ; DATA XREF: .rdata$r:00001F64o
.rdata$r:00001F94                                         ; .rdata$r:00001FCCo
.rdata$r:00001F95                 db    0
.rdata$r:00001F96                 db    0
.rdata$r:00001F97                 db    0
.rdata$r:00001F98                 db    0
.rdata$r:00001F99                 db    0
.rdata$r:00001F9A                 db    0
.rdata$r:00001F9B                 db    0
.rdata$r:00001F9C                 db    3
.rdata$r:00001F9D                 db    0
.rdata$r:00001F9E                 db    0
.rdata$r:00001F9F                 db    0
.rdata$r:00001FA0                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00001FA0 _rdata$r        ends
.rdata$r:00001FA0
.rdata$r:00001FA4 ; ===========================================================================
.rdata$r:00001FA4
.rdata$r:00001FA4 ; Segment type: Pure data
.rdata$r:00001FA4 ; Segment permissions: Read
.rdata$r:00001FA4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001FA4                 assume cs:_rdata$r
.rdata$r:00001FA4                 ;org 1FA4h
.rdata$r:00001FA4 ; COMDAT (pick any)
.rdata$r:00001FA4                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00001FA4 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00001FA4 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00001FA4                                         ; DATA XREF: .rdata$r:00001FA0o
.rdata$r:00001FA4                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001FA8                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001FAC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00001FB0                 db    0
.rdata$r:00001FB1                 align 4
.rdata$r:00001FB1 _rdata$r        ends
.rdata$r:00001FB1
.rdata$r:00001FB4 ; ===========================================================================
.rdata$r:00001FB4
.rdata$r:00001FB4 ; Segment type: Pure data
.rdata$r:00001FB4 ; Segment permissions: Read
.rdata$r:00001FB4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001FB4                 assume cs:_rdata$r
.rdata$r:00001FB4                 ;org 1FB4h
.rdata$r:00001FB4 ; COMDAT (pick any)
.rdata$r:00001FB4                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00001FB4 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00001FB4 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00001FB4                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00001FB4                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00001FB8                 db    2
.rdata$r:00001FB9                 db    0
.rdata$r:00001FBA                 db    0
.rdata$r:00001FBB                 db    0
.rdata$r:00001FBC                 db    0
.rdata$r:00001FBD                 db    0
.rdata$r:00001FBE                 db    0
.rdata$r:00001FBF                 db    0
.rdata$r:00001FC0                 db 0FFh
.rdata$r:00001FC1                 db 0FFh
.rdata$r:00001FC2                 db 0FFh
.rdata$r:00001FC3                 db 0FFh
.rdata$r:00001FC4                 db    0
.rdata$r:00001FC5                 db    0
.rdata$r:00001FC6                 db    0
.rdata$r:00001FC7                 db    0
.rdata$r:00001FC8                 db  40h ; @
.rdata$r:00001FC9                 db    0
.rdata$r:00001FCA                 db    0
.rdata$r:00001FCB                 db    0
.rdata$r:00001FCC                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001FCC _rdata$r        ends
.rdata$r:00001FCC
.rdata$r:00001FD0 ; ===========================================================================
.rdata$r:00001FD0
.rdata$r:00001FD0 ; Segment type: Pure data
.rdata$r:00001FD0 ; Segment permissions: Read
.rdata$r:00001FD0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00001FD0                 assume cs:_rdata$r
.rdata$r:00001FD0                 ;org 1FD0h
.rdata$r:00001FD0 ; COMDAT (pick any)
.rdata$r:00001FD0                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00001FD0 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00001FD0 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00001D4Co
.rdata$r:00001FD1                 db    0
.rdata$r:00001FD2                 db    0
.rdata$r:00001FD3                 db    0
.rdata$r:00001FD4                 db    0
.rdata$r:00001FD5                 db    0
.rdata$r:00001FD6                 db    0
.rdata$r:00001FD7                 db    0
.rdata$r:00001FD8                 db    0
.rdata$r:00001FD9                 db    0
.rdata$r:00001FDA                 db    0
.rdata$r:00001FDB                 db    0
.rdata$r:00001FDC                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00001FE0                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00001FE0 _rdata$r        ends
.rdata$r:00001FE0
.data$r:00001FE4 ; ===========================================================================
.data$r:00001FE4
.data$r:00001FE4 ; Segment type: Pure data
.data$r:00001FE4 ; Segment permissions: Read/Write
.data$r:00001FE4 _data$r         segment dword public 'DATA' use32
.data$r:00001FE4                 assume cs:_data$r
.data$r:00001FE4                 ;org 1FE4h
.data$r:00001FE4 ; COMDAT (pick any)
.data$r:00001FE4                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00001FE4 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00001FE4 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00001FE4                                         ; DATA XREF: .rdata$r:00001FDCo
.data$r:00001FE4                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00001FE4                                         ; const type_info::`vftable'
.data$r:00001FE8                 db    0
.data$r:00001FE9                 db    0
.data$r:00001FEA                 db    0
.data$r:00001FEB                 db    0
.data$r:00001FEC                 db  2Eh ; .
.data$r:00001FED                 db  3Fh ; ?
.data$r:00001FEE                 db  41h ; A
.data$r:00001FEF                 db  56h ; V
.data$r:00001FF0                 db  5Fh ; _
.data$r:00001FF1                 db  53h ; S
.data$r:00001FF2                 db  79h ; y
.data$r:00001FF3                 db  73h ; s
.data$r:00001FF4                 db  74h ; t
.data$r:00001FF5                 db  65h ; e
.data$r:00001FF6                 db  6Dh ; m
.data$r:00001FF7                 db  5Fh ; _
.data$r:00001FF8                 db  65h ; e
.data$r:00001FF9                 db  72h ; r
.data$r:00001FFA                 db  72h ; r
.data$r:00001FFB                 db  6Fh ; o
.data$r:00001FFC                 db  72h ; r
.data$r:00001FFD                 db  5Fh ; _
.data$r:00001FFE                 db  63h ; c
.data$r:00001FFF                 db  61h ; a
.data$r:00002000                 db  74h ; t
.data$r:00002001                 db  65h ; e
.data$r:00002002                 db  67h ; g
.data$r:00002003                 db  6Fh ; o
.data$r:00002004                 db  72h ; r
.data$r:00002005                 db  79h ; y
.data$r:00002006                 db  40h ; @
.data$r:00002007                 db  73h ; s
.data$r:00002008                 db  74h ; t
.data$r:00002009                 db  64h ; d
.data$r:0000200A                 db  40h ; @
.data$r:0000200B                 db  40h ; @
.data$r:0000200C                 db    0
.data$r:0000200D                 align 10h
.data$r:0000200D _data$r         ends
.data$r:0000200D
.rdata$r:00002010 ; ===========================================================================
.rdata$r:00002010
.rdata$r:00002010 ; Segment type: Pure data
.rdata$r:00002010 ; Segment permissions: Read
.rdata$r:00002010 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002010                 assume cs:_rdata$r
.rdata$r:00002010                 ;org 2010h
.rdata$r:00002010 ; COMDAT (pick any)
.rdata$r:00002010                 public ??_R3_System_error_category@std@@8
.rdata$r:00002010 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002010 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00001FE0o
.rdata$r:00002010                                         ; .rdata$r:00002048o
.rdata$r:00002011                 db    0
.rdata$r:00002012                 db    0
.rdata$r:00002013                 db    0
.rdata$r:00002014                 db    0
.rdata$r:00002015                 db    0
.rdata$r:00002016                 db    0
.rdata$r:00002017                 db    0
.rdata$r:00002018                 db    3
.rdata$r:00002019                 db    0
.rdata$r:0000201A                 db    0
.rdata$r:0000201B                 db    0
.rdata$r:0000201C                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000201C _rdata$r        ends
.rdata$r:0000201C
.rdata$r:00002020 ; ===========================================================================
.rdata$r:00002020
.rdata$r:00002020 ; Segment type: Pure data
.rdata$r:00002020 ; Segment permissions: Read
.rdata$r:00002020 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002020                 assume cs:_rdata$r
.rdata$r:00002020                 ;org 2020h
.rdata$r:00002020 ; COMDAT (pick any)
.rdata$r:00002020                 public ??_R2_System_error_category@std@@8
.rdata$r:00002020 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00002020 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00002020                                         ; DATA XREF: .rdata$r:0000201Co
.rdata$r:00002020                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002024                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002028                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000202C                 db    0
.rdata$r:0000202D                 align 10h
.rdata$r:0000202D _rdata$r        ends
.rdata$r:0000202D
.rdata$r:00002030 ; ===========================================================================
.rdata$r:00002030
.rdata$r:00002030 ; Segment type: Pure data
.rdata$r:00002030 ; Segment permissions: Read
.rdata$r:00002030 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002030                 assume cs:_rdata$r
.rdata$r:00002030                 ;org 2030h
.rdata$r:00002030 ; COMDAT (pick any)
.rdata$r:00002030                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00002030 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002030 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00002030                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00002030                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00002034                 db    2
.rdata$r:00002035                 db    0
.rdata$r:00002036                 db    0
.rdata$r:00002037                 db    0
.rdata$r:00002038                 db    0
.rdata$r:00002039                 db    0
.rdata$r:0000203A                 db    0
.rdata$r:0000203B                 db    0
.rdata$r:0000203C                 db 0FFh
.rdata$r:0000203D                 db 0FFh
.rdata$r:0000203E                 db 0FFh
.rdata$r:0000203F                 db 0FFh
.rdata$r:00002040                 db    0
.rdata$r:00002041                 db    0
.rdata$r:00002042                 db    0
.rdata$r:00002043                 db    0
.rdata$r:00002044                 db  40h ; @
.rdata$r:00002045                 db    0
.rdata$r:00002046                 db    0
.rdata$r:00002047                 db    0
.rdata$r:00002048                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002048 _rdata$r        ends
.rdata$r:00002048
.CRT$XCU:0000204C ; ===========================================================================
.CRT$XCU:0000204C
.CRT$XCU:0000204C ; Segment type: Pure data
.CRT$XCU:0000204C ; Segment permissions: Read
.CRT$XCU:0000204C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000204C                 assume cs:_CRT$XCU
.CRT$XCU:0000204C                 ;org 204Ch
.CRT$XCU:0000204C _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00002050 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00002050 _CRT$XCU        ends
.CRT$XCU:00002050
.CRT$XCU:00002054 ; ===========================================================================
.CRT$XCU:00002054
.CRT$XCU:00002054 ; Segment type: Pure data
.CRT$XCU:00002054 ; Segment permissions: Read
.CRT$XCU:00002054 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002054                 assume cs:_CRT$XCU
.CRT$XCU:00002054                 ;org 2054h
.CRT$XCU:00002054 ; COMDAT (pick associative to section at 1D70)
.CRT$XCU:00002054 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00002054 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00002054 _CRT$XCU        ends
.CRT$XCU:00002054
.CRT$XCU:00002058 ; ===========================================================================
.CRT$XCU:00002058
.CRT$XCU:00002058 ; Segment type: Pure data
.CRT$XCU:00002058 ; Segment permissions: Read
.CRT$XCU:00002058 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002058                 assume cs:_CRT$XCU
.CRT$XCU:00002058                 ;org 2058h
.CRT$XCU:00002058 ; COMDAT (pick associative to section at 1D74)
.CRT$XCU:00002058 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:00002058 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:00002058 _CRT$XCU        ends
.CRT$XCU:00002058
.CRT$XCU:0000205C ; ===========================================================================
.CRT$XCU:0000205C
.CRT$XCU:0000205C ; Segment type: Pure data
.CRT$XCU:0000205C ; Segment permissions: Read
.CRT$XCU:0000205C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000205C                 assume cs:_CRT$XCU
.CRT$XCU:0000205C                 ;org 205Ch
.CRT$XCU:0000205C ; COMDAT (pick associative to section at 1D78)
.CRT$XCU:0000205C ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:0000205C ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:0000205C _CRT$XCU        ends
.CRT$XCU:0000205C
.CRT$XCU:00002060 ; ===========================================================================
.CRT$XCU:00002060
.CRT$XCU:00002060 ; Segment type: Pure data
.CRT$XCU:00002060 ; Segment permissions: Read
.CRT$XCU:00002060 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002060                 assume cs:_CRT$XCU
.CRT$XCU:00002060                 ;org 2060h
.CRT$XCU:00002060 ; COMDAT (pick associative to section at 1D7C)
.CRT$XCU:00002060 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00002060 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00002060 _CRT$XCU        ends
.CRT$XCU:00002060
.CRT$XCU:00002064 ; ===========================================================================
.CRT$XCU:00002064
.CRT$XCU:00002064 ; Segment type: Pure data
.CRT$XCU:00002064 ; Segment permissions: Read
.CRT$XCU:00002064 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002064                 assume cs:_CRT$XCU
.CRT$XCU:00002064                 ;org 2064h
.CRT$XCU:00002064 ; COMDAT (pick associative to section at 1D80)
.CRT$XCU:00002064 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:00002064 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:00002064 _CRT$XCU        ends
.CRT$XCU:00002064
.CRT$XCU:00002068 ; ===========================================================================
.CRT$XCU:00002068
.CRT$XCU:00002068 ; Segment type: Pure data
.CRT$XCU:00002068 ; Segment permissions: Read
.CRT$XCU:00002068 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002068                 assume cs:_CRT$XCU
.CRT$XCU:00002068                 ;org 2068h
.CRT$XCU:00002068 ; COMDAT (pick associative to section at 1E14)
.CRT$XCU:00002068 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:00002068 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:00002068 _CRT$XCU        ends
.CRT$XCU:00002068
.CRT$XCU:0000206C ; ===========================================================================
.CRT$XCU:0000206C
.CRT$XCU:0000206C ; Segment type: Pure data
.CRT$XCU:0000206C ; Segment permissions: Read
.CRT$XCU:0000206C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000206C                 assume cs:_CRT$XCU
.CRT$XCU:0000206C                 ;org 206Ch
.CRT$XCU:0000206C ; COMDAT (pick associative to section at 1E18)
.CRT$XCU:0000206C ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:0000206C ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:0000206C _CRT$XCU        ends
.CRT$XCU:0000206C
UNDEF:00002070 ; ===========================================================================
UNDEF:00002070
UNDEF:00002070 ; Segment type: Externs
UNDEF:00002070 ; UNDEF
UNDEF:00002070                 extrn __purecall:near   ; DATA XREF: .rdata:00001CC4o
UNDEF:00002070                                         ; .rdata:00001CC8o
UNDEF:00002074 ; void *__cdecl operator new(unsigned int)
UNDEF:00002074                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00002074                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p
UNDEF:00002078 ; void __cdecl operator delete(void *)
UNDEF:00002078                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:00002078                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:0000207C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000207C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000207C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00002080 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00002080                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00002084 ; size_t __cdecl strlen(const char *Str)
UNDEF:00002084                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00002088 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00002088                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:0000208C ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:0000208C                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:0000208C                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00002090 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00002090                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00002090                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00002090                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:00002094                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00002098 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00002098                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00002098                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:0000209C ; void __cdecl std::_Xbad_alloc()
UNDEF:0000209C                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:0000209C                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_2Ep
UNDEF:0000209C                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_70p
UNDEF:000020A0 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:000020A0                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:000020A0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:000020A4 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:000020A4                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:000020A4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:000020A8 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:000020A8                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000020A8                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:000020AC ; const char *__cdecl std::_Syserror_map(int)
UNDEF:000020AC                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:000020AC                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:000020AC                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:000020B0 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:000020B0                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:000020B0                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:000020B4 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:000020B4                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000020B4                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:000020B8 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:000020B8                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000020B8                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:000020BC ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:000020BC                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000020BC                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:000020C0 ; __fastcall __security_check_cookie(x)
UNDEF:000020C0                 extrn @__security_check_cookie@4:near
UNDEF:000020C0                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+Cp
UNDEF:000020C0                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+Cp ...
UNDEF:000020C4 ; __stdcall _CxxThrowException(x, x)
UNDEF:000020C4                 extrn __CxxThrowException@8:near
UNDEF:000020C4                                         ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:000020C8                 extrn ___CxxFrameHandler3:near
UNDEF:000020C8                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j
UNDEF:000020C8                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+16j ...
UNDEF:000020CC ; const type_info::`vftable'
UNDEF:000020CC                 extrn ??_7type_info@@6B@:near
UNDEF:000020CC                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:000020CC                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:000020D0                 extrn ___security_cookie:near
UNDEF:000020D0                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+14r
UNDEF:000020D0                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+14r ...
UNDEF:000020D4                 extrn __fltused:near
UNDEF:000020D4
UNDEF:000020D4
UNDEF:000020D4                 end