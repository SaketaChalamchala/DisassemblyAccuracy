.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 5C422ABA6FF270D7EEB09F70C4F8E85A
.rdata:00000000 ; Input CRC32 : 121FC346
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\TaskListDlg.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 ; wchar_t _SG123977
.rdata:00000000 $SG123977:                              ; DATA XREF: TaskListDlg::run_dlgProc(uint,uint,long)+101o
.rdata:00000000                 unicode 0, <Verdana>,0
.rdata:00000010 ; const WCHAR _SG124025
.rdata:00000010 $SG124025       dd offset ?hookProc@@YGJIIJ@Z
.rdata:00000010                                         ; DATA XREF: TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+DCo
.rdata:00000010 _rdata          ends                    ; hookProc(uint,uint,long)
.rdata:00000010
.bss:00000014 ; ===========================================================================
.bss:00000014
.bss:00000014 ; Segment type: Uninitialized
.bss:00000014 ; Segment permissions: Read/Write
.bss:00000014 _bss            segment dword public 'BSS' use32
.bss:00000014                 assume cs:_bss
.bss:00000014                 ;org 14h
.bss:00000014                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00000014 ; HWND hWndServer
.bss:00000014 _hWndServer     dd ?                    ; DATA XREF: hookProc(uint,uint,long)+1Br
.bss:00000014                                         ; TaskListDlg::run_dlgProc(uint,uint,long)+171w
.bss:00000018 ; HHOOK hook
.bss:00000018 _hook           dd ?                    ; DATA XREF: hookProc(uint,uint,long)+33r
.bss:00000018                                         ; TaskListDlg::run_dlgProc(uint,uint,long)+199w
.bss:0000001C _allocator_arg  db    ? ;
.bss:0000001D _piecewise_construct db    ? ;
.bss:0000001E                 align 10h
.bss:0000001E _bss            ends
.bss:0000001E
.text$mn:00000020 ; ===========================================================================
.text$mn:00000020
.text$mn:00000020 ; Segment type: Pure code
.text$mn:00000020 ; Segment permissions: Read/Execute
.text$mn:00000020 _text$mn        segment para public 'CODE' use32
.text$mn:00000020                 assume cs:_text$mn
.text$mn:00000020                 ;org 20h
.text$mn:00000020                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000020
.text$mn:00000020 ; =============== S U B R O U T I N E =======================================
.text$mn:00000020
.text$mn:00000020 ; Attributes: bp-based frame
.text$mn:00000020
.text$mn:00000020 ; LRESULT __stdcall hookProc(int code, WPARAM wParam, LPARAM lParam)
.text$mn:00000020 ?hookProc@@YGJIIJ@Z proc near           ; DATA XREF: .rdata:$SG124025o
.text$mn:00000020                                         ; TaskListDlg::run_dlgProc(uint,uint,long)+180o
.text$mn:00000020
.text$mn:00000020 nCode           = dword ptr  8
.text$mn:00000020 wParam          = dword ptr  0Ch
.text$mn:00000020 lParam          = dword ptr  10h
.text$mn:00000020
.text$mn:00000020                 push    ebp
.text$mn:00000021                 mov     ebp, esp
.text$mn:00000023                 cmp     [ebp+nCode], 0
.text$mn:00000027                 jb      short loc_47
.text$mn:00000029                 cmp     [ebp+wParam], 205h
.text$mn:00000030                 jnz     short loc_47
.text$mn:00000032                 push    0               ; lParam
.text$mn:00000034                 push    0               ; wParam
.text$mn:00000036                 push    205h            ; Msg
.text$mn:0000003B                 mov     eax, ds:_hWndServer
.text$mn:00000040                 push    eax             ; hWnd
.text$mn:00000041                 call    dword ptr ds:__imp__PostMessageW@16 ; PostMessageW(x,x,x,x)
.text$mn:00000047
.text$mn:00000047 loc_47:                                 ; CODE XREF: hookProc(uint,uint,long)+7j
.text$mn:00000047                                         ; hookProc(uint,uint,long)+10j
.text$mn:00000047                 mov     ecx, [ebp+lParam]
.text$mn:0000004A                 push    ecx             ; lParam
.text$mn:0000004B                 mov     edx, [ebp+wParam]
.text$mn:0000004E                 push    edx             ; wParam
.text$mn:0000004F                 mov     eax, [ebp+nCode]
.text$mn:00000052                 push    eax             ; nCode
.text$mn:00000053                 mov     ecx, ds:_hook
.text$mn:00000059                 push    ecx             ; hhk
.text$mn:0000005A                 call    dword ptr ds:__imp__CallNextHookEx@16 ; CallNextHookEx(x,x,x,x)
.text$mn:00000060                 pop     ebp
.text$mn:00000061                 retn    0Ch
.text$mn:00000061 ?hookProc@@YGJIIJ@Z endp
.text$mn:00000061
.text$mn:00000061 ; ---------------------------------------------------------------------------
.text$mn:00000064                 align 10h
.text$mn:00000070
.text$mn:00000070 ; =============== S U B R O U T I N E =======================================
.text$mn:00000070
.text$mn:00000070 ; Attributes: bp-based frame
.text$mn:00000070
.text$mn:00000070 ; int __thiscall TaskListDlg::doDialog(TaskListDlg *this, bool)
.text$mn:00000070                 public ?doDialog@TaskListDlg@@QAEH_N@Z
.text$mn:00000070 ?doDialog@TaskListDlg@@QAEH_N@Z proc near
.text$mn:00000070
.text$mn:00000070 var_10          = dword ptr -10h
.text$mn:00000070 hMem            = dword ptr -0Ch
.text$mn:00000070 hDialogTemplate = dword ptr -8
.text$mn:00000070 dwInitParam     = dword ptr -4
.text$mn:00000070 arg_0           = byte ptr  8
.text$mn:00000070
.text$mn:00000070                 push    ebp
.text$mn:00000071                 mov     ebp, esp
.text$mn:00000073                 sub     esp, 10h
.text$mn:00000076                 mov     [ebp+dwInitParam], ecx
.text$mn:00000079                 movzx   eax, [ebp+arg_0]
.text$mn:0000007D                 test    eax, eax
.text$mn:0000007F                 jz      short loc_CF
.text$mn:00000081                 mov     [ebp+hDialogTemplate], 0
.text$mn:00000088                 lea     ecx, [ebp+hDialogTemplate]
.text$mn:0000008B                 push    ecx             ; struct DLGTEMPLATE **
.text$mn:0000008C                 push    960h            ; int
.text$mn:00000091                 mov     ecx, [ebp+dwInitParam] ; this
.text$mn:00000094                 call    ?makeRTLResource@StaticDialog@@IAEPAXHPAPAUDLGTEMPLATE@@@Z ; StaticDialog::makeRTLResource(int,DLGTEMPLATE * *)
.text$mn:00000099                 mov     [ebp+hMem], eax
.text$mn:0000009C                 mov     edx, [ebp+dwInitParam]
.text$mn:0000009F                 push    edx             ; dwInitParam
.text$mn:000000A0                 push    offset ?dlgProc@StaticDialog@@KGHPAUHWND__@@IIJ@Z ; lpDialogFunc
.text$mn:000000A5                 mov     eax, [ebp+dwInitParam]
.text$mn:000000A8                 mov     ecx, [eax+8]
.text$mn:000000AB                 push    ecx             ; hWndParent
.text$mn:000000AC                 mov     edx, [ebp+hDialogTemplate]
.text$mn:000000AF                 push    edx             ; hDialogTemplate
.text$mn:000000B0                 mov     eax, [ebp+dwInitParam]
.text$mn:000000B3                 mov     ecx, [eax+4]
.text$mn:000000B6                 push    ecx             ; hInstance
.text$mn:000000B7                 call    dword ptr ds:__imp__DialogBoxIndirectParamW@20 ; DialogBoxIndirectParamW(x,x,x,x,x)
.text$mn:000000BD                 mov     [ebp+var_10], eax
.text$mn:000000C0                 mov     edx, [ebp+hMem]
.text$mn:000000C3                 push    edx             ; hMem
.text$mn:000000C4                 call    dword ptr ds:__imp__GlobalFree@4 ; GlobalFree(x)
.text$mn:000000CA                 mov     eax, [ebp+var_10]
.text$mn:000000CD                 jmp     short loc_F1
.text$mn:000000CF ; ---------------------------------------------------------------------------
.text$mn:000000CF
.text$mn:000000CF loc_CF:                                 ; CODE XREF: TaskListDlg::doDialog(bool)+Fj
.text$mn:000000CF                 mov     eax, [ebp+dwInitParam]
.text$mn:000000D2                 push    eax             ; dwInitParam
.text$mn:000000D3                 push    offset ?dlgProc@StaticDialog@@KGHPAUHWND__@@IIJ@Z ; lpDialogFunc
.text$mn:000000D8                 mov     ecx, [ebp+dwInitParam]
.text$mn:000000DB                 mov     edx, [ecx+8]
.text$mn:000000DE                 push    edx             ; hWndParent
.text$mn:000000DF                 push    offset TemplateName ; lpTemplateName
.text$mn:000000E4                 mov     eax, [ebp+dwInitParam]
.text$mn:000000E7                 mov     ecx, [eax+4]
.text$mn:000000EA                 push    ecx             ; hInstance
.text$mn:000000EB                 call    dword ptr ds:__imp__DialogBoxParamW@20 ; DialogBoxParamW(x,x,x,x,x)
.text$mn:000000F1
.text$mn:000000F1 loc_F1:                                 ; CODE XREF: TaskListDlg::doDialog(bool)+5Dj
.text$mn:000000F1                 mov     esp, ebp
.text$mn:000000F3                 pop     ebp
.text$mn:000000F4                 retn    4
.text$mn:000000F4 ?doDialog@TaskListDlg@@QAEH_N@Z endp
.text$mn:000000F4
.text$mn:000000F4 ; ---------------------------------------------------------------------------
.text$mn:000000F7                 align 10h
.text$mn:00000100
.text$mn:00000100 ; =============== S U B R O U T I N E =======================================
.text$mn:00000100
.text$mn:00000100 ; Attributes: bp-based frame
.text$mn:00000100
.text$mn:00000100 ; int __stdcall TaskListDlg::run_dlgProc(TaskListDlg *this, unsigned int, unsigned int, struct tagDRAWITEMSTRUCT *)
.text$mn:00000100                 public ?run_dlgProc@TaskListDlg@@MAGHIIJ@Z
.text$mn:00000100 ?run_dlgProc@TaskListDlg@@MAGHIIJ@Z proc near
.text$mn:00000100
.text$mn:00000100 var_40          = dword ptr -40h
.text$mn:00000100 wParam          = dword ptr -3Ch
.text$mn:00000100 lParam          = dword ptr -38h
.text$mn:00000100 var_34          = dword ptr -34h
.text$mn:00000100 var_30          = dword ptr -30h
.text$mn:00000100 var_2C          = dword ptr -2Ch
.text$mn:00000100 var_28          = dword ptr -28h
.text$mn:00000100 var_24          = dword ptr -24h
.text$mn:00000100 var_20          = dword ptr -20h
.text$mn:00000100 var_1C          = dword ptr -1Ch
.text$mn:00000100 var_18          = dword ptr -18h
.text$mn:00000100 var_14          = tagRECT ptr -14h
.text$mn:00000100 var_4           = dword ptr -4
.text$mn:00000100 this            = dword ptr  8
.text$mn:00000100 arg_4           = dword ptr  0Ch
.text$mn:00000100 arg_8           = dword ptr  10h
.text$mn:00000100 arg_C           = dword ptr  14h
.text$mn:00000100
.text$mn:00000100                 push    ebp
.text$mn:00000101                 mov     ebp, esp
.text$mn:00000103                 sub     esp, 40h
.text$mn:00000106                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000010B                 xor     eax, ebp
.text$mn:0000010D                 mov     [ebp+var_4], eax
.text$mn:00000110                 mov     eax, [ebp+arg_4]
.text$mn:00000113                 mov     [ebp+var_18], eax
.text$mn:00000116                 cmp     [ebp+var_18], 110h
.text$mn:0000011D                 ja      short loc_14B
.text$mn:0000011F                 cmp     [ebp+var_18], 110h
.text$mn:00000126                 jz      short loc_16A
.text$mn:00000128                 cmp     [ebp+var_18], 2
.text$mn:0000012C                 jz      loc_2A6
.text$mn:00000132                 cmp     [ebp+var_18], 2Bh ; '+'
.text$mn:00000136                 jz      loc_2FB
.text$mn:0000013C                 cmp     [ebp+var_18], 4Eh ; 'N'
.text$mn:00000140                 jz      loc_311
.text$mn:00000146                 jmp     loc_416
.text$mn:0000014B ; ---------------------------------------------------------------------------
.text$mn:0000014B
.text$mn:0000014B loc_14B:                                ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+1Dj
.text$mn:0000014B                 cmp     [ebp+var_18], 111h
.text$mn:00000152                 jz      loc_3A2
.text$mn:00000158                 cmp     [ebp+var_18], 205h
.text$mn:0000015F                 jz      loc_2CE
.text$mn:00000165                 jmp     loc_416
.text$mn:0000016A ; ---------------------------------------------------------------------------
.text$mn:0000016A
.text$mn:0000016A loc_16A:                                ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+26j
.text$mn:0000016A                 push    0               ; lParam
.text$mn:0000016C                 mov     ecx, [ebp+this]
.text$mn:0000016F                 add     ecx, 54h ; 'T'
.text$mn:00000172                 push    ecx             ; wParam
.text$mn:00000173                 push    2341h           ; Msg
.text$mn:00000178                 mov     edx, [ebp+this]
.text$mn:0000017B                 mov     eax, [edx+8]
.text$mn:0000017E                 push    eax             ; hWnd
.text$mn:0000017F                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000185                 mov     ecx, [ebp+this]
.text$mn:00000188                 add     ecx, 54h ; 'T'
.text$mn:0000018B                 call    ?size@?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QBEIXZ ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::size(void)
.text$mn:00000190                 mov     [ebp+var_20], eax
.text$mn:00000193                 mov     ecx, [ebp+this]
.text$mn:00000196                 movzx   edx, byte ptr [ecx+6Ch]
.text$mn:0000019A                 test    edx, edx
.text$mn:0000019C                 jnz     short loc_1A7
.text$mn:0000019E                 mov     [ebp+var_2C], 1
.text$mn:000001A5                 jmp     short loc_1AE
.text$mn:000001A7 ; ---------------------------------------------------------------------------
.text$mn:000001A7
.text$mn:000001A7 loc_1A7:                                ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+9Cj
.text$mn:000001A7                 mov     [ebp+var_2C], 0FFFFFFFFh
.text$mn:000001AE
.text$mn:000001AE loc_1AE:                                ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+A5j
.text$mn:000001AE                 mov     eax, [ebp+this]
.text$mn:000001B1                 mov     ecx, [eax+64h]
.text$mn:000001B4                 add     ecx, [ebp+var_2C]
.text$mn:000001B7                 mov     [ebp+var_1C], ecx
.text$mn:000001BA                 jns     short loc_1C5
.text$mn:000001BC                 mov     edx, [ebp+var_20]
.text$mn:000001BF                 sub     edx, 1
.text$mn:000001C2                 mov     [ebp+var_1C], edx
.text$mn:000001C5
.text$mn:000001C5 loc_1C5:                                ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+BAj
.text$mn:000001C5                 mov     eax, [ebp+var_20]
.text$mn:000001C8                 sub     eax, 1
.text$mn:000001CB                 cmp     [ebp+var_1C], eax
.text$mn:000001CE                 jle     short loc_1D7
.text$mn:000001D0                 mov     [ebp+var_1C], 0
.text$mn:000001D7
.text$mn:000001D7 loc_1D7:                                ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+CEj
.text$mn:000001D7                 mov     ecx, [ebp+var_1C]
.text$mn:000001DA                 push    ecx             ; int
.text$mn:000001DB                 mov     edx, [ebp+var_20]
.text$mn:000001DE                 push    edx             ; int
.text$mn:000001DF                 mov     eax, [ebp+this]
.text$mn:000001E2                 mov     ecx, [eax+68h]
.text$mn:000001E5                 push    ecx             ; struct _IMAGELIST *
.text$mn:000001E6                 mov     edx, [ebp+this]
.text$mn:000001E9                 mov     eax, [edx+0Ch]
.text$mn:000001EC                 push    eax             ; HWND
.text$mn:000001ED                 mov     ecx, [ebp+this]
.text$mn:000001F0                 mov     edx, [ecx+4]
.text$mn:000001F3                 push    edx             ; HINSTANCE
.text$mn:000001F4                 mov     ecx, [ebp+this]
.text$mn:000001F7                 add     ecx, 20h ; ' '  ; this
.text$mn:000001FA                 call    ?init@TaskList@@QAEXPAUHINSTANCE__@@PAUHWND__@@PAU_IMAGELIST@@HH@Z ; TaskList::init(HINSTANCE__ *,HWND__ *,_IMAGELIST *,int,int)
.text$mn:000001FF                 push    0Eh             ; unsigned int
.text$mn:00000201                 push    offset $SG123977 ; "Verdana"
.text$mn:00000206                 mov     ecx, [ebp+this]
.text$mn:00000209                 add     ecx, 20h ; ' '  ; this
.text$mn:0000020C                 call    ?setFont@TaskList@@QAEXPA_WI@Z ; TaskList::setFont(wchar_t *,uint)
.text$mn:00000211                 lea     eax, [ebp+var_14]
.text$mn:00000214                 push    eax             ; retstr
.text$mn:00000215                 mov     ecx, [ebp+this]
.text$mn:00000218                 add     ecx, 20h ; ' '  ; this
.text$mn:0000021B                 call    ?adjustSize@TaskList@@QAE?AUtagRECT@@XZ ; TaskList::adjustSize(void)
.text$mn:00000220                 mov     ecx, [ebp+this]
.text$mn:00000223                 add     ecx, 10h
.text$mn:00000226                 mov     edx, [eax]
.text$mn:00000228                 mov     [ecx], edx
.text$mn:0000022A                 mov     edx, [eax+4]
.text$mn:0000022D                 mov     [ecx+4], edx
.text$mn:00000230                 mov     edx, [eax+8]
.text$mn:00000233                 mov     [ecx+8], edx
.text$mn:00000236                 mov     eax, [eax+0Ch]
.text$mn:00000239                 mov     [ecx+0Ch], eax
.text$mn:0000023C                 mov     ecx, [ebp+this]
.text$mn:0000023F                 add     ecx, 10h
.text$mn:00000242                 push    ecx
.text$mn:00000243                 mov     edx, [ebp+this]
.text$mn:00000246                 mov     eax, [edx]
.text$mn:00000248                 mov     ecx, [ebp+this]
.text$mn:0000024B                 mov     edx, [eax+10h]
.text$mn:0000024E                 call    edx
.text$mn:00000250                 mov     ecx, [ebp+this] ; this
.text$mn:00000253                 call    ?goToCenter@StaticDialog@@QAEXXZ ; StaticDialog::goToCenter(void)
.text$mn:00000258                 push    1
.text$mn:0000025A                 mov     ecx, [ebp+this]
.text$mn:0000025D                 add     ecx, 20h ; ' '
.text$mn:00000260                 mov     eax, [ebp+this]
.text$mn:00000263                 mov     edx, [eax+20h]
.text$mn:00000266                 mov     eax, [edx+0Ch]
.text$mn:00000269                 call    eax
.text$mn:0000026B                 mov     ecx, [ebp+this]
.text$mn:0000026E                 mov     edx, [ecx+0Ch]
.text$mn:00000271                 mov     ds:_hWndServer, edx
.text$mn:00000277                 push    0               ; dwThreadId
.text$mn:00000279                 mov     eax, [ebp+this]
.text$mn:0000027C                 mov     ecx, [eax+4]
.text$mn:0000027F                 push    ecx             ; hmod
.text$mn:00000280                 push    offset ?hookProc@@YGJIIJ@Z ; lpfn
.text$mn:00000285                 push    0Eh             ; idHook
.text$mn:00000287                 call    dword ptr ds:__imp__SetWindowsHookExW@16 ; SetWindowsHookExW(x,x,x,x)
.text$mn:0000028D                 mov     edx, [ebp+this]
.text$mn:00000290                 mov     [edx+70h], eax
.text$mn:00000293                 mov     eax, [ebp+this]
.text$mn:00000296                 mov     ecx, [eax+70h]
.text$mn:00000299                 mov     ds:_hook, ecx
.text$mn:0000029F                 xor     eax, eax
.text$mn:000002A1                 jmp     loc_41C
.text$mn:000002A6 ; ---------------------------------------------------------------------------
.text$mn:000002A6
.text$mn:000002A6 loc_2A6:                                ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+2Cj
.text$mn:000002A6                 mov     ecx, [ebp+this]
.text$mn:000002A9                 add     ecx, 20h ; ' '
.text$mn:000002AC                 mov     edx, [ebp+this]
.text$mn:000002AF                 mov     eax, [edx+20h]
.text$mn:000002B2                 mov     edx, [eax+8]
.text$mn:000002B5                 call    edx
.text$mn:000002B7                 mov     eax, [ebp+this]
.text$mn:000002BA                 mov     ecx, [eax+70h]
.text$mn:000002BD                 push    ecx             ; hhk
.text$mn:000002BE                 call    dword ptr ds:__imp__UnhookWindowsHookEx@4 ; UnhookWindowsHookEx(x)
.text$mn:000002C4                 mov     eax, 1
.text$mn:000002C9                 jmp     loc_41C
.text$mn:000002CE ; ---------------------------------------------------------------------------
.text$mn:000002CE
.text$mn:000002CE loc_2CE:                                ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+5Fj
.text$mn:000002CE                 mov     ecx, [ebp+this]
.text$mn:000002D1                 add     ecx, 20h ; ' '  ; this
.text$mn:000002D4                 call    ?getCurrentIndex@TaskList@@QBEHXZ ; TaskList::getCurrentIndex(void)
.text$mn:000002D9                 push    eax             ; lParam
.text$mn:000002DA                 push    993h            ; wParam
.text$mn:000002DF                 push    111h            ; Msg
.text$mn:000002E4                 mov     edx, [ebp+this]
.text$mn:000002E7                 mov     eax, [edx+0Ch]
.text$mn:000002EA                 push    eax             ; hWnd
.text$mn:000002EB                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000002F1                 mov     eax, 1
.text$mn:000002F6                 jmp     loc_41C
.text$mn:000002FB ; ---------------------------------------------------------------------------
.text$mn:000002FB
.text$mn:000002FB loc_2FB:                                ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+36j
.text$mn:000002FB                 mov     ecx, [ebp+arg_C]
.text$mn:000002FE                 push    ecx             ; struct tagDRAWITEMSTRUCT *
.text$mn:000002FF                 mov     ecx, [ebp+this] ; this
.text$mn:00000302                 call    ?drawItem@TaskListDlg@@AAEXPAUtagDRAWITEMSTRUCT@@@Z ; TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)
.text$mn:00000307                 mov     eax, 1
.text$mn:0000030C                 jmp     loc_41C
.text$mn:00000311 ; ---------------------------------------------------------------------------
.text$mn:00000311
.text$mn:00000311 loc_311:                                ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+40j
.text$mn:00000311                 mov     edx, [ebp+arg_C]
.text$mn:00000314                 mov     eax, [edx+8]
.text$mn:00000317                 mov     [ebp+var_28], eax
.text$mn:0000031A                 cmp     [ebp+var_28], 0FFFFFF4Fh
.text$mn:00000321                 jz      short loc_331
.text$mn:00000323                 cmp     [ebp+var_28], 0FFFFFFFBh
.text$mn:00000327                 jz      short loc_376
.text$mn:00000329                 cmp     [ebp+var_28], 0FFFFFFFEh
.text$mn:0000032D                 jz      short loc_376
.text$mn:0000032F                 jmp     short loc_3A0
.text$mn:00000331 ; ---------------------------------------------------------------------------
.text$mn:00000331
.text$mn:00000331 loc_331:                                ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+221j
.text$mn:00000331                 mov     ecx, [ebp+arg_C]
.text$mn:00000334                 add     ecx, 0Ch
.text$mn:00000337                 mov     [ebp+var_24], ecx
.text$mn:0000033A                 mov     edx, [ebp+var_24]
.text$mn:0000033D                 mov     eax, [edx+4]
.text$mn:00000340                 push    eax
.text$mn:00000341                 mov     ecx, [ebp+this]
.text$mn:00000344                 add     ecx, 54h ; 'T'
.text$mn:00000347                 call    ??A?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAEAAUTaskLstFnStatus@@I@Z ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)
.text$mn:0000034C                 mov     [ebp+var_30], eax
.text$mn:0000034F                 mov     ecx, [ebp+var_30]
.text$mn:00000352                 add     ecx, 8
.text$mn:00000355                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000035A                 mov     ecx, [ebp+var_24]
.text$mn:0000035D                 mov     [ecx+14h], eax
.text$mn:00000360                 mov     edx, [ebp+var_24]
.text$mn:00000363                 mov     eax, [ebp+var_30]
.text$mn:00000366                 mov     ecx, [eax+24h]
.text$mn:00000369                 mov     [edx+1Ch], ecx
.text$mn:0000036C                 mov     eax, 1
.text$mn:00000371                 jmp     loc_41C
.text$mn:00000376 ; ---------------------------------------------------------------------------
.text$mn:00000376
.text$mn:00000376 loc_376:                                ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+227j
.text$mn:00000376                                         ; TaskListDlg::run_dlgProc(uint,uint,long)+22Dj
.text$mn:00000376                 mov     ecx, [ebp+this]
.text$mn:00000379                 add     ecx, 20h ; ' '  ; this
.text$mn:0000037C                 call    ?updateCurrentIndex@TaskList@@QAEHXZ ; TaskList::updateCurrentIndex(void)
.text$mn:00000381                 push    eax             ; lParam
.text$mn:00000382                 push    993h            ; wParam
.text$mn:00000387                 push    111h            ; Msg
.text$mn:0000038C                 mov     edx, [ebp+this]
.text$mn:0000038F                 mov     eax, [edx+0Ch]
.text$mn:00000392                 push    eax             ; hWnd
.text$mn:00000393                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000399                 mov     eax, 1
.text$mn:0000039E                 jmp     short loc_41C
.text$mn:000003A0 ; ---------------------------------------------------------------------------
.text$mn:000003A0
.text$mn:000003A0 loc_3A0:                                ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+22Fj
.text$mn:000003A0                 jmp     short loc_41A
.text$mn:000003A2 ; ---------------------------------------------------------------------------
.text$mn:000003A2
.text$mn:000003A2 loc_3A2:                                ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+52j
.text$mn:000003A2                 mov     ecx, [ebp+arg_8]
.text$mn:000003A5                 mov     [ebp+var_40], ecx
.text$mn:000003A8                 cmp     [ebp+var_40], 993h
.text$mn:000003AF                 jz      short loc_3B3
.text$mn:000003B1                 jmp     short loc_412
.text$mn:000003B3 ; ---------------------------------------------------------------------------
.text$mn:000003B3
.text$mn:000003B3 loc_3B3:                                ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+2AFj
.text$mn:000003B3                 mov     edx, [ebp+arg_C]
.text$mn:000003B6                 mov     [ebp+var_34], edx
.text$mn:000003B9                 mov     eax, [ebp+var_34]
.text$mn:000003BC                 push    eax
.text$mn:000003BD                 mov     ecx, [ebp+this]
.text$mn:000003C0                 add     ecx, 54h ; 'T'
.text$mn:000003C3                 call    ??A?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAEAAUTaskLstFnStatus@@I@Z ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)
.text$mn:000003C8                 mov     ecx, [eax]
.text$mn:000003CA                 mov     [ebp+wParam], ecx
.text$mn:000003CD                 mov     edx, [ebp+var_34]
.text$mn:000003D0                 push    edx
.text$mn:000003D1                 mov     ecx, [ebp+this]
.text$mn:000003D4                 add     ecx, 54h ; 'T'
.text$mn:000003D7                 call    ??A?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAEAAUTaskLstFnStatus@@I@Z ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)
.text$mn:000003DC                 mov     eax, [eax+4]
.text$mn:000003DF                 mov     [ebp+lParam], eax
.text$mn:000003E2                 mov     ecx, [ebp+lParam]
.text$mn:000003E5                 push    ecx             ; lParam
.text$mn:000003E6                 mov     edx, [ebp+wParam]
.text$mn:000003E9                 push    edx             ; wParam
.text$mn:000003EA                 push    804h            ; Msg
.text$mn:000003EF                 mov     eax, [ebp+this]
.text$mn:000003F2                 mov     ecx, [eax+8]
.text$mn:000003F5                 push    ecx             ; hWnd
.text$mn:000003F6                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000003FC                 push    0FFFFFFFFh      ; nResult
.text$mn:000003FE                 mov     edx, [ebp+this]
.text$mn:00000401                 mov     eax, [edx+0Ch]
.text$mn:00000404                 push    eax             ; hDlg
.text$mn:00000405                 call    dword ptr ds:__imp__EndDialog@8 ; EndDialog(x,x)
.text$mn:0000040B                 mov     eax, 1
.text$mn:00000410                 jmp     short loc_41C
.text$mn:00000412 ; ---------------------------------------------------------------------------
.text$mn:00000412
.text$mn:00000412 loc_412:                                ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+2B1j
.text$mn:00000412                 xor     eax, eax
.text$mn:00000414                 jmp     short loc_41C
.text$mn:00000416 ; ---------------------------------------------------------------------------
.text$mn:00000416
.text$mn:00000416 loc_416:                                ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+46j
.text$mn:00000416                                         ; TaskListDlg::run_dlgProc(uint,uint,long)+65j
.text$mn:00000416                 xor     eax, eax
.text$mn:00000418                 jmp     short loc_41C
.text$mn:0000041A ; ---------------------------------------------------------------------------
.text$mn:0000041A
.text$mn:0000041A loc_41A:                                ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long):loc_3A0j
.text$mn:0000041A                 xor     eax, eax
.text$mn:0000041C
.text$mn:0000041C loc_41C:                                ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+1A1j
.text$mn:0000041C                                         ; TaskListDlg::run_dlgProc(uint,uint,long)+1C9j ...
.text$mn:0000041C                 mov     ecx, [ebp+var_4]
.text$mn:0000041F                 xor     ecx, ebp
.text$mn:00000421                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000426                 mov     esp, ebp
.text$mn:00000428                 pop     ebp
.text$mn:00000429                 retn    10h
.text$mn:00000429 ?run_dlgProc@TaskListDlg@@MAGHIIJ@Z endp
.text$mn:00000429
.text$mn:00000429 ; ---------------------------------------------------------------------------
.text$mn:0000042C                 align 10h
.text$mn:00000430
.text$mn:00000430 ; =============== S U B R O U T I N E =======================================
.text$mn:00000430
.text$mn:00000430 ; Attributes: bp-based frame
.text$mn:00000430
.text$mn:00000430 ; void __thiscall TaskListDlg::drawItem(TaskListDlg *this, struct tagDRAWITEMSTRUCT *)
.text$mn:00000430                 public ?drawItem@TaskListDlg@@AAEXPAUtagDRAWITEMSTRUCT@@@Z
.text$mn:00000430 ?drawItem@TaskListDlg@@AAEXPAUtagDRAWITEMSTRUCT@@@Z proc near
.text$mn:00000430                                         ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+202p
.text$mn:00000430
.text$mn:00000430 sz              = tagSIZE ptr -68h
.text$mn:00000430 var_60          = dword ptr -60h
.text$mn:00000430 fStyle          = dword ptr -5Ch
.text$mn:00000430 color           = dword ptr -58h
.text$mn:00000430 var_54          = dword ptr -54h
.text$mn:00000430 i               = dword ptr -50h
.text$mn:00000430 var_4C          = dword ptr -4Ch
.text$mn:00000430 himl            = dword ptr -48h
.text$mn:00000430 lpString        = dword ptr -44h
.text$mn:00000430 var_40          = dword ptr -40h
.text$mn:00000430 var_3C          = dword ptr -3Ch
.text$mn:00000430 hdc             = dword ptr -38h
.text$mn:00000430 pImageInfo      = IMAGEINFO ptr -34h
.text$mn:00000430 x               = dword ptr -14h
.text$mn:00000430 y               = dword ptr -10h
.text$mn:00000430 var_C           = dword ptr -0Ch
.text$mn:00000430 var_8           = dword ptr -8
.text$mn:00000430 var_4           = dword ptr -4
.text$mn:00000430 arg_0           = dword ptr  8
.text$mn:00000430
.text$mn:00000430                 push    ebp
.text$mn:00000431                 mov     ebp, esp
.text$mn:00000433                 sub     esp, 68h
.text$mn:00000436                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000043B                 xor     eax, ebp
.text$mn:0000043D                 mov     [ebp+var_4], eax
.text$mn:00000440                 mov     [ebp+var_3C], ecx
.text$mn:00000443                 mov     eax, [ebp+arg_0]
.text$mn:00000446                 add     eax, 1Ch
.text$mn:00000449                 mov     ecx, [eax]
.text$mn:0000044B                 mov     [ebp+x], ecx
.text$mn:0000044E                 mov     edx, [eax+4]
.text$mn:00000451                 mov     [ebp+y], edx
.text$mn:00000454                 mov     ecx, [eax+8]
.text$mn:00000457                 mov     [ebp+var_C], ecx
.text$mn:0000045A                 mov     edx, [eax+0Ch]
.text$mn:0000045D                 mov     [ebp+var_8], edx
.text$mn:00000460                 mov     eax, [ebp+arg_0]
.text$mn:00000463                 mov     ecx, [eax+18h]
.text$mn:00000466                 mov     [ebp+hdc], ecx
.text$mn:00000469                 mov     edx, [ebp+arg_0]
.text$mn:0000046C                 mov     eax, [edx+8]
.text$mn:0000046F                 mov     [ebp+var_4C], eax
.text$mn:00000472                 mov     ecx, [ebp+var_4C]
.text$mn:00000475                 push    ecx
.text$mn:00000476                 mov     ecx, [ebp+var_3C]
.text$mn:00000479                 add     ecx, 54h ; 'T'
.text$mn:0000047C                 call    ??A?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAEAAUTaskLstFnStatus@@I@Z ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)
.text$mn:00000481                 add     eax, 8
.text$mn:00000484                 mov     ecx, eax
.text$mn:00000486                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000048B                 mov     [ebp+lpString], eax
.text$mn:0000048E                 mov     edx, [ebp+var_4C]
.text$mn:00000491                 push    edx
.text$mn:00000492                 mov     ecx, [ebp+var_3C]
.text$mn:00000495                 add     ecx, 54h ; 'T'
.text$mn:00000498                 call    ??A?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAEAAUTaskLstFnStatus@@I@Z ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)
.text$mn:0000049D                 mov     eax, [eax+24h]
.text$mn:000004A0                 mov     [ebp+i], eax
.text$mn:000004A3                 mov     [ebp+color], 404040h
.text$mn:000004AA                 mov     [ebp+fStyle], 4
.text$mn:000004B1                 mov     ecx, [ebp+arg_0]
.text$mn:000004B4                 mov     edx, [ecx+10h]
.text$mn:000004B7                 and     edx, 1
.text$mn:000004BA                 jz      short loc_4E0
.text$mn:000004BC                 mov     [ebp+fStyle], 1
.text$mn:000004C3                 mov     [ebp+color], 0
.text$mn:000004CA                 mov     ecx, [ebp+var_3C]
.text$mn:000004CD                 add     ecx, 20h ; ' '  ; this
.text$mn:000004D0                 call    ?GetFontSelected@TaskList@@QAEPAUHFONT__@@XZ ; TaskList::GetFontSelected(void)
.text$mn:000004D5                 push    eax             ; h
.text$mn:000004D6                 mov     eax, [ebp+hdc]
.text$mn:000004D9                 push    eax             ; hdc
.text$mn:000004DA                 call    dword ptr ds:__imp__SelectObject@8 ; SelectObject(x,x)
.text$mn:000004E0
.text$mn:000004E0 loc_4E0:                                ; CODE XREF: TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+8Aj
.text$mn:000004E0                 mov     ecx, [ebp+var_3C]
.text$mn:000004E3                 add     ecx, 20h ; ' '  ; this
.text$mn:000004E6                 call    ?getImgLst@TaskList@@QBEPAU_IMAGELIST@@XZ ; TaskList::getImgLst(void)
.text$mn:000004EB                 mov     [ebp+himl], eax
.text$mn:000004EE                 lea     ecx, [ebp+pImageInfo]
.text$mn:000004F1                 push    ecx             ; pImageInfo
.text$mn:000004F2                 mov     edx, [ebp+i]
.text$mn:000004F5                 push    edx             ; i
.text$mn:000004F6                 mov     eax, [ebp+himl]
.text$mn:000004F9                 push    eax             ; himl
.text$mn:000004FA                 call    dword ptr ds:__imp__ImageList_GetImageInfo@12 ; ImageList_GetImageInfo(x,x,x)
.text$mn:00000500                 lea     ecx, [ebp+pImageInfo.rcImage]
.text$mn:00000503                 mov     [ebp+var_40], ecx
.text$mn:00000506                 lea     edx, [ebp+sz]
.text$mn:00000509                 push    edx             ; lpsz
.text$mn:0000050A                 push    1               ; c
.text$mn:0000050C                 push    offset $SG124025 ; lpString
.text$mn:00000511                 mov     eax, [ebp+hdc]
.text$mn:00000514                 push    eax             ; hdc
.text$mn:00000515                 call    dword ptr ds:__imp__GetTextExtentPointW@16 ; GetTextExtentPointW(x,x,x,x)
.text$mn:0000051B                 mov     ecx, [ebp+sz._cx]
.text$mn:0000051E                 mov     [ebp+var_54], ecx
.text$mn:00000521                 mov     edx, [ebp+var_54]
.text$mn:00000524                 mov     [ebp+var_60], edx
.text$mn:00000527                 mov     eax, [ebp+x]
.text$mn:0000052A                 add     eax, [ebp+var_60]
.text$mn:0000052D                 mov     [ebp+x], eax
.text$mn:00000530                 mov     ecx, [ebp+fStyle]
.text$mn:00000533                 push    ecx             ; fStyle
.text$mn:00000534                 mov     edx, [ebp+y]
.text$mn:00000537                 push    edx             ; y
.text$mn:00000538                 mov     eax, [ebp+x]
.text$mn:0000053B                 push    eax             ; x
.text$mn:0000053C                 mov     ecx, [ebp+hdc]
.text$mn:0000053F                 push    ecx             ; hdcDst
.text$mn:00000540                 mov     edx, [ebp+i]
.text$mn:00000543                 push    edx             ; i
.text$mn:00000544                 mov     eax, [ebp+himl]
.text$mn:00000547                 push    eax             ; himl
.text$mn:00000548                 call    dword ptr ds:__imp__ImageList_Draw@24 ; ImageList_Draw(x,x,x,x,x,x)
.text$mn:0000054E                 mov     ecx, [ebp+var_40]
.text$mn:00000551                 mov     edx, [ebp+var_40]
.text$mn:00000554                 mov     eax, [ecx+8]
.text$mn:00000557                 sub     eax, [edx]
.text$mn:00000559                 add     eax, [ebp+x]
.text$mn:0000055C                 mov     ecx, [ebp+var_54]
.text$mn:0000055F                 lea     edx, [eax+ecx*2]
.text$mn:00000562                 mov     [ebp+x], edx
.text$mn:00000565                 mov     eax, [ebp+color]
.text$mn:00000568                 push    eax             ; color
.text$mn:00000569                 mov     ecx, [ebp+hdc]
.text$mn:0000056C                 push    ecx             ; hdc
.text$mn:0000056D                 call    dword ptr ds:__imp__SetTextColor@8 ; SetTextColor(x,x)
.text$mn:00000573                 push    2Eh ; '.'       ; nIndex
.text$mn:00000575                 call    dword ptr ds:__imp__GetSystemMetrics@4 ; GetSystemMetrics(x)
.text$mn:0000057B                 mov     edx, [ebp+y]
.text$mn:0000057E                 sub     edx, eax
.text$mn:00000580                 mov     [ebp+y], edx
.text$mn:00000583                 push    24h ; '$'       ; format
.text$mn:00000585                 lea     eax, [ebp+x]
.text$mn:00000588                 push    eax             ; lprc
.text$mn:00000589                 mov     ecx, [ebp+lpString]
.text$mn:0000058C                 push    ecx             ; lpString
.text$mn:0000058D                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:00000593                 push    eax             ; cchText
.text$mn:00000594                 mov     edx, [ebp+lpString]
.text$mn:00000597                 push    edx             ; lpchText
.text$mn:00000598                 mov     eax, [ebp+hdc]
.text$mn:0000059B                 push    eax             ; hdc
.text$mn:0000059C                 call    dword ptr ds:__imp__DrawTextW@20 ; DrawTextW(x,x,x,x,x)
.text$mn:000005A2                 mov     ecx, [ebp+var_4]
.text$mn:000005A5                 xor     ecx, ebp
.text$mn:000005A7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000005AC                 mov     esp, ebp
.text$mn:000005AE                 pop     ebp
.text$mn:000005AF                 retn    4
.text$mn:000005AF ?drawItem@TaskListDlg@@AAEXPAUtagDRAWITEMSTRUCT@@@Z endp
.text$mn:000005AF
.text$mn:000005AF ; ---------------------------------------------------------------------------
.text$mn:000005B2                 align 4
.text$mn:000005B2 _text$mn        ends
.text$mn:000005B2
.text$mn:000005B4 ; ===========================================================================
.text$mn:000005B4
.text$mn:000005B4 ; Segment type: Pure code
.text$mn:000005B4 ; Segment permissions: Read/Execute
.text$mn:000005B4 _text$mn        segment para public 'CODE' use32
.text$mn:000005B4                 assume cs:_text$mn
.text$mn:000005B4                 ;org 5B4h
.text$mn:000005B4 ; COMDAT (pick any)
.text$mn:000005B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000005B4
.text$mn:000005B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000005B4
.text$mn:000005B4 ; Attributes: bp-based frame
.text$mn:000005B4
.text$mn:000005B4 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:000005B4                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:000005B4 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:000005B4                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:000005B4
.text$mn:000005B4 var_4           = dword ptr -4
.text$mn:000005B4 arg_0           = dword ptr  8
.text$mn:000005B4
.text$mn:000005B4                 push    ebp
.text$mn:000005B5                 mov     ebp, esp
.text$mn:000005B7                 push    ecx
.text$mn:000005B8                 mov     [ebp+var_4], 0
.text$mn:000005BF                 cmp     [ebp+arg_0], 0
.text$mn:000005C3                 jnz     short loc_5C7
.text$mn:000005C5                 jmp     short loc_5E7
.text$mn:000005C7 ; ---------------------------------------------------------------------------
.text$mn:000005C7
.text$mn:000005C7 loc_5C7:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:000005C7                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:000005CB                 ja      short loc_5E2
.text$mn:000005CD                 mov     eax, [ebp+arg_0]
.text$mn:000005D0                 push    eax             ; unsigned int
.text$mn:000005D1                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000005D6                 add     esp, 4
.text$mn:000005D9                 mov     [ebp+var_4], eax
.text$mn:000005DC                 cmp     [ebp+var_4], 0
.text$mn:000005E0                 jnz     short loc_5E7
.text$mn:000005E2
.text$mn:000005E2 loc_5E2:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:000005E2                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000005E7
.text$mn:000005E7 loc_5E7:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:000005E7                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:000005E7                 mov     eax, [ebp+var_4]
.text$mn:000005EA                 mov     esp, ebp
.text$mn:000005EC                 pop     ebp
.text$mn:000005ED                 retn
.text$mn:000005ED ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:000005ED
.text$mn:000005ED ; ---------------------------------------------------------------------------
.text$mn:000005EE                 align 10h
.text$mn:000005EE _text$mn        ends
.text$mn:000005EE
.text$mn:000005F0 ; ===========================================================================
.text$mn:000005F0
.text$mn:000005F0 ; Segment type: Pure code
.text$mn:000005F0 ; Segment permissions: Read/Execute
.text$mn:000005F0 _text$mn        segment para public 'CODE' use32
.text$mn:000005F0                 assume cs:_text$mn
.text$mn:000005F0                 ;org 5F0h
.text$mn:000005F0 ; COMDAT (pick any)
.text$mn:000005F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000005F0
.text$mn:000005F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000005F0
.text$mn:000005F0 ; Attributes: bp-based frame
.text$mn:000005F0
.text$mn:000005F0 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:000005F0                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:000005F0 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:000005F0                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:000005F0
.text$mn:000005F0 var_4           = dword ptr -4
.text$mn:000005F0 arg_0           = dword ptr  8
.text$mn:000005F0
.text$mn:000005F0                 push    ebp
.text$mn:000005F1                 mov     ebp, esp
.text$mn:000005F3                 push    ecx
.text$mn:000005F4                 mov     [ebp+var_4], 0
.text$mn:000005FB                 cmp     [ebp+arg_0], 0
.text$mn:000005FF                 jnz     short loc_603
.text$mn:00000601                 jmp     short loc_629
.text$mn:00000603 ; ---------------------------------------------------------------------------
.text$mn:00000603
.text$mn:00000603 loc_603:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:00000603                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:0000060A                 ja      short loc_624
.text$mn:0000060C                 mov     eax, [ebp+arg_0]
.text$mn:0000060F                 shl     eax, 3
.text$mn:00000612                 push    eax             ; unsigned int
.text$mn:00000613                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000618                 add     esp, 4
.text$mn:0000061B                 mov     [ebp+var_4], eax
.text$mn:0000061E                 cmp     [ebp+var_4], 0
.text$mn:00000622                 jnz     short loc_629
.text$mn:00000624
.text$mn:00000624 loc_624:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00000624                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000629
.text$mn:00000629 loc_629:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00000629                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00000629                 mov     eax, [ebp+var_4]
.text$mn:0000062C                 mov     esp, ebp
.text$mn:0000062E                 pop     ebp
.text$mn:0000062F                 retn
.text$mn:0000062F ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:0000062F
.text$mn:0000062F _text$mn        ends
.text$mn:0000062F
.text$mn:00000630 ; ===========================================================================
.text$mn:00000630
.text$mn:00000630 ; Segment type: Pure code
.text$mn:00000630 ; Segment permissions: Read/Execute
.text$mn:00000630 _text$mn        segment para public 'CODE' use32
.text$mn:00000630                 assume cs:_text$mn
.text$mn:00000630                 ;org 630h
.text$mn:00000630 ; COMDAT (pick any)
.text$mn:00000630                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000630
.text$mn:00000630 ; =============== S U B R O U T I N E =======================================
.text$mn:00000630
.text$mn:00000630 ; Attributes: bp-based frame
.text$mn:00000630
.text$mn:00000630 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:00000630                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:00000630 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:00000630                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:00000630                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:00000630
.text$mn:00000630 arg_0           = dword ptr  8
.text$mn:00000630 arg_4           = dword ptr  0Ch
.text$mn:00000630 arg_8           = dword ptr  10h
.text$mn:00000630
.text$mn:00000630                 push    ebp
.text$mn:00000631                 mov     ebp, esp
.text$mn:00000633                 cmp     [ebp+arg_0], 0
.text$mn:00000637                 jnz     short loc_64E
.text$mn:00000639                 mov     eax, [ebp+arg_8]
.text$mn:0000063C                 push    eax             ; unsigned int
.text$mn:0000063D                 mov     ecx, [ebp+arg_4]
.text$mn:00000640                 push    ecx             ; wchar_t *
.text$mn:00000641                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00000646                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000064B                 add     esp, 0Ch
.text$mn:0000064E
.text$mn:0000064E loc_64E:                                ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:0000064E                 pop     ebp
.text$mn:0000064F                 retn
.text$mn:0000064F ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:0000064F
.text$mn:0000064F _text$mn        ends
.text$mn:0000064F
.text$mn:00000650 ; ===========================================================================
.text$mn:00000650
.text$mn:00000650 ; Segment type: Pure code
.text$mn:00000650 ; Segment permissions: Read/Execute
.text$mn:00000650 _text$mn        segment para public 'CODE' use32
.text$mn:00000650                 assume cs:_text$mn
.text$mn:00000650                 ;org 650h
.text$mn:00000650 ; COMDAT (pick any)
.text$mn:00000650                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000650
.text$mn:00000650 ; =============== S U B R O U T I N E =======================================
.text$mn:00000650
.text$mn:00000650 ; Attributes: bp-based frame
.text$mn:00000650
.text$mn:00000650 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00000650                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00000650 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00000650                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00000650                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00000650
.text$mn:00000650 arg_0           = dword ptr  8
.text$mn:00000650
.text$mn:00000650                 push    ebp
.text$mn:00000651                 mov     ebp, esp
.text$mn:00000653                 mov     eax, [ebp+arg_0]
.text$mn:00000656                 pop     ebp
.text$mn:00000657                 retn
.text$mn:00000657 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:00000657
.text$mn:00000657 _text$mn        ends
.text$mn:00000657
.text$mn:00000658 ; ===========================================================================
.text$mn:00000658
.text$mn:00000658 ; Segment type: Pure code
.text$mn:00000658 ; Segment permissions: Read/Execute
.text$mn:00000658 _text$mn        segment para public 'CODE' use32
.text$mn:00000658                 assume cs:_text$mn
.text$mn:00000658                 ;org 658h
.text$mn:00000658 ; COMDAT (pick any)
.text$mn:00000658                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000658
.text$mn:00000658 ; =============== S U B R O U T I N E =======================================
.text$mn:00000658
.text$mn:00000658 ; Attributes: bp-based frame
.text$mn:00000658
.text$mn:00000658 ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:00000658                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:00000658 ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:00000658                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:00000658
.text$mn:00000658 arg_0           = dword ptr  8
.text$mn:00000658
.text$mn:00000658                 push    ebp
.text$mn:00000659                 mov     ebp, esp
.text$mn:0000065B                 mov     eax, [ebp+arg_0]
.text$mn:0000065E                 pop     ebp
.text$mn:0000065F                 retn
.text$mn:0000065F ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:0000065F
.text$mn:0000065F _text$mn        ends
.text$mn:0000065F
.text$mn:00000660 ; ===========================================================================
.text$mn:00000660
.text$mn:00000660 ; Segment type: Pure code
.text$mn:00000660 ; Segment permissions: Read/Execute
.text$mn:00000660 _text$mn        segment para public 'CODE' use32
.text$mn:00000660                 assume cs:_text$mn
.text$mn:00000660                 ;org 660h
.text$mn:00000660 ; COMDAT (pick any)
.text$mn:00000660                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000660
.text$mn:00000660 ; =============== S U B R O U T I N E =======================================
.text$mn:00000660
.text$mn:00000660 ; Attributes: bp-based frame
.text$mn:00000660
.text$mn:00000660 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00000660                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00000660 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00000660                                         ; CODE XREF: $LN19+4Bp
.text$mn:00000660
.text$mn:00000660 var_4           = dword ptr -4
.text$mn:00000660 arg_0           = dword ptr  8
.text$mn:00000660 arg_4           = dword ptr  0Ch
.text$mn:00000660
.text$mn:00000660                 push    ebp
.text$mn:00000661                 mov     ebp, esp
.text$mn:00000663                 push    ecx
.text$mn:00000664                 mov     [ebp+var_4], ecx
.text$mn:00000667                 mov     eax, [ebp+arg_4]
.text$mn:0000066A                 push    eax
.text$mn:0000066B                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000670                 add     esp, 4
.text$mn:00000673                 push    eax             ; int
.text$mn:00000674                 mov     ecx, [ebp+arg_0]
.text$mn:00000677                 push    ecx             ; void *
.text$mn:00000678                 mov     edx, [ebp+var_4]
.text$mn:0000067B                 push    edx             ; int
.text$mn:0000067C                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00000681                 add     esp, 0Ch
.text$mn:00000684                 mov     esp, ebp
.text$mn:00000686                 pop     ebp
.text$mn:00000687                 retn    8
.text$mn:00000687 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00000687
.text$mn:00000687 ; ---------------------------------------------------------------------------
.text$mn:0000068A                 align 4
.text$mn:0000068A _text$mn        ends
.text$mn:0000068A
.text$mn:0000068C ; ===========================================================================
.text$mn:0000068C
.text$mn:0000068C ; Segment type: Pure code
.text$mn:0000068C ; Segment permissions: Read/Execute
.text$mn:0000068C _text$mn        segment para public 'CODE' use32
.text$mn:0000068C                 assume cs:_text$mn
.text$mn:0000068C                 ;org 68Ch
.text$mn:0000068C ; COMDAT (pick any)
.text$mn:0000068C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000068C
.text$mn:0000068C ; =============== S U B R O U T I N E =======================================
.text$mn:0000068C
.text$mn:0000068C ; Attributes: bp-based frame
.text$mn:0000068C
.text$mn:0000068C ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:0000068C                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:0000068C ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:0000068C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:0000068C
.text$mn:0000068C var_1C          = dword ptr -1Ch
.text$mn:0000068C var_18          = dword ptr -18h
.text$mn:0000068C var_14          = dword ptr -14h
.text$mn:0000068C var_10          = dword ptr -10h
.text$mn:0000068C var_C           = dword ptr -0Ch
.text$mn:0000068C var_4           = dword ptr -4
.text$mn:0000068C arg_0           = dword ptr  8
.text$mn:0000068C arg_4           = dword ptr  0Ch
.text$mn:0000068C
.text$mn:0000068C                 push    ebp
.text$mn:0000068D                 mov     ebp, esp
.text$mn:0000068F                 push    0FFFFFFFFh
.text$mn:00000691                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00000696                 mov     eax, large fs:0
.text$mn:0000069C                 push    eax
.text$mn:0000069D                 sub     esp, 10h
.text$mn:000006A0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000006A5                 xor     eax, ebp
.text$mn:000006A7                 push    eax
.text$mn:000006A8                 lea     eax, [ebp+var_C]
.text$mn:000006AB                 mov     large fs:0, eax
.text$mn:000006B1                 mov     [ebp+var_18], ecx
.text$mn:000006B4                 mov     eax, [ebp+arg_0]
.text$mn:000006B7                 push    eax             ; void *
.text$mn:000006B8                 push    4               ; unsigned int
.text$mn:000006BA                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000006BF                 add     esp, 8
.text$mn:000006C2                 mov     [ebp+var_10], eax
.text$mn:000006C5                 mov     [ebp+var_4], 0
.text$mn:000006CC                 cmp     [ebp+var_10], 0
.text$mn:000006D0                 jz      short loc_6ED
.text$mn:000006D2                 mov     ecx, [ebp+arg_4]
.text$mn:000006D5                 push    ecx
.text$mn:000006D6                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000006DB                 add     esp, 4
.text$mn:000006DE                 mov     edx, [ebp+var_10]
.text$mn:000006E1                 mov     eax, [eax]
.text$mn:000006E3                 mov     [edx], eax
.text$mn:000006E5                 mov     ecx, [ebp+var_10]
.text$mn:000006E8                 mov     [ebp+var_14], ecx
.text$mn:000006EB                 jmp     short loc_6F4
.text$mn:000006ED ; ---------------------------------------------------------------------------
.text$mn:000006ED
.text$mn:000006ED loc_6ED:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:000006ED                 mov     [ebp+var_14], 0
.text$mn:000006F4
.text$mn:000006F4 loc_6F4:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:000006F4                 mov     edx, [ebp+var_14]
.text$mn:000006F7                 mov     [ebp+var_1C], edx
.text$mn:000006FA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000701                 mov     ecx, [ebp+var_C]
.text$mn:00000704                 mov     large fs:0, ecx
.text$mn:0000070B                 pop     ecx
.text$mn:0000070C                 mov     esp, ebp
.text$mn:0000070E                 pop     ebp
.text$mn:0000070F                 retn    8
.text$mn:0000070F ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:0000070F
.text$mn:0000070F ; ---------------------------------------------------------------------------
.text$mn:00000712                 align 4
.text$mn:00000712 _text$mn        ends
.text$mn:00000712
.text$x:00000714 ; ===========================================================================
.text$x:00000714
.text$x:00000714 ; Segment type: Pure code
.text$x:00000714 ; Segment permissions: Read/Execute
.text$x:00000714 _text$x         segment para public 'CODE' use32
.text$x:00000714                 assume cs:_text$x
.text$x:00000714                 ;org 714h
.text$x:00000714 ; COMDAT (pick associative to section at 68C)
.text$x:00000714                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000714
.text$x:00000714 ; =============== S U B R O U T I N E =======================================
.text$x:00000714
.text$x:00000714
.text$x:00000714 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00000714                                         ; DATA XREF: .xdata$x:00002390o
.text$x:00000714                 mov     eax, [ebp+8]
.text$x:00000717                 push    eax
.text$x:00000718                 mov     eax, [ebp-10h]
.text$x:0000071B                 push    eax             ; void *
.text$x:0000071C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000721                 add     esp, 8
.text$x:00000724                 retn
.text$x:00000724 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00000724
.text$x:00000725
.text$x:00000725 ; =============== S U B R O U T I N E =======================================
.text$x:00000725
.text$x:00000725
.text$x:00000725 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00000725                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00000725
.text$x:00000725 arg_4           = dword ptr  8
.text$x:00000725
.text$x:00000725                 mov     edx, [esp+arg_4]
.text$x:00000729                 lea     eax, [edx+0Ch]
.text$x:0000072C                 mov     ecx, [edx-14h]
.text$x:0000072F                 xor     ecx, eax
.text$x:00000731                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000736                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:0000073B                 jmp     ___CxxFrameHandler3
.text$x:0000073B __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:0000073B
.text$x:0000073B _text$x         ends
.text$x:0000073B
.text$mn:00000740 ; ===========================================================================
.text$mn:00000740
.text$mn:00000740 ; Segment type: Pure code
.text$mn:00000740 ; Segment permissions: Read/Execute
.text$mn:00000740 _text$mn        segment para public 'CODE' use32
.text$mn:00000740                 assume cs:_text$mn
.text$mn:00000740                 ;org 740h
.text$mn:00000740 ; COMDAT (pick any)
.text$mn:00000740                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000740
.text$mn:00000740 ; =============== S U B R O U T I N E =======================================
.text$mn:00000740
.text$mn:00000740 ; Attributes: bp-based frame
.text$mn:00000740
.text$mn:00000740 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00000740                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00000740 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00000740                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00000740
.text$mn:00000740 arg_0           = dword ptr  8
.text$mn:00000740 arg_4           = dword ptr  0Ch
.text$mn:00000740 arg_8           = dword ptr  10h
.text$mn:00000740
.text$mn:00000740                 push    ebp
.text$mn:00000741                 mov     ebp, esp
.text$mn:00000743                 mov     eax, [ebp+arg_8]
.text$mn:00000746                 push    eax
.text$mn:00000747                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000074C                 add     esp, 4
.text$mn:0000074F                 push    eax             ; int
.text$mn:00000750                 mov     ecx, [ebp+arg_4]
.text$mn:00000753                 push    ecx             ; void *
.text$mn:00000754                 mov     ecx, [ebp+arg_0]
.text$mn:00000757                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:0000075C                 pop     ebp
.text$mn:0000075D                 retn
.text$mn:0000075D ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:0000075D
.text$mn:0000075D ; ---------------------------------------------------------------------------
.text$mn:0000075E                 align 10h
.text$mn:0000075E _text$mn        ends
.text$mn:0000075E
.text$mn:00000760 ; ===========================================================================
.text$mn:00000760
.text$mn:00000760 ; Segment type: Pure code
.text$mn:00000760 ; Segment permissions: Read/Execute
.text$mn:00000760 _text$mn        segment para public 'CODE' use32
.text$mn:00000760                 assume cs:_text$mn
.text$mn:00000760                 ;org 760h
.text$mn:00000760 ; COMDAT (pick any)
.text$mn:00000760                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000760
.text$mn:00000760 ; =============== S U B R O U T I N E =======================================
.text$mn:00000760
.text$mn:00000760 ; Attributes: bp-based frame
.text$mn:00000760
.text$mn:00000760 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00000760                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00000760 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00000760                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00000760
.text$mn:00000760 var_1C          = dword ptr -1Ch
.text$mn:00000760 var_18          = dword ptr -18h
.text$mn:00000760 var_14          = dword ptr -14h
.text$mn:00000760 var_10          = dword ptr -10h
.text$mn:00000760 var_C           = dword ptr -0Ch
.text$mn:00000760 var_4           = dword ptr -4
.text$mn:00000760 arg_0           = dword ptr  8
.text$mn:00000760 arg_4           = dword ptr  0Ch
.text$mn:00000760
.text$mn:00000760                 push    ebp
.text$mn:00000761                 mov     ebp, esp
.text$mn:00000763                 push    0FFFFFFFFh
.text$mn:00000765                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:0000076A                 mov     eax, large fs:0
.text$mn:00000770                 push    eax
.text$mn:00000771                 sub     esp, 10h
.text$mn:00000774                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000779                 xor     eax, ebp
.text$mn:0000077B                 push    eax
.text$mn:0000077C                 lea     eax, [ebp+var_C]
.text$mn:0000077F                 mov     large fs:0, eax
.text$mn:00000785                 mov     [ebp+var_18], ecx
.text$mn:00000788                 mov     eax, [ebp+arg_0]
.text$mn:0000078B                 push    eax             ; void *
.text$mn:0000078C                 push    8               ; unsigned int
.text$mn:0000078E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000793                 add     esp, 8
.text$mn:00000796                 mov     [ebp+var_10], eax
.text$mn:00000799                 mov     [ebp+var_4], 0
.text$mn:000007A0                 cmp     [ebp+var_10], 0
.text$mn:000007A4                 jz      short loc_7C7
.text$mn:000007A6                 mov     ecx, [ebp+arg_4]
.text$mn:000007A9                 push    ecx
.text$mn:000007AA                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:000007AF                 add     esp, 4
.text$mn:000007B2                 mov     edx, [eax]
.text$mn:000007B4                 mov     eax, [eax+4]
.text$mn:000007B7                 mov     ecx, [ebp+var_10]
.text$mn:000007BA                 mov     [ecx], edx
.text$mn:000007BC                 mov     [ecx+4], eax
.text$mn:000007BF                 mov     edx, [ebp+var_10]
.text$mn:000007C2                 mov     [ebp+var_14], edx
.text$mn:000007C5                 jmp     short loc_7CE
.text$mn:000007C7 ; ---------------------------------------------------------------------------
.text$mn:000007C7
.text$mn:000007C7 loc_7C7:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:000007C7                 mov     [ebp+var_14], 0
.text$mn:000007CE
.text$mn:000007CE loc_7CE:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:000007CE                 mov     eax, [ebp+var_14]
.text$mn:000007D1                 mov     [ebp+var_1C], eax
.text$mn:000007D4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000007DB                 mov     ecx, [ebp+var_C]
.text$mn:000007DE                 mov     large fs:0, ecx
.text$mn:000007E5                 pop     ecx
.text$mn:000007E6                 mov     esp, ebp
.text$mn:000007E8                 pop     ebp
.text$mn:000007E9                 retn    8
.text$mn:000007E9 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:000007E9
.text$mn:000007E9 _text$mn        ends
.text$mn:000007E9
.text$x:000007EC ; ===========================================================================
.text$x:000007EC
.text$x:000007EC ; Segment type: Pure code
.text$x:000007EC ; Segment permissions: Read/Execute
.text$x:000007EC _text$x         segment para public 'CODE' use32
.text$x:000007EC                 assume cs:_text$x
.text$x:000007EC                 ;org 7ECh
.text$x:000007EC ; COMDAT (pick associative to section at 760)
.text$x:000007EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000007EC
.text$x:000007EC ; =============== S U B R O U T I N E =======================================
.text$x:000007EC
.text$x:000007EC
.text$x:000007EC __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:000007EC                                         ; DATA XREF: .xdata$x:00002364o
.text$x:000007EC                 mov     eax, [ebp+8]
.text$x:000007EF                 push    eax
.text$x:000007F0                 mov     eax, [ebp-10h]
.text$x:000007F3                 push    eax             ; void *
.text$x:000007F4                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000007F9                 add     esp, 8
.text$x:000007FC                 retn
.text$x:000007FC __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:000007FC
.text$x:000007FD
.text$x:000007FD ; =============== S U B R O U T I N E =======================================
.text$x:000007FD
.text$x:000007FD
.text$x:000007FD __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:000007FD                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:000007FD
.text$x:000007FD arg_4           = dword ptr  8
.text$x:000007FD
.text$x:000007FD                 mov     edx, [esp+arg_4]
.text$x:00000801                 lea     eax, [edx+0Ch]
.text$x:00000804                 mov     ecx, [edx-14h]
.text$x:00000807                 xor     ecx, eax
.text$x:00000809                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000080E                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00000813                 jmp     ___CxxFrameHandler3
.text$x:00000813 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00000813
.text$x:00000813 _text$x         ends
.text$x:00000813
.text$mn:00000818 ; ===========================================================================
.text$mn:00000818
.text$mn:00000818 ; Segment type: Pure code
.text$mn:00000818 ; Segment permissions: Read/Execute
.text$mn:00000818 _text$mn        segment para public 'CODE' use32
.text$mn:00000818                 assume cs:_text$mn
.text$mn:00000818                 ;org 818h
.text$mn:00000818 ; COMDAT (pick any)
.text$mn:00000818                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000818
.text$mn:00000818 ; =============== S U B R O U T I N E =======================================
.text$mn:00000818
.text$mn:00000818 ; Attributes: bp-based frame
.text$mn:00000818
.text$mn:00000818 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00000818                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00000818 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00000818                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00000818
.text$mn:00000818 var_4           = dword ptr -4
.text$mn:00000818 arg_0           = dword ptr  8
.text$mn:00000818
.text$mn:00000818                 push    ebp
.text$mn:00000819                 mov     ebp, esp
.text$mn:0000081B                 push    ecx
.text$mn:0000081C                 mov     [ebp+var_4], ecx
.text$mn:0000081F                 mov     eax, [ebp+arg_0]
.text$mn:00000822                 push    eax
.text$mn:00000823                 mov     ecx, [ebp+var_4]
.text$mn:00000826                 push    ecx
.text$mn:00000827                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:0000082C                 add     esp, 8
.text$mn:0000082F                 mov     esp, ebp
.text$mn:00000831                 pop     ebp
.text$mn:00000832                 retn    4
.text$mn:00000832 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00000832
.text$mn:00000832 ; ---------------------------------------------------------------------------
.text$mn:00000835                 align 4
.text$mn:00000835 _text$mn        ends
.text$mn:00000835
.text$mn:00000838 ; ===========================================================================
.text$mn:00000838
.text$mn:00000838 ; Segment type: Pure code
.text$mn:00000838 ; Segment permissions: Read/Execute
.text$mn:00000838 _text$mn        segment para public 'CODE' use32
.text$mn:00000838                 assume cs:_text$mn
.text$mn:00000838                 ;org 838h
.text$mn:00000838 ; COMDAT (pick any)
.text$mn:00000838                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000838
.text$mn:00000838 ; =============== S U B R O U T I N E =======================================
.text$mn:00000838
.text$mn:00000838 ; Attributes: bp-based frame
.text$mn:00000838
.text$mn:00000838 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000838                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00000838 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00000838                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00000838
.text$mn:00000838 var_4           = dword ptr -4
.text$mn:00000838
.text$mn:00000838                 push    ebp
.text$mn:00000839                 mov     ebp, esp
.text$mn:0000083B                 push    ecx
.text$mn:0000083C                 mov     [ebp+var_4], ecx
.text$mn:0000083F                 mov     esp, ebp
.text$mn:00000841                 pop     ebp
.text$mn:00000842                 retn    4
.text$mn:00000842 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00000842
.text$mn:00000842 ; ---------------------------------------------------------------------------
.text$mn:00000845                 align 4
.text$mn:00000845 _text$mn        ends
.text$mn:00000845
.text$mn:00000848 ; ===========================================================================
.text$mn:00000848
.text$mn:00000848 ; Segment type: Pure code
.text$mn:00000848 ; Segment permissions: Read/Execute
.text$mn:00000848 _text$mn        segment para public 'CODE' use32
.text$mn:00000848                 assume cs:_text$mn
.text$mn:00000848                 ;org 848h
.text$mn:00000848 ; COMDAT (pick any)
.text$mn:00000848                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000848
.text$mn:00000848 ; =============== S U B R O U T I N E =======================================
.text$mn:00000848
.text$mn:00000848 ; Attributes: bp-based frame
.text$mn:00000848
.text$mn:00000848 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00000848                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00000848 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00000848                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00000848
.text$mn:00000848 arg_0           = dword ptr  8
.text$mn:00000848 arg_4           = dword ptr  0Ch
.text$mn:00000848
.text$mn:00000848                 push    ebp
.text$mn:00000849                 mov     ebp, esp
.text$mn:0000084B                 mov     eax, [ebp+arg_4]
.text$mn:0000084E                 push    eax
.text$mn:0000084F                 mov     ecx, [ebp+arg_0]
.text$mn:00000852                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000857                 pop     ebp
.text$mn:00000858                 retn
.text$mn:00000858 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00000858
.text$mn:00000858 ; ---------------------------------------------------------------------------
.text$mn:00000859                 align 4
.text$mn:00000859 _text$mn        ends
.text$mn:00000859
.text$mn:0000085C ; ===========================================================================
.text$mn:0000085C
.text$mn:0000085C ; Segment type: Pure code
.text$mn:0000085C ; Segment permissions: Read/Execute
.text$mn:0000085C _text$mn        segment para public 'CODE' use32
.text$mn:0000085C                 assume cs:_text$mn
.text$mn:0000085C                 ;org 85Ch
.text$mn:0000085C ; COMDAT (pick any)
.text$mn:0000085C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000085C
.text$mn:0000085C ; =============== S U B R O U T I N E =======================================
.text$mn:0000085C
.text$mn:0000085C ; Attributes: bp-based frame
.text$mn:0000085C
.text$mn:0000085C ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:0000085C                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:0000085C ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:0000085C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:0000085C
.text$mn:0000085C var_4           = dword ptr -4
.text$mn:0000085C
.text$mn:0000085C                 push    ebp
.text$mn:0000085D                 mov     ebp, esp
.text$mn:0000085F                 push    ecx
.text$mn:00000860                 mov     [ebp+var_4], ecx
.text$mn:00000863                 mov     esp, ebp
.text$mn:00000865                 pop     ebp
.text$mn:00000866                 retn    4
.text$mn:00000866 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00000866
.text$mn:00000866 ; ---------------------------------------------------------------------------
.text$mn:00000869                 align 4
.text$mn:00000869 _text$mn        ends
.text$mn:00000869
.text$mn:0000086C ; ===========================================================================
.text$mn:0000086C
.text$mn:0000086C ; Segment type: Pure code
.text$mn:0000086C ; Segment permissions: Read/Execute
.text$mn:0000086C _text$mn        segment para public 'CODE' use32
.text$mn:0000086C                 assume cs:_text$mn
.text$mn:0000086C                 ;org 86Ch
.text$mn:0000086C ; COMDAT (pick any)
.text$mn:0000086C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000086C
.text$mn:0000086C ; =============== S U B R O U T I N E =======================================
.text$mn:0000086C
.text$mn:0000086C ; Attributes: bp-based frame
.text$mn:0000086C
.text$mn:0000086C ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:0000086C                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:0000086C ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:0000086C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:0000086C                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:0000086C
.text$mn:0000086C arg_0           = dword ptr  8
.text$mn:0000086C
.text$mn:0000086C                 push    ebp
.text$mn:0000086D                 mov     ebp, esp
.text$mn:0000086F                 mov     eax, [ebp+arg_0]
.text$mn:00000872                 pop     ebp
.text$mn:00000873                 retn
.text$mn:00000873 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00000873
.text$mn:00000873 _text$mn        ends
.text$mn:00000873
.text$mn:00000874 ; ===========================================================================
.text$mn:00000874
.text$mn:00000874 ; Segment type: Pure code
.text$mn:00000874 ; Segment permissions: Read/Execute
.text$mn:00000874 _text$mn        segment para public 'CODE' use32
.text$mn:00000874                 assume cs:_text$mn
.text$mn:00000874                 ;org 874h
.text$mn:00000874 ; COMDAT (pick any)
.text$mn:00000874                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000874
.text$mn:00000874 ; =============== S U B R O U T I N E =======================================
.text$mn:00000874
.text$mn:00000874 ; Attributes: bp-based frame
.text$mn:00000874
.text$mn:00000874 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00000874                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00000874 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00000874                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00000874
.text$mn:00000874 arg_0           = dword ptr  8
.text$mn:00000874
.text$mn:00000874                 push    ebp
.text$mn:00000875                 mov     ebp, esp
.text$mn:00000877                 mov     eax, [ebp+arg_0]
.text$mn:0000087A                 pop     ebp
.text$mn:0000087B                 retn
.text$mn:0000087B ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:0000087B
.text$mn:0000087B _text$mn        ends
.text$mn:0000087B
.text$mn:0000087C ; ===========================================================================
.text$mn:0000087C
.text$mn:0000087C ; Segment type: Pure code
.text$mn:0000087C ; Segment permissions: Read/Execute
.text$mn:0000087C _text$mn        segment para public 'CODE' use32
.text$mn:0000087C                 assume cs:_text$mn
.text$mn:0000087C                 ;org 87Ch
.text$mn:0000087C ; COMDAT (pick any)
.text$mn:0000087C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000087C
.text$mn:0000087C ; =============== S U B R O U T I N E =======================================
.text$mn:0000087C
.text$mn:0000087C ; Attributes: bp-based frame
.text$mn:0000087C
.text$mn:0000087C ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:0000087C                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:0000087C ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:0000087C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:0000087C
.text$mn:0000087C var_10          = dword ptr -10h
.text$mn:0000087C var_C           = dword ptr -0Ch
.text$mn:0000087C var_4           = dword ptr -4
.text$mn:0000087C
.text$mn:0000087C                 push    ebp
.text$mn:0000087D                 mov     ebp, esp
.text$mn:0000087F                 push    0FFFFFFFFh
.text$mn:00000881                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000886                 mov     eax, large fs:0
.text$mn:0000088C                 push    eax
.text$mn:0000088D                 push    ecx
.text$mn:0000088E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000893                 xor     eax, ebp
.text$mn:00000895                 push    eax
.text$mn:00000896                 lea     eax, [ebp+var_C]
.text$mn:00000899                 mov     large fs:0, eax
.text$mn:0000089F                 mov     [ebp+var_10], ecx
.text$mn:000008A2                 mov     ecx, [ebp+var_10]
.text$mn:000008A5                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:000008AA                 mov     [ebp+var_4], 0
.text$mn:000008B1                 mov     ecx, [ebp+var_10]
.text$mn:000008B4                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000008B9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000008C0                 mov     eax, [ebp+var_10]
.text$mn:000008C3                 mov     ecx, [ebp+var_C]
.text$mn:000008C6                 mov     large fs:0, ecx
.text$mn:000008CD                 pop     ecx
.text$mn:000008CE                 mov     esp, ebp
.text$mn:000008D0                 pop     ebp
.text$mn:000008D1                 retn    4
.text$mn:000008D1 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:000008D1
.text$mn:000008D1 _text$mn        ends
.text$mn:000008D1
.text$x:000008D4 ; ===========================================================================
.text$x:000008D4
.text$x:000008D4 ; Segment type: Pure code
.text$x:000008D4 ; Segment permissions: Read/Execute
.text$x:000008D4 _text$x         segment para public 'CODE' use32
.text$x:000008D4                 assume cs:_text$x
.text$x:000008D4                 ;org 8D4h
.text$x:000008D4 ; COMDAT (pick associative to section at 87C)
.text$x:000008D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000008D4
.text$x:000008D4 ; =============== S U B R O U T I N E =======================================
.text$x:000008D4
.text$x:000008D4
.text$x:000008D4 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:000008D4                                         ; DATA XREF: .xdata$x:0000209Co
.text$x:000008D4                 mov     ecx, [ebp-10h]
.text$x:000008D7                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:000008D7 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:000008D7
.text$x:000008DC
.text$x:000008DC ; =============== S U B R O U T I N E =======================================
.text$x:000008DC
.text$x:000008DC
.text$x:000008DC __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:000008DC                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:000008DC
.text$x:000008DC arg_4           = dword ptr  8
.text$x:000008DC
.text$x:000008DC                 mov     edx, [esp+arg_4]
.text$x:000008E0                 lea     eax, [edx+0Ch]
.text$x:000008E3                 mov     ecx, [edx-8]
.text$x:000008E6                 xor     ecx, eax
.text$x:000008E8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000008ED                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:000008F2                 jmp     ___CxxFrameHandler3
.text$x:000008F2 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:000008F2
.text$x:000008F2 ; ---------------------------------------------------------------------------
.text$x:000008F7                 align 4
.text$x:000008F7 _text$x         ends
.text$x:000008F7
.text$mn:000008F8 ; ===========================================================================
.text$mn:000008F8
.text$mn:000008F8 ; Segment type: Pure code
.text$mn:000008F8 ; Segment permissions: Read/Execute
.text$mn:000008F8 _text$mn        segment para public 'CODE' use32
.text$mn:000008F8                 assume cs:_text$mn
.text$mn:000008F8                 ;org 8F8h
.text$mn:000008F8 ; COMDAT (pick any)
.text$mn:000008F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000008F8
.text$mn:000008F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000008F8
.text$mn:000008F8 ; Attributes: bp-based frame
.text$mn:000008F8
.text$mn:000008F8 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000008F8                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000008F8 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000008F8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:000008F8
.text$mn:000008F8 var_10          = dword ptr -10h
.text$mn:000008F8 var_C           = dword ptr -0Ch
.text$mn:000008F8 var_4           = dword ptr -4
.text$mn:000008F8
.text$mn:000008F8                 push    ebp
.text$mn:000008F9                 mov     ebp, esp
.text$mn:000008FB                 push    0FFFFFFFFh
.text$mn:000008FD                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000902                 mov     eax, large fs:0
.text$mn:00000908                 push    eax
.text$mn:00000909                 push    ecx
.text$mn:0000090A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000090F                 xor     eax, ebp
.text$mn:00000911                 push    eax
.text$mn:00000912                 lea     eax, [ebp+var_C]
.text$mn:00000915                 mov     large fs:0, eax
.text$mn:0000091B                 mov     [ebp+var_10], ecx
.text$mn:0000091E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000921                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00000926                 mov     [ebp+var_4], 0
.text$mn:0000092D                 mov     eax, [ebp+var_10]
.text$mn:00000930                 mov     dword ptr [eax+14h], 0
.text$mn:00000937                 mov     ecx, [ebp+var_10]
.text$mn:0000093A                 mov     dword ptr [ecx+18h], 0
.text$mn:00000941                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000948                 mov     eax, [ebp+var_10]
.text$mn:0000094B                 mov     ecx, [ebp+var_C]
.text$mn:0000094E                 mov     large fs:0, ecx
.text$mn:00000955                 pop     ecx
.text$mn:00000956                 mov     esp, ebp
.text$mn:00000958                 pop     ebp
.text$mn:00000959                 retn
.text$mn:00000959 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000959
.text$mn:00000959 ; ---------------------------------------------------------------------------
.text$mn:0000095A                 align 4
.text$mn:0000095A _text$mn        ends
.text$mn:0000095A
.text$x:0000095C ; ===========================================================================
.text$x:0000095C
.text$x:0000095C ; Segment type: Pure code
.text$x:0000095C ; Segment permissions: Read/Execute
.text$x:0000095C _text$x         segment para public 'CODE' use32
.text$x:0000095C                 assume cs:_text$x
.text$x:0000095C                 ;org 95Ch
.text$x:0000095C ; COMDAT (pick associative to section at 8F8)
.text$x:0000095C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000095C
.text$x:0000095C ; =============== S U B R O U T I N E =======================================
.text$x:0000095C
.text$x:0000095C
.text$x:0000095C __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:0000095C                                         ; DATA XREF: .xdata$x:00002044o
.text$x:0000095C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000095F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000095F __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:0000095F
.text$x:00000964
.text$x:00000964 ; =============== S U B R O U T I N E =======================================
.text$x:00000964
.text$x:00000964
.text$x:00000964 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000964                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000964
.text$x:00000964 arg_4           = dword ptr  8
.text$x:00000964
.text$x:00000964                 mov     edx, [esp+arg_4]
.text$x:00000968                 lea     eax, [edx+0Ch]
.text$x:0000096B                 mov     ecx, [edx-8]
.text$x:0000096E                 xor     ecx, eax
.text$x:00000970                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000975                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000097A                 jmp     ___CxxFrameHandler3
.text$x:0000097A __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000097A
.text$x:0000097A ; ---------------------------------------------------------------------------
.text$x:0000097F                 align 10h
.text$x:0000097F _text$x         ends
.text$x:0000097F
.text$mn:00000980 ; ===========================================================================
.text$mn:00000980
.text$mn:00000980 ; Segment type: Pure code
.text$mn:00000980 ; Segment permissions: Read/Execute
.text$mn:00000980 _text$mn        segment para public 'CODE' use32
.text$mn:00000980                 assume cs:_text$mn
.text$mn:00000980                 ;org 980h
.text$mn:00000980 ; COMDAT (pick any)
.text$mn:00000980                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000980
.text$mn:00000980 ; =============== S U B R O U T I N E =======================================
.text$mn:00000980
.text$mn:00000980 ; Attributes: bp-based frame
.text$mn:00000980
.text$mn:00000980 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00000980                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00000980 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00000980                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00000980
.text$mn:00000980 var_4           = dword ptr -4
.text$mn:00000980
.text$mn:00000980                 push    ebp
.text$mn:00000981                 mov     ebp, esp
.text$mn:00000983                 push    ecx
.text$mn:00000984                 mov     [ebp+var_4], ecx
.text$mn:00000987                 mov     ecx, [ebp+var_4]
.text$mn:0000098A                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:0000098F                 mov     eax, [ebp+var_4]
.text$mn:00000992
.text$mn:00000992 ; const WCHAR TemplateName
.text$mn:00000992 TemplateName:                           ; DATA XREF: TaskListDlg::doDialog(bool)+6Fo
.text$mn:00000992                 mov     esp, ebp
.text$mn:00000994                 pop     ebp
.text$mn:00000995                 retn
.text$mn:00000995 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00000995
.text$mn:00000995 ; ---------------------------------------------------------------------------
.text$mn:00000996                 align 4
.text$mn:00000996 _text$mn        ends
.text$mn:00000996
.text$mn:00000998 ; ===========================================================================
.text$mn:00000998
.text$mn:00000998 ; Segment type: Pure code
.text$mn:00000998 ; Segment permissions: Read/Execute
.text$mn:00000998 _text$mn        segment para public 'CODE' use32
.text$mn:00000998                 assume cs:_text$mn
.text$mn:00000998                 ;org 998h
.text$mn:00000998 ; COMDAT (pick any)
.text$mn:00000998                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000998
.text$mn:00000998 ; =============== S U B R O U T I N E =======================================
.text$mn:00000998
.text$mn:00000998 ; Attributes: bp-based frame
.text$mn:00000998
.text$mn:00000998 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00000998                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00000998 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00000998                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00000998
.text$mn:00000998 var_4           = dword ptr -4
.text$mn:00000998
.text$mn:00000998                 push    ebp
.text$mn:00000999                 mov     ebp, esp
.text$mn:0000099B                 push    ecx
.text$mn:0000099C                 mov     [ebp+var_4], ecx
.text$mn:0000099F                 mov     eax, [ebp+var_4]
.text$mn:000009A2                 mov     esp, ebp
.text$mn:000009A4                 pop     ebp
.text$mn:000009A5                 retn
.text$mn:000009A5 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:000009A5
.text$mn:000009A5 ; ---------------------------------------------------------------------------
.text$mn:000009A6                 align 4
.text$mn:000009A6 _text$mn        ends
.text$mn:000009A6
.text$mn:000009A8 ; ===========================================================================
.text$mn:000009A8
.text$mn:000009A8 ; Segment type: Pure code
.text$mn:000009A8 ; Segment permissions: Read/Execute
.text$mn:000009A8 _text$mn        segment para public 'CODE' use32
.text$mn:000009A8                 assume cs:_text$mn
.text$mn:000009A8                 ;org 9A8h
.text$mn:000009A8 ; COMDAT (pick any)
.text$mn:000009A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000009A8
.text$mn:000009A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000009A8
.text$mn:000009A8 ; Attributes: bp-based frame
.text$mn:000009A8
.text$mn:000009A8 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:000009A8                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:000009A8 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:000009A8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:000009A8                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:000009A8
.text$mn:000009A8 var_4           = dword ptr -4
.text$mn:000009A8
.text$mn:000009A8                 push    ebp
.text$mn:000009A9                 mov     ebp, esp
.text$mn:000009AB                 push    ecx
.text$mn:000009AC                 mov     [ebp+var_4], ecx
.text$mn:000009AF                 mov     eax, [ebp+var_4]
.text$mn:000009B2                 mov     esp, ebp
.text$mn:000009B4                 pop     ebp
.text$mn:000009B5                 retn
.text$mn:000009B5 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:000009B5
.text$mn:000009B5 ; ---------------------------------------------------------------------------
.text$mn:000009B6                 align 4
.text$mn:000009B6 _text$mn        ends
.text$mn:000009B6
.text$mn:000009B8 ; ===========================================================================
.text$mn:000009B8
.text$mn:000009B8 ; Segment type: Pure code
.text$mn:000009B8 ; Segment permissions: Read/Execute
.text$mn:000009B8 _text$mn        segment para public 'CODE' use32
.text$mn:000009B8                 assume cs:_text$mn
.text$mn:000009B8                 ;org 9B8h
.text$mn:000009B8 ; COMDAT (pick any)
.text$mn:000009B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000009B8
.text$mn:000009B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000009B8
.text$mn:000009B8 ; Attributes: bp-based frame
.text$mn:000009B8
.text$mn:000009B8 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:000009B8                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:000009B8 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:000009B8                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:000009B8                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:000009B8
.text$mn:000009B8 var_14          = dword ptr -14h
.text$mn:000009B8 var_D           = byte ptr -0Dh
.text$mn:000009B8 var_C           = dword ptr -0Ch
.text$mn:000009B8 var_4           = dword ptr -4
.text$mn:000009B8 Str             = dword ptr  8
.text$mn:000009B8
.text$mn:000009B8                 push    ebp
.text$mn:000009B9                 mov     ebp, esp
.text$mn:000009BB                 push    0FFFFFFFFh
.text$mn:000009BD                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:000009C2                 mov     eax, large fs:0
.text$mn:000009C8                 push    eax
.text$mn:000009C9                 sub     esp, 8
.text$mn:000009CC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000009D1                 xor     eax, ebp
.text$mn:000009D3                 push    eax
.text$mn:000009D4                 lea     eax, [ebp+var_C]
.text$mn:000009D7                 mov     large fs:0, eax
.text$mn:000009DD                 mov     [ebp+var_14], ecx
.text$mn:000009E0                 lea     ecx, [ebp+var_D]
.text$mn:000009E3                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000009E8                 push    eax
.text$mn:000009E9                 mov     ecx, [ebp+var_14]
.text$mn:000009EC                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:000009F1                 mov     [ebp+var_4], 0
.text$mn:000009F8                 push    0               ; Size
.text$mn:000009FA                 push    0               ; char
.text$mn:000009FC                 mov     ecx, [ebp+var_14]
.text$mn:000009FF                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000A04                 mov     eax, [ebp+Str]
.text$mn:00000A07                 push    eax             ; Str
.text$mn:00000A08                 mov     ecx, [ebp+var_14]
.text$mn:00000A0B                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00000A10                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000A17                 mov     eax, [ebp+var_14]
.text$mn:00000A1A                 mov     ecx, [ebp+var_C]
.text$mn:00000A1D                 mov     large fs:0, ecx
.text$mn:00000A24                 pop     ecx
.text$mn:00000A25                 mov     esp, ebp
.text$mn:00000A27                 pop     ebp
.text$mn:00000A28                 retn    4
.text$mn:00000A28 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00000A28
.text$mn:00000A28 ; ---------------------------------------------------------------------------
.text$mn:00000A2B                 align 4
.text$mn:00000A2B _text$mn        ends
.text$mn:00000A2B
.text$x:00000A2C ; ===========================================================================
.text$x:00000A2C
.text$x:00000A2C ; Segment type: Pure code
.text$x:00000A2C ; Segment permissions: Read/Execute
.text$x:00000A2C _text$x         segment para public 'CODE' use32
.text$x:00000A2C                 assume cs:_text$x
.text$x:00000A2C                 ;org 0A2Ch
.text$x:00000A2C ; COMDAT (pick associative to section at 9B8)
.text$x:00000A2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000A2C
.text$x:00000A2C ; =============== S U B R O U T I N E =======================================
.text$x:00000A2C
.text$x:00000A2C
.text$x:00000A2C __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00000A2C                                         ; DATA XREF: .xdata$x:000020F4o
.text$x:00000A2C                 mov     ecx, [ebp-14h]
.text$x:00000A2F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000A2F __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00000A2F
.text$x:00000A34
.text$x:00000A34 ; =============== S U B R O U T I N E =======================================
.text$x:00000A34
.text$x:00000A34
.text$x:00000A34 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00000A34                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00000A34
.text$x:00000A34 arg_4           = dword ptr  8
.text$x:00000A34
.text$x:00000A34                 mov     edx, [esp+arg_4]
.text$x:00000A38                 lea     eax, [edx+0Ch]
.text$x:00000A3B                 mov     ecx, [edx-0Ch]
.text$x:00000A3E                 xor     ecx, eax
.text$x:00000A40                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000A45                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00000A4A                 jmp     ___CxxFrameHandler3
.text$x:00000A4A __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00000A4A
.text$x:00000A4A ; ---------------------------------------------------------------------------
.text$x:00000A4F                 align 10h
.text$x:00000A4F _text$x         ends
.text$x:00000A4F
.text$mn:00000A50 ; ===========================================================================
.text$mn:00000A50
.text$mn:00000A50 ; Segment type: Pure code
.text$mn:00000A50 ; Segment permissions: Read/Execute
.text$mn:00000A50 _text$mn        segment para public 'CODE' use32
.text$mn:00000A50                 assume cs:_text$mn
.text$mn:00000A50                 ;org 0A50h
.text$mn:00000A50 ; COMDAT (pick any)
.text$mn:00000A50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A50
.text$mn:00000A50 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A50
.text$mn:00000A50 ; Attributes: bp-based frame
.text$mn:00000A50
.text$mn:00000A50 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000A50                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00000A50 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00000A50                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00000A50
.text$mn:00000A50 var_4           = dword ptr -4
.text$mn:00000A50
.text$mn:00000A50                 push    ebp
.text$mn:00000A51                 mov     ebp, esp
.text$mn:00000A53                 push    ecx
.text$mn:00000A54                 mov     [ebp+var_4], ecx
.text$mn:00000A57                 mov     eax, [ebp+var_4]
.text$mn:00000A5A                 mov     dword ptr [eax], 0
.text$mn:00000A60                 mov     eax, [ebp+var_4]
.text$mn:00000A63                 mov     esp, ebp
.text$mn:00000A65                 pop     ebp
.text$mn:00000A66                 retn
.text$mn:00000A66 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00000A66
.text$mn:00000A66 ; ---------------------------------------------------------------------------
.text$mn:00000A67                 align 4
.text$mn:00000A67 _text$mn        ends
.text$mn:00000A67
.text$mn:00000A68 ; ===========================================================================
.text$mn:00000A68
.text$mn:00000A68 ; Segment type: Pure code
.text$mn:00000A68 ; Segment permissions: Read/Execute
.text$mn:00000A68 _text$mn        segment para public 'CODE' use32
.text$mn:00000A68                 assume cs:_text$mn
.text$mn:00000A68                 ;org 0A68h
.text$mn:00000A68 ; COMDAT (pick any)
.text$mn:00000A68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A68
.text$mn:00000A68 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A68
.text$mn:00000A68 ; Attributes: bp-based frame
.text$mn:00000A68
.text$mn:00000A68 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00000A68                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00000A68 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00000A68                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00000A68
.text$mn:00000A68 var_4           = dword ptr -4
.text$mn:00000A68
.text$mn:00000A68                 push    ebp
.text$mn:00000A69                 mov     ebp, esp
.text$mn:00000A6B                 push    ecx
.text$mn:00000A6C                 mov     [ebp+var_4], ecx
.text$mn:00000A6F                 mov     eax, [ebp+var_4]
.text$mn:00000A72                 mov     dword ptr [eax], 0
.text$mn:00000A78                 mov     ecx, [ebp+var_4]
.text$mn:00000A7B                 mov     dword ptr [ecx+4], 0
.text$mn:00000A82                 mov     eax, [ebp+var_4]
.text$mn:00000A85                 mov     esp, ebp
.text$mn:00000A87                 pop     ebp
.text$mn:00000A88                 retn
.text$mn:00000A88 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00000A88
.text$mn:00000A88 ; ---------------------------------------------------------------------------
.text$mn:00000A89                 align 4
.text$mn:00000A89 _text$mn        ends
.text$mn:00000A89
.text$mn:00000A8C ; ===========================================================================
.text$mn:00000A8C
.text$mn:00000A8C ; Segment type: Pure code
.text$mn:00000A8C ; Segment permissions: Read/Execute
.text$mn:00000A8C _text$mn        segment para public 'CODE' use32
.text$mn:00000A8C                 assume cs:_text$mn
.text$mn:00000A8C                 ;org 0A8Ch
.text$mn:00000A8C ; COMDAT (pick any)
.text$mn:00000A8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A8C
.text$mn:00000A8C ; =============== S U B R O U T I N E =======================================
.text$mn:00000A8C
.text$mn:00000A8C ; Attributes: bp-based frame
.text$mn:00000A8C
.text$mn:00000A8C ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00000A8C                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00000A8C ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00000A8C                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00000A8C                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00000A8C
.text$mn:00000A8C var_10          = dword ptr -10h
.text$mn:00000A8C var_C           = dword ptr -0Ch
.text$mn:00000A8C var_4           = dword ptr -4
.text$mn:00000A8C
.text$mn:00000A8C                 push    ebp
.text$mn:00000A8D                 mov     ebp, esp
.text$mn:00000A8F                 push    0FFFFFFFFh
.text$mn:00000A91                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00000A96                 mov     eax, large fs:0
.text$mn:00000A9C                 push    eax
.text$mn:00000A9D                 push    ecx
.text$mn:00000A9E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000AA3                 xor     eax, ebp
.text$mn:00000AA5                 push    eax
.text$mn:00000AA6                 lea     eax, [ebp+var_C]
.text$mn:00000AA9                 mov     large fs:0, eax
.text$mn:00000AAF                 mov     [ebp+var_10], ecx
.text$mn:00000AB2                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000AB5                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00000ABA                 mov     [ebp+var_4], 0
.text$mn:00000AC1                 mov     eax, [ebp+var_10]
.text$mn:00000AC4                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00000ACA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000AD1                 mov     eax, [ebp+var_10]
.text$mn:00000AD4                 mov     ecx, [ebp+var_C]
.text$mn:00000AD7                 mov     large fs:0, ecx
.text$mn:00000ADE                 pop     ecx
.text$mn:00000ADF                 mov     esp, ebp
.text$mn:00000AE1                 pop     ebp
.text$mn:00000AE2                 retn
.text$mn:00000AE2 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00000AE2
.text$mn:00000AE2 ; ---------------------------------------------------------------------------
.text$mn:00000AE3                 align 4
.text$mn:00000AE3 _text$mn        ends
.text$mn:00000AE3
.text$x:00000AE4 ; ===========================================================================
.text$x:00000AE4
.text$x:00000AE4 ; Segment type: Pure code
.text$x:00000AE4 ; Segment permissions: Read/Execute
.text$x:00000AE4 _text$x         segment para public 'CODE' use32
.text$x:00000AE4                 assume cs:_text$x
.text$x:00000AE4                 ;org 0AE4h
.text$x:00000AE4 ; COMDAT (pick associative to section at A8C)
.text$x:00000AE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000AE4
.text$x:00000AE4 ; =============== S U B R O U T I N E =======================================
.text$x:00000AE4
.text$x:00000AE4
.text$x:00000AE4 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00000AE4                                         ; DATA XREF: .xdata$x:000021D8o
.text$x:00000AE4                 mov     ecx, [ebp-10h]  ; this
.text$x:00000AE7                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00000AE7 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00000AE7
.text$x:00000AEC
.text$x:00000AEC ; =============== S U B R O U T I N E =======================================
.text$x:00000AEC
.text$x:00000AEC
.text$x:00000AEC __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00000AEC                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00000AEC
.text$x:00000AEC arg_4           = dword ptr  8
.text$x:00000AEC
.text$x:00000AEC                 mov     edx, [esp+arg_4]
.text$x:00000AF0                 lea     eax, [edx+0Ch]
.text$x:00000AF3                 mov     ecx, [edx-8]
.text$x:00000AF6                 xor     ecx, eax
.text$x:00000AF8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000AFD                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00000B02                 jmp     ___CxxFrameHandler3
.text$x:00000B02 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00000B02
.text$x:00000B02 ; ---------------------------------------------------------------------------
.text$x:00000B07                 align 4
.text$x:00000B07 _text$x         ends
.text$x:00000B07
.text$mn:00000B08 ; ===========================================================================
.text$mn:00000B08
.text$mn:00000B08 ; Segment type: Pure code
.text$mn:00000B08 ; Segment permissions: Read/Execute
.text$mn:00000B08 _text$mn        segment para public 'CODE' use32
.text$mn:00000B08                 assume cs:_text$mn
.text$mn:00000B08                 ;org 0B08h
.text$mn:00000B08 ; COMDAT (pick any)
.text$mn:00000B08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B08
.text$mn:00000B08 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B08
.text$mn:00000B08 ; Attributes: bp-based frame
.text$mn:00000B08
.text$mn:00000B08 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00000B08                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00000B08 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00000B08                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00000B08
.text$mn:00000B08 var_10          = dword ptr -10h
.text$mn:00000B08 var_C           = dword ptr -0Ch
.text$mn:00000B08 var_4           = dword ptr -4
.text$mn:00000B08
.text$mn:00000B08                 push    ebp
.text$mn:00000B09                 mov     ebp, esp
.text$mn:00000B0B                 push    0FFFFFFFFh
.text$mn:00000B0D                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00000B12                 mov     eax, large fs:0
.text$mn:00000B18                 push    eax
.text$mn:00000B19                 push    ecx
.text$mn:00000B1A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000B1F                 xor     eax, ebp
.text$mn:00000B21                 push    eax
.text$mn:00000B22                 lea     eax, [ebp+var_C]
.text$mn:00000B25                 mov     large fs:0, eax
.text$mn:00000B2B                 mov     [ebp+var_10], ecx
.text$mn:00000B2E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000B31                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00000B36                 mov     [ebp+var_4], 0
.text$mn:00000B3D                 mov     eax, [ebp+var_10]
.text$mn:00000B40                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00000B46                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000B4D                 mov     eax, [ebp+var_10]
.text$mn:00000B50                 mov     ecx, [ebp+var_C]
.text$mn:00000B53                 mov     large fs:0, ecx
.text$mn:00000B5A                 pop     ecx
.text$mn:00000B5B                 mov     esp, ebp
.text$mn:00000B5D                 pop     ebp
.text$mn:00000B5E                 retn
.text$mn:00000B5E ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00000B5E
.text$mn:00000B5E ; ---------------------------------------------------------------------------
.text$mn:00000B5F                 align 10h
.text$mn:00000B5F _text$mn        ends
.text$mn:00000B5F
.text$x:00000B60 ; ===========================================================================
.text$x:00000B60
.text$x:00000B60 ; Segment type: Pure code
.text$x:00000B60 ; Segment permissions: Read/Execute
.text$x:00000B60 _text$x         segment para public 'CODE' use32
.text$x:00000B60                 assume cs:_text$x
.text$x:00000B60                 ;org 0B60h
.text$x:00000B60 ; COMDAT (pick associative to section at B08)
.text$x:00000B60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000B60
.text$x:00000B60 ; =============== S U B R O U T I N E =======================================
.text$x:00000B60
.text$x:00000B60
.text$x:00000B60 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00000B60                                         ; DATA XREF: .xdata$x:0000225Co
.text$x:00000B60                 mov     ecx, [ebp-10h]  ; this
.text$x:00000B63                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000B63 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00000B63
.text$x:00000B68
.text$x:00000B68 ; =============== S U B R O U T I N E =======================================
.text$x:00000B68
.text$x:00000B68
.text$x:00000B68 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00000B68                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00000B68
.text$x:00000B68 arg_4           = dword ptr  8
.text$x:00000B68
.text$x:00000B68                 mov     edx, [esp+arg_4]
.text$x:00000B6C                 lea     eax, [edx+0Ch]
.text$x:00000B6F                 mov     ecx, [edx-8]
.text$x:00000B72                 xor     ecx, eax
.text$x:00000B74                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000B79                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00000B7E                 jmp     ___CxxFrameHandler3
.text$x:00000B7E __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00000B7E
.text$x:00000B7E ; ---------------------------------------------------------------------------
.text$x:00000B83                 align 4
.text$x:00000B83 _text$x         ends
.text$x:00000B83
.text$mn:00000B84 ; ===========================================================================
.text$mn:00000B84
.text$mn:00000B84 ; Segment type: Pure code
.text$mn:00000B84 ; Segment permissions: Read/Execute
.text$mn:00000B84 _text$mn        segment para public 'CODE' use32
.text$mn:00000B84                 assume cs:_text$mn
.text$mn:00000B84                 ;org 0B84h
.text$mn:00000B84 ; COMDAT (pick any)
.text$mn:00000B84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B84
.text$mn:00000B84 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B84
.text$mn:00000B84 ; Attributes: bp-based frame
.text$mn:00000B84
.text$mn:00000B84 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00000B84                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00000B84 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00000B84                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00000B84
.text$mn:00000B84 var_10          = dword ptr -10h
.text$mn:00000B84 var_C           = dword ptr -0Ch
.text$mn:00000B84 var_4           = dword ptr -4
.text$mn:00000B84
.text$mn:00000B84                 push    ebp
.text$mn:00000B85                 mov     ebp, esp
.text$mn:00000B87                 push    0FFFFFFFFh
.text$mn:00000B89                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00000B8E                 mov     eax, large fs:0
.text$mn:00000B94                 push    eax
.text$mn:00000B95                 push    ecx
.text$mn:00000B96                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000B9B                 xor     eax, ebp
.text$mn:00000B9D                 push    eax
.text$mn:00000B9E                 lea     eax, [ebp+var_C]
.text$mn:00000BA1                 mov     large fs:0, eax
.text$mn:00000BA7                 mov     [ebp+var_10], ecx
.text$mn:00000BAA                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000BAD                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00000BB2                 mov     [ebp+var_4], 0
.text$mn:00000BB9                 mov     eax, [ebp+var_10]
.text$mn:00000BBC                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00000BC2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000BC9                 mov     eax, [ebp+var_10]
.text$mn:00000BCC                 mov     ecx, [ebp+var_C]
.text$mn:00000BCF                 mov     large fs:0, ecx
.text$mn:00000BD6                 pop     ecx
.text$mn:00000BD7                 mov     esp, ebp
.text$mn:00000BD9                 pop     ebp
.text$mn:00000BDA                 retn
.text$mn:00000BDA ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00000BDA
.text$mn:00000BDA ; ---------------------------------------------------------------------------
.text$mn:00000BDB                 align 4
.text$mn:00000BDB _text$mn        ends
.text$mn:00000BDB
.text$x:00000BDC ; ===========================================================================
.text$x:00000BDC
.text$x:00000BDC ; Segment type: Pure code
.text$x:00000BDC ; Segment permissions: Read/Execute
.text$x:00000BDC _text$x         segment para public 'CODE' use32
.text$x:00000BDC                 assume cs:_text$x
.text$x:00000BDC                 ;org 0BDCh
.text$x:00000BDC ; COMDAT (pick associative to section at B84)
.text$x:00000BDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000BDC
.text$x:00000BDC ; =============== S U B R O U T I N E =======================================
.text$x:00000BDC
.text$x:00000BDC
.text$x:00000BDC __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00000BDC                                         ; DATA XREF: .xdata$x:000022E0o
.text$x:00000BDC                 mov     ecx, [ebp-10h]  ; this
.text$x:00000BDF                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000BDF __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00000BDF
.text$x:00000BE4
.text$x:00000BE4 ; =============== S U B R O U T I N E =======================================
.text$x:00000BE4
.text$x:00000BE4
.text$x:00000BE4 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00000BE4                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00000BE4
.text$x:00000BE4 arg_4           = dword ptr  8
.text$x:00000BE4
.text$x:00000BE4                 mov     edx, [esp+arg_4]
.text$x:00000BE8                 lea     eax, [edx+0Ch]
.text$x:00000BEB                 mov     ecx, [edx-8]
.text$x:00000BEE                 xor     ecx, eax
.text$x:00000BF0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000BF5                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00000BFA                 jmp     ___CxxFrameHandler3
.text$x:00000BFA __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00000BFA
.text$x:00000BFA ; ---------------------------------------------------------------------------
.text$x:00000BFF                 align 10h
.text$x:00000BFF _text$x         ends
.text$x:00000BFF
.text$mn:00000C00 ; ===========================================================================
.text$mn:00000C00
.text$mn:00000C00 ; Segment type: Pure code
.text$mn:00000C00 ; Segment permissions: Read/Execute
.text$mn:00000C00 _text$mn        segment para public 'CODE' use32
.text$mn:00000C00                 assume cs:_text$mn
.text$mn:00000C00                 ;org 0C00h
.text$mn:00000C00 ; COMDAT (pick any)
.text$mn:00000C00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C00
.text$mn:00000C00 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C00
.text$mn:00000C00 ; Attributes: bp-based frame
.text$mn:00000C00
.text$mn:00000C00 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00000C00                 public ??0error_category@std@@QAE@XZ
.text$mn:00000C00 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00000C00
.text$mn:00000C00 var_4           = dword ptr -4
.text$mn:00000C00
.text$mn:00000C00                 push    ebp
.text$mn:00000C01                 mov     ebp, esp
.text$mn:00000C03                 push    ecx
.text$mn:00000C04                 mov     [ebp+var_4], ecx
.text$mn:00000C07                 mov     eax, [ebp+var_4]
.text$mn:00000C0A                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00000C10                 mov     eax, [ebp+var_4]
.text$mn:00000C13                 mov     esp, ebp
.text$mn:00000C15                 pop     ebp
.text$mn:00000C16                 retn
.text$mn:00000C16 ??0error_category@std@@QAE@XZ endp
.text$mn:00000C16
.text$mn:00000C16 ; ---------------------------------------------------------------------------
.text$mn:00000C17                 align 4
.text$mn:00000C17 _text$mn        ends
.text$mn:00000C17
.text$mn:00000C18 ; ===========================================================================
.text$mn:00000C18
.text$mn:00000C18 ; Segment type: Pure code
.text$mn:00000C18 ; Segment permissions: Read/Execute
.text$mn:00000C18 _text$mn        segment para public 'CODE' use32
.text$mn:00000C18                 assume cs:_text$mn
.text$mn:00000C18                 ;org 0C18h
.text$mn:00000C18 ; COMDAT (pick any)
.text$mn:00000C18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C18
.text$mn:00000C18 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C18
.text$mn:00000C18 ; Attributes: bp-based frame
.text$mn:00000C18
.text$mn:00000C18 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00000C18                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00000C18 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00000C18                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00000C18                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00000C18
.text$mn:00000C18 var_4           = dword ptr -4
.text$mn:00000C18 arg_0           = dword ptr  8
.text$mn:00000C18 arg_4           = dword ptr  0Ch
.text$mn:00000C18
.text$mn:00000C18                 push    ebp
.text$mn:00000C19                 mov     ebp, esp
.text$mn:00000C1B                 push    ecx
.text$mn:00000C1C                 mov     [ebp+var_4], ecx
.text$mn:00000C1F                 mov     eax, [ebp+var_4]
.text$mn:00000C22                 mov     ecx, [ebp+arg_0]
.text$mn:00000C25                 mov     [eax], ecx
.text$mn:00000C27                 mov     edx, [ebp+var_4]
.text$mn:00000C2A                 mov     eax, [ebp+arg_4]
.text$mn:00000C2D                 mov     [edx+4], eax
.text$mn:00000C30                 mov     eax, [ebp+var_4]
.text$mn:00000C33                 mov     esp, ebp
.text$mn:00000C35                 pop     ebp
.text$mn:00000C36                 retn    8
.text$mn:00000C36 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00000C36
.text$mn:00000C36 ; ---------------------------------------------------------------------------
.text$mn:00000C39                 align 4
.text$mn:00000C39 _text$mn        ends
.text$mn:00000C39
.text$mn:00000C3C ; ===========================================================================
.text$mn:00000C3C
.text$mn:00000C3C ; Segment type: Pure code
.text$mn:00000C3C ; Segment permissions: Read/Execute
.text$mn:00000C3C _text$mn        segment para public 'CODE' use32
.text$mn:00000C3C                 assume cs:_text$mn
.text$mn:00000C3C                 ;org 0C3Ch
.text$mn:00000C3C ; COMDAT (pick any)
.text$mn:00000C3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C3C
.text$mn:00000C3C ; =============== S U B R O U T I N E =======================================
.text$mn:00000C3C
.text$mn:00000C3C ; Attributes: bp-based frame
.text$mn:00000C3C
.text$mn:00000C3C ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00000C3C                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00000C3C ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00000C3C                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00000C3C
.text$mn:00000C3C var_4           = dword ptr -4
.text$mn:00000C3C arg_0           = dword ptr  8
.text$mn:00000C3C
.text$mn:00000C3C                 push    ebp
.text$mn:00000C3D                 mov     ebp, esp
.text$mn:00000C3F                 push    ecx
.text$mn:00000C40                 mov     [ebp+var_4], ecx
.text$mn:00000C43                 mov     eax, [ebp+var_4]
.text$mn:00000C46                 mov     ecx, [ebp+arg_0]
.text$mn:00000C49                 mov     [eax], ecx
.text$mn:00000C4B                 mov     eax, [ebp+var_4]
.text$mn:00000C4E                 mov     esp, ebp
.text$mn:00000C50                 pop     ebp
.text$mn:00000C51                 retn    4
.text$mn:00000C51 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00000C51
.text$mn:00000C51 _text$mn        ends
.text$mn:00000C51
.text$mn:00000C54 ; ===========================================================================
.text$mn:00000C54
.text$mn:00000C54 ; Segment type: Pure code
.text$mn:00000C54 ; Segment permissions: Read/Execute
.text$mn:00000C54 _text$mn        segment para public 'CODE' use32
.text$mn:00000C54                 assume cs:_text$mn
.text$mn:00000C54                 ;org 0C54h
.text$mn:00000C54 ; COMDAT (pick any)
.text$mn:00000C54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C54
.text$mn:00000C54 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C54
.text$mn:00000C54 ; Attributes: bp-based frame
.text$mn:00000C54
.text$mn:00000C54 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00000C54                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00000C54 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00000C54                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00000C54                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00000C54
.text$mn:00000C54 var_10          = dword ptr -10h
.text$mn:00000C54 var_C           = dword ptr -0Ch
.text$mn:00000C54 var_4           = dword ptr -4
.text$mn:00000C54
.text$mn:00000C54                 push    ebp
.text$mn:00000C55                 mov     ebp, esp
.text$mn:00000C57                 push    0FFFFFFFFh
.text$mn:00000C59                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00000C5E                 mov     eax, large fs:0
.text$mn:00000C64                 push    eax
.text$mn:00000C65                 push    ecx
.text$mn:00000C66                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000C6B                 xor     eax, ebp
.text$mn:00000C6D                 push    eax
.text$mn:00000C6E                 lea     eax, [ebp+var_C]
.text$mn:00000C71                 mov     large fs:0, eax
.text$mn:00000C77                 mov     [ebp+var_10], ecx
.text$mn:00000C7A                 mov     [ebp+var_4], 0
.text$mn:00000C81                 mov     ecx, [ebp+var_10]
.text$mn:00000C84                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00000C89                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000C90                 mov     ecx, [ebp+var_10]
.text$mn:00000C93                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00000C98                 mov     ecx, [ebp+var_C]
.text$mn:00000C9B                 mov     large fs:0, ecx
.text$mn:00000CA2                 pop     ecx
.text$mn:00000CA3                 mov     esp, ebp
.text$mn:00000CA5                 pop     ebp
.text$mn:00000CA6                 retn
.text$mn:00000CA6 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00000CA6
.text$mn:00000CA6 ; ---------------------------------------------------------------------------
.text$mn:00000CA7                 align 4
.text$mn:00000CA7 _text$mn        ends
.text$mn:00000CA7
.text$x:00000CA8 ; ===========================================================================
.text$x:00000CA8
.text$x:00000CA8 ; Segment type: Pure code
.text$x:00000CA8 ; Segment permissions: Read/Execute
.text$x:00000CA8 _text$x         segment para public 'CODE' use32
.text$x:00000CA8                 assume cs:_text$x
.text$x:00000CA8                 ;org 0CA8h
.text$x:00000CA8 ; COMDAT (pick associative to section at C54)
.text$x:00000CA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000CA8
.text$x:00000CA8 ; =============== S U B R O U T I N E =======================================
.text$x:00000CA8
.text$x:00000CA8
.text$x:00000CA8 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00000CA8                                         ; DATA XREF: .xdata$x:000020C8o
.text$x:00000CA8                 mov     ecx, [ebp-10h]
.text$x:00000CAB                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00000CAB __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00000CAB
.text$x:00000CB0
.text$x:00000CB0 ; =============== S U B R O U T I N E =======================================
.text$x:00000CB0
.text$x:00000CB0
.text$x:00000CB0 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00000CB0                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00000CB0
.text$x:00000CB0 arg_4           = dword ptr  8
.text$x:00000CB0
.text$x:00000CB0                 mov     edx, [esp+arg_4]
.text$x:00000CB4                 lea     eax, [edx+0Ch]
.text$x:00000CB7                 mov     ecx, [edx-8]
.text$x:00000CBA                 xor     ecx, eax
.text$x:00000CBC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000CC1                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00000CC6                 jmp     ___CxxFrameHandler3
.text$x:00000CC6 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00000CC6
.text$x:00000CC6 ; ---------------------------------------------------------------------------
.text$x:00000CCB                 align 4
.text$x:00000CCB _text$x         ends
.text$x:00000CCB
.text$mn:00000CCC ; ===========================================================================
.text$mn:00000CCC
.text$mn:00000CCC ; Segment type: Pure code
.text$mn:00000CCC ; Segment permissions: Read/Execute
.text$mn:00000CCC _text$mn        segment para public 'CODE' use32
.text$mn:00000CCC                 assume cs:_text$mn
.text$mn:00000CCC                 ;org 0CCCh
.text$mn:00000CCC ; COMDAT (pick any)
.text$mn:00000CCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000CCC
.text$mn:00000CCC ; =============== S U B R O U T I N E =======================================
.text$mn:00000CCC
.text$mn:00000CCC ; Attributes: bp-based frame
.text$mn:00000CCC
.text$mn:00000CCC ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00000CCC                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000CCC ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00000CCC                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00000CCC                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00000CCC
.text$mn:00000CCC var_10          = dword ptr -10h
.text$mn:00000CCC var_C           = dword ptr -0Ch
.text$mn:00000CCC var_4           = dword ptr -4
.text$mn:00000CCC
.text$mn:00000CCC                 push    ebp
.text$mn:00000CCD                 mov     ebp, esp
.text$mn:00000CCF                 push    0FFFFFFFFh
.text$mn:00000CD1                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000CD6                 mov     eax, large fs:0
.text$mn:00000CDC                 push    eax
.text$mn:00000CDD                 push    ecx
.text$mn:00000CDE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000CE3                 xor     eax, ebp
.text$mn:00000CE5                 push    eax
.text$mn:00000CE6                 lea     eax, [ebp+var_C]
.text$mn:00000CE9                 mov     large fs:0, eax
.text$mn:00000CEF                 mov     [ebp+var_10], ecx
.text$mn:00000CF2                 mov     [ebp+var_4], 0
.text$mn:00000CF9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000D00                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000D03                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00000D08                 mov     ecx, [ebp+var_C]
.text$mn:00000D0B                 mov     large fs:0, ecx
.text$mn:00000D12                 pop     ecx
.text$mn:00000D13                 mov     esp, ebp
.text$mn:00000D15                 pop     ebp
.text$mn:00000D16                 retn
.text$mn:00000D16 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000D16
.text$mn:00000D16 ; ---------------------------------------------------------------------------
.text$mn:00000D17                 align 4
.text$mn:00000D17 _text$mn        ends
.text$mn:00000D17
.text$x:00000D18 ; ===========================================================================
.text$x:00000D18
.text$x:00000D18 ; Segment type: Pure code
.text$x:00000D18 ; Segment permissions: Read/Execute
.text$x:00000D18 _text$x         segment para public 'CODE' use32
.text$x:00000D18                 assume cs:_text$x
.text$x:00000D18                 ;org 0D18h
.text$x:00000D18 ; COMDAT (pick associative to section at CCC)
.text$x:00000D18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000D18
.text$x:00000D18 ; =============== S U B R O U T I N E =======================================
.text$x:00000D18
.text$x:00000D18
.text$x:00000D18 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00000D18                                         ; DATA XREF: .xdata$x:00002070o
.text$x:00000D18                 mov     ecx, [ebp-10h]  ; this
.text$x:00000D1B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00000D1B __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00000D1B
.text$x:00000D20
.text$x:00000D20 ; =============== S U B R O U T I N E =======================================
.text$x:00000D20
.text$x:00000D20
.text$x:00000D20 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000D20                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000D20
.text$x:00000D20 arg_4           = dword ptr  8
.text$x:00000D20
.text$x:00000D20                 mov     edx, [esp+arg_4]
.text$x:00000D24                 lea     eax, [edx+0Ch]
.text$x:00000D27                 mov     ecx, [edx-8]
.text$x:00000D2A                 xor     ecx, eax
.text$x:00000D2C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000D31                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00000D36                 jmp     ___CxxFrameHandler3
.text$x:00000D36 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00000D36
.text$x:00000D36 ; ---------------------------------------------------------------------------
.text$x:00000D3B                 align 4
.text$x:00000D3B _text$x         ends
.text$x:00000D3B
.text$mn:00000D3C ; ===========================================================================
.text$mn:00000D3C
.text$mn:00000D3C ; Segment type: Pure code
.text$mn:00000D3C ; Segment permissions: Read/Execute
.text$mn:00000D3C _text$mn        segment para public 'CODE' use32
.text$mn:00000D3C                 assume cs:_text$mn
.text$mn:00000D3C                 ;org 0D3Ch
.text$mn:00000D3C ; COMDAT (pick any)
.text$mn:00000D3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D3C
.text$mn:00000D3C ; =============== S U B R O U T I N E =======================================
.text$mn:00000D3C
.text$mn:00000D3C ; Attributes: bp-based frame
.text$mn:00000D3C
.text$mn:00000D3C ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00000D3C                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000D3C ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00000D3C                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00000D3C                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00000D3C
.text$mn:00000D3C var_10          = dword ptr -10h
.text$mn:00000D3C var_C           = dword ptr -0Ch
.text$mn:00000D3C var_4           = dword ptr -4
.text$mn:00000D3C
.text$mn:00000D3C                 push    ebp
.text$mn:00000D3D                 mov     ebp, esp
.text$mn:00000D3F                 push    0FFFFFFFFh
.text$mn:00000D41                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000D46                 mov     eax, large fs:0
.text$mn:00000D4C                 push    eax
.text$mn:00000D4D                 push    ecx
.text$mn:00000D4E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000D53                 xor     eax, ebp
.text$mn:00000D55                 push    eax
.text$mn:00000D56                 lea     eax, [ebp+var_C]
.text$mn:00000D59                 mov     large fs:0, eax
.text$mn:00000D5F                 mov     [ebp+var_10], ecx
.text$mn:00000D62                 mov     [ebp+var_4], 0
.text$mn:00000D69                 push    0               ; Size
.text$mn:00000D6B                 push    1               ; char
.text$mn:00000D6D                 mov     ecx, [ebp+var_10]
.text$mn:00000D70                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000D75                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000D7C                 mov     ecx, [ebp+var_10]
.text$mn:00000D7F                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00000D84                 mov     ecx, [ebp+var_C]
.text$mn:00000D87                 mov     large fs:0, ecx
.text$mn:00000D8E                 pop     ecx
.text$mn:00000D8F                 mov     esp, ebp
.text$mn:00000D91                 pop     ebp
.text$mn:00000D92                 retn
.text$mn:00000D92 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00000D92
.text$mn:00000D92 ; ---------------------------------------------------------------------------
.text$mn:00000D93                 align 4
.text$mn:00000D93 _text$mn        ends
.text$mn:00000D93
.text$x:00000D94 ; ===========================================================================
.text$x:00000D94
.text$x:00000D94 ; Segment type: Pure code
.text$x:00000D94 ; Segment permissions: Read/Execute
.text$x:00000D94 _text$x         segment para public 'CODE' use32
.text$x:00000D94                 assume cs:_text$x
.text$x:00000D94                 ;org 0D94h
.text$x:00000D94 ; COMDAT (pick associative to section at D3C)
.text$x:00000D94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000D94
.text$x:00000D94 ; =============== S U B R O U T I N E =======================================
.text$x:00000D94
.text$x:00000D94
.text$x:00000D94 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00000D94                                         ; DATA XREF: .xdata$x:00002120o
.text$x:00000D94                 mov     ecx, [ebp-10h]
.text$x:00000D97                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000D97 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00000D97
.text$x:00000D9C
.text$x:00000D9C ; =============== S U B R O U T I N E =======================================
.text$x:00000D9C
.text$x:00000D9C
.text$x:00000D9C __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00000D9C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00000D9C
.text$x:00000D9C arg_4           = dword ptr  8
.text$x:00000D9C
.text$x:00000D9C                 mov     edx, [esp+arg_4]
.text$x:00000DA0                 lea     eax, [edx+0Ch]
.text$x:00000DA3                 mov     ecx, [edx-8]
.text$x:00000DA6                 xor     ecx, eax
.text$x:00000DA8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000DAD                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00000DB2                 jmp     ___CxxFrameHandler3
.text$x:00000DB2 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00000DB2
.text$x:00000DB2 ; ---------------------------------------------------------------------------
.text$x:00000DB7                 align 4
.text$x:00000DB7 _text$x         ends
.text$x:00000DB7
.text$mn:00000DB8 ; ===========================================================================
.text$mn:00000DB8
.text$mn:00000DB8 ; Segment type: Pure code
.text$mn:00000DB8 ; Segment permissions: Read/Execute
.text$mn:00000DB8 _text$mn        segment para public 'CODE' use32
.text$mn:00000DB8                 assume cs:_text$mn
.text$mn:00000DB8                 ;org 0DB8h
.text$mn:00000DB8 ; COMDAT (pick any)
.text$mn:00000DB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000DB8
.text$mn:00000DB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000DB8
.text$mn:00000DB8 ; Attributes: bp-based frame
.text$mn:00000DB8
.text$mn:00000DB8 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000DB8                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00000DB8 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00000DB8                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00000DB8                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:00000DB8
.text$mn:00000DB8 var_4           = dword ptr -4
.text$mn:00000DB8
.text$mn:00000DB8                 push    ebp
.text$mn:00000DB9                 mov     ebp, esp
.text$mn:00000DBB                 push    ecx
.text$mn:00000DBC                 mov     [ebp+var_4], ecx
.text$mn:00000DBF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000DC2                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00000DC7                 mov     esp, ebp
.text$mn:00000DC9                 pop     ebp
.text$mn:00000DCA                 retn
.text$mn:00000DCA ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00000DCA
.text$mn:00000DCA ; ---------------------------------------------------------------------------
.text$mn:00000DCB                 align 4
.text$mn:00000DCB _text$mn        ends
.text$mn:00000DCB
.text$mn:00000DCC ; ===========================================================================
.text$mn:00000DCC
.text$mn:00000DCC ; Segment type: Pure code
.text$mn:00000DCC ; Segment permissions: Read/Execute
.text$mn:00000DCC _text$mn        segment para public 'CODE' use32
.text$mn:00000DCC                 assume cs:_text$mn
.text$mn:00000DCC                 ;org 0DCCh
.text$mn:00000DCC ; COMDAT (pick any)
.text$mn:00000DCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000DCC
.text$mn:00000DCC ; =============== S U B R O U T I N E =======================================
.text$mn:00000DCC
.text$mn:00000DCC ; Attributes: bp-based frame
.text$mn:00000DCC
.text$mn:00000DCC ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00000DCC                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00000DCC ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00000DCC                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00000DCC                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00000DCC
.text$mn:00000DCC var_10          = dword ptr -10h
.text$mn:00000DCC var_C           = dword ptr -0Ch
.text$mn:00000DCC var_4           = dword ptr -4
.text$mn:00000DCC
.text$mn:00000DCC                 push    ebp
.text$mn:00000DCD                 mov     ebp, esp
.text$mn:00000DCF                 push    0FFFFFFFFh
.text$mn:00000DD1                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00000DD6                 mov     eax, large fs:0
.text$mn:00000DDC                 push    eax
.text$mn:00000DDD                 push    ecx
.text$mn:00000DDE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000DE3                 xor     eax, ebp
.text$mn:00000DE5                 push    eax
.text$mn:00000DE6                 lea     eax, [ebp+var_C]
.text$mn:00000DE9                 mov     large fs:0, eax
.text$mn:00000DEF                 mov     [ebp+var_10], ecx
.text$mn:00000DF2                 mov     [ebp+var_4], 0
.text$mn:00000DF9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000E00                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000E03                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00000E08                 mov     ecx, [ebp+var_C]
.text$mn:00000E0B                 mov     large fs:0, ecx
.text$mn:00000E12                 pop     ecx
.text$mn:00000E13                 mov     esp, ebp
.text$mn:00000E15                 pop     ebp
.text$mn:00000E16                 retn
.text$mn:00000E16 ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00000E16
.text$mn:00000E16 ; ---------------------------------------------------------------------------
.text$mn:00000E17                 align 4
.text$mn:00000E17 _text$mn        ends
.text$mn:00000E17
.text$x:00000E18 ; ===========================================================================
.text$x:00000E18
.text$x:00000E18 ; Segment type: Pure code
.text$x:00000E18 ; Segment permissions: Read/Execute
.text$x:00000E18 _text$x         segment para public 'CODE' use32
.text$x:00000E18                 assume cs:_text$x
.text$x:00000E18                 ;org 0E18h
.text$x:00000E18 ; COMDAT (pick associative to section at DCC)
.text$x:00000E18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000E18
.text$x:00000E18 ; =============== S U B R O U T I N E =======================================
.text$x:00000E18
.text$x:00000E18
.text$x:00000E18 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00000E18                                         ; DATA XREF: .xdata$x:00002230o
.text$x:00000E18                 mov     ecx, [ebp-10h]  ; this
.text$x:00000E1B                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00000E1B __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00000E1B
.text$x:00000E20
.text$x:00000E20 ; =============== S U B R O U T I N E =======================================
.text$x:00000E20
.text$x:00000E20
.text$x:00000E20 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00000E20                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00000E20
.text$x:00000E20 arg_4           = dword ptr  8
.text$x:00000E20
.text$x:00000E20                 mov     edx, [esp+arg_4]
.text$x:00000E24                 lea     eax, [edx+0Ch]
.text$x:00000E27                 mov     ecx, [edx-8]
.text$x:00000E2A                 xor     ecx, eax
.text$x:00000E2C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000E31                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00000E36                 jmp     ___CxxFrameHandler3
.text$x:00000E36 __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00000E36
.text$x:00000E36 ; ---------------------------------------------------------------------------
.text$x:00000E3B                 align 4
.text$x:00000E3B _text$x         ends
.text$x:00000E3B
.text$mn:00000E3C ; ===========================================================================
.text$mn:00000E3C
.text$mn:00000E3C ; Segment type: Pure code
.text$mn:00000E3C ; Segment permissions: Read/Execute
.text$mn:00000E3C _text$mn        segment para public 'CODE' use32
.text$mn:00000E3C                 assume cs:_text$mn
.text$mn:00000E3C                 ;org 0E3Ch
.text$mn:00000E3C ; COMDAT (pick any)
.text$mn:00000E3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E3C
.text$mn:00000E3C ; =============== S U B R O U T I N E =======================================
.text$mn:00000E3C
.text$mn:00000E3C ; Attributes: bp-based frame
.text$mn:00000E3C
.text$mn:00000E3C ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00000E3C                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00000E3C ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00000E3C                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00000E3C                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00000E3C
.text$mn:00000E3C var_10          = dword ptr -10h
.text$mn:00000E3C var_C           = dword ptr -0Ch
.text$mn:00000E3C var_4           = dword ptr -4
.text$mn:00000E3C
.text$mn:00000E3C                 push    ebp
.text$mn:00000E3D                 mov     ebp, esp
.text$mn:00000E3F                 push    0FFFFFFFFh
.text$mn:00000E41                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00000E46                 mov     eax, large fs:0
.text$mn:00000E4C                 push    eax
.text$mn:00000E4D                 push    ecx
.text$mn:00000E4E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000E53                 xor     eax, ebp
.text$mn:00000E55                 push    eax
.text$mn:00000E56                 lea     eax, [ebp+var_C]
.text$mn:00000E59                 mov     large fs:0, eax
.text$mn:00000E5F                 mov     [ebp+var_10], ecx
.text$mn:00000E62                 mov     [ebp+var_4], 0
.text$mn:00000E69                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000E70                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000E73                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000E78                 mov     ecx, [ebp+var_C]
.text$mn:00000E7B                 mov     large fs:0, ecx
.text$mn:00000E82                 pop     ecx
.text$mn:00000E83                 mov     esp, ebp
.text$mn:00000E85                 pop     ebp
.text$mn:00000E86                 retn
.text$mn:00000E86 ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00000E86
.text$mn:00000E86 ; ---------------------------------------------------------------------------
.text$mn:00000E87                 align 4
.text$mn:00000E87 _text$mn        ends
.text$mn:00000E87
.text$x:00000E88 ; ===========================================================================
.text$x:00000E88
.text$x:00000E88 ; Segment type: Pure code
.text$x:00000E88 ; Segment permissions: Read/Execute
.text$x:00000E88 _text$x         segment para public 'CODE' use32
.text$x:00000E88                 assume cs:_text$x
.text$x:00000E88                 ;org 0E88h
.text$x:00000E88 ; COMDAT (pick associative to section at E3C)
.text$x:00000E88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000E88
.text$x:00000E88 ; =============== S U B R O U T I N E =======================================
.text$x:00000E88
.text$x:00000E88
.text$x:00000E88 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00000E88                                         ; DATA XREF: .xdata$x:000022B4o
.text$x:00000E88                 mov     ecx, [ebp-10h]  ; this
.text$x:00000E8B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000E8B __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00000E8B
.text$x:00000E90
.text$x:00000E90 ; =============== S U B R O U T I N E =======================================
.text$x:00000E90
.text$x:00000E90
.text$x:00000E90 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00000E90                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00000E90
.text$x:00000E90 arg_4           = dword ptr  8
.text$x:00000E90
.text$x:00000E90                 mov     edx, [esp+arg_4]
.text$x:00000E94                 lea     eax, [edx+0Ch]
.text$x:00000E97                 mov     ecx, [edx-8]
.text$x:00000E9A                 xor     ecx, eax
.text$x:00000E9C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000EA1                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00000EA6                 jmp     ___CxxFrameHandler3
.text$x:00000EA6 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00000EA6
.text$x:00000EA6 ; ---------------------------------------------------------------------------
.text$x:00000EAB                 align 4
.text$x:00000EAB _text$x         ends
.text$x:00000EAB
.text$mn:00000EAC ; ===========================================================================
.text$mn:00000EAC
.text$mn:00000EAC ; Segment type: Pure code
.text$mn:00000EAC ; Segment permissions: Read/Execute
.text$mn:00000EAC _text$mn        segment para public 'CODE' use32
.text$mn:00000EAC                 assume cs:_text$mn
.text$mn:00000EAC                 ;org 0EACh
.text$mn:00000EAC ; COMDAT (pick any)
.text$mn:00000EAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000EAC
.text$mn:00000EAC ; =============== S U B R O U T I N E =======================================
.text$mn:00000EAC
.text$mn:00000EAC ; Attributes: bp-based frame
.text$mn:00000EAC
.text$mn:00000EAC ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00000EAC                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00000EAC ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00000EAC                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00000EAC                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00000EAC
.text$mn:00000EAC var_10          = dword ptr -10h
.text$mn:00000EAC var_C           = dword ptr -0Ch
.text$mn:00000EAC var_4           = dword ptr -4
.text$mn:00000EAC
.text$mn:00000EAC                 push    ebp
.text$mn:00000EAD                 mov     ebp, esp
.text$mn:00000EAF                 push    0FFFFFFFFh
.text$mn:00000EB1                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00000EB6                 mov     eax, large fs:0
.text$mn:00000EBC                 push    eax
.text$mn:00000EBD                 push    ecx
.text$mn:00000EBE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000EC3                 xor     eax, ebp
.text$mn:00000EC5                 push    eax
.text$mn:00000EC6                 lea     eax, [ebp+var_C]
.text$mn:00000EC9                 mov     large fs:0, eax
.text$mn:00000ECF                 mov     [ebp+var_10], ecx
.text$mn:00000ED2                 mov     [ebp+var_4], 0
.text$mn:00000ED9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000EE0                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000EE3                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000EE8                 mov     ecx, [ebp+var_C]
.text$mn:00000EEB                 mov     large fs:0, ecx
.text$mn:00000EF2                 pop     ecx
.text$mn:00000EF3                 mov     esp, ebp
.text$mn:00000EF5                 pop     ebp
.text$mn:00000EF6                 retn
.text$mn:00000EF6 ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00000EF6
.text$mn:00000EF6 ; ---------------------------------------------------------------------------
.text$mn:00000EF7                 align 4
.text$mn:00000EF7 _text$mn        ends
.text$mn:00000EF7
.text$x:00000EF8 ; ===========================================================================
.text$x:00000EF8
.text$x:00000EF8 ; Segment type: Pure code
.text$x:00000EF8 ; Segment permissions: Read/Execute
.text$x:00000EF8 _text$x         segment para public 'CODE' use32
.text$x:00000EF8                 assume cs:_text$x
.text$x:00000EF8                 ;org 0EF8h
.text$x:00000EF8 ; COMDAT (pick associative to section at EAC)
.text$x:00000EF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000EF8
.text$x:00000EF8 ; =============== S U B R O U T I N E =======================================
.text$x:00000EF8
.text$x:00000EF8
.text$x:00000EF8 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00000EF8                                         ; DATA XREF: .xdata$x:00002338o
.text$x:00000EF8                 mov     ecx, [ebp-10h]  ; this
.text$x:00000EFB                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000EFB __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00000EFB
.text$x:00000F00
.text$x:00000F00 ; =============== S U B R O U T I N E =======================================
.text$x:00000F00
.text$x:00000F00
.text$x:00000F00 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00000F00                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00000F00
.text$x:00000F00 arg_4           = dword ptr  8
.text$x:00000F00
.text$x:00000F00                 mov     edx, [esp+arg_4]
.text$x:00000F04                 lea     eax, [edx+0Ch]
.text$x:00000F07                 mov     ecx, [edx-8]
.text$x:00000F0A                 xor     ecx, eax
.text$x:00000F0C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000F11                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00000F16                 jmp     ___CxxFrameHandler3
.text$x:00000F16 __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00000F16
.text$x:00000F16 ; ---------------------------------------------------------------------------
.text$x:00000F1B                 align 4
.text$x:00000F1B _text$x         ends
.text$x:00000F1B
.text$mn:00000F1C ; ===========================================================================
.text$mn:00000F1C
.text$mn:00000F1C ; Segment type: Pure code
.text$mn:00000F1C ; Segment permissions: Read/Execute
.text$mn:00000F1C _text$mn        segment para public 'CODE' use32
.text$mn:00000F1C                 assume cs:_text$mn
.text$mn:00000F1C                 ;org 0F1Ch
.text$mn:00000F1C ; COMDAT (pick any)
.text$mn:00000F1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F1C
.text$mn:00000F1C ; =============== S U B R O U T I N E =======================================
.text$mn:00000F1C
.text$mn:00000F1C ; Attributes: bp-based frame
.text$mn:00000F1C
.text$mn:00000F1C ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00000F1C                 public ??1error_category@std@@UAE@XZ
.text$mn:00000F1C ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00000F1C                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00000F1C
.text$mn:00000F1C var_4           = dword ptr -4
.text$mn:00000F1C
.text$mn:00000F1C                 push    ebp
.text$mn:00000F1D                 mov     ebp, esp
.text$mn:00000F1F                 push    ecx
.text$mn:00000F20                 mov     [ebp+var_4], ecx
.text$mn:00000F23                 mov     eax, [ebp+var_4]
.text$mn:00000F26                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00000F2C                 mov     esp, ebp
.text$mn:00000F2E                 pop     ebp
.text$mn:00000F2F                 retn
.text$mn:00000F2F ??1error_category@std@@UAE@XZ endp
.text$mn:00000F2F
.text$mn:00000F2F _text$mn        ends
.text$mn:00000F2F
.text$mn:00000F30 ; ===========================================================================
.text$mn:00000F30
.text$mn:00000F30 ; Segment type: Pure code
.text$mn:00000F30 ; Segment permissions: Read/Execute
.text$mn:00000F30 _text$mn        segment para public 'CODE' use32
.text$mn:00000F30                 assume cs:_text$mn
.text$mn:00000F30                 ;org 0F30h
.text$mn:00000F30 ; COMDAT (pick any)
.text$mn:00000F30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F30
.text$mn:00000F30 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F30
.text$mn:00000F30 ; Attributes: bp-based frame
.text$mn:00000F30
.text$mn:00000F30 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00000F30                 public ??2@YAPAXIPAX@Z
.text$mn:00000F30 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00000F30                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:00000F30
.text$mn:00000F30 arg_4           = dword ptr  0Ch
.text$mn:00000F30
.text$mn:00000F30                 push    ebp
.text$mn:00000F31                 mov     ebp, esp
.text$mn:00000F33                 mov     eax, [ebp+arg_4]
.text$mn:00000F36                 pop     ebp
.text$mn:00000F37                 retn
.text$mn:00000F37 ??2@YAPAXIPAX@Z endp
.text$mn:00000F37
.text$mn:00000F37 _text$mn        ends
.text$mn:00000F37
.text$mn:00000F38 ; ===========================================================================
.text$mn:00000F38
.text$mn:00000F38 ; Segment type: Pure code
.text$mn:00000F38 ; Segment permissions: Read/Execute
.text$mn:00000F38 _text$mn        segment para public 'CODE' use32
.text$mn:00000F38                 assume cs:_text$mn
.text$mn:00000F38                 ;org 0F38h
.text$mn:00000F38 ; COMDAT (pick any)
.text$mn:00000F38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F38
.text$mn:00000F38 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F38
.text$mn:00000F38 ; Attributes: bp-based frame
.text$mn:00000F38
.text$mn:00000F38 ; void __cdecl operator delete(void *)
.text$mn:00000F38                 public ??3@YAXPAX0@Z
.text$mn:00000F38 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00000F38                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:00000F38                 push    ebp
.text$mn:00000F39                 mov     ebp, esp
.text$mn:00000F3B                 pop     ebp
.text$mn:00000F3C                 retn
.text$mn:00000F3C ??3@YAXPAX0@Z   endp
.text$mn:00000F3C
.text$mn:00000F3C ; ---------------------------------------------------------------------------
.text$mn:00000F3D                 align 10h
.text$mn:00000F3D _text$mn        ends
.text$mn:00000F3D
.text$mn:00000F40 ; ===========================================================================
.text$mn:00000F40
.text$mn:00000F40 ; Segment type: Pure code
.text$mn:00000F40 ; Segment permissions: Read/Execute
.text$mn:00000F40 _text$mn        segment para public 'CODE' use32
.text$mn:00000F40                 assume cs:_text$mn
.text$mn:00000F40                 ;org 0F40h
.text$mn:00000F40 ; COMDAT (pick any)
.text$mn:00000F40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F40
.text$mn:00000F40 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F40
.text$mn:00000F40 ; Attributes: bp-based frame
.text$mn:00000F40
.text$mn:00000F40 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00000F40                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00000F40 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00000F40                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00000F40                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00000F40
.text$mn:00000F40 var_8           = dword ptr -8
.text$mn:00000F40 var_4           = dword ptr -4
.text$mn:00000F40 arg_0           = dword ptr  8
.text$mn:00000F40
.text$mn:00000F40                 push    ebp
.text$mn:00000F41                 mov     ebp, esp
.text$mn:00000F43                 sub     esp, 8
.text$mn:00000F46                 mov     [ebp+var_8], ecx
.text$mn:00000F49                 mov     eax, [ebp+var_8]
.text$mn:00000F4C                 cmp     eax, [ebp+arg_0]
.text$mn:00000F4F                 jnz     short loc_F5A
.text$mn:00000F51                 mov     [ebp+var_4], 1
.text$mn:00000F58                 jmp     short loc_F61
.text$mn:00000F5A ; ---------------------------------------------------------------------------
.text$mn:00000F5A
.text$mn:00000F5A loc_F5A:                                ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00000F5A                 mov     [ebp+var_4], 0
.text$mn:00000F61
.text$mn:00000F61 loc_F61:                                ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00000F61                 mov     al, byte ptr [ebp+var_4]
.text$mn:00000F64                 mov     esp, ebp
.text$mn:00000F66                 pop     ebp
.text$mn:00000F67                 retn    4
.text$mn:00000F67 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00000F67
.text$mn:00000F67 ; ---------------------------------------------------------------------------
.text$mn:00000F6A                 align 4
.text$mn:00000F6A _text$mn        ends
.text$mn:00000F6A
.text$mn:00000F6C ; ===========================================================================
.text$mn:00000F6C
.text$mn:00000F6C ; Segment type: Pure code
.text$mn:00000F6C ; Segment permissions: Read/Execute
.text$mn:00000F6C _text$mn        segment para public 'CODE' use32
.text$mn:00000F6C                 assume cs:_text$mn
.text$mn:00000F6C                 ;org 0F6Ch
.text$mn:00000F6C ; COMDAT (pick any)
.text$mn:00000F6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F6C
.text$mn:00000F6C ; =============== S U B R O U T I N E =======================================
.text$mn:00000F6C
.text$mn:00000F6C ; Attributes: bp-based frame
.text$mn:00000F6C
.text$mn:00000F6C ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00000F6C                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00000F6C ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00000F6C                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00000F6C
.text$mn:00000F6C var_8           = dword ptr -8
.text$mn:00000F6C var_4           = dword ptr -4
.text$mn:00000F6C arg_0           = dword ptr  8
.text$mn:00000F6C
.text$mn:00000F6C                 push    ebp
.text$mn:00000F6D                 mov     ebp, esp
.text$mn:00000F6F                 sub     esp, 8
.text$mn:00000F72                 push    esi
.text$mn:00000F73                 mov     [ebp+var_4], ecx
.text$mn:00000F76                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000F79                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00000F7E                 push    eax
.text$mn:00000F7F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000F82                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00000F87                 mov     ecx, eax
.text$mn:00000F89                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00000F8E                 movzx   eax, al
.text$mn:00000F91                 test    eax, eax
.text$mn:00000F93                 jz      short loc_FB4
.text$mn:00000F95                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000F98                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00000F9D                 mov     esi, eax
.text$mn:00000F9F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000FA2                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00000FA7                 cmp     esi, eax
.text$mn:00000FA9                 jnz     short loc_FB4
.text$mn:00000FAB                 mov     [ebp+var_8], 1
.text$mn:00000FB2                 jmp     short loc_FBB
.text$mn:00000FB4 ; ---------------------------------------------------------------------------
.text$mn:00000FB4
.text$mn:00000FB4 loc_FB4:                                ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00000FB4                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00000FB4                 mov     [ebp+var_8], 0
.text$mn:00000FBB
.text$mn:00000FBB loc_FBB:                                ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00000FBB                 mov     al, byte ptr [ebp+var_8]
.text$mn:00000FBE                 pop     esi
.text$mn:00000FBF                 mov     esp, ebp
.text$mn:00000FC1                 pop     ebp
.text$mn:00000FC2                 retn    4
.text$mn:00000FC2 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00000FC2
.text$mn:00000FC2 ; ---------------------------------------------------------------------------
.text$mn:00000FC5                 align 4
.text$mn:00000FC5 _text$mn        ends
.text$mn:00000FC5
.text$mn:00000FC8 ; ===========================================================================
.text$mn:00000FC8
.text$mn:00000FC8 ; Segment type: Pure code
.text$mn:00000FC8 ; Segment permissions: Read/Execute
.text$mn:00000FC8 _text$mn        segment para public 'CODE' use32
.text$mn:00000FC8                 assume cs:_text$mn
.text$mn:00000FC8                 ;org 0FC8h
.text$mn:00000FC8 ; COMDAT (pick any)
.text$mn:00000FC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000FC8
.text$mn:00000FC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FC8
.text$mn:00000FC8 ; Attributes: bp-based frame
.text$mn:00000FC8
.text$mn:00000FC8 ; public: struct TaskLstFnStatus & __thiscall std::vector<struct TaskLstFnStatus, class std::allocator<struct TaskLstFnStatus>>::operator[](unsigned int)
.text$mn:00000FC8                 public ??A?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAEAAUTaskLstFnStatus@@I@Z
.text$mn:00000FC8 ??A?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAEAAUTaskLstFnStatus@@I@Z proc near
.text$mn:00000FC8                                         ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+247p
.text$mn:00000FC8                                         ; TaskListDlg::run_dlgProc(uint,uint,long)+2C3p ...
.text$mn:00000FC8
.text$mn:00000FC8 var_4           = dword ptr -4
.text$mn:00000FC8 arg_0           = dword ptr  8
.text$mn:00000FC8
.text$mn:00000FC8                 push    ebp
.text$mn:00000FC9                 mov     ebp, esp
.text$mn:00000FCB                 push    ecx
.text$mn:00000FCC                 mov     [ebp+var_4], ecx
.text$mn:00000FCF                 mov     ecx, [ebp+var_4]
.text$mn:00000FD2                 call    ?size@?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QBEIXZ ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::size(void)
.text$mn:00000FD7                 cmp     eax, [ebp+arg_0]
.text$mn:00000FDA                 ja      short loc_1044
.text$mn:00000FDC                 push    4B1h            ; unsigned int
.text$mn:00000FE1                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00000FE6                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:00000FEB                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00000FF0                 add     esp, 0Ch
.text$mn:00000FF3                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00000FF8                 test    eax, eax
.text$mn:00000FFA                 jz      short loc_1000
.text$mn:00000FFC                 xor     ecx, ecx
.text$mn:00000FFE                 jnz     short loc_1026
.text$mn:00001000
.text$mn:00001000 loc_1000:                               ; CODE XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+32j
.text$mn:00001000                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00001005                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000100A                 push    0
.text$mn:0000100C                 push    4B2h
.text$mn:00001011                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001016                 push    2
.text$mn:00001018                 call    __CrtDbgReportW
.text$mn:0000101D                 add     esp, 18h
.text$mn:00001020                 cmp     eax, 1
.text$mn:00001023                 jnz     short loc_1026
.text$mn:00001025                 int     3               ; Trap to Debugger
.text$mn:00001026
.text$mn:00001026 loc_1026:                               ; CODE XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+36j
.text$mn:00001026                                         ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+5Bj
.text$mn:00001026                 push    0
.text$mn:00001028                 push    4B2h
.text$mn:0000102D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001032                 push    offset ??_C@_1LO@OIFNPDJM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAT?$AAa?$AAs?$AAk?$AAL?$AAs?$AAt?$AAF?$AAn?$AAS?$AAt?$AAa?$AAt@ ; "std::vector<struct TaskLstFnStatus,clas"...
.text$mn:00001037                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:0000103C                 call    __invalid_parameter
.text$mn:00001041                 add     esp, 14h
.text$mn:00001044
.text$mn:00001044 loc_1044:                               ; CODE XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+12j
.text$mn:00001044                 imul    eax, [ebp+arg_0], 2Ch
.text$mn:00001048                 mov     ecx, [ebp+var_4]
.text$mn:0000104B                 add     eax, [ecx+4]
.text$mn:0000104E                 mov     esp, ebp
.text$mn:00001050                 pop     ebp
.text$mn:00001051                 retn    4
.text$mn:00001051 ??A?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QAEAAUTaskLstFnStatus@@I@Z endp
.text$mn:00001051
.text$mn:00001051 _text$mn        ends
.text$mn:00001051
.text$mn:00001054 ; ===========================================================================
.text$mn:00001054
.text$mn:00001054 ; Segment type: Pure code
.text$mn:00001054 ; Segment permissions: Read/Execute
.text$mn:00001054 _text$mn        segment para public 'CODE' use32
.text$mn:00001054                 assume cs:_text$mn
.text$mn:00001054                 ;org 1054h
.text$mn:00001054 ; COMDAT (pick any)
.text$mn:00001054                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001054
.text$mn:00001054 ; =============== S U B R O U T I N E =======================================
.text$mn:00001054
.text$mn:00001054 ; Attributes: bp-based frame
.text$mn:00001054
.text$mn:00001054 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001054                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00001054 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001054
.text$mn:00001054 var_4           = dword ptr -4
.text$mn:00001054 arg_0           = dword ptr  8
.text$mn:00001054
.text$mn:00001054                 push    ebp
.text$mn:00001055                 mov     ebp, esp
.text$mn:00001057                 push    ecx
.text$mn:00001058                 mov     [ebp+var_4], ecx
.text$mn:0000105B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000105E                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001063                 mov     eax, [ebp+arg_0]
.text$mn:00001066                 and     eax, 1
.text$mn:00001069                 jz      short loc_1077
.text$mn:0000106B                 mov     ecx, [ebp+var_4]
.text$mn:0000106E                 push    ecx             ; void *
.text$mn:0000106F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001074                 add     esp, 4
.text$mn:00001077
.text$mn:00001077 loc_1077:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001077                 mov     eax, [ebp+var_4]
.text$mn:0000107A                 mov     esp, ebp
.text$mn:0000107C                 pop     ebp
.text$mn:0000107D                 retn    4
.text$mn:0000107D ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:0000107D
.text$mn:0000107D _text$mn        ends
.text$mn:0000107D
.text$mn:00001080 ; ===========================================================================
.text$mn:00001080
.text$mn:00001080 ; Segment type: Pure code
.text$mn:00001080 ; Segment permissions: Read/Execute
.text$mn:00001080 _text$mn        segment para public 'CODE' use32
.text$mn:00001080                 assume cs:_text$mn
.text$mn:00001080                 ;org 1080h
.text$mn:00001080 ; COMDAT (pick any)
.text$mn:00001080                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001080
.text$mn:00001080 ; =============== S U B R O U T I N E =======================================
.text$mn:00001080
.text$mn:00001080 ; Attributes: bp-based frame
.text$mn:00001080
.text$mn:00001080 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001080                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00001080 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001080
.text$mn:00001080 var_4           = dword ptr -4
.text$mn:00001080 arg_0           = dword ptr  8
.text$mn:00001080
.text$mn:00001080                 push    ebp
.text$mn:00001081                 mov     ebp, esp
.text$mn:00001083                 push    ecx
.text$mn:00001084                 mov     [ebp+var_4], ecx
.text$mn:00001087                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000108A                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:0000108F                 mov     eax, [ebp+arg_0]
.text$mn:00001092                 and     eax, 1
.text$mn:00001095                 jz      short loc_10A3
.text$mn:00001097                 mov     ecx, [ebp+var_4]
.text$mn:0000109A                 push    ecx             ; void *
.text$mn:0000109B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000010A0                 add     esp, 4
.text$mn:000010A3
.text$mn:000010A3 loc_10A3:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000010A3                 mov     eax, [ebp+var_4]
.text$mn:000010A6                 mov     esp, ebp
.text$mn:000010A8                 pop     ebp
.text$mn:000010A9                 retn    4
.text$mn:000010A9 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:000010A9
.text$mn:000010A9 _text$mn        ends
.text$mn:000010A9
.text$mn:000010AC ; ===========================================================================
.text$mn:000010AC
.text$mn:000010AC ; Segment type: Pure code
.text$mn:000010AC ; Segment permissions: Read/Execute
.text$mn:000010AC _text$mn        segment para public 'CODE' use32
.text$mn:000010AC                 assume cs:_text$mn
.text$mn:000010AC                 ;org 10ACh
.text$mn:000010AC ; COMDAT (pick any)
.text$mn:000010AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000010AC
.text$mn:000010AC ; =============== S U B R O U T I N E =======================================
.text$mn:000010AC
.text$mn:000010AC ; Attributes: bp-based frame
.text$mn:000010AC
.text$mn:000010AC ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000010AC                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:000010AC ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:000010AC
.text$mn:000010AC var_4           = dword ptr -4
.text$mn:000010AC arg_0           = dword ptr  8
.text$mn:000010AC
.text$mn:000010AC                 push    ebp
.text$mn:000010AD                 mov     ebp, esp
.text$mn:000010AF                 push    ecx
.text$mn:000010B0                 mov     [ebp+var_4], ecx
.text$mn:000010B3                 mov     ecx, [ebp+var_4] ; this
.text$mn:000010B6                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:000010BB                 mov     eax, [ebp+arg_0]
.text$mn:000010BE                 and     eax, 1
.text$mn:000010C1                 jz      short loc_10CF
.text$mn:000010C3                 mov     ecx, [ebp+var_4]
.text$mn:000010C6                 push    ecx             ; void *
.text$mn:000010C7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000010CC                 add     esp, 4
.text$mn:000010CF
.text$mn:000010CF loc_10CF:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000010CF                 mov     eax, [ebp+var_4]
.text$mn:000010D2                 mov     esp, ebp
.text$mn:000010D4                 pop     ebp
.text$mn:000010D5                 retn    4
.text$mn:000010D5 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:000010D5
.text$mn:000010D5 _text$mn        ends
.text$mn:000010D5
.text$mn:000010D8 ; ===========================================================================
.text$mn:000010D8
.text$mn:000010D8 ; Segment type: Pure code
.text$mn:000010D8 ; Segment permissions: Read/Execute
.text$mn:000010D8 _text$mn        segment para public 'CODE' use32
.text$mn:000010D8                 assume cs:_text$mn
.text$mn:000010D8                 ;org 10D8h
.text$mn:000010D8 ; COMDAT (pick any)
.text$mn:000010D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000010D8
.text$mn:000010D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000010D8
.text$mn:000010D8 ; Attributes: bp-based frame
.text$mn:000010D8
.text$mn:000010D8 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000010D8                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:000010D8 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:000010D8
.text$mn:000010D8 var_4           = dword ptr -4
.text$mn:000010D8 arg_0           = dword ptr  8
.text$mn:000010D8
.text$mn:000010D8                 push    ebp
.text$mn:000010D9                 mov     ebp, esp
.text$mn:000010DB                 push    ecx
.text$mn:000010DC                 mov     [ebp+var_4], ecx
.text$mn:000010DF                 mov     ecx, [ebp+var_4] ; this
.text$mn:000010E2                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:000010E7                 mov     eax, [ebp+arg_0]
.text$mn:000010EA                 and     eax, 1
.text$mn:000010ED                 jz      short loc_10FB
.text$mn:000010EF                 mov     ecx, [ebp+var_4]
.text$mn:000010F2                 push    ecx             ; void *
.text$mn:000010F3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000010F8                 add     esp, 4
.text$mn:000010FB
.text$mn:000010FB loc_10FB:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000010FB                 mov     eax, [ebp+var_4]
.text$mn:000010FE                 mov     esp, ebp
.text$mn:00001100                 pop     ebp
.text$mn:00001101                 retn    4
.text$mn:00001101 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00001101
.text$mn:00001101 _text$mn        ends
.text$mn:00001101
.text$di:00001104 ; ===========================================================================
.text$di:00001104
.text$di:00001104 ; Segment type: Pure code
.text$di:00001104 ; Segment permissions: Read/Execute
.text$di:00001104 _text$di        segment para public 'CODE' use32
.text$di:00001104                 assume cs:_text$di
.text$di:00001104                 ;org 1104h
.text$di:00001104 ; COMDAT (pick any)
.text$di:00001104                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001104
.text$di:00001104 ; =============== S U B R O U T I N E =======================================
.text$di:00001104
.text$di:00001104 ; Attributes: bp-based frame
.text$di:00001104
.text$di:00001104 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00001104 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00001104                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00001104                 push    ebp
.text$di:00001105                 mov     ebp, esp
.text$di:00001107                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:0000110C                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00001111                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001116                 call    _atexit
.text$di:0000111B                 add     esp, 4
.text$di:0000111E                 pop     ebp
.text$di:0000111F                 retn
.text$di:0000111F ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:0000111F
.text$di:0000111F _text$di        ends
.text$di:0000111F
.text$di:00001120 ; ===========================================================================
.text$di:00001120
.text$di:00001120 ; Segment type: Pure code
.text$di:00001120 ; Segment permissions: Read/Execute
.text$di:00001120 _text$di        segment para public 'CODE' use32
.text$di:00001120                 assume cs:_text$di
.text$di:00001120                 ;org 1120h
.text$di:00001120 ; COMDAT (pick any)
.text$di:00001120                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001120
.text$di:00001120 ; =============== S U B R O U T I N E =======================================
.text$di:00001120
.text$di:00001120 ; Attributes: bp-based frame
.text$di:00001120
.text$di:00001120 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00001120 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00001120                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00001120                 push    ebp
.text$di:00001121                 mov     ebp, esp
.text$di:00001123                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00001128                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:0000112D                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001132                 call    _atexit
.text$di:00001137                 add     esp, 4
.text$di:0000113A                 pop     ebp
.text$di:0000113B                 retn
.text$di:0000113B ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:0000113B
.text$di:0000113B _text$di        ends
.text$di:0000113B
.text$di:0000113C ; ===========================================================================
.text$di:0000113C
.text$di:0000113C ; Segment type: Pure code
.text$di:0000113C ; Segment permissions: Read/Execute
.text$di:0000113C _text$di        segment para public 'CODE' use32
.text$di:0000113C                 assume cs:_text$di
.text$di:0000113C                 ;org 113Ch
.text$di:0000113C ; COMDAT (pick any)
.text$di:0000113C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000113C
.text$di:0000113C ; =============== S U B R O U T I N E =======================================
.text$di:0000113C
.text$di:0000113C ; Attributes: bp-based frame
.text$di:0000113C
.text$di:0000113C ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:0000113C ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:0000113C                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:0000113C                 push    ebp
.text$di:0000113D                 mov     ebp, esp
.text$di:0000113F                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00001144                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00001149                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:0000114E                 call    _atexit
.text$di:00001153                 add     esp, 4
.text$di:00001156                 pop     ebp
.text$di:00001157                 retn
.text$di:00001157 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00001157
.text$di:00001157 _text$di        ends
.text$di:00001157
.text$di:00001158 ; ===========================================================================
.text$di:00001158
.text$di:00001158 ; Segment type: Pure code
.text$di:00001158 ; Segment permissions: Read/Execute
.text$di:00001158 _text$di        segment para public 'CODE' use32
.text$di:00001158                 assume cs:_text$di
.text$di:00001158                 ;org 1158h
.text$di:00001158 ; COMDAT (pick any)
.text$di:00001158                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001158
.text$di:00001158 ; =============== S U B R O U T I N E =======================================
.text$di:00001158
.text$di:00001158 ; Attributes: bp-based frame
.text$di:00001158
.text$di:00001158 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00001158 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001158                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00001158                 push    ebp
.text$di:00001159                 mov     ebp, esp
.text$di:0000115B                 push    0               ; unsigned int
.text$di:0000115D                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00001162                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001167                 pop     ebp
.text$di:00001168                 retn
.text$di:00001168 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001168
.text$di:00001168 ; ---------------------------------------------------------------------------
.text$di:00001169                 align 4
.text$di:00001169 _text$di        ends
.text$di:00001169
.text$di:0000116C ; ===========================================================================
.text$di:0000116C
.text$di:0000116C ; Segment type: Pure code
.text$di:0000116C ; Segment permissions: Read/Execute
.text$di:0000116C _text$di        segment para public 'CODE' use32
.text$di:0000116C                 assume cs:_text$di
.text$di:0000116C                 ;org 116Ch
.text$di:0000116C ; COMDAT (pick any)
.text$di:0000116C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000116C
.text$di:0000116C ; =============== S U B R O U T I N E =======================================
.text$di:0000116C
.text$di:0000116C ; Attributes: bp-based frame
.text$di:0000116C
.text$di:0000116C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:0000116C ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:0000116C                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:0000116C                 push    ebp
.text$di:0000116D                 mov     ebp, esp
.text$di:0000116F                 push    0               ; unsigned int
.text$di:00001171                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00001176                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000117B                 pop     ebp
.text$di:0000117C                 retn
.text$di:0000117C ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:0000117C
.text$di:0000117C ; ---------------------------------------------------------------------------
.text$di:0000117D                 align 10h
.text$di:0000117D _text$di        ends
.text$di:0000117D
.text$di:00001180 ; ===========================================================================
.text$di:00001180
.text$di:00001180 ; Segment type: Pure code
.text$di:00001180 ; Segment permissions: Read/Execute
.text$di:00001180 _text$di        segment para public 'CODE' use32
.text$di:00001180                 assume cs:_text$di
.text$di:00001180                 ;org 1180h
.text$di:00001180 ; COMDAT (pick any)
.text$di:00001180                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001180
.text$di:00001180 ; =============== S U B R O U T I N E =======================================
.text$di:00001180
.text$di:00001180 ; Attributes: bp-based frame
.text$di:00001180
.text$di:00001180 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00001180 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001180                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00001180                 push    ebp
.text$di:00001181                 mov     ebp, esp
.text$di:00001183                 push    0               ; unsigned int
.text$di:00001185                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:0000118A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000118F                 pop     ebp
.text$di:00001190                 retn
.text$di:00001190 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001190
.text$di:00001190 ; ---------------------------------------------------------------------------
.text$di:00001191                 align 4
.text$di:00001191 _text$di        ends
.text$di:00001191
.text$di:00001194 ; ===========================================================================
.text$di:00001194
.text$di:00001194 ; Segment type: Pure code
.text$di:00001194 ; Segment permissions: Read/Execute
.text$di:00001194 _text$di        segment para public 'CODE' use32
.text$di:00001194                 assume cs:_text$di
.text$di:00001194                 ;org 1194h
.text$di:00001194 ; COMDAT (pick any)
.text$di:00001194                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001194
.text$di:00001194 ; =============== S U B R O U T I N E =======================================
.text$di:00001194
.text$di:00001194 ; Attributes: bp-based frame
.text$di:00001194
.text$di:00001194 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00001194 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001194                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00001194                 push    ebp
.text$di:00001195                 mov     ebp, esp
.text$di:00001197                 push    0               ; unsigned int
.text$di:00001199                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:0000119E                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000011A3                 pop     ebp
.text$di:000011A4                 retn
.text$di:000011A4 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000011A4
.text$di:000011A4 ; ---------------------------------------------------------------------------
.text$di:000011A5                 align 4
.text$di:000011A5 _text$di        ends
.text$di:000011A5
.text$di:000011A8 ; ===========================================================================
.text$di:000011A8
.text$di:000011A8 ; Segment type: Pure code
.text$di:000011A8 ; Segment permissions: Read/Execute
.text$di:000011A8 _text$di        segment para public 'CODE' use32
.text$di:000011A8                 assume cs:_text$di
.text$di:000011A8                 ;org 11A8h
.text$di:000011A8 ; COMDAT (pick any)
.text$di:000011A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000011A8
.text$di:000011A8 ; =============== S U B R O U T I N E =======================================
.text$di:000011A8
.text$di:000011A8 ; Attributes: bp-based frame
.text$di:000011A8
.text$di:000011A8 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:000011A8 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:000011A8
.text$di:000011A8 var_1           = byte ptr -1
.text$di:000011A8
.text$di:000011A8                 push    ebp
.text$di:000011A9                 mov     ebp, esp
.text$di:000011AB                 push    ecx
.text$di:000011AC                 xor     eax, eax
.text$di:000011AE                 mov     [ebp+var_1], al
.text$di:000011B1                 mov     esp, ebp
.text$di:000011B3                 pop     ebp
.text$di:000011B4                 retn
.text$di:000011B4 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:000011B4
.text$di:000011B4 ; ---------------------------------------------------------------------------
.text$di:000011B5                 align 4
.text$di:000011B5 _text$di        ends
.text$di:000011B5
.text$di:000011B8 ; ===========================================================================
.text$di:000011B8
.text$di:000011B8 ; Segment type: Pure code
.text$di:000011B8 ; Segment permissions: Read/Execute
.text$di:000011B8 _text$di        segment para public 'CODE' use32
.text$di:000011B8                 assume cs:_text$di
.text$di:000011B8                 ;org 11B8h
.text$di:000011B8 ; COMDAT (pick any)
.text$di:000011B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000011B8
.text$di:000011B8 ; =============== S U B R O U T I N E =======================================
.text$di:000011B8
.text$di:000011B8 ; Attributes: bp-based frame
.text$di:000011B8
.text$di:000011B8 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:000011B8 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:000011B8                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:000011B8
.text$di:000011B8 var_1           = byte ptr -1
.text$di:000011B8
.text$di:000011B8                 push    ebp
.text$di:000011B9                 mov     ebp, esp
.text$di:000011BB                 push    ecx
.text$di:000011BC                 xor     eax, eax
.text$di:000011BE                 mov     [ebp+var_1], al
.text$di:000011C1                 mov     esp, ebp
.text$di:000011C3                 pop     ebp
.text$di:000011C4                 retn
.text$di:000011C4 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:000011C4
.text$di:000011C4 ; ---------------------------------------------------------------------------
.text$di:000011C5                 align 4
.text$di:000011C5 _text$di        ends
.text$di:000011C5
.text$yd:000011C8 ; ===========================================================================
.text$yd:000011C8
.text$yd:000011C8 ; Segment type: Pure code
.text$yd:000011C8 ; Segment permissions: Read/Execute
.text$yd:000011C8 _text$yd        segment para public 'CODE' use32
.text$yd:000011C8                 assume cs:_text$yd
.text$yd:000011C8                 ;org 11C8h
.text$yd:000011C8 ; COMDAT (pick any)
.text$yd:000011C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000011C8
.text$yd:000011C8 ; =============== S U B R O U T I N E =======================================
.text$yd:000011C8
.text$yd:000011C8 ; Attributes: bp-based frame
.text$yd:000011C8
.text$yd:000011C8 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:000011C8 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:000011C8                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:000011C8                 push    ebp
.text$yd:000011C9                 mov     ebp, esp
.text$yd:000011CB                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:000011D0                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:000011D5                 pop     ebp
.text$yd:000011D6                 retn
.text$yd:000011D6 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:000011D6
.text$yd:000011D6 ; ---------------------------------------------------------------------------
.text$yd:000011D7                 align 4
.text$yd:000011D7 _text$yd        ends
.text$yd:000011D7
.text$yd:000011D8 ; ===========================================================================
.text$yd:000011D8
.text$yd:000011D8 ; Segment type: Pure code
.text$yd:000011D8 ; Segment permissions: Read/Execute
.text$yd:000011D8 _text$yd        segment para public 'CODE' use32
.text$yd:000011D8                 assume cs:_text$yd
.text$yd:000011D8                 ;org 11D8h
.text$yd:000011D8 ; COMDAT (pick any)
.text$yd:000011D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000011D8
.text$yd:000011D8 ; =============== S U B R O U T I N E =======================================
.text$yd:000011D8
.text$yd:000011D8 ; Attributes: bp-based frame
.text$yd:000011D8
.text$yd:000011D8 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:000011D8 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:000011D8                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:000011D8                 push    ebp
.text$yd:000011D9                 mov     ebp, esp
.text$yd:000011DB                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:000011E0                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:000011E5                 pop     ebp
.text$yd:000011E6                 retn
.text$yd:000011E6 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:000011E6
.text$yd:000011E6 ; ---------------------------------------------------------------------------
.text$yd:000011E7                 align 4
.text$yd:000011E7 _text$yd        ends
.text$yd:000011E7
.text$yd:000011E8 ; ===========================================================================
.text$yd:000011E8
.text$yd:000011E8 ; Segment type: Pure code
.text$yd:000011E8 ; Segment permissions: Read/Execute
.text$yd:000011E8 _text$yd        segment para public 'CODE' use32
.text$yd:000011E8                 assume cs:_text$yd
.text$yd:000011E8                 ;org 11E8h
.text$yd:000011E8 ; COMDAT (pick any)
.text$yd:000011E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000011E8
.text$yd:000011E8 ; =============== S U B R O U T I N E =======================================
.text$yd:000011E8
.text$yd:000011E8 ; Attributes: bp-based frame
.text$yd:000011E8
.text$yd:000011E8 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:000011E8 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:000011E8                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:000011E8                 push    ebp
.text$yd:000011E9                 mov     ebp, esp
.text$yd:000011EB                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:000011F0                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:000011F5                 pop     ebp
.text$yd:000011F6                 retn
.text$yd:000011F6 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:000011F6
.text$yd:000011F6 ; ---------------------------------------------------------------------------
.text$yd:000011F7                 align 4
.text$yd:000011F7 _text$yd        ends
.text$yd:000011F7
.text$mn:000011F8 ; ===========================================================================
.text$mn:000011F8
.text$mn:000011F8 ; Segment type: Pure code
.text$mn:000011F8 ; Segment permissions: Read/Execute
.text$mn:000011F8 _text$mn        segment para public 'CODE' use32
.text$mn:000011F8                 assume cs:_text$mn
.text$mn:000011F8                 ;org 11F8h
.text$mn:000011F8 ; COMDAT (pick any)
.text$mn:000011F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000011F8
.text$mn:000011F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000011F8
.text$mn:000011F8 ; Attributes: bp-based frame
.text$mn:000011F8
.text$mn:000011F8 ; HFONT __thiscall TaskList::GetFontSelected(TaskList *__hidden this)
.text$mn:000011F8                 public ?GetFontSelected@TaskList@@QAEPAUHFONT__@@XZ
.text$mn:000011F8 ?GetFontSelected@TaskList@@QAEPAUHFONT__@@XZ proc near
.text$mn:000011F8                                         ; CODE XREF: TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+A0p
.text$mn:000011F8
.text$mn:000011F8 var_4           = dword ptr -4
.text$mn:000011F8
.text$mn:000011F8                 push    ebp
.text$mn:000011F9                 mov     ebp, esp
.text$mn:000011FB                 push    ecx
.text$mn:000011FC                 mov     [ebp+var_4], ecx
.text$mn:000011FF                 mov     eax, [ebp+var_4]
.text$mn:00001202                 mov     eax, [eax+18h]
.text$mn:00001205                 mov     esp, ebp
.text$mn:00001207                 pop     ebp
.text$mn:00001208                 retn
.text$mn:00001208 ?GetFontSelected@TaskList@@QAEPAUHFONT__@@XZ endp
.text$mn:00001208
.text$mn:00001208 ; ---------------------------------------------------------------------------
.text$mn:00001209                 align 4
.text$mn:00001209 _text$mn        ends
.text$mn:00001209
.text$mn:0000120C ; ===========================================================================
.text$mn:0000120C
.text$mn:0000120C ; Segment type: Pure code
.text$mn:0000120C ; Segment permissions: Read/Execute
.text$mn:0000120C _text$mn        segment para public 'CODE' use32
.text$mn:0000120C                 assume cs:_text$mn
.text$mn:0000120C                 ;org 120Ch
.text$mn:0000120C ; COMDAT (pick any)
.text$mn:0000120C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000120C
.text$mn:0000120C ; =============== S U B R O U T I N E =======================================
.text$mn:0000120C
.text$mn:0000120C ; Attributes: bp-based frame
.text$mn:0000120C
.text$mn:0000120C ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:0000120C                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:0000120C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:0000120C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:0000120C
.text$mn:0000120C var_10          = byte ptr -10h
.text$mn:0000120C var_8           = dword ptr -8
.text$mn:0000120C var_1           = byte ptr -1
.text$mn:0000120C
.text$mn:0000120C                 push    ebp
.text$mn:0000120D                 mov     ebp, esp
.text$mn:0000120F                 sub     esp, 10h
.text$mn:00001212                 mov     [ebp+var_8], ecx
.text$mn:00001215                 lea     ecx, [ebp+var_1]
.text$mn:00001218                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:0000121D                 push    1
.text$mn:0000121F                 lea     ecx, [ebp+var_1]
.text$mn:00001222                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00001227                 mov     ecx, [ebp+var_8]
.text$mn:0000122A                 mov     [ecx], eax
.text$mn:0000122C                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000122F                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00001234                 push    eax             ; int
.text$mn:00001235                 mov     edx, [ebp+var_8]
.text$mn:00001238                 mov     eax, [edx]
.text$mn:0000123A                 push    eax             ; void *
.text$mn:0000123B                 lea     ecx, [ebp+var_1]
.text$mn:0000123E                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00001243                 mov     ecx, [ebp+var_8]
.text$mn:00001246                 mov     edx, [ecx]
.text$mn:00001248                 mov     eax, [ebp+var_8]
.text$mn:0000124B                 mov     [edx], eax
.text$mn:0000124D                 mov     esp, ebp
.text$mn:0000124F                 pop     ebp
.text$mn:00001250                 retn
.text$mn:00001250 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001250
.text$mn:00001250 ; ---------------------------------------------------------------------------
.text$mn:00001251                 align 4
.text$mn:00001251 _text$mn        ends
.text$mn:00001251
.text$mn:00001254 ; ===========================================================================
.text$mn:00001254
.text$mn:00001254 ; Segment type: Pure code
.text$mn:00001254 ; Segment permissions: Read/Execute
.text$mn:00001254 _text$mn        segment para public 'CODE' use32
.text$mn:00001254                 assume cs:_text$mn
.text$mn:00001254                 ;org 1254h
.text$mn:00001254 ; COMDAT (pick any)
.text$mn:00001254                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001254
.text$mn:00001254 ; =============== S U B R O U T I N E =======================================
.text$mn:00001254
.text$mn:00001254 ; Attributes: bp-based frame
.text$mn:00001254
.text$mn:00001254 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00001254                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001254 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00001254                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00001254
.text$mn:00001254 var_20          = dword ptr -20h
.text$mn:00001254 var_1C          = dword ptr -1Ch
.text$mn:00001254 var_18          = dword ptr -18h
.text$mn:00001254 var_11          = byte ptr -11h
.text$mn:00001254 var_10          = dword ptr -10h
.text$mn:00001254 var_C           = byte ptr -0Ch
.text$mn:00001254 var_4           = dword ptr -4
.text$mn:00001254 arg_0           = dword ptr  8
.text$mn:00001254
.text$mn:00001254 ; FUNCTION CHUNK AT .text$mn:00001376 SIZE 00000009 BYTES
.text$mn:00001254
.text$mn:00001254                 push    ebp
.text$mn:00001255                 mov     ebp, esp
.text$mn:00001257                 push    0FFFFFFFFh
.text$mn:00001259                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000125E                 mov     eax, large fs:0
.text$mn:00001264                 push    eax
.text$mn:00001265                 push    ecx
.text$mn:00001266                 sub     esp, 10h
.text$mn:00001269                 push    ebx
.text$mn:0000126A                 push    esi
.text$mn:0000126B                 push    edi
.text$mn:0000126C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001271                 xor     eax, ebp
.text$mn:00001273                 push    eax
.text$mn:00001274                 lea     eax, [ebp+var_C]
.text$mn:00001277                 mov     large fs:0, eax
.text$mn:0000127D                 mov     [ebp+var_10], esp
.text$mn:00001280                 mov     [ebp+var_18], ecx
.text$mn:00001283                 mov     eax, [ebp+arg_0]
.text$mn:00001286                 or      eax, 0Fh
.text$mn:00001289                 mov     [ebp+var_1C], eax
.text$mn:0000128C                 mov     ecx, [ebp+var_18]
.text$mn:0000128F                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001294                 cmp     eax, [ebp+var_1C]
.text$mn:00001297                 jnb     short loc_12A1
.text$mn:00001299                 mov     ecx, [ebp+arg_0]
.text$mn:0000129C                 mov     [ebp+var_1C], ecx
.text$mn:0000129F                 jmp     short loc_12F3
.text$mn:000012A1 ; ---------------------------------------------------------------------------
.text$mn:000012A1
.text$mn:000012A1 loc_12A1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:000012A1                 mov     edx, [ebp+var_18]
.text$mn:000012A4                 mov     ecx, [edx+18h]
.text$mn:000012A7                 shr     ecx, 1
.text$mn:000012A9                 mov     eax, [ebp+var_1C]
.text$mn:000012AC                 xor     edx, edx
.text$mn:000012AE                 mov     esi, 3
.text$mn:000012B3                 div     esi
.text$mn:000012B5                 cmp     ecx, eax
.text$mn:000012B7                 ja      short loc_12BB
.text$mn:000012B9                 jmp     short loc_12F3
.text$mn:000012BB ; ---------------------------------------------------------------------------
.text$mn:000012BB
.text$mn:000012BB loc_12BB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:000012BB                 mov     ecx, [ebp+var_18]
.text$mn:000012BE                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000012C3                 mov     edx, [ebp+var_18]
.text$mn:000012C6                 mov     ecx, [edx+18h]
.text$mn:000012C9                 shr     ecx, 1
.text$mn:000012CB                 sub     eax, ecx
.text$mn:000012CD                 mov     edx, [ebp+var_18]
.text$mn:000012D0                 cmp     [edx+18h], eax
.text$mn:000012D3                 ja      short loc_12E8
.text$mn:000012D5                 mov     eax, [ebp+var_18]
.text$mn:000012D8                 mov     ecx, [eax+18h]
.text$mn:000012DB                 shr     ecx, 1
.text$mn:000012DD                 mov     edx, [ebp+var_18]
.text$mn:000012E0                 add     ecx, [edx+18h]
.text$mn:000012E3                 mov     [ebp+var_1C], ecx
.text$mn:000012E6                 jmp     short loc_12F3
.text$mn:000012E8 ; ---------------------------------------------------------------------------
.text$mn:000012E8
.text$mn:000012E8 loc_12E8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:000012E8                 mov     ecx, [ebp+var_18]
.text$mn:000012EB                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000012F0                 mov     [ebp+var_1C], eax
.text$mn:000012F3
.text$mn:000012F3 loc_12F3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:000012F3                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:000012F3                 mov     [ebp+var_4], 0
.text$mn:000012FA                 mov     eax, [ebp+var_1C]
.text$mn:000012FD                 add     eax, 1
.text$mn:00001300                 push    eax
.text$mn:00001301                 lea     ecx, [ebp+var_11]
.text$mn:00001304                 push    ecx
.text$mn:00001305                 mov     ecx, [ebp+var_18]
.text$mn:00001308                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000130D                 mov     ecx, eax
.text$mn:0000130F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00001314                 mov     [ebp+var_20], eax
.text$mn:00001317                 jmp     short loc_1376
.text$mn:00001317 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00001317
.text$mn:00001319
.text$mn:00001319 ; =============== S U B R O U T I N E =======================================
.text$mn:00001319
.text$mn:00001319
.text$mn:00001319 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00001319                                         ; DATA XREF: .xdata$x:00002154o
.text$mn:00001319
.text$mn:00001319 ; FUNCTION CHUNK AT .text$mn:00001360 SIZE 00000009 BYTES
.text$mn:00001319 ; FUNCTION CHUNK AT .text$mn:00001370 SIZE 00000006 BYTES
.text$mn:00001319
.text$mn:00001319                 mov     [ebp-10h], esp
.text$mn:0000131C                 mov     edx, [ebp+8]
.text$mn:0000131F                 mov     [ebp-1Ch], edx
.text$mn:00001322                 mov     byte ptr [ebp-4], 2
.text$mn:00001326                 mov     eax, [ebp-1Ch]
.text$mn:00001329                 add     eax, 1
.text$mn:0000132C                 push    eax
.text$mn:0000132D                 lea     ecx, [ebp-12h]
.text$mn:00001330                 push    ecx
.text$mn:00001331                 mov     ecx, [ebp-18h]
.text$mn:00001334                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001339                 mov     ecx, eax
.text$mn:0000133B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00001340                 mov     [ebp-20h], eax
.text$mn:00001343                 jmp     short loc_1360
.text$mn:00001343 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00001343
.text$mn:00001345
.text$mn:00001345 ; =============== S U B R O U T I N E =======================================
.text$mn:00001345
.text$mn:00001345 ; Attributes: noreturn
.text$mn:00001345
.text$mn:00001345 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00001345                                         ; DATA XREF: .xdata$x:00002164o
.text$mn:00001345                 push    0               ; Size
.text$mn:00001347                 push    1               ; char
.text$mn:00001349                 mov     ecx, [ebp-18h]
.text$mn:0000134C                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001351                 push    0
.text$mn:00001353                 push    0
.text$mn:00001355                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00001355 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00001355
.text$mn:0000135A ; ---------------------------------------------------------------------------
.text$mn:0000135A                 mov     eax, offset $LN17
.text$mn:0000135F                 retn
.text$mn:00001360 ; ---------------------------------------------------------------------------
.text$mn:00001360 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001360
.text$mn:00001360 loc_1360:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00001360                 mov     dword ptr [ebp-4], 1
.text$mn:00001367                 jmp     short loc_1370
.text$mn:00001367 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001369
.text$mn:00001369 ; =============== S U B R O U T I N E =======================================
.text$mn:00001369
.text$mn:00001369
.text$mn:00001369 $LN17           proc near               ; DATA XREF: .text$mn:0000135Ao
.text$mn:00001369                 mov     dword ptr [ebp-4], 1
.text$mn:00001369 $LN17           endp ; sp-analysis failed
.text$mn:00001369
.text$mn:00001370 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001370
.text$mn:00001370 loc_1370:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00001370                 mov     eax, offset $LN19
.text$mn:00001375                 retn
.text$mn:00001375 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001376 ; ---------------------------------------------------------------------------
.text$mn:00001376 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001376
.text$mn:00001376 loc_1376:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00001376                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000137D                 jmp     short loc_1386
.text$mn:0000137D ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000137F
.text$mn:0000137F ; =============== S U B R O U T I N E =======================================
.text$mn:0000137F
.text$mn:0000137F
.text$mn:0000137F $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_1370o
.text$mn:0000137F                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00001386
.text$mn:00001386 loc_1386:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00001386                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:0000138A                 jbe     short loc_13A5
.text$mn:0000138C                 mov     edx, [ebp+0Ch]
.text$mn:0000138F                 push    edx             ; Size
.text$mn:00001390                 mov     ecx, [ebp-18h]
.text$mn:00001393                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001398                 push    eax             ; Src
.text$mn:00001399                 mov     eax, [ebp-20h]
.text$mn:0000139C                 push    eax             ; Dst
.text$mn:0000139D                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000013A2                 add     esp, 0Ch
.text$mn:000013A5
.text$mn:000013A5 loc_13A5:                               ; CODE XREF: $LN19+Bj
.text$mn:000013A5                 push    0               ; Size
.text$mn:000013A7                 push    1               ; char
.text$mn:000013A9                 mov     ecx, [ebp-18h]
.text$mn:000013AC                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000013B1                 lea     ecx, [ebp-20h]
.text$mn:000013B4                 push    ecx             ; int
.text$mn:000013B5                 mov     edx, [ebp-18h]
.text$mn:000013B8                 add     edx, 4
.text$mn:000013BB                 push    edx             ; void *
.text$mn:000013BC                 lea     eax, [ebp-13h]
.text$mn:000013BF                 push    eax
.text$mn:000013C0                 mov     ecx, [ebp-18h]
.text$mn:000013C3                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000013C8                 mov     ecx, eax
.text$mn:000013CA                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:000013CF                 mov     ecx, [ebp-18h]
.text$mn:000013D2                 mov     edx, [ebp-1Ch]
.text$mn:000013D5                 mov     [ecx+18h], edx
.text$mn:000013D8                 mov     eax, [ebp+0Ch]
.text$mn:000013DB                 push    eax
.text$mn:000013DC                 mov     ecx, [ebp-18h]
.text$mn:000013DF                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000013E4                 mov     ecx, [ebp-0Ch]
.text$mn:000013E7                 mov     large fs:0, ecx
.text$mn:000013EE                 pop     ecx
.text$mn:000013EF                 pop     edi
.text$mn:000013F0                 pop     esi
.text$mn:000013F1                 pop     ebx
.text$mn:000013F2                 mov     esp, ebp
.text$mn:000013F4                 pop     ebp
.text$mn:000013F5                 retn    8
.text$mn:000013F5 $LN19           endp ; sp-analysis failed
.text$mn:000013F5
.text$mn:000013F5 _text$mn        ends
.text$mn:000013F5
.text$x:000013F8 ; ===========================================================================
.text$x:000013F8
.text$x:000013F8 ; Segment type: Pure code
.text$x:000013F8 ; Segment permissions: Read/Execute
.text$x:000013F8 _text$x         segment para public 'CODE' use32
.text$x:000013F8                 assume cs:_text$x
.text$x:000013F8                 ;org 13F8h
.text$x:000013F8 ; COMDAT (pick associative to section at 1254)
.text$x:000013F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000013F8
.text$x:000013F8 ; =============== S U B R O U T I N E =======================================
.text$x:000013F8
.text$x:000013F8
.text$x:000013F8 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:000013F8                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:000013F8
.text$x:000013F8 arg_4           = dword ptr  8
.text$x:000013F8
.text$x:000013F8                 mov     edx, [esp+arg_4]
.text$x:000013FC                 lea     eax, [edx+0Ch]
.text$x:000013FF                 mov     ecx, [edx-24h]
.text$x:00001402                 xor     ecx, eax
.text$x:00001404                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001409                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:0000140E                 jmp     ___CxxFrameHandler3
.text$x:0000140E __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:0000140E
.text$x:0000140E ; ---------------------------------------------------------------------------
.text$x:00001413                 align 4
.text$x:00001413 _text$x         ends
.text$x:00001413
.text$mn:00001414 ; ===========================================================================
.text$mn:00001414
.text$mn:00001414 ; Segment type: Pure code
.text$mn:00001414 ; Segment permissions: Read/Execute
.text$mn:00001414 _text$mn        segment para public 'CODE' use32
.text$mn:00001414                 assume cs:_text$mn
.text$mn:00001414                 ;org 1414h
.text$mn:00001414 ; COMDAT (pick any)
.text$mn:00001414                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001414
.text$mn:00001414 ; =============== S U B R O U T I N E =======================================
.text$mn:00001414
.text$mn:00001414 ; Attributes: bp-based frame
.text$mn:00001414
.text$mn:00001414 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00001414                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00001414 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00001414                                         ; CODE XREF: $LN19+60p
.text$mn:00001414                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00001414
.text$mn:00001414 var_8           = dword ptr -8
.text$mn:00001414 var_1           = byte ptr -1
.text$mn:00001414 arg_0           = dword ptr  8
.text$mn:00001414
.text$mn:00001414                 push    ebp
.text$mn:00001415                 mov     ebp, esp
.text$mn:00001417                 sub     esp, 8
.text$mn:0000141A                 mov     [ebp+var_8], ecx
.text$mn:0000141D                 mov     [ebp+var_1], 0
.text$mn:00001421                 mov     eax, [ebp+var_8]
.text$mn:00001424                 mov     ecx, [ebp+arg_0]
.text$mn:00001427                 mov     [eax+14h], ecx
.text$mn:0000142A                 lea     edx, [ebp+var_1]
.text$mn:0000142D                 push    edx
.text$mn:0000142E                 mov     ecx, [ebp+var_8]
.text$mn:00001431                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001436                 add     eax, [ebp+arg_0]
.text$mn:00001439                 push    eax
.text$mn:0000143A                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:0000143F                 add     esp, 8
.text$mn:00001442                 mov     esp, ebp
.text$mn:00001444                 pop     ebp
.text$mn:00001445                 retn    4
.text$mn:00001445 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00001445
.text$mn:00001445 _text$mn        ends
.text$mn:00001445
.text$mn:00001448 ; ===========================================================================
.text$mn:00001448
.text$mn:00001448 ; Segment type: Pure code
.text$mn:00001448 ; Segment permissions: Read/Execute
.text$mn:00001448 _text$mn        segment para public 'CODE' use32
.text$mn:00001448                 assume cs:_text$mn
.text$mn:00001448                 ;org 1448h
.text$mn:00001448 ; COMDAT (pick any)
.text$mn:00001448                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001448
.text$mn:00001448 ; =============== S U B R O U T I N E =======================================
.text$mn:00001448
.text$mn:00001448 ; Attributes: bp-based frame
.text$mn:00001448
.text$mn:00001448 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00001448                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00001448 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001448                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00001448
.text$mn:00001448 var_8           = dword ptr -8
.text$mn:00001448 var_1           = byte ptr -1
.text$mn:00001448
.text$mn:00001448                 push    ebp
.text$mn:00001449                 mov     ebp, esp
.text$mn:0000144B                 sub     esp, 8
.text$mn:0000144E                 mov     [ebp+var_8], ecx
.text$mn:00001451                 lea     ecx, [ebp+var_1]
.text$mn:00001454                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001459                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000145C                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00001461                 mov     eax, [ebp+var_8]
.text$mn:00001464                 mov     ecx, [eax]
.text$mn:00001466                 push    ecx
.text$mn:00001467                 lea     ecx, [ebp+var_1]
.text$mn:0000146A                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000146F                 push    1               ; int
.text$mn:00001471                 mov     edx, [ebp+var_8]
.text$mn:00001474                 mov     eax, [edx]
.text$mn:00001476                 push    eax             ; void *
.text$mn:00001477                 lea     ecx, [ebp+var_1]
.text$mn:0000147A                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000147F                 mov     ecx, [ebp+var_8]
.text$mn:00001482                 mov     dword ptr [ecx], 0
.text$mn:00001488                 mov     esp, ebp
.text$mn:0000148A                 pop     ebp
.text$mn:0000148B                 retn
.text$mn:0000148B ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000148B
.text$mn:0000148B _text$mn        ends
.text$mn:0000148B
.text$mn:0000148C ; ===========================================================================
.text$mn:0000148C
.text$mn:0000148C ; Segment type: Pure code
.text$mn:0000148C ; Segment permissions: Read/Execute
.text$mn:0000148C _text$mn        segment para public 'CODE' use32
.text$mn:0000148C                 assume cs:_text$mn
.text$mn:0000148C                 ;org 148Ch
.text$mn:0000148C ; COMDAT (pick any)
.text$mn:0000148C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000148C
.text$mn:0000148C ; =============== S U B R O U T I N E =======================================
.text$mn:0000148C
.text$mn:0000148C ; Attributes: bp-based frame
.text$mn:0000148C
.text$mn:0000148C ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:0000148C                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:0000148C ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:0000148C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:0000148C                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:0000148C
.text$mn:0000148C var_4           = dword ptr -4
.text$mn:0000148C arg_0           = dword ptr  8
.text$mn:0000148C
.text$mn:0000148C                 push    ebp
.text$mn:0000148D                 mov     ebp, esp
.text$mn:0000148F                 push    ecx
.text$mn:00001490                 mov     [ebp+var_4], ecx
.text$mn:00001493                 mov     ecx, [ebp+arg_0]
.text$mn:00001496                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:0000149B                 mov     eax, [ebp+arg_0]
.text$mn:0000149E                 mov     esp, ebp
.text$mn:000014A0                 pop     ebp
.text$mn:000014A1                 retn    4
.text$mn:000014A1 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:000014A1
.text$mn:000014A1 _text$mn        ends
.text$mn:000014A1
.text$mn:000014A4 ; ===========================================================================
.text$mn:000014A4
.text$mn:000014A4 ; Segment type: Pure code
.text$mn:000014A4 ; Segment permissions: Read/Execute
.text$mn:000014A4 _text$mn        segment para public 'CODE' use32
.text$mn:000014A4                 assume cs:_text$mn
.text$mn:000014A4                 ;org 14A4h
.text$mn:000014A4 ; COMDAT (pick any)
.text$mn:000014A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014A4
.text$mn:000014A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000014A4
.text$mn:000014A4 ; Attributes: bp-based frame
.text$mn:000014A4
.text$mn:000014A4 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:000014A4                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:000014A4 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:000014A4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:000014A4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:000014A4
.text$mn:000014A4 var_C           = dword ptr -0Ch
.text$mn:000014A4 Size            = dword ptr -8
.text$mn:000014A4 var_4           = dword ptr -4
.text$mn:000014A4 arg_0           = dword ptr  8
.text$mn:000014A4 arg_4           = byte ptr  0Ch
.text$mn:000014A4
.text$mn:000014A4                 push    ebp
.text$mn:000014A5                 mov     ebp, esp
.text$mn:000014A7                 sub     esp, 0Ch
.text$mn:000014AA                 mov     [ebp+var_4], ecx
.text$mn:000014AD                 mov     ecx, [ebp+var_4]
.text$mn:000014B0                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000014B5                 cmp     eax, [ebp+arg_0]
.text$mn:000014B8                 jnb     short loc_14C2
.text$mn:000014BA                 mov     ecx, [ebp+var_4]
.text$mn:000014BD                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:000014C2
.text$mn:000014C2 loc_14C2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:000014C2                 mov     eax, [ebp+var_4]
.text$mn:000014C5                 mov     ecx, [eax+18h]
.text$mn:000014C8                 cmp     ecx, [ebp+arg_0]
.text$mn:000014CB                 jnb     short loc_14E2
.text$mn:000014CD                 mov     edx, [ebp+var_4]
.text$mn:000014D0                 mov     eax, [edx+14h]
.text$mn:000014D3                 push    eax
.text$mn:000014D4                 mov     ecx, [ebp+arg_0]
.text$mn:000014D7                 push    ecx
.text$mn:000014D8                 mov     ecx, [ebp+var_4]
.text$mn:000014DB                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:000014E0                 jmp     short loc_152C
.text$mn:000014E2 ; ---------------------------------------------------------------------------
.text$mn:000014E2
.text$mn:000014E2 loc_14E2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:000014E2                 movzx   edx, [ebp+arg_4]
.text$mn:000014E6                 test    edx, edx
.text$mn:000014E8                 jz      short loc_151C
.text$mn:000014EA                 cmp     [ebp+arg_0], 10h
.text$mn:000014EE                 jnb     short loc_151C
.text$mn:000014F0                 mov     eax, [ebp+var_4]
.text$mn:000014F3                 mov     ecx, [ebp+arg_0]
.text$mn:000014F6                 cmp     ecx, [eax+14h]
.text$mn:000014F9                 jnb     short loc_1503
.text$mn:000014FB                 mov     edx, [ebp+arg_0]
.text$mn:000014FE                 mov     [ebp+Size], edx
.text$mn:00001501                 jmp     short loc_150C
.text$mn:00001503 ; ---------------------------------------------------------------------------
.text$mn:00001503
.text$mn:00001503 loc_1503:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00001503                 mov     eax, [ebp+var_4]
.text$mn:00001506                 mov     ecx, [eax+14h]
.text$mn:00001509                 mov     [ebp+Size], ecx
.text$mn:0000150C
.text$mn:0000150C loc_150C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:0000150C                 mov     edx, [ebp+Size]
.text$mn:0000150F                 push    edx             ; Size
.text$mn:00001510                 push    1               ; char
.text$mn:00001512                 mov     ecx, [ebp+var_4]
.text$mn:00001515                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000151A                 jmp     short loc_152C
.text$mn:0000151C ; ---------------------------------------------------------------------------
.text$mn:0000151C
.text$mn:0000151C loc_151C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:0000151C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:0000151C                 cmp     [ebp+arg_0], 0
.text$mn:00001520                 jnz     short loc_152C
.text$mn:00001522                 push    0
.text$mn:00001524                 mov     ecx, [ebp+var_4]
.text$mn:00001527                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000152C
.text$mn:0000152C loc_152C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:0000152C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:0000152C                 cmp     [ebp+arg_0], 0
.text$mn:00001530                 jbe     short loc_153B
.text$mn:00001532                 mov     [ebp+var_C], 1
.text$mn:00001539                 jmp     short loc_1542
.text$mn:0000153B ; ---------------------------------------------------------------------------
.text$mn:0000153B
.text$mn:0000153B loc_153B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:0000153B                 mov     [ebp+var_C], 0
.text$mn:00001542
.text$mn:00001542 loc_1542:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00001542                 mov     al, byte ptr [ebp+var_C]
.text$mn:00001545                 mov     esp, ebp
.text$mn:00001547                 pop     ebp
.text$mn:00001548                 retn    8
.text$mn:00001548 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00001548
.text$mn:00001548 ; ---------------------------------------------------------------------------
.text$mn:0000154B                 align 4
.text$mn:0000154B _text$mn        ends
.text$mn:0000154B
.text$mn:0000154C ; ===========================================================================
.text$mn:0000154C
.text$mn:0000154C ; Segment type: Pure code
.text$mn:0000154C ; Segment permissions: Read/Execute
.text$mn:0000154C _text$mn        segment para public 'CODE' use32
.text$mn:0000154C                 assume cs:_text$mn
.text$mn:0000154C                 ;org 154Ch
.text$mn:0000154C ; COMDAT (pick any)
.text$mn:0000154C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000154C
.text$mn:0000154C ; =============== S U B R O U T I N E =======================================
.text$mn:0000154C
.text$mn:0000154C ; Attributes: bp-based frame
.text$mn:0000154C
.text$mn:0000154C ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:0000154C                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:0000154C ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:0000154C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:0000154C
.text$mn:0000154C var_4           = dword ptr -4
.text$mn:0000154C arg_0           = dword ptr  8
.text$mn:0000154C
.text$mn:0000154C                 push    ebp
.text$mn:0000154D                 mov     ebp, esp
.text$mn:0000154F                 push    ecx
.text$mn:00001550                 mov     [ebp+var_4], ecx
.text$mn:00001553                 cmp     [ebp+arg_0], 0
.text$mn:00001557                 jz      short loc_1579
.text$mn:00001559                 mov     ecx, [ebp+var_4]
.text$mn:0000155C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001561                 cmp     [ebp+arg_0], eax
.text$mn:00001564                 jb      short loc_1579
.text$mn:00001566                 mov     ecx, [ebp+var_4]
.text$mn:00001569                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000156E                 mov     ecx, [ebp+var_4]
.text$mn:00001571                 add     eax, [ecx+14h]
.text$mn:00001574                 cmp     eax, [ebp+arg_0]
.text$mn:00001577                 ja      short loc_157F
.text$mn:00001579
.text$mn:00001579 loc_1579:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00001579                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00001579                 xor     al, al
.text$mn:0000157B                 jmp     short loc_1581
.text$mn:0000157D ; ---------------------------------------------------------------------------
.text$mn:0000157D                 jmp     short loc_1581
.text$mn:0000157F ; ---------------------------------------------------------------------------
.text$mn:0000157F
.text$mn:0000157F loc_157F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:0000157F                 mov     al, 1
.text$mn:00001581
.text$mn:00001581 loc_1581:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00001581                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00001581                 mov     esp, ebp
.text$mn:00001583                 pop     ebp
.text$mn:00001584                 retn    4
.text$mn:00001584 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00001584
.text$mn:00001584 ; ---------------------------------------------------------------------------
.text$mn:00001587                 align 4
.text$mn:00001587 _text$mn        ends
.text$mn:00001587
.text$mn:00001588 ; ===========================================================================
.text$mn:00001588
.text$mn:00001588 ; Segment type: Pure code
.text$mn:00001588 ; Segment permissions: Read/Execute
.text$mn:00001588 _text$mn        segment para public 'CODE' use32
.text$mn:00001588                 assume cs:_text$mn
.text$mn:00001588                 ;org 1588h
.text$mn:00001588 ; COMDAT (pick any)
.text$mn:00001588                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001588
.text$mn:00001588 ; =============== S U B R O U T I N E =======================================
.text$mn:00001588
.text$mn:00001588 ; Attributes: bp-based frame
.text$mn:00001588
.text$mn:00001588 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001588                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00001588 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00001588                                         ; CODE XREF: $LN19+14p
.text$mn:00001588                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00001588
.text$mn:00001588 var_8           = dword ptr -8
.text$mn:00001588 var_4           = dword ptr -4
.text$mn:00001588
.text$mn:00001588                 push    ebp
.text$mn:00001589                 mov     ebp, esp
.text$mn:0000158B                 sub     esp, 8
.text$mn:0000158E                 mov     [ebp+var_4], ecx
.text$mn:00001591                 mov     eax, [ebp+var_4]
.text$mn:00001594                 cmp     dword ptr [eax+18h], 10h
.text$mn:00001598                 jb      short loc_15AE
.text$mn:0000159A                 mov     ecx, [ebp+var_4]
.text$mn:0000159D                 mov     edx, [ecx+4]
.text$mn:000015A0                 push    edx
.text$mn:000015A1                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000015A6                 add     esp, 4
.text$mn:000015A9                 mov     [ebp+var_8], eax
.text$mn:000015AC                 jmp     short loc_15B7
.text$mn:000015AE ; ---------------------------------------------------------------------------
.text$mn:000015AE
.text$mn:000015AE loc_15AE:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:000015AE                 mov     eax, [ebp+var_4]
.text$mn:000015B1                 add     eax, 4
.text$mn:000015B4                 mov     [ebp+var_8], eax
.text$mn:000015B7
.text$mn:000015B7 loc_15B7:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000015B7                 mov     eax, [ebp+var_8]
.text$mn:000015BA                 mov     esp, ebp
.text$mn:000015BC                 pop     ebp
.text$mn:000015BD                 retn
.text$mn:000015BD ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:000015BD
.text$mn:000015BD ; ---------------------------------------------------------------------------
.text$mn:000015BE                 align 10h
.text$mn:000015BE _text$mn        ends
.text$mn:000015BE
.text$mn:000015C0 ; ===========================================================================
.text$mn:000015C0
.text$mn:000015C0 ; Segment type: Pure code
.text$mn:000015C0 ; Segment permissions: Read/Execute
.text$mn:000015C0 _text$mn        segment para public 'CODE' use32
.text$mn:000015C0                 assume cs:_text$mn
.text$mn:000015C0                 ;org 15C0h
.text$mn:000015C0 ; COMDAT (pick any)
.text$mn:000015C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000015C0
.text$mn:000015C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000015C0
.text$mn:000015C0 ; Attributes: bp-based frame
.text$mn:000015C0
.text$mn:000015C0 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:000015C0                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:000015C0 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:000015C0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:000015C0
.text$mn:000015C0 var_8           = dword ptr -8
.text$mn:000015C0 var_4           = dword ptr -4
.text$mn:000015C0
.text$mn:000015C0                 push    ebp
.text$mn:000015C1                 mov     ebp, esp
.text$mn:000015C3                 sub     esp, 8
.text$mn:000015C6                 mov     [ebp+var_4], ecx
.text$mn:000015C9                 mov     eax, [ebp+var_4]
.text$mn:000015CC                 cmp     dword ptr [eax+18h], 10h
.text$mn:000015D0                 jb      short loc_15E6
.text$mn:000015D2                 mov     ecx, [ebp+var_4]
.text$mn:000015D5                 mov     edx, [ecx+4]
.text$mn:000015D8                 push    edx
.text$mn:000015D9                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000015DE                 add     esp, 4
.text$mn:000015E1                 mov     [ebp+var_8], eax
.text$mn:000015E4                 jmp     short loc_15EF
.text$mn:000015E6 ; ---------------------------------------------------------------------------
.text$mn:000015E6
.text$mn:000015E6 loc_15E6:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:000015E6                 mov     eax, [ebp+var_4]
.text$mn:000015E9                 add     eax, 4
.text$mn:000015EC                 mov     [ebp+var_8], eax
.text$mn:000015EF
.text$mn:000015EF loc_15EF:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000015EF                 mov     eax, [ebp+var_8]
.text$mn:000015F2                 mov     esp, ebp
.text$mn:000015F4                 pop     ebp
.text$mn:000015F5                 retn
.text$mn:000015F5 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:000015F5
.text$mn:000015F5 ; ---------------------------------------------------------------------------
.text$mn:000015F6                 align 4
.text$mn:000015F6 _text$mn        ends
.text$mn:000015F6
.text$mn:000015F8 ; ===========================================================================
.text$mn:000015F8
.text$mn:000015F8 ; Segment type: Pure code
.text$mn:000015F8 ; Segment permissions: Read/Execute
.text$mn:000015F8 _text$mn        segment para public 'CODE' use32
.text$mn:000015F8                 assume cs:_text$mn
.text$mn:000015F8                 ;org 15F8h
.text$mn:000015F8 ; COMDAT (pick any)
.text$mn:000015F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000015F8
.text$mn:000015F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000015F8
.text$mn:000015F8 ; Attributes: bp-based frame
.text$mn:000015F8
.text$mn:000015F8 ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:000015F8                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:000015F8 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:000015F8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)+Ap
.text$mn:000015F8
.text$mn:000015F8 var_8           = dword ptr -8
.text$mn:000015F8 var_4           = dword ptr -4
.text$mn:000015F8
.text$mn:000015F8                 push    ebp
.text$mn:000015F9                 mov     ebp, esp
.text$mn:000015FB                 sub     esp, 8
.text$mn:000015FE                 mov     [ebp+var_4], ecx
.text$mn:00001601                 mov     eax, [ebp+var_4]
.text$mn:00001604                 cmp     dword ptr [eax+18h], 8
.text$mn:00001608                 jb      short loc_161E
.text$mn:0000160A                 mov     ecx, [ebp+var_4]
.text$mn:0000160D                 mov     edx, [ecx+4]
.text$mn:00001610                 push    edx
.text$mn:00001611                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00001616                 add     esp, 4
.text$mn:00001619                 mov     [ebp+var_8], eax
.text$mn:0000161C                 jmp     short loc_1627
.text$mn:0000161E ; ---------------------------------------------------------------------------
.text$mn:0000161E
.text$mn:0000161E loc_161E:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:0000161E                 mov     eax, [ebp+var_4]
.text$mn:00001621                 add     eax, 4
.text$mn:00001624                 mov     [ebp+var_8], eax
.text$mn:00001627
.text$mn:00001627 loc_1627:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00001627                 mov     eax, [ebp+var_8]
.text$mn:0000162A                 mov     esp, ebp
.text$mn:0000162C                 pop     ebp
.text$mn:0000162D                 retn
.text$mn:0000162D ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:0000162D
.text$mn:0000162D ; ---------------------------------------------------------------------------
.text$mn:0000162E                 align 10h
.text$mn:0000162E _text$mn        ends
.text$mn:0000162E
.text$mn:00001630 ; ===========================================================================
.text$mn:00001630
.text$mn:00001630 ; Segment type: Pure code
.text$mn:00001630 ; Segment permissions: Read/Execute
.text$mn:00001630 _text$mn        segment para public 'CODE' use32
.text$mn:00001630                 assume cs:_text$mn
.text$mn:00001630                 ;org 1630h
.text$mn:00001630 ; COMDAT (pick any)
.text$mn:00001630                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001630
.text$mn:00001630 ; =============== S U B R O U T I N E =======================================
.text$mn:00001630
.text$mn:00001630 ; Attributes: bp-based frame
.text$mn:00001630
.text$mn:00001630 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00001630                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00001630 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00001630                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00001630                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:00001630
.text$mn:00001630 var_18          = byte ptr -18h
.text$mn:00001630 var_14          = dword ptr -14h
.text$mn:00001630 var_10          = dword ptr -10h
.text$mn:00001630 var_C           = dword ptr -0Ch
.text$mn:00001630 var_4           = dword ptr -4
.text$mn:00001630
.text$mn:00001630                 push    ebp
.text$mn:00001631                 mov     ebp, esp
.text$mn:00001633                 push    0FFFFFFFFh
.text$mn:00001635                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:0000163A                 mov     eax, large fs:0
.text$mn:00001640                 push    eax
.text$mn:00001641                 sub     esp, 0Ch
.text$mn:00001644                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001649                 xor     eax, ebp
.text$mn:0000164B                 push    eax
.text$mn:0000164C                 lea     eax, [ebp+var_C]
.text$mn:0000164F                 mov     large fs:0, eax
.text$mn:00001655                 mov     [ebp+var_14], ecx
.text$mn:00001658                 mov     eax, [ebp+var_14]
.text$mn:0000165B                 cmp     dword ptr [eax], 0
.text$mn:0000165E                 jz      short loc_16BB
.text$mn:00001660                 push    3               ; int
.text$mn:00001662                 lea     ecx, [ebp+var_18] ; this
.text$mn:00001665                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000166A                 mov     [ebp+var_4], 0
.text$mn:00001671                 mov     ecx, [ebp+var_14]
.text$mn:00001674                 mov     edx, [ecx]
.text$mn:00001676                 add     edx, 4
.text$mn:00001679                 mov     [ebp+var_10], edx
.text$mn:0000167C                 jmp     short loc_168B
.text$mn:0000167E ; ---------------------------------------------------------------------------
.text$mn:0000167E
.text$mn:0000167E loc_167E:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:0000167E                 mov     eax, [ebp+var_10]
.text$mn:00001681                 mov     ecx, [eax]
.text$mn:00001683                 mov     edx, [ebp+var_10]
.text$mn:00001686                 mov     eax, [ecx+4]
.text$mn:00001689                 mov     [edx], eax
.text$mn:0000168B
.text$mn:0000168B loc_168B:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:0000168B                 mov     ecx, [ebp+var_10]
.text$mn:0000168E                 cmp     dword ptr [ecx], 0
.text$mn:00001691                 jz      short loc_16A0
.text$mn:00001693                 mov     edx, [ebp+var_10]
.text$mn:00001696                 mov     eax, [edx]
.text$mn:00001698                 mov     dword ptr [eax], 0
.text$mn:0000169E                 jmp     short loc_167E
.text$mn:000016A0 ; ---------------------------------------------------------------------------
.text$mn:000016A0
.text$mn:000016A0 loc_16A0:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:000016A0                 mov     ecx, [ebp+var_14]
.text$mn:000016A3                 mov     edx, [ecx]
.text$mn:000016A5                 mov     dword ptr [edx+4], 0
.text$mn:000016AC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000016B3                 lea     ecx, [ebp+var_18] ; this
.text$mn:000016B6                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000016BB
.text$mn:000016BB loc_16BB:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:000016BB                 mov     ecx, [ebp+var_C]
.text$mn:000016BE                 mov     large fs:0, ecx
.text$mn:000016C5                 pop     ecx
.text$mn:000016C6                 mov     esp, ebp
.text$mn:000016C8                 pop     ebp
.text$mn:000016C9                 retn
.text$mn:000016C9 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:000016C9
.text$mn:000016C9 ; ---------------------------------------------------------------------------
.text$mn:000016CA                 align 4
.text$mn:000016CA _text$mn        ends
.text$mn:000016CA
.text$x:000016CC ; ===========================================================================
.text$x:000016CC
.text$x:000016CC ; Segment type: Pure code
.text$x:000016CC ; Segment permissions: Read/Execute
.text$x:000016CC _text$x         segment para public 'CODE' use32
.text$x:000016CC                 assume cs:_text$x
.text$x:000016CC                 ;org 16CCh
.text$x:000016CC ; COMDAT (pick associative to section at 1630)
.text$x:000016CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000016CC
.text$x:000016CC ; =============== S U B R O U T I N E =======================================
.text$x:000016CC
.text$x:000016CC
.text$x:000016CC __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:000016CC                                         ; DATA XREF: .xdata$x:00002018o
.text$x:000016CC                 lea     ecx, [ebp-18h]  ; this
.text$x:000016CF                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000016CF __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:000016CF
.text$x:000016D4
.text$x:000016D4 ; =============== S U B R O U T I N E =======================================
.text$x:000016D4
.text$x:000016D4
.text$x:000016D4 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:000016D4                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:000016D4
.text$x:000016D4 arg_4           = dword ptr  8
.text$x:000016D4
.text$x:000016D4                 mov     edx, [esp+arg_4]
.text$x:000016D8                 lea     eax, [edx+0Ch]
.text$x:000016DB                 mov     ecx, [edx-10h]
.text$x:000016DE                 xor     ecx, eax
.text$x:000016E0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000016E5                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:000016EA                 jmp     ___CxxFrameHandler3
.text$x:000016EA __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:000016EA
.text$x:000016EA ; ---------------------------------------------------------------------------
.text$x:000016EF                 align 10h
.text$x:000016EF _text$x         ends
.text$x:000016EF
.text$mn:000016F0 ; ===========================================================================
.text$mn:000016F0
.text$mn:000016F0 ; Segment type: Pure code
.text$mn:000016F0 ; Segment permissions: Read/Execute
.text$mn:000016F0 _text$mn        segment para public 'CODE' use32
.text$mn:000016F0                 assume cs:_text$mn
.text$mn:000016F0                 ;org 16F0h
.text$mn:000016F0 ; COMDAT (pick any)
.text$mn:000016F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016F0
.text$mn:000016F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000016F0
.text$mn:000016F0 ; Attributes: bp-based frame
.text$mn:000016F0
.text$mn:000016F0 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:000016F0                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:000016F0 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:000016F0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:000016F0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:000016F0
.text$mn:000016F0 var_C           = dword ptr -0Ch
.text$mn:000016F0 var_8           = dword ptr -8
.text$mn:000016F0 var_2           = byte ptr -2
.text$mn:000016F0 var_1           = byte ptr -1
.text$mn:000016F0 arg_0           = byte ptr  8
.text$mn:000016F0 Size            = dword ptr  0Ch
.text$mn:000016F0
.text$mn:000016F0                 push    ebp
.text$mn:000016F1                 mov     ebp, esp
.text$mn:000016F3                 sub     esp, 0Ch
.text$mn:000016F6                 mov     [ebp+var_8], ecx
.text$mn:000016F9                 movzx   eax, [ebp+arg_0]
.text$mn:000016FD                 test    eax, eax
.text$mn:000016FF                 jnz     short loc_1703
.text$mn:00001701                 jmp     short loc_1776
.text$mn:00001703 ; ---------------------------------------------------------------------------
.text$mn:00001703
.text$mn:00001703 loc_1703:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00001703                 mov     ecx, [ebp+var_8]
.text$mn:00001706                 cmp     dword ptr [ecx+18h], 10h
.text$mn:0000170A                 jb      short loc_1776
.text$mn:0000170C                 mov     edx, [ebp+var_8]
.text$mn:0000170F                 mov     eax, [edx+4]
.text$mn:00001712                 mov     [ebp+var_C], eax
.text$mn:00001715                 mov     ecx, [ebp+var_8]
.text$mn:00001718                 add     ecx, 4
.text$mn:0000171B                 push    ecx
.text$mn:0000171C                 lea     edx, [ebp+var_1]
.text$mn:0000171F                 push    edx
.text$mn:00001720                 mov     ecx, [ebp+var_8]
.text$mn:00001723                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001728                 mov     ecx, eax
.text$mn:0000172A                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:0000172F                 cmp     [ebp+Size], 0
.text$mn:00001733                 jbe     short loc_1755
.text$mn:00001735                 mov     eax, [ebp+Size]
.text$mn:00001738                 push    eax             ; Size
.text$mn:00001739                 mov     ecx, [ebp+var_C]
.text$mn:0000173C                 push    ecx
.text$mn:0000173D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001742                 add     esp, 4
.text$mn:00001745                 push    eax             ; Src
.text$mn:00001746                 mov     edx, [ebp+var_8]
.text$mn:00001749                 add     edx, 4
.text$mn:0000174C                 push    edx             ; Dst
.text$mn:0000174D                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001752                 add     esp, 0Ch
.text$mn:00001755
.text$mn:00001755 loc_1755:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00001755                 mov     eax, [ebp+var_8]
.text$mn:00001758                 mov     ecx, [eax+18h]
.text$mn:0000175B                 add     ecx, 1
.text$mn:0000175E                 push    ecx             ; int
.text$mn:0000175F                 mov     edx, [ebp+var_C]
.text$mn:00001762                 push    edx             ; void *
.text$mn:00001763                 lea     eax, [ebp+var_2]
.text$mn:00001766                 push    eax
.text$mn:00001767                 mov     ecx, [ebp+var_8]
.text$mn:0000176A                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000176F                 mov     ecx, eax
.text$mn:00001771                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:00001776
.text$mn:00001776 loc_1776:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:00001776                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:00001776                 mov     ecx, [ebp+var_8]
.text$mn:00001779                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00001780                 mov     edx, [ebp+Size]
.text$mn:00001783                 push    edx
.text$mn:00001784                 mov     ecx, [ebp+var_8]
.text$mn:00001787                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000178C                 mov     esp, ebp
.text$mn:0000178E                 pop     ebp
.text$mn:0000178F                 retn    8
.text$mn:0000178F ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:0000178F
.text$mn:0000178F ; ---------------------------------------------------------------------------
.text$mn:00001792                 align 4
.text$mn:00001792 _text$mn        ends
.text$mn:00001792
.text$mn:00001794 ; ===========================================================================
.text$mn:00001794
.text$mn:00001794 ; Segment type: Pure code
.text$mn:00001794 ; Segment permissions: Read/Execute
.text$mn:00001794 _text$mn        segment para public 'CODE' use32
.text$mn:00001794                 assume cs:_text$mn
.text$mn:00001794                 ;org 1794h
.text$mn:00001794 ; COMDAT (pick any)
.text$mn:00001794                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001794
.text$mn:00001794 ; =============== S U B R O U T I N E =======================================
.text$mn:00001794
.text$mn:00001794 ; Attributes: bp-based frame
.text$mn:00001794
.text$mn:00001794 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00001794                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00001794 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00001794                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00001794
.text$mn:00001794 var_4           = dword ptr -4
.text$mn:00001794
.text$mn:00001794                 push    ebp
.text$mn:00001795                 mov     ebp, esp
.text$mn:00001797                 push    ecx
.text$mn:00001798                 mov     [ebp+var_4], ecx
.text$mn:0000179B                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:000017A0                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000017A5                 mov     esp, ebp
.text$mn:000017A7                 pop     ebp
.text$mn:000017A8                 retn
.text$mn:000017A8 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000017A8
.text$mn:000017A8 ; ---------------------------------------------------------------------------
.text$mn:000017A9                 align 4
.text$mn:000017A9 _text$mn        ends
.text$mn:000017A9
.text$mn:000017AC ; ===========================================================================
.text$mn:000017AC
.text$mn:000017AC ; Segment type: Pure code
.text$mn:000017AC ; Segment permissions: Read/Execute
.text$mn:000017AC _text$mn        segment para public 'CODE' use32
.text$mn:000017AC                 assume cs:_text$mn
.text$mn:000017AC                 ;org 17ACh
.text$mn:000017AC ; COMDAT (pick any)
.text$mn:000017AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000017AC
.text$mn:000017AC ; =============== S U B R O U T I N E =======================================
.text$mn:000017AC
.text$mn:000017AC ; Attributes: bp-based frame
.text$mn:000017AC
.text$mn:000017AC ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:000017AC                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000017AC ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000017AC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:000017AC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:000017AC
.text$mn:000017AC var_4           = dword ptr -4
.text$mn:000017AC
.text$mn:000017AC                 push    ebp
.text$mn:000017AD                 mov     ebp, esp
.text$mn:000017AF                 push    ecx
.text$mn:000017B0                 mov     [ebp+var_4], ecx
.text$mn:000017B3                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:000017B8                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:000017BD                 mov     esp, ebp
.text$mn:000017BF                 pop     ebp
.text$mn:000017C0                 retn
.text$mn:000017C0 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000017C0
.text$mn:000017C0 ; ---------------------------------------------------------------------------
.text$mn:000017C1                 align 4
.text$mn:000017C1 _text$mn        ends
.text$mn:000017C1
.text$mn:000017C4 ; ===========================================================================
.text$mn:000017C4
.text$mn:000017C4 ; Segment type: Pure code
.text$mn:000017C4 ; Segment permissions: Read/Execute
.text$mn:000017C4 _text$mn        segment para public 'CODE' use32
.text$mn:000017C4                 assume cs:_text$mn
.text$mn:000017C4                 ;org 17C4h
.text$mn:000017C4 ; COMDAT (pick any)
.text$mn:000017C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000017C4
.text$mn:000017C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000017C4
.text$mn:000017C4 ; Attributes: bp-based frame
.text$mn:000017C4
.text$mn:000017C4 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:000017C4                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:000017C4 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:000017C4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:000017C4                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:000017C4
.text$mn:000017C4 var_4           = dword ptr -4
.text$mn:000017C4 arg_0           = dword ptr  8
.text$mn:000017C4
.text$mn:000017C4                 push    ebp
.text$mn:000017C5                 mov     ebp, esp
.text$mn:000017C7                 push    ecx
.text$mn:000017C8                 mov     [ebp+var_4], ecx
.text$mn:000017CB                 mov     eax, [ebp+arg_0]
.text$mn:000017CE                 push    eax
.text$mn:000017CF                 mov     ecx, [ebp+var_4]
.text$mn:000017D2                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:000017D7                 mov     esp, ebp
.text$mn:000017D9                 pop     ebp
.text$mn:000017DA                 retn    4
.text$mn:000017DA ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:000017DA
.text$mn:000017DA ; ---------------------------------------------------------------------------
.text$mn:000017DD                 align 10h
.text$mn:000017DD _text$mn        ends
.text$mn:000017DD
.text$mn:000017E0 ; ===========================================================================
.text$mn:000017E0
.text$mn:000017E0 ; Segment type: Pure code
.text$mn:000017E0 ; Segment permissions: Read/Execute
.text$mn:000017E0 _text$mn        segment para public 'CODE' use32
.text$mn:000017E0                 assume cs:_text$mn
.text$mn:000017E0                 ;org 17E0h
.text$mn:000017E0 ; COMDAT (pick any)
.text$mn:000017E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000017E0
.text$mn:000017E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000017E0
.text$mn:000017E0 ; Attributes: bp-based frame
.text$mn:000017E0
.text$mn:000017E0 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:000017E0                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:000017E0 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:000017E0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:000017E0
.text$mn:000017E0 var_4           = dword ptr -4
.text$mn:000017E0 arg_0           = dword ptr  8
.text$mn:000017E0
.text$mn:000017E0                 push    ebp
.text$mn:000017E1                 mov     ebp, esp
.text$mn:000017E3                 push    ecx
.text$mn:000017E4                 mov     [ebp+var_4], ecx
.text$mn:000017E7                 push    0
.text$mn:000017E9                 mov     eax, [ebp+arg_0]
.text$mn:000017EC                 push    eax
.text$mn:000017ED                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:000017F2                 add     esp, 8
.text$mn:000017F5                 mov     esp, ebp
.text$mn:000017F7                 pop     ebp
.text$mn:000017F8                 retn    4
.text$mn:000017F8 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:000017F8
.text$mn:000017F8 ; ---------------------------------------------------------------------------
.text$mn:000017FB                 align 4
.text$mn:000017FB _text$mn        ends
.text$mn:000017FB
.text$mn:000017FC ; ===========================================================================
.text$mn:000017FC
.text$mn:000017FC ; Segment type: Pure code
.text$mn:000017FC ; Segment permissions: Read/Execute
.text$mn:000017FC _text$mn        segment para public 'CODE' use32
.text$mn:000017FC                 assume cs:_text$mn
.text$mn:000017FC                 ;org 17FCh
.text$mn:000017FC ; COMDAT (pick any)
.text$mn:000017FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000017FC
.text$mn:000017FC ; =============== S U B R O U T I N E =======================================
.text$mn:000017FC
.text$mn:000017FC ; Attributes: bp-based frame
.text$mn:000017FC
.text$mn:000017FC ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:000017FC                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:000017FC ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:000017FC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:000017FC
.text$mn:000017FC var_4           = dword ptr -4
.text$mn:000017FC arg_0           = dword ptr  8
.text$mn:000017FC
.text$mn:000017FC                 push    ebp
.text$mn:000017FD                 mov     ebp, esp
.text$mn:000017FF                 push    ecx
.text$mn:00001800                 mov     [ebp+var_4], ecx
.text$mn:00001803                 push    0
.text$mn:00001805                 mov     eax, [ebp+arg_0]
.text$mn:00001808                 push    eax
.text$mn:00001809                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:0000180E                 add     esp, 8
.text$mn:00001811                 mov     esp, ebp
.text$mn:00001813                 pop     ebp
.text$mn:00001814                 retn    4
.text$mn:00001814 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00001814
.text$mn:00001814 ; ---------------------------------------------------------------------------
.text$mn:00001817                 align 4
.text$mn:00001817 _text$mn        ends
.text$mn:00001817
.text$mn:00001818 ; ===========================================================================
.text$mn:00001818
.text$mn:00001818 ; Segment type: Pure code
.text$mn:00001818 ; Segment permissions: Read/Execute
.text$mn:00001818 _text$mn        segment para public 'CODE' use32
.text$mn:00001818                 assume cs:_text$mn
.text$mn:00001818                 ;org 1818h
.text$mn:00001818 ; COMDAT (pick any)
.text$mn:00001818                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001818
.text$mn:00001818 ; =============== S U B R O U T I N E =======================================
.text$mn:00001818
.text$mn:00001818 ; Attributes: bp-based frame
.text$mn:00001818
.text$mn:00001818 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00001818                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00001818 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00001818                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00001818
.text$mn:00001818 Size            = dword ptr -8
.text$mn:00001818 var_4           = dword ptr -4
.text$mn:00001818 arg_0           = dword ptr  8
.text$mn:00001818 arg_4           = dword ptr  0Ch
.text$mn:00001818 arg_8           = dword ptr  10h
.text$mn:00001818
.text$mn:00001818                 push    ebp
.text$mn:00001819                 mov     ebp, esp
.text$mn:0000181B                 sub     esp, 8
.text$mn:0000181E                 mov     [ebp+var_4], ecx
.text$mn:00001821                 mov     ecx, [ebp+arg_0]
.text$mn:00001824                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00001829                 cmp     eax, [ebp+arg_4]
.text$mn:0000182C                 jnb     short loc_1836
.text$mn:0000182E                 mov     ecx, [ebp+var_4]
.text$mn:00001831                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001836
.text$mn:00001836 loc_1836:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00001836                 mov     ecx, [ebp+arg_0]
.text$mn:00001839                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000183E                 sub     eax, [ebp+arg_4]
.text$mn:00001841                 mov     [ebp+Size], eax
.text$mn:00001844                 mov     eax, [ebp+arg_8]
.text$mn:00001847                 cmp     eax, [ebp+Size]
.text$mn:0000184A                 jnb     short loc_1852
.text$mn:0000184C                 mov     ecx, [ebp+arg_8]
.text$mn:0000184F                 mov     [ebp+Size], ecx
.text$mn:00001852
.text$mn:00001852 loc_1852:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00001852                 mov     edx, [ebp+var_4]
.text$mn:00001855                 cmp     edx, [ebp+arg_0]
.text$mn:00001858                 jnz     short loc_1879
.text$mn:0000185A                 mov     eax, [ebp+arg_4]
.text$mn:0000185D                 add     eax, [ebp+Size]
.text$mn:00001860                 push    eax
.text$mn:00001861                 mov     ecx, [ebp+var_4]
.text$mn:00001864                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00001869                 mov     ecx, [ebp+arg_4]
.text$mn:0000186C                 push    ecx
.text$mn:0000186D                 push    0
.text$mn:0000186F                 mov     ecx, [ebp+var_4]
.text$mn:00001872                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00001877                 jmp     short loc_18BB
.text$mn:00001879 ; ---------------------------------------------------------------------------
.text$mn:00001879
.text$mn:00001879 loc_1879:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00001879                 push    0
.text$mn:0000187B                 mov     edx, [ebp+Size]
.text$mn:0000187E                 push    edx
.text$mn:0000187F                 mov     ecx, [ebp+var_4]
.text$mn:00001882                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00001887                 movzx   eax, al
.text$mn:0000188A                 test    eax, eax
.text$mn:0000188C                 jz      short loc_18BB
.text$mn:0000188E                 mov     ecx, [ebp+Size]
.text$mn:00001891                 push    ecx             ; Size
.text$mn:00001892                 mov     ecx, [ebp+arg_0]
.text$mn:00001895                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000189A                 add     eax, [ebp+arg_4]
.text$mn:0000189D                 push    eax             ; Src
.text$mn:0000189E                 mov     ecx, [ebp+var_4]
.text$mn:000018A1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000018A6                 push    eax             ; Dst
.text$mn:000018A7                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000018AC                 add     esp, 0Ch
.text$mn:000018AF                 mov     edx, [ebp+Size]
.text$mn:000018B2                 push    edx
.text$mn:000018B3                 mov     ecx, [ebp+var_4]
.text$mn:000018B6                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000018BB
.text$mn:000018BB loc_18BB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:000018BB                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:000018BB                 mov     eax, [ebp+var_4]
.text$mn:000018BE                 mov     esp, ebp
.text$mn:000018C0                 pop     ebp
.text$mn:000018C1                 retn    0Ch
.text$mn:000018C1 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:000018C1
.text$mn:000018C1 _text$mn        ends
.text$mn:000018C1
.text$mn:000018C4 ; ===========================================================================
.text$mn:000018C4
.text$mn:000018C4 ; Segment type: Pure code
.text$mn:000018C4 ; Segment permissions: Read/Execute
.text$mn:000018C4 _text$mn        segment para public 'CODE' use32
.text$mn:000018C4                 assume cs:_text$mn
.text$mn:000018C4                 ;org 18C4h
.text$mn:000018C4 ; COMDAT (pick any)
.text$mn:000018C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000018C4
.text$mn:000018C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000018C4
.text$mn:000018C4 ; Attributes: bp-based frame
.text$mn:000018C4
.text$mn:000018C4 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:000018C4                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:000018C4 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:000018C4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:000018C4
.text$mn:000018C4 var_4           = dword ptr -4
.text$mn:000018C4 Str             = dword ptr  8
.text$mn:000018C4
.text$mn:000018C4                 push    ebp
.text$mn:000018C5                 mov     ebp, esp
.text$mn:000018C7                 push    ecx
.text$mn:000018C8                 mov     [ebp+var_4], ecx
.text$mn:000018CB                 push    490h            ; unsigned int
.text$mn:000018D0                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000018D5                 mov     eax, [ebp+Str]
.text$mn:000018D8                 push    eax             ; int
.text$mn:000018D9                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:000018DE                 add     esp, 0Ch
.text$mn:000018E1                 mov     ecx, [ebp+Str]
.text$mn:000018E4                 push    ecx             ; Str
.text$mn:000018E5                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:000018EA                 add     esp, 4
.text$mn:000018ED                 push    eax             ; Size
.text$mn:000018EE                 mov     edx, [ebp+Str]
.text$mn:000018F1                 push    edx             ; Src
.text$mn:000018F2                 mov     ecx, [ebp+var_4]
.text$mn:000018F5                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:000018FA                 mov     esp, ebp
.text$mn:000018FC                 pop     ebp
.text$mn:000018FD                 retn    4
.text$mn:000018FD ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:000018FD
.text$mn:000018FD _text$mn        ends
.text$mn:000018FD
.text$mn:00001900 ; ===========================================================================
.text$mn:00001900
.text$mn:00001900 ; Segment type: Pure code
.text$mn:00001900 ; Segment permissions: Read/Execute
.text$mn:00001900 _text$mn        segment para public 'CODE' use32
.text$mn:00001900                 assume cs:_text$mn
.text$mn:00001900                 ;org 1900h
.text$mn:00001900 ; COMDAT (pick any)
.text$mn:00001900                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001900
.text$mn:00001900 ; =============== S U B R O U T I N E =======================================
.text$mn:00001900
.text$mn:00001900 ; Attributes: bp-based frame
.text$mn:00001900
.text$mn:00001900 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00001900                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00001900 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00001900                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00001900
.text$mn:00001900 var_4           = dword ptr -4
.text$mn:00001900 Src             = dword ptr  8
.text$mn:00001900 Size            = dword ptr  0Ch
.text$mn:00001900
.text$mn:00001900                 push    ebp
.text$mn:00001901                 mov     ebp, esp
.text$mn:00001903                 push    ecx
.text$mn:00001904                 mov     [ebp+var_4], ecx
.text$mn:00001907                 cmp     [ebp+Size], 0
.text$mn:0000190B                 jz      short loc_1923
.text$mn:0000190D                 push    47Fh            ; unsigned int
.text$mn:00001912                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001917                 mov     eax, [ebp+Src]
.text$mn:0000191A                 push    eax             ; int
.text$mn:0000191B                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001920                 add     esp, 0Ch
.text$mn:00001923
.text$mn:00001923 loc_1923:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00001923                 mov     ecx, [ebp+Src]
.text$mn:00001926                 push    ecx
.text$mn:00001927                 mov     ecx, [ebp+var_4]
.text$mn:0000192A                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:0000192F                 movzx   edx, al
.text$mn:00001932                 test    edx, edx
.text$mn:00001934                 jz      short loc_1956
.text$mn:00001936                 mov     eax, [ebp+Size]
.text$mn:00001939                 push    eax
.text$mn:0000193A                 mov     ecx, [ebp+var_4]
.text$mn:0000193D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001942                 mov     ecx, [ebp+Src]
.text$mn:00001945                 sub     ecx, eax
.text$mn:00001947                 push    ecx
.text$mn:00001948                 mov     edx, [ebp+var_4]
.text$mn:0000194B                 push    edx
.text$mn:0000194C                 mov     ecx, [ebp+var_4]
.text$mn:0000194F                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00001954                 jmp     short loc_1993
.text$mn:00001956 ; ---------------------------------------------------------------------------
.text$mn:00001956
.text$mn:00001956 loc_1956:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00001956                 push    0
.text$mn:00001958                 mov     eax, [ebp+Size]
.text$mn:0000195B                 push    eax
.text$mn:0000195C                 mov     ecx, [ebp+var_4]
.text$mn:0000195F                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00001964                 movzx   ecx, al
.text$mn:00001967                 test    ecx, ecx
.text$mn:00001969                 jz      short loc_1990
.text$mn:0000196B                 mov     edx, [ebp+Size]
.text$mn:0000196E                 push    edx             ; Size
.text$mn:0000196F                 mov     eax, [ebp+Src]
.text$mn:00001972                 push    eax             ; Src
.text$mn:00001973                 mov     ecx, [ebp+var_4]
.text$mn:00001976                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000197B                 push    eax             ; Dst
.text$mn:0000197C                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001981                 add     esp, 0Ch
.text$mn:00001984                 mov     ecx, [ebp+Size]
.text$mn:00001987                 push    ecx
.text$mn:00001988                 mov     ecx, [ebp+var_4]
.text$mn:0000198B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001990
.text$mn:00001990 loc_1990:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00001990                 mov     eax, [ebp+var_4]
.text$mn:00001993
.text$mn:00001993 loc_1993:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:00001993                 mov     esp, ebp
.text$mn:00001995                 pop     ebp
.text$mn:00001996                 retn    8
.text$mn:00001996 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00001996
.text$mn:00001996 ; ---------------------------------------------------------------------------
.text$mn:00001999                 align 4
.text$mn:00001999 _text$mn        ends
.text$mn:00001999
.text$mn:0000199C ; ===========================================================================
.text$mn:0000199C
.text$mn:0000199C ; Segment type: Pure code
.text$mn:0000199C ; Segment permissions: Read/Execute
.text$mn:0000199C _text$mn        segment para public 'CODE' use32
.text$mn:0000199C                 assume cs:_text$mn
.text$mn:0000199C                 ;org 199Ch
.text$mn:0000199C ; COMDAT (pick any)
.text$mn:0000199C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000199C
.text$mn:0000199C ; =============== S U B R O U T I N E =======================================
.text$mn:0000199C
.text$mn:0000199C ; Attributes: bp-based frame
.text$mn:0000199C
.text$mn:0000199C ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:0000199C                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:0000199C ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:0000199C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:0000199C
.text$mn:0000199C arg_0           = dword ptr  8
.text$mn:0000199C arg_4           = dword ptr  0Ch
.text$mn:0000199C
.text$mn:0000199C                 push    ebp
.text$mn:0000199D                 mov     ebp, esp
.text$mn:0000199F                 mov     eax, [ebp+arg_0]
.text$mn:000019A2                 mov     ecx, [ebp+arg_4]
.text$mn:000019A5                 mov     dl, [ecx]
.text$mn:000019A7                 mov     [eax], dl
.text$mn:000019A9                 pop     ebp
.text$mn:000019AA                 retn
.text$mn:000019AA ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:000019AA
.text$mn:000019AA ; ---------------------------------------------------------------------------
.text$mn:000019AB                 align 4
.text$mn:000019AB _text$mn        ends
.text$mn:000019AB
.text$mn:000019AC ; ===========================================================================
.text$mn:000019AC
.text$mn:000019AC ; Segment type: Pure code
.text$mn:000019AC ; Segment permissions: Read/Execute
.text$mn:000019AC _text$mn        segment para public 'CODE' use32
.text$mn:000019AC                 assume cs:_text$mn
.text$mn:000019AC                 ;org 19ACh
.text$mn:000019AC ; COMDAT (pick any)
.text$mn:000019AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019AC
.text$mn:000019AC ; =============== S U B R O U T I N E =======================================
.text$mn:000019AC
.text$mn:000019AC ; Attributes: bp-based frame
.text$mn:000019AC
.text$mn:000019AC ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:000019AC                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:000019AC ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:000019AC                                         ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+255p
.text$mn:000019AC                                         ; TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+56p
.text$mn:000019AC
.text$mn:000019AC var_4           = dword ptr -4
.text$mn:000019AC
.text$mn:000019AC                 push    ebp
.text$mn:000019AD                 mov     ebp, esp
.text$mn:000019AF                 push    ecx
.text$mn:000019B0                 mov     [ebp+var_4], ecx
.text$mn:000019B3                 mov     ecx, [ebp+var_4]
.text$mn:000019B6                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000019BB                 mov     esp, ebp
.text$mn:000019BD                 pop     ebp
.text$mn:000019BE                 retn
.text$mn:000019BE ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:000019BE
.text$mn:000019BE ; ---------------------------------------------------------------------------
.text$mn:000019BF                 align 10h
.text$mn:000019BF _text$mn        ends
.text$mn:000019BF
.text$mn:000019C0 ; ===========================================================================
.text$mn:000019C0
.text$mn:000019C0 ; Segment type: Pure code
.text$mn:000019C0 ; Segment permissions: Read/Execute
.text$mn:000019C0 _text$mn        segment para public 'CODE' use32
.text$mn:000019C0                 assume cs:_text$mn
.text$mn:000019C0                 ;org 19C0h
.text$mn:000019C0 ; COMDAT (pick any)
.text$mn:000019C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019C0
.text$mn:000019C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000019C0
.text$mn:000019C0 ; Attributes: bp-based frame
.text$mn:000019C0
.text$mn:000019C0 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:000019C0                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:000019C0 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000019C0                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:000019C0
.text$mn:000019C0 var_4           = dword ptr -4
.text$mn:000019C0
.text$mn:000019C0                 push    ebp
.text$mn:000019C1                 mov     ebp, esp
.text$mn:000019C3                 push    ecx
.text$mn:000019C4                 mov     [ebp+var_4], ecx
.text$mn:000019C7                 mov     eax, [ebp+var_4]
.text$mn:000019CA                 mov     eax, [eax+4]
.text$mn:000019CD                 mov     esp, ebp
.text$mn:000019CF                 pop     ebp
.text$mn:000019D0                 retn
.text$mn:000019D0 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:000019D0
.text$mn:000019D0 ; ---------------------------------------------------------------------------
.text$mn:000019D1                 align 4
.text$mn:000019D1 _text$mn        ends
.text$mn:000019D1
.text$mn:000019D4 ; ===========================================================================
.text$mn:000019D4
.text$mn:000019D4 ; Segment type: Pure code
.text$mn:000019D4 ; Segment permissions: Read/Execute
.text$mn:000019D4 _text$mn        segment para public 'CODE' use32
.text$mn:000019D4                 assume cs:_text$mn
.text$mn:000019D4                 ;org 19D4h
.text$mn:000019D4 ; COMDAT (pick any)
.text$mn:000019D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019D4
.text$mn:000019D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000019D4
.text$mn:000019D4 ; Attributes: bp-based frame
.text$mn:000019D4
.text$mn:000019D4 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:000019D4                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:000019D4 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000019D4                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:000019D4                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:000019D4
.text$mn:000019D4 var_4           = dword ptr -4
.text$mn:000019D4
.text$mn:000019D4                 push    ebp
.text$mn:000019D5                 mov     ebp, esp
.text$mn:000019D7                 push    ecx
.text$mn:000019D8                 mov     [ebp+var_4], ecx
.text$mn:000019DB                 mov     eax, [ebp+var_4]
.text$mn:000019DE                 mov     eax, [eax+4]
.text$mn:000019E1                 mov     esp, ebp
.text$mn:000019E3                 pop     ebp
.text$mn:000019E4                 retn
.text$mn:000019E4 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:000019E4
.text$mn:000019E4 ; ---------------------------------------------------------------------------
.text$mn:000019E5                 align 4
.text$mn:000019E5 _text$mn        ends
.text$mn:000019E5
.text$mn:000019E8 ; ===========================================================================
.text$mn:000019E8
.text$mn:000019E8 ; Segment type: Pure code
.text$mn:000019E8 ; Segment permissions: Read/Execute
.text$mn:000019E8 _text$mn        segment para public 'CODE' use32
.text$mn:000019E8                 assume cs:_text$mn
.text$mn:000019E8                 ;org 19E8h
.text$mn:000019E8 ; COMDAT (pick any)
.text$mn:000019E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019E8
.text$mn:000019E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000019E8
.text$mn:000019E8 ; Attributes: bp-based frame
.text$mn:000019E8
.text$mn:000019E8 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:000019E8                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000019E8 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:000019E8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:000019E8
.text$mn:000019E8 var_4           = dword ptr -4
.text$mn:000019E8 Dst             = dword ptr  8
.text$mn:000019E8 Src             = dword ptr  0Ch
.text$mn:000019E8 Size            = dword ptr  10h
.text$mn:000019E8
.text$mn:000019E8                 push    ebp
.text$mn:000019E9                 mov     ebp, esp
.text$mn:000019EB                 push    ecx
.text$mn:000019EC                 cmp     [ebp+Size], 0
.text$mn:000019F0                 jnz     short loc_19FA
.text$mn:000019F2                 mov     eax, [ebp+Dst]
.text$mn:000019F5                 mov     [ebp+var_4], eax
.text$mn:000019F8                 jmp     short loc_1A11
.text$mn:000019FA ; ---------------------------------------------------------------------------
.text$mn:000019FA
.text$mn:000019FA loc_19FA:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:000019FA                 mov     ecx, [ebp+Size]
.text$mn:000019FD                 push    ecx             ; Size
.text$mn:000019FE                 mov     edx, [ebp+Src]
.text$mn:00001A01                 push    edx             ; Src
.text$mn:00001A02                 mov     eax, [ebp+Dst]
.text$mn:00001A05                 push    eax             ; Dst
.text$mn:00001A06                 call    _memcpy
.text$mn:00001A0B                 add     esp, 0Ch
.text$mn:00001A0E                 mov     [ebp+var_4], eax
.text$mn:00001A11
.text$mn:00001A11 loc_1A11:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00001A11                 mov     eax, [ebp+var_4]
.text$mn:00001A14                 mov     esp, ebp
.text$mn:00001A16                 pop     ebp
.text$mn:00001A17                 retn
.text$mn:00001A17 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00001A17
.text$mn:00001A17 _text$mn        ends
.text$mn:00001A17
.text$mn:00001A18 ; ===========================================================================
.text$mn:00001A18
.text$mn:00001A18 ; Segment type: Pure code
.text$mn:00001A18 ; Segment permissions: Read/Execute
.text$mn:00001A18 _text$mn        segment para public 'CODE' use32
.text$mn:00001A18                 assume cs:_text$mn
.text$mn:00001A18                 ;org 1A18h
.text$mn:00001A18 ; COMDAT (pick any)
.text$mn:00001A18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A18
.text$mn:00001A18 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A18
.text$mn:00001A18 ; Attributes: bp-based frame
.text$mn:00001A18
.text$mn:00001A18 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00001A18                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00001A18 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00001A18                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00001A18
.text$mn:00001A18 var_4           = dword ptr -4
.text$mn:00001A18 arg_0           = dword ptr  8
.text$mn:00001A18 arg_4           = dword ptr  0Ch
.text$mn:00001A18
.text$mn:00001A18                 push    ebp
.text$mn:00001A19                 mov     ebp, esp
.text$mn:00001A1B                 push    ecx
.text$mn:00001A1C                 mov     [ebp+var_4], ecx
.text$mn:00001A1F                 mov     eax, [ebp+arg_4]
.text$mn:00001A22                 push    eax             ; int
.text$mn:00001A23                 mov     ecx, [ebp+arg_0]
.text$mn:00001A26                 push    ecx             ; void *
.text$mn:00001A27                 mov     ecx, [ebp+var_4]
.text$mn:00001A2A                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00001A2F                 mov     esp, ebp
.text$mn:00001A31                 pop     ebp
.text$mn:00001A32                 retn    8
.text$mn:00001A32 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:00001A32
.text$mn:00001A32 ; ---------------------------------------------------------------------------
.text$mn:00001A35                 align 4
.text$mn:00001A35 _text$mn        ends
.text$mn:00001A35
.text$mn:00001A38 ; ===========================================================================
.text$mn:00001A38
.text$mn:00001A38 ; Segment type: Pure code
.text$mn:00001A38 ; Segment permissions: Read/Execute
.text$mn:00001A38 _text$mn        segment para public 'CODE' use32
.text$mn:00001A38                 assume cs:_text$mn
.text$mn:00001A38                 ;org 1A38h
.text$mn:00001A38 ; COMDAT (pick any)
.text$mn:00001A38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A38
.text$mn:00001A38 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A38
.text$mn:00001A38 ; Attributes: bp-based frame
.text$mn:00001A38
.text$mn:00001A38 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00001A38                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00001A38 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00001A38                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00001A38
.text$mn:00001A38 var_4           = dword ptr -4
.text$mn:00001A38 arg_0           = dword ptr  8
.text$mn:00001A38
.text$mn:00001A38                 push    ebp
.text$mn:00001A39                 mov     ebp, esp
.text$mn:00001A3B                 push    ecx
.text$mn:00001A3C                 mov     [ebp+var_4], ecx
.text$mn:00001A3F                 mov     eax, [ebp+arg_0]
.text$mn:00001A42                 push    eax             ; void *
.text$mn:00001A43                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001A48                 add     esp, 4
.text$mn:00001A4B                 mov     esp, ebp
.text$mn:00001A4D                 pop     ebp
.text$mn:00001A4E                 retn    8
.text$mn:00001A4E ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:00001A4E
.text$mn:00001A4E ; ---------------------------------------------------------------------------
.text$mn:00001A51                 align 4
.text$mn:00001A51 _text$mn        ends
.text$mn:00001A51
.text$mn:00001A54 ; ===========================================================================
.text$mn:00001A54
.text$mn:00001A54 ; Segment type: Pure code
.text$mn:00001A54 ; Segment permissions: Read/Execute
.text$mn:00001A54 _text$mn        segment para public 'CODE' use32
.text$mn:00001A54                 assume cs:_text$mn
.text$mn:00001A54                 ;org 1A54h
.text$mn:00001A54 ; COMDAT (pick any)
.text$mn:00001A54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A54
.text$mn:00001A54 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A54
.text$mn:00001A54 ; Attributes: bp-based frame
.text$mn:00001A54
.text$mn:00001A54 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00001A54                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00001A54 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00001A54                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00001A54
.text$mn:00001A54 var_4           = dword ptr -4
.text$mn:00001A54 arg_0           = dword ptr  8
.text$mn:00001A54
.text$mn:00001A54                 push    ebp
.text$mn:00001A55                 mov     ebp, esp
.text$mn:00001A57                 push    ecx
.text$mn:00001A58                 mov     [ebp+var_4], ecx
.text$mn:00001A5B                 mov     eax, [ebp+arg_0]
.text$mn:00001A5E                 push    eax             ; void *
.text$mn:00001A5F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001A64                 add     esp, 4
.text$mn:00001A67                 mov     esp, ebp
.text$mn:00001A69                 pop     ebp
.text$mn:00001A6A                 retn    8
.text$mn:00001A6A ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00001A6A
.text$mn:00001A6A ; ---------------------------------------------------------------------------
.text$mn:00001A6D                 align 10h
.text$mn:00001A6D _text$mn        ends
.text$mn:00001A6D
.text$mn:00001A70 ; ===========================================================================
.text$mn:00001A70
.text$mn:00001A70 ; Segment type: Pure code
.text$mn:00001A70 ; Segment permissions: Read/Execute
.text$mn:00001A70 _text$mn        segment para public 'CODE' use32
.text$mn:00001A70                 assume cs:_text$mn
.text$mn:00001A70                 ;org 1A70h
.text$mn:00001A70 ; COMDAT (pick any)
.text$mn:00001A70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A70
.text$mn:00001A70 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A70
.text$mn:00001A70 ; Attributes: bp-based frame
.text$mn:00001A70
.text$mn:00001A70 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00001A70                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00001A70 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00001A70                                         ; DATA XREF: .rdata:00002458o
.text$mn:00001A70
.text$mn:00001A70 var_4           = dword ptr -4
.text$mn:00001A70 arg_0           = dword ptr  8
.text$mn:00001A70 arg_4           = dword ptr  0Ch
.text$mn:00001A70
.text$mn:00001A70                 push    ebp
.text$mn:00001A71                 mov     ebp, esp
.text$mn:00001A73                 push    ecx
.text$mn:00001A74                 mov     [ebp+var_4], ecx
.text$mn:00001A77                 mov     eax, [ebp+arg_4]
.text$mn:00001A7A                 push    eax             ; int
.text$mn:00001A7B                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00001A80                 add     esp, 4
.text$mn:00001A83                 test    eax, eax
.text$mn:00001A85                 jz      short loc_1AA0
.text$mn:00001A87                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00001A8C                 push    eax             ; struct std::error_category *
.text$mn:00001A8D                 mov     ecx, [ebp+arg_4]
.text$mn:00001A90                 push    ecx             ; int
.text$mn:00001A91                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001A94                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00001A99                 mov     eax, [ebp+arg_0]
.text$mn:00001A9C                 jmp     short loc_1AB5
.text$mn:00001A9E ; ---------------------------------------------------------------------------
.text$mn:00001A9E                 jmp     short loc_1AB5
.text$mn:00001AA0 ; ---------------------------------------------------------------------------
.text$mn:00001AA0
.text$mn:00001AA0 loc_1AA0:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00001AA0                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00001AA5                 push    eax             ; struct std::error_category *
.text$mn:00001AA6                 mov     edx, [ebp+arg_4]
.text$mn:00001AA9                 push    edx             ; int
.text$mn:00001AAA                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001AAD                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00001AB2                 mov     eax, [ebp+arg_0]
.text$mn:00001AB5
.text$mn:00001AB5 loc_1AB5:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00001AB5                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00001AB5                 mov     esp, ebp
.text$mn:00001AB7                 pop     ebp
.text$mn:00001AB8                 retn    8
.text$mn:00001AB8 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00001AB8
.text$mn:00001AB8 ; ---------------------------------------------------------------------------
.text$mn:00001ABB                 align 4
.text$mn:00001ABB _text$mn        ends
.text$mn:00001ABB
.text$mn:00001ABC ; ===========================================================================
.text$mn:00001ABC
.text$mn:00001ABC ; Segment type: Pure code
.text$mn:00001ABC ; Segment permissions: Read/Execute
.text$mn:00001ABC _text$mn        segment para public 'CODE' use32
.text$mn:00001ABC                 assume cs:_text$mn
.text$mn:00001ABC                 ;org 1ABCh
.text$mn:00001ABC ; COMDAT (pick any)
.text$mn:00001ABC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001ABC
.text$mn:00001ABC ; =============== S U B R O U T I N E =======================================
.text$mn:00001ABC
.text$mn:00001ABC ; Attributes: bp-based frame
.text$mn:00001ABC
.text$mn:00001ABC ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00001ABC                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00001ABC ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00001ABC                                         ; DATA XREF: .rdata:000023C8o
.text$mn:00001ABC                                         ; .rdata:000023E4o ...
.text$mn:00001ABC
.text$mn:00001ABC var_4           = dword ptr -4
.text$mn:00001ABC arg_0           = dword ptr  8
.text$mn:00001ABC arg_4           = dword ptr  0Ch
.text$mn:00001ABC
.text$mn:00001ABC                 push    ebp
.text$mn:00001ABD                 mov     ebp, esp
.text$mn:00001ABF                 push    ecx
.text$mn:00001AC0                 mov     [ebp+var_4], ecx
.text$mn:00001AC3                 mov     eax, [ebp+var_4]
.text$mn:00001AC6                 push    eax             ; struct std::error_category *
.text$mn:00001AC7                 mov     ecx, [ebp+arg_4]
.text$mn:00001ACA                 push    ecx             ; int
.text$mn:00001ACB                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001ACE                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00001AD3                 mov     eax, [ebp+arg_0]
.text$mn:00001AD6                 mov     esp, ebp
.text$mn:00001AD8                 pop     ebp
.text$mn:00001AD9                 retn    8
.text$mn:00001AD9 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00001AD9
.text$mn:00001AD9 _text$mn        ends
.text$mn:00001AD9
.text$mn:00001ADC ; ===========================================================================
.text$mn:00001ADC
.text$mn:00001ADC ; Segment type: Pure code
.text$mn:00001ADC ; Segment permissions: Read/Execute
.text$mn:00001ADC _text$mn        segment para public 'CODE' use32
.text$mn:00001ADC                 assume cs:_text$mn
.text$mn:00001ADC                 ;org 1ADCh
.text$mn:00001ADC ; COMDAT (pick any)
.text$mn:00001ADC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001ADC
.text$mn:00001ADC ; =============== S U B R O U T I N E =======================================
.text$mn:00001ADC
.text$mn:00001ADC ; Attributes: bp-based frame
.text$mn:00001ADC
.text$mn:00001ADC ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00001ADC                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00001ADC ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00001ADC                                         ; DATA XREF: .rdata:000023CCo
.text$mn:00001ADC                                         ; .rdata:000023E8o ...
.text$mn:00001ADC
.text$mn:00001ADC var_8           = dword ptr -8
.text$mn:00001ADC var_4           = dword ptr -4
.text$mn:00001ADC arg_0           = dword ptr  8
.text$mn:00001ADC arg_4           = dword ptr  0Ch
.text$mn:00001ADC
.text$mn:00001ADC                 push    ebp
.text$mn:00001ADD                 mov     ebp, esp
.text$mn:00001ADF                 sub     esp, 8
.text$mn:00001AE2                 mov     [ebp+var_8], ecx
.text$mn:00001AE5                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001AE8                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00001AED                 push    eax
.text$mn:00001AEE                 mov     ecx, [ebp+var_8]
.text$mn:00001AF1                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00001AF6                 movzx   eax, al
.text$mn:00001AF9                 test    eax, eax
.text$mn:00001AFB                 jz      short loc_1B13
.text$mn:00001AFD                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001B00                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00001B05                 cmp     eax, [ebp+arg_4]
.text$mn:00001B08                 jnz     short loc_1B13
.text$mn:00001B0A                 mov     [ebp+var_4], 1
.text$mn:00001B11                 jmp     short loc_1B1A
.text$mn:00001B13 ; ---------------------------------------------------------------------------
.text$mn:00001B13
.text$mn:00001B13 loc_1B13:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:00001B13                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:00001B13                 mov     [ebp+var_4], 0
.text$mn:00001B1A
.text$mn:00001B1A loc_1B1A:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00001B1A                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001B1D                 mov     esp, ebp
.text$mn:00001B1F                 pop     ebp
.text$mn:00001B20                 retn    8
.text$mn:00001B20 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00001B20
.text$mn:00001B20 ; ---------------------------------------------------------------------------
.text$mn:00001B23                 align 4
.text$mn:00001B23 _text$mn        ends
.text$mn:00001B23
.text$mn:00001B24 ; ===========================================================================
.text$mn:00001B24
.text$mn:00001B24 ; Segment type: Pure code
.text$mn:00001B24 ; Segment permissions: Read/Execute
.text$mn:00001B24 _text$mn        segment para public 'CODE' use32
.text$mn:00001B24                 assume cs:_text$mn
.text$mn:00001B24                 ;org 1B24h
.text$mn:00001B24 ; COMDAT (pick any)
.text$mn:00001B24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B24
.text$mn:00001B24 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B24
.text$mn:00001B24 ; Attributes: bp-based frame
.text$mn:00001B24
.text$mn:00001B24 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00001B24                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00001B24 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00001B24                                         ; DATA XREF: .rdata:000023D0o
.text$mn:00001B24                                         ; .rdata:000023ECo ...
.text$mn:00001B24
.text$mn:00001B24 var_C           = byte ptr -0Ch
.text$mn:00001B24 var_4           = dword ptr -4
.text$mn:00001B24 arg_0           = dword ptr  8
.text$mn:00001B24 arg_4           = dword ptr  0Ch
.text$mn:00001B24
.text$mn:00001B24                 push    ebp
.text$mn:00001B25                 mov     ebp, esp
.text$mn:00001B27                 sub     esp, 0Ch
.text$mn:00001B2A                 mov     [ebp+var_4], ecx
.text$mn:00001B2D                 mov     eax, [ebp+arg_4]
.text$mn:00001B30                 push    eax             ; std::error_condition *
.text$mn:00001B31                 mov     ecx, [ebp+arg_0]
.text$mn:00001B34                 push    ecx
.text$mn:00001B35                 lea     edx, [ebp+var_C]
.text$mn:00001B38                 push    edx
.text$mn:00001B39                 mov     eax, [ebp+var_4]
.text$mn:00001B3C                 mov     edx, [eax]
.text$mn:00001B3E                 mov     ecx, [ebp+var_4]
.text$mn:00001B41                 mov     eax, [edx+0Ch]
.text$mn:00001B44                 call    eax
.text$mn:00001B46                 mov     ecx, eax
.text$mn:00001B48                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00001B4D                 mov     esp, ebp
.text$mn:00001B4F                 pop     ebp
.text$mn:00001B50                 retn    8
.text$mn:00001B50 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00001B50
.text$mn:00001B50 ; ---------------------------------------------------------------------------
.text$mn:00001B53                 align 4
.text$mn:00001B53 _text$mn        ends
.text$mn:00001B53
.text$mn:00001B54 ; ===========================================================================
.text$mn:00001B54
.text$mn:00001B54 ; Segment type: Pure code
.text$mn:00001B54 ; Segment permissions: Read/Execute
.text$mn:00001B54 _text$mn        segment para public 'CODE' use32
.text$mn:00001B54                 assume cs:_text$mn
.text$mn:00001B54                 ;org 1B54h
.text$mn:00001B54 ; COMDAT (pick any)
.text$mn:00001B54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B54
.text$mn:00001B54 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B54
.text$mn:00001B54 ; Attributes: bp-based frame
.text$mn:00001B54
.text$mn:00001B54 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00001B54                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00001B54 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00001B54                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00001B54
.text$mn:00001B54 var_4           = dword ptr -4
.text$mn:00001B54 arg_0           = dword ptr  8
.text$mn:00001B54
.text$mn:00001B54                 push    ebp
.text$mn:00001B55                 mov     ebp, esp
.text$mn:00001B57                 push    ecx
.text$mn:00001B58                 mov     [ebp+var_4], ecx
.text$mn:00001B5B                 mov     eax, [ebp+var_4]
.text$mn:00001B5E                 mov     ecx, [eax+14h]
.text$mn:00001B61                 cmp     ecx, [ebp+arg_0]
.text$mn:00001B64                 jnb     short loc_1B6E
.text$mn:00001B66                 mov     ecx, [ebp+var_4]
.text$mn:00001B69                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001B6E
.text$mn:00001B6E loc_1B6E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00001B6E                 mov     edx, [ebp+arg_0]
.text$mn:00001B71                 push    edx
.text$mn:00001B72                 mov     ecx, [ebp+var_4]
.text$mn:00001B75                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001B7A                 mov     eax, [ebp+var_4]
.text$mn:00001B7D                 mov     esp, ebp
.text$mn:00001B7F                 pop     ebp
.text$mn:00001B80                 retn    4
.text$mn:00001B80 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00001B80
.text$mn:00001B80 ; ---------------------------------------------------------------------------
.text$mn:00001B83                 align 4
.text$mn:00001B83 _text$mn        ends
.text$mn:00001B83
.text$mn:00001B84 ; ===========================================================================
.text$mn:00001B84
.text$mn:00001B84 ; Segment type: Pure code
.text$mn:00001B84 ; Segment permissions: Read/Execute
.text$mn:00001B84 _text$mn        segment para public 'CODE' use32
.text$mn:00001B84                 assume cs:_text$mn
.text$mn:00001B84                 ;org 1B84h
.text$mn:00001B84 ; COMDAT (pick any)
.text$mn:00001B84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B84
.text$mn:00001B84 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B84
.text$mn:00001B84 ; Attributes: bp-based frame
.text$mn:00001B84
.text$mn:00001B84 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00001B84                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00001B84 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00001B84                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00001B84
.text$mn:00001B84 var_C           = dword ptr -0Ch
.text$mn:00001B84 Dst             = dword ptr -8
.text$mn:00001B84 var_4           = dword ptr -4
.text$mn:00001B84 arg_0           = dword ptr  8
.text$mn:00001B84 arg_4           = dword ptr  0Ch
.text$mn:00001B84
.text$mn:00001B84                 push    ebp
.text$mn:00001B85                 mov     ebp, esp
.text$mn:00001B87                 sub     esp, 0Ch
.text$mn:00001B8A                 mov     [ebp+var_4], ecx
.text$mn:00001B8D                 mov     eax, [ebp+var_4]
.text$mn:00001B90                 mov     ecx, [eax+14h]
.text$mn:00001B93                 cmp     ecx, [ebp+arg_0]
.text$mn:00001B96                 jnb     short loc_1BA0
.text$mn:00001B98                 mov     ecx, [ebp+var_4]
.text$mn:00001B9B                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001BA0
.text$mn:00001BA0 loc_1BA0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00001BA0                 mov     edx, [ebp+var_4]
.text$mn:00001BA3                 mov     eax, [edx+14h]
.text$mn:00001BA6                 sub     eax, [ebp+arg_0]
.text$mn:00001BA9                 cmp     eax, [ebp+arg_4]
.text$mn:00001BAC                 ja      short loc_1BBC
.text$mn:00001BAE                 mov     ecx, [ebp+arg_0]
.text$mn:00001BB1                 push    ecx
.text$mn:00001BB2                 mov     ecx, [ebp+var_4]
.text$mn:00001BB5                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001BBA                 jmp     short loc_1C02
.text$mn:00001BBC ; ---------------------------------------------------------------------------
.text$mn:00001BBC
.text$mn:00001BBC loc_1BBC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00001BBC                 cmp     [ebp+arg_4], 0
.text$mn:00001BC0                 jbe     short loc_1C02
.text$mn:00001BC2                 mov     ecx, [ebp+var_4]
.text$mn:00001BC5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001BCA                 add     eax, [ebp+arg_0]
.text$mn:00001BCD                 mov     [ebp+Dst], eax
.text$mn:00001BD0                 mov     edx, [ebp+var_4]
.text$mn:00001BD3                 mov     eax, [edx+14h]
.text$mn:00001BD6                 sub     eax, [ebp+arg_4]
.text$mn:00001BD9                 mov     [ebp+var_C], eax
.text$mn:00001BDC                 mov     ecx, [ebp+var_C]
.text$mn:00001BDF                 sub     ecx, [ebp+arg_0]
.text$mn:00001BE2                 push    ecx             ; Size
.text$mn:00001BE3                 mov     edx, [ebp+Dst]
.text$mn:00001BE6                 add     edx, [ebp+arg_4]
.text$mn:00001BE9                 push    edx             ; Src
.text$mn:00001BEA                 mov     eax, [ebp+Dst]
.text$mn:00001BED                 push    eax             ; Dst
.text$mn:00001BEE                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00001BF3                 add     esp, 0Ch
.text$mn:00001BF6                 mov     ecx, [ebp+var_C]
.text$mn:00001BF9                 push    ecx
.text$mn:00001BFA                 mov     ecx, [ebp+var_4]
.text$mn:00001BFD                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001C02
.text$mn:00001C02 loc_1C02:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:00001C02                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:00001C02                 mov     eax, [ebp+var_4]
.text$mn:00001C05                 mov     esp, ebp
.text$mn:00001C07                 pop     ebp
.text$mn:00001C08                 retn    8
.text$mn:00001C08 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00001C08
.text$mn:00001C08 ; ---------------------------------------------------------------------------
.text$mn:00001C0B                 align 4
.text$mn:00001C0B _text$mn        ends
.text$mn:00001C0B
.text$mn:00001C0C ; ===========================================================================
.text$mn:00001C0C
.text$mn:00001C0C ; Segment type: Pure code
.text$mn:00001C0C ; Segment permissions: Read/Execute
.text$mn:00001C0C _text$mn        segment para public 'CODE' use32
.text$mn:00001C0C                 assume cs:_text$mn
.text$mn:00001C0C                 ;org 1C0Ch
.text$mn:00001C0C ; COMDAT (pick any)
.text$mn:00001C0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C0C
.text$mn:00001C0C ; =============== S U B R O U T I N E =======================================
.text$mn:00001C0C
.text$mn:00001C0C ; Attributes: bp-based frame
.text$mn:00001C0C
.text$mn:00001C0C ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00001C0C                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00001C0C ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00001C0C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00001C0C                 push    ebp
.text$mn:00001C0D                 mov     ebp, esp
.text$mn:00001C0F                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00001C14                 pop     ebp
.text$mn:00001C15                 retn
.text$mn:00001C15 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00001C15
.text$mn:00001C15 ; ---------------------------------------------------------------------------
.text$mn:00001C16                 align 4
.text$mn:00001C16 _text$mn        ends
.text$mn:00001C16
.text$mn:00001C18 ; ===========================================================================
.text$mn:00001C18
.text$mn:00001C18 ; Segment type: Pure code
.text$mn:00001C18 ; Segment permissions: Read/Execute
.text$mn:00001C18 _text$mn        segment para public 'CODE' use32
.text$mn:00001C18                 assume cs:_text$mn
.text$mn:00001C18                 ;org 1C18h
.text$mn:00001C18 ; COMDAT (pick any)
.text$mn:00001C18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C18
.text$mn:00001C18 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C18
.text$mn:00001C18 ; Attributes: bp-based frame
.text$mn:00001C18
.text$mn:00001C18 ; int __thiscall TaskList::getCurrentIndex(TaskList *__hidden this)
.text$mn:00001C18                 public ?getCurrentIndex@TaskList@@QBEHXZ
.text$mn:00001C18 ?getCurrentIndex@TaskList@@QBEHXZ proc near
.text$mn:00001C18                                         ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+1D4p
.text$mn:00001C18
.text$mn:00001C18 var_4           = dword ptr -4
.text$mn:00001C18
.text$mn:00001C18                 push    ebp
.text$mn:00001C19                 mov     ebp, esp
.text$mn:00001C1B                 push    ecx
.text$mn:00001C1C                 mov     [ebp+var_4], ecx
.text$mn:00001C1F                 mov     eax, [ebp+var_4]
.text$mn:00001C22                 mov     eax, [eax+20h]
.text$mn:00001C25                 mov     esp, ebp
.text$mn:00001C27                 pop     ebp
.text$mn:00001C28                 retn
.text$mn:00001C28 ?getCurrentIndex@TaskList@@QBEHXZ endp
.text$mn:00001C28
.text$mn:00001C28 ; ---------------------------------------------------------------------------
.text$mn:00001C29                 align 4
.text$mn:00001C29 _text$mn        ends
.text$mn:00001C29
.text$mn:00001C2C ; ===========================================================================
.text$mn:00001C2C
.text$mn:00001C2C ; Segment type: Pure code
.text$mn:00001C2C ; Segment permissions: Read/Execute
.text$mn:00001C2C _text$mn        segment para public 'CODE' use32
.text$mn:00001C2C                 assume cs:_text$mn
.text$mn:00001C2C                 ;org 1C2Ch
.text$mn:00001C2C ; COMDAT (pick any)
.text$mn:00001C2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C2C
.text$mn:00001C2C ; =============== S U B R O U T I N E =======================================
.text$mn:00001C2C
.text$mn:00001C2C ; Attributes: bp-based frame
.text$mn:00001C2C
.text$mn:00001C2C ; struct _IMAGELIST *__thiscall TaskList::getImgLst(TaskList *__hidden this)
.text$mn:00001C2C                 public ?getImgLst@TaskList@@QBEPAU_IMAGELIST@@XZ
.text$mn:00001C2C ?getImgLst@TaskList@@QBEPAU_IMAGELIST@@XZ proc near
.text$mn:00001C2C                                         ; CODE XREF: TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+B6p
.text$mn:00001C2C
.text$mn:00001C2C var_4           = dword ptr -4
.text$mn:00001C2C
.text$mn:00001C2C                 push    ebp
.text$mn:00001C2D                 mov     ebp, esp
.text$mn:00001C2F                 push    ecx
.text$mn:00001C30                 mov     [ebp+var_4], ecx
.text$mn:00001C33                 push    0               ; lParam
.text$mn:00001C35                 push    1               ; wParam
.text$mn:00001C37                 push    1002h           ; Msg
.text$mn:00001C3C                 mov     eax, [ebp+var_4]
.text$mn:00001C3F                 mov     ecx, [eax+0Ch]
.text$mn:00001C42                 push    ecx             ; hWnd
.text$mn:00001C43                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001C49                 mov     esp, ebp
.text$mn:00001C4B                 pop     ebp
.text$mn:00001C4C                 retn
.text$mn:00001C4C ?getImgLst@TaskList@@QBEPAU_IMAGELIST@@XZ endp
.text$mn:00001C4C
.text$mn:00001C4C ; ---------------------------------------------------------------------------
.text$mn:00001C4D                 align 10h
.text$mn:00001C4D _text$mn        ends
.text$mn:00001C4D
.text$mn:00001C50 ; ===========================================================================
.text$mn:00001C50
.text$mn:00001C50 ; Segment type: Pure code
.text$mn:00001C50 ; Segment permissions: Read/Execute
.text$mn:00001C50 _text$mn        segment para public 'CODE' use32
.text$mn:00001C50                 assume cs:_text$mn
.text$mn:00001C50                 ;org 1C50h
.text$mn:00001C50 ; COMDAT (pick any)
.text$mn:00001C50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C50
.text$mn:00001C50 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C50
.text$mn:00001C50 ; Attributes: bp-based frame
.text$mn:00001C50
.text$mn:00001C50 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00001C50                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00001C50 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00001C50                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00001C50
.text$mn:00001C50 var_4           = dword ptr -4
.text$mn:00001C50 Str             = dword ptr  8
.text$mn:00001C50
.text$mn:00001C50                 push    ebp
.text$mn:00001C51                 mov     ebp, esp
.text$mn:00001C53                 push    ecx
.text$mn:00001C54                 mov     eax, [ebp+Str]
.text$mn:00001C57                 movsx   ecx, byte ptr [eax]
.text$mn:00001C5A                 test    ecx, ecx
.text$mn:00001C5C                 jnz     short loc_1C67
.text$mn:00001C5E                 mov     [ebp+var_4], 0
.text$mn:00001C65                 jmp     short loc_1C76
.text$mn:00001C67 ; ---------------------------------------------------------------------------
.text$mn:00001C67
.text$mn:00001C67 loc_1C67:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00001C67                 mov     edx, [ebp+Str]
.text$mn:00001C6A                 push    edx             ; Str
.text$mn:00001C6B                 call    _strlen
.text$mn:00001C70                 add     esp, 4
.text$mn:00001C73                 mov     [ebp+var_4], eax
.text$mn:00001C76
.text$mn:00001C76 loc_1C76:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00001C76                 mov     eax, [ebp+var_4]
.text$mn:00001C79                 mov     esp, ebp
.text$mn:00001C7B                 pop     ebp
.text$mn:00001C7C                 retn
.text$mn:00001C7C ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00001C7C
.text$mn:00001C7C ; ---------------------------------------------------------------------------
.text$mn:00001C7D                 align 10h
.text$mn:00001C7D _text$mn        ends
.text$mn:00001C7D
.text$mn:00001C80 ; ===========================================================================
.text$mn:00001C80
.text$mn:00001C80 ; Segment type: Pure code
.text$mn:00001C80 ; Segment permissions: Read/Execute
.text$mn:00001C80 _text$mn        segment para public 'CODE' use32
.text$mn:00001C80                 assume cs:_text$mn
.text$mn:00001C80                 ;org 1C80h
.text$mn:00001C80 ; COMDAT (pick any)
.text$mn:00001C80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C80
.text$mn:00001C80 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C80
.text$mn:00001C80 ; Attributes: bp-based frame
.text$mn:00001C80
.text$mn:00001C80 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00001C80                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00001C80 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00001C80                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00001C80
.text$mn:00001C80 var_4           = dword ptr -4
.text$mn:00001C80
.text$mn:00001C80                 push    ebp
.text$mn:00001C81                 mov     ebp, esp
.text$mn:00001C83                 push    ecx
.text$mn:00001C84                 mov     [ebp+var_4], ecx
.text$mn:00001C87                 mov     eax, [ebp+var_4]
.text$mn:00001C8A                 push    eax
.text$mn:00001C8B                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00001C90                 add     esp, 4
.text$mn:00001C93                 mov     esp, ebp
.text$mn:00001C95                 pop     ebp
.text$mn:00001C96                 retn
.text$mn:00001C96 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:00001C96
.text$mn:00001C96 ; ---------------------------------------------------------------------------
.text$mn:00001C97                 align 4
.text$mn:00001C97 _text$mn        ends
.text$mn:00001C97
.text$mn:00001C98 ; ===========================================================================
.text$mn:00001C98
.text$mn:00001C98 ; Segment type: Pure code
.text$mn:00001C98 ; Segment permissions: Read/Execute
.text$mn:00001C98 _text$mn        segment para public 'CODE' use32
.text$mn:00001C98                 assume cs:_text$mn
.text$mn:00001C98                 ;org 1C98h
.text$mn:00001C98 ; COMDAT (pick any)
.text$mn:00001C98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C98
.text$mn:00001C98 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C98
.text$mn:00001C98 ; Attributes: bp-based frame
.text$mn:00001C98
.text$mn:00001C98 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00001C98                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00001C98 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00001C98                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00001C98
.text$mn:00001C98 var_4           = dword ptr -4
.text$mn:00001C98
.text$mn:00001C98                 push    ebp
.text$mn:00001C99                 mov     ebp, esp
.text$mn:00001C9B                 push    ecx
.text$mn:00001C9C                 mov     [ebp+var_4], ecx
.text$mn:00001C9F                 or      eax, 0FFFFFFFFh
.text$mn:00001CA2                 mov     esp, ebp
.text$mn:00001CA4                 pop     ebp
.text$mn:00001CA5                 retn
.text$mn:00001CA5 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00001CA5
.text$mn:00001CA5 ; ---------------------------------------------------------------------------
.text$mn:00001CA6                 align 4
.text$mn:00001CA6 _text$mn        ends
.text$mn:00001CA6
.text$mn:00001CA8 ; ===========================================================================
.text$mn:00001CA8
.text$mn:00001CA8 ; Segment type: Pure code
.text$mn:00001CA8 ; Segment permissions: Read/Execute
.text$mn:00001CA8 _text$mn        segment para public 'CODE' use32
.text$mn:00001CA8                 assume cs:_text$mn
.text$mn:00001CA8                 ;org 1CA8h
.text$mn:00001CA8 ; COMDAT (pick any)
.text$mn:00001CA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CA8
.text$mn:00001CA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CA8
.text$mn:00001CA8 ; Attributes: bp-based frame
.text$mn:00001CA8
.text$mn:00001CA8 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:00001CA8                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:00001CA8 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:00001CA8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:00001CA8
.text$mn:00001CA8 arg_0           = dword ptr  8
.text$mn:00001CA8
.text$mn:00001CA8                 push    ebp
.text$mn:00001CA9                 mov     ebp, esp
.text$mn:00001CAB                 mov     ecx, [ebp+arg_0]
.text$mn:00001CAE                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:00001CB3                 pop     ebp
.text$mn:00001CB4                 retn
.text$mn:00001CB4 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00001CB4
.text$mn:00001CB4 ; ---------------------------------------------------------------------------
.text$mn:00001CB5                 align 4
.text$mn:00001CB5 _text$mn        ends
.text$mn:00001CB5
.text$mn:00001CB8 ; ===========================================================================
.text$mn:00001CB8
.text$mn:00001CB8 ; Segment type: Pure code
.text$mn:00001CB8 ; Segment permissions: Read/Execute
.text$mn:00001CB8 _text$mn        segment para public 'CODE' use32
.text$mn:00001CB8                 assume cs:_text$mn
.text$mn:00001CB8                 ;org 1CB8h
.text$mn:00001CB8 ; COMDAT (pick any)
.text$mn:00001CB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CB8
.text$mn:00001CB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CB8
.text$mn:00001CB8 ; Attributes: bp-based frame
.text$mn:00001CB8
.text$mn:00001CB8 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:00001CB8                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00001CB8 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00001CB8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:00001CB8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:00001CB8
.text$mn:00001CB8 var_10          = dword ptr -10h
.text$mn:00001CB8 var_C           = dword ptr -0Ch
.text$mn:00001CB8 var_8           = dword ptr -8
.text$mn:00001CB8 var_1           = byte ptr -1
.text$mn:00001CB8
.text$mn:00001CB8                 push    ebp
.text$mn:00001CB9                 mov     ebp, esp
.text$mn:00001CBB                 sub     esp, 10h
.text$mn:00001CBE                 mov     [ebp+var_10], ecx
.text$mn:00001CC1                 lea     eax, [ebp+var_1]
.text$mn:00001CC4                 push    eax
.text$mn:00001CC5                 mov     ecx, [ebp+var_10]
.text$mn:00001CC8                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001CCD                 mov     ecx, eax
.text$mn:00001CCF                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00001CD4                 mov     [ebp+var_8], eax
.text$mn:00001CD7                 cmp     [ebp+var_8], 1
.text$mn:00001CDB                 ja      short loc_1CE6
.text$mn:00001CDD                 mov     [ebp+var_C], 1
.text$mn:00001CE4                 jmp     short loc_1CEF
.text$mn:00001CE6 ; ---------------------------------------------------------------------------
.text$mn:00001CE6
.text$mn:00001CE6 loc_1CE6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:00001CE6                 mov     ecx, [ebp+var_8]
.text$mn:00001CE9                 sub     ecx, 1
.text$mn:00001CEC                 mov     [ebp+var_C], ecx
.text$mn:00001CEF
.text$mn:00001CEF loc_1CEF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00001CEF                 mov     eax, [ebp+var_C]
.text$mn:00001CF2                 mov     esp, ebp
.text$mn:00001CF4                 pop     ebp
.text$mn:00001CF5                 retn
.text$mn:00001CF5 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00001CF5
.text$mn:00001CF5 ; ---------------------------------------------------------------------------
.text$mn:00001CF6                 align 4
.text$mn:00001CF6 _text$mn        ends
.text$mn:00001CF6
.text$mn:00001CF8 ; ===========================================================================
.text$mn:00001CF8
.text$mn:00001CF8 ; Segment type: Pure code
.text$mn:00001CF8 ; Segment permissions: Read/Execute
.text$mn:00001CF8 _text$mn        segment para public 'CODE' use32
.text$mn:00001CF8                 assume cs:_text$mn
.text$mn:00001CF8                 ;org 1CF8h
.text$mn:00001CF8 ; COMDAT (pick any)
.text$mn:00001CF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CF8
.text$mn:00001CF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CF8
.text$mn:00001CF8 ; Attributes: bp-based frame
.text$mn:00001CF8
.text$mn:00001CF8 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00001CF8                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001CF8 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001CF8                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00001CF8                                         ; DATA XREF: .rdata:000023E0o
.text$mn:00001CF8
.text$mn:00001CF8 var_1C          = dword ptr -1Ch
.text$mn:00001CF8 var_18          = dword ptr -18h
.text$mn:00001CF8 Str             = dword ptr -14h
.text$mn:00001CF8 var_10          = dword ptr -10h
.text$mn:00001CF8 var_C           = dword ptr -0Ch
.text$mn:00001CF8 var_4           = dword ptr -4
.text$mn:00001CF8 arg_0           = dword ptr  8
.text$mn:00001CF8 arg_4           = dword ptr  0Ch
.text$mn:00001CF8
.text$mn:00001CF8                 push    ebp
.text$mn:00001CF9                 mov     ebp, esp
.text$mn:00001CFB                 push    0FFFFFFFFh
.text$mn:00001CFD                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001D02                 mov     eax, large fs:0
.text$mn:00001D08                 push    eax
.text$mn:00001D09                 sub     esp, 10h
.text$mn:00001D0C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001D11                 xor     eax, ebp
.text$mn:00001D13                 push    eax
.text$mn:00001D14                 lea     eax, [ebp+var_C]
.text$mn:00001D17                 mov     large fs:0, eax
.text$mn:00001D1D                 mov     [ebp+var_1C], ecx
.text$mn:00001D20                 mov     [ebp+var_18], 0
.text$mn:00001D27                 mov     eax, [ebp+arg_4]
.text$mn:00001D2A                 push    eax             ; int
.text$mn:00001D2B                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00001D30                 add     esp, 4
.text$mn:00001D33                 mov     [ebp+var_10], eax
.text$mn:00001D36                 cmp     [ebp+var_10], 0
.text$mn:00001D3A                 jz      short loc_1D44
.text$mn:00001D3C                 mov     ecx, [ebp+var_10]
.text$mn:00001D3F                 mov     [ebp+Str], ecx
.text$mn:00001D42                 jmp     short loc_1D4B
.text$mn:00001D44 ; ---------------------------------------------------------------------------
.text$mn:00001D44
.text$mn:00001D44 loc_1D44:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00001D44                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00001D4B
.text$mn:00001D4B loc_1D4B:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:00001D4B                 mov     edx, [ebp+Str]
.text$mn:00001D4E                 push    edx             ; Str
.text$mn:00001D4F                 mov     ecx, [ebp+arg_0]
.text$mn:00001D52                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001D57                 mov     [ebp+var_4], 0
.text$mn:00001D5E                 mov     eax, [ebp+var_18]
.text$mn:00001D61                 or      eax, 1
.text$mn:00001D64                 mov     [ebp+var_18], eax
.text$mn:00001D67                 mov     eax, [ebp+arg_0]
.text$mn:00001D6A                 mov     ecx, [ebp+var_C]
.text$mn:00001D6D                 mov     large fs:0, ecx
.text$mn:00001D74                 pop     ecx
.text$mn:00001D75                 mov     esp, ebp
.text$mn:00001D77                 pop     ebp
.text$mn:00001D78                 retn    8
.text$mn:00001D78 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001D78
.text$mn:00001D78 ; ---------------------------------------------------------------------------
.text$mn:00001D7B                 align 4
.text$mn:00001D7B _text$mn        ends
.text$mn:00001D7B
.text$x:00001D7C ; ===========================================================================
.text$x:00001D7C
.text$x:00001D7C ; Segment type: Pure code
.text$x:00001D7C ; Segment permissions: Read/Execute
.text$x:00001D7C _text$x         segment para public 'CODE' use32
.text$x:00001D7C                 assume cs:_text$x
.text$x:00001D7C                 ;org 1D7Ch
.text$x:00001D7C ; COMDAT (pick associative to section at 1CF8)
.text$x:00001D7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001D7C
.text$x:00001D7C ; =============== S U B R O U T I N E =======================================
.text$x:00001D7C
.text$x:00001D7C
.text$x:00001D7C __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001D7C                                         ; DATA XREF: .xdata$x:00002204o
.text$x:00001D7C                 mov     eax, [ebp-18h]
.text$x:00001D7F                 and     eax, 1
.text$x:00001D82                 jz      $LN6
.text$x:00001D88                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00001D8C                 mov     ecx, [ebp+8]
.text$x:00001D8F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001D94 ; ---------------------------------------------------------------------------
.text$x:00001D94
.text$x:00001D94 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001D94                 retn
.text$x:00001D94 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001D94
.text$x:00001D95
.text$x:00001D95 ; =============== S U B R O U T I N E =======================================
.text$x:00001D95
.text$x:00001D95
.text$x:00001D95 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001D95                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00001D95
.text$x:00001D95 arg_4           = dword ptr  8
.text$x:00001D95
.text$x:00001D95                 mov     edx, [esp+arg_4]
.text$x:00001D99                 lea     eax, [edx+0Ch]
.text$x:00001D9C                 mov     ecx, [edx-14h]
.text$x:00001D9F                 xor     ecx, eax
.text$x:00001DA1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001DA6                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001DAB                 jmp     ___CxxFrameHandler3
.text$x:00001DAB __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001DAB
.text$x:00001DAB _text$x         ends
.text$x:00001DAB
.text$mn:00001DB0 ; ===========================================================================
.text$mn:00001DB0
.text$mn:00001DB0 ; Segment type: Pure code
.text$mn:00001DB0 ; Segment permissions: Read/Execute
.text$mn:00001DB0 _text$mn        segment para public 'CODE' use32
.text$mn:00001DB0                 assume cs:_text$mn
.text$mn:00001DB0                 ;org 1DB0h
.text$mn:00001DB0 ; COMDAT (pick any)
.text$mn:00001DB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DB0
.text$mn:00001DB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DB0
.text$mn:00001DB0 ; Attributes: bp-based frame
.text$mn:00001DB0
.text$mn:00001DB0 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00001DB0                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001DB0 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001DB0                                         ; DATA XREF: .rdata:00002414o
.text$mn:00001DB0
.text$mn:00001DB0 var_14          = dword ptr -14h
.text$mn:00001DB0 var_10          = dword ptr -10h
.text$mn:00001DB0 var_C           = dword ptr -0Ch
.text$mn:00001DB0 var_4           = dword ptr -4
.text$mn:00001DB0 arg_0           = dword ptr  8
.text$mn:00001DB0 arg_4           = dword ptr  0Ch
.text$mn:00001DB0
.text$mn:00001DB0                 push    ebp
.text$mn:00001DB1                 mov     ebp, esp
.text$mn:00001DB3                 push    0FFFFFFFFh
.text$mn:00001DB5                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001DBA                 mov     eax, large fs:0
.text$mn:00001DC0                 push    eax
.text$mn:00001DC1                 sub     esp, 8
.text$mn:00001DC4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001DC9                 xor     eax, ebp
.text$mn:00001DCB                 push    eax
.text$mn:00001DCC                 lea     eax, [ebp+var_C]
.text$mn:00001DCF                 mov     large fs:0, eax
.text$mn:00001DD5                 mov     [ebp+var_14], ecx
.text$mn:00001DD8                 mov     [ebp+var_10], 0
.text$mn:00001DDF                 cmp     [ebp+arg_4], 1
.text$mn:00001DE3                 jnz     short loc_1E09
.text$mn:00001DE5                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00001DEA                 mov     ecx, [ebp+arg_0]
.text$mn:00001DED                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001DF2                 mov     [ebp+var_4], 0
.text$mn:00001DF9                 mov     eax, [ebp+var_10]
.text$mn:00001DFC                 or      eax, 1
.text$mn:00001DFF                 mov     [ebp+var_10], eax
.text$mn:00001E02                 mov     eax, [ebp+arg_0]
.text$mn:00001E05                 jmp     short loc_1E2C
.text$mn:00001E07 ; ---------------------------------------------------------------------------
.text$mn:00001E07                 jmp     short loc_1E2C
.text$mn:00001E09 ; ---------------------------------------------------------------------------
.text$mn:00001E09
.text$mn:00001E09 loc_1E09:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00001E09                 mov     ecx, [ebp+arg_4]
.text$mn:00001E0C                 push    ecx
.text$mn:00001E0D                 mov     edx, [ebp+arg_0]
.text$mn:00001E10                 push    edx
.text$mn:00001E11                 mov     ecx, [ebp+var_14]
.text$mn:00001E14                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00001E19                 mov     [ebp+var_4], 0
.text$mn:00001E20                 mov     eax, [ebp+var_10]
.text$mn:00001E23                 or      eax, 1
.text$mn:00001E26                 mov     [ebp+var_10], eax
.text$mn:00001E29                 mov     eax, [ebp+arg_0]
.text$mn:00001E2C
.text$mn:00001E2C loc_1E2C:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00001E2C                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00001E2C                 mov     ecx, [ebp+var_C]
.text$mn:00001E2F                 mov     large fs:0, ecx
.text$mn:00001E36                 pop     ecx
.text$mn:00001E37                 mov     esp, ebp
.text$mn:00001E39                 pop     ebp
.text$mn:00001E3A                 retn    8
.text$mn:00001E3A ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001E3A
.text$mn:00001E3A ; ---------------------------------------------------------------------------
.text$mn:00001E3D                 align 10h
.text$mn:00001E3D _text$mn        ends
.text$mn:00001E3D
.text$x:00001E40 ; ===========================================================================
.text$x:00001E40
.text$x:00001E40 ; Segment type: Pure code
.text$x:00001E40 ; Segment permissions: Read/Execute
.text$x:00001E40 _text$x         segment para public 'CODE' use32
.text$x:00001E40                 assume cs:_text$x
.text$x:00001E40                 ;org 1E40h
.text$x:00001E40 ; COMDAT (pick associative to section at 1DB0)
.text$x:00001E40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001E40
.text$x:00001E40 ; =============== S U B R O U T I N E =======================================
.text$x:00001E40
.text$x:00001E40
.text$x:00001E40 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001E40                                         ; DATA XREF: .xdata$x:00002288o
.text$x:00001E40                 mov     eax, [ebp-10h]
.text$x:00001E43                 and     eax, 1
.text$x:00001E46                 jz      $LN6_0
.text$x:00001E4C                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00001E50                 mov     ecx, [ebp+8]
.text$x:00001E53                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001E58 ; ---------------------------------------------------------------------------
.text$x:00001E58
.text$x:00001E58 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001E58                 retn
.text$x:00001E58 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001E58
.text$x:00001E59
.text$x:00001E59 ; =============== S U B R O U T I N E =======================================
.text$x:00001E59
.text$x:00001E59
.text$x:00001E59 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001E59                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00001E59
.text$x:00001E59 arg_4           = dword ptr  8
.text$x:00001E59
.text$x:00001E59                 mov     edx, [esp+arg_4]
.text$x:00001E5D                 lea     eax, [edx+0Ch]
.text$x:00001E60                 mov     ecx, [edx-0Ch]
.text$x:00001E63                 xor     ecx, eax
.text$x:00001E65                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001E6A                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001E6F                 jmp     ___CxxFrameHandler3
.text$x:00001E6F __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001E6F
.text$x:00001E6F _text$x         ends
.text$x:00001E6F
.text$mn:00001E74 ; ===========================================================================
.text$mn:00001E74
.text$mn:00001E74 ; Segment type: Pure code
.text$mn:00001E74 ; Segment permissions: Read/Execute
.text$mn:00001E74 _text$mn        segment para public 'CODE' use32
.text$mn:00001E74                 assume cs:_text$mn
.text$mn:00001E74                 ;org 1E74h
.text$mn:00001E74 ; COMDAT (pick any)
.text$mn:00001E74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E74
.text$mn:00001E74 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E74
.text$mn:00001E74 ; Attributes: bp-based frame
.text$mn:00001E74
.text$mn:00001E74 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00001E74                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001E74 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001E74                                         ; DATA XREF: .rdata:00002454o
.text$mn:00001E74
.text$mn:00001E74 var_1C          = dword ptr -1Ch
.text$mn:00001E74 var_18          = dword ptr -18h
.text$mn:00001E74 Str             = dword ptr -14h
.text$mn:00001E74 var_10          = dword ptr -10h
.text$mn:00001E74 var_C           = dword ptr -0Ch
.text$mn:00001E74 var_4           = dword ptr -4
.text$mn:00001E74 arg_0           = dword ptr  8
.text$mn:00001E74 arg_4           = dword ptr  0Ch
.text$mn:00001E74
.text$mn:00001E74                 push    ebp
.text$mn:00001E75                 mov     ebp, esp
.text$mn:00001E77                 push    0FFFFFFFFh
.text$mn:00001E79                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001E7E                 mov     eax, large fs:0
.text$mn:00001E84                 push    eax
.text$mn:00001E85                 sub     esp, 10h
.text$mn:00001E88                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001E8D                 xor     eax, ebp
.text$mn:00001E8F                 push    eax
.text$mn:00001E90                 lea     eax, [ebp+var_C]
.text$mn:00001E93                 mov     large fs:0, eax
.text$mn:00001E99                 mov     [ebp+var_1C], ecx
.text$mn:00001E9C                 mov     [ebp+var_18], 0
.text$mn:00001EA3                 mov     eax, [ebp+arg_4]
.text$mn:00001EA6                 push    eax             ; int
.text$mn:00001EA7                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00001EAC                 add     esp, 4
.text$mn:00001EAF                 mov     [ebp+var_10], eax
.text$mn:00001EB2                 cmp     [ebp+var_10], 0
.text$mn:00001EB6                 jz      short loc_1EC0
.text$mn:00001EB8                 mov     ecx, [ebp+var_10]
.text$mn:00001EBB                 mov     [ebp+Str], ecx
.text$mn:00001EBE                 jmp     short loc_1EC7
.text$mn:00001EC0 ; ---------------------------------------------------------------------------
.text$mn:00001EC0
.text$mn:00001EC0 loc_1EC0:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00001EC0                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00001EC7
.text$mn:00001EC7 loc_1EC7:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00001EC7                 mov     edx, [ebp+Str]
.text$mn:00001ECA                 push    edx             ; Str
.text$mn:00001ECB                 mov     ecx, [ebp+arg_0]
.text$mn:00001ECE                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001ED3                 mov     [ebp+var_4], 0
.text$mn:00001EDA                 mov     eax, [ebp+var_18]
.text$mn:00001EDD                 or      eax, 1
.text$mn:00001EE0                 mov     [ebp+var_18], eax
.text$mn:00001EE3                 mov     eax, [ebp+arg_0]
.text$mn:00001EE6                 mov     ecx, [ebp+var_C]
.text$mn:00001EE9                 mov     large fs:0, ecx
.text$mn:00001EF0                 pop     ecx
.text$mn:00001EF1                 mov     esp, ebp
.text$mn:00001EF3                 pop     ebp
.text$mn:00001EF4                 retn    8
.text$mn:00001EF4 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001EF4
.text$mn:00001EF4 ; ---------------------------------------------------------------------------
.text$mn:00001EF7                 align 4
.text$mn:00001EF7 _text$mn        ends
.text$mn:00001EF7
.text$x:00001EF8 ; ===========================================================================
.text$x:00001EF8
.text$x:00001EF8 ; Segment type: Pure code
.text$x:00001EF8 ; Segment permissions: Read/Execute
.text$x:00001EF8 _text$x         segment para public 'CODE' use32
.text$x:00001EF8                 assume cs:_text$x
.text$x:00001EF8                 ;org 1EF8h
.text$x:00001EF8 ; COMDAT (pick associative to section at 1E74)
.text$x:00001EF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001EF8
.text$x:00001EF8 ; =============== S U B R O U T I N E =======================================
.text$x:00001EF8
.text$x:00001EF8
.text$x:00001EF8 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001EF8                                         ; DATA XREF: .xdata$x:0000230Co
.text$x:00001EF8                 mov     eax, [ebp-18h]
.text$x:00001EFB                 and     eax, 1
.text$x:00001EFE                 jz      $LN6_1
.text$x:00001F04                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00001F08                 mov     ecx, [ebp+8]
.text$x:00001F0B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001F10 ; ---------------------------------------------------------------------------
.text$x:00001F10
.text$x:00001F10 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001F10                 retn
.text$x:00001F10 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001F10
.text$x:00001F11
.text$x:00001F11 ; =============== S U B R O U T I N E =======================================
.text$x:00001F11
.text$x:00001F11
.text$x:00001F11 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001F11                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00001F11
.text$x:00001F11 arg_4           = dword ptr  8
.text$x:00001F11
.text$x:00001F11                 mov     edx, [esp+arg_4]
.text$x:00001F15                 lea     eax, [edx+0Ch]
.text$x:00001F18                 mov     ecx, [edx-14h]
.text$x:00001F1B                 xor     ecx, eax
.text$x:00001F1D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001F22                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001F27                 jmp     ___CxxFrameHandler3
.text$x:00001F27 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001F27
.text$x:00001F27 _text$x         ends
.text$x:00001F27
.text$mn:00001F2C ; ===========================================================================
.text$mn:00001F2C
.text$mn:00001F2C ; Segment type: Pure code
.text$mn:00001F2C ; Segment permissions: Read/Execute
.text$mn:00001F2C _text$mn        segment para public 'CODE' use32
.text$mn:00001F2C                 assume cs:_text$mn
.text$mn:00001F2C                 ;org 1F2Ch
.text$mn:00001F2C ; COMDAT (pick any)
.text$mn:00001F2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F2C
.text$mn:00001F2C ; =============== S U B R O U T I N E =======================================
.text$mn:00001F2C
.text$mn:00001F2C ; Attributes: bp-based frame
.text$mn:00001F2C
.text$mn:00001F2C ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00001F2C                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00001F2C ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00001F2C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00001F2C
.text$mn:00001F2C var_4           = dword ptr -4
.text$mn:00001F2C Dst             = dword ptr  8
.text$mn:00001F2C Src             = dword ptr  0Ch
.text$mn:00001F2C Size            = dword ptr  10h
.text$mn:00001F2C
.text$mn:00001F2C                 push    ebp
.text$mn:00001F2D                 mov     ebp, esp
.text$mn:00001F2F                 push    ecx
.text$mn:00001F30                 cmp     [ebp+Size], 0
.text$mn:00001F34                 jnz     short loc_1F3E
.text$mn:00001F36                 mov     eax, [ebp+Dst]
.text$mn:00001F39                 mov     [ebp+var_4], eax
.text$mn:00001F3C                 jmp     short loc_1F55
.text$mn:00001F3E ; ---------------------------------------------------------------------------
.text$mn:00001F3E
.text$mn:00001F3E loc_1F3E:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00001F3E                 mov     ecx, [ebp+Size]
.text$mn:00001F41                 push    ecx             ; Size
.text$mn:00001F42                 mov     edx, [ebp+Src]
.text$mn:00001F45                 push    edx             ; Src
.text$mn:00001F46                 mov     eax, [ebp+Dst]
.text$mn:00001F49                 push    eax             ; Dst
.text$mn:00001F4A                 call    _memmove
.text$mn:00001F4F                 add     esp, 0Ch
.text$mn:00001F52                 mov     [ebp+var_4], eax
.text$mn:00001F55
.text$mn:00001F55 loc_1F55:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00001F55                 mov     eax, [ebp+var_4]
.text$mn:00001F58                 mov     esp, ebp
.text$mn:00001F5A                 pop     ebp
.text$mn:00001F5B                 retn
.text$mn:00001F5B ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00001F5B
.text$mn:00001F5B _text$mn        ends
.text$mn:00001F5B
.text$mn:00001F5C ; ===========================================================================
.text$mn:00001F5C
.text$mn:00001F5C ; Segment type: Pure code
.text$mn:00001F5C ; Segment permissions: Read/Execute
.text$mn:00001F5C _text$mn        segment para public 'CODE' use32
.text$mn:00001F5C                 assume cs:_text$mn
.text$mn:00001F5C                 ;org 1F5Ch
.text$mn:00001F5C ; COMDAT (pick any)
.text$mn:00001F5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F5C
.text$mn:00001F5C ; =============== S U B R O U T I N E =======================================
.text$mn:00001F5C
.text$mn:00001F5C ; Attributes: bp-based frame
.text$mn:00001F5C
.text$mn:00001F5C ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00001F5C                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00001F5C ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00001F5C                                         ; DATA XREF: .rdata:000023DCo
.text$mn:00001F5C
.text$mn:00001F5C var_4           = dword ptr -4
.text$mn:00001F5C
.text$mn:00001F5C                 push    ebp
.text$mn:00001F5D                 mov     ebp, esp
.text$mn:00001F5F                 push    ecx
.text$mn:00001F60                 mov     [ebp+var_4], ecx
.text$mn:00001F63                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00001F68                 mov     esp, ebp
.text$mn:00001F6A                 pop     ebp
.text$mn:00001F6B                 retn
.text$mn:00001F6B ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00001F6B
.text$mn:00001F6B _text$mn        ends
.text$mn:00001F6B
.text$mn:00001F6C ; ===========================================================================
.text$mn:00001F6C
.text$mn:00001F6C ; Segment type: Pure code
.text$mn:00001F6C ; Segment permissions: Read/Execute
.text$mn:00001F6C _text$mn        segment para public 'CODE' use32
.text$mn:00001F6C                 assume cs:_text$mn
.text$mn:00001F6C                 ;org 1F6Ch
.text$mn:00001F6C ; COMDAT (pick any)
.text$mn:00001F6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F6C
.text$mn:00001F6C ; =============== S U B R O U T I N E =======================================
.text$mn:00001F6C
.text$mn:00001F6C ; Attributes: bp-based frame
.text$mn:00001F6C
.text$mn:00001F6C ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00001F6C                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00001F6C ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00001F6C                                         ; DATA XREF: .rdata:00002410o
.text$mn:00001F6C
.text$mn:00001F6C var_4           = dword ptr -4
.text$mn:00001F6C
.text$mn:00001F6C                 push    ebp
.text$mn:00001F6D                 mov     ebp, esp
.text$mn:00001F6F                 push    ecx
.text$mn:00001F70                 mov     [ebp+var_4], ecx
.text$mn:00001F73                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00001F78                 mov     esp, ebp
.text$mn:00001F7A                 pop     ebp
.text$mn:00001F7B                 retn
.text$mn:00001F7B ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00001F7B
.text$mn:00001F7B _text$mn        ends
.text$mn:00001F7B
.text$mn:00001F7C ; ===========================================================================
.text$mn:00001F7C
.text$mn:00001F7C ; Segment type: Pure code
.text$mn:00001F7C ; Segment permissions: Read/Execute
.text$mn:00001F7C _text$mn        segment para public 'CODE' use32
.text$mn:00001F7C                 assume cs:_text$mn
.text$mn:00001F7C                 ;org 1F7Ch
.text$mn:00001F7C ; COMDAT (pick any)
.text$mn:00001F7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F7C
.text$mn:00001F7C ; =============== S U B R O U T I N E =======================================
.text$mn:00001F7C
.text$mn:00001F7C ; Attributes: bp-based frame
.text$mn:00001F7C
.text$mn:00001F7C ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00001F7C                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00001F7C ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00001F7C                                         ; DATA XREF: .rdata:00002450o
.text$mn:00001F7C
.text$mn:00001F7C var_4           = dword ptr -4
.text$mn:00001F7C
.text$mn:00001F7C                 push    ebp
.text$mn:00001F7D                 mov     ebp, esp
.text$mn:00001F7F                 push    ecx
.text$mn:00001F80                 mov     [ebp+var_4], ecx
.text$mn:00001F83                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00001F88                 mov     esp, ebp
.text$mn:00001F8A                 pop     ebp
.text$mn:00001F8B                 retn
.text$mn:00001F8B ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00001F8B
.text$mn:00001F8B _text$mn        ends
.text$mn:00001F8B
.text$mn:00001F8C ; ===========================================================================
.text$mn:00001F8C
.text$mn:00001F8C ; Segment type: Pure code
.text$mn:00001F8C ; Segment permissions: Read/Execute
.text$mn:00001F8C _text$mn        segment para public 'CODE' use32
.text$mn:00001F8C                 assume cs:_text$mn
.text$mn:00001F8C                 ;org 1F8Ch
.text$mn:00001F8C ; COMDAT (pick any)
.text$mn:00001F8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F8C
.text$mn:00001F8C ; =============== S U B R O U T I N E =======================================
.text$mn:00001F8C
.text$mn:00001F8C ; Attributes: bp-based frame
.text$mn:00001F8C
.text$mn:00001F8C ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00001F8C                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00001F8C ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00001F8C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00001F8C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00001F8C
.text$mn:00001F8C var_4           = dword ptr -4
.text$mn:00001F8C
.text$mn:00001F8C                 push    ebp
.text$mn:00001F8D                 mov     ebp, esp
.text$mn:00001F8F                 push    ecx
.text$mn:00001F90                 mov     [ebp+var_4], ecx
.text$mn:00001F93                 mov     eax, [ebp+var_4]
.text$mn:00001F96                 mov     eax, [eax+14h]
.text$mn:00001F99                 mov     esp, ebp
.text$mn:00001F9B                 pop     ebp
.text$mn:00001F9C                 retn
.text$mn:00001F9C ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00001F9C
.text$mn:00001F9C ; ---------------------------------------------------------------------------
.text$mn:00001F9D                 align 10h
.text$mn:00001F9D _text$mn        ends
.text$mn:00001F9D
.text$mn:00001FA0 ; ===========================================================================
.text$mn:00001FA0
.text$mn:00001FA0 ; Segment type: Pure code
.text$mn:00001FA0 ; Segment permissions: Read/Execute
.text$mn:00001FA0 _text$mn        segment para public 'CODE' use32
.text$mn:00001FA0                 assume cs:_text$mn
.text$mn:00001FA0                 ;org 1FA0h
.text$mn:00001FA0 ; COMDAT (pick any)
.text$mn:00001FA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FA0
.text$mn:00001FA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FA0
.text$mn:00001FA0 ; Attributes: bp-based frame
.text$mn:00001FA0
.text$mn:00001FA0 ; public: unsigned int __thiscall std::vector<struct TaskLstFnStatus, class std::allocator<struct TaskLstFnStatus>>::size(void)const
.text$mn:00001FA0                 public ?size@?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QBEIXZ
.text$mn:00001FA0 ?size@?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QBEIXZ proc near
.text$mn:00001FA0                                         ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+8Bp
.text$mn:00001FA0                                         ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+Ap
.text$mn:00001FA0
.text$mn:00001FA0 var_4           = dword ptr -4
.text$mn:00001FA0
.text$mn:00001FA0                 push    ebp
.text$mn:00001FA1                 mov     ebp, esp
.text$mn:00001FA3                 push    ecx
.text$mn:00001FA4                 mov     [ebp+var_4], ecx
.text$mn:00001FA7                 mov     eax, [ebp+var_4]
.text$mn:00001FAA                 mov     ecx, [ebp+var_4]
.text$mn:00001FAD                 mov     eax, [eax+8]
.text$mn:00001FB0                 sub     eax, [ecx+4]
.text$mn:00001FB3                 cdq
.text$mn:00001FB4                 mov     ecx, 2Ch ; ','
.text$mn:00001FB9                 idiv    ecx
.text$mn:00001FBB                 mov     esp, ebp
.text$mn:00001FBD                 pop     ebp
.text$mn:00001FBE                 retn
.text$mn:00001FBE ?size@?$vector@UTaskLstFnStatus@@V?$allocator@UTaskLstFnStatus@@@std@@@std@@QBEIXZ endp
.text$mn:00001FBE
.text$mn:00001FBE ; ---------------------------------------------------------------------------
.text$mn:00001FBF                 align 10h
.text$mn:00001FBF _text$mn        ends
.text$mn:00001FBF
.text$mn:00001FC0 ; ===========================================================================
.text$mn:00001FC0
.text$mn:00001FC0 ; Segment type: Pure code
.text$mn:00001FC0 ; Segment permissions: Read/Execute
.text$mn:00001FC0 _text$mn        segment para public 'CODE' use32
.text$mn:00001FC0                 assume cs:_text$mn
.text$mn:00001FC0                 ;org 1FC0h
.text$mn:00001FC0 ; COMDAT (pick any)
.text$mn:00001FC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FC0
.text$mn:00001FC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FC0
.text$mn:00001FC0 ; Attributes: bp-based frame
.text$mn:00001FC0
.text$mn:00001FC0 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00001FC0                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00001FC0 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00001FC0                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_1AA0p
.text$mn:00001FC0                 push    ebp
.text$mn:00001FC1                 mov     ebp, esp
.text$mn:00001FC3                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00001FC8                 pop     ebp
.text$mn:00001FC9                 retn
.text$mn:00001FC9 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00001FC9
.text$mn:00001FC9 ; ---------------------------------------------------------------------------
.text$mn:00001FCA                 align 4
.text$mn:00001FCA _text$mn        ends
.text$mn:00001FCA
.text$mn:00001FCC ; ===========================================================================
.text$mn:00001FCC
.text$mn:00001FCC ; Segment type: Pure code
.text$mn:00001FCC ; Segment permissions: Read/Execute
.text$mn:00001FCC _text$mn        segment para public 'CODE' use32
.text$mn:00001FCC                 assume cs:_text$mn
.text$mn:00001FCC                 ;org 1FCCh
.text$mn:00001FCC ; COMDAT (pick any)
.text$mn:00001FCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FCC
.text$mn:00001FCC ; =============== S U B R O U T I N E =======================================
.text$mn:00001FCC
.text$mn:00001FCC ; Attributes: bp-based frame
.text$mn:00001FCC
.text$mn:00001FCC ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00001FCC                 public ?value@error_code@std@@QBEHXZ
.text$mn:00001FCC ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00001FCC
.text$mn:00001FCC var_4           = dword ptr -4
.text$mn:00001FCC
.text$mn:00001FCC                 push    ebp
.text$mn:00001FCD                 mov     ebp, esp
.text$mn:00001FCF                 push    ecx
.text$mn:00001FD0                 mov     [ebp+var_4], ecx
.text$mn:00001FD3                 mov     eax, [ebp+var_4]
.text$mn:00001FD6                 mov     eax, [eax]
.text$mn:00001FD8                 mov     esp, ebp
.text$mn:00001FDA                 pop     ebp
.text$mn:00001FDB                 retn
.text$mn:00001FDB ?value@error_code@std@@QBEHXZ endp
.text$mn:00001FDB
.text$mn:00001FDB _text$mn        ends
.text$mn:00001FDB
.text$mn:00001FDC ; ===========================================================================
.text$mn:00001FDC
.text$mn:00001FDC ; Segment type: Pure code
.text$mn:00001FDC ; Segment permissions: Read/Execute
.text$mn:00001FDC _text$mn        segment para public 'CODE' use32
.text$mn:00001FDC                 assume cs:_text$mn
.text$mn:00001FDC                 ;org 1FDCh
.text$mn:00001FDC ; COMDAT (pick any)
.text$mn:00001FDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FDC
.text$mn:00001FDC ; =============== S U B R O U T I N E =======================================
.text$mn:00001FDC
.text$mn:00001FDC ; Attributes: bp-based frame
.text$mn:00001FDC
.text$mn:00001FDC ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00001FDC                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00001FDC ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00001FDC                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00001FDC                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00001FDC
.text$mn:00001FDC var_4           = dword ptr -4
.text$mn:00001FDC
.text$mn:00001FDC                 push    ebp
.text$mn:00001FDD                 mov     ebp, esp
.text$mn:00001FDF                 push    ecx
.text$mn:00001FE0                 mov     [ebp+var_4], ecx
.text$mn:00001FE3                 mov     eax, [ebp+var_4]
.text$mn:00001FE6                 mov     eax, [eax]
.text$mn:00001FE8                 mov     esp, ebp
.text$mn:00001FEA                 pop     ebp
.text$mn:00001FEB                 retn
.text$mn:00001FEB ?value@error_condition@std@@QBEHXZ endp
.text$mn:00001FEB
.text$mn:00001FEB _text$mn        ends
.text$mn:00001FEB
.text$mn:00001FEC ; ===========================================================================
.text$mn:00001FEC
.text$mn:00001FEC ; Segment type: Pure code
.text$mn:00001FEC ; Segment permissions: Read/Execute
.text$mn:00001FEC _text$mn        segment para public 'CODE' use32
.text$mn:00001FEC                 assume cs:_text$mn
.text$mn:00001FEC                 ;org 1FECh
.text$mn:00001FEC ; COMDAT (pick any)
.text$mn:00001FEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FEC
.text$mn:00001FEC ; =============== S U B R O U T I N E =======================================
.text$mn:00001FEC
.text$mn:00001FEC ; Attributes: bp-based frame
.text$mn:00001FEC
.text$mn:00001FEC                 public _hypot
.text$mn:00001FEC _hypot          proc near
.text$mn:00001FEC
.text$mn:00001FEC var_10          = qword ptr -10h
.text$mn:00001FEC var_8           = qword ptr -8
.text$mn:00001FEC arg_0           = qword ptr  8
.text$mn:00001FEC arg_8           = qword ptr  10h
.text$mn:00001FEC
.text$mn:00001FEC                 push    ebp
.text$mn:00001FED                 mov     ebp, esp
.text$mn:00001FEF                 sub     esp, 8
.text$mn:00001FF2                 movsd   xmm0, [ebp+arg_8]
.text$mn:00001FF7                 movsd   [esp+8+var_8], xmm0
.text$mn:00001FFC                 sub     esp, 8
.text$mn:00001FFF                 movsd   xmm0, [ebp+arg_0]
.text$mn:00002004                 movsd   [esp+10h+var_10], xmm0
.text$mn:00002009                 call    __hypot
.text$mn:0000200E                 add     esp, 10h
.text$mn:00002011                 pop     ebp
.text$mn:00002012                 retn
.text$mn:00002012 _hypot          endp
.text$mn:00002012
.text$mn:00002012 ; ---------------------------------------------------------------------------
.text$mn:00002013                 align 4
.text$mn:00002013 _text$mn        ends
.text$mn:00002013
.xdata$x:00002014 ; ===========================================================================
.xdata$x:00002014
.xdata$x:00002014 ; Segment type: Pure data
.xdata$x:00002014 ; Segment permissions: Read
.xdata$x:00002014 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002014                 assume cs:_xdata$x
.xdata$x:00002014                 ;org 2014h
.xdata$x:00002014 ; COMDAT (pick associative to section at 1630)
.xdata$x:00002014 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00002014                                         ; DATA XREF: .xdata$x:00002024o
.xdata$x:00002015                 db 0FFh
.xdata$x:00002016                 db 0FFh
.xdata$x:00002017                 db 0FFh
.xdata$x:00002018                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:0000201C __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:0000201C                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:0000201D                 db    5
.xdata$x:0000201E                 db  93h ; ô
.xdata$x:0000201F                 db  19h
.xdata$x:00002020                 db    1
.xdata$x:00002021                 db    0
.xdata$x:00002022                 db    0
.xdata$x:00002023                 db    0
.xdata$x:00002024                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00002028                 align 20h
.xdata$x:00002028 _xdata$x        ends
.xdata$x:00002028
.xdata$x:00002040 ; ===========================================================================
.xdata$x:00002040
.xdata$x:00002040 ; Segment type: Pure data
.xdata$x:00002040 ; Segment permissions: Read
.xdata$x:00002040 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002040                 assume cs:_xdata$x
.xdata$x:00002040                 ;org 2040h
.xdata$x:00002040 ; COMDAT (pick associative to section at 8F8)
.xdata$x:00002040 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002040                                         ; DATA XREF: .xdata$x:00002050o
.xdata$x:00002041                 db 0FFh
.xdata$x:00002042                 db 0FFh
.xdata$x:00002043                 db 0FFh
.xdata$x:00002044                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002048 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002048                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002049                 db    5
.xdata$x:0000204A                 db  93h ; ô
.xdata$x:0000204B                 db  19h
.xdata$x:0000204C                 db    1
.xdata$x:0000204D                 db    0
.xdata$x:0000204E                 db    0
.xdata$x:0000204F                 db    0
.xdata$x:00002050                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002054                 db    0
.xdata$x:00002055                 db    0
.xdata$x:00002056                 db    0
.xdata$x:00002057                 db    0
.xdata$x:00002058                 db    0
.xdata$x:00002059                 db    0
.xdata$x:0000205A                 db    0
.xdata$x:0000205B                 db    0
.xdata$x:0000205C                 db    0
.xdata$x:0000205D                 db    0
.xdata$x:0000205E                 db    0
.xdata$x:0000205F                 db    0
.xdata$x:00002060                 db    0
.xdata$x:00002061                 db    0
.xdata$x:00002062                 db    0
.xdata$x:00002063                 db    0
.xdata$x:00002064                 db    0
.xdata$x:00002065                 db    0
.xdata$x:00002066                 db    0
.xdata$x:00002067                 db    0
.xdata$x:00002068                 db    0
.xdata$x:00002069                 db    0
.xdata$x:0000206A                 db    0
.xdata$x:0000206B                 db    0
.xdata$x:0000206B _xdata$x        ends
.xdata$x:0000206B
.xdata$x:0000206C ; ===========================================================================
.xdata$x:0000206C
.xdata$x:0000206C ; Segment type: Pure data
.xdata$x:0000206C ; Segment permissions: Read
.xdata$x:0000206C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000206C                 assume cs:_xdata$x
.xdata$x:0000206C                 ;org 206Ch
.xdata$x:0000206C ; COMDAT (pick associative to section at CCC)
.xdata$x:0000206C __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000206C                                         ; DATA XREF: .xdata$x:0000207Co
.xdata$x:0000206D                 db 0FFh
.xdata$x:0000206E                 db 0FFh
.xdata$x:0000206F                 db 0FFh
.xdata$x:00002070                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002074 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002074                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002075                 db    5
.xdata$x:00002076                 db  93h ; ô
.xdata$x:00002077                 db  19h
.xdata$x:00002078                 db    1
.xdata$x:00002079                 db    0
.xdata$x:0000207A                 db    0
.xdata$x:0000207B                 db    0
.xdata$x:0000207C                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002080                 db    0
.xdata$x:00002081                 db    0
.xdata$x:00002082                 db    0
.xdata$x:00002083                 db    0
.xdata$x:00002084                 db    0
.xdata$x:00002085                 db    0
.xdata$x:00002086                 db    0
.xdata$x:00002087                 db    0
.xdata$x:00002088                 db    0
.xdata$x:00002089                 db    0
.xdata$x:0000208A                 db    0
.xdata$x:0000208B                 db    0
.xdata$x:0000208C                 db    0
.xdata$x:0000208D                 db    0
.xdata$x:0000208E                 db    0
.xdata$x:0000208F                 db    0
.xdata$x:00002090                 db    0
.xdata$x:00002091                 db    0
.xdata$x:00002092                 db    0
.xdata$x:00002093                 db    0
.xdata$x:00002094                 db    0
.xdata$x:00002095                 db    0
.xdata$x:00002096                 db    0
.xdata$x:00002097                 db    0
.xdata$x:00002097 _xdata$x        ends
.xdata$x:00002097
.xdata$x:00002098 ; ===========================================================================
.xdata$x:00002098
.xdata$x:00002098 ; Segment type: Pure data
.xdata$x:00002098 ; Segment permissions: Read
.xdata$x:00002098 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002098                 assume cs:_xdata$x
.xdata$x:00002098                 ;org 2098h
.xdata$x:00002098 ; COMDAT (pick associative to section at 87C)
.xdata$x:00002098 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00002098                                         ; DATA XREF: .xdata$x:000020A8o
.xdata$x:00002099                 db 0FFh
.xdata$x:0000209A                 db 0FFh
.xdata$x:0000209B                 db 0FFh
.xdata$x:0000209C                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:000020A0 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:000020A0                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:000020A1                 db    5
.xdata$x:000020A2                 db  93h ; ô
.xdata$x:000020A3                 db  19h
.xdata$x:000020A4                 db    1
.xdata$x:000020A5                 db    0
.xdata$x:000020A6                 db    0
.xdata$x:000020A7                 db    0
.xdata$x:000020A8                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:000020AC                 db    0
.xdata$x:000020AD                 db    0
.xdata$x:000020AE                 db    0
.xdata$x:000020AF                 db    0
.xdata$x:000020B0                 db    0
.xdata$x:000020B1                 db    0
.xdata$x:000020B2                 db    0
.xdata$x:000020B3                 db    0
.xdata$x:000020B4                 db    0
.xdata$x:000020B5                 db    0
.xdata$x:000020B6                 db    0
.xdata$x:000020B7                 db    0
.xdata$x:000020B8                 db    0
.xdata$x:000020B9                 db    0
.xdata$x:000020BA                 db    0
.xdata$x:000020BB                 db    0
.xdata$x:000020BC                 db    0
.xdata$x:000020BD                 db    0
.xdata$x:000020BE                 db    0
.xdata$x:000020BF                 db    0
.xdata$x:000020C0                 db    0
.xdata$x:000020C1                 db    0
.xdata$x:000020C2                 db    0
.xdata$x:000020C3                 db    0
.xdata$x:000020C3 _xdata$x        ends
.xdata$x:000020C3
.xdata$x:000020C4 ; ===========================================================================
.xdata$x:000020C4
.xdata$x:000020C4 ; Segment type: Pure data
.xdata$x:000020C4 ; Segment permissions: Read
.xdata$x:000020C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000020C4                 assume cs:_xdata$x
.xdata$x:000020C4                 ;org 20C4h
.xdata$x:000020C4 ; COMDAT (pick associative to section at C54)
.xdata$x:000020C4 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000020C4                                         ; DATA XREF: .xdata$x:000020D4o
.xdata$x:000020C5                 db 0FFh
.xdata$x:000020C6                 db 0FFh
.xdata$x:000020C7                 db 0FFh
.xdata$x:000020C8                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000020CC __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000020CC                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000020CD                 db    5
.xdata$x:000020CE                 db  93h ; ô
.xdata$x:000020CF                 db  19h
.xdata$x:000020D0                 db    1
.xdata$x:000020D1                 db    0
.xdata$x:000020D2                 db    0
.xdata$x:000020D3                 db    0
.xdata$x:000020D4                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:000020D8                 db    0
.xdata$x:000020D9                 db    0
.xdata$x:000020DA                 db    0
.xdata$x:000020DB                 db    0
.xdata$x:000020DC                 db    0
.xdata$x:000020DD                 db    0
.xdata$x:000020DE                 db    0
.xdata$x:000020DF                 db    0
.xdata$x:000020E0                 db    0
.xdata$x:000020E1                 db    0
.xdata$x:000020E2                 db    0
.xdata$x:000020E3                 db    0
.xdata$x:000020E4                 db    0
.xdata$x:000020E5                 db    0
.xdata$x:000020E6                 db    0
.xdata$x:000020E7                 db    0
.xdata$x:000020E8                 db    0
.xdata$x:000020E9                 db    0
.xdata$x:000020EA                 db    0
.xdata$x:000020EB                 db    0
.xdata$x:000020EC                 db    0
.xdata$x:000020ED                 db    0
.xdata$x:000020EE                 db    0
.xdata$x:000020EF                 db    0
.xdata$x:000020EF _xdata$x        ends
.xdata$x:000020EF
.xdata$x:000020F0 ; ===========================================================================
.xdata$x:000020F0
.xdata$x:000020F0 ; Segment type: Pure data
.xdata$x:000020F0 ; Segment permissions: Read
.xdata$x:000020F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000020F0                 assume cs:_xdata$x
.xdata$x:000020F0                 ;org 20F0h
.xdata$x:000020F0 ; COMDAT (pick associative to section at 9B8)
.xdata$x:000020F0 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:000020F0                                         ; DATA XREF: .xdata$x:00002100o
.xdata$x:000020F1                 db 0FFh
.xdata$x:000020F2                 db 0FFh
.xdata$x:000020F3                 db 0FFh
.xdata$x:000020F4                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:000020F8 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:000020F8                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:000020F9                 db    5
.xdata$x:000020FA                 db  93h ; ô
.xdata$x:000020FB                 db  19h
.xdata$x:000020FC                 db    1
.xdata$x:000020FD                 db    0
.xdata$x:000020FE                 db    0
.xdata$x:000020FF                 db    0
.xdata$x:00002100                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00002104                 db    0
.xdata$x:00002105                 db    0
.xdata$x:00002106                 db    0
.xdata$x:00002107                 db    0
.xdata$x:00002108                 db    0
.xdata$x:00002109                 db    0
.xdata$x:0000210A                 db    0
.xdata$x:0000210B                 db    0
.xdata$x:0000210C                 db    0
.xdata$x:0000210D                 db    0
.xdata$x:0000210E                 db    0
.xdata$x:0000210F                 db    0
.xdata$x:00002110                 db    0
.xdata$x:00002111                 db    0
.xdata$x:00002112                 db    0
.xdata$x:00002113                 db    0
.xdata$x:00002114                 db    0
.xdata$x:00002115                 db    0
.xdata$x:00002116                 db    0
.xdata$x:00002117                 db    0
.xdata$x:00002118                 db    0
.xdata$x:00002119                 db    0
.xdata$x:0000211A                 db    0
.xdata$x:0000211B                 db    0
.xdata$x:0000211B _xdata$x        ends
.xdata$x:0000211B
.xdata$x:0000211C ; ===========================================================================
.xdata$x:0000211C
.xdata$x:0000211C ; Segment type: Pure data
.xdata$x:0000211C ; Segment permissions: Read
.xdata$x:0000211C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000211C                 assume cs:_xdata$x
.xdata$x:0000211C                 ;org 211Ch
.xdata$x:0000211C ; COMDAT (pick associative to section at D3C)
.xdata$x:0000211C __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000211C                                         ; DATA XREF: .xdata$x:0000212Co
.xdata$x:0000211D                 db 0FFh
.xdata$x:0000211E                 db 0FFh
.xdata$x:0000211F                 db 0FFh
.xdata$x:00002120                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00002124 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00002124                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00002125                 db    5
.xdata$x:00002126                 db  93h ; ô
.xdata$x:00002127                 db  19h
.xdata$x:00002128                 db    1
.xdata$x:00002129                 db    0
.xdata$x:0000212A                 db    0
.xdata$x:0000212B                 db    0
.xdata$x:0000212C                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00002130                 db    0
.xdata$x:00002131                 db    0
.xdata$x:00002132                 db    0
.xdata$x:00002133                 db    0
.xdata$x:00002134                 db    0
.xdata$x:00002135                 db    0
.xdata$x:00002136                 db    0
.xdata$x:00002137                 db    0
.xdata$x:00002138                 db    0
.xdata$x:00002139                 db    0
.xdata$x:0000213A                 db    0
.xdata$x:0000213B                 db    0
.xdata$x:0000213C                 db    0
.xdata$x:0000213D                 db    0
.xdata$x:0000213E                 db    0
.xdata$x:0000213F                 db    0
.xdata$x:00002140                 db    0
.xdata$x:00002141                 db    0
.xdata$x:00002142                 db    0
.xdata$x:00002143                 db    0
.xdata$x:00002144                 db    0
.xdata$x:00002145                 db    0
.xdata$x:00002146                 db    0
.xdata$x:00002147                 db    0
.xdata$x:00002147 _xdata$x        ends
.xdata$x:00002147
.xdata$x:00002148 ; ===========================================================================
.xdata$x:00002148
.xdata$x:00002148 ; Segment type: Pure data
.xdata$x:00002148 ; Segment permissions: Read
.xdata$x:00002148 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002148                 assume cs:_xdata$x
.xdata$x:00002148                 ;org 2148h
.xdata$x:00002148 ; COMDAT (pick associative to section at 1254)
.xdata$x:00002148 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00002148                                         ; DATA XREF: .xdata$x:000021D0o
.xdata$x:00002149                 db    0
.xdata$x:0000214A                 db    0
.xdata$x:0000214B                 db    0
.xdata$x:0000214C                 db    0
.xdata$x:0000214D                 db    0
.xdata$x:0000214E                 db    0
.xdata$x:0000214F                 db    0
.xdata$x:00002150                 db    0
.xdata$x:00002151                 db    0
.xdata$x:00002152                 db    0
.xdata$x:00002153                 db    0
.xdata$x:00002154                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00002158 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00002158                                         ; DATA XREF: .xdata$x:000021BCo
.xdata$x:00002159                 db    0
.xdata$x:0000215A                 db    0
.xdata$x:0000215B                 db    0
.xdata$x:0000215C                 db    0
.xdata$x:0000215D                 db    0
.xdata$x:0000215E                 db    0
.xdata$x:0000215F                 db    0
.xdata$x:00002160                 db    0
.xdata$x:00002161                 db    0
.xdata$x:00002162                 db    0
.xdata$x:00002163                 db    0
.xdata$x:00002164                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00002168 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00002168                                         ; DATA XREF: .xdata$x:00002190o
.xdata$x:00002169                 db 0FFh
.xdata$x:0000216A                 db 0FFh
.xdata$x:0000216B                 db 0FFh
.xdata$x:0000216C                 db    0
.xdata$x:0000216D                 db    0
.xdata$x:0000216E                 db    0
.xdata$x:0000216F                 db    0
.xdata$x:00002170                 db 0FFh
.xdata$x:00002171                 db 0FFh
.xdata$x:00002172                 db 0FFh
.xdata$x:00002173                 db 0FFh
.xdata$x:00002174                 db    0
.xdata$x:00002175                 db    0
.xdata$x:00002176                 db    0
.xdata$x:00002177                 db    0
.xdata$x:00002178                 db    1
.xdata$x:00002179                 db    0
.xdata$x:0000217A                 db    0
.xdata$x:0000217B                 db    0
.xdata$x:0000217C                 db    0
.xdata$x:0000217D                 db    0
.xdata$x:0000217E                 db    0
.xdata$x:0000217F                 db    0
.xdata$x:00002180                 db    1
.xdata$x:00002181                 db    0
.xdata$x:00002182                 db    0
.xdata$x:00002183                 db    0
.xdata$x:00002184                 db    0
.xdata$x:00002185                 db    0
.xdata$x:00002186                 db    0
.xdata$x:00002187                 db    0
.xdata$x:00002188 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00002188                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00002189                 db    5
.xdata$x:0000218A                 db  93h ; ô
.xdata$x:0000218B                 db  19h
.xdata$x:0000218C                 db    4
.xdata$x:0000218D                 db    0
.xdata$x:0000218E                 db    0
.xdata$x:0000218F                 db    0
.xdata$x:00002190                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002194                 db    2
.xdata$x:00002195                 db    0
.xdata$x:00002196                 db    0
.xdata$x:00002197                 db    0
.xdata$x:00002198                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:0000219C                 db    0
.xdata$x:0000219D                 db    0
.xdata$x:0000219E                 db    0
.xdata$x:0000219F                 db    0
.xdata$x:000021A0                 db    0
.xdata$x:000021A1                 db    0
.xdata$x:000021A2                 db    0
.xdata$x:000021A3                 db    0
.xdata$x:000021A4                 db    0
.xdata$x:000021A5                 db    0
.xdata$x:000021A6                 db    0
.xdata$x:000021A7                 db    0
.xdata$x:000021A8                 db    0
.xdata$x:000021A9                 db    0
.xdata$x:000021AA                 db    0
.xdata$x:000021AB                 db    0
.xdata$x:000021AC __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:000021AC                                         ; DATA XREF: .xdata$x:00002198o
.xdata$x:000021AD                 db    0
.xdata$x:000021AE                 db    0
.xdata$x:000021AF                 db    0
.xdata$x:000021B0                 db    2
.xdata$x:000021B1                 db    0
.xdata$x:000021B2                 db    0
.xdata$x:000021B3                 db    0
.xdata$x:000021B4                 db    3
.xdata$x:000021B5                 db    0
.xdata$x:000021B6                 db    0
.xdata$x:000021B7                 db    0
.xdata$x:000021B8                 db    1
.xdata$x:000021B9                 db    0
.xdata$x:000021BA                 db    0
.xdata$x:000021BB                 db    0
.xdata$x:000021BC                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:000021C0                 db    0
.xdata$x:000021C1                 db    0
.xdata$x:000021C2                 db    0
.xdata$x:000021C3                 db    0
.xdata$x:000021C4                 db    0
.xdata$x:000021C5                 db    0
.xdata$x:000021C6                 db    0
.xdata$x:000021C7                 db    0
.xdata$x:000021C8                 db    3
.xdata$x:000021C9                 db    0
.xdata$x:000021CA                 db    0
.xdata$x:000021CB                 db    0
.xdata$x:000021CC                 db    1
.xdata$x:000021CD                 db    0
.xdata$x:000021CE                 db    0
.xdata$x:000021CF                 db    0
.xdata$x:000021D0                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:000021D0 _xdata$x        ends
.xdata$x:000021D0
.xdata$x:000021D4 ; ===========================================================================
.xdata$x:000021D4
.xdata$x:000021D4 ; Segment type: Pure data
.xdata$x:000021D4 ; Segment permissions: Read
.xdata$x:000021D4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000021D4                 assume cs:_xdata$x
.xdata$x:000021D4                 ;org 21D4h
.xdata$x:000021D4 ; COMDAT (pick associative to section at A8C)
.xdata$x:000021D4 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000021D4                                         ; DATA XREF: .xdata$x:000021E4o
.xdata$x:000021D5                 db 0FFh
.xdata$x:000021D6                 db 0FFh
.xdata$x:000021D7                 db 0FFh
.xdata$x:000021D8                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:000021DC __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000021DC                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:000021DD                 db    5
.xdata$x:000021DE                 db  93h ; ô
.xdata$x:000021DF                 db  19h
.xdata$x:000021E0                 db    1
.xdata$x:000021E1                 db    0
.xdata$x:000021E2                 db    0
.xdata$x:000021E3                 db    0
.xdata$x:000021E4                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:000021E8                 align 20h
.xdata$x:000021E8 _xdata$x        ends
.xdata$x:000021E8
.xdata$x:00002200 ; ===========================================================================
.xdata$x:00002200
.xdata$x:00002200 ; Segment type: Pure data
.xdata$x:00002200 ; Segment permissions: Read
.xdata$x:00002200 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002200                 assume cs:_xdata$x
.xdata$x:00002200                 ;org 2200h
.xdata$x:00002200 ; COMDAT (pick associative to section at 1CF8)
.xdata$x:00002200 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002200                                         ; DATA XREF: .xdata$x:00002210o
.xdata$x:00002201                 db 0FFh
.xdata$x:00002202                 db 0FFh
.xdata$x:00002203                 db 0FFh
.xdata$x:00002204                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002208 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002208                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002209                 db    5
.xdata$x:0000220A                 db  93h ; ô
.xdata$x:0000220B                 db  19h
.xdata$x:0000220C                 db    1
.xdata$x:0000220D                 db    0
.xdata$x:0000220E                 db    0
.xdata$x:0000220F                 db    0
.xdata$x:00002210                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002214                 db    0
.xdata$x:00002215                 db    0
.xdata$x:00002216                 db    0
.xdata$x:00002217                 db    0
.xdata$x:00002218                 db    0
.xdata$x:00002219                 db    0
.xdata$x:0000221A                 db    0
.xdata$x:0000221B                 db    0
.xdata$x:0000221C                 db    0
.xdata$x:0000221D                 db    0
.xdata$x:0000221E                 db    0
.xdata$x:0000221F                 db    0
.xdata$x:00002220                 db    0
.xdata$x:00002221                 db    0
.xdata$x:00002222                 db    0
.xdata$x:00002223                 db    0
.xdata$x:00002224                 db    0
.xdata$x:00002225                 db    0
.xdata$x:00002226                 db    0
.xdata$x:00002227                 db    0
.xdata$x:00002228                 db    0
.xdata$x:00002229                 db    0
.xdata$x:0000222A                 db    0
.xdata$x:0000222B                 db    0
.xdata$x:0000222B _xdata$x        ends
.xdata$x:0000222B
.xdata$x:0000222C ; ===========================================================================
.xdata$x:0000222C
.xdata$x:0000222C ; Segment type: Pure data
.xdata$x:0000222C ; Segment permissions: Read
.xdata$x:0000222C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000222C                 assume cs:_xdata$x
.xdata$x:0000222C                 ;org 222Ch
.xdata$x:0000222C ; COMDAT (pick associative to section at DCC)
.xdata$x:0000222C __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000222C                                         ; DATA XREF: .xdata$x:0000223Co
.xdata$x:0000222D                 db 0FFh
.xdata$x:0000222E                 db 0FFh
.xdata$x:0000222F                 db 0FFh
.xdata$x:00002230                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00002234 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002234                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00002235                 db    5
.xdata$x:00002236                 db  93h ; ô
.xdata$x:00002237                 db  19h
.xdata$x:00002238                 db    1
.xdata$x:00002239                 db    0
.xdata$x:0000223A                 db    0
.xdata$x:0000223B                 db    0
.xdata$x:0000223C                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00002240                 db    0
.xdata$x:00002241                 db    0
.xdata$x:00002242                 db    0
.xdata$x:00002243                 db    0
.xdata$x:00002244                 db    0
.xdata$x:00002245                 db    0
.xdata$x:00002246                 db    0
.xdata$x:00002247                 db    0
.xdata$x:00002248                 db    0
.xdata$x:00002249                 db    0
.xdata$x:0000224A                 db    0
.xdata$x:0000224B                 db    0
.xdata$x:0000224C                 db    0
.xdata$x:0000224D                 db    0
.xdata$x:0000224E                 db    0
.xdata$x:0000224F                 db    0
.xdata$x:00002250                 db    0
.xdata$x:00002251                 db    0
.xdata$x:00002252                 db    0
.xdata$x:00002253                 db    0
.xdata$x:00002254                 db    0
.xdata$x:00002255                 db    0
.xdata$x:00002256                 db    0
.xdata$x:00002257                 db    0
.xdata$x:00002257 _xdata$x        ends
.xdata$x:00002257
.xdata$x:00002258 ; ===========================================================================
.xdata$x:00002258
.xdata$x:00002258 ; Segment type: Pure data
.xdata$x:00002258 ; Segment permissions: Read
.xdata$x:00002258 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002258                 assume cs:_xdata$x
.xdata$x:00002258                 ;org 2258h
.xdata$x:00002258 ; COMDAT (pick associative to section at B08)
.xdata$x:00002258 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002258                                         ; DATA XREF: .xdata$x:00002268o
.xdata$x:00002259                 db 0FFh
.xdata$x:0000225A                 db 0FFh
.xdata$x:0000225B                 db 0FFh
.xdata$x:0000225C                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00002260 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002260                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00002261                 db    5
.xdata$x:00002262                 db  93h ; ô
.xdata$x:00002263                 db  19h
.xdata$x:00002264                 db    1
.xdata$x:00002265                 db    0
.xdata$x:00002266                 db    0
.xdata$x:00002267                 db    0
.xdata$x:00002268                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:0000226C                 db    0
.xdata$x:0000226D                 db    0
.xdata$x:0000226E                 db    0
.xdata$x:0000226F                 db    0
.xdata$x:00002270                 db    0
.xdata$x:00002271                 db    0
.xdata$x:00002272                 db    0
.xdata$x:00002273                 db    0
.xdata$x:00002274                 db    0
.xdata$x:00002275                 db    0
.xdata$x:00002276                 db    0
.xdata$x:00002277                 db    0
.xdata$x:00002278                 db    0
.xdata$x:00002279                 db    0
.xdata$x:0000227A                 db    0
.xdata$x:0000227B                 db    0
.xdata$x:0000227C                 db    0
.xdata$x:0000227D                 db    0
.xdata$x:0000227E                 db    0
.xdata$x:0000227F                 db    0
.xdata$x:00002280                 db    0
.xdata$x:00002281                 db    0
.xdata$x:00002282                 db    0
.xdata$x:00002283                 db    0
.xdata$x:00002283 _xdata$x        ends
.xdata$x:00002283
.xdata$x:00002284 ; ===========================================================================
.xdata$x:00002284
.xdata$x:00002284 ; Segment type: Pure data
.xdata$x:00002284 ; Segment permissions: Read
.xdata$x:00002284 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002284                 assume cs:_xdata$x
.xdata$x:00002284                 ;org 2284h
.xdata$x:00002284 ; COMDAT (pick associative to section at 1DB0)
.xdata$x:00002284 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002284                                         ; DATA XREF: .xdata$x:00002294o
.xdata$x:00002285                 db 0FFh
.xdata$x:00002286                 db 0FFh
.xdata$x:00002287                 db 0FFh
.xdata$x:00002288                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000228C __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000228C                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000228D                 db    5
.xdata$x:0000228E                 db  93h ; ô
.xdata$x:0000228F                 db  19h
.xdata$x:00002290                 db    1
.xdata$x:00002291                 db    0
.xdata$x:00002292                 db    0
.xdata$x:00002293                 db    0
.xdata$x:00002294                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002298                 db    0
.xdata$x:00002299                 db    0
.xdata$x:0000229A                 db    0
.xdata$x:0000229B                 db    0
.xdata$x:0000229C                 db    0
.xdata$x:0000229D                 db    0
.xdata$x:0000229E                 db    0
.xdata$x:0000229F                 db    0
.xdata$x:000022A0                 db    0
.xdata$x:000022A1                 db    0
.xdata$x:000022A2                 db    0
.xdata$x:000022A3                 db    0
.xdata$x:000022A4                 db    0
.xdata$x:000022A5                 db    0
.xdata$x:000022A6                 db    0
.xdata$x:000022A7                 db    0
.xdata$x:000022A8                 db    0
.xdata$x:000022A9                 db    0
.xdata$x:000022AA                 db    0
.xdata$x:000022AB                 db    0
.xdata$x:000022AC                 db    0
.xdata$x:000022AD                 db    0
.xdata$x:000022AE                 db    0
.xdata$x:000022AF                 db    0
.xdata$x:000022AF _xdata$x        ends
.xdata$x:000022AF
.xdata$x:000022B0 ; ===========================================================================
.xdata$x:000022B0
.xdata$x:000022B0 ; Segment type: Pure data
.xdata$x:000022B0 ; Segment permissions: Read
.xdata$x:000022B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000022B0                 assume cs:_xdata$x
.xdata$x:000022B0                 ;org 22B0h
.xdata$x:000022B0 ; COMDAT (pick associative to section at E3C)
.xdata$x:000022B0 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000022B0                                         ; DATA XREF: .xdata$x:000022C0o
.xdata$x:000022B1                 db 0FFh
.xdata$x:000022B2                 db 0FFh
.xdata$x:000022B3                 db 0FFh
.xdata$x:000022B4                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:000022B8 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000022B8                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:000022B9                 db    5
.xdata$x:000022BA                 db  93h ; ô
.xdata$x:000022BB                 db  19h
.xdata$x:000022BC                 db    1
.xdata$x:000022BD                 db    0
.xdata$x:000022BE                 db    0
.xdata$x:000022BF                 db    0
.xdata$x:000022C0                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:000022C4                 db    0
.xdata$x:000022C5                 db    0
.xdata$x:000022C6                 db    0
.xdata$x:000022C7                 db    0
.xdata$x:000022C8                 db    0
.xdata$x:000022C9                 db    0
.xdata$x:000022CA                 db    0
.xdata$x:000022CB                 db    0
.xdata$x:000022CC                 db    0
.xdata$x:000022CD                 db    0
.xdata$x:000022CE                 db    0
.xdata$x:000022CF                 db    0
.xdata$x:000022D0                 db    0
.xdata$x:000022D1                 db    0
.xdata$x:000022D2                 db    0
.xdata$x:000022D3                 db    0
.xdata$x:000022D4                 db    0
.xdata$x:000022D5                 db    0
.xdata$x:000022D6                 db    0
.xdata$x:000022D7                 db    0
.xdata$x:000022D8                 db    0
.xdata$x:000022D9                 db    0
.xdata$x:000022DA                 db    0
.xdata$x:000022DB                 db    0
.xdata$x:000022DB _xdata$x        ends
.xdata$x:000022DB
.xdata$x:000022DC ; ===========================================================================
.xdata$x:000022DC
.xdata$x:000022DC ; Segment type: Pure data
.xdata$x:000022DC ; Segment permissions: Read
.xdata$x:000022DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000022DC                 assume cs:_xdata$x
.xdata$x:000022DC                 ;org 22DCh
.xdata$x:000022DC ; COMDAT (pick associative to section at B84)
.xdata$x:000022DC __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000022DC                                         ; DATA XREF: .xdata$x:000022ECo
.xdata$x:000022DD                 db 0FFh
.xdata$x:000022DE                 db 0FFh
.xdata$x:000022DF                 db 0FFh
.xdata$x:000022E0                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:000022E4 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000022E4                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:000022E5                 db    5
.xdata$x:000022E6                 db  93h ; ô
.xdata$x:000022E7                 db  19h
.xdata$x:000022E8                 db    1
.xdata$x:000022E9                 db    0
.xdata$x:000022EA                 db    0
.xdata$x:000022EB                 db    0
.xdata$x:000022EC                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:000022F0                 db    0
.xdata$x:000022F1                 db    0
.xdata$x:000022F2                 db    0
.xdata$x:000022F3                 db    0
.xdata$x:000022F4                 db    0
.xdata$x:000022F5                 db    0
.xdata$x:000022F6                 db    0
.xdata$x:000022F7                 db    0
.xdata$x:000022F8                 db    0
.xdata$x:000022F9                 db    0
.xdata$x:000022FA                 db    0
.xdata$x:000022FB                 db    0
.xdata$x:000022FC                 db    0
.xdata$x:000022FD                 db    0
.xdata$x:000022FE                 db    0
.xdata$x:000022FF                 db    0
.xdata$x:00002300                 db    0
.xdata$x:00002301                 db    0
.xdata$x:00002302                 db    0
.xdata$x:00002303                 db    0
.xdata$x:00002304                 db    0
.xdata$x:00002305                 db    0
.xdata$x:00002306                 db    0
.xdata$x:00002307                 db    0
.xdata$x:00002307 _xdata$x        ends
.xdata$x:00002307
.xdata$x:00002308 ; ===========================================================================
.xdata$x:00002308
.xdata$x:00002308 ; Segment type: Pure data
.xdata$x:00002308 ; Segment permissions: Read
.xdata$x:00002308 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002308                 assume cs:_xdata$x
.xdata$x:00002308                 ;org 2308h
.xdata$x:00002308 ; COMDAT (pick associative to section at 1E74)
.xdata$x:00002308 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002308                                         ; DATA XREF: .xdata$x:00002318o
.xdata$x:00002309                 db 0FFh
.xdata$x:0000230A                 db 0FFh
.xdata$x:0000230B                 db 0FFh
.xdata$x:0000230C                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002310 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002310                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002311                 db    5
.xdata$x:00002312                 db  93h ; ô
.xdata$x:00002313                 db  19h
.xdata$x:00002314                 db    1
.xdata$x:00002315                 db    0
.xdata$x:00002316                 db    0
.xdata$x:00002317                 db    0
.xdata$x:00002318                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000231C                 db    0
.xdata$x:0000231D                 db    0
.xdata$x:0000231E                 db    0
.xdata$x:0000231F                 db    0
.xdata$x:00002320                 db    0
.xdata$x:00002321                 db    0
.xdata$x:00002322                 db    0
.xdata$x:00002323                 db    0
.xdata$x:00002324                 db    0
.xdata$x:00002325                 db    0
.xdata$x:00002326                 db    0
.xdata$x:00002327                 db    0
.xdata$x:00002328                 db    0
.xdata$x:00002329                 db    0
.xdata$x:0000232A                 db    0
.xdata$x:0000232B                 db    0
.xdata$x:0000232C                 db    0
.xdata$x:0000232D                 db    0
.xdata$x:0000232E                 db    0
.xdata$x:0000232F                 db    0
.xdata$x:00002330                 db    0
.xdata$x:00002331                 db    0
.xdata$x:00002332                 db    0
.xdata$x:00002333                 db    0
.xdata$x:00002333 _xdata$x        ends
.xdata$x:00002333
.xdata$x:00002334 ; ===========================================================================
.xdata$x:00002334
.xdata$x:00002334 ; Segment type: Pure data
.xdata$x:00002334 ; Segment permissions: Read
.xdata$x:00002334 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002334                 assume cs:_xdata$x
.xdata$x:00002334                 ;org 2334h
.xdata$x:00002334 ; COMDAT (pick associative to section at EAC)
.xdata$x:00002334 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002334                                         ; DATA XREF: .xdata$x:00002344o
.xdata$x:00002335                 db 0FFh
.xdata$x:00002336                 db 0FFh
.xdata$x:00002337                 db 0FFh
.xdata$x:00002338                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:0000233C __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000233C                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:0000233D                 db    5
.xdata$x:0000233E                 db  93h ; ô
.xdata$x:0000233F                 db  19h
.xdata$x:00002340                 db    1
.xdata$x:00002341                 db    0
.xdata$x:00002342                 db    0
.xdata$x:00002343                 db    0
.xdata$x:00002344                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00002348                 align 20h
.xdata$x:00002348 _xdata$x        ends
.xdata$x:00002348
.xdata$x:00002360 ; ===========================================================================
.xdata$x:00002360
.xdata$x:00002360 ; Segment type: Pure data
.xdata$x:00002360 ; Segment permissions: Read
.xdata$x:00002360 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002360                 assume cs:_xdata$x
.xdata$x:00002360                 ;org 2360h
.xdata$x:00002360 ; COMDAT (pick associative to section at 760)
.xdata$x:00002360 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00002360                                         ; DATA XREF: .xdata$x:00002370o
.xdata$x:00002361                 db 0FFh
.xdata$x:00002362                 db 0FFh
.xdata$x:00002363                 db 0FFh
.xdata$x:00002364                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00002368 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00002368                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00002369                 db    5
.xdata$x:0000236A                 db  93h ; ô
.xdata$x:0000236B                 db  19h
.xdata$x:0000236C                 db    1
.xdata$x:0000236D                 db    0
.xdata$x:0000236E                 db    0
.xdata$x:0000236F                 db    0
.xdata$x:00002370                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00002374                 db    0
.xdata$x:00002375                 db    0
.xdata$x:00002376                 db    0
.xdata$x:00002377                 db    0
.xdata$x:00002378                 db    0
.xdata$x:00002379                 db    0
.xdata$x:0000237A                 db    0
.xdata$x:0000237B                 db    0
.xdata$x:0000237C                 db    0
.xdata$x:0000237D                 db    0
.xdata$x:0000237E                 db    0
.xdata$x:0000237F                 db    0
.xdata$x:00002380                 db    0
.xdata$x:00002381                 db    0
.xdata$x:00002382                 db    0
.xdata$x:00002383                 db    0
.xdata$x:00002384                 db    0
.xdata$x:00002385                 db    0
.xdata$x:00002386                 db    0
.xdata$x:00002387                 db    0
.xdata$x:00002388                 db    0
.xdata$x:00002389                 db    0
.xdata$x:0000238A                 db    0
.xdata$x:0000238B                 db    0
.xdata$x:0000238B _xdata$x        ends
.xdata$x:0000238B
.xdata$x:0000238C ; ===========================================================================
.xdata$x:0000238C
.xdata$x:0000238C ; Segment type: Pure data
.xdata$x:0000238C ; Segment permissions: Read
.xdata$x:0000238C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000238C                 assume cs:_xdata$x
.xdata$x:0000238C                 ;org 238Ch
.xdata$x:0000238C ; COMDAT (pick associative to section at 68C)
.xdata$x:0000238C __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:0000238C                                         ; DATA XREF: .xdata$x:0000239Co
.xdata$x:0000238D                 db 0FFh
.xdata$x:0000238E                 db 0FFh
.xdata$x:0000238F                 db 0FFh
.xdata$x:00002390                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00002394 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00002394                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00002395                 db    5
.xdata$x:00002396                 db  93h ; ô
.xdata$x:00002397                 db  19h
.xdata$x:00002398                 db    1
.xdata$x:00002399                 db    0
.xdata$x:0000239A                 db    0
.xdata$x:0000239B                 db    0
.xdata$x:0000239C                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:000023A0                 db    0
.xdata$x:000023A1                 db    0
.xdata$x:000023A2                 db    0
.xdata$x:000023A3                 db    0
.xdata$x:000023A4                 db    0
.xdata$x:000023A5                 db    0
.xdata$x:000023A6                 db    0
.xdata$x:000023A7                 db    0
.xdata$x:000023A8                 db    0
.xdata$x:000023A9                 db    0
.xdata$x:000023AA                 db    0
.xdata$x:000023AB                 db    0
.xdata$x:000023AC                 db    0
.xdata$x:000023AD                 db    0
.xdata$x:000023AE                 db    0
.xdata$x:000023AF                 db    0
.xdata$x:000023B0                 db    0
.xdata$x:000023B1                 db    0
.xdata$x:000023B2                 db    0
.xdata$x:000023B3                 db    0
.xdata$x:000023B4                 db    0
.xdata$x:000023B5                 db    0
.xdata$x:000023B6                 db    0
.xdata$x:000023B7                 db    0
.xdata$x:000023B7 _xdata$x        ends
.xdata$x:000023B7
.rdata:000023B8 ; ===========================================================================
.rdata:000023B8
.rdata:000023B8 ; Segment type: Pure data
.rdata:000023B8 ; Segment permissions: Read
.rdata:000023B8 _rdata          segment dword public 'DATA' use32
.rdata:000023B8                 assume cs:_rdata
.rdata:000023B8                 ;org 23B8h
.rdata:000023B8 ; COMDAT (pick largest)
.rdata:000023B8                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:000023BC                 public ??_7error_category@std@@6B@
.rdata:000023BC ; const std::error_category::`vftable'
.rdata:000023BC ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:000023BC                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:000023BC                                         ; std::error_category::~error_category(void)+Ao
.rdata:000023BC                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:000023C0                 dd offset __purecall
.rdata:000023C4                 dd offset __purecall
.rdata:000023C8                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:000023CC                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000023D0                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000023D0 _rdata          ends
.rdata:000023D0
.rdata:000023D4 ; ===========================================================================
.rdata:000023D4
.rdata:000023D4 ; Segment type: Pure data
.rdata:000023D4 ; Segment permissions: Read
.rdata:000023D4 _rdata          segment dword public 'DATA' use32
.rdata:000023D4                 assume cs:_rdata
.rdata:000023D4                 ;org 23D4h
.rdata:000023D4 ; COMDAT (pick largest)
.rdata:000023D4                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:000023D8                 public ??_7_Generic_error_category@std@@6B@
.rdata:000023D8 ; const std::_Generic_error_category::`vftable'
.rdata:000023D8 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:000023D8                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:000023D8                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:000023DC                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:000023E0                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:000023E4                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:000023E8                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000023EC                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000023EC _rdata          ends
.rdata:000023EC
.rdata:000023F0 ; ===========================================================================
.rdata:000023F0
.rdata:000023F0 ; Segment type: Pure data
.rdata:000023F0 ; Segment permissions: Read
.rdata:000023F0 _rdata          segment dword public 'DATA' use32
.rdata:000023F0                 assume cs:_rdata
.rdata:000023F0                 ;org 23F0h
.rdata:000023F0 ; COMDAT (pick any)
.rdata:000023F0                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:000023F0 ; `string'
.rdata:000023F0 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:000023F0                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:000023F0 _rdata          ends
.rdata:000023F0
.rdata:000023F8 ; ===========================================================================
.rdata:000023F8
.rdata:000023F8 ; Segment type: Pure data
.rdata:000023F8 ; Segment permissions: Read
.rdata:000023F8 _rdata          segment dword public 'DATA' use32
.rdata:000023F8                 assume cs:_rdata
.rdata:000023F8                 ;org 23F8h
.rdata:000023F8 ; COMDAT (pick any)
.rdata:000023F8                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:000023F8 ; `string'
.rdata:000023F8 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:000023F8                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_1D44o
.rdata:000023F8                                         ; std::_System_error_category::message(int):loc_1EC0o
.rdata:00002406                 align 4
.rdata:00002406 _rdata          ends
.rdata:00002406
.rdata:00002408 ; ===========================================================================
.rdata:00002408
.rdata:00002408 ; Segment type: Pure data
.rdata:00002408 ; Segment permissions: Read
.rdata:00002408 _rdata          segment dword public 'DATA' use32
.rdata:00002408                 assume cs:_rdata
.rdata:00002408                 ;org 2408h
.rdata:00002408 ; COMDAT (pick largest)
.rdata:00002408                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:0000240C                 public ??_7_Iostream_error_category@std@@6B@
.rdata:0000240C ; const std::_Iostream_error_category::`vftable'
.rdata:0000240C ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:0000240C                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:0000240C                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00002410                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00002414                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00002418                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000241C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002420                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002420 _rdata          ends
.rdata:00002420
.rdata:00002424 ; ===========================================================================
.rdata:00002424
.rdata:00002424 ; Segment type: Pure data
.rdata:00002424 ; Segment permissions: Read
.rdata:00002424 _rdata          segment dword public 'DATA' use32
.rdata:00002424                 assume cs:_rdata
.rdata:00002424                 ;org 2424h
.rdata:00002424 ; COMDAT (pick any)
.rdata:00002424                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00002424 ; `string'
.rdata:00002424 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00002424                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:0000242D                 align 10h
.rdata:0000242D _rdata          ends
.rdata:0000242D
.rdata:00002430 ; ===========================================================================
.rdata:00002430
.rdata:00002430 ; Segment type: Pure data
.rdata:00002430 ; Segment permissions: Read
.rdata:00002430 _rdata          segment dword public 'DATA' use32
.rdata:00002430                 assume cs:_rdata
.rdata:00002430                 ;org 2430h
.rdata:00002430 ; COMDAT (pick any)
.rdata:00002430                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00002430 ; char `string'[]
.rdata:00002430 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00002430                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00002446                 align 4
.rdata:00002446 _rdata          ends
.rdata:00002446
.rdata:00002448 ; ===========================================================================
.rdata:00002448
.rdata:00002448 ; Segment type: Pure data
.rdata:00002448 ; Segment permissions: Read
.rdata:00002448 _rdata          segment dword public 'DATA' use32
.rdata:00002448                 assume cs:_rdata
.rdata:00002448                 ;org 2448h
.rdata:00002448 ; COMDAT (pick largest)
.rdata:00002448                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:0000244C                 public ??_7_System_error_category@std@@6B@
.rdata:0000244C ; const std::_System_error_category::`vftable'
.rdata:0000244C ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:0000244C                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:0000244C                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00002450                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00002454                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00002458                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:0000245C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002460                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002460 _rdata          ends
.rdata:00002460
.rdata:00002464 ; ===========================================================================
.rdata:00002464
.rdata:00002464 ; Segment type: Pure data
.rdata:00002464 ; Segment permissions: Read
.rdata:00002464 _rdata          segment dword public 'DATA' use32
.rdata:00002464                 assume cs:_rdata
.rdata:00002464                 ;org 2464h
.rdata:00002464 ; COMDAT (pick any)
.rdata:00002464                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00002464 ; `string'
.rdata:00002464 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00002464                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:0000246B                 align 4
.rdata:0000246B _rdata          ends
.rdata:0000246B
.bss:0000246C ; ===========================================================================
.bss:0000246C
.bss:0000246C ; Segment type: Uninitialized
.bss:0000246C ; Segment permissions: Read/Write
.bss:0000246C _bss            segment dword public 'BSS' use32
.bss:0000246C                 assume cs:_bss
.bss:0000246C                 ;org 246Ch
.bss:0000246C ; COMDAT (pick any)
.bss:0000246C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000246C                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:0000246C ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:0000246C ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:0000246C                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:0000246C                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:0000246D                 db    ? ;
.bss:0000246E                 db    ? ;
.bss:0000246F                 db    ? ;
.bss:0000246F _bss            ends
.bss:0000246F
.bss:00002470 ; ===========================================================================
.bss:00002470
.bss:00002470 ; Segment type: Uninitialized
.bss:00002470 ; Segment permissions: Read/Write
.bss:00002470 _bss            segment dword public 'BSS' use32
.bss:00002470                 assume cs:_bss
.bss:00002470                 ;org 2470h
.bss:00002470 ; COMDAT (pick any)
.bss:00002470                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002470                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00002470 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00002470 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00002470                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00002470                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00002471                 db    ? ;
.bss:00002472                 db    ? ;
.bss:00002473                 db    ? ;
.bss:00002473 _bss            ends
.bss:00002473
.bss:00002474 ; ===========================================================================
.bss:00002474
.bss:00002474 ; Segment type: Uninitialized
.bss:00002474 ; Segment permissions: Read/Write
.bss:00002474 _bss            segment dword public 'BSS' use32
.bss:00002474                 assume cs:_bss
.bss:00002474                 ;org 2474h
.bss:00002474 ; COMDAT (pick any)
.bss:00002474                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002474                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00002474 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00002474 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00002474                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00002474                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00002475                 db    ? ;
.bss:00002476                 db    ? ;
.bss:00002477                 db    ? ;
.bss:00002477 _bss            ends
.bss:00002477
.bss:00002478 ; ===========================================================================
.bss:00002478
.bss:00002478 ; Segment type: Uninitialized
.bss:00002478 ; Segment permissions: Read/Write
.bss:00002478 _bss            segment dword public 'BSS' use32
.bss:00002478                 assume cs:_bss
.bss:00002478                 ;org 2478h
.bss:00002478 ; COMDAT (pick any)
.bss:00002478                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002478                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00002478 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00002478 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00002478                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00002479                 db    ? ;
.bss:0000247A                 db    ? ;
.bss:0000247B                 db    ? ;
.bss:0000247B _bss            ends
.bss:0000247B
.bss:0000247C ; ===========================================================================
.bss:0000247C
.bss:0000247C ; Segment type: Uninitialized
.bss:0000247C ; Segment permissions: Read/Write
.bss:0000247C _bss            segment dword public 'BSS' use32
.bss:0000247C                 assume cs:_bss
.bss:0000247C                 ;org 247Ch
.bss:0000247C ; COMDAT (pick any)
.bss:0000247C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000247C                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000247C ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:0000247C ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000247C                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:0000247D                 db    ? ;
.bss:0000247E                 db    ? ;
.bss:0000247F                 db    ? ;
.bss:0000247F _bss            ends
.bss:0000247F
.rdata:00002480 ; ===========================================================================
.rdata:00002480
.rdata:00002480 ; Segment type: Pure data
.rdata:00002480 ; Segment permissions: Read
.rdata:00002480 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00002480 _rdata          segment para public 'DATA' use32
.rdata:00002480                 assume cs:_rdata
.rdata:00002480                 ;org 2480h
.rdata:00002480 ; COMDAT (pick any)
.rdata:00002480                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00002480 ; wchar_t `string'
.rdata:00002480 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00002480                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00002480                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:00002480                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00002480                 unicode 0, <clude\xstring>,0
.rdata:0000250E                 align 10h
.rdata:0000250E _rdata          ends
.rdata:0000250E
.bss:00002510 ; ===========================================================================
.bss:00002510
.bss:00002510 ; Segment type: Uninitialized
.bss:00002510 ; Segment permissions: Read/Write
.bss:00002510 _bss            segment dword public 'BSS' use32
.bss:00002510                 assume cs:_bss
.bss:00002510                 ;org 2510h
.bss:00002510 ; COMDAT (pick any)
.bss:00002510                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002510                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00002510 ; std::locale::id std::numpunct<char>::id
.bss:00002510 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00002510                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00002511                 db    ? ;
.bss:00002512                 db    ? ;
.bss:00002513                 db    ? ;
.bss:00002513 _bss            ends
.bss:00002513
.bss:00002514 ; ===========================================================================
.bss:00002514
.bss:00002514 ; Segment type: Uninitialized
.bss:00002514 ; Segment permissions: Read/Write
.bss:00002514 _bss            segment dword public 'BSS' use32
.bss:00002514                 assume cs:_bss
.bss:00002514                 ;org 2514h
.bss:00002514 ; COMDAT (pick any)
.bss:00002514                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002514                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00002514 ; std::locale::id std::numpunct<wchar_t>::id
.bss:00002514 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00002514                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00002515                 db    ? ;
.bss:00002516                 db    ? ;
.bss:00002517                 db    ? ;
.bss:00002517 _bss            ends
.bss:00002517
.rdata:00002518 ; ===========================================================================
.rdata:00002518
.rdata:00002518 ; Segment type: Pure data
.rdata:00002518 ; Segment permissions: Read
.rdata:00002518 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00002518 _rdata          segment para public 'DATA' use32
.rdata:00002518                 assume cs:_rdata
.rdata:00002518                 ;org 2518h
.rdata:00002518 ; COMDAT (pick any)
.rdata:00002518                 public ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00002518 ; wchar_t `string'
.rdata:00002518 ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00002518                                         ; DATA XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+19o
.rdata:00002518                                         ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+49o ...
.rdata:00002518                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00002518                 unicode 0, <clude\vector>,0
.rdata:00002518 _rdata          ends
.rdata:00002518
.rdata:000025A4 ; ===========================================================================
.rdata:000025A4
.rdata:000025A4 ; Segment type: Pure data
.rdata:000025A4 ; Segment permissions: Read
.rdata:000025A4 _rdata          segment dword public 'DATA' use32
.rdata:000025A4                 assume cs:_rdata
.rdata:000025A4                 ;org 25A4h
.rdata:000025A4 ; COMDAT (pick any)
.rdata:000025A4                 public ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:000025A4 ; wchar_t `string'
.rdata:000025A4 ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:000025A4                                         ; DATA XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+1Eo
.rdata:000025A4                 unicode 0, <vector subscript out of range>,0
.rdata:000025A4 _rdata          ends
.rdata:000025A4
.rdata:000025E0 ; ===========================================================================
.rdata:000025E0
.rdata:000025E0 ; Segment type: Pure data
.rdata:000025E0 ; Segment permissions: Read
.rdata:000025E0 _rdata          segment dword public 'DATA' use32
.rdata:000025E0                 assume cs:_rdata
.rdata:000025E0                 ;org 25E0h
.rdata:000025E0 ; COMDAT (pick any)
.rdata:000025E0                 public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
.rdata:000025E0 ; `string'
.rdata:000025E0 ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ db 'Standard C++ Libraries Out of Range',0
.rdata:000025E0                                         ; DATA XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+2Bo
.rdata:000025E0 _rdata          ends
.rdata:000025E0
.rdata:00002604 ; ===========================================================================
.rdata:00002604
.rdata:00002604 ; Segment type: Pure data
.rdata:00002604 ; Segment permissions: Read
.rdata:00002604 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00002604 _rdata          segment para public 'DATA' use32
.rdata:00002604                 assume cs:_rdata
.rdata:00002604                 ;org 2604h
.rdata:00002604 ; COMDAT (pick any)
.rdata:00002604                 public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
.rdata:00002604 ; `string'
.rdata:00002604 ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
.rdata:00002604                                         ; DATA XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint):loc_1000o
.rdata:00002604                 unicode 0, <"Standard C++ Libraries Out of Range" && 0>,0
.rdata:0000265A                 align 4
.rdata:0000265A _rdata          ends
.rdata:0000265A
.rdata:0000265C ; ===========================================================================
.rdata:0000265C
.rdata:0000265C ; Segment type: Pure data
.rdata:0000265C ; Segment permissions: Read
.rdata:0000265C _rdata          segment dword public 'DATA' use32
.rdata:0000265C                 assume cs:_rdata
.rdata:0000265C                 ;org 265Ch
.rdata:0000265C ; COMDAT (pick any)
.rdata:0000265C                 public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
.rdata:0000265C ; `string'
.rdata:0000265C ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
.rdata:0000265C                                         ; DATA XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+3Do
.rdata:0000265C                 unicode 0, <%s>,0
.rdata:00002662                 align 4
.rdata:00002662 _rdata          ends
.rdata:00002662
.rdata:00002664 ; ===========================================================================
.rdata:00002664
.rdata:00002664 ; Segment type: Pure data
.rdata:00002664 ; Segment permissions: Read
.rdata:00002664 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00002664 _rdata          segment para public 'DATA' use32
.rdata:00002664                 assume cs:_rdata
.rdata:00002664                 ;org 2664h
.rdata:00002664 ; COMDAT (pick any)
.rdata:00002664                 public ??_C@_1LO@OIFNPDJM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAT?$AAa?$AAs?$AAk?$AAL?$AAs?$AAt?$AAF?$AAn?$AAS?$AAt?$AAa?$AAt@
.rdata:00002664 ; `string'
.rdata:00002664 ??_C@_1LO@OIFNPDJM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAT?$AAa?$AAs?$AAk?$AAL?$AAs?$AAt?$AAF?$AAn?$AAS?$AAt?$AAa?$AAt@:
.rdata:00002664                                         ; DATA XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+6Ao
.rdata:00002664                 unicode 0, <std::vector>
.rdata:00002664                 dw 3Ch
.rdata:00002664                 unicode 0, <struct TaskLstFnStatus,class std::allocator>
.rdata:00002664                 dw 3Ch
.rdata:00002664                 unicode 0, <struct TaskLstFnStatus>
.rdata:00002664                 dw 3Eh
.rdata:00002664                 unicode 0, < >
.rdata:00002664                 dw 3Eh
.rdata:00002664                 unicode 0, <::operator []>,0
.rdata:00002722                 align 4
.rdata:00002722 _rdata          ends
.rdata:00002722
.rdata:00002724 ; ===========================================================================
.rdata:00002724
.rdata:00002724 ; Segment type: Pure data
.rdata:00002724 ; Segment permissions: Read
.rdata:00002724 _rdata          segment dword public 'DATA' use32
.rdata:00002724                 assume cs:_rdata
.rdata:00002724                 ;org 2724h
.rdata:00002724 ; COMDAT (pick any)
.rdata:00002724                 public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
.rdata:00002724 ; `string'
.rdata:00002724 ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
.rdata:00002724                                         ; DATA XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+6Fo
.rdata:00002724                 unicode 0, <"out of range">,0
.rdata:00002742                 align 4
.rdata:00002742 _rdata          ends
.rdata:00002742
.rdata:00002744 ; ===========================================================================
.rdata:00002744
.rdata:00002744 ; Segment type: Pure data
.rdata:00002744 ; Segment permissions: Read
.rdata:00002744 _rdata          segment dword public 'DATA' use32
.rdata:00002744                 assume cs:_rdata
.rdata:00002744                 ;org 2744h
.rdata:00002744 ; COMDAT (pick any)
.rdata:00002744                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00002744 ; char `string'[]
.rdata:00002744 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00002744                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00002744 _rdata          ends
.rdata:00002744
.rdata:00002754 ; ===========================================================================
.rdata:00002754
.rdata:00002754 ; Segment type: Pure data
.rdata:00002754 ; Segment permissions: Read
.rdata:00002754 _rdata          segment dword public 'DATA' use32
.rdata:00002754                 assume cs:_rdata
.rdata:00002754                 ;org 2754h
.rdata:00002754 ; COMDAT (pick any)
.rdata:00002754                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00002754 ; char `string'[]
.rdata:00002754 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00002754                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00002754 _rdata          ends
.rdata:00002754
.rdata:0000276C ; ===========================================================================
.rdata:0000276C
.rdata:0000276C ; Segment type: Pure data
.rdata:0000276C ; Segment permissions: Read
.rdata:0000276C _rdata          segment dword public 'DATA' use32
.rdata:0000276C                 assume cs:_rdata
.rdata:0000276C                 ;org 276Ch
.rdata:0000276C ; COMDAT (pick any)
.rdata:0000276C                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:0000276C ; wchar_t `string'
.rdata:0000276C ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:0000276C                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:0000276C                 unicode 0, <invalid null pointer>,0
.rdata:00002796                 align 4
.rdata:00002796 _rdata          ends
.rdata:00002796
.rdata$r:00002798 ; ===========================================================================
.rdata$r:00002798
.rdata$r:00002798 ; Segment type: Pure data
.rdata$r:00002798 ; Segment permissions: Read
.rdata$r:00002798 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002798                 assume cs:_rdata$r
.rdata$r:00002798                 ;org 2798h
.rdata$r:00002798 ; COMDAT (pick any)
.rdata$r:00002798                 public ??_R4error_category@std@@6B@
.rdata$r:00002798 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00002798 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:000023B8o
.rdata$r:00002799                 db    0
.rdata$r:0000279A                 db    0
.rdata$r:0000279B                 db    0
.rdata$r:0000279C                 db    0
.rdata$r:0000279D                 db    0
.rdata$r:0000279E                 db    0
.rdata$r:0000279F                 db    0
.rdata$r:000027A0                 db    0
.rdata$r:000027A1                 db    0
.rdata$r:000027A2                 db    0
.rdata$r:000027A3                 db    0
.rdata$r:000027A4                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:000027A8                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000027A8 _rdata$r        ends
.rdata$r:000027A8
.data$r:000027AC ; ===========================================================================
.data$r:000027AC
.data$r:000027AC ; Segment type: Pure data
.data$r:000027AC ; Segment permissions: Read/Write
.data$r:000027AC _data$r         segment dword public 'DATA' use32
.data$r:000027AC                 assume cs:_data$r
.data$r:000027AC                 ;org 27ACh
.data$r:000027AC ; COMDAT (pick any)
.data$r:000027AC                 public ??_R0?AVerror_category@std@@@8
.data$r:000027AC ; class std::error_category `RTTI Type Descriptor'
.data$r:000027AC ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000027AC                                         ; DATA XREF: .rdata$r:000027A4o
.data$r:000027AC                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000027AC                                         ; const type_info::`vftable'
.data$r:000027B0                 db    0
.data$r:000027B1                 db    0
.data$r:000027B2                 db    0
.data$r:000027B3                 db    0
.data$r:000027B4                 db  2Eh ; .
.data$r:000027B5                 db  3Fh ; ?
.data$r:000027B6                 db  41h ; A
.data$r:000027B7                 db  56h ; V
.data$r:000027B8                 db  65h ; e
.data$r:000027B9                 db  72h ; r
.data$r:000027BA                 db  72h ; r
.data$r:000027BB                 db  6Fh ; o
.data$r:000027BC                 db  72h ; r
.data$r:000027BD                 db  5Fh ; _
.data$r:000027BE                 db  63h ; c
.data$r:000027BF                 db  61h ; a
.data$r:000027C0                 db  74h ; t
.data$r:000027C1                 db  65h ; e
.data$r:000027C2                 db  67h ; g
.data$r:000027C3                 db  6Fh ; o
.data$r:000027C4                 db  72h ; r
.data$r:000027C5                 db  79h ; y
.data$r:000027C6                 db  40h ; @
.data$r:000027C7                 db  73h ; s
.data$r:000027C8                 db  74h ; t
.data$r:000027C9                 db  64h ; d
.data$r:000027CA                 db  40h ; @
.data$r:000027CB                 db  40h ; @
.data$r:000027CC                 db    0
.data$r:000027CD                 align 10h
.data$r:000027CD _data$r         ends
.data$r:000027CD
.rdata$r:000027D0 ; ===========================================================================
.rdata$r:000027D0
.rdata$r:000027D0 ; Segment type: Pure data
.rdata$r:000027D0 ; Segment permissions: Read
.rdata$r:000027D0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027D0                 assume cs:_rdata$r
.rdata$r:000027D0                 ;org 27D0h
.rdata$r:000027D0 ; COMDAT (pick any)
.rdata$r:000027D0                 public ??_R3error_category@std@@8
.rdata$r:000027D0 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000027D0 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:000027A8o
.rdata$r:000027D0                                         ; .rdata$r:00002800o
.rdata$r:000027D1                 db    0
.rdata$r:000027D2                 db    0
.rdata$r:000027D3                 db    0
.rdata$r:000027D4                 db    0
.rdata$r:000027D5                 db    0
.rdata$r:000027D6                 db    0
.rdata$r:000027D7                 db    0
.rdata$r:000027D8                 db    1
.rdata$r:000027D9                 db    0
.rdata$r:000027DA                 db    0
.rdata$r:000027DB                 db    0
.rdata$r:000027DC                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:000027DC _rdata$r        ends
.rdata$r:000027DC
.rdata$r:000027E0 ; ===========================================================================
.rdata$r:000027E0
.rdata$r:000027E0 ; Segment type: Pure data
.rdata$r:000027E0 ; Segment permissions: Read
.rdata$r:000027E0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027E0                 assume cs:_rdata$r
.rdata$r:000027E0                 ;org 27E0h
.rdata$r:000027E0 ; COMDAT (pick any)
.rdata$r:000027E0                 public ??_R2error_category@std@@8
.rdata$r:000027E0 ; std::error_category::`RTTI Base Class Array'
.rdata$r:000027E0 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:000027E0                                         ; DATA XREF: .rdata$r:000027DCo
.rdata$r:000027E0                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000027E4                 db    0
.rdata$r:000027E5                 align 4
.rdata$r:000027E5 _rdata$r        ends
.rdata$r:000027E5
.rdata$r:000027E8 ; ===========================================================================
.rdata$r:000027E8
.rdata$r:000027E8 ; Segment type: Pure data
.rdata$r:000027E8 ; Segment permissions: Read
.rdata$r:000027E8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000027E8                 assume cs:_rdata$r
.rdata$r:000027E8                 ;org 27E8h
.rdata$r:000027E8 ; COMDAT (pick any)
.rdata$r:000027E8                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:000027E8 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000027E8 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:000027E8                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:000027E8                                         ; .rdata$r:00002858o ...
.rdata$r:000027E8                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:000027EC                 db    0
.rdata$r:000027ED                 db    0
.rdata$r:000027EE                 db    0
.rdata$r:000027EF                 db    0
.rdata$r:000027F0                 db    0
.rdata$r:000027F1                 db    0
.rdata$r:000027F2                 db    0
.rdata$r:000027F3                 db    0
.rdata$r:000027F4                 db 0FFh
.rdata$r:000027F5                 db 0FFh
.rdata$r:000027F6                 db 0FFh
.rdata$r:000027F7                 db 0FFh
.rdata$r:000027F8                 db    0
.rdata$r:000027F9                 db    0
.rdata$r:000027FA                 db    0
.rdata$r:000027FB                 db    0
.rdata$r:000027FC                 db  40h ; @
.rdata$r:000027FD                 db    0
.rdata$r:000027FE                 db    0
.rdata$r:000027FF                 db    0
.rdata$r:00002800                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002800 _rdata$r        ends
.rdata$r:00002800
.rdata$r:00002804 ; ===========================================================================
.rdata$r:00002804
.rdata$r:00002804 ; Segment type: Pure data
.rdata$r:00002804 ; Segment permissions: Read
.rdata$r:00002804 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002804                 assume cs:_rdata$r
.rdata$r:00002804                 ;org 2804h
.rdata$r:00002804 ; COMDAT (pick any)
.rdata$r:00002804                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00002804 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00002804 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00002804                                         ; DATA XREF: .rdata:000023D4o
.rdata$r:00002805                 db    0
.rdata$r:00002806                 db    0
.rdata$r:00002807                 db    0
.rdata$r:00002808                 db    0
.rdata$r:00002809                 db    0
.rdata$r:0000280A                 db    0
.rdata$r:0000280B                 db    0
.rdata$r:0000280C                 db    0
.rdata$r:0000280D                 db    0
.rdata$r:0000280E                 db    0
.rdata$r:0000280F                 db    0
.rdata$r:00002810                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00002814                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002814 _rdata$r        ends
.rdata$r:00002814
.data$r:00002818 ; ===========================================================================
.data$r:00002818
.data$r:00002818 ; Segment type: Pure data
.data$r:00002818 ; Segment permissions: Read/Write
.data$r:00002818 _data$r         segment dword public 'DATA' use32
.data$r:00002818                 assume cs:_data$r
.data$r:00002818                 ;org 2818h
.data$r:00002818 ; COMDAT (pick any)
.data$r:00002818                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00002818 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00002818 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002818                                         ; DATA XREF: .rdata$r:00002810o
.data$r:00002818                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002818                                         ; const type_info::`vftable'
.data$r:0000281C                 align 10h
.data$r:00002820 a_?av_generic_e db '.?AV_Generic_error_category@std@@',0
.data$r:00002842                 align 4
.data$r:00002842 _data$r         ends
.data$r:00002842
.rdata$r:00002844 ; ===========================================================================
.rdata$r:00002844
.rdata$r:00002844 ; Segment type: Pure data
.rdata$r:00002844 ; Segment permissions: Read
.rdata$r:00002844 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002844                 assume cs:_rdata$r
.rdata$r:00002844                 ;org 2844h
.rdata$r:00002844 ; COMDAT (pick any)
.rdata$r:00002844                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00002844 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002844 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00002844                                         ; DATA XREF: .rdata$r:00002814o
.rdata$r:00002844                                         ; .rdata$r:00002878o
.rdata$r:00002845                 db    0
.rdata$r:00002846                 db    0
.rdata$r:00002847                 db    0
.rdata$r:00002848                 db    0
.rdata$r:00002849                 db    0
.rdata$r:0000284A                 db    0
.rdata$r:0000284B                 db    0
.rdata$r:0000284C                 db    2
.rdata$r:0000284D                 db    0
.rdata$r:0000284E                 db    0
.rdata$r:0000284F                 db    0
.rdata$r:00002850                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00002850 _rdata$r        ends
.rdata$r:00002850
.rdata$r:00002854 ; ===========================================================================
.rdata$r:00002854
.rdata$r:00002854 ; Segment type: Pure data
.rdata$r:00002854 ; Segment permissions: Read
.rdata$r:00002854 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002854                 assume cs:_rdata$r
.rdata$r:00002854                 ;org 2854h
.rdata$r:00002854 ; COMDAT (pick any)
.rdata$r:00002854                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00002854 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00002854 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00002854                                         ; DATA XREF: .rdata$r:00002850o
.rdata$r:00002854                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002858                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000285C                 db    0
.rdata$r:0000285D                 align 10h
.rdata$r:0000285D _rdata$r        ends
.rdata$r:0000285D
.rdata$r:00002860 ; ===========================================================================
.rdata$r:00002860
.rdata$r:00002860 ; Segment type: Pure data
.rdata$r:00002860 ; Segment permissions: Read
.rdata$r:00002860 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002860                 assume cs:_rdata$r
.rdata$r:00002860                 ;org 2860h
.rdata$r:00002860 ; COMDAT (pick any)
.rdata$r:00002860                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00002860 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002860 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00002860                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00002860                                         ; .rdata$r:000028D0o ...
.rdata$r:00002860                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00002864                 db    1
.rdata$r:00002865                 db    0
.rdata$r:00002866                 db    0
.rdata$r:00002867                 db    0
.rdata$r:00002868                 db    0
.rdata$r:00002869                 db    0
.rdata$r:0000286A                 db    0
.rdata$r:0000286B                 db    0
.rdata$r:0000286C                 db 0FFh
.rdata$r:0000286D                 db 0FFh
.rdata$r:0000286E                 db 0FFh
.rdata$r:0000286F                 db 0FFh
.rdata$r:00002870                 db    0
.rdata$r:00002871                 db    0
.rdata$r:00002872                 db    0
.rdata$r:00002873                 db    0
.rdata$r:00002874                 db  40h ; @
.rdata$r:00002875                 db    0
.rdata$r:00002876                 db    0
.rdata$r:00002877                 db    0
.rdata$r:00002878                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002878 _rdata$r        ends
.rdata$r:00002878
.rdata$r:0000287C ; ===========================================================================
.rdata$r:0000287C
.rdata$r:0000287C ; Segment type: Pure data
.rdata$r:0000287C ; Segment permissions: Read
.rdata$r:0000287C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000287C                 assume cs:_rdata$r
.rdata$r:0000287C                 ;org 287Ch
.rdata$r:0000287C ; COMDAT (pick any)
.rdata$r:0000287C                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:0000287C ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:0000287C ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:0000287C                                         ; DATA XREF: .rdata:00002408o
.rdata$r:0000287D                 db    0
.rdata$r:0000287E                 db    0
.rdata$r:0000287F                 db    0
.rdata$r:00002880                 db    0
.rdata$r:00002881                 db    0
.rdata$r:00002882                 db    0
.rdata$r:00002883                 db    0
.rdata$r:00002884                 db    0
.rdata$r:00002885                 db    0
.rdata$r:00002886                 db    0
.rdata$r:00002887                 db    0
.rdata$r:00002888                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000288C                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000288C _rdata$r        ends
.rdata$r:0000288C
.data$r:00002890 ; ===========================================================================
.data$r:00002890
.data$r:00002890 ; Segment type: Pure data
.data$r:00002890 ; Segment permissions: Read/Write
.data$r:00002890 _data$r         segment dword public 'DATA' use32
.data$r:00002890                 assume cs:_data$r
.data$r:00002890                 ;org 2890h
.data$r:00002890 ; COMDAT (pick any)
.data$r:00002890                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:00002890 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:00002890 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002890                                         ; DATA XREF: .rdata$r:00002888o
.data$r:00002890                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002890                                         ; const type_info::`vftable'
.data$r:00002894                 align 8
.data$r:00002898 a_?av_iostream_ db '.?AV_Iostream_error_category@std@@',0
.data$r:000028BB                 align 4
.data$r:000028BB _data$r         ends
.data$r:000028BB
.rdata$r:000028BC ; ===========================================================================
.rdata$r:000028BC
.rdata$r:000028BC ; Segment type: Pure data
.rdata$r:000028BC ; Segment permissions: Read
.rdata$r:000028BC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000028BC                 assume cs:_rdata$r
.rdata$r:000028BC                 ;org 28BCh
.rdata$r:000028BC ; COMDAT (pick any)
.rdata$r:000028BC                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:000028BC ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000028BC ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:000028BC                                         ; DATA XREF: .rdata$r:0000288Co
.rdata$r:000028BC                                         ; .rdata$r:000028F4o
.rdata$r:000028BD                 db    0
.rdata$r:000028BE                 db    0
.rdata$r:000028BF                 db    0
.rdata$r:000028C0                 db    0
.rdata$r:000028C1                 db    0
.rdata$r:000028C2                 db    0
.rdata$r:000028C3                 db    0
.rdata$r:000028C4                 db    3
.rdata$r:000028C5                 db    0
.rdata$r:000028C6                 db    0
.rdata$r:000028C7                 db    0
.rdata$r:000028C8                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000028C8 _rdata$r        ends
.rdata$r:000028C8
.rdata$r:000028CC ; ===========================================================================
.rdata$r:000028CC
.rdata$r:000028CC ; Segment type: Pure data
.rdata$r:000028CC ; Segment permissions: Read
.rdata$r:000028CC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000028CC                 assume cs:_rdata$r
.rdata$r:000028CC                 ;org 28CCh
.rdata$r:000028CC ; COMDAT (pick any)
.rdata$r:000028CC                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:000028CC ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000028CC ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:000028CC                                         ; DATA XREF: .rdata$r:000028C8o
.rdata$r:000028CC                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000028D0                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000028D4                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000028D8                 db    0
.rdata$r:000028D9                 align 4
.rdata$r:000028D9 _rdata$r        ends
.rdata$r:000028D9
.rdata$r:000028DC ; ===========================================================================
.rdata$r:000028DC
.rdata$r:000028DC ; Segment type: Pure data
.rdata$r:000028DC ; Segment permissions: Read
.rdata$r:000028DC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000028DC                 assume cs:_rdata$r
.rdata$r:000028DC                 ;org 28DCh
.rdata$r:000028DC ; COMDAT (pick any)
.rdata$r:000028DC                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:000028DC ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000028DC ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:000028DC                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:000028DC                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:000028E0                 db    2
.rdata$r:000028E1                 db    0
.rdata$r:000028E2                 db    0
.rdata$r:000028E3                 db    0
.rdata$r:000028E4                 db    0
.rdata$r:000028E5                 db    0
.rdata$r:000028E6                 db    0
.rdata$r:000028E7                 db    0
.rdata$r:000028E8                 db 0FFh
.rdata$r:000028E9                 db 0FFh
.rdata$r:000028EA                 db 0FFh
.rdata$r:000028EB                 db 0FFh
.rdata$r:000028EC                 db    0
.rdata$r:000028ED                 db    0
.rdata$r:000028EE                 db    0
.rdata$r:000028EF                 db    0
.rdata$r:000028F0                 db  40h ; @
.rdata$r:000028F1                 db    0
.rdata$r:000028F2                 db    0
.rdata$r:000028F3                 db    0
.rdata$r:000028F4                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000028F4 _rdata$r        ends
.rdata$r:000028F4
.rdata$r:000028F8 ; ===========================================================================
.rdata$r:000028F8
.rdata$r:000028F8 ; Segment type: Pure data
.rdata$r:000028F8 ; Segment permissions: Read
.rdata$r:000028F8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000028F8                 assume cs:_rdata$r
.rdata$r:000028F8                 ;org 28F8h
.rdata$r:000028F8 ; COMDAT (pick any)
.rdata$r:000028F8                 public ??_R4_System_error_category@std@@6B@
.rdata$r:000028F8 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:000028F8 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00002448o
.rdata$r:000028F9                 db    0
.rdata$r:000028FA                 db    0
.rdata$r:000028FB                 db    0
.rdata$r:000028FC                 db    0
.rdata$r:000028FD                 db    0
.rdata$r:000028FE                 db    0
.rdata$r:000028FF                 db    0
.rdata$r:00002900                 db    0
.rdata$r:00002901                 db    0
.rdata$r:00002902                 db    0
.rdata$r:00002903                 db    0
.rdata$r:00002904                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00002908                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002908 _rdata$r        ends
.rdata$r:00002908
.data$r:0000290C ; ===========================================================================
.data$r:0000290C
.data$r:0000290C ; Segment type: Pure data
.data$r:0000290C ; Segment permissions: Read/Write
.data$r:0000290C _data$r         segment dword public 'DATA' use32
.data$r:0000290C                 assume cs:_data$r
.data$r:0000290C                 ;org 290Ch
.data$r:0000290C ; COMDAT (pick any)
.data$r:0000290C                 public ??_R0?AV_System_error_category@std@@@8
.data$r:0000290C ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:0000290C ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000290C                                         ; DATA XREF: .rdata$r:00002904o
.data$r:0000290C                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000290C                                         ; const type_info::`vftable'
.data$r:00002910                 db    0
.data$r:00002911                 db    0
.data$r:00002912                 db    0
.data$r:00002913                 db    0
.data$r:00002914                 db  2Eh ; .
.data$r:00002915                 db  3Fh ; ?
.data$r:00002916                 db  41h ; A
.data$r:00002917                 db  56h ; V
.data$r:00002918                 db  5Fh ; _
.data$r:00002919                 db  53h ; S
.data$r:0000291A                 db  79h ; y
.data$r:0000291B                 db  73h ; s
.data$r:0000291C                 db  74h ; t
.data$r:0000291D                 db  65h ; e
.data$r:0000291E                 db  6Dh ; m
.data$r:0000291F                 db  5Fh ; _
.data$r:00002920                 db  65h ; e
.data$r:00002921                 db  72h ; r
.data$r:00002922                 db  72h ; r
.data$r:00002923                 db  6Fh ; o
.data$r:00002924                 db  72h ; r
.data$r:00002925                 db  5Fh ; _
.data$r:00002926                 db  63h ; c
.data$r:00002927                 db  61h ; a
.data$r:00002928                 db  74h ; t
.data$r:00002929                 db  65h ; e
.data$r:0000292A                 db  67h ; g
.data$r:0000292B                 db  6Fh ; o
.data$r:0000292C                 db  72h ; r
.data$r:0000292D                 db  79h ; y
.data$r:0000292E                 db  40h ; @
.data$r:0000292F                 db  73h ; s
.data$r:00002930                 db  74h ; t
.data$r:00002931                 db  64h ; d
.data$r:00002932                 db  40h ; @
.data$r:00002933                 db  40h ; @
.data$r:00002934                 db    0
.data$r:00002935                 align 4
.data$r:00002935 _data$r         ends
.data$r:00002935
.rdata$r:00002938 ; ===========================================================================
.rdata$r:00002938
.rdata$r:00002938 ; Segment type: Pure data
.rdata$r:00002938 ; Segment permissions: Read
.rdata$r:00002938 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002938                 assume cs:_rdata$r
.rdata$r:00002938                 ;org 2938h
.rdata$r:00002938 ; COMDAT (pick any)
.rdata$r:00002938                 public ??_R3_System_error_category@std@@8
.rdata$r:00002938 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002938 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00002908o
.rdata$r:00002938                                         ; .rdata$r:00002970o
.rdata$r:00002939                 db    0
.rdata$r:0000293A                 db    0
.rdata$r:0000293B                 db    0
.rdata$r:0000293C                 db    0
.rdata$r:0000293D                 db    0
.rdata$r:0000293E                 db    0
.rdata$r:0000293F                 db    0
.rdata$r:00002940                 db    3
.rdata$r:00002941                 db    0
.rdata$r:00002942                 db    0
.rdata$r:00002943                 db    0
.rdata$r:00002944                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00002944 _rdata$r        ends
.rdata$r:00002944
.rdata$r:00002948 ; ===========================================================================
.rdata$r:00002948
.rdata$r:00002948 ; Segment type: Pure data
.rdata$r:00002948 ; Segment permissions: Read
.rdata$r:00002948 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002948                 assume cs:_rdata$r
.rdata$r:00002948                 ;org 2948h
.rdata$r:00002948 ; COMDAT (pick any)
.rdata$r:00002948                 public ??_R2_System_error_category@std@@8
.rdata$r:00002948 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00002948 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00002948                                         ; DATA XREF: .rdata$r:00002944o
.rdata$r:00002948                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000294C                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002950                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002954                 db    0
.rdata$r:00002955                 align 4
.rdata$r:00002955 _rdata$r        ends
.rdata$r:00002955
.rdata$r:00002958 ; ===========================================================================
.rdata$r:00002958
.rdata$r:00002958 ; Segment type: Pure data
.rdata$r:00002958 ; Segment permissions: Read
.rdata$r:00002958 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002958                 assume cs:_rdata$r
.rdata$r:00002958                 ;org 2958h
.rdata$r:00002958 ; COMDAT (pick any)
.rdata$r:00002958                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00002958 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002958 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00002958                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00002958                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000295C                 db    2
.rdata$r:0000295D                 db    0
.rdata$r:0000295E                 db    0
.rdata$r:0000295F                 db    0
.rdata$r:00002960                 db    0
.rdata$r:00002961                 db    0
.rdata$r:00002962                 db    0
.rdata$r:00002963                 db    0
.rdata$r:00002964                 db 0FFh
.rdata$r:00002965                 db 0FFh
.rdata$r:00002966                 db 0FFh
.rdata$r:00002967                 db 0FFh
.rdata$r:00002968                 db    0
.rdata$r:00002969                 db    0
.rdata$r:0000296A                 db    0
.rdata$r:0000296B                 db    0
.rdata$r:0000296C                 db  40h ; @
.rdata$r:0000296D                 db    0
.rdata$r:0000296E                 db    0
.rdata$r:0000296F                 db    0
.rdata$r:00002970                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002970 _rdata$r        ends
.rdata$r:00002970
.CRT$XCU:00002974 ; ===========================================================================
.CRT$XCU:00002974
.CRT$XCU:00002974 ; Segment type: Pure data
.CRT$XCU:00002974 ; Segment permissions: Read
.CRT$XCU:00002974 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002974                 assume cs:_CRT$XCU
.CRT$XCU:00002974                 ;org 2974h
.CRT$XCU:00002974 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00002978 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00002978 _CRT$XCU        ends
.CRT$XCU:00002978
.CRT$XCU:0000297C ; ===========================================================================
.CRT$XCU:0000297C
.CRT$XCU:0000297C ; Segment type: Pure data
.CRT$XCU:0000297C ; Segment permissions: Read
.CRT$XCU:0000297C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000297C                 assume cs:_CRT$XCU
.CRT$XCU:0000297C                 ;org 297Ch
.CRT$XCU:0000297C ; COMDAT (pick associative to section at 246C)
.CRT$XCU:0000297C ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:0000297C ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:0000297C _CRT$XCU        ends
.CRT$XCU:0000297C
.CRT$XCU:00002980 ; ===========================================================================
.CRT$XCU:00002980
.CRT$XCU:00002980 ; Segment type: Pure data
.CRT$XCU:00002980 ; Segment permissions: Read
.CRT$XCU:00002980 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002980                 assume cs:_CRT$XCU
.CRT$XCU:00002980                 ;org 2980h
.CRT$XCU:00002980 ; COMDAT (pick associative to section at 2470)
.CRT$XCU:00002980 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:00002980 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:00002980 _CRT$XCU        ends
.CRT$XCU:00002980
.CRT$XCU:00002984 ; ===========================================================================
.CRT$XCU:00002984
.CRT$XCU:00002984 ; Segment type: Pure data
.CRT$XCU:00002984 ; Segment permissions: Read
.CRT$XCU:00002984 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002984                 assume cs:_CRT$XCU
.CRT$XCU:00002984                 ;org 2984h
.CRT$XCU:00002984 ; COMDAT (pick associative to section at 2474)
.CRT$XCU:00002984 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00002984 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00002984 _CRT$XCU        ends
.CRT$XCU:00002984
.CRT$XCU:00002988 ; ===========================================================================
.CRT$XCU:00002988
.CRT$XCU:00002988 ; Segment type: Pure data
.CRT$XCU:00002988 ; Segment permissions: Read
.CRT$XCU:00002988 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002988                 assume cs:_CRT$XCU
.CRT$XCU:00002988                 ;org 2988h
.CRT$XCU:00002988 ; COMDAT (pick associative to section at 2478)
.CRT$XCU:00002988 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00002988 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00002988 _CRT$XCU        ends
.CRT$XCU:00002988
.CRT$XCU:0000298C ; ===========================================================================
.CRT$XCU:0000298C
.CRT$XCU:0000298C ; Segment type: Pure data
.CRT$XCU:0000298C ; Segment permissions: Read
.CRT$XCU:0000298C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000298C                 assume cs:_CRT$XCU
.CRT$XCU:0000298C                 ;org 298Ch
.CRT$XCU:0000298C ; COMDAT (pick associative to section at 247C)
.CRT$XCU:0000298C ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:0000298C ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:0000298C _CRT$XCU        ends
.CRT$XCU:0000298C
.CRT$XCU:00002990 ; ===========================================================================
.CRT$XCU:00002990
.CRT$XCU:00002990 ; Segment type: Pure data
.CRT$XCU:00002990 ; Segment permissions: Read
.CRT$XCU:00002990 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002990                 assume cs:_CRT$XCU
.CRT$XCU:00002990                 ;org 2990h
.CRT$XCU:00002990 ; COMDAT (pick associative to section at 2510)
.CRT$XCU:00002990 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:00002990 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:00002990 _CRT$XCU        ends
.CRT$XCU:00002990
.CRT$XCU:00002994 ; ===========================================================================
.CRT$XCU:00002994
.CRT$XCU:00002994 ; Segment type: Pure data
.CRT$XCU:00002994 ; Segment permissions: Read
.CRT$XCU:00002994 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002994                 assume cs:_CRT$XCU
.CRT$XCU:00002994                 ;org 2994h
.CRT$XCU:00002994 ; COMDAT (pick associative to section at 2514)
.CRT$XCU:00002994 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00002994 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00002994 _CRT$XCU        ends
.CRT$XCU:00002994
UNDEF:000029A0 ; ===========================================================================
UNDEF:000029A0
UNDEF:000029A0 ; Segment type: Externs
UNDEF:000029A0 ; UNDEF
UNDEF:000029A0                 extrn __purecall:near   ; DATA XREF: .rdata:000023C0o
UNDEF:000029A0                                         ; .rdata:000023C4o
UNDEF:000029A4 ; void *__cdecl operator new(unsigned int)
UNDEF:000029A4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:000029A4                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p
UNDEF:000029A8 ; void __cdecl operator delete(void *)
UNDEF:000029A8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:000029A8                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:000029AC ; int __cdecl atexit(void (__cdecl *)())
UNDEF:000029AC                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:000029AC                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:000029B0                 extrn __invalid_parameter:near
UNDEF:000029B0                                         ; CODE XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+74p
UNDEF:000029B4 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:000029B4                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:000029B4                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:000029B8 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:000029B8                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:000029B8                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:000029B8                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:000029BC                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:000029C0 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:000029C0                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:000029C4 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:000029C4                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:000029C8 ; size_t __cdecl strlen(const char *Str)
UNDEF:000029C8                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:000029CC                 extrn __CrtDbgReportW:near
UNDEF:000029CC                                         ; CODE XREF: std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+50p
UNDEF:000029D0 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:000029D0                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:000029D0                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:000029D0                                         ; std::vector<TaskLstFnStatus,std::allocator<TaskLstFnStatus>>::operator[](uint)+23p
UNDEF:000029D4 ; void __cdecl std::_Xbad_alloc()
UNDEF:000029D4                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:000029D4                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_5E2p
UNDEF:000029D4                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_624p
UNDEF:000029D8 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:000029D8                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:000029D8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:000029DC ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:000029DC                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:000029DC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:000029E0 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:000029E0                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000029E0                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:000029E4 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:000029E4                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:000029E4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:000029E4                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:000029E8 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:000029E8                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:000029E8                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:000029EC ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:000029EC                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000029EC                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:000029F0 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:000029F0                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000029F0                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:000029F4 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:000029F4                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000029F4                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:000029F8 ; HGLOBAL __stdcall GlobalFree(HGLOBAL hMem)
UNDEF:000029F8                 extrn __imp__GlobalFree@4:near
UNDEF:000029F8                                         ; CODE XREF: TaskListDlg::doDialog(bool)+54p
UNDEF:000029F8                                         ; DATA XREF: TaskListDlg::doDialog(bool)+54r
UNDEF:000029FC ; int __stdcall lstrlenW(LPCWSTR lpString)
UNDEF:000029FC                 extrn __imp__lstrlenW@4:near
UNDEF:000029FC                                         ; CODE XREF: TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+15Dp
UNDEF:000029FC                                         ; DATA XREF: TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+15Dr
UNDEF:00002A00 ; BOOL __stdcall GetTextExtentPointW(HDC hdc, LPCWSTR lpString, int c, LPSIZE lpsz)
UNDEF:00002A00                 extrn __imp__GetTextExtentPointW@16:near
UNDEF:00002A00                                         ; CODE XREF: TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+E5p
UNDEF:00002A00                                         ; DATA XREF: TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+E5r
UNDEF:00002A04 ; HGDIOBJ __stdcall SelectObject(HDC hdc, HGDIOBJ h)
UNDEF:00002A04                 extrn __imp__SelectObject@8:near
UNDEF:00002A04                                         ; CODE XREF: TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+AAp
UNDEF:00002A04                                         ; DATA XREF: TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+AAr
UNDEF:00002A08 ; COLORREF __stdcall SetTextColor(HDC hdc, COLORREF color)
UNDEF:00002A08                 extrn __imp__SetTextColor@8:near
UNDEF:00002A08                                         ; CODE XREF: TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+13Dp
UNDEF:00002A08                                         ; DATA XREF: TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+13Dr
UNDEF:00002A0C ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00002A0C                 extrn __imp__SendMessageW@16:near
UNDEF:00002A0C                                         ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+7Fp
UNDEF:00002A0C                                         ; TaskListDlg::run_dlgProc(uint,uint,long)+1EBp ...
UNDEF:00002A10 ; BOOL __stdcall PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00002A10                 extrn __imp__PostMessageW@16:near
UNDEF:00002A10                                         ; CODE XREF: hookProc(uint,uint,long)+21p
UNDEF:00002A10                                         ; DATA XREF: hookProc(uint,uint,long)+21r
UNDEF:00002A14 ; INT_PTR __stdcall DialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
UNDEF:00002A14                 extrn __imp__DialogBoxParamW@20:near
UNDEF:00002A14                                         ; CODE XREF: TaskListDlg::doDialog(bool)+7Bp
UNDEF:00002A14                                         ; DATA XREF: TaskListDlg::doDialog(bool)+7Br
UNDEF:00002A18 ; INT_PTR __stdcall DialogBoxIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
UNDEF:00002A18                 extrn __imp__DialogBoxIndirectParamW@20:near
UNDEF:00002A18                                         ; CODE XREF: TaskListDlg::doDialog(bool)+47p
UNDEF:00002A18                                         ; DATA XREF: TaskListDlg::doDialog(bool)+47r
UNDEF:00002A1C ; BOOL __stdcall EndDialog(HWND hDlg, INT_PTR nResult)
UNDEF:00002A1C                 extrn __imp__EndDialog@8:near
UNDEF:00002A1C                                         ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+305p
UNDEF:00002A1C                                         ; DATA XREF: TaskListDlg::run_dlgProc(uint,uint,long)+305r
UNDEF:00002A20 ; int __stdcall GetSystemMetrics(int nIndex)
UNDEF:00002A20                 extrn __imp__GetSystemMetrics@4:near
UNDEF:00002A20                                         ; CODE XREF: TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+145p
UNDEF:00002A20                                         ; DATA XREF: TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+145r
UNDEF:00002A24 ; int __stdcall DrawTextW(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format)
UNDEF:00002A24                 extrn __imp__DrawTextW@20:near
UNDEF:00002A24                                         ; CODE XREF: TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+16Cp
UNDEF:00002A24                                         ; DATA XREF: TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+16Cr
UNDEF:00002A28 ; HHOOK __stdcall SetWindowsHookExW(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId)
UNDEF:00002A28                 extrn __imp__SetWindowsHookExW@16:near
UNDEF:00002A28                                         ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+187p
UNDEF:00002A28                                         ; DATA XREF: TaskListDlg::run_dlgProc(uint,uint,long)+187r
UNDEF:00002A2C ; BOOL __stdcall UnhookWindowsHookEx(HHOOK hhk)
UNDEF:00002A2C                 extrn __imp__UnhookWindowsHookEx@4:near
UNDEF:00002A2C                                         ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+1BEp
UNDEF:00002A2C                                         ; DATA XREF: TaskListDlg::run_dlgProc(uint,uint,long)+1BEr
UNDEF:00002A30 ; LRESULT __stdcall CallNextHookEx(HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam)
UNDEF:00002A30                 extrn __imp__CallNextHookEx@16:near
UNDEF:00002A30                                         ; CODE XREF: hookProc(uint,uint,long)+3Ap
UNDEF:00002A30                                         ; DATA XREF: hookProc(uint,uint,long)+3Ar
UNDEF:00002A34 ; void __thiscall StaticDialog::goToCenter(StaticDialog *__hidden this)
UNDEF:00002A34                 extrn ?goToCenter@StaticDialog@@QAEXXZ:near
UNDEF:00002A34                                         ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+153p
UNDEF:00002A38 ; INT_PTR __stdcall StaticDialog::dlgProc(HWND, UINT, WPARAM, LPARAM)
UNDEF:00002A38                 extrn ?dlgProc@StaticDialog@@KGHPAUHWND__@@IIJ@Z:near
UNDEF:00002A38                                         ; DATA XREF: TaskListDlg::doDialog(bool)+30o
UNDEF:00002A38                                         ; TaskListDlg::doDialog(bool)+63o
UNDEF:00002A3C ; void *__thiscall StaticDialog::makeRTLResource(StaticDialog *__hidden this, int, struct DLGTEMPLATE **)
UNDEF:00002A3C                 extrn ?makeRTLResource@StaticDialog@@IAEPAXHPAPAUDLGTEMPLATE@@@Z:near
UNDEF:00002A3C                                         ; CODE XREF: TaskListDlg::doDialog(bool)+24p
UNDEF:00002A40 ; BOOL __stdcall ImageList_Draw(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, UINT fStyle)
UNDEF:00002A40                 extrn __imp__ImageList_Draw@24:near
UNDEF:00002A40                                         ; CODE XREF: TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+118p
UNDEF:00002A40                                         ; DATA XREF: TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+118r
UNDEF:00002A44 ; BOOL __stdcall ImageList_GetImageInfo(HIMAGELIST himl, int i, IMAGEINFO *pImageInfo)
UNDEF:00002A44                 extrn __imp__ImageList_GetImageInfo@12:near
UNDEF:00002A44                                         ; CODE XREF: TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+CAp
UNDEF:00002A44                                         ; DATA XREF: TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+CAr
UNDEF:00002A48 ; void __thiscall TaskList::init(TaskList *__hidden this, HINSTANCE, HWND, struct _IMAGELIST *, int, int)
UNDEF:00002A48                 extrn ?init@TaskList@@QAEXPAUHINSTANCE__@@PAUHWND__@@PAU_IMAGELIST@@HH@Z:near
UNDEF:00002A48                                         ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+FAp
UNDEF:00002A4C ; void __thiscall TaskList::setFont(TaskList *__hidden this, wchar_t *, unsigned int)
UNDEF:00002A4C                 extrn ?setFont@TaskList@@QAEXPA_WI@Z:near
UNDEF:00002A4C                                         ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+10Cp
UNDEF:00002A50 ; struct tagRECT *__thiscall TaskList::adjustSize(TaskList *__hidden this, struct tagRECT *__return_ptr __struct_ptr retstr)
UNDEF:00002A50                 extrn ?adjustSize@TaskList@@QAE?AUtagRECT@@XZ:near
UNDEF:00002A50                                         ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+11Bp
UNDEF:00002A54 ; int __thiscall TaskList::updateCurrentIndex(TaskList *__hidden this)
UNDEF:00002A54                 extrn ?updateCurrentIndex@TaskList@@QAEHXZ:near
UNDEF:00002A54                                         ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+27Cp
UNDEF:00002A58 ; __fastcall __security_check_cookie(x)
UNDEF:00002A58                 extrn @__security_check_cookie@4:near
UNDEF:00002A58                                         ; CODE XREF: TaskListDlg::run_dlgProc(uint,uint,long)+321p
UNDEF:00002A58                                         ; TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+177p ...
UNDEF:00002A5C ; __stdcall _CxxThrowException(x, x)
UNDEF:00002A5C                 extrn __CxxThrowException@8:near
UNDEF:00002A5C                                         ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:00002A60                 extrn ___CxxFrameHandler3:near
UNDEF:00002A60                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j
UNDEF:00002A60                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+16j ...
UNDEF:00002A64 ; const type_info::`vftable'
UNDEF:00002A64                 extrn ??_7type_info@@6B@:near
UNDEF:00002A64                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:00002A64                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:00002A68                 extrn ___security_cookie:near
UNDEF:00002A68                                         ; DATA XREF: TaskListDlg::run_dlgProc(uint,uint,long)+6r
UNDEF:00002A68                                         ; TaskListDlg::drawItem(tagDRAWITEMSTRUCT *)+6r ...
UNDEF:00002A6C                 extrn __fltused:near
UNDEF:00002A6C
UNDEF:00002A6C
UNDEF:00002A6C                 end