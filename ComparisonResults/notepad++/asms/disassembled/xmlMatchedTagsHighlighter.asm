.data:00000000 ;
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.data:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.data:00000000 ; |                      License info: 48-3677-7074-51                      |
.data:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ;
.data:00000000 ; Input MD5   : 28B8E581098C4A24827FD08A9025EEF3
.data:00000000 ; Input CRC32 : A6F39094
.data:00000000
.data:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\xmlMatchedTagsHighlighter.obj
.data:00000000 ; Format      : COFF (X386MAGIC)
.data:00000000 ; includelib "libcpmtd"
.data:00000000 ; includelib "uuid.lib"
.data:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.data:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.data:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.data:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.data:00000000 ; includelib "LIBCMTD"
.data:00000000 ; includelib "OLDNAMES"
.data:00000000
.data:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.data:00000000
.data:00000000                 .686p
.data:00000000                 .mmx
.data:00000000                 .model flat
.data:00000000
.data:00000000 ; ===========================================================================
.data:00000000
.data:00000000 ; Segment type: Pure data
.data:00000000 ; Segment permissions: Read/Write
.data:00000000 ; Segment alignment 'qword' can not be represented in assembly
.data:00000000 _data           segment para public 'DATA' use32
.data:00000000                 assume cs:_data
.data:00000000 _acTop_xpm      dd offset $SG143481     ; "12 12 56 1"
.data:00000004                 dd offset $SG143482     ; " \tc #FFFFFF"
.data:00000008                 dd offset $SG143483     ; ".\tc #8AB2E9"
.data:0000000C                 dd offset $SG143484     ; "+\tc #CCDCF6"
.data:00000010                 dd offset $SG143485     ; "@\tc #80ABEA"
.data:00000014                 dd offset $SG143486     ; "#\tc #7DA9E8"
.data:00000018                 dd offset $SG143487     ; "$\tc #C7DAF3"
.data:0000001C                 dd offset $SG143488     ; "%\tc #79A7E6"
.data:00000020                 dd offset $SG143489     ; "&\tc #ADC8EF"
.data:00000024                 dd offset $SG143490     ; "*\tc #87B0E8"
.data:00000028                 dd offset $SG143491     ; "=\tc #BBD2F0"
.data:0000002C                 dd offset $SG143492     ; "-\tc #6EA0E2"
.data:00000030                 dd offset $SG143493     ; ";\tc #A8C7EE"
.data:00000034                 dd offset $SG143494     ; ">\tc #A3C2ED"
.data:00000038                 dd offset $SG143495     ; ",\tc #75A4E3"
.data:0000003C off_3C          dd offset $SG143496     ; DATA XREF: .rdata:$SG152401o
.data:0000003C                                         ; .rdata:$SG152490o ...
.data:0000003C                                         ; "'\tc #A7C4EB"
.data:00000040                 dd offset $SG143497     ; ")\tc #6297E1"
.data:00000044                 dd offset $SG143498     ; "!\tc #A1C1EC"
.data:00000048                 dd offset $SG143499     ; "~\tc #92B7E8"
.data:0000004C                 dd offset $SG143500     ; "{\tc #99BBE9"
.data:00000050                 dd offset $SG143501     ; "]\tc #6197DD"
.data:00000054                 dd offset $SG143502     ; "^\tc #96B9E6"
.data:00000058                 dd offset $SG143503     ; "/\tc #538EDB"
.data:0000005C                 dd offset $SG143504     ; "(\tc #99BBEA"
.data:00000060                 dd offset $SG143505     ; "_\tc #80AAE3"
.data:00000064                 dd offset $SG143506     ; ":\tc #81ABE3"
.data:00000068                 dd offset $SG143507     ; "<\tc #8AB1E4"
.data:0000006C                 dd offset $SG143508     ; "[\tc #4B88D6"
.data:00000070                 dd offset $SG143509     ; "}\tc #4882D1"
.data:00000074                 dd offset $SG143510     ; "|\tc #4384D6"
.data:00000078                 dd offset $SG143511     ; "1\tc #90B5E7"
.data:0000007C                 dd offset $SG143512     ; "2\tc #74A3E0"
.data:00000080                 dd offset $SG143513     ; "3\tc #77A4E0"
.data:00000084                 dd offset $SG143514     ; "4\tc #81ABE2"
.data:00000088                 dd offset $SG143515     ; "5\tc #437FD3"
.data:0000008C                 dd offset $SG143516     ; "6\tc #7FA2DF"
.data:00000090                 dd offset $SG143517     ; "7\tc #3577D2"
.data:00000094                 dd offset $SG143518     ; "8\tc #87AFE4"
.data:00000098                 dd offset $SG143519     ; "9\tc #72A1DF"
.data:0000009C                 dd offset $SG143520     ; "0\tc #7CA9E1"
.data:000000A0                 dd offset $SG143521     ; "a\tc #3F7AD0"
.data:000000A4                 dd offset $SG143522     ; "b\tc #85A4DE"
.data:000000A8                 dd offset $SG143523     ; "c\tc #FBFCFE"
.data:000000AC                 dd offset $SG143524     ; "d\tc #236ECD"
.data:000000B0                 dd offset $SG143525     ; "e\tc #7EA8E1"
.data:000000B4                 dd offset $SG143526     ; "f\tc #79A6E0"
.data:000000B8                 dd offset $SG143527     ; "g\tc #3D77D0"
.data:000000BC                 dd offset $SG143528     ; "h\tc #87A4DC"
.data:000000C0                 dd offset $SG143529     ; "i\tc #1A62C9"
.data:000000C4                 dd offset $SG143530     ; "j\tc #75A3DF"
.data:000000C8                 dd offset $SG143531     ; "k\tc #3C74CF"
.data:000000CC                 dd offset $SG143532     ; "l\tc #8DA6DE"
.data:000000D0                 dd offset $SG143533     ; "m\tc #1859C4"
.data:000000D4                 dd offset $SG143534     ; "n\tc #3B71CC"
.data:000000D8                 dd offset $SG143535     ; "o\tc #8EA5DD"
.data:000000DC                 dd offset $SG143536     ; "p\tc #164EC0"
.data:000000E0                 dd offset $SG143537     ; "q\tc #92A7DD"
.data:000000E4                 dd offset $SG143538     ; "    .+      "
.data:000000E8                 dd offset $SG143539     ; "    @#$     "
.data:000000EC                 dd offset $SG143540     ; "    %&*=    "
.data:000000F0                 dd offset $SG143541     ; "    -;>,'   "
.data:000000F4                 dd offset $SG143542     ; "    )!~{]^  "
.data:000000F8                 dd offset $SG143543     ; "    /(_:<[} "
.data:000000FC                 dd offset $SG143544     ; "    |123456 "
.data:00000100                 dd offset $SG143545     ; "    7890abc "
.data:00000104                 dd offset $SG143546     ; "    defgh   "
.data:00000108                 dd offset $SG143547     ; "    ijkl    "
.data:0000010C                 dd offset $SG143548     ; "    mno     "
.data:00000110                 dd offset $SG143549     ; "    pq      "
.data:00000114                 align 8
.data:00000118 _acBottom_xpm   dd offset $SG143551     ; "12 12 54 1"
.data:0000011C                 dd offset $SG143552     ; " \tc #FFFFFF"
.data:00000120                 dd offset $SG143553     ; ".\tc #C4D7F3"
.data:00000124                 dd offset $SG143554     ; "+\tc #72A1E3"
.data:00000128                 dd offset $SG143555     ; "@\tc #C1D6F2"
.data:0000012C                 dd offset $SG143556     ; "#\tc #6397E1"
.data:00000130                 dd offset $SG143557     ; "$\tc #5990DD"
.data:00000134                 dd offset $SG143558     ; "%\tc #BBD2F0"
.data:00000138                 dd offset $SG143559     ; "&\tc #7AA6E5"
.data:0000013C                 dd offset $SG143560     ; "*\tc #9ABDEA"
.data:00000140                 dd offset $SG143561     ; "=\tc #4A87D9"
.data:00000144                 dd offset $SG143562     ; "-\tc #B1CAEE"
.data:00000148                 dd offset $SG143563     ; ";\tc #75A4E3"
.data:0000014C                 dd offset $SG143564     ; ">\tc #99BBE9"
.data:00000150                 dd offset $SG143565     ; ",\tc #95B9E8"
.data:00000154                 dd offset $SG143566     ; "'\tc #3A7CD4"
.data:00000158                 dd offset $SG143567     ; ")\tc #A9C6EC"
.data:0000015C                 dd offset $SG143568     ; "!\tc #71A0E0"
.data:00000160                 dd offset $SG143569     ; "~\tc #86AFE5"
.data:00000164                 dd offset $SG143570     ; "{\tc #8DB2E6"
.data:00000168                 dd offset $SG143571     ; "]\tc #2A72CF"
.data:0000016C                 dd offset $SG143572     ; "^\tc #73A0E0"
.data:00000170                 dd offset $SG143573     ; "/\tc #6B9DE0"
.data:00000174                 dd offset $SG143574     ; "(\tc #95B8E8"
.data:00000178                 dd offset $SG143575     ; "_\tc #81ABE3"
.data:0000017C                 dd offset $SG143576     ; ":\tc #72A1DF"
.data:00000180                 dd offset $SG143577     ; "<\tc #83ADE3"
.data:00000184                 dd offset $SG143578     ; "[\tc #1B65C9"
.data:00000188                 dd offset $SG143579     ; "}\tc #5F95DC"
.data:0000018C                 dd offset $SG143580     ; "|\tc #8BB3E5"
.data:00000190                 dd offset $SG143581     ; "1\tc #77A4E0"
.data:00000194                 dd offset $SG143582     ; "2\tc #679ADC"
.data:00000198                 dd offset $SG143583     ; "3\tc #7AA6E1"
.data:0000019C                 dd offset $SG143584     ; "4\tc #195CC6"
.data:000001A0                 dd offset $SG143585     ; "5\tc #FCFDFE"
.data:000001A4                 dd offset $SG143586     ; "6\tc #8DB2E4"
.data:000001A8                 dd offset $SG143587     ; "7\tc #4885D6"
.data:000001AC                 dd offset $SG143588     ; "8\tc #7CA9E1"
.data:000001B0                 dd offset $SG143589     ; "9\tc #6698DB"
.data:000001B4                 dd offset $SG143590     ; "0\tc #71A1DE"
.data:000001B8                 dd offset $SG143591     ; "a\tc #1752C0"
.data:000001BC                 dd offset $SG143592     ; "b\tc #88ABE0"
.data:000001C0                 dd offset $SG143593     ; "c\tc #3D77D0"
.data:000001C4                 dd offset $SG143594     ; "d\tc #6E9FDD"
.data:000001C8                 dd offset $SG143595     ; "e\tc #699BDC"
.data:000001CC                 dd offset $SG143596     ; "f\tc #1547BD"
.data:000001D0                 dd offset $SG143597     ; "g\tc #8DA6DE"
.data:000001D4                 dd offset $SG143598     ; "h\tc #376BC9"
.data:000001D8                 dd offset $SG143599     ; "i\tc #6295DA"
.data:000001DC                 dd offset $SG143600     ; "j\tc #1440B9"
.data:000001E0                 dd offset $SG143601     ; "k\tc #8DA0DB"
.data:000001E4                 dd offset $SG143602     ; "l\tc #315FC4"
.data:000001E8                 dd offset $SG143603     ; "m\tc #1339B7"
.data:000001EC                 dd offset $SG143604     ; "n\tc #909FDA"
.data:000001F0                 dd offset $SG143605     ; "o\tc #1233B4"
.data:000001F4                 dd offset $SG143606     ; "         .+ "
.data:000001F8                 dd offset $SG143607     ; "        @#$ "
.data:000001FC                 dd offset $SG143608     ; "       %&*= L"
.data:00000200                 dd offset $SG143609     ; "      -;>,' "
.data:00000204                 dd offset $SG143610     ; "     )!>~{] "
.data:00000208                 dd offset $SG143611     ; "    ^/(_:<[ "
.data:0000020C                 dd offset $SG143612     ; "    (}|1234 "
.data:00000210                 dd offset $SG143613     ; "    567890a "
.data:00000214                 dd offset $SG143614     ; "      bcdef "
.data:00000218                 dd offset $SG143615     ; "       ghij "
.data:0000021C                 dd offset $SG143616     ; "        klm "
.data:00000220                 dd offset $SG143617     ; "         no "
.data:00000224                 align 8
.data:00000228 _bookmark_xpm   dd offset $SG143619     ; "13 14 54 1"
.data:0000022C                 dd offset $SG143620     ; " \tc None"
.data:00000230                 dd offset $SG143621     ; ".\tc #545254"
.data:00000234                 dd offset $SG143622     ; "+\tc #3C3E3C"
.data:00000238                 dd offset $SG143623     ; "@\tc #646464"
.data:0000023C                 dd offset $SG143624     ; "#\tc #A4A4A4"
.data:00000240                 dd offset $SG143625     ; "$\tc #B7B8B7"
.data:00000244                 dd offset $SG143626     ; "%\tc #747284"
.data:00000248                 dd offset $SG143627     ; "&\tc #B4B2C4"
.data:0000024C                 dd offset $SG143628     ; "*\tc #DCD7E4"
.data:00000250                 dd offset $SG143629     ; "=\tc #1C1A1C"
.data:00000254                 dd offset $SG143630     ; "-\tc #403E58"
.data:00000258                 dd offset $SG143631     ; ";\tc #5C5A8C"
.data:0000025C                 dd offset $SG143632     ; ">\tc #7C7EAC"
.data:00000260                 dd offset $SG143633     ; ",\tc #7C8EBC"
.data:00000264                 dd offset $SG143634     ; "'\tc #242644"
.data:00000268                 dd offset $SG143635     ; ")\tc #282668"
.data:0000026C                 dd offset $SG143636     ; "!\tc #24367C"
.data:00000270                 dd offset $SG143637     ; "~\tc #244A84"
.data:00000274                 dd offset $SG143638     ; "{\tc #2C5098"
.data:00000278                 dd offset $SG143639     ; "]\tc #14162C"
.data:0000027C                 dd offset $SG143640     ; "^\tc #142E7C"
.data:00000280                 dd offset $SG143641     ; "/\tc #143789"
.data:00000284                 dd offset $SG143642     ; "(\tc #204990"
.data:00000288                 dd offset $SG143643     ; "_\tc #174091"
.data:0000028C                 dd offset $SG143644     ; ":\tc #0C0630"
.data:00000290                 dd offset $SG143645     ; "<\tc #24327C"
.data:00000294                 dd offset $SG143646     ; "[\tc #2450A0"
.data:00000298                 dd offset $SG143647     ; "}\tc #345DB4"
.data:0000029C                 dd offset $SG143648     ; "|\tc #3C68B8"
.data:000002A0                 dd offset $SG143649     ; "1\tc #141244"
.data:000002A4                 dd offset $SG143650     ; "2\tc #24428C"
.data:000002A8                 dd offset $SG143651     ; "3\tc #3462B9"
.data:000002AC                 dd offset $SG143652     ; "4\tc #4470C4"
.data:000002B0                 dd offset $SG143653     ; "5\tc #4C7FD6"
.data:000002B4                 dd offset $SG143654     ; "6\tc #4472CC"
.data:000002B8                 dd offset $SG143655     ; "7\tc #24224C"
.data:000002BC                 dd offset $SG143656     ; "8\tc #5C8DEC"
.data:000002C0                 dd offset $SG143657     ; "9\tc #5C94F6"
.data:000002C4                 dd offset $SG143658     ; "0\tc #5482DF"
.data:000002C8                 dd offset $SG143659     ; "a\tc #619DF7"
.data:000002CC                 dd offset $SG143660     ; "b\tc #6CA6FC"
.data:000002D0                 dd offset $SG143661     ; "c\tc #64A2FC"
.data:000002D4                 dd offset $SG143662     ; "d\tc #1C2E5C"
.data:000002D8                 dd offset $SG143663     ; "e\tc #6CA2FC"
.data:000002DC                 dd offset $SG143664     ; "f\tc #74B2FC"
.data:000002E0                 dd offset $SG143665     ; "g\tc #7CB8FC"
.data:000002E4                 dd offset $SG143666     ; "h\tc #1C3264"
.data:000002E8                 dd offset $SG143667     ; "i\tc #346AD4"
.data:000002EC                 dd offset $SG143668     ; "j\tc #7CBEFC"
.data:000002F0                 dd offset $SG143669     ; "k\tc #3C72DC"
.data:000002F4                 dd offset $SG143670     ; "l\tc #243250"
.data:000002F8                 dd offset $SG143671     ; "m\tc #346AB4"
.data:000002FC                 dd offset $SG143672     ; "n\tc #3C82DC"
.data:00000300                 dd offset $SG143673     ; "o\tc #6C6A6C"
.data:00000304                 dd offset $SG143674     ; "     .+.     "
.data:00000308                 dd offset $SG143675     ; "   @##$##@   "
.data:0000030C                 dd offset $SG143676     ; "  @%&***&%@  "
.data:00000310                 dd offset $SG143677     ; " =-;>,,,>;-= "
.data:00000314                 dd offset $SG143678     ; " ')!~{{{~!)' "
.data:00000318                 dd offset $SG143679     ; "])^/({{{(_^)]"
.data:0000031C                 dd offset $SG143680     ; ":<_[}|||}[_<:"
.data:00000320                 dd offset $SG143681     ; "12[3455563[21"
.data:00000324                 dd offset $SG143682     ; "7_365899063_7"
.data:00000328                 dd offset $SG143683     ; " /|09abc904/ "
.data:0000032C                 dd offset $SG143684     ; " d}8efgfb83d "
.data:00000330                 dd offset $SG143685     ; "  hiafjgakh  "
.data:00000334                 dd offset $SG143686     ; "   l~mnm~l   "
.data:00000338                 dd offset $SG143687     ; "     o@o     "
.data:00000338 _data           ends
.data:00000338
.rdata:0000033C ; ===========================================================================
.rdata:0000033C
.rdata:0000033C ; Segment type: Pure data
.rdata:0000033C ; Segment permissions: Read
.rdata:0000033C _rdata          segment dword public 'DATA' use32
.rdata:0000033C                 assume cs:_rdata
.rdata:0000033C                 ;org 33Ch
.rdata:0000033C $SG143481       db '12 12 56 1',0       ; DATA XREF: .data:_acTop_xpmo
.rdata:00000347                 align 4
.rdata:00000348 $SG143482       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:00000004o
.rdata:00000354 $SG143483       db '.',9,'c #8AB2E9',0  ; DATA XREF: .data:00000008o
.rdata:00000360 $SG143484       db '+',9,'c #CCDCF6',0  ; DATA XREF: .data:0000000Co
.rdata:0000036C $SG143485       db '@',9,'c #80ABEA',0  ; DATA XREF: .data:00000010o
.rdata:00000378 $SG143486       db '#',9,'c #7DA9E8',0  ; DATA XREF: .data:00000014o
.rdata:00000384 $SG143487       db '$',9,'c #C7DAF3',0  ; DATA XREF: .data:00000018o
.rdata:00000390 $SG143488       db '%',9,'c #79A7E6',0  ; DATA XREF: .data:0000001Co
.rdata:0000039C $SG143489       db '&',9,'c #ADC8EF',0  ; DATA XREF: .data:00000020o
.rdata:000003A8 $SG143490       db '*',9,'c #87B0E8',0  ; DATA XREF: .data:00000024o
.rdata:000003B4 $SG143491       db '=',9,'c #BBD2F0',0  ; DATA XREF: .data:00000028o
.rdata:000003C0 $SG143492       db '-',9,'c #6EA0E2',0  ; DATA XREF: .data:0000002Co
.rdata:000003CC $SG143493       db ';',9,'c #A8C7EE',0  ; DATA XREF: .data:00000030o
.rdata:000003D8 $SG143494       db '>',9,'c #A3C2ED',0  ; DATA XREF: .data:00000034o
.rdata:000003E4 $SG143495       db ',',9,'c #75A4E3',0  ; DATA XREF: .data:00000038o
.rdata:000003F0 $SG143496       db 27h,9,'c #A7C4EB',0  ; DATA XREF: .data:off_3Co
.rdata:000003FC $SG143497       db ')',9,'c #6297E1',0  ; DATA XREF: .data:00000040o
.rdata:00000408 $SG143498       db '!',9,'c #A1C1EC',0  ; DATA XREF: .data:00000044o
.rdata:00000414 $SG143499       db '~',9,'c #92B7E8',0  ; DATA XREF: .data:00000048o
.rdata:00000420 $SG143500       db '{',9,'c #99BBE9',0  ; DATA XREF: .data:0000004Co
.rdata:0000042C $SG143501       db ']',9,'c #6197DD',0  ; DATA XREF: .data:00000050o
.rdata:00000438 $SG143502       db '^',9,'c #96B9E6',0  ; DATA XREF: .data:00000054o
.rdata:00000444 $SG143503       db '/',9,'c #538EDB',0  ; DATA XREF: .data:00000058o
.rdata:00000450 $SG143504       db '(',9,'c #99BBEA',0  ; DATA XREF: .data:0000005Co
.rdata:0000045C $SG143505       db '_',9,'c #80AAE3',0  ; DATA XREF: .data:00000060o
.rdata:00000468 $SG143506       db ':',9,'c #81ABE3',0  ; DATA XREF: .data:00000064o
.rdata:00000474 $SG143507       db '<',9,'c #8AB1E4',0  ; DATA XREF: .data:00000068o
.rdata:00000480 $SG143508       db '[',9,'c #4B88D6',0  ; DATA XREF: .data:0000006Co
.rdata:0000048C $SG143509       db '}',9,'c #4882D1',0  ; DATA XREF: .data:00000070o
.rdata:00000498 $SG143510       db '|',9,'c #4384D6',0  ; DATA XREF: .data:00000074o
.rdata:000004A4 $SG143511       db '1',9,'c #90B5E7',0  ; DATA XREF: .data:00000078o
.rdata:000004B0 $SG143512       db '2',9,'c #74A3E0',0  ; DATA XREF: .data:0000007Co
.rdata:000004BC $SG143513       db '3',9,'c #77A4E0',0  ; DATA XREF: .data:00000080o
.rdata:000004C8 $SG143514       db '4',9,'c #81ABE2',0  ; DATA XREF: .data:00000084o
.rdata:000004D4 $SG143515       db '5',9,'c #437FD3',0  ; DATA XREF: .data:00000088o
.rdata:000004E0 $SG143516       db '6',9,'c #7FA2DF',0  ; DATA XREF: .data:0000008Co
.rdata:000004EC $SG143517       db '7',9,'c #3577D2',0  ; DATA XREF: .data:00000090o
.rdata:000004F8 $SG143518       db '8',9,'c #87AFE4',0  ; DATA XREF: .data:00000094o
.rdata:00000504 $SG143519       db '9',9,'c #72A1DF',0  ; DATA XREF: .data:00000098o
.rdata:00000510 $SG143520       db '0',9,'c #7CA9E1',0  ; DATA XREF: .data:0000009Co
.rdata:0000051C $SG143521       db 'a',9,'c #3F7AD0',0  ; DATA XREF: .data:000000A0o
.rdata:00000528 $SG143522       db 'b',9,'c #85A4DE',0  ; DATA XREF: .data:000000A4o
.rdata:00000534 $SG143523       db 'c',9,'c #FBFCFE',0  ; DATA XREF: .data:000000A8o
.rdata:00000540 $SG143524       db 'd',9,'c #236ECD',0  ; DATA XREF: .data:000000ACo
.rdata:0000054C $SG143525       db 'e',9,'c #7EA8E1',0  ; DATA XREF: .data:000000B0o
.rdata:00000558 $SG143526       db 'f',9,'c #79A6E0',0  ; DATA XREF: .data:000000B4o
.rdata:00000564 $SG143527       db 'g',9,'c #3D77D0',0  ; DATA XREF: .data:000000B8o
.rdata:00000570 $SG143528       db 'h',9,'c #87A4DC',0  ; DATA XREF: .data:000000BCo
.rdata:0000057C $SG143529       db 'i',9,'c #1A62C9',0  ; DATA XREF: .data:000000C0o
.rdata:00000588 $SG143530       db 'j',9,'c #75A3DF',0  ; DATA XREF: .data:000000C4o
.rdata:00000594 $SG143531       db 'k',9,'c #3C74CF',0  ; DATA XREF: .data:000000C8o
.rdata:000005A0 $SG143532       db 'l',9,'c #8DA6DE',0  ; DATA XREF: .data:000000CCo
.rdata:000005AC $SG143533       db 'm',9,'c #1859C4',0  ; DATA XREF: .data:000000D0o
.rdata:000005B8 $SG152750       dd offset loc_3F39+3    ; DATA XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+9Ao
.rdata:000005BC $SG143534       db 'n',9,'c #3B71CC',0  ; DATA XREF: .data:000000D4o
.rdata:000005C8 $SG152751       dd offset loc_253A+2    ; DATA XREF: XmlMatchedTagsHighlighter::tagMatch(bool):loc_E3Eo
.rdata:000005CC $SG143535       db 'o',9,'c #8EA5DD',0  ; DATA XREF: .data:000000D8o
.rdata:000005D8 $SG143536       db 'p',9,'c #164EC0',0  ; DATA XREF: .data:000000DCo
.rdata:000005E4 $SG143537       db 'q',9,'c #92A7DD',0  ; DATA XREF: .data:000000E0o
.rdata:000005F0 $SG143538       db '    .+      ',0     ; DATA XREF: .data:000000E4o
.rdata:000005FD                 align 10h
.rdata:00000600 $SG143539       db '    @#$     ',0     ; DATA XREF: .data:000000E8o
.rdata:0000060D                 align 10h
.rdata:00000610 $SG143540       db '    %&*=    ',0     ; DATA XREF: .data:000000ECo
.rdata:0000061D                 align 10h
.rdata:00000620 $SG143541       db '    -;>,',27h,'   ',0 ; DATA XREF: .data:000000F0o
.rdata:0000062D                 align 10h
.rdata:00000630 $SG143542       db '    )!~{]^  ',0     ; DATA XREF: .data:000000F4o
.rdata:0000063D                 align 10h
.rdata:00000640 $SG143543       db '    /(_:<[} ',0     ; DATA XREF: .data:000000F8o
.rdata:0000064D                 align 10h
.rdata:00000650 $SG143544       db '    |123456 ',0     ; DATA XREF: .data:000000FCo
.rdata:0000065D                 align 10h
.rdata:00000660 $SG143545       db '    7890abc ',0     ; DATA XREF: .data:00000100o
.rdata:0000066D                 align 10h
.rdata:00000670 $SG143546       db '    defgh   ',0     ; DATA XREF: .data:00000104o
.rdata:0000067D                 align 10h
.rdata:00000680 $SG143547       db '    ijkl    ',0     ; DATA XREF: .data:00000108o
.rdata:0000068D                 align 10h
.rdata:00000690 $SG143548       db '    mno     ',0     ; DATA XREF: .data:0000010Co
.rdata:0000069D                 align 10h
.rdata:000006A0 $SG143549       db '    pq      ',0     ; DATA XREF: .data:00000110o
.rdata:000006AD                 align 10h
.rdata:000006B0 $SG143551       db '12 12 54 1',0       ; DATA XREF: .data:_acBottom_xpmo
.rdata:000006BB                 align 4
.rdata:000006BC $SG143552       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:0000011Co
.rdata:000006C8 $SG152769       dd offset loc_3E3F      ; DATA XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+CCo
.rdata:000006CC $SG143553       db '.',9,'c #C4D7F3',0  ; DATA XREF: .data:00000120o
.rdata:000006D8 $SG152770       dd offset loc_3E23+2    ; DATA XREF: XmlMatchedTagsHighlighter::tagMatch(bool):loc_E70o
.rdata:000006DC $SG143554       db '+',9,'c #72A1E3',0  ; DATA XREF: .data:00000124o
.rdata:000006E8 $SG143555       db '@',9,'c #C1D6F2',0  ; DATA XREF: .data:00000128o
.rdata:000006F4 $SG143556       db '#',9,'c #6397E1',0  ; DATA XREF: .data:0000012Co
.rdata:00000700 $SG143557       db '$',9,'c #5990DD',0  ; DATA XREF: .data:00000130o
.rdata:0000070C $SG143558       db '%',9,'c #BBD2F0',0  ; DATA XREF: .data:00000134o
.rdata:00000718 $SG143559       db '&',9,'c #7AA6E5',0  ; DATA XREF: .data:00000138o
.rdata:00000724 $SG143560       db '*',9,'c #9ABDEA',0  ; DATA XREF: .data:0000013Co
.rdata:00000730 $SG143561       db '=',9,'c #4A87D9',0  ; DATA XREF: .data:00000140o
.rdata:0000073C $SG143562       db '-',9,'c #B1CAEE',0  ; DATA XREF: .data:00000144o
.rdata:00000748 $SG143563       db ';',9,'c #75A4E3',0  ; DATA XREF: .data:00000148o
.rdata:00000754 $SG143564       db '>',9,'c #99BBE9',0  ; DATA XREF: .data:0000014Co
.rdata:00000760 $SG143565       db ',',9,'c #95B9E8',0  ; DATA XREF: .data:00000150o
.rdata:0000076C $SG143566       db 27h,9,'c #3A7CD4',0  ; DATA XREF: .data:00000154o
.rdata:00000778 $SG143567       db ')',9,'c #A9C6EC',0  ; DATA XREF: .data:00000158o
.rdata:00000784 $SG143568       db '!',9,'c #71A0E0',0  ; DATA XREF: .data:0000015Co
.rdata:00000790 $SG143569       db '~',9,'c #86AFE5',0  ; DATA XREF: .data:00000160o
.rdata:0000079C $SG143570       db '{',9,'c #8DB2E6',0  ; DATA XREF: .data:00000164o
.rdata:000007A8 $SG143571       db ']',9,'c #2A72CF',0  ; DATA XREF: .data:00000168o
.rdata:000007B4 $SG143572       db '^',9,'c #73A0E0',0  ; DATA XREF: .data:0000016Co
.rdata:000007C0 $SG143573       db '/',9,'c #6B9DE0',0  ; DATA XREF: .data:00000170o
.rdata:000007CC $SG143574       db '(',9,'c #95B8E8',0  ; DATA XREF: .data:00000174o
.rdata:000007D8 $SG143575       db '_',9,'c #81ABE3',0  ; DATA XREF: .data:00000178o
.rdata:000007E4 $SG143576       db ':',9,'c #72A1DF',0  ; DATA XREF: .data:0000017Co
.rdata:000007F0 $SG143577       db '<',9,'c #83ADE3',0  ; DATA XREF: .data:00000180o
.rdata:000007FC $SG143578       db '[',9,'c #1B65C9',0  ; DATA XREF: .data:00000184o
.rdata:00000808 $SG143579       db '}',9,'c #5F95DC',0  ; DATA XREF: .data:00000188o
.rdata:00000814 $SG143580       db '|',9,'c #8BB3E5',0  ; DATA XREF: .data:0000018Co
.rdata:00000820 $SG143581       db '1',9,'c #77A4E0',0  ; DATA XREF: .data:00000190o
.rdata:0000082C $SG143582       db '2',9,'c #679ADC',0  ; DATA XREF: .data:00000194o
.rdata:00000838 $SG143583       db '3',9,'c #7AA6E1',0  ; DATA XREF: .data:00000198o
.rdata:00000844 $SG143584       db '4',9,'c #195CC6',0  ; DATA XREF: .data:0000019Co
.rdata:00000850 $SG143585       db '5',9,'c #FCFDFE',0  ; DATA XREF: .data:000001A0o
.rdata:0000085C $SG143586       db '6',9,'c #8DB2E4',0  ; DATA XREF: .data:000001A4o
.rdata:00000868 $SG143587       db '7',9,'c #4885D6',0  ; DATA XREF: .data:000001A8o
.rdata:00000874 $SG143588       db '8',9,'c #7CA9E1',0  ; DATA XREF: .data:000001ACo
.rdata:00000880 $SG143589       db '9',9,'c #6698DB',0  ; DATA XREF: .data:000001B0o
.rdata:0000088C $SG143590       db '0',9,'c #71A1DE',0  ; DATA XREF: .data:000001B4o
.rdata:00000898 $SG143591       db 'a',9,'c #1752C0',0  ; DATA XREF: .data:000001B8o
.rdata:000008A4 $SG143592       db 'b',9,'c #88ABE0',0  ; DATA XREF: .data:000001BCo
.rdata:000008B0 $SG143593       db 'c',9,'c #3D77D0',0  ; DATA XREF: .data:000001C0o
.rdata:000008BC $SG143594       db 'd',9,'c #6E9FDD',0  ; DATA XREF: .data:000001C4o
.rdata:000008C8 $SG143595       db 'e',9,'c #699BDC',0  ; DATA XREF: .data:000001C8o
.rdata:000008D4 $SG143596       db 'f',9,'c #1547BD',0  ; DATA XREF: .data:000001CCo
.rdata:000008E0 $SG143597       db 'g',9,'c #8DA6DE',0  ; DATA XREF: .data:000001D0o
.rdata:000008EC $SG143598       db 'h',9,'c #376BC9',0  ; DATA XREF: .data:000001D4o
.rdata:000008F8 $SG143599       db 'i',9,'c #6295DA',0  ; DATA XREF: .data:000001D8o
.rdata:00000904 $SG143600       db 'j',9,'c #1440B9',0  ; DATA XREF: .data:000001DCo
.rdata:00000910 $SG143601       db 'k',9,'c #8DA0DB',0  ; DATA XREF: .data:000001E0o
.rdata:0000091C $SG143602       db 'l',9,'c #315FC4',0  ; DATA XREF: .data:000001E4o
.rdata:00000928 $SG143603       db 'm',9,'c #1339B7',0  ; DATA XREF: .data:000001E8o
.rdata:00000934 $SG143604       db 'n',9,'c #909FDA',0  ; DATA XREF: .data:000001ECo
.rdata:00000940 $SG143605       db 'o',9,'c #1233B4',0  ; DATA XREF: .data:000001F0o
.rdata:0000094C $SG143606       db '         .+ ',0     ; DATA XREF: .data:000001F4o
.rdata:00000959                 align 4
.rdata:0000095C $SG143607       db '        @#$ ',0     ; DATA XREF: .data:000001F8o
.rdata:00000969                 align 4
.rdata:0000096C $SG143608       db '       %&*= L',0    ; DATA XREF: .data:000001FCo
.rdata:0000097A                 align 4
.rdata:0000097C $SG143609       db '      -;>,',27h,' ',0 ; DATA XREF: .data:00000200o
.rdata:00000989                 align 4
.rdata:0000098C $SG143610       db '     )!>~{] ',0     ; DATA XREF: .data:00000204o
.rdata:00000999                 align 4
.rdata:0000099C $SG143611       db '    ^/(_:<[ ',0     ; DATA XREF: .data:00000208o
.rdata:000009A9                 align 4
.rdata:000009AC $SG143612       db '    (}|1234 ',0     ; DATA XREF: .data:0000020Co
.rdata:000009B9                 align 4
.rdata:000009BC $SG143613       db '    567890a ',0     ; DATA XREF: .data:00000210o
.rdata:000009C9                 align 4
.rdata:000009CC $SG143614       db '      bcdef ',0     ; DATA XREF: .data:00000214o
.rdata:000009D9                 align 4
.rdata:000009DC $SG143615       db '       ghij ',0     ; DATA XREF: .data:00000218o
.rdata:000009E9                 align 4
.rdata:000009EC $SG143616       db '        klm ',0     ; DATA XREF: .data:0000021Co
.rdata:000009F9                 align 4
.rdata:000009FC $SG143617       db '         no ',0     ; DATA XREF: .data:00000220o
.rdata:00000A09                 align 4
.rdata:00000A0C $SG143619       db '13 14 54 1',0       ; DATA XREF: .data:_bookmark_xpmo
.rdata:00000A17                 align 4
.rdata:00000A18 $SG143620       db ' ',9,'c None',0     ; DATA XREF: .data:0000022Co
.rdata:00000A21                 align 4
.rdata:00000A24 $SG143621       db '.',9,'c #545254',0  ; DATA XREF: .data:00000230o
.rdata:00000A30 $SG143622       db '+',9,'c #3C3E3C',0  ; DATA XREF: .data:00000234o
.rdata:00000A3C $SG143623       db '@',9,'c #646464',0  ; DATA XREF: .data:00000238o
.rdata:00000A48 $SG143624       db '#',9,'c #A4A4A4',0  ; DATA XREF: .data:0000023Co
.rdata:00000A54 $SG143625       db '$',9,'c #B7B8B7',0  ; DATA XREF: .data:00000240o
.rdata:00000A60 $SG143626       db '%',9,'c #747284',0  ; DATA XREF: .data:00000244o
.rdata:00000A6C $SG143627       db '&',9,'c #B4B2C4',0  ; DATA XREF: .data:00000248o
.rdata:00000A78 $SG143628       db '*',9,'c #DCD7E4',0  ; DATA XREF: .data:0000024Co
.rdata:00000A84 $SG143629       db '=',9,'c #1C1A1C',0  ; DATA XREF: .data:00000250o
.rdata:00000A90 $SG143630       db '-',9,'c #403E58',0  ; DATA XREF: .data:00000254o
.rdata:00000A9C $SG143631       db ';',9,'c #5C5A8C',0  ; DATA XREF: .data:00000258o
.rdata:00000AA8 $SG143632       db '>',9,'c #7C7EAC',0  ; DATA XREF: .data:0000025Co
.rdata:00000AB4 $SG143633       db ',',9,'c #7C8EBC',0  ; DATA XREF: .data:00000260o
.rdata:00000AC0 $SG143634       db 27h,9,'c #242644',0  ; DATA XREF: .data:00000264o
.rdata:00000ACC $SG143635       db ')',9,'c #282668',0  ; DATA XREF: .data:00000268o
.rdata:00000AD8 $SG143636       db '!',9,'c #24367C',0  ; DATA XREF: .data:0000026Co
.rdata:00000AE4 $SG143637       db '~',9,'c #244A84',0  ; DATA XREF: .data:00000270o
.rdata:00000AF0 $SG143638       db '{',9,'c #2C5098',0  ; DATA XREF: .data:00000274o
.rdata:00000AFC $SG143639       db ']',9,'c #14162C',0  ; DATA XREF: .data:00000278o
.rdata:00000B08 $SG143640       db '^',9,'c #142E7C',0  ; DATA XREF: .data:0000027Co
.rdata:00000B14 $SG143641       db '/',9,'c #143789',0  ; DATA XREF: .data:00000280o
.rdata:00000B20 $SG143642       db '(',9,'c #204990',0  ; DATA XREF: .data:00000284o
.rdata:00000B2C $SG143643       db '_',9,'c #174091',0  ; DATA XREF: .data:00000288o
.rdata:00000B38 $SG143644       db ':',9,'c #0C0630',0  ; DATA XREF: .data:0000028Co
.rdata:00000B44 $SG143645       db '<',9,'c #24327C',0  ; DATA XREF: .data:00000290o
.rdata:00000B50 $SG143646       db '[',9,'c #2450A0',0  ; DATA XREF: .data:00000294o
.rdata:00000B5C $SG143647       db '}',9,'c #345DB4',0  ; DATA XREF: .data:00000298o
.rdata:00000B68 $SG143648       db '|',9,'c #3C68B8',0  ; DATA XREF: .data:0000029Co
.rdata:00000B74 $SG143649       db '1',9,'c #141244',0  ; DATA XREF: .data:000002A0o
.rdata:00000B80 $SG143650       db '2',9,'c #24428C',0  ; DATA XREF: .data:000002A4o
.rdata:00000B8C $SG143651       db '3',9,'c #3462B9',0  ; DATA XREF: .data:000002A8o
.rdata:00000B98 $SG143652       db '4',9,'c #4470C4',0  ; DATA XREF: .data:000002ACo
.rdata:00000BA4 $SG143653       db '5',9,'c #4C7FD6',0  ; DATA XREF: .data:000002B0o
.rdata:00000BB0 $SG143654       db '6',9,'c #4472CC',0  ; DATA XREF: .data:000002B4o
.rdata:00000BBC $SG143655       db '7',9,'c #24224C',0  ; DATA XREF: .data:000002B8o
.rdata:00000BC8 $SG143656       db '8',9,'c #5C8DEC',0  ; DATA XREF: .data:000002BCo
.rdata:00000BD4 $SG143657       db '9',9,'c #5C94F6',0  ; DATA XREF: .data:000002C0o
.rdata:00000BE0 $SG143658       db '0',9,'c #5482DF',0  ; DATA XREF: .data:000002C4o
.rdata:00000BEC $SG143659       db 'a',9,'c #619DF7',0  ; DATA XREF: .data:000002C8o
.rdata:00000BF8 $SG143660       db 'b',9,'c #6CA6FC',0  ; DATA XREF: .data:000002CCo
.rdata:00000C04 $SG143661       db 'c',9,'c #64A2FC',0  ; DATA XREF: .data:000002D0o
.rdata:00000C10 $SG143662       db 'd',9,'c #1C2E5C',0  ; DATA XREF: .data:000002D4o
.rdata:00000C1C $SG143663       db 'e',9,'c #6CA2FC',0  ; DATA XREF: .data:000002D8o
.rdata:00000C28 $SG143664       db 'f',9,'c #74B2FC',0  ; DATA XREF: .data:000002DCo
.rdata:00000C34 $SG143665       db 'g',9,'c #7CB8FC',0  ; DATA XREF: .data:000002E0o
.rdata:00000C40 $SG143666       db 'h',9,'c #1C3264',0  ; DATA XREF: .data:000002E4o
.rdata:00000C4C $SG143667       db 'i',9,'c #346AD4',0  ; DATA XREF: .data:000002E8o
.rdata:00000C58 $SG143668       db 'j',9,'c #7CBEFC',0  ; DATA XREF: .data:000002ECo
.rdata:00000C64 $SG143669       db 'k',9,'c #3C72DC',0  ; DATA XREF: .data:000002F0o
.rdata:00000C70 $SG143670       db 'l',9,'c #243250',0  ; DATA XREF: .data:000002F4o
.rdata:00000C7C $SG143671       db 'm',9,'c #346AB4',0  ; DATA XREF: .data:000002F8o
.rdata:00000C88 $SG143672       db 'n',9,'c #3C82DC',0  ; DATA XREF: .data:000002FCo
.rdata:00000C94 $SG143673       db 'o',9,'c #6C6A6C',0  ; DATA XREF: .data:00000300o
.rdata:00000CA0 $SG143674       db '     .+.     ',0    ; DATA XREF: .data:00000304o
.rdata:00000CAE                 align 10h
.rdata:00000CB0 $SG143675       db '   @##$##@   ',0    ; DATA XREF: .data:00000308o
.rdata:00000CBE                 align 10h
.rdata:00000CC0 $SG143676       db '  @%&***&%@  ',0    ; DATA XREF: .data:0000030Co
.rdata:00000CCE                 align 10h
.rdata:00000CD0 $SG143677       db ' =-;>,,,>;-= ',0    ; DATA XREF: .data:00000310o
.rdata:00000CDE                 align 10h
.rdata:00000CE0 $SG143678       db ' ',27h,')!~{{{~!)',27h,' ',0
.rdata:00000CE0                                         ; DATA XREF: .data:00000314o
.rdata:00000CEE                 align 10h
.rdata:00000CF0 $SG143679       db '])^/({{{(_^)]',0    ; DATA XREF: .data:00000318o
.rdata:00000CFE                 align 10h
.rdata:00000D00 $SG143680       db ':<_[}|||}[_<:',0    ; DATA XREF: .data:0000031Co
.rdata:00000D0E                 align 10h
.rdata:00000D10 $SG143681       db '12[3455563[21',0    ; DATA XREF: .data:00000320o
.rdata:00000D1E                 align 10h
.rdata:00000D20 $SG143682       db '7_365899063_7',0    ; DATA XREF: .data:00000324o
.rdata:00000D2E                 align 10h
.rdata:00000D30 $SG143683       db ' /|09abc904/ ',0    ; DATA XREF: .data:00000328o
.rdata:00000D3E                 align 10h
.rdata:00000D40 $SG143684       db ' d}8efgfb83d ',0    ; DATA XREF: .data:0000032Co
.rdata:00000D4E                 align 10h
.rdata:00000D50 $SG143685       db '  hiafjgakh  ',0    ; DATA XREF: .data:00000330o
.rdata:00000D5E                 align 10h
.rdata:00000D60 $SG143686       db '   l~mnm~l   ',0    ; DATA XREF: .data:00000334o
.rdata:00000D6E                 align 10h
.rdata:00000D70 $SG143687       db '     o@o     ',0    ; DATA XREF: .data:00000338o
.rdata:00000D7E                 align 10h
.rdata:00000D80 $SG152401       dd offset off_3C        ; DATA XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+6Bo
.rdata:00000D84 $SG152410       dd offset off_3C+2      ; DATA XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+112o
.rdata:00000D88 $SG152419       dd offset off_3C+2      ; DATA XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+1FCo
.rdata:00000D8C ; char _SG152490[]
.rdata:00000D8C $SG152490       dd offset off_3C        ; DATA XREF: XmlMatchedTagsHighlighter::findOpenTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+2Bo
.rdata:00000D90 $SG152526       dd offset off_3C+2      ; DATA XREF: XmlMatchedTagsHighlighter::findCloseAngle(int,int)+42o
.rdata:00000D94 ; char _SG152540[3]
.rdata:00000D94 $SG152540       db '</',0               ; DATA XREF: XmlMatchedTagsHighlighter::findCloseTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+2Bo
.rdata:00000D97                 align 4
.rdata:00000D97 _rdata          ends
.rdata:00000D97
.text$mn:00000D98 ; ===========================================================================
.text$mn:00000D98
.text$mn:00000D98 ; Segment type: Pure code
.text$mn:00000D98 ; Segment permissions: Read/Execute
.text$mn:00000D98 _text$mn        segment para public 'CODE' use32
.text$mn:00000D98                 assume cs:_text$mn
.text$mn:00000D98                 ;org 0D98h
.text$mn:00000D98                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000D98
.text$mn:00000D98 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D98
.text$mn:00000D98 ; Attributes: bp-based frame
.text$mn:00000D98
.text$mn:00000D98 ; void __thiscall XmlMatchedTagsHighlighter::tagMatch(XmlMatchedTagsHighlighter *this, bool)
.text$mn:00000D98                 public ?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z
.text$mn:00000D98 ?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z proc near
.text$mn:00000D98
.text$mn:00000D98 var_C4          = byte ptr -0C4h
.text$mn:00000D98 var_B4          = dword ptr -0B4h
.text$mn:00000D98 var_B0          = dword ptr -0B0h
.text$mn:00000D98 var_AC          = dword ptr -0ACh
.text$mn:00000D98 var_A8          = dword ptr -0A8h
.text$mn:00000D98 var_A4          = dword ptr -0A4h
.text$mn:00000D98 var_A0          = dword ptr -0A0h
.text$mn:00000D98 var_9C          = dword ptr -9Ch
.text$mn:00000D98 var_98          = dword ptr -98h
.text$mn:00000D98 var_94          = dword ptr -94h
.text$mn:00000D98 var_90          = dword ptr -90h
.text$mn:00000D98 Str             = dword ptr -8Ch
.text$mn:00000D98 var_88          = dword ptr -88h
.text$mn:00000D98 var_84          = dword ptr -84h
.text$mn:00000D98 var_80          = dword ptr -80h
.text$mn:00000D98 var_7C          = dword ptr -7Ch
.text$mn:00000D98 var_78          = dword ptr -78h
.text$mn:00000D98 var_74          = dword ptr -74h
.text$mn:00000D98 var_70          = dword ptr -70h
.text$mn:00000D98 var_6C          = dword ptr -6Ch
.text$mn:00000D98 var_68          = dword ptr -68h
.text$mn:00000D98 var_64          = dword ptr -64h
.text$mn:00000D98 var_60          = byte ptr -60h
.text$mn:00000D98 var_44          = byte ptr -44h
.text$mn:00000D98 var_28          = byte ptr -28h
.text$mn:00000D98 var_24          = dword ptr -24h
.text$mn:00000D98 var_20          = byte ptr -20h
.text$mn:00000D98 var_1C          = dword ptr -1Ch
.text$mn:00000D98 var_14          = byte ptr -14h
.text$mn:00000D98 var_10          = dword ptr -10h
.text$mn:00000D98 var_C           = dword ptr -0Ch
.text$mn:00000D98 var_4           = dword ptr -4
.text$mn:00000D98 arg_0           = byte ptr  8
.text$mn:00000D98
.text$mn:00000D98                 push    ebp
.text$mn:00000D99                 mov     ebp, esp
.text$mn:00000D9B                 push    0FFFFFFFFh
.text$mn:00000D9D                 push    offset __ehhandler$?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z
.text$mn:00000DA2                 mov     eax, large fs:0
.text$mn:00000DA8                 push    eax
.text$mn:00000DA9                 sub     esp, 0B8h
.text$mn:00000DAF                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000DB4                 xor     eax, ebp
.text$mn:00000DB6                 mov     [ebp+var_10], eax
.text$mn:00000DB9                 push    esi
.text$mn:00000DBA                 push    eax
.text$mn:00000DBB                 lea     eax, [ebp+var_C]
.text$mn:00000DBE                 mov     large fs:0, eax
.text$mn:00000DC4                 mov     [ebp+var_78], ecx
.text$mn:00000DC7                 push    1Bh             ; int
.text$mn:00000DC9                 mov     eax, [ebp+var_78]
.text$mn:00000DCC                 mov     ecx, [eax]      ; this
.text$mn:00000DCE                 call    ?clearIndicator@ScintillaEditView@@QAEXH@Z ; ScintillaEditView::clearIndicator(int)
.text$mn:00000DD3                 push    1Ah             ; int
.text$mn:00000DD5                 mov     ecx, [ebp+var_78]
.text$mn:00000DD8                 mov     ecx, [ecx]      ; this
.text$mn:00000DDA                 call    ?clearIndicator@ScintillaEditView@@QAEXH@Z ; ScintillaEditView::clearIndicator(int)
.text$mn:00000DDF                 mov     edx, [ebp+var_78]
.text$mn:00000DE2                 mov     ecx, [edx]      ; this
.text$mn:00000DE4                 call    ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBuffer(void)
.text$mn:00000DE9                 mov     ecx, eax
.text$mn:00000DEB                 call    ?getLangType@Buffer@@QBE?AW4LangType@@XZ ; Buffer::getLangType(void)
.text$mn:00000DF0                 mov     [ebp+var_7C], eax
.text$mn:00000DF3                 cmp     [ebp+var_7C], 9
.text$mn:00000DF7                 jz      short loc_E16
.text$mn:00000DF9                 cmp     [ebp+var_7C], 8
.text$mn:00000DFD                 jz      short loc_E16
.text$mn:00000DFF                 cmp     [ebp+var_7C], 1
.text$mn:00000E03                 jz      short loc_E16
.text$mn:00000E05                 cmp     [ebp+var_7C], 10h
.text$mn:00000E09                 jz      short loc_E16
.text$mn:00000E0B                 cmp     [ebp+var_7C], 37h ; '7'
.text$mn:00000E0F                 jz      short loc_E16
.text$mn:00000E11                 jmp     loc_1252
.text$mn:00000E16 ; ---------------------------------------------------------------------------
.text$mn:00000E16
.text$mn:00000E16 loc_E16:                                ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+5Fj
.text$mn:00000E16                                         ; XmlMatchedTagsHighlighter::tagMatch(bool)+65j ...
.text$mn:00000E16                 cmp     [ebp+var_7C], 1
.text$mn:00000E1A                 jz      short loc_E2C
.text$mn:00000E1C                 cmp     [ebp+var_7C], 10h
.text$mn:00000E20                 jz      short loc_E2C
.text$mn:00000E22                 cmp     [ebp+var_7C], 37h ; '7'
.text$mn:00000E26                 jnz     loc_F66
.text$mn:00000E2C
.text$mn:00000E2C loc_E2C:                                ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+82j
.text$mn:00000E2C                                         ; XmlMatchedTagsHighlighter::tagMatch(bool)+88j
.text$mn:00000E2C                 cmp     [ebp+var_7C], 1
.text$mn:00000E30                 jnz     short loc_E3E
.text$mn:00000E32                 mov     [ebp+Str], offset $SG152750
.text$mn:00000E3C                 jmp     short loc_E48
.text$mn:00000E3E ; ---------------------------------------------------------------------------
.text$mn:00000E3E
.text$mn:00000E3E loc_E3E:                                ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+98j
.text$mn:00000E3E                 mov     [ebp+Str], offset $SG152751
.text$mn:00000E48
.text$mn:00000E48 loc_E48:                                ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+A4j
.text$mn:00000E48                 mov     eax, [ebp+Str]
.text$mn:00000E4E                 push    eax             ; Str
.text$mn:00000E4F                 lea     ecx, [ebp+var_44]
.text$mn:00000E52                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00000E57                 mov     [ebp+var_4], 0
.text$mn:00000E5E                 cmp     [ebp+var_7C], 1
.text$mn:00000E62                 jnz     short loc_E70
.text$mn:00000E64                 mov     [ebp+var_90], offset $SG152769
.text$mn:00000E6E                 jmp     short loc_E7A
.text$mn:00000E70 ; ---------------------------------------------------------------------------
.text$mn:00000E70
.text$mn:00000E70 loc_E70:                                ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+CAj
.text$mn:00000E70                 mov     [ebp+var_90], offset $SG152770
.text$mn:00000E7A
.text$mn:00000E7A loc_E7A:                                ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+D6j
.text$mn:00000E7A                 mov     ecx, [ebp+var_90]
.text$mn:00000E80                 push    ecx             ; Str
.text$mn:00000E81                 lea     ecx, [ebp+var_60]
.text$mn:00000E84                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00000E89                 mov     byte ptr [ebp+var_4], 1
.text$mn:00000E8D                 push    0               ; __int32
.text$mn:00000E8F                 push    0               ; unsigned int
.text$mn:00000E91                 push    7D8h            ; unsigned int
.text$mn:00000E96                 mov     edx, [ebp+var_78]
.text$mn:00000E99                 mov     ecx, [edx]      ; this
.text$mn:00000E9B                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000EA0                 add     eax, 1
.text$mn:00000EA3                 mov     [ebp+var_98], eax
.text$mn:00000EA9                 push    0
.text$mn:00000EAB                 push    0
.text$mn:00000EAD                 mov     eax, [ebp+var_98]
.text$mn:00000EB3                 push    eax
.text$mn:00000EB4                 lea     ecx, [ebp+var_44]
.text$mn:00000EB7                 call    ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
.text$mn:00000EBC                 push    eax
.text$mn:00000EBD                 lea     ecx, [ebp+var_28]
.text$mn:00000EC0                 push    ecx
.text$mn:00000EC1                 mov     ecx, [ebp+var_78]
.text$mn:00000EC4                 call    ?findText@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@PBDHHH@Z ; XmlMatchedTagsHighlighter::findText(char const *,int,int,int)
.text$mn:00000EC9                 push    0
.text$mn:00000ECB                 push    0
.text$mn:00000ECD                 mov     edx, [ebp+var_98]
.text$mn:00000ED3                 push    edx
.text$mn:00000ED4                 lea     ecx, [ebp+var_60]
.text$mn:00000ED7                 call    ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
.text$mn:00000EDC                 push    eax
.text$mn:00000EDD                 lea     eax, [ebp+var_1C]
.text$mn:00000EE0                 push    eax
.text$mn:00000EE1                 mov     ecx, [ebp+var_78]
.text$mn:00000EE4                 call    ?findText@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@PBDHHH@Z ; XmlMatchedTagsHighlighter::findText(char const *,int,int,int)
.text$mn:00000EE9                 movzx   ecx, [ebp+var_20]
.text$mn:00000EED                 test    ecx, ecx
.text$mn:00000EEF                 jz      short loc_F4B
.text$mn:00000EF1                 movzx   edx, [ebp+var_14]
.text$mn:00000EF5                 test    edx, edx
.text$mn:00000EF7                 jnz     short loc_F1B
.text$mn:00000EF9                 mov     byte ptr [ebp+var_4], 0
.text$mn:00000EFD                 lea     ecx, [ebp+var_60]
.text$mn:00000F00                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00000F05                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000F0C                 lea     ecx, [ebp+var_44]
.text$mn:00000F0F                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00000F14                 jmp     loc_1252
.text$mn:00000F19 ; ---------------------------------------------------------------------------
.text$mn:00000F19                 jmp     short loc_F4B
.text$mn:00000F1B ; ---------------------------------------------------------------------------
.text$mn:00000F1B
.text$mn:00000F1B loc_F1B:                                ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+15Fj
.text$mn:00000F1B                 movzx   eax, [ebp+var_14]
.text$mn:00000F1F                 test    eax, eax
.text$mn:00000F21                 jz      short loc_F4B
.text$mn:00000F23                 mov     ecx, [ebp+var_1C]
.text$mn:00000F26                 cmp     ecx, [ebp+var_24]
.text$mn:00000F29                 jg      short loc_F4B
.text$mn:00000F2B                 mov     byte ptr [ebp+var_4], 0
.text$mn:00000F2F                 lea     ecx, [ebp+var_60]
.text$mn:00000F32                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00000F37                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000F3E                 lea     ecx, [ebp+var_44]
.text$mn:00000F41                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00000F46                 jmp     loc_1252
.text$mn:00000F4B ; ---------------------------------------------------------------------------
.text$mn:00000F4B
.text$mn:00000F4B loc_F4B:                                ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+157j
.text$mn:00000F4B                                         ; XmlMatchedTagsHighlighter::tagMatch(bool)+181j ...
.text$mn:00000F4B                 mov     byte ptr [ebp+var_4], 0
.text$mn:00000F4F                 lea     ecx, [ebp+var_60]
.text$mn:00000F52                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00000F57                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000F5E                 lea     ecx, [ebp+var_44]
.text$mn:00000F61                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00000F66
.text$mn:00000F66 loc_F66:                                ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+8Ej
.text$mn:00000F66                 push    0               ; __int32
.text$mn:00000F68                 push    0               ; unsigned int
.text$mn:00000F6A                 push    88Fh            ; unsigned int
.text$mn:00000F6F                 mov     edx, [ebp+var_78]
.text$mn:00000F72                 mov     ecx, [edx]      ; this
.text$mn:00000F74                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000F79                 mov     [ebp+var_AC], eax
.text$mn:00000F7F                 push    0               ; __int32
.text$mn:00000F81                 push    0               ; unsigned int
.text$mn:00000F83                 push    891h            ; unsigned int
.text$mn:00000F88                 mov     eax, [ebp+var_78]
.text$mn:00000F8B                 mov     ecx, [eax]      ; this
.text$mn:00000F8D                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000F92                 mov     [ebp+var_B4], eax
.text$mn:00000F98                 push    0               ; __int32
.text$mn:00000F9A                 push    0               ; unsigned int
.text$mn:00000F9C                 push    897h            ; unsigned int
.text$mn:00000FA1                 mov     ecx, [ebp+var_78]
.text$mn:00000FA4                 mov     ecx, [ecx]      ; this
.text$mn:00000FA6                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000FAB                 mov     [ebp+var_A8], eax
.text$mn:00000FB1                 lea     edx, [ebp+var_74]
.text$mn:00000FB4                 push    edx             ; struct XmlMatchedTagsHighlighter::XmlMatchedTagsPos *
.text$mn:00000FB5                 mov     ecx, [ebp+var_78] ; this
.text$mn:00000FB8                 call    ?getXmlMatchedTagsPos@XmlMatchedTagsHighlighter@@AAE_NAAUXmlMatchedTagsPos@1@@Z ; XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)
.text$mn:00000FBD                 movzx   eax, al
.text$mn:00000FC0                 test    eax, eax
.text$mn:00000FC2                 jz      loc_120A
.text$mn:00000FC8                 push    0               ; __int32
.text$mn:00000FCA                 push    1Bh             ; unsigned int
.text$mn:00000FCC                 push    9C4h            ; unsigned int
.text$mn:00000FD1                 mov     ecx, [ebp+var_78]
.text$mn:00000FD4                 mov     ecx, [ecx]      ; this
.text$mn:00000FD6                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000FDB                 mov     [ebp+var_84], 2
.text$mn:00000FE5                 cmp     [ebp+var_68], 0FFFFFFFFh
.text$mn:00000FE9                 jz      short loc_1015
.text$mn:00000FEB                 cmp     [ebp+var_64], 0FFFFFFFFh
.text$mn:00000FEF                 jz      short loc_1015
.text$mn:00000FF1                 mov     edx, [ebp+var_64]
.text$mn:00000FF4                 sub     edx, [ebp+var_68]
.text$mn:00000FF7                 push    edx             ; __int32
.text$mn:00000FF8                 mov     eax, [ebp+var_68]
.text$mn:00000FFB                 push    eax             ; unsigned int
.text$mn:00000FFC                 push    9C8h            ; unsigned int
.text$mn:00001001                 mov     ecx, [ebp+var_78]
.text$mn:00001004                 mov     ecx, [ecx]      ; this
.text$mn:00001006                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000100B                 mov     [ebp+var_84], 1
.text$mn:00001015
.text$mn:00001015 loc_1015:                               ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+251j
.text$mn:00001015                                         ; XmlMatchedTagsHighlighter::tagMatch(bool)+257j
.text$mn:00001015                 mov     edx, [ebp+var_70]
.text$mn:00001018                 sub     edx, [ebp+var_74]
.text$mn:0000101B                 push    edx             ; __int32
.text$mn:0000101C                 mov     eax, [ebp+var_74]
.text$mn:0000101F                 push    eax             ; unsigned int
.text$mn:00001020                 push    9C8h            ; unsigned int
.text$mn:00001025                 mov     ecx, [ebp+var_78]
.text$mn:00001028                 mov     ecx, [ecx]      ; this
.text$mn:0000102A                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000102F                 mov     edx, [ebp+var_84]
.text$mn:00001035                 push    edx             ; __int32
.text$mn:00001036                 mov     eax, [ebp+var_6C]
.text$mn:00001039                 sub     eax, [ebp+var_84]
.text$mn:0000103F                 push    eax             ; unsigned int
.text$mn:00001040                 push    9C8h            ; unsigned int
.text$mn:00001045                 mov     ecx, [ebp+var_78]
.text$mn:00001048                 mov     ecx, [ecx]      ; this
.text$mn:0000104A                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000104F                 movzx   edx, [ebp+arg_0]
.text$mn:00001053                 test    edx, edx
.text$mn:00001055                 jz      loc_111B
.text$mn:0000105B                 mov     eax, [ebp+var_6C]
.text$mn:0000105E                 sub     eax, [ebp+var_84]
.text$mn:00001064                 push    eax
.text$mn:00001065                 mov     ecx, [ebp+var_70]
.text$mn:00001068                 push    ecx
.text$mn:00001069                 lea     edx, [ebp+var_C4]
.text$mn:0000106F                 push    edx
.text$mn:00001070                 mov     ecx, [ebp+var_78]
.text$mn:00001073                 call    ?getAttributesPos@XmlMatchedTagsHighlighter@@AAE?AV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@HH@Z ; XmlMatchedTagsHighlighter::getAttributesPos(int,int)
.text$mn:00001078                 mov     [ebp+var_4], 2
.text$mn:0000107F                 push    0               ; __int32
.text$mn:00001081                 push    1Ah             ; unsigned int
.text$mn:00001083                 push    9C4h            ; unsigned int
.text$mn:00001088                 mov     eax, [ebp+var_78]
.text$mn:0000108B                 mov     ecx, [eax]      ; this
.text$mn:0000108D                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001092                 mov     [ebp+var_80], 0
.text$mn:00001099                 lea     ecx, [ebp+var_C4]
.text$mn:0000109F                 call    ?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::size(void)
.text$mn:000010A4                 mov     [ebp+var_A0], eax
.text$mn:000010AA                 jmp     short loc_10B5
.text$mn:000010AC ; ---------------------------------------------------------------------------
.text$mn:000010AC
.text$mn:000010AC loc_10AC:                               ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+36Fj
.text$mn:000010AC                 mov     ecx, [ebp+var_80]
.text$mn:000010AF                 add     ecx, 1
.text$mn:000010B2                 mov     [ebp+var_80], ecx
.text$mn:000010B5
.text$mn:000010B5 loc_10B5:                               ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+312j
.text$mn:000010B5                 mov     edx, [ebp+var_80]
.text$mn:000010B8                 cmp     edx, [ebp+var_A0]
.text$mn:000010BE                 jnb     short loc_1109
.text$mn:000010C0                 mov     eax, [ebp+var_80]
.text$mn:000010C3                 push    eax
.text$mn:000010C4                 lea     ecx, [ebp+var_C4]
.text$mn:000010CA                 call    ??A?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEAAU?$pair@HH@1@I@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::operator[](uint)
.text$mn:000010CF                 mov     esi, eax
.text$mn:000010D1                 mov     ecx, [ebp+var_80]
.text$mn:000010D4                 push    ecx
.text$mn:000010D5                 lea     ecx, [ebp+var_C4]
.text$mn:000010DB                 call    ??A?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEAAU?$pair@HH@1@I@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::operator[](uint)
.text$mn:000010E0                 mov     edx, [esi+4]
.text$mn:000010E3                 sub     edx, [eax]
.text$mn:000010E5                 push    edx             ; __int32
.text$mn:000010E6                 mov     eax, [ebp+var_80]
.text$mn:000010E9                 push    eax
.text$mn:000010EA                 lea     ecx, [ebp+var_C4]
.text$mn:000010F0                 call    ??A?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEAAU?$pair@HH@1@I@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::operator[](uint)
.text$mn:000010F5                 mov     ecx, [eax]
.text$mn:000010F7                 push    ecx             ; unsigned int
.text$mn:000010F8                 push    9C8h            ; unsigned int
.text$mn:000010FD                 mov     edx, [ebp+var_78]
.text$mn:00001100                 mov     ecx, [edx]      ; this
.text$mn:00001102                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001107                 jmp     short loc_10AC
.text$mn:00001109 ; ---------------------------------------------------------------------------
.text$mn:00001109
.text$mn:00001109 loc_1109:                               ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+326j
.text$mn:00001109                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001110                 lea     ecx, [ebp+var_C4]
.text$mn:00001116                 call    ??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::~vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>(void)
.text$mn:0000111B
.text$mn:0000111B loc_111B:                               ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+2BDj
.text$mn:0000111B                 mov     eax, [ebp+var_78]
.text$mn:0000111E                 mov     ecx, [eax]      ; this
.text$mn:00001120                 call    ?isShownIndentGuide@ScintillaEditView@@QBE_NXZ ; ScintillaEditView::isShownIndentGuide(void)
.text$mn:00001125                 movzx   ecx, al
.text$mn:00001128                 test    ecx, ecx
.text$mn:0000112A                 jz      loc_120A
.text$mn:00001130                 push    0               ; __int32
.text$mn:00001132                 mov     edx, [ebp+var_74]
.text$mn:00001135                 push    edx             ; unsigned int
.text$mn:00001136                 push    851h            ; unsigned int
.text$mn:0000113B                 mov     eax, [ebp+var_78]
.text$mn:0000113E                 mov     ecx, [eax]      ; this
.text$mn:00001140                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001145                 mov     [ebp+var_88], eax
.text$mn:0000114B                 push    0               ; __int32
.text$mn:0000114D                 mov     ecx, [ebp+var_68]
.text$mn:00001150                 push    ecx             ; unsigned int
.text$mn:00001151                 push    851h            ; unsigned int
.text$mn:00001156                 mov     edx, [ebp+var_78]
.text$mn:00001159                 mov     ecx, [edx]      ; this
.text$mn:0000115B                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001160                 mov     [ebp+var_94], eax
.text$mn:00001166                 push    0               ; __int32
.text$mn:00001168                 mov     eax, [ebp+var_74]
.text$mn:0000116B                 push    eax             ; unsigned int
.text$mn:0000116C                 push    876h            ; unsigned int
.text$mn:00001171                 mov     ecx, [ebp+var_78]
.text$mn:00001174                 mov     ecx, [ecx]      ; this
.text$mn:00001176                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000117B                 mov     [ebp+var_A4], eax
.text$mn:00001181                 push    0               ; __int32
.text$mn:00001183                 mov     edx, [ebp+var_68]
.text$mn:00001186                 push    edx             ; unsigned int
.text$mn:00001187                 push    876h            ; unsigned int
.text$mn:0000118C                 mov     eax, [ebp+var_78]
.text$mn:0000118F                 mov     ecx, [eax]      ; this
.text$mn:00001191                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001196                 mov     [ebp+var_B0], eax
.text$mn:0000119C                 cmp     [ebp+var_68], 0FFFFFFFFh
.text$mn:000011A0                 jz      short loc_120A
.text$mn:000011A2                 mov     ecx, [ebp+var_A4]
.text$mn:000011A8                 cmp     ecx, [ebp+var_B0]
.text$mn:000011AE                 jz      short loc_120A
.text$mn:000011B0                 mov     edx, [ebp+var_64]
.text$mn:000011B3                 sub     edx, 1
.text$mn:000011B6                 push    edx             ; __int32
.text$mn:000011B7                 mov     eax, [ebp+var_74]
.text$mn:000011BA                 push    eax             ; unsigned int
.text$mn:000011BB                 push    92Fh            ; unsigned int
.text$mn:000011C0                 mov     ecx, [ebp+var_78]
.text$mn:000011C3                 mov     ecx, [ecx]      ; this
.text$mn:000011C5                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000011CA                 mov     edx, [ebp+var_88]
.text$mn:000011D0                 cmp     edx, [ebp+var_94]
.text$mn:000011D6                 jge     short loc_11E6
.text$mn:000011D8                 mov     eax, [ebp+var_88]
.text$mn:000011DE                 mov     [ebp+var_9C], eax
.text$mn:000011E4                 jmp     short loc_11F2
.text$mn:000011E6 ; ---------------------------------------------------------------------------
.text$mn:000011E6
.text$mn:000011E6 loc_11E6:                               ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+43Ej
.text$mn:000011E6                 mov     ecx, [ebp+var_94]
.text$mn:000011EC                 mov     [ebp+var_9C], ecx
.text$mn:000011F2
.text$mn:000011F2 loc_11F2:                               ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+44Cj
.text$mn:000011F2                 push    0               ; __int32
.text$mn:000011F4                 mov     edx, [ebp+var_9C]
.text$mn:000011FA                 push    edx             ; unsigned int
.text$mn:000011FB                 push    856h            ; unsigned int
.text$mn:00001200                 mov     eax, [ebp+var_78]
.text$mn:00001203                 mov     ecx, [eax]      ; this
.text$mn:00001205                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000120A
.text$mn:0000120A loc_120A:                               ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+22Aj
.text$mn:0000120A                                         ; XmlMatchedTagsHighlighter::tagMatch(bool)+392j ...
.text$mn:0000120A                 push    0               ; __int32
.text$mn:0000120C                 mov     ecx, [ebp+var_AC]
.text$mn:00001212                 push    ecx             ; unsigned int
.text$mn:00001213                 push    88Eh            ; unsigned int
.text$mn:00001218                 mov     edx, [ebp+var_78]
.text$mn:0000121B                 mov     ecx, [edx]      ; this
.text$mn:0000121D                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001222                 push    0               ; __int32
.text$mn:00001224                 mov     eax, [ebp+var_B4]
.text$mn:0000122A                 push    eax             ; unsigned int
.text$mn:0000122B                 push    890h            ; unsigned int
.text$mn:00001230                 mov     ecx, [ebp+var_78]
.text$mn:00001233                 mov     ecx, [ecx]      ; this
.text$mn:00001235                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000123A                 push    0               ; __int32
.text$mn:0000123C                 mov     edx, [ebp+var_A8]
.text$mn:00001242                 push    edx             ; unsigned int
.text$mn:00001243                 push    896h            ; unsigned int
.text$mn:00001248                 mov     eax, [ebp+var_78]
.text$mn:0000124B                 mov     ecx, [eax]      ; this
.text$mn:0000124D                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001252
.text$mn:00001252 loc_1252:                               ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+79j
.text$mn:00001252                                         ; XmlMatchedTagsHighlighter::tagMatch(bool)+17Cj ...
.text$mn:00001252                 mov     ecx, [ebp+var_C]
.text$mn:00001255                 mov     large fs:0, ecx
.text$mn:0000125C                 pop     ecx
.text$mn:0000125D                 pop     esi
.text$mn:0000125E                 mov     ecx, [ebp+var_10]
.text$mn:00001261                 xor     ecx, ebp
.text$mn:00001263                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001268                 mov     esp, ebp
.text$mn:0000126A                 pop     ebp
.text$mn:0000126B                 retn    4
.text$mn:0000126B ?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z endp
.text$mn:0000126B
.text$mn:0000126B ; ---------------------------------------------------------------------------
.text$mn:0000126E                 db 0Ah dup(0CCh)
.text$mn:00001278
.text$mn:00001278 ; =============== S U B R O U T I N E =======================================
.text$mn:00001278
.text$mn:00001278 ; Attributes: bp-based frame
.text$mn:00001278
.text$mn:00001278 ; bool __thiscall XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter *this, struct XmlMatchedTagsHighlighter::XmlMatchedTagsPos *)
.text$mn:00001278                 public ?getXmlMatchedTagsPos@XmlMatchedTagsHighlighter@@AAE_NAAUXmlMatchedTagsPos@1@@Z
.text$mn:00001278 ?getXmlMatchedTagsPos@XmlMatchedTagsHighlighter@@AAE_NAAUXmlMatchedTagsPos@1@@Z proc near
.text$mn:00001278                                         ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+220p
.text$mn:00001278
.text$mn:00001278 var_138         = dword ptr -138h
.text$mn:00001278 var_134         = dword ptr -134h
.text$mn:00001278 var_130         = dword ptr -130h
.text$mn:00001278 var_12C         = dword ptr -12Ch
.text$mn:00001278 var_128         = dword ptr -128h
.text$mn:00001278 var_124         = dword ptr -124h
.text$mn:00001278 var_120         = dword ptr -120h
.text$mn:00001278 var_11C         = dword ptr -11Ch
.text$mn:00001278 var_118         = dword ptr -118h
.text$mn:00001278 var_114         = dword ptr -114h
.text$mn:00001278 var_110         = dword ptr -110h
.text$mn:00001278 var_10C         = dword ptr -10Ch
.text$mn:00001278 var_108         = dword ptr -108h
.text$mn:00001278 var_104         = dword ptr -104h
.text$mn:00001278 var_100         = dword ptr -100h
.text$mn:00001278 var_FC          = dword ptr -0FCh
.text$mn:00001278 var_F5          = byte ptr -0F5h
.text$mn:00001278 var_F4          = dword ptr -0F4h
.text$mn:00001278 var_F0          = dword ptr -0F0h
.text$mn:00001278 var_EC          = dword ptr -0ECh
.text$mn:00001278 var_E5          = byte ptr -0E5h
.text$mn:00001278 var_E4          = byte ptr -0E4h
.text$mn:00001278 var_D8          = byte ptr -0D8h
.text$mn:00001278 var_CC          = byte ptr -0CCh
.text$mn:00001278 var_C0          = byte ptr -0C0h
.text$mn:00001278 var_B4          = byte ptr -0B4h
.text$mn:00001278 var_A8          = byte ptr -0A8h
.text$mn:00001278 var_9C          = byte ptr -9Ch
.text$mn:00001278 var_80          = byte ptr -80h
.text$mn:00001278 var_7C          = dword ptr -7Ch
.text$mn:00001278 var_78          = byte ptr -78h
.text$mn:00001278 var_74          = byte ptr -74h
.text$mn:00001278 var_58          = dword ptr -58h
.text$mn:00001278 var_54          = dword ptr -54h
.text$mn:00001278 var_50          = dword ptr -50h
.text$mn:00001278 var_4C          = dword ptr -4Ch
.text$mn:00001278 var_48          = dword ptr -48h
.text$mn:00001278 var_44          = dword ptr -44h
.text$mn:00001278 var_40          = dword ptr -40h
.text$mn:00001278 var_3C          = dword ptr -3Ch
.text$mn:00001278 var_38          = dword ptr -38h
.text$mn:00001278 var_34          = dword ptr -34h
.text$mn:00001278 var_30          = dword ptr -30h
.text$mn:00001278 var_2C          = dword ptr -2Ch
.text$mn:00001278 var_28          = dword ptr -28h
.text$mn:00001278 var_24          = dword ptr -24h
.text$mn:00001278 var_20          = dword ptr -20h
.text$mn:00001278 var_1C          = dword ptr -1Ch
.text$mn:00001278 var_18          = dword ptr -18h
.text$mn:00001278 var_14          = dword ptr -14h
.text$mn:00001278 var_10          = dword ptr -10h
.text$mn:00001278 var_C           = dword ptr -0Ch
.text$mn:00001278 var_4           = dword ptr -4
.text$mn:00001278 arg_0           = dword ptr  8
.text$mn:00001278
.text$mn:00001278                 push    ebp
.text$mn:00001279                 mov     ebp, esp
.text$mn:0000127B                 push    0FFFFFFFFh
.text$mn:0000127D                 push    offset __ehhandler$?getXmlMatchedTagsPos@XmlMatchedTagsHighlighter@@AAE_NAAUXmlMatchedTagsPos@1@@Z
.text$mn:00001282                 mov     eax, large fs:0
.text$mn:00001288                 push    eax
.text$mn:00001289                 sub     esp, 12Ch
.text$mn:0000128F                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001294                 xor     eax, ebp
.text$mn:00001296                 mov     [ebp+var_10], eax
.text$mn:00001299                 push    eax
.text$mn:0000129A                 lea     eax, [ebp+var_C]
.text$mn:0000129D                 mov     large fs:0, eax
.text$mn:000012A3                 mov     [ebp+var_EC], ecx
.text$mn:000012A9                 mov     [ebp+var_E5], 0
.text$mn:000012B0                 push    0               ; __int32
.text$mn:000012B2                 push    0               ; unsigned int
.text$mn:000012B4                 push    7D8h            ; unsigned int
.text$mn:000012B9                 mov     eax, [ebp+var_EC]
.text$mn:000012BF                 mov     ecx, [eax]      ; this
.text$mn:000012C1                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000012C6                 mov     [ebp+var_124], eax
.text$mn:000012CC                 mov     ecx, [ebp+var_124]
.text$mn:000012D2                 mov     [ebp+var_F4], ecx
.text$mn:000012D8
.text$mn:000012D8 loc_12D8:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+DEj
.text$mn:000012D8                 push    0
.text$mn:000012DA                 push    0
.text$mn:000012DC                 mov     edx, [ebp+var_F4]
.text$mn:000012E2                 push    edx
.text$mn:000012E3                 push    offset $SG152401
.text$mn:000012E8                 lea     eax, [ebp+var_B4]
.text$mn:000012EE                 push    eax
.text$mn:000012EF                 mov     ecx, [ebp+var_EC]
.text$mn:000012F5                 call    ?findText@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@PBDHHH@Z ; XmlMatchedTagsHighlighter::findText(char const *,int,int,int)
.text$mn:000012FA                 mov     ecx, [eax]
.text$mn:000012FC                 mov     [ebp+var_1C], ecx
.text$mn:000012FF                 mov     edx, [eax+4]
.text$mn:00001302                 mov     [ebp+var_18], edx
.text$mn:00001305                 mov     eax, [eax+8]
.text$mn:00001308                 mov     [ebp+var_14], eax
.text$mn:0000130B                 push    0               ; __int32
.text$mn:0000130D                 mov     ecx, [ebp+var_1C]
.text$mn:00001310                 push    ecx             ; unsigned int
.text$mn:00001311                 push    7DAh            ; unsigned int
.text$mn:00001316                 mov     edx, [ebp+var_EC]
.text$mn:0000131C                 mov     ecx, [edx]      ; this
.text$mn:0000131E                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001323                 mov     [ebp+var_100], eax
.text$mn:00001329                 mov     eax, [ebp+var_1C]
.text$mn:0000132C                 sub     eax, 1
.text$mn:0000132F                 mov     [ebp+var_F4], eax
.text$mn:00001335                 movzx   ecx, byte ptr [ebp+var_14]
.text$mn:00001339                 test    ecx, ecx
.text$mn:0000133B                 jz      short loc_1358
.text$mn:0000133D                 cmp     [ebp+var_100], 6
.text$mn:00001344                 jz      short loc_134F
.text$mn:00001346                 cmp     [ebp+var_100], 7
.text$mn:0000134D                 jnz     short loc_1358
.text$mn:0000134F
.text$mn:0000134F loc_134F:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+CCj
.text$mn:0000134F                 cmp     [ebp+var_F4], 0
.text$mn:00001356                 jg      short loc_12D8
.text$mn:00001358
.text$mn:00001358 loc_1358:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+C3j
.text$mn:00001358                                         ; XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+D5j
.text$mn:00001358                 movzx   edx, byte ptr [ebp+var_14]
.text$mn:0000135C                 test    edx, edx
.text$mn:0000135E                 jz      loc_1A22
.text$mn:00001364                 cmp     [ebp+var_100], 11h
.text$mn:0000136B                 jz      loc_1A22
.text$mn:00001371                 mov     eax, [ebp+var_1C]
.text$mn:00001374                 mov     [ebp+var_F4], eax
.text$mn:0000137A
.text$mn:0000137A loc_137A:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+187j
.text$mn:0000137A                 push    0
.text$mn:0000137C                 mov     ecx, [ebp+var_124]
.text$mn:00001382                 push    ecx
.text$mn:00001383                 mov     edx, [ebp+var_F4]
.text$mn:00001389                 push    edx
.text$mn:0000138A                 push    offset $SG152410
.text$mn:0000138F                 lea     eax, [ebp+var_C0]
.text$mn:00001395                 push    eax
.text$mn:00001396                 mov     ecx, [ebp+var_EC]
.text$mn:0000139C                 call    ?findText@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@PBDHHH@Z ; XmlMatchedTagsHighlighter::findText(char const *,int,int,int)
.text$mn:000013A1                 mov     ecx, [eax]
.text$mn:000013A3                 mov     [ebp+var_40], ecx
.text$mn:000013A6                 mov     edx, [eax+4]
.text$mn:000013A9                 mov     [ebp+var_3C], edx
.text$mn:000013AC                 mov     eax, [eax+8]
.text$mn:000013AF                 mov     [ebp+var_38], eax
.text$mn:000013B2                 push    0               ; __int32
.text$mn:000013B4                 mov     ecx, [ebp+var_40]
.text$mn:000013B7                 push    ecx             ; unsigned int
.text$mn:000013B8                 push    7DAh            ; unsigned int
.text$mn:000013BD                 mov     edx, [ebp+var_EC]
.text$mn:000013C3                 mov     ecx, [edx]      ; this
.text$mn:000013C5                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000013CA                 mov     [ebp+var_100], eax
.text$mn:000013D0                 mov     eax, [ebp+var_3C]
.text$mn:000013D3                 mov     [ebp+var_F4], eax
.text$mn:000013D9                 movzx   ecx, byte ptr [ebp+var_38]
.text$mn:000013DD                 test    ecx, ecx
.text$mn:000013DF                 jz      short loc_1405
.text$mn:000013E1                 cmp     [ebp+var_100], 6
.text$mn:000013E8                 jz      short loc_13F3
.text$mn:000013EA                 cmp     [ebp+var_100], 7
.text$mn:000013F1                 jnz     short loc_1405
.text$mn:000013F3
.text$mn:000013F3 loc_13F3:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+170j
.text$mn:000013F3                 mov     edx, [ebp+var_F4]
.text$mn:000013F9                 cmp     edx, [ebp+var_124]
.text$mn:000013FF                 jle     loc_137A
.text$mn:00001405
.text$mn:00001405 loc_1405:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+167j
.text$mn:00001405                                         ; XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+179j
.text$mn:00001405                 movzx   eax, byte ptr [ebp+var_38]
.text$mn:00001409                 test    eax, eax
.text$mn:0000140B                 jnz     loc_1A22
.text$mn:00001411                 push    0               ; __int32
.text$mn:00001413                 mov     ecx, [ebp+var_1C]
.text$mn:00001416                 add     ecx, 1
.text$mn:00001419                 push    ecx             ; unsigned int
.text$mn:0000141A                 push    7D7h            ; unsigned int
.text$mn:0000141F                 mov     edx, [ebp+var_EC]
.text$mn:00001425                 mov     ecx, [edx]      ; this
.text$mn:00001427                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000142C                 mov     [ebp+var_F0], eax
.text$mn:00001432                 cmp     [ebp+var_F0], 2Fh ; '/'
.text$mn:00001439                 jnz     loc_1726
.text$mn:0000143F                 mov     eax, [ebp+arg_0]
.text$mn:00001442                 mov     ecx, [ebp+var_1C]
.text$mn:00001445                 mov     [eax+0Ch], ecx
.text$mn:00001448                 push    0               ; __int32
.text$mn:0000144A                 push    0               ; unsigned int
.text$mn:0000144C                 push    7D6h            ; unsigned int
.text$mn:00001451                 mov     edx, [ebp+var_EC]
.text$mn:00001457                 mov     ecx, [edx]      ; this
.text$mn:00001459                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000145E                 mov     [ebp+var_130], eax
.text$mn:00001464                 push    0
.text$mn:00001466                 mov     eax, [ebp+var_130]
.text$mn:0000146C                 push    eax
.text$mn:0000146D                 mov     ecx, [ebp+var_124]
.text$mn:00001473                 push    ecx
.text$mn:00001474                 push    offset $SG152419
.text$mn:00001479                 lea     edx, [ebp+var_80]
.text$mn:0000147C                 push    edx
.text$mn:0000147D                 mov     ecx, [ebp+var_EC]
.text$mn:00001483                 call    ?findText@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@PBDHHH@Z ; XmlMatchedTagsHighlighter::findText(char const *,int,int,int)
.text$mn:00001488                 movzx   eax, [ebp+var_78]
.text$mn:0000148C                 test    eax, eax
.text$mn:0000148E                 jz      short loc_1499
.text$mn:00001490                 mov     ecx, [ebp+arg_0]
.text$mn:00001493                 mov     edx, [ebp+var_7C]
.text$mn:00001496                 mov     [ecx+10h], edx
.text$mn:00001499
.text$mn:00001499 loc_1499:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+216j
.text$mn:00001499                 mov     eax, [ebp+var_1C]
.text$mn:0000149C                 add     eax, 2
.text$mn:0000149F                 mov     [ebp+var_10C], eax
.text$mn:000014A5                 lea     ecx, [ebp+var_74]
.text$mn:000014A8                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:000014AD                 mov     [ebp+var_4], 0
.text$mn:000014B4                 push    0               ; __int32
.text$mn:000014B6                 mov     ecx, [ebp+var_10C]
.text$mn:000014BC                 push    ecx             ; unsigned int
.text$mn:000014BD                 push    7D7h            ; unsigned int
.text$mn:000014C2                 mov     edx, [ebp+var_EC]
.text$mn:000014C8                 mov     ecx, [edx]      ; this
.text$mn:000014CA                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000014CF                 mov     [ebp+var_F0], eax
.text$mn:000014D5
.text$mn:000014D5 loc_14D5:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+2ECj
.text$mn:000014D5                 mov     eax, [ebp+var_10C]
.text$mn:000014DB                 cmp     eax, [ebp+var_130]
.text$mn:000014E1                 jge     loc_1569
.text$mn:000014E7                 mov     ecx, [ebp+var_F0]
.text$mn:000014ED                 push    ecx             ; int
.text$mn:000014EE                 mov     ecx, [ebp+var_EC] ; this
.text$mn:000014F4                 call    ?isWhitespace@XmlMatchedTagsHighlighter@@AAE_NH@Z ; XmlMatchedTagsHighlighter::isWhitespace(int)
.text$mn:000014F9                 movzx   edx, al
.text$mn:000014FC                 test    edx, edx
.text$mn:000014FE                 jnz     short loc_1569
.text$mn:00001500                 cmp     [ebp+var_F0], 2Fh ; '/'
.text$mn:00001507                 jz      short loc_1569
.text$mn:00001509                 cmp     [ebp+var_F0], 3Eh ; '>'
.text$mn:00001510                 jz      short loc_1569
.text$mn:00001512                 cmp     [ebp+var_F0], 22h ; '"'
.text$mn:00001519                 jz      short loc_1569
.text$mn:0000151B                 cmp     [ebp+var_F0], 27h ; '''
.text$mn:00001522                 jz      short loc_1569
.text$mn:00001524                 movzx   eax, byte ptr [ebp+var_F0]
.text$mn:0000152B                 push    eax
.text$mn:0000152C                 lea     ecx, [ebp+var_74]
.text$mn:0000152F                 call    ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::push_back(char)
.text$mn:00001534                 mov     ecx, [ebp+var_10C]
.text$mn:0000153A                 add     ecx, 1
.text$mn:0000153D                 mov     [ebp+var_10C], ecx
.text$mn:00001543                 push    0               ; __int32
.text$mn:00001545                 mov     edx, [ebp+var_10C]
.text$mn:0000154B                 push    edx             ; unsigned int
.text$mn:0000154C                 push    7D7h            ; unsigned int
.text$mn:00001551                 mov     eax, [ebp+var_EC]
.text$mn:00001557                 mov     ecx, [eax]      ; this
.text$mn:00001559                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000155E                 mov     [ebp+var_F0], eax
.text$mn:00001564                 jmp     loc_14D5
.text$mn:00001569 ; ---------------------------------------------------------------------------
.text$mn:00001569
.text$mn:00001569 loc_1569:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+269j
.text$mn:00001569                                         ; XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+286j ...
.text$mn:00001569                 lea     ecx, [ebp+var_74]
.text$mn:0000156C                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00001571                 test    eax, eax
.text$mn:00001573                 jz      loc_1712
.text$mn:00001579                 mov     ecx, [ebp+arg_0]
.text$mn:0000157C                 mov     edx, [ecx+0Ch]
.text$mn:0000157F                 mov     [ebp+var_114], edx
.text$mn:00001585                 mov     [ebp+var_104], 1
.text$mn:0000158F
.text$mn:0000158F loc_158F:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+494j
.text$mn:0000158F                 push    0
.text$mn:00001591                 mov     eax, [ebp+var_114]
.text$mn:00001597                 push    eax
.text$mn:00001598                 lea     ecx, [ebp+var_74]
.text$mn:0000159B                 push    ecx
.text$mn:0000159C                 lea     edx, [ebp+var_E4]
.text$mn:000015A2                 push    edx
.text$mn:000015A3                 mov     ecx, [ebp+var_EC]
.text$mn:000015A9                 call    ?findOpenTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z ; XmlMatchedTagsHighlighter::findOpenTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)
.text$mn:000015AE                 mov     ecx, [eax]
.text$mn:000015B0                 mov     [ebp+var_28], ecx
.text$mn:000015B3                 mov     edx, [eax+4]
.text$mn:000015B6                 mov     [ebp+var_24], edx
.text$mn:000015B9                 mov     eax, [eax+8]
.text$mn:000015BC                 mov     [ebp+var_20], eax
.text$mn:000015BF                 movzx   ecx, byte ptr [ebp+var_20]
.text$mn:000015C3                 test    ecx, ecx
.text$mn:000015C5                 jz      loc_16F2
.text$mn:000015CB                 mov     edx, [ebp+var_104]
.text$mn:000015D1                 sub     edx, 1
.text$mn:000015D4                 mov     [ebp+var_104], edx
.text$mn:000015DA                 mov     eax, [ebp+var_24]
.text$mn:000015DD                 mov     [ebp+var_118], eax
.text$mn:000015E3                 mov     [ebp+var_120], 0
.text$mn:000015ED                 mov     ecx, [ebp+var_118]
.text$mn:000015F3                 cmp     ecx, [ebp+var_114]
.text$mn:000015F9                 jge     short loc_1607
.text$mn:000015FB                 mov     [ebp+var_134], 1
.text$mn:00001605                 jmp     short loc_1611
.text$mn:00001607 ; ---------------------------------------------------------------------------
.text$mn:00001607
.text$mn:00001607 loc_1607:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+381j
.text$mn:00001607                 mov     [ebp+var_134], 0
.text$mn:00001611
.text$mn:00001611 loc_1611:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+38Dj
.text$mn:00001611                 mov     dl, byte ptr [ebp+var_134]
.text$mn:00001617                 mov     [ebp+var_F5], dl
.text$mn:0000161D
.text$mn:0000161D loc_161D:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+419j
.text$mn:0000161D                 mov     eax, [ebp+var_114]
.text$mn:00001623                 push    eax
.text$mn:00001624                 mov     ecx, [ebp+var_118]
.text$mn:0000162A                 push    ecx
.text$mn:0000162B                 lea     edx, [ebp+var_74]
.text$mn:0000162E                 push    edx
.text$mn:0000162F                 lea     eax, [ebp+var_D8]
.text$mn:00001635                 push    eax
.text$mn:00001636                 mov     ecx, [ebp+var_EC]
.text$mn:0000163C                 call    ?findCloseTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z ; XmlMatchedTagsHighlighter::findCloseTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)
.text$mn:00001641                 mov     ecx, [eax]
.text$mn:00001643                 mov     [ebp+var_4C], ecx
.text$mn:00001646                 mov     edx, [eax+4]
.text$mn:00001649                 mov     [ebp+var_48], edx
.text$mn:0000164C                 mov     eax, [eax+8]
.text$mn:0000164F                 mov     [ebp+var_44], eax
.text$mn:00001652                 movzx   ecx, byte ptr [ebp+var_44]
.text$mn:00001656                 test    ecx, ecx
.text$mn:00001658                 jz      short loc_168B
.text$mn:0000165A                 mov     edx, [ebp+var_120]
.text$mn:00001660                 add     edx, 1
.text$mn:00001663                 mov     [ebp+var_120], edx
.text$mn:00001669                 movzx   eax, [ebp+var_F5]
.text$mn:00001670                 test    eax, eax
.text$mn:00001672                 jz      short loc_167F
.text$mn:00001674                 mov     ecx, [ebp+var_48]
.text$mn:00001677                 mov     [ebp+var_118], ecx
.text$mn:0000167D                 jmp     short loc_168B
.text$mn:0000167F ; ---------------------------------------------------------------------------
.text$mn:0000167F
.text$mn:0000167F loc_167F:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+3FAj
.text$mn:0000167F                 mov     edx, [ebp+var_4C]
.text$mn:00001682                 sub     edx, 1
.text$mn:00001685                 mov     [ebp+var_118], edx
.text$mn:0000168B
.text$mn:0000168B loc_168B:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+3E0j
.text$mn:0000168B                                         ; XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+405j
.text$mn:0000168B                 movzx   eax, byte ptr [ebp+var_44]
.text$mn:0000168F                 test    eax, eax
.text$mn:00001691                 jnz     short loc_161D
.text$mn:00001693                 cmp     [ebp+var_120], 0
.text$mn:0000169A                 jnz     short loc_16D7
.text$mn:0000169C                 cmp     [ebp+var_104], 0
.text$mn:000016A3                 jnz     short loc_16D7
.text$mn:000016A5                 mov     ecx, [ebp+arg_0]
.text$mn:000016A8                 mov     edx, [ebp+var_28]
.text$mn:000016AB                 mov     [ecx], edx
.text$mn:000016AD                 mov     eax, [ebp+var_24]
.text$mn:000016B0                 add     eax, 1
.text$mn:000016B3                 mov     ecx, [ebp+arg_0]
.text$mn:000016B6                 mov     [ecx+8], eax
.text$mn:000016B9                 lea     ecx, [ebp+var_74]
.text$mn:000016BC                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:000016C1                 mov     edx, [ebp+var_28]
.text$mn:000016C4                 lea     eax, [edx+eax+1]
.text$mn:000016C8                 mov     ecx, [ebp+arg_0]
.text$mn:000016CB                 mov     [ecx+4], eax
.text$mn:000016CE                 mov     [ebp+var_E5], 1
.text$mn:000016D5                 jmp     short loc_16F2
.text$mn:000016D7 ; ---------------------------------------------------------------------------
.text$mn:000016D7
.text$mn:000016D7 loc_16D7:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+422j
.text$mn:000016D7                                         ; XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+42Bj
.text$mn:000016D7                 mov     edx, [ebp+var_104]
.text$mn:000016DD                 add     edx, [ebp+var_120]
.text$mn:000016E3                 mov     [ebp+var_104], edx
.text$mn:000016E9                 mov     eax, [ebp+var_28]
.text$mn:000016EC                 mov     [ebp+var_114], eax
.text$mn:000016F2
.text$mn:000016F2 loc_16F2:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+34Dj
.text$mn:000016F2                                         ; XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+45Dj
.text$mn:000016F2                 movzx   ecx, [ebp+var_E5]
.text$mn:000016F9                 test    ecx, ecx
.text$mn:000016FB                 jnz     short loc_1712
.text$mn:000016FD                 cmp     [ebp+var_104], 0
.text$mn:00001704                 jle     short loc_1712
.text$mn:00001706                 movzx   edx, byte ptr [ebp+var_20]
.text$mn:0000170A                 test    edx, edx
.text$mn:0000170C                 jnz     loc_158F
.text$mn:00001712
.text$mn:00001712 loc_1712:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+2FBj
.text$mn:00001712                                         ; XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+483j ...
.text$mn:00001712                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001719                 lea     ecx, [ebp+var_74]
.text$mn:0000171C                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00001721                 jmp     loc_1A22
.text$mn:00001726 ; ---------------------------------------------------------------------------
.text$mn:00001726
.text$mn:00001726 loc_1726:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+1C1j
.text$mn:00001726                 mov     eax, [ebp+var_1C]
.text$mn:00001729                 add     eax, 1
.text$mn:0000172C                 mov     [ebp+var_FC], eax
.text$mn:00001732                 push    0               ; __int32
.text$mn:00001734                 push    0               ; unsigned int
.text$mn:00001736                 push    7D6h            ; unsigned int
.text$mn:0000173B                 mov     ecx, [ebp+var_EC]
.text$mn:00001741                 mov     ecx, [ecx]      ; this
.text$mn:00001743                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001748                 mov     [ebp+var_128], eax
.text$mn:0000174E                 mov     edx, [ebp+arg_0]
.text$mn:00001751                 mov     eax, [ebp+var_1C]
.text$mn:00001754                 mov     [edx], eax
.text$mn:00001756                 lea     ecx, [ebp+var_9C]
.text$mn:0000175C                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00001761                 mov     [ebp+var_4], 1
.text$mn:00001768                 push    0               ; __int32
.text$mn:0000176A                 mov     ecx, [ebp+var_FC]
.text$mn:00001770                 push    ecx             ; unsigned int
.text$mn:00001771                 push    7D7h            ; unsigned int
.text$mn:00001776                 mov     edx, [ebp+var_EC]
.text$mn:0000177C                 mov     ecx, [edx]      ; this
.text$mn:0000177E                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001783                 mov     [ebp+var_F0], eax
.text$mn:00001789
.text$mn:00001789 loc_1789:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+5A3j
.text$mn:00001789                 mov     eax, [ebp+var_FC]
.text$mn:0000178F                 cmp     eax, [ebp+var_128]
.text$mn:00001795                 jge     loc_1820
.text$mn:0000179B                 mov     ecx, [ebp+var_F0]
.text$mn:000017A1                 push    ecx             ; int
.text$mn:000017A2                 mov     ecx, [ebp+var_EC] ; this
.text$mn:000017A8                 call    ?isWhitespace@XmlMatchedTagsHighlighter@@AAE_NH@Z ; XmlMatchedTagsHighlighter::isWhitespace(int)
.text$mn:000017AD                 movzx   edx, al
.text$mn:000017B0                 test    edx, edx
.text$mn:000017B2                 jnz     short loc_1820
.text$mn:000017B4                 cmp     [ebp+var_F0], 2Fh ; '/'
.text$mn:000017BB                 jz      short loc_1820
.text$mn:000017BD                 cmp     [ebp+var_F0], 3Eh ; '>'
.text$mn:000017C4                 jz      short loc_1820
.text$mn:000017C6                 cmp     [ebp+var_F0], 22h ; '"'
.text$mn:000017CD                 jz      short loc_1820
.text$mn:000017CF                 cmp     [ebp+var_F0], 27h ; '''
.text$mn:000017D6                 jz      short loc_1820
.text$mn:000017D8                 movzx   eax, byte ptr [ebp+var_F0]
.text$mn:000017DF                 push    eax
.text$mn:000017E0                 lea     ecx, [ebp+var_9C]
.text$mn:000017E6                 call    ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::push_back(char)
.text$mn:000017EB                 mov     ecx, [ebp+var_FC]
.text$mn:000017F1                 add     ecx, 1
.text$mn:000017F4                 mov     [ebp+var_FC], ecx
.text$mn:000017FA                 push    0               ; __int32
.text$mn:000017FC                 mov     edx, [ebp+var_FC]
.text$mn:00001802                 push    edx             ; unsigned int
.text$mn:00001803                 push    7D7h            ; unsigned int
.text$mn:00001808                 mov     eax, [ebp+var_EC]
.text$mn:0000180E                 mov     ecx, [eax]      ; this
.text$mn:00001810                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001815                 mov     [ebp+var_F0], eax
.text$mn:0000181B                 jmp     loc_1789
.text$mn:00001820 ; ---------------------------------------------------------------------------
.text$mn:00001820
.text$mn:00001820 loc_1820:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+51Dj
.text$mn:00001820                                         ; XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+53Aj ...
.text$mn:00001820                 lea     ecx, [ebp+var_9C]
.text$mn:00001826                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000182B                 test    eax, eax
.text$mn:0000182D                 jz      loc_1A10
.text$mn:00001833                 lea     ecx, [ebp+var_9C]
.text$mn:00001839                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000183E                 mov     ecx, [ebp+var_1C]
.text$mn:00001841                 lea     edx, [ecx+eax+1]
.text$mn:00001845                 mov     eax, [ebp+arg_0]
.text$mn:00001848                 mov     [eax+4], edx
.text$mn:0000184B                 mov     ecx, [ebp+var_128]
.text$mn:00001851                 push    ecx             ; int
.text$mn:00001852                 mov     edx, [ebp+var_FC]
.text$mn:00001858                 push    edx             ; int
.text$mn:00001859                 mov     ecx, [ebp+var_EC] ; this
.text$mn:0000185F                 call    ?findCloseAngle@XmlMatchedTagsHighlighter@@AAEHHH@Z ; XmlMatchedTagsHighlighter::findCloseAngle(int,int)
.text$mn:00001864                 mov     [ebp+var_12C], eax
.text$mn:0000186A                 cmp     [ebp+var_12C], 0FFFFFFFFh
.text$mn:00001871                 jz      loc_1A10
.text$mn:00001877                 mov     eax, [ebp+var_12C]
.text$mn:0000187D                 add     eax, 1
.text$mn:00001880                 mov     ecx, [ebp+arg_0]
.text$mn:00001883                 mov     [ecx+8], eax
.text$mn:00001886                 push    0               ; __int32
.text$mn:00001888                 mov     edx, [ebp+var_12C]
.text$mn:0000188E                 sub     edx, 1
.text$mn:00001891                 push    edx             ; unsigned int
.text$mn:00001892                 push    7D7h            ; unsigned int
.text$mn:00001897                 mov     eax, [ebp+var_EC]
.text$mn:0000189D                 mov     ecx, [eax]      ; this
.text$mn:0000189F                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000018A4                 cmp     eax, 2Fh ; '/'
.text$mn:000018A7                 jnz     short loc_18C9
.text$mn:000018A9                 mov     ecx, [ebp+arg_0]
.text$mn:000018AC                 mov     dword ptr [ecx+10h], 0FFFFFFFFh
.text$mn:000018B3                 mov     edx, [ebp+arg_0]
.text$mn:000018B6                 mov     dword ptr [edx+0Ch], 0FFFFFFFFh
.text$mn:000018BD                 mov     [ebp+var_E5], 1
.text$mn:000018C4                 jmp     loc_1A10
.text$mn:000018C9 ; ---------------------------------------------------------------------------
.text$mn:000018C9
.text$mn:000018C9 loc_18C9:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+62Fj
.text$mn:000018C9                 mov     eax, [ebp+arg_0]
.text$mn:000018CC                 mov     ecx, [eax+8]
.text$mn:000018CF                 mov     [ebp+var_110], ecx
.text$mn:000018D5                 mov     [ebp+var_108], 1
.text$mn:000018DF
.text$mn:000018DF loc_18DF:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+792j
.text$mn:000018DF                 mov     edx, [ebp+var_128]
.text$mn:000018E5                 push    edx
.text$mn:000018E6                 mov     eax, [ebp+var_110]
.text$mn:000018EC                 push    eax
.text$mn:000018ED                 lea     ecx, [ebp+var_9C]
.text$mn:000018F3                 push    ecx
.text$mn:000018F4                 lea     edx, [ebp+var_CC]
.text$mn:000018FA                 push    edx
.text$mn:000018FB                 mov     ecx, [ebp+var_EC]
.text$mn:00001901                 call    ?findCloseTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z ; XmlMatchedTagsHighlighter::findCloseTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)
.text$mn:00001906                 mov     ecx, [eax]
.text$mn:00001908                 mov     [ebp+var_34], ecx
.text$mn:0000190B                 mov     edx, [eax+4]
.text$mn:0000190E                 mov     [ebp+var_30], edx
.text$mn:00001911                 mov     eax, [eax+8]
.text$mn:00001914                 mov     [ebp+var_2C], eax
.text$mn:00001917                 movzx   ecx, byte ptr [ebp+var_2C]
.text$mn:0000191B                 test    ecx, ecx
.text$mn:0000191D                 jz      loc_19F0
.text$mn:00001923                 mov     edx, [ebp+var_108]
.text$mn:00001929                 sub     edx, 1
.text$mn:0000192C                 mov     [ebp+var_108], edx
.text$mn:00001932                 mov     eax, [ebp+var_34]
.text$mn:00001935                 mov     [ebp+var_138], eax
.text$mn:0000193B                 mov     [ebp+var_11C], 0
.text$mn:00001945
.text$mn:00001945 loc_1945:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+72Bj
.text$mn:00001945                 mov     ecx, [ebp+var_138]
.text$mn:0000194B                 push    ecx
.text$mn:0000194C                 mov     edx, [ebp+var_110]
.text$mn:00001952                 push    edx
.text$mn:00001953                 lea     eax, [ebp+var_9C]
.text$mn:00001959                 push    eax
.text$mn:0000195A                 lea     ecx, [ebp+var_A8]
.text$mn:00001960                 push    ecx
.text$mn:00001961                 mov     ecx, [ebp+var_EC]
.text$mn:00001967                 call    ?findOpenTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z ; XmlMatchedTagsHighlighter::findOpenTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)
.text$mn:0000196C                 mov     edx, [eax]
.text$mn:0000196E                 mov     [ebp+var_58], edx
.text$mn:00001971                 mov     ecx, [eax+4]
.text$mn:00001974                 mov     [ebp+var_54], ecx
.text$mn:00001977                 mov     edx, [eax+8]
.text$mn:0000197A                 mov     [ebp+var_50], edx
.text$mn:0000197D                 movzx   eax, byte ptr [ebp+var_50]
.text$mn:00001981                 test    eax, eax
.text$mn:00001983                 jz      short loc_199D
.text$mn:00001985                 mov     ecx, [ebp+var_11C]
.text$mn:0000198B                 add     ecx, 1
.text$mn:0000198E                 mov     [ebp+var_11C], ecx
.text$mn:00001994                 mov     edx, [ebp+var_54]
.text$mn:00001997                 mov     [ebp+var_110], edx
.text$mn:0000199D
.text$mn:0000199D loc_199D:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+70Bj
.text$mn:0000199D                 movzx   eax, byte ptr [ebp+var_50]
.text$mn:000019A1                 test    eax, eax
.text$mn:000019A3                 jnz     short loc_1945
.text$mn:000019A5                 cmp     [ebp+var_11C], 0
.text$mn:000019AC                 jnz     short loc_19D5
.text$mn:000019AE                 cmp     [ebp+var_108], 0
.text$mn:000019B5                 jnz     short loc_19D5
.text$mn:000019B7                 mov     ecx, [ebp+arg_0]
.text$mn:000019BA                 mov     edx, [ebp+var_34]
.text$mn:000019BD                 mov     [ecx+0Ch], edx
.text$mn:000019C0                 mov     eax, [ebp+var_30]
.text$mn:000019C3                 add     eax, 1
.text$mn:000019C6                 mov     ecx, [ebp+arg_0]
.text$mn:000019C9                 mov     [ecx+10h], eax
.text$mn:000019CC                 mov     [ebp+var_E5], 1
.text$mn:000019D3                 jmp     short loc_19F0
.text$mn:000019D5 ; ---------------------------------------------------------------------------
.text$mn:000019D5
.text$mn:000019D5 loc_19D5:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+734j
.text$mn:000019D5                                         ; XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+73Dj
.text$mn:000019D5                 mov     edx, [ebp+var_108]
.text$mn:000019DB                 add     edx, [ebp+var_11C]
.text$mn:000019E1                 mov     [ebp+var_108], edx
.text$mn:000019E7                 mov     eax, [ebp+var_30]
.text$mn:000019EA                 mov     [ebp+var_110], eax
.text$mn:000019F0
.text$mn:000019F0 loc_19F0:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+6A5j
.text$mn:000019F0                                         ; XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+75Bj
.text$mn:000019F0                 movzx   ecx, [ebp+var_E5]
.text$mn:000019F7                 test    ecx, ecx
.text$mn:000019F9                 jnz     short loc_1A10
.text$mn:000019FB                 cmp     [ebp+var_108], 0
.text$mn:00001A02                 jle     short loc_1A10
.text$mn:00001A04                 movzx   edx, byte ptr [ebp+var_2C]
.text$mn:00001A08                 test    edx, edx
.text$mn:00001A0A                 jnz     loc_18DF
.text$mn:00001A10
.text$mn:00001A10 loc_1A10:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+5B5j
.text$mn:00001A10                                         ; XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+5F9j ...
.text$mn:00001A10                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001A17                 lea     ecx, [ebp+var_9C]
.text$mn:00001A1D                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00001A22
.text$mn:00001A22 loc_1A22:                               ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+E6j
.text$mn:00001A22                                         ; XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+F3j ...
.text$mn:00001A22                 mov     al, [ebp+var_E5]
.text$mn:00001A28                 mov     ecx, [ebp+var_C]
.text$mn:00001A2B                 mov     large fs:0, ecx
.text$mn:00001A32                 pop     ecx
.text$mn:00001A33                 mov     ecx, [ebp+var_10]
.text$mn:00001A36                 xor     ecx, ebp
.text$mn:00001A38                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001A3D                 mov     esp, ebp
.text$mn:00001A3F                 pop     ebp
.text$mn:00001A40                 retn    4
.text$mn:00001A40 ?getXmlMatchedTagsPos@XmlMatchedTagsHighlighter@@AAE_NAAUXmlMatchedTagsPos@1@@Z endp
.text$mn:00001A40
.text$mn:00001A40 ; ---------------------------------------------------------------------------
.text$mn:00001A43                 align 8
.text$mn:00001A48
.text$mn:00001A48 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A48
.text$mn:00001A48 ; Attributes: bp-based frame
.text$mn:00001A48
.text$mn:00001A48 ; private: struct XmlMatchedTagsHighlighter::FindResult __thiscall XmlMatchedTagsHighlighter::findText(char const *, int, int, int)
.text$mn:00001A48                 public ?findText@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@PBDHHH@Z
.text$mn:00001A48 ?findText@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@PBDHHH@Z proc near
.text$mn:00001A48                                         ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+12Cp
.text$mn:00001A48                                         ; XmlMatchedTagsHighlighter::tagMatch(bool)+14Cp ...
.text$mn:00001A48
.text$mn:00001A48 var_2C          = dword ptr -2Ch
.text$mn:00001A48 var_28          = dword ptr -28h
.text$mn:00001A48 var_24          = dword ptr -24h
.text$mn:00001A48 var_20          = dword ptr -20h
.text$mn:00001A48 var_1C          = dword ptr -1Ch
.text$mn:00001A48 var_18          = dword ptr -18h
.text$mn:00001A48 var_14          = dword ptr -14h
.text$mn:00001A48 var_10          = dword ptr -10h
.text$mn:00001A48 var_C           = dword ptr -0Ch
.text$mn:00001A48 var_8           = dword ptr -8
.text$mn:00001A48 var_4           = dword ptr -4
.text$mn:00001A48 arg_0           = dword ptr  8
.text$mn:00001A48 arg_4           = dword ptr  0Ch
.text$mn:00001A48 arg_8           = dword ptr  10h
.text$mn:00001A48 arg_C           = dword ptr  14h
.text$mn:00001A48 arg_10          = dword ptr  18h
.text$mn:00001A48
.text$mn:00001A48                 push    ebp
.text$mn:00001A49                 mov     ebp, esp
.text$mn:00001A4B                 sub     esp, 2Ch
.text$mn:00001A4E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001A53                 xor     eax, ebp
.text$mn:00001A55                 mov     [ebp+var_4], eax
.text$mn:00001A58                 mov     [ebp+var_18], ecx
.text$mn:00001A5B                 mov     eax, [ebp+arg_4]
.text$mn:00001A5E                 mov     [ebp+var_24], eax
.text$mn:00001A61                 mov     ecx, [ebp+arg_8]
.text$mn:00001A64                 mov     [ebp+var_2C], ecx
.text$mn:00001A67                 mov     edx, [ebp+arg_C]
.text$mn:00001A6A                 mov     [ebp+var_28], edx
.text$mn:00001A6D                 lea     eax, [ebp+var_2C]
.text$mn:00001A70                 push    eax             ; __int32
.text$mn:00001A71                 mov     ecx, [ebp+arg_10]
.text$mn:00001A74                 push    ecx             ; unsigned int
.text$mn:00001A75                 push    866h            ; unsigned int
.text$mn:00001A7A                 mov     edx, [ebp+var_18]
.text$mn:00001A7D                 mov     ecx, [edx]      ; this
.text$mn:00001A7F                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001A84                 mov     [ebp+var_14], eax
.text$mn:00001A87                 cmp     [ebp+var_14], 0FFFFFFFFh
.text$mn:00001A8B                 jnz     short loc_1A93
.text$mn:00001A8D                 mov     byte ptr [ebp+var_8], 0
.text$mn:00001A91                 jmp     short loc_1AA3
.text$mn:00001A93 ; ---------------------------------------------------------------------------
.text$mn:00001A93
.text$mn:00001A93 loc_1A93:                               ; CODE XREF: XmlMatchedTagsHighlighter::findText(char const *,int,int,int)+43j
.text$mn:00001A93                 mov     byte ptr [ebp+var_8], 1
.text$mn:00001A97                 mov     eax, [ebp+var_20]
.text$mn:00001A9A                 mov     [ebp+var_10], eax
.text$mn:00001A9D                 mov     ecx, [ebp+var_1C]
.text$mn:00001AA0                 mov     [ebp+var_C], ecx
.text$mn:00001AA3
.text$mn:00001AA3 loc_1AA3:                               ; CODE XREF: XmlMatchedTagsHighlighter::findText(char const *,int,int,int)+49j
.text$mn:00001AA3                 mov     edx, [ebp+arg_0]
.text$mn:00001AA6                 mov     eax, [ebp+var_10]
.text$mn:00001AA9                 mov     [edx], eax
.text$mn:00001AAB                 mov     ecx, [ebp+var_C]
.text$mn:00001AAE                 mov     [edx+4], ecx
.text$mn:00001AB1                 mov     eax, [ebp+var_8]
.text$mn:00001AB4                 mov     [edx+8], eax
.text$mn:00001AB7                 mov     eax, [ebp+arg_0]
.text$mn:00001ABA                 mov     ecx, [ebp+var_4]
.text$mn:00001ABD                 xor     ecx, ebp
.text$mn:00001ABF                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001AC4                 mov     esp, ebp
.text$mn:00001AC6                 pop     ebp
.text$mn:00001AC7                 retn    14h
.text$mn:00001AC7 ?findText@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@PBDHHH@Z endp
.text$mn:00001AC7
.text$mn:00001AC7 ; ---------------------------------------------------------------------------
.text$mn:00001ACA                 db 0Eh dup(0CCh)
.text$mn:00001AD8
.text$mn:00001AD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AD8
.text$mn:00001AD8 ; Attributes: bp-based frame
.text$mn:00001AD8
.text$mn:00001AD8 ; private: struct XmlMatchedTagsHighlighter::FindResult __thiscall XmlMatchedTagsHighlighter::findOpenTag(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, int, int)
.text$mn:00001AD8                 public ?findOpenTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z
.text$mn:00001AD8 ?findOpenTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z proc near
.text$mn:00001AD8                                         ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+331p
.text$mn:00001AD8                                         ; XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+6EFp
.text$mn:00001AD8
.text$mn:00001AD8 var_74          = dword ptr -74h
.text$mn:00001AD8 var_70          = dword ptr -70h
.text$mn:00001AD8 var_6C          = dword ptr -6Ch
.text$mn:00001AD8 var_68          = dword ptr -68h
.text$mn:00001AD8 var_64          = dword ptr -64h
.text$mn:00001AD8 var_60          = dword ptr -60h
.text$mn:00001AD8 var_5C          = dword ptr -5Ch
.text$mn:00001AD8 var_58          = dword ptr -58h
.text$mn:00001AD8 var_51          = byte ptr -51h
.text$mn:00001AD8 var_50          = byte ptr -50h
.text$mn:00001AD8 var_44          = byte ptr -44h
.text$mn:00001AD8 var_28          = dword ptr -28h
.text$mn:00001AD8 var_24          = dword ptr -24h
.text$mn:00001AD8 var_20          = dword ptr -20h
.text$mn:00001AD8 var_1C          = dword ptr -1Ch
.text$mn:00001AD8 var_18          = dword ptr -18h
.text$mn:00001AD8 var_14          = dword ptr -14h
.text$mn:00001AD8 var_10          = dword ptr -10h
.text$mn:00001AD8 var_C           = dword ptr -0Ch
.text$mn:00001AD8 var_4           = dword ptr -4
.text$mn:00001AD8 arg_0           = dword ptr  8
.text$mn:00001AD8 arg_4           = dword ptr  0Ch
.text$mn:00001AD8 arg_8           = dword ptr  10h
.text$mn:00001AD8 arg_C           = dword ptr  14h
.text$mn:00001AD8
.text$mn:00001AD8                 push    ebp
.text$mn:00001AD9                 mov     ebp, esp
.text$mn:00001ADB                 push    0FFFFFFFFh
.text$mn:00001ADD                 push    offset __ehhandler$?findOpenTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z
.text$mn:00001AE2                 mov     eax, large fs:0
.text$mn:00001AE8                 push    eax
.text$mn:00001AE9                 sub     esp, 68h
.text$mn:00001AEC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001AF1                 xor     eax, ebp
.text$mn:00001AF3                 mov     [ebp+var_10], eax
.text$mn:00001AF6                 push    eax
.text$mn:00001AF7                 lea     eax, [ebp+var_C]
.text$mn:00001AFA                 mov     large fs:0, eax
.text$mn:00001B00                 mov     [ebp+var_58], ecx
.text$mn:00001B03                 push    offset $SG152490 ; Str
.text$mn:00001B08                 lea     ecx, [ebp+var_44]
.text$mn:00001B0B                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001B10                 mov     [ebp+var_4], 0
.text$mn:00001B17                 mov     eax, [ebp+arg_4]
.text$mn:00001B1A                 push    eax
.text$mn:00001B1B                 lea     ecx, [ebp+var_44]
.text$mn:00001B1E                 call    ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)
.text$mn:00001B23                 mov     byte ptr [ebp+var_20], 0
.text$mn:00001B27                 mov     [ebp+var_68], 0
.text$mn:00001B2E                 mov     ecx, [ebp+arg_8]
.text$mn:00001B31                 mov     [ebp+var_60], ecx
.text$mn:00001B34                 mov     edx, [ebp+arg_C]
.text$mn:00001B37                 mov     [ebp+var_74], edx
.text$mn:00001B3A                 mov     eax, [ebp+arg_8]
.text$mn:00001B3D                 cmp     eax, [ebp+arg_C]
.text$mn:00001B40                 jge     short loc_1B4B
.text$mn:00001B42                 mov     [ebp+var_6C], 1
.text$mn:00001B49                 jmp     short loc_1B52
.text$mn:00001B4B ; ---------------------------------------------------------------------------
.text$mn:00001B4B
.text$mn:00001B4B loc_1B4B:                               ; CODE XREF: XmlMatchedTagsHighlighter::findOpenTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+68j
.text$mn:00001B4B                 mov     [ebp+var_6C], 0
.text$mn:00001B52
.text$mn:00001B52 loc_1B52:                               ; CODE XREF: XmlMatchedTagsHighlighter::findOpenTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+71j
.text$mn:00001B52                 mov     cl, byte ptr [ebp+var_6C]
.text$mn:00001B55                 mov     [ebp+var_51], cl
.text$mn:00001B58
.text$mn:00001B58 loc_1B58:                               ; CODE XREF: XmlMatchedTagsHighlighter::findOpenTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+1ABj
.text$mn:00001B58                 push    0
.text$mn:00001B5A                 mov     edx, [ebp+var_74]
.text$mn:00001B5D                 push    edx
.text$mn:00001B5E                 mov     eax, [ebp+var_60]
.text$mn:00001B61                 push    eax
.text$mn:00001B62                 lea     ecx, [ebp+var_44]
.text$mn:00001B65                 call    ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
.text$mn:00001B6A                 push    eax
.text$mn:00001B6B                 lea     ecx, [ebp+var_50]
.text$mn:00001B6E                 push    ecx
.text$mn:00001B6F                 mov     ecx, [ebp+var_58]
.text$mn:00001B72                 call    ?findText@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@PBDHHH@Z ; XmlMatchedTagsHighlighter::findText(char const *,int,int,int)
.text$mn:00001B77                 mov     edx, [eax]
.text$mn:00001B79                 mov     [ebp+var_1C], edx
.text$mn:00001B7C                 mov     ecx, [eax+4]
.text$mn:00001B7F                 mov     [ebp+var_18], ecx
.text$mn:00001B82                 mov     edx, [eax+8]
.text$mn:00001B85                 mov     [ebp+var_14], edx
.text$mn:00001B88                 movzx   eax, byte ptr [ebp+var_14]
.text$mn:00001B8C                 test    eax, eax
.text$mn:00001B8E                 jz      loc_1C59
.text$mn:00001B94                 push    0               ; __int32
.text$mn:00001B96                 mov     ecx, [ebp+var_18]
.text$mn:00001B99                 push    ecx             ; unsigned int
.text$mn:00001B9A                 push    7D7h            ; unsigned int
.text$mn:00001B9F                 mov     edx, [ebp+var_58]
.text$mn:00001BA2                 mov     ecx, [edx]      ; this
.text$mn:00001BA4                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001BA9                 mov     [ebp+var_68], eax
.text$mn:00001BAC                 push    0               ; __int32
.text$mn:00001BAE                 mov     eax, [ebp+var_1C]
.text$mn:00001BB1                 push    eax             ; unsigned int
.text$mn:00001BB2                 push    7DAh            ; unsigned int
.text$mn:00001BB7                 mov     ecx, [ebp+var_58]
.text$mn:00001BBA                 mov     ecx, [ecx]      ; this
.text$mn:00001BBC                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001BC1                 mov     [ebp+var_64], eax
.text$mn:00001BC4                 cmp     [ebp+var_64], 11h
.text$mn:00001BC8                 jz      loc_1C59
.text$mn:00001BCE                 cmp     [ebp+var_64], 6
.text$mn:00001BD2                 jz      loc_1C59
.text$mn:00001BD8                 cmp     [ebp+var_64], 7
.text$mn:00001BDC                 jz      short loc_1C59
.text$mn:00001BDE                 cmp     [ebp+var_68], 3Eh ; '>'
.text$mn:00001BE2                 jnz     short loc_1BF0
.text$mn:00001BE4                 mov     edx, [ebp+var_18]
.text$mn:00001BE7                 mov     [ebp+var_24], edx
.text$mn:00001BEA                 mov     byte ptr [ebp+var_20], 1
.text$mn:00001BEE                 jmp     short loc_1C59
.text$mn:00001BF0 ; ---------------------------------------------------------------------------
.text$mn:00001BF0
.text$mn:00001BF0 loc_1BF0:                               ; CODE XREF: XmlMatchedTagsHighlighter::findOpenTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+10Aj
.text$mn:00001BF0                 mov     eax, [ebp+var_68]
.text$mn:00001BF3                 push    eax             ; int
.text$mn:00001BF4                 mov     ecx, [ebp+var_58] ; this
.text$mn:00001BF7                 call    ?isWhitespace@XmlMatchedTagsHighlighter@@AAE_NH@Z ; XmlMatchedTagsHighlighter::isWhitespace(int)
.text$mn:00001BFC                 movzx   ecx, al
.text$mn:00001BFF                 test    ecx, ecx
.text$mn:00001C01                 jz      short loc_1C59
.text$mn:00001C03                 movzx   edx, [ebp+var_51]
.text$mn:00001C07                 test    edx, edx
.text$mn:00001C09                 jz      short loc_1C13
.text$mn:00001C0B                 mov     eax, [ebp+arg_C]
.text$mn:00001C0E                 mov     [ebp+var_70], eax
.text$mn:00001C11                 jmp     short loc_1C19
.text$mn:00001C13 ; ---------------------------------------------------------------------------
.text$mn:00001C13
.text$mn:00001C13 loc_1C13:                               ; CODE XREF: XmlMatchedTagsHighlighter::findOpenTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+131j
.text$mn:00001C13                 mov     ecx, [ebp+arg_8]
.text$mn:00001C16                 mov     [ebp+var_70], ecx
.text$mn:00001C19
.text$mn:00001C19 loc_1C19:                               ; CODE XREF: XmlMatchedTagsHighlighter::findOpenTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+139j
.text$mn:00001C19                 mov     edx, [ebp+var_70]
.text$mn:00001C1C                 push    edx             ; int
.text$mn:00001C1D                 mov     eax, [ebp+var_18]
.text$mn:00001C20                 push    eax             ; int
.text$mn:00001C21                 mov     ecx, [ebp+var_58] ; this
.text$mn:00001C24                 call    ?findCloseAngle@XmlMatchedTagsHighlighter@@AAEHHH@Z ; XmlMatchedTagsHighlighter::findCloseAngle(int,int)
.text$mn:00001C29                 mov     [ebp+var_5C], eax
.text$mn:00001C2C                 cmp     [ebp+var_5C], 0FFFFFFFFh
.text$mn:00001C30                 jz      short loc_1C59
.text$mn:00001C32                 push    0               ; __int32
.text$mn:00001C34                 mov     ecx, [ebp+var_5C]
.text$mn:00001C37                 sub     ecx, 1
.text$mn:00001C3A                 push    ecx             ; unsigned int
.text$mn:00001C3B                 push    7D7h            ; unsigned int
.text$mn:00001C40                 mov     edx, [ebp+var_58]
.text$mn:00001C43                 mov     ecx, [edx]      ; this
.text$mn:00001C45                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001C4A                 cmp     eax, 2Fh ; '/'
.text$mn:00001C4D                 jz      short loc_1C59
.text$mn:00001C4F                 mov     eax, [ebp+var_5C]
.text$mn:00001C52                 mov     [ebp+var_24], eax
.text$mn:00001C55                 mov     byte ptr [ebp+var_20], 1
.text$mn:00001C59
.text$mn:00001C59 loc_1C59:                               ; CODE XREF: XmlMatchedTagsHighlighter::findOpenTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+B6j
.text$mn:00001C59                                         ; XmlMatchedTagsHighlighter::findOpenTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+F0j ...
.text$mn:00001C59                 movzx   ecx, [ebp+var_51]
.text$mn:00001C5D                 test    ecx, ecx
.text$mn:00001C5F                 jz      short loc_1C6C
.text$mn:00001C61                 mov     edx, [ebp+var_18]
.text$mn:00001C64                 add     edx, 1
.text$mn:00001C67                 mov     [ebp+var_60], edx
.text$mn:00001C6A                 jmp     short loc_1C75
.text$mn:00001C6C ; ---------------------------------------------------------------------------
.text$mn:00001C6C
.text$mn:00001C6C loc_1C6C:                               ; CODE XREF: XmlMatchedTagsHighlighter::findOpenTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+187j
.text$mn:00001C6C                 mov     eax, [ebp+var_1C]
.text$mn:00001C6F                 sub     eax, 1
.text$mn:00001C72                 mov     [ebp+var_60], eax
.text$mn:00001C75
.text$mn:00001C75 loc_1C75:                               ; CODE XREF: XmlMatchedTagsHighlighter::findOpenTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+192j
.text$mn:00001C75                 movzx   ecx, byte ptr [ebp+var_14]
.text$mn:00001C79                 test    ecx, ecx
.text$mn:00001C7B                 jz      short loc_1C89
.text$mn:00001C7D                 movzx   edx, byte ptr [ebp+var_20]
.text$mn:00001C81                 test    edx, edx
.text$mn:00001C83                 jz      loc_1B58
.text$mn:00001C89
.text$mn:00001C89 loc_1C89:                               ; CODE XREF: XmlMatchedTagsHighlighter::findOpenTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+1A3j
.text$mn:00001C89                 mov     eax, [ebp+var_1C]
.text$mn:00001C8C                 mov     [ebp+var_28], eax
.text$mn:00001C8F                 mov     ecx, [ebp+arg_0]
.text$mn:00001C92                 mov     edx, [ebp+var_28]
.text$mn:00001C95                 mov     [ecx], edx
.text$mn:00001C97                 mov     eax, [ebp+var_24]
.text$mn:00001C9A                 mov     [ecx+4], eax
.text$mn:00001C9D                 mov     edx, [ebp+var_20]
.text$mn:00001CA0                 mov     [ecx+8], edx
.text$mn:00001CA3                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001CAA                 lea     ecx, [ebp+var_44]
.text$mn:00001CAD                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00001CB2                 mov     eax, [ebp+arg_0]
.text$mn:00001CB5                 mov     ecx, [ebp+var_C]
.text$mn:00001CB8                 mov     large fs:0, ecx
.text$mn:00001CBF                 pop     ecx
.text$mn:00001CC0                 mov     ecx, [ebp+var_10]
.text$mn:00001CC3                 xor     ecx, ebp
.text$mn:00001CC5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001CCA                 mov     esp, ebp
.text$mn:00001CCC                 pop     ebp
.text$mn:00001CCD                 retn    10h
.text$mn:00001CCD ?findOpenTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z endp
.text$mn:00001CCD
.text$mn:00001CCD ; ---------------------------------------------------------------------------
.text$mn:00001CD0                 db 8 dup(0CCh)
.text$mn:00001CD8
.text$mn:00001CD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CD8
.text$mn:00001CD8 ; Attributes: bp-based frame
.text$mn:00001CD8
.text$mn:00001CD8 ; private: struct XmlMatchedTagsHighlighter::FindResult __thiscall XmlMatchedTagsHighlighter::findCloseTag(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, int, int)
.text$mn:00001CD8                 public ?findCloseTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z
.text$mn:00001CD8 ?findCloseTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z proc near
.text$mn:00001CD8                                         ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+3C4p
.text$mn:00001CD8                                         ; XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+689p
.text$mn:00001CD8
.text$mn:00001CD8 var_70          = dword ptr -70h
.text$mn:00001CD8 var_6C          = dword ptr -6Ch
.text$mn:00001CD8 var_68          = dword ptr -68h
.text$mn:00001CD8 var_64          = dword ptr -64h
.text$mn:00001CD8 var_60          = dword ptr -60h
.text$mn:00001CD8 var_5C          = dword ptr -5Ch
.text$mn:00001CD8 var_58          = dword ptr -58h
.text$mn:00001CD8 var_52          = byte ptr -52h
.text$mn:00001CD8 var_51          = byte ptr -51h
.text$mn:00001CD8 var_50          = byte ptr -50h
.text$mn:00001CD8 var_44          = byte ptr -44h
.text$mn:00001CD8 var_28          = dword ptr -28h
.text$mn:00001CD8 var_24          = dword ptr -24h
.text$mn:00001CD8 var_20          = dword ptr -20h
.text$mn:00001CD8 var_1C          = dword ptr -1Ch
.text$mn:00001CD8 var_18          = dword ptr -18h
.text$mn:00001CD8 var_14          = dword ptr -14h
.text$mn:00001CD8 var_10          = dword ptr -10h
.text$mn:00001CD8 var_C           = dword ptr -0Ch
.text$mn:00001CD8 var_4           = dword ptr -4
.text$mn:00001CD8 arg_0           = dword ptr  8
.text$mn:00001CD8 arg_4           = dword ptr  0Ch
.text$mn:00001CD8 arg_8           = dword ptr  10h
.text$mn:00001CD8 arg_C           = dword ptr  14h
.text$mn:00001CD8
.text$mn:00001CD8                 push    ebp
.text$mn:00001CD9                 mov     ebp, esp
.text$mn:00001CDB                 push    0FFFFFFFFh
.text$mn:00001CDD                 push    offset __ehhandler$?findCloseTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z
.text$mn:00001CE2                 mov     eax, large fs:0
.text$mn:00001CE8                 push    eax
.text$mn:00001CE9                 sub     esp, 64h
.text$mn:00001CEC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001CF1                 xor     eax, ebp
.text$mn:00001CF3                 mov     [ebp+var_10], eax
.text$mn:00001CF6                 push    eax
.text$mn:00001CF7                 lea     eax, [ebp+var_C]
.text$mn:00001CFA                 mov     large fs:0, eax
.text$mn:00001D00                 mov     [ebp+var_58], ecx
.text$mn:00001D03                 push    offset $SG152540 ; "</"
.text$mn:00001D08                 lea     ecx, [ebp+var_44]
.text$mn:00001D0B                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001D10                 mov     [ebp+var_4], 0
.text$mn:00001D17                 mov     eax, [ebp+arg_4]
.text$mn:00001D1A                 push    eax
.text$mn:00001D1B                 lea     ecx, [ebp+var_44]
.text$mn:00001D1E                 call    ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)
.text$mn:00001D23                 mov     byte ptr [ebp+var_20], 0
.text$mn:00001D27                 mov     ecx, [ebp+arg_8]
.text$mn:00001D2A                 mov     [ebp+var_68], ecx
.text$mn:00001D2D                 mov     edx, [ebp+arg_C]
.text$mn:00001D30                 mov     [ebp+var_70], edx
.text$mn:00001D33                 mov     eax, [ebp+arg_8]
.text$mn:00001D36                 cmp     eax, [ebp+arg_C]
.text$mn:00001D39                 jge     short loc_1D44
.text$mn:00001D3B                 mov     [ebp+var_6C], 1
.text$mn:00001D42                 jmp     short loc_1D4B
.text$mn:00001D44 ; ---------------------------------------------------------------------------
.text$mn:00001D44
.text$mn:00001D44 loc_1D44:                               ; CODE XREF: XmlMatchedTagsHighlighter::findCloseTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+61j
.text$mn:00001D44                 mov     [ebp+var_6C], 0
.text$mn:00001D4B
.text$mn:00001D4B loc_1D4B:                               ; CODE XREF: XmlMatchedTagsHighlighter::findCloseTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+6Aj
.text$mn:00001D4B                 mov     cl, byte ptr [ebp+var_6C]
.text$mn:00001D4E                 mov     [ebp+var_52], cl
.text$mn:00001D51
.text$mn:00001D51 loc_1D51:                               ; CODE XREF: XmlMatchedTagsHighlighter::findCloseTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+1B4j
.text$mn:00001D51                 mov     [ebp+var_51], 0
.text$mn:00001D55                 push    0
.text$mn:00001D57                 mov     edx, [ebp+var_70]
.text$mn:00001D5A                 push    edx
.text$mn:00001D5B                 mov     eax, [ebp+var_68]
.text$mn:00001D5E                 push    eax
.text$mn:00001D5F                 lea     ecx, [ebp+var_44]
.text$mn:00001D62                 call    ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
.text$mn:00001D67                 push    eax
.text$mn:00001D68                 lea     ecx, [ebp+var_50]
.text$mn:00001D6B                 push    ecx
.text$mn:00001D6C                 mov     ecx, [ebp+var_58]
.text$mn:00001D6F                 call    ?findText@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@PBDHHH@Z ; XmlMatchedTagsHighlighter::findText(char const *,int,int,int)
.text$mn:00001D74                 mov     edx, [eax]
.text$mn:00001D76                 mov     [ebp+var_1C], edx
.text$mn:00001D79                 mov     ecx, [eax+4]
.text$mn:00001D7C                 mov     [ebp+var_18], ecx
.text$mn:00001D7F                 mov     edx, [eax+8]
.text$mn:00001D82                 mov     [ebp+var_14], edx
.text$mn:00001D85                 movzx   eax, byte ptr [ebp+var_14]
.text$mn:00001D89                 test    eax, eax
.text$mn:00001D8B                 jz      loc_1E7E
.text$mn:00001D91                 push    0               ; __int32
.text$mn:00001D93                 mov     ecx, [ebp+var_18]
.text$mn:00001D96                 push    ecx             ; unsigned int
.text$mn:00001D97                 push    7D7h            ; unsigned int
.text$mn:00001D9C                 mov     edx, [ebp+var_58]
.text$mn:00001D9F                 mov     ecx, [edx]      ; this
.text$mn:00001DA1                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001DA6                 mov     [ebp+var_5C], eax
.text$mn:00001DA9                 push    0               ; __int32
.text$mn:00001DAB                 mov     eax, [ebp+var_1C]
.text$mn:00001DAE                 push    eax             ; unsigned int
.text$mn:00001DAF                 push    7DAh            ; unsigned int
.text$mn:00001DB4                 mov     ecx, [ebp+var_58]
.text$mn:00001DB7                 mov     ecx, [ecx]      ; this
.text$mn:00001DB9                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001DBE                 mov     [ebp+var_64], eax
.text$mn:00001DC1                 movzx   edx, [ebp+var_52]
.text$mn:00001DC5                 test    edx, edx
.text$mn:00001DC7                 jz      short loc_1DD4
.text$mn:00001DC9                 mov     eax, [ebp+var_18]
.text$mn:00001DCC                 add     eax, 1
.text$mn:00001DCF                 mov     [ebp+var_68], eax
.text$mn:00001DD2                 jmp     short loc_1DDD
.text$mn:00001DD4 ; ---------------------------------------------------------------------------
.text$mn:00001DD4
.text$mn:00001DD4 loc_1DD4:                               ; CODE XREF: XmlMatchedTagsHighlighter::findCloseTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+EFj
.text$mn:00001DD4                 mov     ecx, [ebp+var_1C]
.text$mn:00001DD7                 sub     ecx, 1
.text$mn:00001DDA                 mov     [ebp+var_68], ecx
.text$mn:00001DDD
.text$mn:00001DDD loc_1DDD:                               ; CODE XREF: XmlMatchedTagsHighlighter::findCloseTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+FAj
.text$mn:00001DDD                 cmp     [ebp+var_64], 11h
.text$mn:00001DE1                 jz      loc_1E7E
.text$mn:00001DE7                 cmp     [ebp+var_64], 7
.text$mn:00001DEB                 jz      loc_1E7E
.text$mn:00001DF1                 cmp     [ebp+var_64], 6
.text$mn:00001DF5                 jz      loc_1E7E
.text$mn:00001DFB                 cmp     [ebp+var_5C], 3Eh ; '>'
.text$mn:00001DFF                 jnz     short loc_1E17
.text$mn:00001E01                 mov     [ebp+var_51], 1
.text$mn:00001E05                 mov     edx, [ebp+var_1C]
.text$mn:00001E08                 mov     [ebp+var_28], edx
.text$mn:00001E0B                 mov     eax, [ebp+var_18]
.text$mn:00001E0E                 mov     [ebp+var_24], eax
.text$mn:00001E11                 mov     byte ptr [ebp+var_20], 1
.text$mn:00001E15                 jmp     short loc_1E7E
.text$mn:00001E17 ; ---------------------------------------------------------------------------
.text$mn:00001E17
.text$mn:00001E17 loc_1E17:                               ; CODE XREF: XmlMatchedTagsHighlighter::findCloseTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+127j
.text$mn:00001E17                 mov     ecx, [ebp+var_5C]
.text$mn:00001E1A                 push    ecx             ; int
.text$mn:00001E1B                 mov     ecx, [ebp+var_58] ; this
.text$mn:00001E1E                 call    ?isWhitespace@XmlMatchedTagsHighlighter@@AAE_NH@Z ; XmlMatchedTagsHighlighter::isWhitespace(int)
.text$mn:00001E23                 movzx   edx, al
.text$mn:00001E26                 test    edx, edx
.text$mn:00001E28                 jz      short loc_1E7E
.text$mn:00001E2A                 mov     eax, [ebp+var_18]
.text$mn:00001E2D                 mov     [ebp+var_60], eax
.text$mn:00001E30
.text$mn:00001E30 loc_1E30:                               ; CODE XREF: XmlMatchedTagsHighlighter::findCloseTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+18Aj
.text$mn:00001E30                 mov     ecx, [ebp+var_60]
.text$mn:00001E33                 add     ecx, 1
.text$mn:00001E36                 mov     [ebp+var_60], ecx
.text$mn:00001E39                 push    0               ; __int32
.text$mn:00001E3B                 mov     edx, [ebp+var_60]
.text$mn:00001E3E                 push    edx             ; unsigned int
.text$mn:00001E3F                 push    7D7h            ; unsigned int
.text$mn:00001E44                 mov     eax, [ebp+var_58]
.text$mn:00001E47                 mov     ecx, [eax]      ; this
.text$mn:00001E49                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001E4E                 mov     [ebp+var_5C], eax
.text$mn:00001E51                 mov     ecx, [ebp+var_5C]
.text$mn:00001E54                 push    ecx             ; int
.text$mn:00001E55                 mov     ecx, [ebp+var_58] ; this
.text$mn:00001E58                 call    ?isWhitespace@XmlMatchedTagsHighlighter@@AAE_NH@Z ; XmlMatchedTagsHighlighter::isWhitespace(int)
.text$mn:00001E5D                 movzx   edx, al
.text$mn:00001E60                 test    edx, edx
.text$mn:00001E62                 jnz     short loc_1E30
.text$mn:00001E64                 cmp     [ebp+var_5C], 3Eh ; '>'
.text$mn:00001E68                 jnz     short loc_1E7E
.text$mn:00001E6A                 mov     [ebp+var_51], 1
.text$mn:00001E6E                 mov     eax, [ebp+var_1C]
.text$mn:00001E71                 mov     [ebp+var_28], eax
.text$mn:00001E74                 mov     ecx, [ebp+var_60]
.text$mn:00001E77                 mov     [ebp+var_24], ecx
.text$mn:00001E7A                 mov     byte ptr [ebp+var_20], 1
.text$mn:00001E7E
.text$mn:00001E7E loc_1E7E:                               ; CODE XREF: XmlMatchedTagsHighlighter::findCloseTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+B3j
.text$mn:00001E7E                                         ; XmlMatchedTagsHighlighter::findCloseTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+109j ...
.text$mn:00001E7E                 movzx   edx, byte ptr [ebp+var_14]
.text$mn:00001E82                 test    edx, edx
.text$mn:00001E84                 jz      short loc_1E92
.text$mn:00001E86                 movzx   eax, [ebp+var_51]
.text$mn:00001E8A                 test    eax, eax
.text$mn:00001E8C                 jz      loc_1D51
.text$mn:00001E92
.text$mn:00001E92 loc_1E92:                               ; CODE XREF: XmlMatchedTagsHighlighter::findCloseTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+1ACj
.text$mn:00001E92                 mov     ecx, [ebp+arg_0]
.text$mn:00001E95                 mov     edx, [ebp+var_28]
.text$mn:00001E98                 mov     [ecx], edx
.text$mn:00001E9A                 mov     eax, [ebp+var_24]
.text$mn:00001E9D                 mov     [ecx+4], eax
.text$mn:00001EA0                 mov     edx, [ebp+var_20]
.text$mn:00001EA3                 mov     [ecx+8], edx
.text$mn:00001EA6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001EAD                 lea     ecx, [ebp+var_44]
.text$mn:00001EB0                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00001EB5                 mov     eax, [ebp+arg_0]
.text$mn:00001EB8                 mov     ecx, [ebp+var_C]
.text$mn:00001EBB                 mov     large fs:0, ecx
.text$mn:00001EC2                 pop     ecx
.text$mn:00001EC3                 mov     ecx, [ebp+var_10]
.text$mn:00001EC6                 xor     ecx, ebp
.text$mn:00001EC8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001ECD                 mov     esp, ebp
.text$mn:00001ECF                 pop     ebp
.text$mn:00001ED0                 retn    10h
.text$mn:00001ED0 ?findCloseTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z endp
.text$mn:00001ED0
.text$mn:00001ED0 ; ---------------------------------------------------------------------------
.text$mn:00001ED3                 align 8
.text$mn:00001ED8
.text$mn:00001ED8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001ED8
.text$mn:00001ED8 ; Attributes: bp-based frame
.text$mn:00001ED8
.text$mn:00001ED8 ; int __thiscall XmlMatchedTagsHighlighter::findCloseAngle(XmlMatchedTagsHighlighter *this, int, int)
.text$mn:00001ED8                 public ?findCloseAngle@XmlMatchedTagsHighlighter@@AAEHHH@Z
.text$mn:00001ED8 ?findCloseAngle@XmlMatchedTagsHighlighter@@AAEHHH@Z proc near
.text$mn:00001ED8                                         ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+5E7p
.text$mn:00001ED8                                         ; XmlMatchedTagsHighlighter::findOpenTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+14Cp
.text$mn:00001ED8
.text$mn:00001ED8 var_30          = dword ptr -30h
.text$mn:00001ED8 var_2C          = dword ptr -2Ch
.text$mn:00001ED8 var_28          = dword ptr -28h
.text$mn:00001ED8 var_24          = dword ptr -24h
.text$mn:00001ED8 var_1D          = byte ptr -1Dh
.text$mn:00001ED8 var_1C          = byte ptr -1Ch
.text$mn:00001ED8 var_10          = dword ptr -10h
.text$mn:00001ED8 var_C           = dword ptr -0Ch
.text$mn:00001ED8 var_8           = dword ptr -8
.text$mn:00001ED8 var_4           = dword ptr -4
.text$mn:00001ED8 arg_0           = dword ptr  8
.text$mn:00001ED8 arg_4           = dword ptr  0Ch
.text$mn:00001ED8
.text$mn:00001ED8                 push    ebp
.text$mn:00001ED9                 mov     ebp, esp
.text$mn:00001EDB                 sub     esp, 30h
.text$mn:00001EDE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001EE3                 xor     eax, ebp
.text$mn:00001EE5                 mov     [ebp+var_4], eax
.text$mn:00001EE8                 mov     [ebp+var_2C], ecx
.text$mn:00001EEB                 mov     [ebp+var_24], 0FFFFFFFFh
.text$mn:00001EF2                 mov     eax, [ebp+arg_0]
.text$mn:00001EF5                 cmp     eax, [ebp+arg_4]
.text$mn:00001EF8                 jle     short loc_1F0C
.text$mn:00001EFA                 mov     ecx, [ebp+arg_4]
.text$mn:00001EFD                 mov     [ebp+var_30], ecx
.text$mn:00001F00                 mov     edx, [ebp+arg_0]
.text$mn:00001F03                 mov     [ebp+arg_4], edx
.text$mn:00001F06                 mov     eax, [ebp+var_30]
.text$mn:00001F09                 mov     [ebp+arg_0], eax
.text$mn:00001F0C
.text$mn:00001F0C loc_1F0C:                               ; CODE XREF: XmlMatchedTagsHighlighter::findCloseAngle(int,int)+20j
.text$mn:00001F0C                                         ; XmlMatchedTagsHighlighter::findCloseAngle(int,int)+B0j
.text$mn:00001F0C                 mov     [ebp+var_1D], 0
.text$mn:00001F10                 push    0
.text$mn:00001F12                 mov     ecx, [ebp+arg_4]
.text$mn:00001F15                 push    ecx
.text$mn:00001F16                 mov     edx, [ebp+arg_0]
.text$mn:00001F19                 push    edx
.text$mn:00001F1A                 push    offset $SG152526
.text$mn:00001F1F                 lea     eax, [ebp+var_1C]
.text$mn:00001F22                 push    eax
.text$mn:00001F23                 mov     ecx, [ebp+var_2C]
.text$mn:00001F26                 call    ?findText@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@PBDHHH@Z ; XmlMatchedTagsHighlighter::findText(char const *,int,int,int)
.text$mn:00001F2B                 mov     ecx, [eax]
.text$mn:00001F2D                 mov     [ebp+var_10], ecx
.text$mn:00001F30                 mov     edx, [eax+4]
.text$mn:00001F33                 mov     [ebp+var_C], edx
.text$mn:00001F36                 mov     eax, [eax+8]
.text$mn:00001F39                 mov     [ebp+var_8], eax
.text$mn:00001F3C                 movzx   ecx, byte ptr [ebp+var_8]
.text$mn:00001F40                 test    ecx, ecx
.text$mn:00001F42                 jz      short loc_1F7A
.text$mn:00001F44                 push    0               ; __int32
.text$mn:00001F46                 mov     edx, [ebp+var_10]
.text$mn:00001F49                 push    edx             ; unsigned int
.text$mn:00001F4A                 push    7DAh            ; unsigned int
.text$mn:00001F4F                 mov     eax, [ebp+var_2C]
.text$mn:00001F52                 mov     ecx, [eax]      ; this
.text$mn:00001F54                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001F59                 mov     [ebp+var_28], eax
.text$mn:00001F5C                 cmp     [ebp+var_28], 6
.text$mn:00001F60                 jz      short loc_1F74
.text$mn:00001F62                 cmp     [ebp+var_28], 7
.text$mn:00001F66                 jz      short loc_1F74
.text$mn:00001F68                 mov     ecx, [ebp+var_10]
.text$mn:00001F6B                 mov     [ebp+var_24], ecx
.text$mn:00001F6E                 mov     [ebp+var_1D], 1
.text$mn:00001F72                 jmp     short loc_1F7A
.text$mn:00001F74 ; ---------------------------------------------------------------------------
.text$mn:00001F74
.text$mn:00001F74 loc_1F74:                               ; CODE XREF: XmlMatchedTagsHighlighter::findCloseAngle(int,int)+88j
.text$mn:00001F74                                         ; XmlMatchedTagsHighlighter::findCloseAngle(int,int)+8Ej
.text$mn:00001F74                 mov     edx, [ebp+var_C]
.text$mn:00001F77                 mov     [ebp+arg_0], edx
.text$mn:00001F7A
.text$mn:00001F7A loc_1F7A:                               ; CODE XREF: XmlMatchedTagsHighlighter::findCloseAngle(int,int)+6Aj
.text$mn:00001F7A                                         ; XmlMatchedTagsHighlighter::findCloseAngle(int,int)+9Aj
.text$mn:00001F7A                 movzx   eax, byte ptr [ebp+var_8]
.text$mn:00001F7E                 test    eax, eax
.text$mn:00001F80                 jz      short loc_1F8A
.text$mn:00001F82                 movzx   ecx, [ebp+var_1D]
.text$mn:00001F86                 test    ecx, ecx
.text$mn:00001F88                 jz      short loc_1F0C
.text$mn:00001F8A
.text$mn:00001F8A loc_1F8A:                               ; CODE XREF: XmlMatchedTagsHighlighter::findCloseAngle(int,int)+A8j
.text$mn:00001F8A                 mov     eax, [ebp+var_24]
.text$mn:00001F8D                 mov     ecx, [ebp+var_4]
.text$mn:00001F90                 xor     ecx, ebp
.text$mn:00001F92                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001F97                 mov     esp, ebp
.text$mn:00001F99                 pop     ebp
.text$mn:00001F9A                 retn    8
.text$mn:00001F9A ?findCloseAngle@XmlMatchedTagsHighlighter@@AAEHHH@Z endp
.text$mn:00001F9A
.text$mn:00001F9A ; ---------------------------------------------------------------------------
.text$mn:00001F9D                 db 0Bh dup(0CCh)
.text$mn:00001FA8
.text$mn:00001FA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FA8
.text$mn:00001FA8 ; Attributes: bp-based frame
.text$mn:00001FA8
.text$mn:00001FA8 ; private: class std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>> __thiscall XmlMatchedTagsHighlighter::getAttributesPos(int, int)
.text$mn:00001FA8                 public ?getAttributesPos@XmlMatchedTagsHighlighter@@AAE?AV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@HH@Z
.text$mn:00001FA8 ?getAttributesPos@XmlMatchedTagsHighlighter@@AAE?AV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@HH@Z proc near
.text$mn:00001FA8                                         ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+2DBp
.text$mn:00001FA8
.text$mn:00001FA8 var_68          = byte ptr -68h
.text$mn:00001FA8 var_58          = byte ptr -58h
.text$mn:00001FA8 var_50          = byte ptr -50h
.text$mn:00001FA8 var_48          = dword ptr -48h
.text$mn:00001FA8 var_44          = dword ptr -44h
.text$mn:00001FA8 var_40          = dword ptr -40h
.text$mn:00001FA8 var_3C          = dword ptr -3Ch
.text$mn:00001FA8 var_38          = dword ptr -38h
.text$mn:00001FA8 var_34          = dword ptr -34h
.text$mn:00001FA8 var_30          = dword ptr -30h
.text$mn:00001FA8 var_2C          = dword ptr -2Ch
.text$mn:00001FA8 var_28          = dword ptr -28h
.text$mn:00001FA8 var_24          = dword ptr -24h
.text$mn:00001FA8 var_20          = dword ptr -20h
.text$mn:00001FA8 var_1C          = dword ptr -1Ch
.text$mn:00001FA8 var_18          = dword ptr -18h
.text$mn:00001FA8 var_14          = dword ptr -14h
.text$mn:00001FA8 var_10          = dword ptr -10h
.text$mn:00001FA8 var_C           = dword ptr -0Ch
.text$mn:00001FA8 var_4           = dword ptr -4
.text$mn:00001FA8 arg_0           = dword ptr  8
.text$mn:00001FA8 arg_4           = dword ptr  0Ch
.text$mn:00001FA8 arg_8           = dword ptr  10h
.text$mn:00001FA8
.text$mn:00001FA8                 push    ebp
.text$mn:00001FA9                 mov     ebp, esp
.text$mn:00001FAB                 push    0FFFFFFFFh
.text$mn:00001FAD                 push    offset __ehhandler$?getAttributesPos@XmlMatchedTagsHighlighter@@AAE?AV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@HH@Z
.text$mn:00001FB2                 mov     eax, large fs:0
.text$mn:00001FB8                 push    eax
.text$mn:00001FB9                 sub     esp, 5Ch
.text$mn:00001FBC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001FC1                 xor     eax, ebp
.text$mn:00001FC3                 push    eax
.text$mn:00001FC4                 lea     eax, [ebp+var_C]
.text$mn:00001FC7                 mov     large fs:0, eax
.text$mn:00001FCD                 mov     [ebp+var_34], ecx
.text$mn:00001FD0                 mov     [ebp+var_2C], 0
.text$mn:00001FD7                 lea     ecx, [ebp+var_68]
.text$mn:00001FDA                 call    ??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>(void)
.text$mn:00001FDF                 mov     [ebp+var_4], 1
.text$mn:00001FE6                 mov     eax, [ebp+arg_8]
.text$mn:00001FE9                 sub     eax, [ebp+arg_4]
.text$mn:00001FEC                 add     eax, 1
.text$mn:00001FEF                 mov     [ebp+var_28], eax
.text$mn:00001FF2                 mov     ecx, [ebp+var_28]
.text$mn:00001FF5                 add     ecx, 1
.text$mn:00001FF8                 push    ecx             ; unsigned int
.text$mn:00001FF9                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:00001FFE                 add     esp, 4
.text$mn:00002001                 mov     [ebp+var_30], eax
.text$mn:00002004                 mov     edx, [ebp+var_30]
.text$mn:00002007                 mov     [ebp+var_24], edx
.text$mn:0000200A                 mov     eax, [ebp+arg_8]
.text$mn:0000200D                 push    eax             ; int
.text$mn:0000200E                 mov     ecx, [ebp+arg_4]
.text$mn:00002011                 push    ecx             ; int
.text$mn:00002012                 mov     edx, [ebp+var_24]
.text$mn:00002015                 push    edx             ; char *
.text$mn:00002016                 mov     eax, [ebp+var_34]
.text$mn:00002019                 mov     ecx, [eax]      ; this
.text$mn:0000201B                 call    ?getText@ScintillaEditView@@QBEXPADHH@Z ; ScintillaEditView::getText(char *,int,int)
.text$mn:00002020                 mov     [ebp+var_10], 0
.text$mn:00002027                 mov     [ebp+var_20], 0FFFFFFFFh
.text$mn:0000202E                 mov     [ebp+var_1C], 1
.text$mn:00002035                 mov     [ebp+var_14], 0
.text$mn:0000203C                 jmp     short loc_2047
.text$mn:0000203E ; ---------------------------------------------------------------------------
.text$mn:0000203E
.text$mn:0000203E loc_203E:                               ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int):loc_2181j
.text$mn:0000203E                 mov     ecx, [ebp+var_14]
.text$mn:00002041                 add     ecx, 1
.text$mn:00002044                 mov     [ebp+var_14], ecx
.text$mn:00002047
.text$mn:00002047 loc_2047:                               ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+94j
.text$mn:00002047                 mov     edx, [ebp+var_14]
.text$mn:0000204A                 cmp     edx, [ebp+var_28]
.text$mn:0000204D                 jge     loc_2186
.text$mn:00002053                 mov     eax, [ebp+var_24]
.text$mn:00002056                 add     eax, [ebp+var_14]
.text$mn:00002059                 movsx   ecx, byte ptr [eax]
.text$mn:0000205C                 mov     [ebp+var_18], ecx
.text$mn:0000205F                 mov     edx, [ebp+var_18]
.text$mn:00002062                 sub     edx, 9
.text$mn:00002065                 mov     [ebp+var_18], edx
.text$mn:00002068                 cmp     [ebp+var_18], 34h ; '4' ; switch 53 cases
.text$mn:0000206C                 ja      $LN8            ; jumptable 0000207C default case
.text$mn:00002072                 mov     eax, [ebp+var_18]
.text$mn:00002075                 movzx   ecx, ds:$LN36[eax]
.text$mn:0000207C                 jmp     ds:$LN38[ecx*4] ; switch jump
.text$mn:00002083 ; ---------------------------------------------------------------------------
.text$mn:00002083
.text$mn:00002083 $LN25:                                  ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+D4j
.text$mn:00002083                                         ; DATA XREF: .text$mn:$LN38o
.text$mn:00002083                 cmp     [ebp+var_10], 1 ; jumptable 0000207C cases 0,1,4,23
.text$mn:00002087                 jnz     short loc_2092
.text$mn:00002089                 mov     [ebp+var_10], 2
.text$mn:00002090                 jmp     short loc_20A6
.text$mn:00002092 ; ---------------------------------------------------------------------------
.text$mn:00002092
.text$mn:00002092 loc_2092:                               ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+DFj
.text$mn:00002092                 cmp     [ebp+var_10], 5
.text$mn:00002096                 jnz     short loc_20A6
.text$mn:00002098                 mov     [ebp+var_10], 6
.text$mn:0000209F                 mov     [ebp+var_1C], 0
.text$mn:000020A6
.text$mn:000020A6 loc_20A6:                               ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+E8j
.text$mn:000020A6                                         ; XmlMatchedTagsHighlighter::getAttributesPos(int,int)+EEj
.text$mn:000020A6                 jmp     loc_2146
.text$mn:000020AB ; ---------------------------------------------------------------------------
.text$mn:000020AB
.text$mn:000020AB $LN21:                                  ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+D4j
.text$mn:000020AB                                         ; DATA XREF: .text$mn:$LN38o
.text$mn:000020AB                 cmp     [ebp+var_10], 1 ; jumptable 0000207C case 52
.text$mn:000020AF                 jz      short loc_20B7
.text$mn:000020B1                 cmp     [ebp+var_10], 2
.text$mn:000020B5                 jnz     short loc_20C0
.text$mn:000020B7
.text$mn:000020B7 loc_20B7:                               ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+107j
.text$mn:000020B7                 mov     [ebp+var_10], 3
.text$mn:000020BE                 jmp     short loc_20D3
.text$mn:000020C0 ; ---------------------------------------------------------------------------
.text$mn:000020C0
.text$mn:000020C0 loc_20C0:                               ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+10Dj
.text$mn:000020C0                 cmp     [ebp+var_10], 3
.text$mn:000020C4                 jz      short loc_20CC
.text$mn:000020C6                 cmp     [ebp+var_10], 5
.text$mn:000020CA                 jnz     short loc_20D3
.text$mn:000020CC
.text$mn:000020CC loc_20CC:                               ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+11Cj
.text$mn:000020CC                 mov     [ebp+var_10], 0
.text$mn:000020D3
.text$mn:000020D3 loc_20D3:                               ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+116j
.text$mn:000020D3                                         ; XmlMatchedTagsHighlighter::getAttributesPos(int,int)+122j
.text$mn:000020D3                 jmp     short loc_2146
.text$mn:000020D5 ; ---------------------------------------------------------------------------
.text$mn:000020D5
.text$mn:000020D5 $LN15:                                  ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+D4j
.text$mn:000020D5                                         ; DATA XREF: .text$mn:$LN38o
.text$mn:000020D5                 cmp     [ebp+var_10], 4 ; jumptable 0000207C case 25
.text$mn:000020D9                 jnz     short loc_20EB
.text$mn:000020DB                 mov     [ebp+var_10], 6
.text$mn:000020E2                 mov     [ebp+var_1C], 1
.text$mn:000020E9                 jmp     short loc_2113
.text$mn:000020EB ; ---------------------------------------------------------------------------
.text$mn:000020EB
.text$mn:000020EB loc_20EB:                               ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+131j
.text$mn:000020EB                 cmp     [ebp+var_10], 1
.text$mn:000020EF                 jz      short loc_20FD
.text$mn:000020F1                 cmp     [ebp+var_10], 2
.text$mn:000020F5                 jz      short loc_20FD
.text$mn:000020F7                 cmp     [ebp+var_10], 5
.text$mn:000020FB                 jnz     short loc_2106
.text$mn:000020FD
.text$mn:000020FD loc_20FD:                               ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+147j
.text$mn:000020FD                                         ; XmlMatchedTagsHighlighter::getAttributesPos(int,int)+14Dj
.text$mn:000020FD                 mov     [ebp+var_10], 0
.text$mn:00002104                 jmp     short loc_2113
.text$mn:00002106 ; ---------------------------------------------------------------------------
.text$mn:00002106
.text$mn:00002106 loc_2106:                               ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+153j
.text$mn:00002106                 cmp     [ebp+var_10], 3
.text$mn:0000210A                 jnz     short loc_2113
.text$mn:0000210C                 mov     [ebp+var_10], 4
.text$mn:00002113
.text$mn:00002113 loc_2113:                               ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+141j
.text$mn:00002113                                         ; XmlMatchedTagsHighlighter::getAttributesPos(int,int)+15Cj ...
.text$mn:00002113                 jmp     short loc_2146
.text$mn:00002115 ; ---------------------------------------------------------------------------
.text$mn:00002115
.text$mn:00002115 $LN8:                                   ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+C4j
.text$mn:00002115                                         ; XmlMatchedTagsHighlighter::getAttributesPos(int,int)+D4j
.text$mn:00002115                                         ; DATA XREF: ...
.text$mn:00002115                 cmp     [ebp+var_10], 0 ; jumptable 0000207C default case
.text$mn:00002119                 jnz     short loc_212A
.text$mn:0000211B                 mov     [ebp+var_10], 1
.text$mn:00002122                 mov     edx, [ebp+var_14]
.text$mn:00002125                 mov     [ebp+var_20], edx
.text$mn:00002128                 jmp     short loc_2146
.text$mn:0000212A ; ---------------------------------------------------------------------------
.text$mn:0000212A
.text$mn:0000212A loc_212A:                               ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+171j
.text$mn:0000212A                 cmp     [ebp+var_10], 2
.text$mn:0000212E                 jnz     short loc_2139
.text$mn:00002130                 mov     [ebp+var_10], 0
.text$mn:00002137                 jmp     short loc_2146
.text$mn:00002139 ; ---------------------------------------------------------------------------
.text$mn:00002139
.text$mn:00002139 loc_2139:                               ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+186j
.text$mn:00002139                 cmp     [ebp+var_10], 3
.text$mn:0000213D                 jnz     short loc_2146
.text$mn:0000213F                 mov     [ebp+var_10], 5
.text$mn:00002146
.text$mn:00002146 loc_2146:                               ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int):loc_20A6j
.text$mn:00002146                                         ; XmlMatchedTagsHighlighter::getAttributesPos(int,int):loc_20D3j ...
.text$mn:00002146                 cmp     [ebp+var_10], 6
.text$mn:0000214A                 jnz     short loc_2181
.text$mn:0000214C                 mov     eax, [ebp+arg_4]
.text$mn:0000214F                 add     eax, [ebp+var_14]
.text$mn:00002152                 add     eax, [ebp+var_1C]
.text$mn:00002155                 mov     [ebp+var_38], eax
.text$mn:00002158                 mov     ecx, [ebp+arg_4]
.text$mn:0000215B                 add     ecx, [ebp+var_20]
.text$mn:0000215E                 mov     [ebp+var_3C], ecx
.text$mn:00002161                 lea     edx, [ebp+var_38]
.text$mn:00002164                 push    edx
.text$mn:00002165                 lea     eax, [ebp+var_3C]
.text$mn:00002168                 push    eax
.text$mn:00002169                 lea     ecx, [ebp+var_50]
.text$mn:0000216C                 call    ??$?0HHX@?$pair@HH@std@@QAE@$$QAH0@Z ; std::pair<int,int>::pair<int,int>(int &&,int &&)
.text$mn:00002171                 push    eax
.text$mn:00002172                 lea     ecx, [ebp+var_68]
.text$mn:00002175                 call    ?push_back@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEX$$QAU?$pair@HH@2@@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::push_back(std::pair<int,int> &&)
.text$mn:0000217A                 mov     [ebp+var_10], 0
.text$mn:00002181
.text$mn:00002181 loc_2181:                               ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+1A2j
.text$mn:00002181                 jmp     loc_203E
.text$mn:00002186 ; ---------------------------------------------------------------------------
.text$mn:00002186
.text$mn:00002186 loc_2186:                               ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+A5j
.text$mn:00002186                 cmp     [ebp+var_10], 5
.text$mn:0000218A                 jnz     short loc_21BB
.text$mn:0000218C                 mov     ecx, [ebp+var_14]
.text$mn:0000218F                 mov     edx, [ebp+arg_4]
.text$mn:00002192                 lea     eax, [edx+ecx-1]
.text$mn:00002196                 mov     [ebp+var_40], eax
.text$mn:00002199                 mov     ecx, [ebp+arg_4]
.text$mn:0000219C                 add     ecx, [ebp+var_20]
.text$mn:0000219F                 mov     [ebp+var_44], ecx
.text$mn:000021A2                 lea     edx, [ebp+var_40]
.text$mn:000021A5                 push    edx
.text$mn:000021A6                 lea     eax, [ebp+var_44]
.text$mn:000021A9                 push    eax
.text$mn:000021AA                 lea     ecx, [ebp+var_58]
.text$mn:000021AD                 call    ??$?0HHX@?$pair@HH@std@@QAE@$$QAH0@Z ; std::pair<int,int>::pair<int,int>(int &&,int &&)
.text$mn:000021B2                 push    eax
.text$mn:000021B3                 lea     ecx, [ebp+var_68]
.text$mn:000021B6                 call    ?push_back@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEX$$QAU?$pair@HH@2@@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::push_back(std::pair<int,int> &&)
.text$mn:000021BB
.text$mn:000021BB loc_21BB:                               ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+1E2j
.text$mn:000021BB                 mov     ecx, [ebp+var_24]
.text$mn:000021BE                 mov     [ebp+var_48], ecx
.text$mn:000021C1                 mov     edx, [ebp+var_48]
.text$mn:000021C4                 push    edx             ; void *
.text$mn:000021C5                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:000021CA                 add     esp, 4
.text$mn:000021CD                 lea     eax, [ebp+var_68]
.text$mn:000021D0                 push    eax
.text$mn:000021D1                 mov     ecx, [ebp+arg_0]
.text$mn:000021D4                 call    ??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@$$QAV01@@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>(std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>> &&)
.text$mn:000021D9                 mov     ecx, [ebp+var_2C]
.text$mn:000021DC                 or      ecx, 1
.text$mn:000021DF                 mov     [ebp+var_2C], ecx
.text$mn:000021E2                 mov     byte ptr [ebp+var_4], 0
.text$mn:000021E6                 lea     ecx, [ebp+var_68]
.text$mn:000021E9                 call    ??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::~vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>(void)
.text$mn:000021EE                 mov     eax, [ebp+arg_0]
.text$mn:000021F1                 mov     ecx, [ebp+var_C]
.text$mn:000021F4                 mov     large fs:0, ecx
.text$mn:000021FB                 pop     ecx
.text$mn:000021FC                 mov     esp, ebp
.text$mn:000021FE                 pop     ebp
.text$mn:000021FF                 retn    0Ch
.text$mn:000021FF ?getAttributesPos@XmlMatchedTagsHighlighter@@AAE?AV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@HH@Z endp
.text$mn:000021FF
.text$mn:000021FF ; ---------------------------------------------------------------------------
.text$mn:00002202                 align 4
.text$mn:00002204 $LN38           dd offset $LN25, offset $LN15, offset $LN21, offset $LN8
.text$mn:00002204                                         ; DATA XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+D4r
.text$mn:00002204                                         ; jump table for switch statement
.text$mn:00002214 $LN36           db      0,     0,     3,     3
.text$mn:00002214                                         ; DATA XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+CDr
.text$mn:00002214                 db      0,     3,     3,     3 ; indirect table for switch statement
.text$mn:00002214                 db      3,     3,     3,     3
.text$mn:00002214                 db      3,     3,     3,     3
.text$mn:00002214                 db      3,     3,     3,     3
.text$mn:00002214                 db      3,     3,     3,     0
.text$mn:00002214                 db      3,     1,     3,     3
.text$mn:00002214                 db      3,     3,     3,     3
.text$mn:00002214                 db      3,     3,     3,     3
.text$mn:00002214                 db      3,     3,     3,     3
.text$mn:00002214                 db      3,     3,     3,     3
.text$mn:00002214                 db      3,     3,     3,     3
.text$mn:00002214                 db      3,     3,     3,     3
.text$mn:00002214                 db      2
.text$mn:00002249                 align 4
.text$mn:00002249 _text$mn        ends
.text$mn:00002249
.text$x:0000224C ; ===========================================================================
.text$x:0000224C
.text$x:0000224C ; Segment type: Pure code
.text$x:0000224C ; Segment permissions: Read/Execute
.text$x:0000224C _text$x         segment para public 'CODE' use32
.text$x:0000224C                 assume cs:_text$x
.text$x:0000224C                 ;org 224Ch
.text$x:0000224C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000224C
.text$x:0000224C ; =============== S U B R O U T I N E =======================================
.text$x:0000224C
.text$x:0000224C
.text$x:0000224C __unwindfunclet$?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z$0 proc near
.text$x:0000224C                                         ; DATA XREF: .xdata$x:00006670o
.text$x:0000224C                 lea     ecx, [ebp-44h]
.text$x:0000224F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000224F __unwindfunclet$?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z$0 endp
.text$x:0000224F
.text$x:00002254
.text$x:00002254 ; =============== S U B R O U T I N E =======================================
.text$x:00002254
.text$x:00002254
.text$x:00002254 __unwindfunclet$?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z$1 proc near
.text$x:00002254                                         ; DATA XREF: .xdata$x:00006678o
.text$x:00002254                 lea     ecx, [ebp-60h]
.text$x:00002257                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002257 __unwindfunclet$?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z$1 endp
.text$x:00002257
.text$x:0000225C
.text$x:0000225C ; =============== S U B R O U T I N E =======================================
.text$x:0000225C
.text$x:0000225C
.text$x:0000225C __unwindfunclet$?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z$2 proc near
.text$x:0000225C                                         ; DATA XREF: .xdata$x:00006680o
.text$x:0000225C                 lea     ecx, [ebp-0C4h]
.text$x:00002262                 jmp     ??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::~vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>(void)
.text$x:00002262 __unwindfunclet$?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z$2 endp
.text$x:00002262
.text$x:00002267
.text$x:00002267 ; =============== S U B R O U T I N E =======================================
.text$x:00002267
.text$x:00002267
.text$x:00002267 __ehhandler$?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z proc near
.text$x:00002267                                         ; DATA XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+5o
.text$x:00002267
.text$x:00002267 arg_4           = dword ptr  8
.text$x:00002267
.text$x:00002267                 mov     edx, [esp+arg_4]
.text$x:0000226B                 lea     eax, [edx+0Ch]
.text$x:0000226E                 mov     ecx, [edx-0C0h]
.text$x:00002274                 xor     ecx, eax
.text$x:00002276                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000227B                 mov     ecx, [edx-4]
.text$x:0000227E                 xor     ecx, eax
.text$x:00002280                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002285                 mov     eax, offset __ehfuncinfo$?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z
.text$x:0000228A                 jmp     ___CxxFrameHandler3
.text$x:0000228A __ehhandler$?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z endp
.text$x:0000228A
.text$x:0000228F
.text$x:0000228F ; =============== S U B R O U T I N E =======================================
.text$x:0000228F
.text$x:0000228F
.text$x:0000228F __unwindfunclet$?getXmlMatchedTagsPos@XmlMatchedTagsHighlighter@@AAE_NAAUXmlMatchedTagsPos@1@@Z$0 proc near
.text$x:0000228F                                         ; DATA XREF: .xdata$x:00006660o
.text$x:0000228F                 lea     ecx, [ebp-74h]
.text$x:00002292                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002292 __unwindfunclet$?getXmlMatchedTagsPos@XmlMatchedTagsHighlighter@@AAE_NAAUXmlMatchedTagsPos@1@@Z$0 endp
.text$x:00002292
.text$x:00002297
.text$x:00002297 ; =============== S U B R O U T I N E =======================================
.text$x:00002297
.text$x:00002297
.text$x:00002297 __unwindfunclet$?getXmlMatchedTagsPos@XmlMatchedTagsHighlighter@@AAE_NAAUXmlMatchedTagsPos@1@@Z$1 proc near
.text$x:00002297                                         ; DATA XREF: .xdata$x:00006668o
.text$x:00002297                 lea     ecx, [ebp-9Ch]
.text$x:0000229D                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000229D __unwindfunclet$?getXmlMatchedTagsPos@XmlMatchedTagsHighlighter@@AAE_NAAUXmlMatchedTagsPos@1@@Z$1 endp
.text$x:0000229D
.text$x:000022A2
.text$x:000022A2 ; =============== S U B R O U T I N E =======================================
.text$x:000022A2
.text$x:000022A2
.text$x:000022A2 __ehhandler$?getXmlMatchedTagsPos@XmlMatchedTagsHighlighter@@AAE_NAAUXmlMatchedTagsPos@1@@Z proc near
.text$x:000022A2                                         ; DATA XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+5o
.text$x:000022A2
.text$x:000022A2 arg_4           = dword ptr  8
.text$x:000022A2
.text$x:000022A2                 mov     edx, [esp+arg_4]
.text$x:000022A6                 lea     eax, [edx+0Ch]
.text$x:000022A9                 mov     ecx, [edx-130h]
.text$x:000022AF                 xor     ecx, eax
.text$x:000022B1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000022B6                 mov     ecx, [edx-4]
.text$x:000022B9                 xor     ecx, eax
.text$x:000022BB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000022C0                 mov     eax, offset __ehfuncinfo$?getXmlMatchedTagsPos@XmlMatchedTagsHighlighter@@AAE_NAAUXmlMatchedTagsPos@1@@Z
.text$x:000022C5                 jmp     ___CxxFrameHandler3
.text$x:000022C5 __ehhandler$?getXmlMatchedTagsPos@XmlMatchedTagsHighlighter@@AAE_NAAUXmlMatchedTagsPos@1@@Z endp
.text$x:000022C5
.text$x:000022CA
.text$x:000022CA ; =============== S U B R O U T I N E =======================================
.text$x:000022CA
.text$x:000022CA
.text$x:000022CA __unwindfunclet$?findOpenTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z$0 proc near
.text$x:000022CA                                         ; DATA XREF: .xdata$x:00006648o
.text$x:000022CA                 lea     ecx, [ebp-44h]
.text$x:000022CD                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000022CD __unwindfunclet$?findOpenTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z$0 endp
.text$x:000022CD
.text$x:000022D2
.text$x:000022D2 ; =============== S U B R O U T I N E =======================================
.text$x:000022D2
.text$x:000022D2
.text$x:000022D2 __ehhandler$?findOpenTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z proc near
.text$x:000022D2                                         ; DATA XREF: XmlMatchedTagsHighlighter::findOpenTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+5o
.text$x:000022D2
.text$x:000022D2 arg_4           = dword ptr  8
.text$x:000022D2
.text$x:000022D2                 mov     edx, [esp+arg_4]
.text$x:000022D6                 lea     eax, [edx+0Ch]
.text$x:000022D9                 mov     ecx, [edx-6Ch]
.text$x:000022DC                 xor     ecx, eax
.text$x:000022DE                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000022E3                 mov     ecx, [edx-4]
.text$x:000022E6                 xor     ecx, eax
.text$x:000022E8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000022ED                 mov     eax, offset __ehfuncinfo$?findOpenTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z
.text$x:000022F2                 jmp     ___CxxFrameHandler3
.text$x:000022F2 __ehhandler$?findOpenTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z endp
.text$x:000022F2
.text$x:000022F7
.text$x:000022F7 ; =============== S U B R O U T I N E =======================================
.text$x:000022F7
.text$x:000022F7
.text$x:000022F7 __unwindfunclet$?findCloseTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z$0 proc near
.text$x:000022F7                                         ; DATA XREF: .xdata$x:00006640o
.text$x:000022F7                 lea     ecx, [ebp-44h]
.text$x:000022FA                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000022FA __unwindfunclet$?findCloseTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z$0 endp
.text$x:000022FA
.text$x:000022FF
.text$x:000022FF ; =============== S U B R O U T I N E =======================================
.text$x:000022FF
.text$x:000022FF
.text$x:000022FF __ehhandler$?findCloseTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z proc near
.text$x:000022FF                                         ; DATA XREF: XmlMatchedTagsHighlighter::findCloseTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+5o
.text$x:000022FF
.text$x:000022FF arg_4           = dword ptr  8
.text$x:000022FF
.text$x:000022FF                 mov     edx, [esp+arg_4]
.text$x:00002303                 lea     eax, [edx+0Ch]
.text$x:00002306                 mov     ecx, [edx-68h]
.text$x:00002309                 xor     ecx, eax
.text$x:0000230B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002310                 mov     ecx, [edx-4]
.text$x:00002313                 xor     ecx, eax
.text$x:00002315                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000231A                 mov     eax, offset __ehfuncinfo$?findCloseTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z
.text$x:0000231F                 jmp     ___CxxFrameHandler3
.text$x:0000231F __ehhandler$?findCloseTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z endp
.text$x:0000231F
.text$x:00002324
.text$x:00002324 ; =============== S U B R O U T I N E =======================================
.text$x:00002324
.text$x:00002324
.text$x:00002324 __unwindfunclet$?getAttributesPos@XmlMatchedTagsHighlighter@@AAE?AV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@HH@Z$0 proc near
.text$x:00002324                                         ; DATA XREF: .xdata$x:00006658o
.text$x:00002324                 lea     ecx, [ebp-68h]
.text$x:00002327                 jmp     ??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::~vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>(void)
.text$x:00002327 __unwindfunclet$?getAttributesPos@XmlMatchedTagsHighlighter@@AAE?AV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@HH@Z$0 endp
.text$x:00002327
.text$x:0000232C
.text$x:0000232C ; =============== S U B R O U T I N E =======================================
.text$x:0000232C
.text$x:0000232C
.text$x:0000232C __unwindfunclet$?getAttributesPos@XmlMatchedTagsHighlighter@@AAE?AV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@HH@Z$1 proc near
.text$x:0000232C                                         ; DATA XREF: .xdata$x:00006650o
.text$x:0000232C                 mov     eax, [ebp-2Ch]
.text$x:0000232F                 and     eax, 1
.text$x:00002332                 jz      locret_2344
.text$x:00002338                 and     dword ptr [ebp-2Ch], 0FFFFFFFEh
.text$x:0000233C                 mov     ecx, [ebp+8]
.text$x:0000233F                 jmp     ??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::~vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>(void)
.text$x:00002344 ; ---------------------------------------------------------------------------
.text$x:00002344
.text$x:00002344 locret_2344:                            ; CODE XREF: __unwindfunclet$?getAttributesPos@XmlMatchedTagsHighlighter@@AAE?AV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@HH@Z$1+6j
.text$x:00002344                 retn
.text$x:00002344 __unwindfunclet$?getAttributesPos@XmlMatchedTagsHighlighter@@AAE?AV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@HH@Z$1 endp
.text$x:00002344
.text$x:00002345
.text$x:00002345 ; =============== S U B R O U T I N E =======================================
.text$x:00002345
.text$x:00002345
.text$x:00002345 __ehhandler$?getAttributesPos@XmlMatchedTagsHighlighter@@AAE?AV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@HH@Z proc near
.text$x:00002345                                         ; DATA XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+5o
.text$x:00002345
.text$x:00002345 arg_4           = dword ptr  8
.text$x:00002345
.text$x:00002345                 mov     edx, [esp+arg_4]
.text$x:00002349                 lea     eax, [edx+0Ch]
.text$x:0000234C                 mov     ecx, [edx-60h]
.text$x:0000234F                 xor     ecx, eax
.text$x:00002351                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002356                 mov     eax, offset __ehfuncinfo$?getAttributesPos@XmlMatchedTagsHighlighter@@AAE?AV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@HH@Z
.text$x:0000235B                 jmp     ___CxxFrameHandler3
.text$x:0000235B __ehhandler$?getAttributesPos@XmlMatchedTagsHighlighter@@AAE?AV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@HH@Z endp
.text$x:0000235B
.text$x:0000235B _text$x         ends
.text$x:0000235B
.text$mn:00002360 ; ===========================================================================
.text$mn:00002360
.text$mn:00002360 ; Segment type: Pure code
.text$mn:00002360 ; Segment permissions: Read/Execute
.text$mn:00002360 _text$mn        segment para public 'CODE' use32
.text$mn:00002360                 assume cs:_text$mn
.text$mn:00002360                 ;org 2360h
.text$mn:00002360 ; COMDAT (pick any)
.text$mn:00002360                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002360
.text$mn:00002360 ; =============== S U B R O U T I N E =======================================
.text$mn:00002360
.text$mn:00002360 ; Attributes: bp-based frame
.text$mn:00002360
.text$mn:00002360 ; public: __thiscall std::pair<int, int>::pair<int, int>(int &&, int &&)
.text$mn:00002360                 public ??$?0HHX@?$pair@HH@std@@QAE@$$QAH0@Z
.text$mn:00002360 ??$?0HHX@?$pair@HH@std@@QAE@$$QAH0@Z proc near
.text$mn:00002360                                         ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+1C4p
.text$mn:00002360                                         ; XmlMatchedTagsHighlighter::getAttributesPos(int,int)+205p
.text$mn:00002360
.text$mn:00002360 var_4           = dword ptr -4
.text$mn:00002360 arg_0           = dword ptr  8
.text$mn:00002360 arg_4           = dword ptr  0Ch
.text$mn:00002360
.text$mn:00002360                 push    ebp
.text$mn:00002361                 mov     ebp, esp
.text$mn:00002363                 push    ecx
.text$mn:00002364                 mov     [ebp+var_4], ecx
.text$mn:00002367                 mov     eax, [ebp+arg_0]
.text$mn:0000236A                 push    eax
.text$mn:0000236B                 call    ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>(int &)
.text$mn:00002370                 add     esp, 4
.text$mn:00002373                 mov     ecx, [ebp+var_4]
.text$mn:00002376                 mov     edx, [eax]
.text$mn:00002378                 mov     [ecx], edx
.text$mn:0000237A                 mov     eax, [ebp+arg_4]
.text$mn:0000237D                 push    eax
.text$mn:0000237E                 call    ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>(int &)
.text$mn:00002383                 add     esp, 4
.text$mn:00002386                 mov     ecx, [ebp+var_4]
.text$mn:00002389                 mov     edx, [eax]
.text$mn:0000238B                 mov     [ecx+4], edx
.text$mn:0000238E                 mov     eax, [ebp+var_4]
.text$mn:00002391                 mov     esp, ebp
.text$mn:00002393                 pop     ebp
.text$mn:00002394                 retn    8
.text$mn:00002394 ??$?0HHX@?$pair@HH@std@@QAE@$$QAH0@Z endp
.text$mn:00002394
.text$mn:00002394 ; ---------------------------------------------------------------------------
.text$mn:00002397                 align 4
.text$mn:00002397 _text$mn        ends
.text$mn:00002397
.text$mn:00002398 ; ===========================================================================
.text$mn:00002398
.text$mn:00002398 ; Segment type: Pure code
.text$mn:00002398 ; Segment permissions: Read/Execute
.text$mn:00002398 _text$mn        segment para public 'CODE' use32
.text$mn:00002398                 assume cs:_text$mn
.text$mn:00002398                 ;org 2398h
.text$mn:00002398 ; COMDAT (pick any)
.text$mn:00002398                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002398
.text$mn:00002398 ; =============== S U B R O U T I N E =======================================
.text$mn:00002398
.text$mn:00002398 ; Attributes: bp-based frame
.text$mn:00002398
.text$mn:00002398 ; public: __thiscall std::pair<int, int>::pair<int, int>(struct std::pair<int, int> &&)
.text$mn:00002398                 public ??$?0HHX@?$pair@HH@std@@QAE@$$QAU01@@Z
.text$mn:00002398 ??$?0HHX@?$pair@HH@std@@QAE@$$QAU01@@Z proc near
.text$mn:00002398                                         ; CODE XREF: std::allocator<std::pair<int,int>>::construct<std::pair<int,int>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> &&)+56p
.text$mn:00002398
.text$mn:00002398 var_4           = dword ptr -4
.text$mn:00002398 arg_0           = dword ptr  8
.text$mn:00002398
.text$mn:00002398                 push    ebp
.text$mn:00002399                 mov     ebp, esp
.text$mn:0000239B                 push    ecx
.text$mn:0000239C                 mov     [ebp+var_4], ecx
.text$mn:0000239F                 mov     eax, [ebp+arg_0]
.text$mn:000023A2                 push    eax
.text$mn:000023A3                 call    ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>(int &)
.text$mn:000023A8                 add     esp, 4
.text$mn:000023AB                 mov     ecx, [ebp+var_4]
.text$mn:000023AE                 mov     edx, [eax]
.text$mn:000023B0                 mov     [ecx], edx
.text$mn:000023B2                 mov     eax, [ebp+arg_0]
.text$mn:000023B5                 add     eax, 4
.text$mn:000023B8                 push    eax
.text$mn:000023B9                 call    ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>(int &)
.text$mn:000023BE                 add     esp, 4
.text$mn:000023C1                 mov     ecx, [ebp+var_4]
.text$mn:000023C4                 mov     edx, [eax]
.text$mn:000023C6                 mov     [ecx+4], edx
.text$mn:000023C9                 mov     eax, [ebp+var_4]
.text$mn:000023CC                 mov     esp, ebp
.text$mn:000023CE                 pop     ebp
.text$mn:000023CF                 retn    4
.text$mn:000023CF ??$?0HHX@?$pair@HH@std@@QAE@$$QAU01@@Z endp
.text$mn:000023CF
.text$mn:000023CF ; ---------------------------------------------------------------------------
.text$mn:000023D2                 align 4
.text$mn:000023D2 _text$mn        ends
.text$mn:000023D2
.text$mn:000023D4 ; ===========================================================================
.text$mn:000023D4
.text$mn:000023D4 ; Segment type: Pure code
.text$mn:000023D4 ; Segment permissions: Read/Execute
.text$mn:000023D4 _text$mn        segment para public 'CODE' use32
.text$mn:000023D4                 assume cs:_text$mn
.text$mn:000023D4                 ;org 23D4h
.text$mn:000023D4 ; COMDAT (pick any)
.text$mn:000023D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023D4
.text$mn:000023D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023D4
.text$mn:000023D4 ; Attributes: bp-based frame
.text$mn:000023D4
.text$mn:000023D4 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:000023D4                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:000023D4 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:000023D4                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:000023D4
.text$mn:000023D4 var_4           = dword ptr -4
.text$mn:000023D4 arg_0           = dword ptr  8
.text$mn:000023D4
.text$mn:000023D4                 push    ebp
.text$mn:000023D5                 mov     ebp, esp
.text$mn:000023D7                 push    ecx
.text$mn:000023D8                 mov     [ebp+var_4], 0
.text$mn:000023DF                 cmp     [ebp+arg_0], 0
.text$mn:000023E3                 jnz     short loc_23E7
.text$mn:000023E5                 jmp     short loc_2407
.text$mn:000023E7 ; ---------------------------------------------------------------------------
.text$mn:000023E7
.text$mn:000023E7 loc_23E7:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:000023E7                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:000023EB                 ja      short loc_2402
.text$mn:000023ED                 mov     eax, [ebp+arg_0]
.text$mn:000023F0                 push    eax             ; unsigned int
.text$mn:000023F1                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000023F6                 add     esp, 4
.text$mn:000023F9                 mov     [ebp+var_4], eax
.text$mn:000023FC                 cmp     [ebp+var_4], 0
.text$mn:00002400                 jnz     short loc_2407
.text$mn:00002402
.text$mn:00002402 loc_2402:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:00002402                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002407
.text$mn:00002407 loc_2407:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00002407                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00002407                 mov     eax, [ebp+var_4]
.text$mn:0000240A                 mov     esp, ebp
.text$mn:0000240C                 pop     ebp
.text$mn:0000240D                 retn
.text$mn:0000240D ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:0000240D
.text$mn:0000240D ; ---------------------------------------------------------------------------
.text$mn:0000240E                 align 10h
.text$mn:0000240E _text$mn        ends
.text$mn:0000240E
.text$mn:00002410 ; ===========================================================================
.text$mn:00002410
.text$mn:00002410 ; Segment type: Pure code
.text$mn:00002410 ; Segment permissions: Read/Execute
.text$mn:00002410 _text$mn        segment para public 'CODE' use32
.text$mn:00002410                 assume cs:_text$mn
.text$mn:00002410                 ;org 2410h
.text$mn:00002410 ; COMDAT (pick any)
.text$mn:00002410                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002410
.text$mn:00002410 ; =============== S U B R O U T I N E =======================================
.text$mn:00002410
.text$mn:00002410 ; Attributes: bp-based frame
.text$mn:00002410
.text$mn:00002410 ; struct std::pair<int, int> * __cdecl std::_Allocate<struct std::pair<int, int>>(unsigned int, struct std::pair<int, int> *)
.text$mn:00002410                 public ??$_Allocate@U?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@IPAU10@@Z
.text$mn:00002410 ??$_Allocate@U?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@IPAU10@@Z proc near
.text$mn:00002410                                         ; CODE XREF: std::allocator<std::pair<int,int>>::allocate(uint)+Dp
.text$mn:00002410
.text$mn:00002410 var_4           = dword ptr -4
.text$mn:00002410 arg_0           = dword ptr  8
.text$mn:00002410
.text$mn:00002410                 push    ebp
.text$mn:00002411                 mov     ebp, esp
.text$mn:00002413                 push    ecx
.text$mn:00002414                 mov     [ebp+var_4], 0
.text$mn:0000241B                 cmp     [ebp+arg_0], 0
.text$mn:0000241F                 jnz     short loc_2423
.text$mn:00002421                 jmp     short loc_2449
.text$mn:00002423 ; ---------------------------------------------------------------------------
.text$mn:00002423
.text$mn:00002423 loc_2423:                               ; CODE XREF: std::_Allocate<std::pair<int,int>>(uint,std::pair<int,int> *)+Fj
.text$mn:00002423                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:0000242A                 ja      short loc_2444
.text$mn:0000242C                 mov     eax, [ebp+arg_0]
.text$mn:0000242F                 shl     eax, 3
.text$mn:00002432                 push    eax             ; unsigned int
.text$mn:00002433                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002438                 add     esp, 4
.text$mn:0000243B                 mov     [ebp+var_4], eax
.text$mn:0000243E                 cmp     [ebp+var_4], 0
.text$mn:00002442                 jnz     short loc_2449
.text$mn:00002444
.text$mn:00002444 loc_2444:                               ; CODE XREF: std::_Allocate<std::pair<int,int>>(uint,std::pair<int,int> *)+1Aj
.text$mn:00002444                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002449
.text$mn:00002449 loc_2449:                               ; CODE XREF: std::_Allocate<std::pair<int,int>>(uint,std::pair<int,int> *)+11j
.text$mn:00002449                                         ; std::_Allocate<std::pair<int,int>>(uint,std::pair<int,int> *)+32j
.text$mn:00002449                 mov     eax, [ebp+var_4]
.text$mn:0000244C                 mov     esp, ebp
.text$mn:0000244E                 pop     ebp
.text$mn:0000244F                 retn
.text$mn:0000244F ??$_Allocate@U?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@IPAU10@@Z endp
.text$mn:0000244F
.text$mn:0000244F _text$mn        ends
.text$mn:0000244F
.text$mn:00002450 ; ===========================================================================
.text$mn:00002450
.text$mn:00002450 ; Segment type: Pure code
.text$mn:00002450 ; Segment permissions: Read/Execute
.text$mn:00002450 _text$mn        segment para public 'CODE' use32
.text$mn:00002450                 assume cs:_text$mn
.text$mn:00002450                 ;org 2450h
.text$mn:00002450 ; COMDAT (pick any)
.text$mn:00002450                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002450
.text$mn:00002450 ; =============== S U B R O U T I N E =======================================
.text$mn:00002450
.text$mn:00002450 ; Attributes: bp-based frame
.text$mn:00002450
.text$mn:00002450 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00002450                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00002450 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00002450                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00002450
.text$mn:00002450 var_4           = dword ptr -4
.text$mn:00002450 arg_0           = dword ptr  8
.text$mn:00002450
.text$mn:00002450                 push    ebp
.text$mn:00002451                 mov     ebp, esp
.text$mn:00002453                 push    ecx
.text$mn:00002454                 mov     [ebp+var_4], 0
.text$mn:0000245B                 cmp     [ebp+arg_0], 0
.text$mn:0000245F                 jnz     short loc_2463
.text$mn:00002461                 jmp     short loc_2489
.text$mn:00002463 ; ---------------------------------------------------------------------------
.text$mn:00002463
.text$mn:00002463 loc_2463:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:00002463                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:0000246A                 ja      short loc_2484
.text$mn:0000246C                 mov     eax, [ebp+arg_0]
.text$mn:0000246F                 shl     eax, 3
.text$mn:00002472                 push    eax             ; unsigned int
.text$mn:00002473                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002478                 add     esp, 4
.text$mn:0000247B                 mov     [ebp+var_4], eax
.text$mn:0000247E                 cmp     [ebp+var_4], 0
.text$mn:00002482                 jnz     short loc_2489
.text$mn:00002484
.text$mn:00002484 loc_2484:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00002484                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002489
.text$mn:00002489 loc_2489:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00002489                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00002489                 mov     eax, [ebp+var_4]
.text$mn:0000248C                 mov     esp, ebp
.text$mn:0000248E                 pop     ebp
.text$mn:0000248F                 retn
.text$mn:0000248F ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:0000248F
.text$mn:0000248F _text$mn        ends
.text$mn:0000248F
.text$mn:00002490 ; ===========================================================================
.text$mn:00002490
.text$mn:00002490 ; Segment type: Pure code
.text$mn:00002490 ; Segment permissions: Read/Execute
.text$mn:00002490 _text$mn        segment para public 'CODE' use32
.text$mn:00002490                 assume cs:_text$mn
.text$mn:00002490                 ;org 2490h
.text$mn:00002490 ; COMDAT (pick any)
.text$mn:00002490                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002490
.text$mn:00002490 ; =============== S U B R O U T I N E =======================================
.text$mn:00002490
.text$mn:00002490 ; Attributes: bp-based frame
.text$mn:00002490
.text$mn:00002490 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:00002490                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:00002490 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:00002490                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:00002490                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:00002490
.text$mn:00002490 arg_0           = dword ptr  8
.text$mn:00002490 arg_4           = dword ptr  0Ch
.text$mn:00002490 arg_8           = dword ptr  10h
.text$mn:00002490
.text$mn:00002490                 push    ebp
.text$mn:00002491                 mov     ebp, esp
.text$mn:00002493                 cmp     [ebp+arg_0], 0
.text$mn:00002497                 jnz     short loc_24AE
.text$mn:00002499                 mov     eax, [ebp+arg_8]
.text$mn:0000249C                 push    eax             ; unsigned int
.text$mn:0000249D                 mov     ecx, [ebp+arg_4]
.text$mn:000024A0                 push    ecx             ; wchar_t *
.text$mn:000024A1                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000024A6                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000024AB                 add     esp, 0Ch
.text$mn:000024AE
.text$mn:000024AE loc_24AE:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:000024AE                 pop     ebp
.text$mn:000024AF                 retn
.text$mn:000024AF ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:000024AF
.text$mn:000024AF _text$mn        ends
.text$mn:000024AF
.text$mn:000024B0 ; ===========================================================================
.text$mn:000024B0
.text$mn:000024B0 ; Segment type: Pure code
.text$mn:000024B0 ; Segment permissions: Read/Execute
.text$mn:000024B0 _text$mn        segment para public 'CODE' use32
.text$mn:000024B0                 assume cs:_text$mn
.text$mn:000024B0                 ;org 24B0h
.text$mn:000024B0 ; COMDAT (pick any)
.text$mn:000024B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000024B0
.text$mn:000024B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000024B0
.text$mn:000024B0 ; Attributes: bp-based frame
.text$mn:000024B0
.text$mn:000024B0 ; int __cdecl std::_Debug_pointer<std::pair<int,int>>(int, wchar_t *, unsigned int)
.text$mn:000024B0                 public ??$_Debug_pointer@U?$pair@HH@std@@@std@@YAXPAU?$pair@HH@0@PB_WI@Z
.text$mn:000024B0 ??$_Debug_pointer@U?$pair@HH@std@@@std@@YAXPAU?$pair@HH@0@PB_WI@Z proc near
.text$mn:000024B0                                         ; CODE XREF: std::_Debug_range2<std::pair<int,int> *>(std::pair<int,int> *,std::pair<int,int> *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:000024B0                                         ; std::_Debug_range2<std::pair<int,int> *>(std::pair<int,int> *,std::pair<int,int> *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:000024B0
.text$mn:000024B0 arg_0           = dword ptr  8
.text$mn:000024B0 arg_4           = dword ptr  0Ch
.text$mn:000024B0 arg_8           = dword ptr  10h
.text$mn:000024B0
.text$mn:000024B0                 push    ebp
.text$mn:000024B1                 mov     ebp, esp
.text$mn:000024B3                 cmp     [ebp+arg_0], 0
.text$mn:000024B7                 jnz     short loc_24CE
.text$mn:000024B9                 mov     eax, [ebp+arg_8]
.text$mn:000024BC                 push    eax             ; unsigned int
.text$mn:000024BD                 mov     ecx, [ebp+arg_4]
.text$mn:000024C0                 push    ecx             ; wchar_t *
.text$mn:000024C1                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000024C6                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000024CB                 add     esp, 0Ch
.text$mn:000024CE
.text$mn:000024CE loc_24CE:                               ; CODE XREF: std::_Debug_pointer<std::pair<int,int>>(std::pair<int,int> *,wchar_t const *,uint)+7j
.text$mn:000024CE                 pop     ebp
.text$mn:000024CF                 retn
.text$mn:000024CF ??$_Debug_pointer@U?$pair@HH@std@@@std@@YAXPAU?$pair@HH@0@PB_WI@Z endp
.text$mn:000024CF
.text$mn:000024CF _text$mn        ends
.text$mn:000024CF
.text$mn:000024D0 ; ===========================================================================
.text$mn:000024D0
.text$mn:000024D0 ; Segment type: Pure code
.text$mn:000024D0 ; Segment permissions: Read/Execute
.text$mn:000024D0 _text$mn        segment para public 'CODE' use32
.text$mn:000024D0                 assume cs:_text$mn
.text$mn:000024D0                 ;org 24D0h
.text$mn:000024D0 ; COMDAT (pick any)
.text$mn:000024D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000024D0
.text$mn:000024D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000024D0
.text$mn:000024D0 ; Attributes: bp-based frame
.text$mn:000024D0
.text$mn:000024D0 ; int __cdecl std::_Debug_range2<std::pair<int,int> *>(int, int, wchar_t *, unsigned int)
.text$mn:000024D0                 public ??$_Debug_range2@PAU?$pair@HH@std@@@std@@YAXPAU?$pair@HH@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:000024D0 ??$_Debug_range2@PAU?$pair@HH@std@@@std@@YAXPAU?$pair@HH@0@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:000024D0                                         ; CODE XREF: std::_Debug_range<std::pair<int,int> *>(std::pair<int,int> *,std::pair<int,int> *,wchar_t const *,uint)+2Ap
.text$mn:000024D0
.text$mn:000024D0 arg_0           = dword ptr  8
.text$mn:000024D0 arg_4           = dword ptr  0Ch
.text$mn:000024D0 arg_8           = dword ptr  10h
.text$mn:000024D0 arg_C           = dword ptr  14h
.text$mn:000024D0
.text$mn:000024D0                 push    ebp
.text$mn:000024D1                 mov     ebp, esp
.text$mn:000024D3                 mov     eax, [ebp+arg_0]
.text$mn:000024D6                 cmp     eax, [ebp+arg_4]
.text$mn:000024D9                 jz      short loc_2520
.text$mn:000024DB                 mov     ecx, [ebp+arg_C]
.text$mn:000024DE                 push    ecx             ; unsigned int
.text$mn:000024DF                 mov     edx, [ebp+arg_8]
.text$mn:000024E2                 push    edx             ; wchar_t *
.text$mn:000024E3                 mov     eax, [ebp+arg_0]
.text$mn:000024E6                 push    eax             ; int
.text$mn:000024E7                 call    ??$_Debug_pointer@U?$pair@HH@std@@@std@@YAXPAU?$pair@HH@0@PB_WI@Z ; std::_Debug_pointer<std::pair<int,int>>(std::pair<int,int> *,wchar_t const *,uint)
.text$mn:000024EC                 add     esp, 0Ch
.text$mn:000024EF                 mov     ecx, [ebp+arg_C]
.text$mn:000024F2                 push    ecx             ; unsigned int
.text$mn:000024F3                 mov     edx, [ebp+arg_8]
.text$mn:000024F6                 push    edx             ; wchar_t *
.text$mn:000024F7                 mov     eax, [ebp+arg_4]
.text$mn:000024FA                 push    eax             ; int
.text$mn:000024FB                 call    ??$_Debug_pointer@U?$pair@HH@std@@@std@@YAXPAU?$pair@HH@0@PB_WI@Z ; std::_Debug_pointer<std::pair<int,int>>(std::pair<int,int> *,wchar_t const *,uint)
.text$mn:00002500                 add     esp, 0Ch
.text$mn:00002503                 mov     ecx, [ebp+arg_4]
.text$mn:00002506                 cmp     ecx, [ebp+arg_0]
.text$mn:00002509                 jnb     short loc_2520
.text$mn:0000250B                 mov     edx, [ebp+arg_C]
.text$mn:0000250E                 push    edx             ; unsigned int
.text$mn:0000250F                 mov     eax, [ebp+arg_8]
.text$mn:00002512                 push    eax             ; wchar_t *
.text$mn:00002513                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00002518                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000251D                 add     esp, 0Ch
.text$mn:00002520
.text$mn:00002520 loc_2520:                               ; CODE XREF: std::_Debug_range2<std::pair<int,int> *>(std::pair<int,int> *,std::pair<int,int> *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00002520                                         ; std::_Debug_range2<std::pair<int,int> *>(std::pair<int,int> *,std::pair<int,int> *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00002520                 pop     ebp
.text$mn:00002521                 retn
.text$mn:00002521 ??$_Debug_range2@PAU?$pair@HH@std@@@std@@YAXPAU?$pair@HH@0@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00002521
.text$mn:00002521 ; ---------------------------------------------------------------------------
.text$mn:00002522                 align 4
.text$mn:00002522 _text$mn        ends
.text$mn:00002522
.text$mn:00002524 ; ===========================================================================
.text$mn:00002524
.text$mn:00002524 ; Segment type: Pure code
.text$mn:00002524 ; Segment permissions: Read/Execute
.text$mn:00002524 _text$mn        segment para public 'CODE' use32
.text$mn:00002524                 assume cs:_text$mn
.text$mn:00002524                 ;org 2524h
.text$mn:00002524 ; COMDAT (pick any)
.text$mn:00002524                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002524
.text$mn:00002524 ; =============== S U B R O U T I N E =======================================
.text$mn:00002524
.text$mn:00002524 ; Attributes: bp-based frame
.text$mn:00002524
.text$mn:00002524 ; int __cdecl std::_Debug_range<std::pair<int,int> *>(int, int, wchar_t *, unsigned int)
.text$mn:00002524                 public ??$_Debug_range@PAU?$pair@HH@std@@@std@@YAXPAU?$pair@HH@0@0PB_WI@Z
.text$mn:00002524 ??$_Debug_range@PAU?$pair@HH@std@@@std@@YAXPAU?$pair@HH@0@0PB_WI@Z proc near
.text$mn:00002524                                         ; CODE XREF: std::_Uninit_move<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int>>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &,std::pair<int,int> *,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:00002524
.text$mn:00002524 var_1           = byte ptr -1
.text$mn:00002524 arg_0           = dword ptr  8
.text$mn:00002524 arg_4           = dword ptr  0Ch
.text$mn:00002524 arg_8           = dword ptr  10h
.text$mn:00002524 arg_C           = dword ptr  14h
.text$mn:00002524
.text$mn:00002524                 push    ebp
.text$mn:00002525                 mov     ebp, esp
.text$mn:00002527                 push    ecx
.text$mn:00002528                 lea     eax, [ebp+arg_0]
.text$mn:0000252B                 push    eax
.text$mn:0000252C                 lea     ecx, [ebp+var_1]
.text$mn:0000252F                 push    ecx
.text$mn:00002530                 call    ??$_Iter_cat@PAU?$pair@HH@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@HH@0@@Z ; std::_Iter_cat<std::pair<int,int> *>(std::pair<int,int> * const &)
.text$mn:00002535                 add     esp, 8
.text$mn:00002538                 mov     dl, [eax]
.text$mn:0000253A
.text$mn:0000253A loc_253A:                               ; DATA XREF: .rdata:$SG152751o
.text$mn:0000253A                 movzx   eax, dl
.text$mn:0000253D                 push    eax
.text$mn:0000253E                 mov     ecx, [ebp+arg_C]
.text$mn:00002541                 push    ecx             ; unsigned int
.text$mn:00002542                 mov     edx, [ebp+arg_8]
.text$mn:00002545                 push    edx             ; wchar_t *
.text$mn:00002546                 mov     eax, [ebp+arg_4]
.text$mn:00002549                 push    eax             ; int
.text$mn:0000254A                 mov     ecx, [ebp+arg_0]
.text$mn:0000254D                 push    ecx             ; int
.text$mn:0000254E                 call    ??$_Debug_range2@PAU?$pair@HH@std@@@std@@YAXPAU?$pair@HH@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::pair<int,int> *>(std::pair<int,int> *,std::pair<int,int> *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00002553                 add     esp, 14h
.text$mn:00002556                 mov     esp, ebp
.text$mn:00002558                 pop     ebp
.text$mn:00002559                 retn
.text$mn:00002559 ??$_Debug_range@PAU?$pair@HH@std@@@std@@YAXPAU?$pair@HH@0@0PB_WI@Z endp
.text$mn:00002559
.text$mn:00002559 ; ---------------------------------------------------------------------------
.text$mn:0000255A                 align 4
.text$mn:0000255A _text$mn        ends
.text$mn:0000255A
.text$mn:0000255C ; ===========================================================================
.text$mn:0000255C
.text$mn:0000255C ; Segment type: Pure code
.text$mn:0000255C ; Segment permissions: Read/Execute
.text$mn:0000255C _text$mn        segment para public 'CODE' use32
.text$mn:0000255C                 assume cs:_text$mn
.text$mn:0000255C                 ;org 255Ch
.text$mn:0000255C ; COMDAT (pick any)
.text$mn:0000255C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000255C
.text$mn:0000255C ; =============== S U B R O U T I N E =======================================
.text$mn:0000255C
.text$mn:0000255C ; Attributes: bp-based frame
.text$mn:0000255C
.text$mn:0000255C ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct std::pair<int, int>>>>(struct std::pair<int, int> *, struct std::pair<int, int> *, struct std::_Wrap_alloc<class std::allocator<struct std::pair<int, int>>> &)
.text$mn:0000255C                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@@std@@YAXPAU?$pair@HH@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@@Z
.text$mn:0000255C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@@std@@YAXPAU?$pair@HH@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@@Z proc near
.text$mn:0000255C                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Destroy(std::pair<int,int> *,std::pair<int,int> *)+21p
.text$mn:0000255C
.text$mn:0000255C var_1           = byte ptr -1
.text$mn:0000255C arg_0           = dword ptr  8
.text$mn:0000255C arg_4           = dword ptr  0Ch
.text$mn:0000255C arg_8           = dword ptr  10h
.text$mn:0000255C
.text$mn:0000255C                 push    ebp
.text$mn:0000255D                 mov     ebp, esp
.text$mn:0000255F                 push    ecx
.text$mn:00002560                 mov     eax, [ebp+arg_4]
.text$mn:00002563                 push    eax
.text$mn:00002564                 mov     ecx, [ebp+arg_0]
.text$mn:00002567                 push    ecx
.text$mn:00002568                 call    ??$_Ptr_cat@U?$pair@HH@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@HH@0@0@Z ; std::_Ptr_cat<std::pair<int,int>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> *)
.text$mn:0000256D                 add     esp, 8
.text$mn:00002570                 mov     [ebp+var_1], al
.text$mn:00002573                 movzx   edx, [ebp+var_1]
.text$mn:00002577                 push    edx
.text$mn:00002578                 mov     eax, [ebp+arg_8]
.text$mn:0000257B                 push    eax
.text$mn:0000257C                 mov     ecx, [ebp+arg_4]
.text$mn:0000257F                 push    ecx
.text$mn:00002580                 mov     edx, [ebp+arg_0]
.text$mn:00002583                 push    edx
.text$mn:00002584                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@@std@@YAXPAU?$pair@HH@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<int,int>>>>(std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002589                 add     esp, 10h
.text$mn:0000258C                 mov     esp, ebp
.text$mn:0000258E                 pop     ebp
.text$mn:0000258F                 retn
.text$mn:0000258F ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@@std@@YAXPAU?$pair@HH@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@@Z endp
.text$mn:0000258F
.text$mn:0000258F _text$mn        ends
.text$mn:0000258F
.text$mn:00002590 ; ===========================================================================
.text$mn:00002590
.text$mn:00002590 ; Segment type: Pure code
.text$mn:00002590 ; Segment permissions: Read/Execute
.text$mn:00002590 _text$mn        segment para public 'CODE' use32
.text$mn:00002590                 assume cs:_text$mn
.text$mn:00002590                 ;org 2590h
.text$mn:00002590 ; COMDAT (pick any)
.text$mn:00002590                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002590
.text$mn:00002590 ; =============== S U B R O U T I N E =======================================
.text$mn:00002590
.text$mn:00002590 ; Attributes: bp-based frame
.text$mn:00002590
.text$mn:00002590 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct std::pair<int, int>>>>(struct std::pair<int, int> *, struct std::pair<int, int> *, struct std::_Wrap_alloc<class std::allocator<struct std::pair<int, int>>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002590                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@@std@@YAXPAU?$pair@HH@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002590 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@@std@@YAXPAU?$pair@HH@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002590                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<int,int>>>>(std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &)+28p
.text$mn:00002590
.text$mn:00002590 arg_0           = dword ptr  8
.text$mn:00002590 arg_4           = dword ptr  0Ch
.text$mn:00002590 arg_8           = dword ptr  10h
.text$mn:00002590
.text$mn:00002590                 push    ebp
.text$mn:00002591                 mov     ebp, esp
.text$mn:00002593                 jmp     short loc_259E
.text$mn:00002595 ; ---------------------------------------------------------------------------
.text$mn:00002595
.text$mn:00002595 loc_2595:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<int,int>>>>(std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:00002595                 mov     eax, [ebp+arg_0]
.text$mn:00002598                 add     eax, 8
.text$mn:0000259B                 mov     [ebp+arg_0], eax
.text$mn:0000259E
.text$mn:0000259E loc_259E:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<int,int>>>>(std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:0000259E                 mov     ecx, [ebp+arg_0]
.text$mn:000025A1                 cmp     ecx, [ebp+arg_4]
.text$mn:000025A4                 jz      short loc_25B4
.text$mn:000025A6                 mov     edx, [ebp+arg_0]
.text$mn:000025A9                 push    edx
.text$mn:000025AA                 mov     ecx, [ebp+arg_8]
.text$mn:000025AD                 call    ??$destroy@U?$pair@HH@std@@@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAEXPAU?$pair@HH@1@@Z ; std::_Wrap_alloc<std::allocator<std::pair<int,int>>>::destroy<std::pair<int,int>>(std::pair<int,int> *)
.text$mn:000025B2                 jmp     short loc_2595
.text$mn:000025B4 ; ---------------------------------------------------------------------------
.text$mn:000025B4
.text$mn:000025B4 loc_25B4:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<int,int>>>>(std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:000025B4                 pop     ebp
.text$mn:000025B5                 retn
.text$mn:000025B5 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@@std@@YAXPAU?$pair@HH@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:000025B5
.text$mn:000025B5 ; ---------------------------------------------------------------------------
.text$mn:000025B6                 align 4
.text$mn:000025B6 _text$mn        ends
.text$mn:000025B6
.text$mn:000025B8 ; ===========================================================================
.text$mn:000025B8
.text$mn:000025B8 ; Segment type: Pure code
.text$mn:000025B8 ; Segment permissions: Read/Execute
.text$mn:000025B8 _text$mn        segment para public 'CODE' use32
.text$mn:000025B8                 assume cs:_text$mn
.text$mn:000025B8                 ;org 25B8h
.text$mn:000025B8 ; COMDAT (pick any)
.text$mn:000025B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000025B8
.text$mn:000025B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000025B8
.text$mn:000025B8 ; Attributes: bp-based frame
.text$mn:000025B8
.text$mn:000025B8 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct std::pair<int, int> *>(struct std::pair<int, int> * const &)
.text$mn:000025B8                 public ??$_Iter_cat@PAU?$pair@HH@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@HH@0@@Z
.text$mn:000025B8 ??$_Iter_cat@PAU?$pair@HH@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@HH@0@@Z proc near
.text$mn:000025B8                                         ; CODE XREF: std::_Debug_range<std::pair<int,int> *>(std::pair<int,int> *,std::pair<int,int> *,wchar_t const *,uint)+Cp
.text$mn:000025B8
.text$mn:000025B8 var_1           = byte ptr -1
.text$mn:000025B8 arg_0           = dword ptr  8
.text$mn:000025B8
.text$mn:000025B8                 push    ebp
.text$mn:000025B9                 mov     ebp, esp
.text$mn:000025BB                 push    ecx
.text$mn:000025BC                 mov     eax, [ebp+arg_0]
.text$mn:000025BF                 mov     cl, [ebp+var_1]
.text$mn:000025C2                 mov     [eax], cl
.text$mn:000025C4                 mov     eax, [ebp+arg_0]
.text$mn:000025C7                 mov     esp, ebp
.text$mn:000025C9                 pop     ebp
.text$mn:000025CA                 retn
.text$mn:000025CA ??$_Iter_cat@PAU?$pair@HH@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@HH@0@@Z endp
.text$mn:000025CA
.text$mn:000025CA ; ---------------------------------------------------------------------------
.text$mn:000025CB                 align 4
.text$mn:000025CB _text$mn        ends
.text$mn:000025CB
.text$mn:000025CC ; ===========================================================================
.text$mn:000025CC
.text$mn:000025CC ; Segment type: Pure code
.text$mn:000025CC ; Segment permissions: Read/Execute
.text$mn:000025CC _text$mn        segment para public 'CODE' use32
.text$mn:000025CC                 assume cs:_text$mn
.text$mn:000025CC                 ;org 25CCh
.text$mn:000025CC ; COMDAT (pick any)
.text$mn:000025CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000025CC
.text$mn:000025CC ; =============== S U B R O U T I N E =======================================
.text$mn:000025CC
.text$mn:000025CC ; Attributes: bp-based frame
.text$mn:000025CC
.text$mn:000025CC ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct std::pair<int, int>, struct std::pair<int, int>>(struct std::pair<int, int> *, struct std::pair<int, int> *)
.text$mn:000025CC                 public ??$_Ptr_cat@U?$pair@HH@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@HH@0@0@Z
.text$mn:000025CC ??$_Ptr_cat@U?$pair@HH@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@HH@0@0@Z proc near
.text$mn:000025CC                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<int,int>>>>(std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &)+Cp
.text$mn:000025CC                                         ; std::_Uninit_move<std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>>>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &)+Cp
.text$mn:000025CC
.text$mn:000025CC var_1           = byte ptr -1
.text$mn:000025CC
.text$mn:000025CC                 push    ebp
.text$mn:000025CD                 mov     ebp, esp
.text$mn:000025CF                 push    ecx
.text$mn:000025D0                 mov     al, [ebp+var_1]
.text$mn:000025D3                 mov     esp, ebp
.text$mn:000025D5                 pop     ebp
.text$mn:000025D6                 retn
.text$mn:000025D6 ??$_Ptr_cat@U?$pair@HH@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@HH@0@0@Z endp
.text$mn:000025D6
.text$mn:000025D6 ; ---------------------------------------------------------------------------
.text$mn:000025D7                 align 4
.text$mn:000025D7 _text$mn        ends
.text$mn:000025D7
.text$mn:000025D8 ; ===========================================================================
.text$mn:000025D8
.text$mn:000025D8 ; Segment type: Pure code
.text$mn:000025D8 ; Segment permissions: Read/Execute
.text$mn:000025D8 _text$mn        segment para public 'CODE' use32
.text$mn:000025D8                 assume cs:_text$mn
.text$mn:000025D8                 ;org 25D8h
.text$mn:000025D8 ; COMDAT (pick any)
.text$mn:000025D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000025D8
.text$mn:000025D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000025D8
.text$mn:000025D8 ; Attributes: bp-based frame
.text$mn:000025D8
.text$mn:000025D8 ; struct std::pair<int, int> * & __cdecl std::_Rechecked<struct std::pair<int, int> *, struct std::pair<int, int> *>(struct std::pair<int, int> * &, struct std::pair<int, int> *)
.text$mn:000025D8                 public ??$_Rechecked@PAU?$pair@HH@std@@PAU12@@std@@YAAAPAU?$pair@HH@0@AAPAU10@PAU10@@Z
.text$mn:000025D8 ??$_Rechecked@PAU?$pair@HH@std@@PAU12@@std@@YAAAPAU?$pair@HH@0@AAPAU10@PAU10@@Z proc near
.text$mn:000025D8                                         ; CODE XREF: std::_Uninitialized_move<std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>>>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &)+3Bp
.text$mn:000025D8
.text$mn:000025D8 arg_0           = dword ptr  8
.text$mn:000025D8 arg_4           = dword ptr  0Ch
.text$mn:000025D8
.text$mn:000025D8                 push    ebp
.text$mn:000025D9                 mov     ebp, esp
.text$mn:000025DB                 mov     eax, [ebp+arg_0]
.text$mn:000025DE                 mov     ecx, [ebp+arg_4]
.text$mn:000025E1                 mov     [eax], ecx
.text$mn:000025E3                 mov     eax, [ebp+arg_0]
.text$mn:000025E6                 pop     ebp
.text$mn:000025E7                 retn
.text$mn:000025E7 ??$_Rechecked@PAU?$pair@HH@std@@PAU12@@std@@YAAAPAU?$pair@HH@0@AAPAU10@PAU10@@Z endp
.text$mn:000025E7
.text$mn:000025E7 _text$mn        ends
.text$mn:000025E7
.text$mn:000025E8 ; ===========================================================================
.text$mn:000025E8
.text$mn:000025E8 ; Segment type: Pure code
.text$mn:000025E8 ; Segment permissions: Read/Execute
.text$mn:000025E8 _text$mn        segment para public 'CODE' use32
.text$mn:000025E8                 assume cs:_text$mn
.text$mn:000025E8                 ;org 25E8h
.text$mn:000025E8 ; COMDAT (pick any)
.text$mn:000025E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000025E8
.text$mn:000025E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000025E8
.text$mn:000025E8 ; Attributes: bp-based frame
.text$mn:000025E8
.text$mn:000025E8 ; protected: struct std::pair<int, int> * __thiscall std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>::_Umove<struct std::pair<int, int> *>(struct std::pair<int, int> *, struct std::pair<int, int> *, struct std::pair<int, int> *)
.text$mn:000025E8                 public ??$_Umove@PAU?$pair@HH@std@@@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEPAU?$pair@HH@1@PAU21@00@Z
.text$mn:000025E8 ??$_Umove@PAU?$pair@HH@std@@@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEPAU?$pair@HH@1@PAU21@00@Z proc near
.text$mn:000025E8                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Reallocate(uint)+65p
.text$mn:000025E8
.text$mn:000025E8 var_8           = dword ptr -8
.text$mn:000025E8 var_1           = byte ptr -1
.text$mn:000025E8 arg_0           = dword ptr  8
.text$mn:000025E8 arg_4           = dword ptr  0Ch
.text$mn:000025E8 arg_8           = dword ptr  10h
.text$mn:000025E8
.text$mn:000025E8                 push    ebp
.text$mn:000025E9                 mov     ebp, esp
.text$mn:000025EB                 sub     esp, 8
.text$mn:000025EE                 mov     [ebp+var_8], ecx
.text$mn:000025F1                 lea     eax, [ebp+var_1]
.text$mn:000025F4                 push    eax
.text$mn:000025F5                 mov     ecx, [ebp+var_8]
.text$mn:000025F8                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Getal(void)
.text$mn:000025FD                 lea     ecx, [ebp+var_1]
.text$mn:00002600                 push    ecx
.text$mn:00002601                 mov     edx, [ebp+arg_8]
.text$mn:00002604                 push    edx
.text$mn:00002605                 mov     eax, [ebp+arg_4]
.text$mn:00002608                 push    eax
.text$mn:00002609                 mov     ecx, [ebp+arg_0]
.text$mn:0000260C                 push    ecx
.text$mn:0000260D                 call    ??$_Uninitialized_move@PAU?$pair@HH@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>>>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &)
.text$mn:00002612                 add     esp, 10h
.text$mn:00002615                 mov     esp, ebp
.text$mn:00002617                 pop     ebp
.text$mn:00002618                 retn    0Ch
.text$mn:00002618 ??$_Umove@PAU?$pair@HH@std@@@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEPAU?$pair@HH@1@PAU21@00@Z endp
.text$mn:00002618
.text$mn:00002618 ; ---------------------------------------------------------------------------
.text$mn:0000261B                 align 4
.text$mn:0000261B _text$mn        ends
.text$mn:0000261B
.text$mn:0000261C ; ===========================================================================
.text$mn:0000261C
.text$mn:0000261C ; Segment type: Pure code
.text$mn:0000261C ; Segment permissions: Read/Execute
.text$mn:0000261C _text$mn        segment para public 'CODE' use32
.text$mn:0000261C                 assume cs:_text$mn
.text$mn:0000261C                 ;org 261Ch
.text$mn:0000261C ; COMDAT (pick any)
.text$mn:0000261C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000261C
.text$mn:0000261C ; =============== S U B R O U T I N E =======================================
.text$mn:0000261C
.text$mn:0000261C ; Attributes: bp-based frame
.text$mn:0000261C
.text$mn:0000261C ; struct std::pair<int, int> * __cdecl std::_Unchecked<struct std::pair<int, int> *>(struct std::pair<int, int> *)
.text$mn:0000261C                 public ??$_Unchecked@PAU?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@PAU10@@Z
.text$mn:0000261C ??$_Unchecked@PAU?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@PAU10@@Z proc near
.text$mn:0000261C                                         ; CODE XREF: std::_Uninitialized_move<std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>>>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &)+Bp
.text$mn:0000261C                                         ; std::_Uninitialized_move<std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>>>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &)+18p ...
.text$mn:0000261C
.text$mn:0000261C arg_0           = dword ptr  8
.text$mn:0000261C
.text$mn:0000261C                 push    ebp
.text$mn:0000261D                 mov     ebp, esp
.text$mn:0000261F                 mov     eax, [ebp+arg_0]
.text$mn:00002622                 pop     ebp
.text$mn:00002623                 retn
.text$mn:00002623 ??$_Unchecked@PAU?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@PAU10@@Z endp
.text$mn:00002623
.text$mn:00002623 _text$mn        ends
.text$mn:00002623
.text$mn:00002624 ; ===========================================================================
.text$mn:00002624
.text$mn:00002624 ; Segment type: Pure code
.text$mn:00002624 ; Segment permissions: Read/Execute
.text$mn:00002624 _text$mn        segment para public 'CODE' use32
.text$mn:00002624                 assume cs:_text$mn
.text$mn:00002624                 ;org 2624h
.text$mn:00002624 ; COMDAT (pick any)
.text$mn:00002624                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002624
.text$mn:00002624 ; =============== S U B R O U T I N E =======================================
.text$mn:00002624
.text$mn:00002624 ; Attributes: bp-based frame
.text$mn:00002624
.text$mn:00002624 ; int __cdecl std::_Uninit_move<std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>>>(int, int, void *, int)
.text$mn:00002624                 public ??$_Uninit_move@PAU?$pair@HH@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@@Z
.text$mn:00002624 ??$_Uninit_move@PAU?$pair@HH@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@@Z proc near
.text$mn:00002624                                         ; CODE XREF: std::_Uninitialized_move<std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>>>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &)+2Ep
.text$mn:00002624
.text$mn:00002624 var_1           = byte ptr -1
.text$mn:00002624 arg_0           = dword ptr  8
.text$mn:00002624 arg_4           = dword ptr  0Ch
.text$mn:00002624 arg_8           = dword ptr  10h
.text$mn:00002624 arg_C           = dword ptr  14h
.text$mn:00002624
.text$mn:00002624                 push    ebp
.text$mn:00002625                 mov     ebp, esp
.text$mn:00002627                 push    ecx
.text$mn:00002628                 mov     eax, [ebp+arg_8]
.text$mn:0000262B                 push    eax
.text$mn:0000262C                 mov     ecx, [ebp+arg_0]
.text$mn:0000262F                 push    ecx
.text$mn:00002630                 call    ??$_Ptr_cat@U?$pair@HH@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@HH@0@0@Z ; std::_Ptr_cat<std::pair<int,int>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> *)
.text$mn:00002635                 add     esp, 8
.text$mn:00002638                 mov     [ebp+var_1], al
.text$mn:0000263B                 movzx   edx, [ebp+var_1]
.text$mn:0000263F                 push    edx
.text$mn:00002640                 mov     eax, [ebp+arg_0]
.text$mn:00002643                 push    eax
.text$mn:00002644                 call    ??$_Val_type@PAU?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@PAU10@@Z ; std::_Val_type<std::pair<int,int> *>(std::pair<int,int> *)
.text$mn:00002649                 add     esp, 4
.text$mn:0000264C                 push    eax
.text$mn:0000264D                 mov     ecx, [ebp+arg_C]
.text$mn:00002650                 push    ecx             ; int
.text$mn:00002651                 mov     edx, [ebp+arg_8]
.text$mn:00002654                 push    edx             ; void *
.text$mn:00002655                 mov     eax, [ebp+arg_4]
.text$mn:00002658                 push    eax             ; int
.text$mn:00002659                 mov     ecx, [ebp+arg_0]
.text$mn:0000265C                 push    ecx             ; int
.text$mn:0000265D                 call    ??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int>>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &,std::pair<int,int> *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002662                 add     esp, 18h
.text$mn:00002665                 mov     esp, ebp
.text$mn:00002667                 pop     ebp
.text$mn:00002668                 retn
.text$mn:00002668 ??$_Uninit_move@PAU?$pair@HH@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@@Z endp
.text$mn:00002668
.text$mn:00002668 ; ---------------------------------------------------------------------------
.text$mn:00002669                 align 4
.text$mn:00002669 _text$mn        ends
.text$mn:00002669
.text$mn:0000266C ; ===========================================================================
.text$mn:0000266C
.text$mn:0000266C ; Segment type: Pure code
.text$mn:0000266C ; Segment permissions: Read/Execute
.text$mn:0000266C _text$mn        segment para public 'CODE' use32
.text$mn:0000266C                 assume cs:_text$mn
.text$mn:0000266C                 ;org 266Ch
.text$mn:0000266C ; COMDAT (pick any)
.text$mn:0000266C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000266C
.text$mn:0000266C ; =============== S U B R O U T I N E =======================================
.text$mn:0000266C
.text$mn:0000266C ; Attributes: bp-based frame
.text$mn:0000266C
.text$mn:0000266C ; int __cdecl std::_Uninit_move<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int>>,std::pair<int,int>>(int, int, void *, int)
.text$mn:0000266C                 public ??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000266C ??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:0000266C                                         ; CODE XREF: std::_Uninit_move<std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>>>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &)+39p
.text$mn:0000266C
.text$mn:0000266C var_14          = dword ptr -14h
.text$mn:0000266C var_10          = dword ptr -10h
.text$mn:0000266C var_C           = dword ptr -0Ch
.text$mn:0000266C var_4           = dword ptr -4
.text$mn:0000266C arg_0           = dword ptr  8
.text$mn:0000266C arg_4           = dword ptr  0Ch
.text$mn:0000266C arg_8           = dword ptr  10h
.text$mn:0000266C arg_C           = dword ptr  14h
.text$mn:0000266C
.text$mn:0000266C ; FUNCTION CHUNK AT .text$mn:00002733 SIZE 00000009 BYTES
.text$mn:0000266C ; FUNCTION CHUNK AT .text$mn:00002743 SIZE 00000015 BYTES
.text$mn:0000266C
.text$mn:0000266C                 push    ebp
.text$mn:0000266D                 mov     ebp, esp
.text$mn:0000266F                 push    0FFFFFFFFh
.text$mn:00002671                 push    offset __ehhandler$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002676                 mov     eax, large fs:0
.text$mn:0000267C                 push    eax
.text$mn:0000267D                 push    ecx
.text$mn:0000267E                 push    ecx
.text$mn:0000267F                 push    ebx
.text$mn:00002680                 push    esi
.text$mn:00002681                 push    edi
.text$mn:00002682                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002687                 xor     eax, ebp
.text$mn:00002689                 push    eax
.text$mn:0000268A                 lea     eax, [ebp+var_C]
.text$mn:0000268D                 mov     large fs:0, eax
.text$mn:00002693                 mov     [ebp+var_10], esp
.text$mn:00002696                 push    1B6h            ; unsigned int
.text$mn:0000269B                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000026A0                 mov     eax, [ebp+arg_4]
.text$mn:000026A3                 push    eax             ; int
.text$mn:000026A4                 mov     ecx, [ebp+arg_0]
.text$mn:000026A7                 push    ecx             ; int
.text$mn:000026A8                 call    ??$_Debug_range@PAU?$pair@HH@std@@@std@@YAXPAU?$pair@HH@0@0PB_WI@Z ; std::_Debug_range<std::pair<int,int> *>(std::pair<int,int> *,std::pair<int,int> *,wchar_t const *,uint)
.text$mn:000026AD                 add     esp, 10h
.text$mn:000026B0                 push    1B7h            ; unsigned int
.text$mn:000026B5                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000026BA                 mov     edx, [ebp+arg_8]
.text$mn:000026BD                 push    edx             ; int
.text$mn:000026BE                 call    ??$_Debug_pointer@U?$pair@HH@std@@@std@@YAXPAU?$pair@HH@0@PB_WI@Z ; std::_Debug_pointer<std::pair<int,int>>(std::pair<int,int> *,wchar_t const *,uint)
.text$mn:000026C3                 add     esp, 0Ch
.text$mn:000026C6                 mov     eax, [ebp+arg_8]
.text$mn:000026C9                 mov     [ebp+var_14], eax
.text$mn:000026CC                 mov     [ebp+var_4], 0
.text$mn:000026D3                 jmp     short loc_26E7
.text$mn:000026D5 ; ---------------------------------------------------------------------------
.text$mn:000026D5
.text$mn:000026D5 loc_26D5:                               ; CODE XREF: std::_Uninit_move<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int>>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &,std::pair<int,int> *,std::_Nonscalar_ptr_iterator_tag)+93j
.text$mn:000026D5                 mov     ecx, [ebp+arg_8]
.text$mn:000026D8                 add     ecx, 8
.text$mn:000026DB                 mov     [ebp+arg_8], ecx
.text$mn:000026DE                 mov     edx, [ebp+arg_0]
.text$mn:000026E1                 add     edx, 8
.text$mn:000026E4                 mov     [ebp+arg_0], edx
.text$mn:000026E7
.text$mn:000026E7 loc_26E7:                               ; CODE XREF: std::_Uninit_move<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int>>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &,std::pair<int,int> *,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:000026E7                 mov     eax, [ebp+arg_0]
.text$mn:000026EA                 cmp     eax, [ebp+arg_4]
.text$mn:000026ED                 jz      short loc_2701
.text$mn:000026EF                 mov     ecx, [ebp+arg_0]
.text$mn:000026F2                 push    ecx             ; int
.text$mn:000026F3                 mov     edx, [ebp+arg_8]
.text$mn:000026F6                 push    edx             ; void *
.text$mn:000026F7                 mov     ecx, [ebp+arg_C]
.text$mn:000026FA                 call    ??$construct@U?$pair@HH@std@@U12@@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAEXPAU?$pair@HH@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::pair<int,int>>>::construct<std::pair<int,int>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> &&)
.text$mn:000026FF                 jmp     short loc_26D5
.text$mn:00002701 ; ---------------------------------------------------------------------------
.text$mn:00002701
.text$mn:00002701 loc_2701:                               ; CODE XREF: std::_Uninit_move<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int>>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &,std::pair<int,int> *,std::_Nonscalar_ptr_iterator_tag)+81j
.text$mn:00002701                 jmp     short loc_2733
.text$mn:00002701 ??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00002701
.text$mn:00002703
.text$mn:00002703 ; =============== S U B R O U T I N E =======================================
.text$mn:00002703
.text$mn:00002703 ; Attributes: noreturn
.text$mn:00002703
.text$mn:00002703 __catch$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:00002703                                         ; DATA XREF: .xdata$x:00006B40o
.text$mn:00002703                 jmp     short loc_270E
.text$mn:00002705 ; ---------------------------------------------------------------------------
.text$mn:00002705
.text$mn:00002705 loc_2705:                               ; CODE XREF: __catch$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:00002705                 mov     eax, [ebp-14h]
.text$mn:00002708                 add     eax, 8
.text$mn:0000270B                 mov     [ebp-14h], eax
.text$mn:0000270E
.text$mn:0000270E loc_270E:                               ; CODE XREF: __catch$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:0000270E                 mov     ecx, [ebp-14h]
.text$mn:00002711                 cmp     ecx, [ebp+10h]
.text$mn:00002714                 jz      short loc_2724
.text$mn:00002716                 mov     edx, [ebp-14h]
.text$mn:00002719                 push    edx
.text$mn:0000271A                 mov     ecx, [ebp+14h]
.text$mn:0000271D                 call    ??$destroy@U?$pair@HH@std@@@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAEXPAU?$pair@HH@1@@Z ; std::_Wrap_alloc<std::allocator<std::pair<int,int>>>::destroy<std::pair<int,int>>(std::pair<int,int> *)
.text$mn:00002722                 jmp     short loc_2705
.text$mn:00002724 ; ---------------------------------------------------------------------------
.text$mn:00002724
.text$mn:00002724 loc_2724:                               ; CODE XREF: __catch$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:00002724                 push    0
.text$mn:00002726                 push    0
.text$mn:00002728                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00002728 __catch$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:00002728
.text$mn:0000272D ; ---------------------------------------------------------------------------
.text$mn:0000272D                 mov     eax, offset $LN13
.text$mn:00002732                 retn
.text$mn:00002733 ; ---------------------------------------------------------------------------
.text$mn:00002733 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002733
.text$mn:00002733 loc_2733:                               ; CODE XREF: std::_Uninit_move<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int>>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &,std::pair<int,int> *,std::_Nonscalar_ptr_iterator_tag):loc_2701j
.text$mn:00002733                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000273A                 jmp     short loc_2743
.text$mn:0000273A ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000273C
.text$mn:0000273C ; =============== S U B R O U T I N E =======================================
.text$mn:0000273C
.text$mn:0000273C
.text$mn:0000273C $LN13           proc near               ; DATA XREF: .text$mn:0000272Do
.text$mn:0000273C                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000273C $LN13           endp ; sp-analysis failed
.text$mn:0000273C
.text$mn:00002743 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002743
.text$mn:00002743 loc_2743:                               ; CODE XREF: std::_Uninit_move<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int>>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &,std::pair<int,int> *,std::_Nonscalar_ptr_iterator_tag)+CEj
.text$mn:00002743                 mov     eax, [ebp+arg_8]
.text$mn:00002746                 mov     ecx, [ebp+var_C]
.text$mn:00002749                 mov     large fs:0, ecx
.text$mn:00002750                 pop     ecx
.text$mn:00002751                 pop     edi
.text$mn:00002752                 pop     esi
.text$mn:00002753                 pop     ebx
.text$mn:00002754                 mov     esp, ebp
.text$mn:00002756                 pop     ebp
.text$mn:00002757                 retn
.text$mn:00002757 ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002757 _text$mn        ends
.text$mn:00002757
.text$x:00002758 ; ===========================================================================
.text$x:00002758
.text$x:00002758 ; Segment type: Pure code
.text$x:00002758 ; Segment permissions: Read/Execute
.text$x:00002758 _text$x         segment para public 'CODE' use32
.text$x:00002758                 assume cs:_text$x
.text$x:00002758                 ;org 2758h
.text$x:00002758 ; COMDAT (pick associative to section at 266C)
.text$x:00002758                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002758
.text$x:00002758 ; =============== S U B R O U T I N E =======================================
.text$x:00002758
.text$x:00002758
.text$x:00002758 __ehhandler$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:00002758                                         ; DATA XREF: std::_Uninit_move<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int>>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &,std::pair<int,int> *,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:00002758
.text$x:00002758 arg_4           = dword ptr  8
.text$x:00002758
.text$x:00002758                 mov     edx, [esp+arg_4]
.text$x:0000275C                 lea     eax, [edx+0Ch]
.text$x:0000275F                 mov     ecx, [edx-18h]
.text$x:00002762                 xor     ecx, eax
.text$x:00002764                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002769                 mov     eax, offset __ehfuncinfo$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:0000276E                 jmp     ___CxxFrameHandler3
.text$x:0000276E __ehhandler$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:0000276E
.text$x:0000276E ; ---------------------------------------------------------------------------
.text$x:00002773                 align 4
.text$x:00002773 _text$x         ends
.text$x:00002773
.text$mn:00002774 ; ===========================================================================
.text$mn:00002774
.text$mn:00002774 ; Segment type: Pure code
.text$mn:00002774 ; Segment permissions: Read/Execute
.text$mn:00002774 _text$mn        segment para public 'CODE' use32
.text$mn:00002774                 assume cs:_text$mn
.text$mn:00002774                 ;org 2774h
.text$mn:00002774 ; COMDAT (pick any)
.text$mn:00002774                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002774
.text$mn:00002774 ; =============== S U B R O U T I N E =======================================
.text$mn:00002774
.text$mn:00002774 ; Attributes: bp-based frame
.text$mn:00002774
.text$mn:00002774 ; struct std::pair<int, int> * __cdecl std::_Uninitialized_move<struct std::pair<int, int> *, struct std::pair<int, int> *, struct std::_Wrap_alloc<class std::allocator<struct std::pair<int, int>>>>(struct std::pair<int, int> *, struct std::pair<int, int> *, struct std::pair<int, int> *, struct std::_Wrap_alloc<class std::allocator<struct std::pair<int, int>>> &)
.text$mn:00002774                 public ??$_Uninitialized_move@PAU?$pair@HH@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@@Z
.text$mn:00002774 ??$_Uninitialized_move@PAU?$pair@HH@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@@Z proc near
.text$mn:00002774                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Umove<std::pair<int,int> *>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *)+25p
.text$mn:00002774
.text$mn:00002774 arg_0           = dword ptr  8
.text$mn:00002774 arg_4           = dword ptr  0Ch
.text$mn:00002774 arg_8           = dword ptr  10h
.text$mn:00002774 arg_C           = dword ptr  14h
.text$mn:00002774
.text$mn:00002774                 push    ebp
.text$mn:00002775                 mov     ebp, esp
.text$mn:00002777                 mov     eax, [ebp+arg_C]
.text$mn:0000277A                 push    eax             ; int
.text$mn:0000277B                 mov     ecx, [ebp+arg_8]
.text$mn:0000277E                 push    ecx
.text$mn:0000277F                 call    ??$_Unchecked@PAU?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@PAU10@@Z ; std::_Unchecked<std::pair<int,int> *>(std::pair<int,int> *)
.text$mn:00002784                 add     esp, 4
.text$mn:00002787                 push    eax             ; void *
.text$mn:00002788                 mov     edx, [ebp+arg_4]
.text$mn:0000278B                 push    edx
.text$mn:0000278C                 call    ??$_Unchecked@PAU?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@PAU10@@Z ; std::_Unchecked<std::pair<int,int> *>(std::pair<int,int> *)
.text$mn:00002791                 add     esp, 4
.text$mn:00002794                 push    eax             ; int
.text$mn:00002795                 mov     eax, [ebp+arg_0]
.text$mn:00002798                 push    eax
.text$mn:00002799                 call    ??$_Unchecked@PAU?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@PAU10@@Z ; std::_Unchecked<std::pair<int,int> *>(std::pair<int,int> *)
.text$mn:0000279E                 add     esp, 4
.text$mn:000027A1                 push    eax             ; int
.text$mn:000027A2                 call    ??$_Uninit_move@PAU?$pair@HH@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@@Z ; std::_Uninit_move<std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>>>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &)
.text$mn:000027A7                 add     esp, 10h
.text$mn:000027AA                 push    eax
.text$mn:000027AB                 lea     ecx, [ebp+arg_8]
.text$mn:000027AE                 push    ecx
.text$mn:000027AF                 call    ??$_Rechecked@PAU?$pair@HH@std@@PAU12@@std@@YAAAPAU?$pair@HH@0@AAPAU10@PAU10@@Z ; std::_Rechecked<std::pair<int,int> *,std::pair<int,int> *>(std::pair<int,int> * &,std::pair<int,int> *)
.text$mn:000027B4                 add     esp, 8
.text$mn:000027B7                 mov     eax, [eax]
.text$mn:000027B9                 pop     ebp
.text$mn:000027BA                 retn
.text$mn:000027BA ??$_Uninitialized_move@PAU?$pair@HH@std@@PAU12@U?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@2@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@@Z endp
.text$mn:000027BA
.text$mn:000027BA ; ---------------------------------------------------------------------------
.text$mn:000027BB                 align 4
.text$mn:000027BB _text$mn        ends
.text$mn:000027BB
.text$mn:000027BC ; ===========================================================================
.text$mn:000027BC
.text$mn:000027BC ; Segment type: Pure code
.text$mn:000027BC ; Segment permissions: Read/Execute
.text$mn:000027BC _text$mn        segment para public 'CODE' use32
.text$mn:000027BC                 assume cs:_text$mn
.text$mn:000027BC                 ;org 27BCh
.text$mn:000027BC ; COMDAT (pick any)
.text$mn:000027BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027BC
.text$mn:000027BC ; =============== S U B R O U T I N E =======================================
.text$mn:000027BC
.text$mn:000027BC ; Attributes: bp-based frame
.text$mn:000027BC
.text$mn:000027BC ; struct std::pair<int, int> * __cdecl std::_Val_type<struct std::pair<int, int> *>(struct std::pair<int, int> *)
.text$mn:000027BC                 public ??$_Val_type@PAU?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@PAU10@@Z
.text$mn:000027BC ??$_Val_type@PAU?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@PAU10@@Z proc near
.text$mn:000027BC                                         ; CODE XREF: std::_Uninit_move<std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>>>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &)+20p
.text$mn:000027BC                 push    ebp
.text$mn:000027BD                 mov     ebp, esp
.text$mn:000027BF                 xor     eax, eax
.text$mn:000027C1                 pop     ebp
.text$mn:000027C2                 retn
.text$mn:000027C2 ??$_Val_type@PAU?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@PAU10@@Z endp
.text$mn:000027C2
.text$mn:000027C2 ; ---------------------------------------------------------------------------
.text$mn:000027C3                 align 4
.text$mn:000027C3 _text$mn        ends
.text$mn:000027C3
.text$mn:000027C4 ; ===========================================================================
.text$mn:000027C4
.text$mn:000027C4 ; Segment type: Pure code
.text$mn:000027C4 ; Segment permissions: Read/Execute
.text$mn:000027C4 _text$mn        segment para public 'CODE' use32
.text$mn:000027C4                 assume cs:_text$mn
.text$mn:000027C4                 ;org 27C4h
.text$mn:000027C4 ; COMDAT (pick any)
.text$mn:000027C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027C4
.text$mn:000027C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000027C4
.text$mn:000027C4 ; Attributes: bp-based frame
.text$mn:000027C4
.text$mn:000027C4 ; char * __cdecl std::addressof<char>(char &)
.text$mn:000027C4                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:000027C4 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:000027C4                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:000027C4                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:000027C4
.text$mn:000027C4 arg_0           = dword ptr  8
.text$mn:000027C4
.text$mn:000027C4                 push    ebp
.text$mn:000027C5                 mov     ebp, esp
.text$mn:000027C7                 mov     eax, [ebp+arg_0]
.text$mn:000027CA                 pop     ebp
.text$mn:000027CB                 retn
.text$mn:000027CB ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:000027CB
.text$mn:000027CB _text$mn        ends
.text$mn:000027CB
.text$mn:000027CC ; ===========================================================================
.text$mn:000027CC
.text$mn:000027CC ; Segment type: Pure code
.text$mn:000027CC ; Segment permissions: Read/Execute
.text$mn:000027CC _text$mn        segment para public 'CODE' use32
.text$mn:000027CC                 assume cs:_text$mn
.text$mn:000027CC                 ;org 27CCh
.text$mn:000027CC ; COMDAT (pick any)
.text$mn:000027CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027CC
.text$mn:000027CC ; =============== S U B R O U T I N E =======================================
.text$mn:000027CC
.text$mn:000027CC ; Attributes: bp-based frame
.text$mn:000027CC
.text$mn:000027CC ; struct std::pair<int, int> * __cdecl std::addressof<struct std::pair<int, int>>(struct std::pair<int, int> &)
.text$mn:000027CC                 public ??$addressof@U?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@AAU10@@Z
.text$mn:000027CC ??$addressof@U?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@AAU10@@Z proc near
.text$mn:000027CC                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::push_back(std::pair<int,int> &&)+Dp
.text$mn:000027CC                                         ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::push_back(std::pair<int,int> &&)+2Dp
.text$mn:000027CC
.text$mn:000027CC arg_0           = dword ptr  8
.text$mn:000027CC
.text$mn:000027CC                 push    ebp
.text$mn:000027CD                 mov     ebp, esp
.text$mn:000027CF                 mov     eax, [ebp+arg_0]
.text$mn:000027D2                 pop     ebp
.text$mn:000027D3                 retn
.text$mn:000027D3 ??$addressof@U?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@AAU10@@Z endp
.text$mn:000027D3
.text$mn:000027D3 _text$mn        ends
.text$mn:000027D3
.text$mn:000027D4 ; ===========================================================================
.text$mn:000027D4
.text$mn:000027D4 ; Segment type: Pure code
.text$mn:000027D4 ; Segment permissions: Read/Execute
.text$mn:000027D4 _text$mn        segment para public 'CODE' use32
.text$mn:000027D4                 assume cs:_text$mn
.text$mn:000027D4                 ;org 27D4h
.text$mn:000027D4 ; COMDAT (pick any)
.text$mn:000027D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027D4
.text$mn:000027D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000027D4
.text$mn:000027D4 ; Attributes: bp-based frame
.text$mn:000027D4
.text$mn:000027D4 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:000027D4                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:000027D4 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000027D4                                         ; CODE XREF: $LN19+4Bp
.text$mn:000027D4
.text$mn:000027D4 var_4           = dword ptr -4
.text$mn:000027D4 arg_0           = dword ptr  8
.text$mn:000027D4 arg_4           = dword ptr  0Ch
.text$mn:000027D4
.text$mn:000027D4                 push    ebp
.text$mn:000027D5                 mov     ebp, esp
.text$mn:000027D7                 push    ecx
.text$mn:000027D8                 mov     [ebp+var_4], ecx
.text$mn:000027DB                 mov     eax, [ebp+arg_4]
.text$mn:000027DE                 push    eax
.text$mn:000027DF                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000027E4                 add     esp, 4
.text$mn:000027E7                 push    eax             ; int
.text$mn:000027E8                 mov     ecx, [ebp+arg_0]
.text$mn:000027EB                 push    ecx             ; void *
.text$mn:000027EC                 mov     edx, [ebp+var_4]
.text$mn:000027EF                 push    edx             ; int
.text$mn:000027F0                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:000027F5                 add     esp, 0Ch
.text$mn:000027F8                 mov     esp, ebp
.text$mn:000027FA                 pop     ebp
.text$mn:000027FB                 retn    8
.text$mn:000027FB ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000027FB
.text$mn:000027FB ; ---------------------------------------------------------------------------
.text$mn:000027FE                 align 10h
.text$mn:000027FE _text$mn        ends
.text$mn:000027FE
.text$mn:00002800 ; ===========================================================================
.text$mn:00002800
.text$mn:00002800 ; Segment type: Pure code
.text$mn:00002800 ; Segment permissions: Read/Execute
.text$mn:00002800 _text$mn        segment para public 'CODE' use32
.text$mn:00002800                 assume cs:_text$mn
.text$mn:00002800                 ;org 2800h
.text$mn:00002800 ; COMDAT (pick any)
.text$mn:00002800                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002800
.text$mn:00002800 ; =============== S U B R O U T I N E =======================================
.text$mn:00002800
.text$mn:00002800 ; Attributes: bp-based frame
.text$mn:00002800
.text$mn:00002800 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00002800                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00002800 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00002800                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00002800
.text$mn:00002800 var_1C          = dword ptr -1Ch
.text$mn:00002800 var_18          = dword ptr -18h
.text$mn:00002800 var_14          = dword ptr -14h
.text$mn:00002800 var_10          = dword ptr -10h
.text$mn:00002800 var_C           = dword ptr -0Ch
.text$mn:00002800 var_4           = dword ptr -4
.text$mn:00002800 arg_0           = dword ptr  8
.text$mn:00002800 arg_4           = dword ptr  0Ch
.text$mn:00002800
.text$mn:00002800                 push    ebp
.text$mn:00002801                 mov     ebp, esp
.text$mn:00002803                 push    0FFFFFFFFh
.text$mn:00002805                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:0000280A                 mov     eax, large fs:0
.text$mn:00002810                 push    eax
.text$mn:00002811                 sub     esp, 10h
.text$mn:00002814                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002819                 xor     eax, ebp
.text$mn:0000281B                 push    eax
.text$mn:0000281C                 lea     eax, [ebp+var_C]
.text$mn:0000281F                 mov     large fs:0, eax
.text$mn:00002825                 mov     [ebp+var_18], ecx
.text$mn:00002828                 mov     eax, [ebp+arg_0]
.text$mn:0000282B                 push    eax             ; void *
.text$mn:0000282C                 push    4               ; unsigned int
.text$mn:0000282E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00002833                 add     esp, 8
.text$mn:00002836                 mov     [ebp+var_10], eax
.text$mn:00002839                 mov     [ebp+var_4], 0
.text$mn:00002840                 cmp     [ebp+var_10], 0
.text$mn:00002844                 jz      short loc_2861
.text$mn:00002846                 mov     ecx, [ebp+arg_4]
.text$mn:00002849                 push    ecx
.text$mn:0000284A                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000284F                 add     esp, 4
.text$mn:00002852                 mov     edx, [ebp+var_10]
.text$mn:00002855                 mov     eax, [eax]
.text$mn:00002857                 mov     [edx], eax
.text$mn:00002859                 mov     ecx, [ebp+var_10]
.text$mn:0000285C                 mov     [ebp+var_14], ecx
.text$mn:0000285F                 jmp     short loc_2868
.text$mn:00002861 ; ---------------------------------------------------------------------------
.text$mn:00002861
.text$mn:00002861 loc_2861:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00002861                 mov     [ebp+var_14], 0
.text$mn:00002868
.text$mn:00002868 loc_2868:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00002868                 mov     edx, [ebp+var_14]
.text$mn:0000286B                 mov     [ebp+var_1C], edx
.text$mn:0000286E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002875                 mov     ecx, [ebp+var_C]
.text$mn:00002878                 mov     large fs:0, ecx
.text$mn:0000287F                 pop     ecx
.text$mn:00002880                 mov     esp, ebp
.text$mn:00002882                 pop     ebp
.text$mn:00002883                 retn    8
.text$mn:00002883 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00002883
.text$mn:00002883 ; ---------------------------------------------------------------------------
.text$mn:00002886                 align 4
.text$mn:00002886 _text$mn        ends
.text$mn:00002886
.text$x:00002888 ; ===========================================================================
.text$x:00002888
.text$x:00002888 ; Segment type: Pure code
.text$x:00002888 ; Segment permissions: Read/Execute
.text$x:00002888 _text$x         segment para public 'CODE' use32
.text$x:00002888                 assume cs:_text$x
.text$x:00002888                 ;org 2888h
.text$x:00002888 ; COMDAT (pick associative to section at 2800)
.text$x:00002888                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002888
.text$x:00002888 ; =============== S U B R O U T I N E =======================================
.text$x:00002888
.text$x:00002888
.text$x:00002888 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00002888                                         ; DATA XREF: .xdata$x:00006B0Co
.text$x:00002888                 mov     eax, [ebp+8]
.text$x:0000288B                 push    eax
.text$x:0000288C                 mov     eax, [ebp-10h]
.text$x:0000288F                 push    eax             ; void *
.text$x:00002890                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00002895                 add     esp, 8
.text$x:00002898                 retn
.text$x:00002898 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00002898
.text$x:00002899
.text$x:00002899 ; =============== S U B R O U T I N E =======================================
.text$x:00002899
.text$x:00002899
.text$x:00002899 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00002899                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00002899
.text$x:00002899 arg_4           = dword ptr  8
.text$x:00002899
.text$x:00002899                 mov     edx, [esp+arg_4]
.text$x:0000289D                 lea     eax, [edx+0Ch]
.text$x:000028A0                 mov     ecx, [edx-14h]
.text$x:000028A3                 xor     ecx, eax
.text$x:000028A5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000028AA                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:000028AF                 jmp     ___CxxFrameHandler3
.text$x:000028AF __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:000028AF
.text$x:000028AF _text$x         ends
.text$x:000028AF
.text$mn:000028B4 ; ===========================================================================
.text$mn:000028B4
.text$mn:000028B4 ; Segment type: Pure code
.text$mn:000028B4 ; Segment permissions: Read/Execute
.text$mn:000028B4 _text$mn        segment para public 'CODE' use32
.text$mn:000028B4                 assume cs:_text$mn
.text$mn:000028B4                 ;org 28B4h
.text$mn:000028B4 ; COMDAT (pick any)
.text$mn:000028B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000028B4
.text$mn:000028B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000028B4
.text$mn:000028B4 ; Attributes: bp-based frame
.text$mn:000028B4
.text$mn:000028B4 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:000028B4                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:000028B4 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:000028B4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:000028B4
.text$mn:000028B4 arg_0           = dword ptr  8
.text$mn:000028B4 arg_4           = dword ptr  0Ch
.text$mn:000028B4 arg_8           = dword ptr  10h
.text$mn:000028B4
.text$mn:000028B4                 push    ebp
.text$mn:000028B5                 mov     ebp, esp
.text$mn:000028B7                 mov     eax, [ebp+arg_8]
.text$mn:000028BA                 push    eax
.text$mn:000028BB                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000028C0                 add     esp, 4
.text$mn:000028C3                 push    eax             ; int
.text$mn:000028C4                 mov     ecx, [ebp+arg_4]
.text$mn:000028C7                 push    ecx             ; void *
.text$mn:000028C8                 mov     ecx, [ebp+arg_0]
.text$mn:000028CB                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:000028D0                 pop     ebp
.text$mn:000028D1                 retn
.text$mn:000028D1 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:000028D1
.text$mn:000028D1 ; ---------------------------------------------------------------------------
.text$mn:000028D2                 align 4
.text$mn:000028D2 _text$mn        ends
.text$mn:000028D2
.text$mn:000028D4 ; ===========================================================================
.text$mn:000028D4
.text$mn:000028D4 ; Segment type: Pure code
.text$mn:000028D4 ; Segment permissions: Read/Execute
.text$mn:000028D4 _text$mn        segment para public 'CODE' use32
.text$mn:000028D4                 assume cs:_text$mn
.text$mn:000028D4                 ;org 28D4h
.text$mn:000028D4 ; COMDAT (pick any)
.text$mn:000028D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000028D4
.text$mn:000028D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000028D4
.text$mn:000028D4 ; Attributes: bp-based frame
.text$mn:000028D4
.text$mn:000028D4 ; int __stdcall std::_Wrap_alloc<std::allocator<std::pair<int,int>>>::construct<std::pair<int,int>,std::pair<int,int>>(void *, int)
.text$mn:000028D4                 public ??$construct@U?$pair@HH@std@@U12@@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAEXPAU?$pair@HH@1@$$QAU21@@Z
.text$mn:000028D4 ??$construct@U?$pair@HH@std@@U12@@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAEXPAU?$pair@HH@1@$$QAU21@@Z proc near
.text$mn:000028D4                                         ; CODE XREF: std::_Uninit_move<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int>>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &,std::pair<int,int> *,std::_Nonscalar_ptr_iterator_tag)+8Ep
.text$mn:000028D4                                         ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::push_back(std::pair<int,int> &&)+9Ap ...
.text$mn:000028D4
.text$mn:000028D4 var_4           = dword ptr -4
.text$mn:000028D4 arg_0           = dword ptr  8
.text$mn:000028D4 arg_4           = dword ptr  0Ch
.text$mn:000028D4
.text$mn:000028D4                 push    ebp
.text$mn:000028D5                 mov     ebp, esp
.text$mn:000028D7                 push    ecx
.text$mn:000028D8                 mov     [ebp+var_4], ecx
.text$mn:000028DB                 mov     eax, [ebp+arg_4]
.text$mn:000028DE                 push    eax
.text$mn:000028DF                 call    ??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z ; std::forward<std::pair<int,int>>(std::pair<int,int> &)
.text$mn:000028E4                 add     esp, 4
.text$mn:000028E7                 push    eax             ; int
.text$mn:000028E8                 mov     ecx, [ebp+arg_0]
.text$mn:000028EB                 push    ecx             ; void *
.text$mn:000028EC                 mov     edx, [ebp+var_4]
.text$mn:000028EF                 push    edx             ; int
.text$mn:000028F0                 call    ??$construct@U?$pair@HH@std@@U12@@?$allocator_traits@V?$allocator@U?$pair@HH@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@HH@std@@@1@PAU?$pair@HH@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::pair<int,int>>>::construct<std::pair<int,int>,std::pair<int,int>>(std::allocator<std::pair<int,int>> &,std::pair<int,int> *,std::pair<int,int> &&)
.text$mn:000028F5                 add     esp, 0Ch
.text$mn:000028F8                 mov     esp, ebp
.text$mn:000028FA                 pop     ebp
.text$mn:000028FB                 retn    8
.text$mn:000028FB ??$construct@U?$pair@HH@std@@U12@@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAEXPAU?$pair@HH@1@$$QAU21@@Z endp
.text$mn:000028FB
.text$mn:000028FB ; ---------------------------------------------------------------------------
.text$mn:000028FE                 align 10h
.text$mn:000028FE _text$mn        ends
.text$mn:000028FE
.text$mn:00002900 ; ===========================================================================
.text$mn:00002900
.text$mn:00002900 ; Segment type: Pure code
.text$mn:00002900 ; Segment permissions: Read/Execute
.text$mn:00002900 _text$mn        segment para public 'CODE' use32
.text$mn:00002900                 assume cs:_text$mn
.text$mn:00002900                 ;org 2900h
.text$mn:00002900 ; COMDAT (pick any)
.text$mn:00002900                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002900
.text$mn:00002900 ; =============== S U B R O U T I N E =======================================
.text$mn:00002900
.text$mn:00002900 ; Attributes: bp-based frame
.text$mn:00002900
.text$mn:00002900 ; int __stdcall std::allocator<std::pair<int,int>>::construct<std::pair<int,int>,std::pair<int,int>>(void *, int)
.text$mn:00002900                 public ??$construct@U?$pair@HH@std@@U12@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@$$QAU21@@Z
.text$mn:00002900 ??$construct@U?$pair@HH@std@@U12@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@$$QAU21@@Z proc near
.text$mn:00002900                                         ; CODE XREF: std::allocator_traits<std::allocator<std::pair<int,int>>>::construct<std::pair<int,int>,std::pair<int,int>>(std::allocator<std::pair<int,int>> &,std::pair<int,int> *,std::pair<int,int> &&)+17p
.text$mn:00002900
.text$mn:00002900 var_1C          = dword ptr -1Ch
.text$mn:00002900 var_18          = dword ptr -18h
.text$mn:00002900 var_14          = dword ptr -14h
.text$mn:00002900 var_10          = dword ptr -10h
.text$mn:00002900 var_C           = dword ptr -0Ch
.text$mn:00002900 var_4           = dword ptr -4
.text$mn:00002900 arg_0           = dword ptr  8
.text$mn:00002900 arg_4           = dword ptr  0Ch
.text$mn:00002900
.text$mn:00002900                 push    ebp
.text$mn:00002901                 mov     ebp, esp
.text$mn:00002903                 push    0FFFFFFFFh
.text$mn:00002905                 push    offset __ehhandler$??$construct@U?$pair@HH@std@@U12@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@$$QAU21@@Z
.text$mn:0000290A                 mov     eax, large fs:0
.text$mn:00002910                 push    eax
.text$mn:00002911                 sub     esp, 10h
.text$mn:00002914                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002919                 xor     eax, ebp
.text$mn:0000291B                 push    eax
.text$mn:0000291C                 lea     eax, [ebp+var_C]
.text$mn:0000291F                 mov     large fs:0, eax
.text$mn:00002925                 mov     [ebp+var_18], ecx
.text$mn:00002928                 mov     eax, [ebp+arg_0]
.text$mn:0000292B                 push    eax             ; void *
.text$mn:0000292C                 push    8               ; unsigned int
.text$mn:0000292E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00002933                 add     esp, 8
.text$mn:00002936                 mov     [ebp+var_10], eax
.text$mn:00002939                 mov     [ebp+var_4], 0
.text$mn:00002940                 cmp     [ebp+var_10], 0
.text$mn:00002944                 jz      short loc_2960
.text$mn:00002946                 mov     ecx, [ebp+arg_4]
.text$mn:00002949                 push    ecx
.text$mn:0000294A                 call    ??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z ; std::forward<std::pair<int,int>>(std::pair<int,int> &)
.text$mn:0000294F                 add     esp, 4
.text$mn:00002952                 push    eax
.text$mn:00002953                 mov     ecx, [ebp+var_10]
.text$mn:00002956                 call    ??$?0HHX@?$pair@HH@std@@QAE@$$QAU01@@Z ; std::pair<int,int>::pair<int,int>(std::pair<int,int> &&)
.text$mn:0000295B                 mov     [ebp+var_14], eax
.text$mn:0000295E                 jmp     short loc_2967
.text$mn:00002960 ; ---------------------------------------------------------------------------
.text$mn:00002960
.text$mn:00002960 loc_2960:                               ; CODE XREF: std::allocator<std::pair<int,int>>::construct<std::pair<int,int>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> &&)+44j
.text$mn:00002960                 mov     [ebp+var_14], 0
.text$mn:00002967
.text$mn:00002967 loc_2967:                               ; CODE XREF: std::allocator<std::pair<int,int>>::construct<std::pair<int,int>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> &&)+5Ej
.text$mn:00002967                 mov     edx, [ebp+var_14]
.text$mn:0000296A                 mov     [ebp+var_1C], edx
.text$mn:0000296D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002974                 mov     ecx, [ebp+var_C]
.text$mn:00002977                 mov     large fs:0, ecx
.text$mn:0000297E                 pop     ecx
.text$mn:0000297F                 mov     esp, ebp
.text$mn:00002981                 pop     ebp
.text$mn:00002982                 retn    8
.text$mn:00002982 ??$construct@U?$pair@HH@std@@U12@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@$$QAU21@@Z endp
.text$mn:00002982
.text$mn:00002982 ; ---------------------------------------------------------------------------
.text$mn:00002985                 align 4
.text$mn:00002985 _text$mn        ends
.text$mn:00002985
.text$x:00002988 ; ===========================================================================
.text$x:00002988
.text$x:00002988 ; Segment type: Pure code
.text$x:00002988 ; Segment permissions: Read/Execute
.text$x:00002988 _text$x         segment para public 'CODE' use32
.text$x:00002988                 assume cs:_text$x
.text$x:00002988                 ;org 2988h
.text$x:00002988 ; COMDAT (pick associative to section at 2900)
.text$x:00002988                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002988
.text$x:00002988 ; =============== S U B R O U T I N E =======================================
.text$x:00002988
.text$x:00002988
.text$x:00002988 __unwindfunclet$??$construct@U?$pair@HH@std@@U12@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@$$QAU21@@Z$0 proc near
.text$x:00002988                                         ; DATA XREF: .xdata$x:00006AE0o
.text$x:00002988                 mov     eax, [ebp+8]
.text$x:0000298B                 push    eax
.text$x:0000298C                 mov     eax, [ebp-10h]
.text$x:0000298F                 push    eax             ; void *
.text$x:00002990                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00002995                 add     esp, 8
.text$x:00002998                 retn
.text$x:00002998 __unwindfunclet$??$construct@U?$pair@HH@std@@U12@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@$$QAU21@@Z$0 endp
.text$x:00002998
.text$x:00002999
.text$x:00002999 ; =============== S U B R O U T I N E =======================================
.text$x:00002999
.text$x:00002999
.text$x:00002999 __ehhandler$??$construct@U?$pair@HH@std@@U12@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@$$QAU21@@Z proc near
.text$x:00002999                                         ; DATA XREF: std::allocator<std::pair<int,int>>::construct<std::pair<int,int>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> &&)+5o
.text$x:00002999
.text$x:00002999 arg_4           = dword ptr  8
.text$x:00002999
.text$x:00002999                 mov     edx, [esp+arg_4]
.text$x:0000299D                 lea     eax, [edx+0Ch]
.text$x:000029A0                 mov     ecx, [edx-14h]
.text$x:000029A3                 xor     ecx, eax
.text$x:000029A5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000029AA                 mov     eax, offset __ehfuncinfo$??$construct@U?$pair@HH@std@@U12@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@$$QAU21@@Z
.text$x:000029AF                 jmp     ___CxxFrameHandler3
.text$x:000029AF __ehhandler$??$construct@U?$pair@HH@std@@U12@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@$$QAU21@@Z endp
.text$x:000029AF
.text$x:000029AF _text$x         ends
.text$x:000029AF
.text$mn:000029B4 ; ===========================================================================
.text$mn:000029B4
.text$mn:000029B4 ; Segment type: Pure code
.text$mn:000029B4 ; Segment permissions: Read/Execute
.text$mn:000029B4 _text$mn        segment para public 'CODE' use32
.text$mn:000029B4                 assume cs:_text$mn
.text$mn:000029B4                 ;org 29B4h
.text$mn:000029B4 ; COMDAT (pick any)
.text$mn:000029B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000029B4
.text$mn:000029B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000029B4
.text$mn:000029B4 ; Attributes: bp-based frame
.text$mn:000029B4
.text$mn:000029B4 ; int __cdecl std::allocator_traits<std::allocator<std::pair<int,int>>>::construct<std::pair<int,int>,std::pair<int,int>>(int, void *, int)
.text$mn:000029B4                 public ??$construct@U?$pair@HH@std@@U12@@?$allocator_traits@V?$allocator@U?$pair@HH@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@HH@std@@@1@PAU?$pair@HH@1@$$QAU31@@Z
.text$mn:000029B4 ??$construct@U?$pair@HH@std@@U12@@?$allocator_traits@V?$allocator@U?$pair@HH@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@HH@std@@@1@PAU?$pair@HH@1@$$QAU31@@Z proc near
.text$mn:000029B4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::pair<int,int>>>::construct<std::pair<int,int>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> &&)+1Cp
.text$mn:000029B4
.text$mn:000029B4 arg_0           = dword ptr  8
.text$mn:000029B4 arg_4           = dword ptr  0Ch
.text$mn:000029B4 arg_8           = dword ptr  10h
.text$mn:000029B4
.text$mn:000029B4                 push    ebp
.text$mn:000029B5                 mov     ebp, esp
.text$mn:000029B7                 mov     eax, [ebp+arg_8]
.text$mn:000029BA                 push    eax
.text$mn:000029BB                 call    ??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z ; std::forward<std::pair<int,int>>(std::pair<int,int> &)
.text$mn:000029C0                 add     esp, 4
.text$mn:000029C3                 push    eax             ; int
.text$mn:000029C4                 mov     ecx, [ebp+arg_4]
.text$mn:000029C7                 push    ecx             ; void *
.text$mn:000029C8                 mov     ecx, [ebp+arg_0]
.text$mn:000029CB                 call    ??$construct@U?$pair@HH@std@@U12@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@$$QAU21@@Z ; std::allocator<std::pair<int,int>>::construct<std::pair<int,int>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> &&)
.text$mn:000029D0                 pop     ebp
.text$mn:000029D1                 retn
.text$mn:000029D1 ??$construct@U?$pair@HH@std@@U12@@?$allocator_traits@V?$allocator@U?$pair@HH@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@HH@std@@@1@PAU?$pair@HH@1@$$QAU31@@Z endp
.text$mn:000029D1
.text$mn:000029D1 ; ---------------------------------------------------------------------------
.text$mn:000029D2                 align 4
.text$mn:000029D2 _text$mn        ends
.text$mn:000029D2
.text$mn:000029D4 ; ===========================================================================
.text$mn:000029D4
.text$mn:000029D4 ; Segment type: Pure code
.text$mn:000029D4 ; Segment permissions: Read/Execute
.text$mn:000029D4 _text$mn        segment para public 'CODE' use32
.text$mn:000029D4                 assume cs:_text$mn
.text$mn:000029D4                 ;org 29D4h
.text$mn:000029D4 ; COMDAT (pick any)
.text$mn:000029D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000029D4
.text$mn:000029D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000029D4
.text$mn:000029D4 ; Attributes: bp-based frame
.text$mn:000029D4
.text$mn:000029D4 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:000029D4                 public ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000029D4 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:000029D4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Alloc_proxy(void)+32p
.text$mn:000029D4
.text$mn:000029D4 var_4           = dword ptr -4
.text$mn:000029D4 arg_0           = dword ptr  8
.text$mn:000029D4 arg_4           = dword ptr  0Ch
.text$mn:000029D4
.text$mn:000029D4                 push    ebp
.text$mn:000029D5                 mov     ebp, esp
.text$mn:000029D7                 push    ecx
.text$mn:000029D8                 mov     [ebp+var_4], ecx
.text$mn:000029DB                 mov     eax, [ebp+arg_4]
.text$mn:000029DE                 push    eax
.text$mn:000029DF                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:000029E4                 add     esp, 4
.text$mn:000029E7                 push    eax             ; int
.text$mn:000029E8                 mov     ecx, [ebp+arg_0]
.text$mn:000029EB                 push    ecx             ; void *
.text$mn:000029EC                 mov     edx, [ebp+var_4]
.text$mn:000029EF                 push    edx             ; int
.text$mn:000029F0                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000029F5                 add     esp, 0Ch
.text$mn:000029F8                 mov     esp, ebp
.text$mn:000029FA                 pop     ebp
.text$mn:000029FB                 retn    8
.text$mn:000029FB ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:000029FB
.text$mn:000029FB ; ---------------------------------------------------------------------------
.text$mn:000029FE                 align 10h
.text$mn:000029FE _text$mn        ends
.text$mn:000029FE
.text$mn:00002A00 ; ===========================================================================
.text$mn:00002A00
.text$mn:00002A00 ; Segment type: Pure code
.text$mn:00002A00 ; Segment permissions: Read/Execute
.text$mn:00002A00 _text$mn        segment para public 'CODE' use32
.text$mn:00002A00                 assume cs:_text$mn
.text$mn:00002A00                 ;org 2A00h
.text$mn:00002A00 ; COMDAT (pick any)
.text$mn:00002A00                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A00
.text$mn:00002A00 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A00
.text$mn:00002A00 ; Attributes: bp-based frame
.text$mn:00002A00
.text$mn:00002A00 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00002A00                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00002A00 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00002A00                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)+17p
.text$mn:00002A00                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00002A00
.text$mn:00002A00 var_1C          = dword ptr -1Ch
.text$mn:00002A00 var_18          = dword ptr -18h
.text$mn:00002A00 var_14          = dword ptr -14h
.text$mn:00002A00 var_10          = dword ptr -10h
.text$mn:00002A00 var_C           = dword ptr -0Ch
.text$mn:00002A00 var_4           = dword ptr -4
.text$mn:00002A00 arg_0           = dword ptr  8
.text$mn:00002A00 arg_4           = dword ptr  0Ch
.text$mn:00002A00
.text$mn:00002A00                 push    ebp
.text$mn:00002A01                 mov     ebp, esp
.text$mn:00002A03                 push    0FFFFFFFFh
.text$mn:00002A05                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00002A0A                 mov     eax, large fs:0
.text$mn:00002A10                 push    eax
.text$mn:00002A11                 sub     esp, 10h
.text$mn:00002A14                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002A19                 xor     eax, ebp
.text$mn:00002A1B                 push    eax
.text$mn:00002A1C                 lea     eax, [ebp+var_C]
.text$mn:00002A1F                 mov     large fs:0, eax
.text$mn:00002A25                 mov     [ebp+var_18], ecx
.text$mn:00002A28                 mov     eax, [ebp+arg_0]
.text$mn:00002A2B                 push    eax             ; void *
.text$mn:00002A2C                 push    8               ; unsigned int
.text$mn:00002A2E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00002A33                 add     esp, 8
.text$mn:00002A36                 mov     [ebp+var_10], eax
.text$mn:00002A39                 mov     [ebp+var_4], 0
.text$mn:00002A40                 cmp     [ebp+var_10], 0
.text$mn:00002A44                 jz      short loc_2A67
.text$mn:00002A46                 mov     ecx, [ebp+arg_4]
.text$mn:00002A49                 push    ecx
.text$mn:00002A4A                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00002A4F                 add     esp, 4
.text$mn:00002A52                 mov     edx, [eax]
.text$mn:00002A54                 mov     eax, [eax+4]
.text$mn:00002A57                 mov     ecx, [ebp+var_10]
.text$mn:00002A5A                 mov     [ecx], edx
.text$mn:00002A5C                 mov     [ecx+4], eax
.text$mn:00002A5F                 mov     edx, [ebp+var_10]
.text$mn:00002A62                 mov     [ebp+var_14], edx
.text$mn:00002A65                 jmp     short loc_2A6E
.text$mn:00002A67 ; ---------------------------------------------------------------------------
.text$mn:00002A67
.text$mn:00002A67 loc_2A67:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00002A67                 mov     [ebp+var_14], 0
.text$mn:00002A6E
.text$mn:00002A6E loc_2A6E:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00002A6E                 mov     eax, [ebp+var_14]
.text$mn:00002A71                 mov     [ebp+var_1C], eax
.text$mn:00002A74                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002A7B                 mov     ecx, [ebp+var_C]
.text$mn:00002A7E                 mov     large fs:0, ecx
.text$mn:00002A85                 pop     ecx
.text$mn:00002A86                 mov     esp, ebp
.text$mn:00002A88                 pop     ebp
.text$mn:00002A89                 retn    8
.text$mn:00002A89 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00002A89
.text$mn:00002A89 _text$mn        ends
.text$mn:00002A89
.text$x:00002A8C ; ===========================================================================
.text$x:00002A8C
.text$x:00002A8C ; Segment type: Pure code
.text$x:00002A8C ; Segment permissions: Read/Execute
.text$x:00002A8C _text$x         segment para public 'CODE' use32
.text$x:00002A8C                 assume cs:_text$x
.text$x:00002A8C                 ;org 2A8Ch
.text$x:00002A8C ; COMDAT (pick associative to section at 2A00)
.text$x:00002A8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002A8C
.text$x:00002A8C ; =============== S U B R O U T I N E =======================================
.text$x:00002A8C
.text$x:00002A8C
.text$x:00002A8C __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00002A8C                                         ; DATA XREF: .xdata$x:00006AB4o
.text$x:00002A8C                 mov     eax, [ebp+8]
.text$x:00002A8F                 push    eax
.text$x:00002A90                 mov     eax, [ebp-10h]
.text$x:00002A93                 push    eax             ; void *
.text$x:00002A94                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00002A99                 add     esp, 8
.text$x:00002A9C                 retn
.text$x:00002A9C __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00002A9C
.text$x:00002A9D
.text$x:00002A9D ; =============== S U B R O U T I N E =======================================
.text$x:00002A9D
.text$x:00002A9D
.text$x:00002A9D __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00002A9D                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00002A9D
.text$x:00002A9D arg_4           = dword ptr  8
.text$x:00002A9D
.text$x:00002A9D                 mov     edx, [esp+arg_4]
.text$x:00002AA1                 lea     eax, [edx+0Ch]
.text$x:00002AA4                 mov     ecx, [edx-14h]
.text$x:00002AA7                 xor     ecx, eax
.text$x:00002AA9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002AAE                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00002AB3                 jmp     ___CxxFrameHandler3
.text$x:00002AB3 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00002AB3
.text$x:00002AB3 _text$x         ends
.text$x:00002AB3
.text$mn:00002AB8 ; ===========================================================================
.text$mn:00002AB8
.text$mn:00002AB8 ; Segment type: Pure code
.text$mn:00002AB8 ; Segment permissions: Read/Execute
.text$mn:00002AB8 _text$mn        segment para public 'CODE' use32
.text$mn:00002AB8                 assume cs:_text$mn
.text$mn:00002AB8                 ;org 2AB8h
.text$mn:00002AB8 ; COMDAT (pick any)
.text$mn:00002AB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002AB8
.text$mn:00002AB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AB8
.text$mn:00002AB8 ; Attributes: bp-based frame
.text$mn:00002AB8
.text$mn:00002AB8 ; int __cdecl std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(int, void *, int)
.text$mn:00002AB8                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
.text$mn:00002AB8 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z proc near
.text$mn:00002AB8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+1Cp
.text$mn:00002AB8
.text$mn:00002AB8 arg_0           = dword ptr  8
.text$mn:00002AB8 arg_4           = dword ptr  0Ch
.text$mn:00002AB8 arg_8           = dword ptr  10h
.text$mn:00002AB8
.text$mn:00002AB8                 push    ebp
.text$mn:00002AB9                 mov     ebp, esp
.text$mn:00002ABB                 mov     eax, [ebp+arg_8]
.text$mn:00002ABE                 push    eax
.text$mn:00002ABF                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00002AC4                 add     esp, 4
.text$mn:00002AC7                 push    eax             ; int
.text$mn:00002AC8                 mov     ecx, [ebp+arg_4]
.text$mn:00002ACB                 push    ecx             ; void *
.text$mn:00002ACC                 mov     ecx, [ebp+arg_0]
.text$mn:00002ACF                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00002AD4                 pop     ebp
.text$mn:00002AD5                 retn
.text$mn:00002AD5 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z endp
.text$mn:00002AD5
.text$mn:00002AD5 ; ---------------------------------------------------------------------------
.text$mn:00002AD6                 align 4
.text$mn:00002AD6 _text$mn        ends
.text$mn:00002AD6
.text$mn:00002AD8 ; ===========================================================================
.text$mn:00002AD8
.text$mn:00002AD8 ; Segment type: Pure code
.text$mn:00002AD8 ; Segment permissions: Read/Execute
.text$mn:00002AD8 _text$mn        segment para public 'CODE' use32
.text$mn:00002AD8                 assume cs:_text$mn
.text$mn:00002AD8                 ;org 2AD8h
.text$mn:00002AD8 ; COMDAT (pick any)
.text$mn:00002AD8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002AD8
.text$mn:00002AD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AD8
.text$mn:00002AD8 ; Attributes: bp-based frame
.text$mn:00002AD8
.text$mn:00002AD8 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00002AD8                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00002AD8 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00002AD8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00002AD8
.text$mn:00002AD8 var_4           = dword ptr -4
.text$mn:00002AD8 arg_0           = dword ptr  8
.text$mn:00002AD8
.text$mn:00002AD8                 push    ebp
.text$mn:00002AD9                 mov     ebp, esp
.text$mn:00002ADB                 push    ecx
.text$mn:00002ADC                 mov     [ebp+var_4], ecx
.text$mn:00002ADF                 mov     eax, [ebp+arg_0]
.text$mn:00002AE2                 push    eax
.text$mn:00002AE3                 mov     ecx, [ebp+var_4]
.text$mn:00002AE6                 push    ecx
.text$mn:00002AE7                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00002AEC                 add     esp, 8
.text$mn:00002AEF                 mov     esp, ebp
.text$mn:00002AF1                 pop     ebp
.text$mn:00002AF2                 retn    4
.text$mn:00002AF2 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00002AF2
.text$mn:00002AF2 ; ---------------------------------------------------------------------------
.text$mn:00002AF5                 align 4
.text$mn:00002AF5 _text$mn        ends
.text$mn:00002AF5
.text$mn:00002AF8 ; ===========================================================================
.text$mn:00002AF8
.text$mn:00002AF8 ; Segment type: Pure code
.text$mn:00002AF8 ; Segment permissions: Read/Execute
.text$mn:00002AF8 _text$mn        segment para public 'CODE' use32
.text$mn:00002AF8                 assume cs:_text$mn
.text$mn:00002AF8                 ;org 2AF8h
.text$mn:00002AF8 ; COMDAT (pick any)
.text$mn:00002AF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002AF8
.text$mn:00002AF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AF8
.text$mn:00002AF8 ; Attributes: bp-based frame
.text$mn:00002AF8
.text$mn:00002AF8 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00002AF8                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00002AF8 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00002AF8                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00002AF8
.text$mn:00002AF8 var_4           = dword ptr -4
.text$mn:00002AF8
.text$mn:00002AF8                 push    ebp
.text$mn:00002AF9                 mov     ebp, esp
.text$mn:00002AFB                 push    ecx
.text$mn:00002AFC                 mov     [ebp+var_4], ecx
.text$mn:00002AFF                 mov     esp, ebp
.text$mn:00002B01                 pop     ebp
.text$mn:00002B02                 retn    4
.text$mn:00002B02 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00002B02
.text$mn:00002B02 ; ---------------------------------------------------------------------------
.text$mn:00002B05                 align 4
.text$mn:00002B05 _text$mn        ends
.text$mn:00002B05
.text$mn:00002B08 ; ===========================================================================
.text$mn:00002B08
.text$mn:00002B08 ; Segment type: Pure code
.text$mn:00002B08 ; Segment permissions: Read/Execute
.text$mn:00002B08 _text$mn        segment para public 'CODE' use32
.text$mn:00002B08                 assume cs:_text$mn
.text$mn:00002B08                 ;org 2B08h
.text$mn:00002B08 ; COMDAT (pick any)
.text$mn:00002B08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B08
.text$mn:00002B08 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B08
.text$mn:00002B08 ; Attributes: bp-based frame
.text$mn:00002B08
.text$mn:00002B08 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00002B08                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00002B08 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00002B08                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00002B08
.text$mn:00002B08 arg_0           = dword ptr  8
.text$mn:00002B08 arg_4           = dword ptr  0Ch
.text$mn:00002B08
.text$mn:00002B08                 push    ebp
.text$mn:00002B09                 mov     ebp, esp
.text$mn:00002B0B                 mov     eax, [ebp+arg_4]
.text$mn:00002B0E                 push    eax
.text$mn:00002B0F                 mov     ecx, [ebp+arg_0]
.text$mn:00002B12                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00002B17                 pop     ebp
.text$mn:00002B18                 retn
.text$mn:00002B18 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00002B18
.text$mn:00002B18 ; ---------------------------------------------------------------------------
.text$mn:00002B19                 align 4
.text$mn:00002B19 _text$mn        ends
.text$mn:00002B19
.text$mn:00002B1C ; ===========================================================================
.text$mn:00002B1C
.text$mn:00002B1C ; Segment type: Pure code
.text$mn:00002B1C ; Segment permissions: Read/Execute
.text$mn:00002B1C _text$mn        segment para public 'CODE' use32
.text$mn:00002B1C                 assume cs:_text$mn
.text$mn:00002B1C                 ;org 2B1Ch
.text$mn:00002B1C ; COMDAT (pick any)
.text$mn:00002B1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B1C
.text$mn:00002B1C ; =============== S U B R O U T I N E =======================================
.text$mn:00002B1C
.text$mn:00002B1C ; Attributes: bp-based frame
.text$mn:00002B1C
.text$mn:00002B1C ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::pair<int, int>>>::destroy<struct std::pair<int, int>>(struct std::pair<int, int> *)
.text$mn:00002B1C                 public ??$destroy@U?$pair@HH@std@@@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAEXPAU?$pair@HH@1@@Z
.text$mn:00002B1C ??$destroy@U?$pair@HH@std@@@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAEXPAU?$pair@HH@1@@Z proc near
.text$mn:00002B1C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<int,int>>>>(std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:00002B1C                                         ; __catch$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Ap
.text$mn:00002B1C
.text$mn:00002B1C var_4           = dword ptr -4
.text$mn:00002B1C arg_0           = dword ptr  8
.text$mn:00002B1C
.text$mn:00002B1C                 push    ebp
.text$mn:00002B1D                 mov     ebp, esp
.text$mn:00002B1F                 push    ecx
.text$mn:00002B20                 mov     [ebp+var_4], ecx
.text$mn:00002B23                 mov     eax, [ebp+arg_0]
.text$mn:00002B26                 push    eax
.text$mn:00002B27                 mov     ecx, [ebp+var_4]
.text$mn:00002B2A                 push    ecx
.text$mn:00002B2B                 call    ??$destroy@U?$pair@HH@std@@@?$allocator_traits@V?$allocator@U?$pair@HH@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@HH@std@@@1@PAU?$pair@HH@1@@Z ; std::allocator_traits<std::allocator<std::pair<int,int>>>::destroy<std::pair<int,int>>(std::allocator<std::pair<int,int>> &,std::pair<int,int> *)
.text$mn:00002B30                 add     esp, 8
.text$mn:00002B33                 mov     esp, ebp
.text$mn:00002B35                 pop     ebp
.text$mn:00002B36                 retn    4
.text$mn:00002B36 ??$destroy@U?$pair@HH@std@@@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAEXPAU?$pair@HH@1@@Z endp
.text$mn:00002B36
.text$mn:00002B36 ; ---------------------------------------------------------------------------
.text$mn:00002B39                 align 4
.text$mn:00002B39 _text$mn        ends
.text$mn:00002B39
.text$mn:00002B3C ; ===========================================================================
.text$mn:00002B3C
.text$mn:00002B3C ; Segment type: Pure code
.text$mn:00002B3C ; Segment permissions: Read/Execute
.text$mn:00002B3C _text$mn        segment para public 'CODE' use32
.text$mn:00002B3C                 assume cs:_text$mn
.text$mn:00002B3C                 ;org 2B3Ch
.text$mn:00002B3C ; COMDAT (pick any)
.text$mn:00002B3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B3C
.text$mn:00002B3C ; =============== S U B R O U T I N E =======================================
.text$mn:00002B3C
.text$mn:00002B3C ; Attributes: bp-based frame
.text$mn:00002B3C
.text$mn:00002B3C ; public: void __thiscall std::allocator<struct std::pair<int, int>>::destroy<struct std::pair<int, int>>(struct std::pair<int, int> *)
.text$mn:00002B3C                 public ??$destroy@U?$pair@HH@std@@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@@Z
.text$mn:00002B3C ??$destroy@U?$pair@HH@std@@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@@Z proc near
.text$mn:00002B3C                                         ; CODE XREF: std::allocator_traits<std::allocator<std::pair<int,int>>>::destroy<std::pair<int,int>>(std::allocator<std::pair<int,int>> &,std::pair<int,int> *)+Ap
.text$mn:00002B3C
.text$mn:00002B3C var_4           = dword ptr -4
.text$mn:00002B3C
.text$mn:00002B3C                 push    ebp
.text$mn:00002B3D                 mov     ebp, esp
.text$mn:00002B3F                 push    ecx
.text$mn:00002B40                 mov     [ebp+var_4], ecx
.text$mn:00002B43                 mov     esp, ebp
.text$mn:00002B45                 pop     ebp
.text$mn:00002B46                 retn    4
.text$mn:00002B46 ??$destroy@U?$pair@HH@std@@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@@Z endp
.text$mn:00002B46
.text$mn:00002B46 ; ---------------------------------------------------------------------------
.text$mn:00002B49                 align 4
.text$mn:00002B49 _text$mn        ends
.text$mn:00002B49
.text$mn:00002B4C ; ===========================================================================
.text$mn:00002B4C
.text$mn:00002B4C ; Segment type: Pure code
.text$mn:00002B4C ; Segment permissions: Read/Execute
.text$mn:00002B4C _text$mn        segment para public 'CODE' use32
.text$mn:00002B4C                 assume cs:_text$mn
.text$mn:00002B4C                 ;org 2B4Ch
.text$mn:00002B4C ; COMDAT (pick any)
.text$mn:00002B4C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B4C
.text$mn:00002B4C ; =============== S U B R O U T I N E =======================================
.text$mn:00002B4C
.text$mn:00002B4C ; Attributes: bp-based frame
.text$mn:00002B4C
.text$mn:00002B4C ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::pair<int, int>>>::destroy<struct std::pair<int, int>>(class std::allocator<struct std::pair<int, int>> &, struct std::pair<int, int> *)
.text$mn:00002B4C                 public ??$destroy@U?$pair@HH@std@@@?$allocator_traits@V?$allocator@U?$pair@HH@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@HH@std@@@1@PAU?$pair@HH@1@@Z
.text$mn:00002B4C ??$destroy@U?$pair@HH@std@@@?$allocator_traits@V?$allocator@U?$pair@HH@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@HH@std@@@1@PAU?$pair@HH@1@@Z proc near
.text$mn:00002B4C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::pair<int,int>>>::destroy<std::pair<int,int>>(std::pair<int,int> *)+Fp
.text$mn:00002B4C
.text$mn:00002B4C arg_0           = dword ptr  8
.text$mn:00002B4C arg_4           = dword ptr  0Ch
.text$mn:00002B4C
.text$mn:00002B4C                 push    ebp
.text$mn:00002B4D                 mov     ebp, esp
.text$mn:00002B4F                 mov     eax, [ebp+arg_4]
.text$mn:00002B52                 push    eax
.text$mn:00002B53                 mov     ecx, [ebp+arg_0]
.text$mn:00002B56                 call    ??$destroy@U?$pair@HH@std@@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@@Z ; std::allocator<std::pair<int,int>>::destroy<std::pair<int,int>>(std::pair<int,int> *)
.text$mn:00002B5B                 pop     ebp
.text$mn:00002B5C                 retn
.text$mn:00002B5C ??$destroy@U?$pair@HH@std@@@?$allocator_traits@V?$allocator@U?$pair@HH@std@@@std@@@std@@SAXAAV?$allocator@U?$pair@HH@std@@@1@PAU?$pair@HH@1@@Z endp
.text$mn:00002B5C
.text$mn:00002B5C ; ---------------------------------------------------------------------------
.text$mn:00002B5D                 align 10h
.text$mn:00002B5D _text$mn        ends
.text$mn:00002B5D
.text$mn:00002B60 ; ===========================================================================
.text$mn:00002B60
.text$mn:00002B60 ; Segment type: Pure code
.text$mn:00002B60 ; Segment permissions: Read/Execute
.text$mn:00002B60 _text$mn        segment para public 'CODE' use32
.text$mn:00002B60                 assume cs:_text$mn
.text$mn:00002B60                 ;org 2B60h
.text$mn:00002B60 ; COMDAT (pick any)
.text$mn:00002B60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B60
.text$mn:00002B60 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B60
.text$mn:00002B60 ; Attributes: bp-based frame
.text$mn:00002B60
.text$mn:00002B60 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00002B60                 public ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00002B60 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00002B60                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Free_proxy(void)+22p
.text$mn:00002B60
.text$mn:00002B60 var_4           = dword ptr -4
.text$mn:00002B60 arg_0           = dword ptr  8
.text$mn:00002B60
.text$mn:00002B60                 push    ebp
.text$mn:00002B61                 mov     ebp, esp
.text$mn:00002B63                 push    ecx
.text$mn:00002B64                 mov     [ebp+var_4], ecx
.text$mn:00002B67                 mov     eax, [ebp+arg_0]
.text$mn:00002B6A                 push    eax
.text$mn:00002B6B                 mov     ecx, [ebp+var_4]
.text$mn:00002B6E                 push    ecx
.text$mn:00002B6F                 call    ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)
.text$mn:00002B74                 add     esp, 8
.text$mn:00002B77                 mov     esp, ebp
.text$mn:00002B79                 pop     ebp
.text$mn:00002B7A                 retn    4
.text$mn:00002B7A ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00002B7A
.text$mn:00002B7A ; ---------------------------------------------------------------------------
.text$mn:00002B7D                 align 10h
.text$mn:00002B7D _text$mn        ends
.text$mn:00002B7D
.text$mn:00002B80 ; ===========================================================================
.text$mn:00002B80
.text$mn:00002B80 ; Segment type: Pure code
.text$mn:00002B80 ; Segment permissions: Read/Execute
.text$mn:00002B80 _text$mn        segment para public 'CODE' use32
.text$mn:00002B80                 assume cs:_text$mn
.text$mn:00002B80                 ;org 2B80h
.text$mn:00002B80 ; COMDAT (pick any)
.text$mn:00002B80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B80
.text$mn:00002B80 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B80
.text$mn:00002B80 ; Attributes: bp-based frame
.text$mn:00002B80
.text$mn:00002B80 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00002B80                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00002B80 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00002B80                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)+Ap
.text$mn:00002B80                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00002B80
.text$mn:00002B80 var_4           = dword ptr -4
.text$mn:00002B80
.text$mn:00002B80                 push    ebp
.text$mn:00002B81                 mov     ebp, esp
.text$mn:00002B83                 push    ecx
.text$mn:00002B84                 mov     [ebp+var_4], ecx
.text$mn:00002B87                 mov     esp, ebp
.text$mn:00002B89                 pop     ebp
.text$mn:00002B8A                 retn    4
.text$mn:00002B8A ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00002B8A
.text$mn:00002B8A ; ---------------------------------------------------------------------------
.text$mn:00002B8D                 align 10h
.text$mn:00002B8D _text$mn        ends
.text$mn:00002B8D
.text$mn:00002B90 ; ===========================================================================
.text$mn:00002B90
.text$mn:00002B90 ; Segment type: Pure code
.text$mn:00002B90 ; Segment permissions: Read/Execute
.text$mn:00002B90 _text$mn        segment para public 'CODE' use32
.text$mn:00002B90                 assume cs:_text$mn
.text$mn:00002B90                 ;org 2B90h
.text$mn:00002B90 ; COMDAT (pick any)
.text$mn:00002B90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B90
.text$mn:00002B90 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B90
.text$mn:00002B90 ; Attributes: bp-based frame
.text$mn:00002B90
.text$mn:00002B90 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(class std::allocator<struct std::_Container_proxy> &, struct std::_Container_proxy *)
.text$mn:00002B90                 public ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
.text$mn:00002B90 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z proc near
.text$mn:00002B90                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)+Fp
.text$mn:00002B90
.text$mn:00002B90 arg_0           = dword ptr  8
.text$mn:00002B90 arg_4           = dword ptr  0Ch
.text$mn:00002B90
.text$mn:00002B90                 push    ebp
.text$mn:00002B91                 mov     ebp, esp
.text$mn:00002B93                 mov     eax, [ebp+arg_4]
.text$mn:00002B96                 push    eax
.text$mn:00002B97                 mov     ecx, [ebp+arg_0]
.text$mn:00002B9A                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00002B9F                 pop     ebp
.text$mn:00002BA0                 retn
.text$mn:00002BA0 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z endp
.text$mn:00002BA0
.text$mn:00002BA0 ; ---------------------------------------------------------------------------
.text$mn:00002BA1                 align 4
.text$mn:00002BA1 _text$mn        ends
.text$mn:00002BA1
.text$mn:00002BA4 ; ===========================================================================
.text$mn:00002BA4
.text$mn:00002BA4 ; Segment type: Pure code
.text$mn:00002BA4 ; Segment permissions: Read/Execute
.text$mn:00002BA4 _text$mn        segment para public 'CODE' use32
.text$mn:00002BA4                 assume cs:_text$mn
.text$mn:00002BA4                 ;org 2BA4h
.text$mn:00002BA4 ; COMDAT (pick any)
.text$mn:00002BA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002BA4
.text$mn:00002BA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BA4
.text$mn:00002BA4 ; Attributes: bp-based frame
.text$mn:00002BA4
.text$mn:00002BA4 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00002BA4                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00002BA4 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00002BA4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00002BA4                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00002BA4
.text$mn:00002BA4 arg_0           = dword ptr  8
.text$mn:00002BA4
.text$mn:00002BA4                 push    ebp
.text$mn:00002BA5                 mov     ebp, esp
.text$mn:00002BA7                 mov     eax, [ebp+arg_0]
.text$mn:00002BAA                 pop     ebp
.text$mn:00002BAB                 retn
.text$mn:00002BAB ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00002BAB
.text$mn:00002BAB _text$mn        ends
.text$mn:00002BAB
.text$mn:00002BAC ; ===========================================================================
.text$mn:00002BAC
.text$mn:00002BAC ; Segment type: Pure code
.text$mn:00002BAC ; Segment permissions: Read/Execute
.text$mn:00002BAC _text$mn        segment para public 'CODE' use32
.text$mn:00002BAC                 assume cs:_text$mn
.text$mn:00002BAC                 ;org 2BACh
.text$mn:00002BAC ; COMDAT (pick any)
.text$mn:00002BAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002BAC
.text$mn:00002BAC ; =============== S U B R O U T I N E =======================================
.text$mn:00002BAC
.text$mn:00002BAC ; Attributes: bp-based frame
.text$mn:00002BAC
.text$mn:00002BAC ; int && __cdecl std::forward<int>(int &)
.text$mn:00002BAC                 public ??$forward@H@std@@YA$$QAHAAH@Z
.text$mn:00002BAC ??$forward@H@std@@YA$$QAHAAH@Z proc near
.text$mn:00002BAC                                         ; CODE XREF: std::pair<int,int>::pair<int,int>(int &&,int &&)+Bp
.text$mn:00002BAC                                         ; std::pair<int,int>::pair<int,int>(int &&,int &&)+1Ep ...
.text$mn:00002BAC
.text$mn:00002BAC arg_0           = dword ptr  8
.text$mn:00002BAC
.text$mn:00002BAC                 push    ebp
.text$mn:00002BAD                 mov     ebp, esp
.text$mn:00002BAF                 mov     eax, [ebp+arg_0]
.text$mn:00002BB2                 pop     ebp
.text$mn:00002BB3                 retn
.text$mn:00002BB3 ??$forward@H@std@@YA$$QAHAAH@Z endp
.text$mn:00002BB3
.text$mn:00002BB3 _text$mn        ends
.text$mn:00002BB3
.text$mn:00002BB4 ; ===========================================================================
.text$mn:00002BB4
.text$mn:00002BB4 ; Segment type: Pure code
.text$mn:00002BB4 ; Segment permissions: Read/Execute
.text$mn:00002BB4 _text$mn        segment para public 'CODE' use32
.text$mn:00002BB4                 assume cs:_text$mn
.text$mn:00002BB4                 ;org 2BB4h
.text$mn:00002BB4 ; COMDAT (pick any)
.text$mn:00002BB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002BB4
.text$mn:00002BB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BB4
.text$mn:00002BB4 ; Attributes: bp-based frame
.text$mn:00002BB4
.text$mn:00002BB4 ; struct std::pair<int, int> && __cdecl std::forward<struct std::pair<int, int>>(struct std::pair<int, int> &)
.text$mn:00002BB4                 public ??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z
.text$mn:00002BB4 ??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z proc near
.text$mn:00002BB4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::pair<int,int>>>::construct<std::pair<int,int>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> &&)+Bp
.text$mn:00002BB4                                         ; std::allocator<std::pair<int,int>>::construct<std::pair<int,int>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> &&)+4Ap ...
.text$mn:00002BB4
.text$mn:00002BB4 arg_0           = dword ptr  8
.text$mn:00002BB4
.text$mn:00002BB4                 push    ebp
.text$mn:00002BB5                 mov     ebp, esp
.text$mn:00002BB7                 mov     eax, [ebp+arg_0]
.text$mn:00002BBA                 pop     ebp
.text$mn:00002BBB                 retn
.text$mn:00002BBB ??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z endp
.text$mn:00002BBB
.text$mn:00002BBB _text$mn        ends
.text$mn:00002BBB
.text$mn:00002BBC ; ===========================================================================
.text$mn:00002BBC
.text$mn:00002BBC ; Segment type: Pure code
.text$mn:00002BBC ; Segment permissions: Read/Execute
.text$mn:00002BBC _text$mn        segment para public 'CODE' use32
.text$mn:00002BBC                 assume cs:_text$mn
.text$mn:00002BBC                 ;org 2BBCh
.text$mn:00002BBC ; COMDAT (pick any)
.text$mn:00002BBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002BBC
.text$mn:00002BBC ; =============== S U B R O U T I N E =======================================
.text$mn:00002BBC
.text$mn:00002BBC ; Attributes: bp-based frame
.text$mn:00002BBC
.text$mn:00002BBC ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00002BBC                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00002BBC ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00002BBC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+Bp
.text$mn:00002BBC                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap ...
.text$mn:00002BBC
.text$mn:00002BBC arg_0           = dword ptr  8
.text$mn:00002BBC
.text$mn:00002BBC                 push    ebp
.text$mn:00002BBD                 mov     ebp, esp
.text$mn:00002BBF                 mov     eax, [ebp+arg_0]
.text$mn:00002BC2                 pop     ebp
.text$mn:00002BC3                 retn
.text$mn:00002BC3 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00002BC3
.text$mn:00002BC3 _text$mn        ends
.text$mn:00002BC3
.text$mn:00002BC4 ; ===========================================================================
.text$mn:00002BC4
.text$mn:00002BC4 ; Segment type: Pure code
.text$mn:00002BC4 ; Segment permissions: Read/Execute
.text$mn:00002BC4 _text$mn        segment para public 'CODE' use32
.text$mn:00002BC4                 assume cs:_text$mn
.text$mn:00002BC4                 ;org 2BC4h
.text$mn:00002BC4 ; COMDAT (pick any)
.text$mn:00002BC4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002BC4
.text$mn:00002BC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BC4
.text$mn:00002BC4 ; Attributes: bp-based frame
.text$mn:00002BC4
.text$mn:00002BC4 ; class std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>> && __cdecl std::forward<class std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>>(class std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>> &)
.text$mn:00002BC4                 public ??$forward@V?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@YA$$QAV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@0@AAV10@@Z
.text$mn:00002BC4 ??$forward@V?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@YA$$QAV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@0@AAV10@@Z proc near
.text$mn:00002BC4                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>(std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>> &&)+52p
.text$mn:00002BC4
.text$mn:00002BC4 arg_0           = dword ptr  8
.text$mn:00002BC4
.text$mn:00002BC4                 push    ebp
.text$mn:00002BC5                 mov     ebp, esp
.text$mn:00002BC7                 mov     eax, [ebp+arg_0]
.text$mn:00002BCA                 pop     ebp
.text$mn:00002BCB                 retn
.text$mn:00002BCB ??$forward@V?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@YA$$QAV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@0@AAV10@@Z endp
.text$mn:00002BCB
.text$mn:00002BCB _text$mn        ends
.text$mn:00002BCB
.text$mn:00002BCC ; ===========================================================================
.text$mn:00002BCC
.text$mn:00002BCC ; Segment type: Pure code
.text$mn:00002BCC ; Segment permissions: Read/Execute
.text$mn:00002BCC _text$mn        segment para public 'CODE' use32
.text$mn:00002BCC                 assume cs:_text$mn
.text$mn:00002BCC                 ;org 2BCCh
.text$mn:00002BCC ; COMDAT (pick any)
.text$mn:00002BCC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002BCC
.text$mn:00002BCC ; =============== S U B R O U T I N E =======================================
.text$mn:00002BCC
.text$mn:00002BCC ; Attributes: bp-based frame
.text$mn:00002BCC
.text$mn:00002BCC ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:00002BCC                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00002BCC ??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:00002BCC                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>> const &)+2Dp
.text$mn:00002BCC
.text$mn:00002BCC var_10          = dword ptr -10h
.text$mn:00002BCC var_C           = dword ptr -0Ch
.text$mn:00002BCC var_4           = dword ptr -4
.text$mn:00002BCC arg_0           = dword ptr  8
.text$mn:00002BCC
.text$mn:00002BCC                 push    ebp
.text$mn:00002BCD                 mov     ebp, esp
.text$mn:00002BCF                 push    0FFFFFFFFh
.text$mn:00002BD1                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00002BD6                 mov     eax, large fs:0
.text$mn:00002BDC                 push    eax
.text$mn:00002BDD                 push    ecx
.text$mn:00002BDE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002BE3                 xor     eax, ebp
.text$mn:00002BE5                 push    eax
.text$mn:00002BE6                 lea     eax, [ebp+var_C]
.text$mn:00002BE9                 mov     large fs:0, eax
.text$mn:00002BEF                 mov     [ebp+var_10], ecx
.text$mn:00002BF2                 mov     eax, [ebp+arg_0]
.text$mn:00002BF5                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00002BF6                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002BF9                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:00002BFE                 mov     [ebp+var_4], 0
.text$mn:00002C05                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002C0C                 mov     eax, [ebp+var_10]
.text$mn:00002C0F                 mov     ecx, [ebp+var_C]
.text$mn:00002C12                 mov     large fs:0, ecx
.text$mn:00002C19                 pop     ecx
.text$mn:00002C1A                 mov     esp, ebp
.text$mn:00002C1C                 pop     ebp
.text$mn:00002C1D                 retn    4
.text$mn:00002C1D ??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:00002C1D
.text$mn:00002C1D _text$mn        ends
.text$mn:00002C1D
.text$x:00002C20 ; ===========================================================================
.text$x:00002C20
.text$x:00002C20 ; Segment type: Pure code
.text$x:00002C20 ; Segment permissions: Read/Execute
.text$x:00002C20 _text$x         segment para public 'CODE' use32
.text$x:00002C20                 assume cs:_text$x
.text$x:00002C20                 ;org 2C20h
.text$x:00002C20 ; COMDAT (pick associative to section at 2BCC)
.text$x:00002C20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002C20
.text$x:00002C20 ; =============== S U B R O U T I N E =======================================
.text$x:00002C20
.text$x:00002C20
.text$x:00002C20 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:00002C20                                         ; DATA XREF: .xdata$x:0000694Co
.text$x:00002C20                 mov     ecx, [ebp-10h]  ; this
.text$x:00002C23                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00002C23 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:00002C23
.text$x:00002C28
.text$x:00002C28 ; =============== S U B R O U T I N E =======================================
.text$x:00002C28
.text$x:00002C28
.text$x:00002C28 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:00002C28                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12> const &)+5o
.text$x:00002C28
.text$x:00002C28 arg_4           = dword ptr  8
.text$x:00002C28
.text$x:00002C28                 mov     edx, [esp+arg_4]
.text$x:00002C2C                 lea     eax, [edx+0Ch]
.text$x:00002C2F                 mov     ecx, [edx-8]
.text$x:00002C32                 xor     ecx, eax
.text$x:00002C34                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002C39                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:00002C3E                 jmp     ___CxxFrameHandler3
.text$x:00002C3E __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:00002C3E
.text$x:00002C3E ; ---------------------------------------------------------------------------
.text$x:00002C43                 align 4
.text$x:00002C43 _text$x         ends
.text$x:00002C43
.text$mn:00002C44 ; ===========================================================================
.text$mn:00002C44
.text$mn:00002C44 ; Segment type: Pure code
.text$mn:00002C44 ; Segment permissions: Read/Execute
.text$mn:00002C44 _text$mn        segment para public 'CODE' use32
.text$mn:00002C44                 assume cs:_text$mn
.text$mn:00002C44                 ;org 2C44h
.text$mn:00002C44 ; COMDAT (pick any)
.text$mn:00002C44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002C44
.text$mn:00002C44 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C44
.text$mn:00002C44 ; Attributes: bp-based frame
.text$mn:00002C44
.text$mn:00002C44 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, char, int, char const *, char const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, char, int, char const *, char const &, struct std::_Iterator_base12>(void)
.text$mn:00002C44                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00002C44 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00002C44                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(char const *,std::_Container_base12 const *)+29p
.text$mn:00002C44
.text$mn:00002C44 var_10          = dword ptr -10h
.text$mn:00002C44 var_C           = dword ptr -0Ch
.text$mn:00002C44 var_4           = dword ptr -4
.text$mn:00002C44
.text$mn:00002C44                 push    ebp
.text$mn:00002C45                 mov     ebp, esp
.text$mn:00002C47                 push    0FFFFFFFFh
.text$mn:00002C49                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00002C4E                 mov     eax, large fs:0
.text$mn:00002C54                 push    eax
.text$mn:00002C55                 push    ecx
.text$mn:00002C56                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002C5B                 xor     eax, ebp
.text$mn:00002C5D                 push    eax
.text$mn:00002C5E                 lea     eax, [ebp+var_C]
.text$mn:00002C61                 mov     large fs:0, eax
.text$mn:00002C67                 mov     [ebp+var_10], ecx
.text$mn:00002C6A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002C6D                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:00002C72                 mov     [ebp+var_4], 0
.text$mn:00002C79                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002C80                 mov     eax, [ebp+var_10]
.text$mn:00002C83                 mov     ecx, [ebp+var_C]
.text$mn:00002C86                 mov     large fs:0, ecx
.text$mn:00002C8D                 pop     ecx
.text$mn:00002C8E                 mov     esp, ebp
.text$mn:00002C90                 pop     ebp
.text$mn:00002C91                 retn
.text$mn:00002C91 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00002C91
.text$mn:00002C91 ; ---------------------------------------------------------------------------
.text$mn:00002C92                 align 4
.text$mn:00002C92 _text$mn        ends
.text$mn:00002C92
.text$x:00002C94 ; ===========================================================================
.text$x:00002C94
.text$x:00002C94 ; Segment type: Pure code
.text$x:00002C94 ; Segment permissions: Read/Execute
.text$x:00002C94 _text$x         segment para public 'CODE' use32
.text$x:00002C94                 assume cs:_text$x
.text$x:00002C94                 ;org 2C94h
.text$x:00002C94 ; COMDAT (pick associative to section at 2C44)
.text$x:00002C94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002C94
.text$x:00002C94 ; =============== S U B R O U T I N E =======================================
.text$x:00002C94
.text$x:00002C94
.text$x:00002C94 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00002C94                                         ; DATA XREF: .xdata$x:000068F4o
.text$x:00002C94                 mov     ecx, [ebp-10h]  ; this
.text$x:00002C97                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00002C97 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00002C97
.text$x:00002C9C
.text$x:00002C9C ; =============== S U B R O U T I N E =======================================
.text$x:00002C9C
.text$x:00002C9C
.text$x:00002C9C __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00002C9C                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>(void)+5o
.text$x:00002C9C
.text$x:00002C9C arg_4           = dword ptr  8
.text$x:00002C9C
.text$x:00002C9C                 mov     edx, [esp+arg_4]
.text$x:00002CA0                 lea     eax, [edx+0Ch]
.text$x:00002CA3                 mov     ecx, [edx-8]
.text$x:00002CA6                 xor     ecx, eax
.text$x:00002CA8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002CAD                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ
.text$x:00002CB2                 jmp     ___CxxFrameHandler3
.text$x:00002CB2 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00002CB2
.text$x:00002CB2 ; ---------------------------------------------------------------------------
.text$x:00002CB7                 align 4
.text$x:00002CB7 _text$x         ends
.text$x:00002CB7
.text$mn:00002CB8 ; ===========================================================================
.text$mn:00002CB8
.text$mn:00002CB8 ; Segment type: Pure code
.text$mn:00002CB8 ; Segment permissions: Read/Execute
.text$mn:00002CB8 _text$mn        segment para public 'CODE' use32
.text$mn:00002CB8                 assume cs:_text$mn
.text$mn:00002CB8                 ;org 2CB8h
.text$mn:00002CB8 ; COMDAT (pick any)
.text$mn:00002CB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002CB8
.text$mn:00002CB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CB8
.text$mn:00002CB8 ; Attributes: bp-based frame
.text$mn:00002CB8
.text$mn:00002CB8 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00002CB8                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00002CB8 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00002CB8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00002CB8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p
.text$mn:00002CB8
.text$mn:00002CB8 var_10          = dword ptr -10h
.text$mn:00002CB8 var_C           = dword ptr -0Ch
.text$mn:00002CB8 var_4           = dword ptr -4
.text$mn:00002CB8
.text$mn:00002CB8                 push    ebp
.text$mn:00002CB9                 mov     ebp, esp
.text$mn:00002CBB                 push    0FFFFFFFFh
.text$mn:00002CBD                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00002CC2                 mov     eax, large fs:0
.text$mn:00002CC8                 push    eax
.text$mn:00002CC9                 push    ecx
.text$mn:00002CCA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002CCF                 xor     eax, ebp
.text$mn:00002CD1                 push    eax
.text$mn:00002CD2                 lea     eax, [ebp+var_C]
.text$mn:00002CD5                 mov     large fs:0, eax
.text$mn:00002CDB                 mov     [ebp+var_10], ecx
.text$mn:00002CDE                 mov     ecx, [ebp+var_10]
.text$mn:00002CE1                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00002CE6                 mov     [ebp+var_4], 0
.text$mn:00002CED                 mov     ecx, [ebp+var_10]
.text$mn:00002CF0                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00002CF5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002CFC                 mov     eax, [ebp+var_10]
.text$mn:00002CFF                 mov     ecx, [ebp+var_C]
.text$mn:00002D02                 mov     large fs:0, ecx
.text$mn:00002D09                 pop     ecx
.text$mn:00002D0A                 mov     esp, ebp
.text$mn:00002D0C                 pop     ebp
.text$mn:00002D0D                 retn    4
.text$mn:00002D0D ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00002D0D
.text$mn:00002D0D _text$mn        ends
.text$mn:00002D0D
.text$x:00002D10 ; ===========================================================================
.text$x:00002D10
.text$x:00002D10 ; Segment type: Pure code
.text$x:00002D10 ; Segment permissions: Read/Execute
.text$x:00002D10 _text$x         segment para public 'CODE' use32
.text$x:00002D10                 assume cs:_text$x
.text$x:00002D10                 ;org 2D10h
.text$x:00002D10 ; COMDAT (pick associative to section at 2CB8)
.text$x:00002D10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002D10
.text$x:00002D10 ; =============== S U B R O U T I N E =======================================
.text$x:00002D10
.text$x:00002D10
.text$x:00002D10 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00002D10                                         ; DATA XREF: .xdata$x:00006238o
.text$x:00002D10                 mov     ecx, [ebp-10h]
.text$x:00002D13                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00002D13 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00002D13
.text$x:00002D18
.text$x:00002D18 ; =============== S U B R O U T I N E =======================================
.text$x:00002D18
.text$x:00002D18
.text$x:00002D18 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00002D18                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00002D18
.text$x:00002D18 arg_4           = dword ptr  8
.text$x:00002D18
.text$x:00002D18                 mov     edx, [esp+arg_4]
.text$x:00002D1C                 lea     eax, [edx+0Ch]
.text$x:00002D1F                 mov     ecx, [edx-8]
.text$x:00002D22                 xor     ecx, eax
.text$x:00002D24                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002D29                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00002D2E                 jmp     ___CxxFrameHandler3
.text$x:00002D2E __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00002D2E
.text$x:00002D2E ; ---------------------------------------------------------------------------
.text$x:00002D33                 align 4
.text$x:00002D33 _text$x         ends
.text$x:00002D33
.text$mn:00002D34 ; ===========================================================================
.text$mn:00002D34
.text$mn:00002D34 ; Segment type: Pure code
.text$mn:00002D34 ; Segment permissions: Read/Execute
.text$mn:00002D34 _text$mn        segment para public 'CODE' use32
.text$mn:00002D34                 assume cs:_text$mn
.text$mn:00002D34                 ;org 2D34h
.text$mn:00002D34 ; COMDAT (pick any)
.text$mn:00002D34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002D34
.text$mn:00002D34 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D34
.text$mn:00002D34 ; Attributes: bp-based frame
.text$mn:00002D34
.text$mn:00002D34 ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(struct std::_Iterator_base12 *)
.text$mn:00002D34                 public ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00002D34 ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00002D34                                         ; CODE XREF: std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::_String_iterator<std::_String_val<std::_Simple_types<char>>>(std::_String_iterator<std::_String_val<std::_Simple_types<char>>> const &)+2Dp
.text$mn:00002D34                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::insert(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>,char)+5Bp ...
.text$mn:00002D34
.text$mn:00002D34 var_10          = dword ptr -10h
.text$mn:00002D34 var_C           = dword ptr -0Ch
.text$mn:00002D34 var_4           = dword ptr -4
.text$mn:00002D34 arg_0           = dword ptr  8
.text$mn:00002D34
.text$mn:00002D34                 push    ebp
.text$mn:00002D35                 mov     ebp, esp
.text$mn:00002D37                 push    0FFFFFFFFh
.text$mn:00002D39                 push    offset __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00002D3E                 mov     eax, large fs:0
.text$mn:00002D44                 push    eax
.text$mn:00002D45                 push    ecx
.text$mn:00002D46                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002D4B                 xor     eax, ebp
.text$mn:00002D4D                 push    eax
.text$mn:00002D4E                 lea     eax, [ebp+var_C]
.text$mn:00002D51                 mov     large fs:0, eax
.text$mn:00002D57                 mov     [ebp+var_10], ecx
.text$mn:00002D5A                 mov     eax, [ebp+arg_0]
.text$mn:00002D5D                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00002D5E                 mov     ecx, [ebp+var_10]
.text$mn:00002D61                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12> const &)
.text$mn:00002D66                 mov     [ebp+var_4], 0
.text$mn:00002D6D                 mov     ecx, [ebp+var_10]
.text$mn:00002D70                 mov     edx, [ebp+arg_0]
.text$mn:00002D73                 mov     eax, [edx+8]
.text$mn:00002D76                 mov     [ecx+8], eax
.text$mn:00002D79                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002D80                 mov     eax, [ebp+var_10]
.text$mn:00002D83                 mov     ecx, [ebp+var_C]
.text$mn:00002D86                 mov     large fs:0, ecx
.text$mn:00002D8D                 pop     ecx
.text$mn:00002D8E                 mov     esp, ebp
.text$mn:00002D90                 pop     ebp
.text$mn:00002D91                 retn    4
.text$mn:00002D91 ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00002D91
.text$mn:00002D91 _text$mn        ends
.text$mn:00002D91
.text$x:00002D94 ; ===========================================================================
.text$x:00002D94
.text$x:00002D94 ; Segment type: Pure code
.text$x:00002D94 ; Segment permissions: Read/Execute
.text$x:00002D94 _text$x         segment para public 'CODE' use32
.text$x:00002D94                 assume cs:_text$x
.text$x:00002D94                 ;org 2D94h
.text$x:00002D94 ; COMDAT (pick associative to section at 2D34)
.text$x:00002D94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002D94
.text$x:00002D94 ; =============== S U B R O U T I N E =======================================
.text$x:00002D94
.text$x:00002D94
.text$x:00002D94 __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00002D94                                         ; DATA XREF: .xdata$x:000069D0o
.text$x:00002D94                 mov     ecx, [ebp-10h]
.text$x:00002D97                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>(void)
.text$x:00002D97 __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00002D97
.text$x:00002D9C
.text$x:00002D9C ; =============== S U B R O U T I N E =======================================
.text$x:00002D9C
.text$x:00002D9C
.text$x:00002D9C __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00002D9C                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>> const &)+5o
.text$x:00002D9C
.text$x:00002D9C arg_4           = dword ptr  8
.text$x:00002D9C
.text$x:00002D9C                 mov     edx, [esp+arg_4]
.text$x:00002DA0                 lea     eax, [edx+0Ch]
.text$x:00002DA3                 mov     ecx, [edx-8]
.text$x:00002DA6                 xor     ecx, eax
.text$x:00002DA8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002DAD                 mov     eax, offset __ehfuncinfo$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:00002DB2                 jmp     ___CxxFrameHandler3
.text$x:00002DB2 __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00002DB2
.text$x:00002DB2 ; ---------------------------------------------------------------------------
.text$x:00002DB7                 align 4
.text$x:00002DB7 _text$x         ends
.text$x:00002DB7
.text$mn:00002DB8 ; ===========================================================================
.text$mn:00002DB8
.text$mn:00002DB8 ; Segment type: Pure code
.text$mn:00002DB8 ; Segment permissions: Read/Execute
.text$mn:00002DB8 _text$mn        segment para public 'CODE' use32
.text$mn:00002DB8                 assume cs:_text$mn
.text$mn:00002DB8                 ;org 2DB8h
.text$mn:00002DB8 ; COMDAT (pick any)
.text$mn:00002DB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002DB8
.text$mn:00002DB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DB8
.text$mn:00002DB8 ; Attributes: bp-based frame
.text$mn:00002DB8
.text$mn:00002DB8 ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(int, struct std::_Container_base12 *)
.text$mn:00002DB8                 public ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z
.text$mn:00002DB8 ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z proc near
.text$mn:00002DB8                                         ; CODE XREF: std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::_String_iterator<std::_String_val<std::_Simple_types<char>>>(char *,std::_Container_base12 const *)+31p
.text$mn:00002DB8
.text$mn:00002DB8 var_10          = dword ptr -10h
.text$mn:00002DB8 var_C           = dword ptr -0Ch
.text$mn:00002DB8 var_4           = dword ptr -4
.text$mn:00002DB8 arg_0           = dword ptr  8
.text$mn:00002DB8 arg_4           = dword ptr  0Ch
.text$mn:00002DB8
.text$mn:00002DB8                 push    ebp
.text$mn:00002DB9                 mov     ebp, esp
.text$mn:00002DBB                 push    0FFFFFFFFh
.text$mn:00002DBD                 push    offset __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z
.text$mn:00002DC2                 mov     eax, large fs:0
.text$mn:00002DC8                 push    eax
.text$mn:00002DC9                 push    ecx
.text$mn:00002DCA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002DCF                 xor     eax, ebp
.text$mn:00002DD1                 push    eax
.text$mn:00002DD2                 lea     eax, [ebp+var_C]
.text$mn:00002DD5                 mov     large fs:0, eax
.text$mn:00002DDB                 mov     [ebp+var_10], ecx
.text$mn:00002DDE                 mov     ecx, [ebp+var_10]
.text$mn:00002DE1                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>(void)
.text$mn:00002DE6                 mov     [ebp+var_4], 0
.text$mn:00002DED                 mov     eax, [ebp+arg_4]
.text$mn:00002DF0                 push    eax             ; struct std::_Container_base12 *
.text$mn:00002DF1                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002DF4                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:00002DF9                 mov     ecx, [ebp+var_10]
.text$mn:00002DFC                 mov     edx, [ebp+arg_0]
.text$mn:00002DFF                 mov     [ecx+8], edx
.text$mn:00002E02                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002E09                 mov     eax, [ebp+var_10]
.text$mn:00002E0C                 mov     ecx, [ebp+var_C]
.text$mn:00002E0F                 mov     large fs:0, ecx
.text$mn:00002E16                 pop     ecx
.text$mn:00002E17                 mov     esp, ebp
.text$mn:00002E19                 pop     ebp
.text$mn:00002E1A                 retn    8
.text$mn:00002E1A ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z endp
.text$mn:00002E1A
.text$mn:00002E1A ; ---------------------------------------------------------------------------
.text$mn:00002E1D                 align 10h
.text$mn:00002E1D _text$mn        ends
.text$mn:00002E1D
.text$x:00002E20 ; ===========================================================================
.text$x:00002E20
.text$x:00002E20 ; Segment type: Pure code
.text$x:00002E20 ; Segment permissions: Read/Execute
.text$x:00002E20 _text$x         segment para public 'CODE' use32
.text$x:00002E20                 assume cs:_text$x
.text$x:00002E20                 ;org 2E20h
.text$x:00002E20 ; COMDAT (pick associative to section at 2DB8)
.text$x:00002E20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002E20
.text$x:00002E20 ; =============== S U B R O U T I N E =======================================
.text$x:00002E20
.text$x:00002E20
.text$x:00002E20 __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z$0 proc near
.text$x:00002E20                                         ; DATA XREF: .xdata$x:00006978o
.text$x:00002E20                 mov     ecx, [ebp-10h]
.text$x:00002E23                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>(void)
.text$x:00002E23 __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z$0 endp
.text$x:00002E23
.text$x:00002E28
.text$x:00002E28 ; =============== S U B R O U T I N E =======================================
.text$x:00002E28
.text$x:00002E28
.text$x:00002E28 __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z proc near
.text$x:00002E28                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(char const *,std::_Container_base12 const *)+5o
.text$x:00002E28
.text$x:00002E28 arg_4           = dword ptr  8
.text$x:00002E28
.text$x:00002E28                 mov     edx, [esp+arg_4]
.text$x:00002E2C                 lea     eax, [edx+0Ch]
.text$x:00002E2F                 mov     ecx, [edx-8]
.text$x:00002E32                 xor     ecx, eax
.text$x:00002E34                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002E39                 mov     eax, offset __ehfuncinfo$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z
.text$x:00002E3E                 jmp     ___CxxFrameHandler3
.text$x:00002E3E __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z endp
.text$x:00002E3E
.text$x:00002E3E ; ---------------------------------------------------------------------------
.text$x:00002E43                 align 4
.text$x:00002E43 _text$x         ends
.text$x:00002E43
.text$mn:00002E44 ; ===========================================================================
.text$mn:00002E44
.text$mn:00002E44 ; Segment type: Pure code
.text$mn:00002E44 ; Segment permissions: Read/Execute
.text$mn:00002E44 _text$mn        segment para public 'CODE' use32
.text$mn:00002E44                 assume cs:_text$mn
.text$mn:00002E44                 ;org 2E44h
.text$mn:00002E44 ; COMDAT (pick any)
.text$mn:00002E44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002E44
.text$mn:00002E44 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E44
.text$mn:00002E44 ; Attributes: bp-based frame
.text$mn:00002E44
.text$mn:00002E44 ; int __stdcall std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::_String_iterator<std::_String_val<std::_Simple_types<char>>>(struct std::_Iterator_base12 *)
.text$mn:00002E44                 public ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00002E44 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00002E44                                         ; CODE XREF: std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::operator+(int)+36p
.text$mn:00002E44                                         ; std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::operator+(int)+52p
.text$mn:00002E44
.text$mn:00002E44 var_10          = dword ptr -10h
.text$mn:00002E44 var_C           = dword ptr -0Ch
.text$mn:00002E44 var_4           = dword ptr -4
.text$mn:00002E44 arg_0           = dword ptr  8
.text$mn:00002E44
.text$mn:00002E44                 push    ebp
.text$mn:00002E45                 mov     ebp, esp
.text$mn:00002E47                 push    0FFFFFFFFh
.text$mn:00002E49                 push    offset __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00002E4E                 mov     eax, large fs:0
.text$mn:00002E54                 push    eax
.text$mn:00002E55                 push    ecx
.text$mn:00002E56                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002E5B                 xor     eax, ebp
.text$mn:00002E5D                 push    eax
.text$mn:00002E5E                 lea     eax, [ebp+var_C]
.text$mn:00002E61                 mov     large fs:0, eax
.text$mn:00002E67                 mov     [ebp+var_10], ecx
.text$mn:00002E6A                 mov     eax, [ebp+arg_0]
.text$mn:00002E6D                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00002E6E                 mov     ecx, [ebp+var_10]
.text$mn:00002E71                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>> const &)
.text$mn:00002E76                 mov     [ebp+var_4], 0
.text$mn:00002E7D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002E84                 mov     eax, [ebp+var_10]
.text$mn:00002E87                 mov     ecx, [ebp+var_C]
.text$mn:00002E8A                 mov     large fs:0, ecx
.text$mn:00002E91                 pop     ecx
.text$mn:00002E92                 mov     esp, ebp
.text$mn:00002E94                 pop     ebp
.text$mn:00002E95                 retn    4
.text$mn:00002E95 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00002E95
.text$mn:00002E95 _text$mn        ends
.text$mn:00002E95
.text$x:00002E98 ; ===========================================================================
.text$x:00002E98
.text$x:00002E98 ; Segment type: Pure code
.text$x:00002E98 ; Segment permissions: Read/Execute
.text$x:00002E98 _text$x         segment para public 'CODE' use32
.text$x:00002E98                 assume cs:_text$x
.text$x:00002E98                 ;org 2E98h
.text$x:00002E98 ; COMDAT (pick associative to section at 2E44)
.text$x:00002E98                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002E98
.text$x:00002E98 ; =============== S U B R O U T I N E =======================================
.text$x:00002E98
.text$x:00002E98
.text$x:00002E98 __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00002E98                                         ; DATA XREF: .xdata$x:00006A88o
.text$x:00002E98                 mov     ecx, [ebp-10h]
.text$x:00002E9B                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$x:00002E9B __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00002E9B
.text$x:00002EA0
.text$x:00002EA0 ; =============== S U B R O U T I N E =======================================
.text$x:00002EA0
.text$x:00002EA0
.text$x:00002EA0 __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00002EA0                                         ; DATA XREF: std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::_String_iterator<std::_String_val<std::_Simple_types<char>>>(std::_String_iterator<std::_String_val<std::_Simple_types<char>>> const &)+5o
.text$x:00002EA0
.text$x:00002EA0 arg_4           = dword ptr  8
.text$x:00002EA0
.text$x:00002EA0                 mov     edx, [esp+arg_4]
.text$x:00002EA4                 lea     eax, [edx+0Ch]
.text$x:00002EA7                 mov     ecx, [edx-8]
.text$x:00002EAA                 xor     ecx, eax
.text$x:00002EAC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002EB1                 mov     eax, offset __ehfuncinfo$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:00002EB6                 jmp     ___CxxFrameHandler3
.text$x:00002EB6 __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00002EB6
.text$x:00002EB6 ; ---------------------------------------------------------------------------
.text$x:00002EBB                 align 4
.text$x:00002EBB _text$x         ends
.text$x:00002EBB
.text$mn:00002EBC ; ===========================================================================
.text$mn:00002EBC
.text$mn:00002EBC ; Segment type: Pure code
.text$mn:00002EBC ; Segment permissions: Read/Execute
.text$mn:00002EBC _text$mn        segment para public 'CODE' use32
.text$mn:00002EBC                 assume cs:_text$mn
.text$mn:00002EBC                 ;org 2EBCh
.text$mn:00002EBC ; COMDAT (pick any)
.text$mn:00002EBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002EBC
.text$mn:00002EBC ; =============== S U B R O U T I N E =======================================
.text$mn:00002EBC
.text$mn:00002EBC ; Attributes: bp-based frame
.text$mn:00002EBC
.text$mn:00002EBC ; int __stdcall std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::_String_iterator<std::_String_val<std::_Simple_types<char>>>(int, struct std::_Container_base12 *)
.text$mn:00002EBC                 public ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z
.text$mn:00002EBC ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z proc near
.text$mn:00002EBC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::begin(void)+3Fp
.text$mn:00002EBC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::end(void)+45p
.text$mn:00002EBC
.text$mn:00002EBC var_10          = dword ptr -10h
.text$mn:00002EBC var_C           = dword ptr -0Ch
.text$mn:00002EBC var_4           = dword ptr -4
.text$mn:00002EBC arg_0           = dword ptr  8
.text$mn:00002EBC arg_4           = dword ptr  0Ch
.text$mn:00002EBC
.text$mn:00002EBC                 push    ebp
.text$mn:00002EBD                 mov     ebp, esp
.text$mn:00002EBF                 push    0FFFFFFFFh
.text$mn:00002EC1                 push    offset __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z
.text$mn:00002EC6                 mov     eax, large fs:0
.text$mn:00002ECC                 push    eax
.text$mn:00002ECD                 push    ecx
.text$mn:00002ECE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002ED3                 xor     eax, ebp
.text$mn:00002ED5                 push    eax
.text$mn:00002ED6                 lea     eax, [ebp+var_C]
.text$mn:00002ED9                 mov     large fs:0, eax
.text$mn:00002EDF                 mov     [ebp+var_10], ecx
.text$mn:00002EE2                 mov     eax, [ebp+arg_4]
.text$mn:00002EE5                 push    eax             ; struct std::_Container_base12 *
.text$mn:00002EE6                 mov     ecx, [ebp+arg_0]
.text$mn:00002EE9                 push    ecx             ; int
.text$mn:00002EEA                 mov     ecx, [ebp+var_10]
.text$mn:00002EED                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(char const *,std::_Container_base12 const *)
.text$mn:00002EF2                 mov     [ebp+var_4], 0
.text$mn:00002EF9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002F00                 mov     eax, [ebp+var_10]
.text$mn:00002F03                 mov     ecx, [ebp+var_C]
.text$mn:00002F06                 mov     large fs:0, ecx
.text$mn:00002F0D                 pop     ecx
.text$mn:00002F0E                 mov     esp, ebp
.text$mn:00002F10                 pop     ebp
.text$mn:00002F11                 retn    8
.text$mn:00002F11 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z endp
.text$mn:00002F11
.text$mn:00002F11 _text$mn        ends
.text$mn:00002F11
.text$x:00002F14 ; ===========================================================================
.text$x:00002F14
.text$x:00002F14 ; Segment type: Pure code
.text$x:00002F14 ; Segment permissions: Read/Execute
.text$x:00002F14 _text$x         segment para public 'CODE' use32
.text$x:00002F14                 assume cs:_text$x
.text$x:00002F14                 ;org 2F14h
.text$x:00002F14 ; COMDAT (pick associative to section at 2EBC)
.text$x:00002F14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002F14
.text$x:00002F14 ; =============== S U B R O U T I N E =======================================
.text$x:00002F14
.text$x:00002F14
.text$x:00002F14 __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z$0 proc near
.text$x:00002F14                                         ; DATA XREF: .xdata$x:000069FCo
.text$x:00002F14                 mov     ecx, [ebp-10h]
.text$x:00002F17                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$x:00002F17 __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z$0 endp
.text$x:00002F17
.text$x:00002F1C
.text$x:00002F1C ; =============== S U B R O U T I N E =======================================
.text$x:00002F1C
.text$x:00002F1C
.text$x:00002F1C __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z proc near
.text$x:00002F1C                                         ; DATA XREF: std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::_String_iterator<std::_String_val<std::_Simple_types<char>>>(char *,std::_Container_base12 const *)+5o
.text$x:00002F1C
.text$x:00002F1C arg_4           = dword ptr  8
.text$x:00002F1C
.text$x:00002F1C                 mov     edx, [esp+arg_4]
.text$x:00002F20                 lea     eax, [edx+0Ch]
.text$x:00002F23                 mov     ecx, [edx-8]
.text$x:00002F26                 xor     ecx, eax
.text$x:00002F28                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F2D                 mov     eax, offset __ehfuncinfo$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z
.text$x:00002F32                 jmp     ___CxxFrameHandler3
.text$x:00002F32 __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z endp
.text$x:00002F32
.text$x:00002F32 ; ---------------------------------------------------------------------------
.text$x:00002F37                 align 4
.text$x:00002F37 _text$x         ends
.text$x:00002F37
.text$mn:00002F38 ; ===========================================================================
.text$mn:00002F38
.text$mn:00002F38 ; Segment type: Pure code
.text$mn:00002F38 ; Segment permissions: Read/Execute
.text$mn:00002F38 _text$mn        segment para public 'CODE' use32
.text$mn:00002F38                 assume cs:_text$mn
.text$mn:00002F38                 ;org 2F38h
.text$mn:00002F38 ; COMDAT (pick any)
.text$mn:00002F38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002F38
.text$mn:00002F38 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F38
.text$mn:00002F38 ; Attributes: bp-based frame
.text$mn:00002F38
.text$mn:00002F38 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00002F38                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002F38 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00002F38                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00002F38
.text$mn:00002F38 var_10          = dword ptr -10h
.text$mn:00002F38 var_C           = dword ptr -0Ch
.text$mn:00002F38 var_4           = dword ptr -4
.text$mn:00002F38
.text$mn:00002F38                 push    ebp
.text$mn:00002F39                 mov     ebp, esp
.text$mn:00002F3B                 push    0FFFFFFFFh
.text$mn:00002F3D                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002F42                 mov     eax, large fs:0
.text$mn:00002F48                 push    eax
.text$mn:00002F49                 push    ecx
.text$mn:00002F4A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002F4F                 xor     eax, ebp
.text$mn:00002F51                 push    eax
.text$mn:00002F52                 lea     eax, [ebp+var_C]
.text$mn:00002F55                 mov     large fs:0, eax
.text$mn:00002F5B                 mov     [ebp+var_10], ecx
.text$mn:00002F5E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002F61                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00002F66                 mov     [ebp+var_4], 0
.text$mn:00002F6D                 mov     eax, [ebp+var_10]
.text$mn:00002F70                 mov     dword ptr [eax+14h], 0
.text$mn:00002F77                 mov     ecx, [ebp+var_10]
.text$mn:00002F7A                 mov     dword ptr [ecx+18h], 0
.text$mn:00002F81                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002F88                 mov     eax, [ebp+var_10]
.text$mn:00002F8B                 mov     ecx, [ebp+var_C]
.text$mn:00002F8E                 mov     large fs:0, ecx
.text$mn:00002F95                 pop     ecx
.text$mn:00002F96                 mov     esp, ebp
.text$mn:00002F98                 pop     ebp
.text$mn:00002F99                 retn
.text$mn:00002F99 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00002F99
.text$mn:00002F99 ; ---------------------------------------------------------------------------
.text$mn:00002F9A                 align 4
.text$mn:00002F9A _text$mn        ends
.text$mn:00002F9A
.text$x:00002F9C ; ===========================================================================
.text$x:00002F9C
.text$x:00002F9C ; Segment type: Pure code
.text$x:00002F9C ; Segment permissions: Read/Execute
.text$x:00002F9C _text$x         segment para public 'CODE' use32
.text$x:00002F9C                 assume cs:_text$x
.text$x:00002F9C                 ;org 2F9Ch
.text$x:00002F9C ; COMDAT (pick associative to section at 2F38)
.text$x:00002F9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002F9C
.text$x:00002F9C ; =============== S U B R O U T I N E =======================================
.text$x:00002F9C
.text$x:00002F9C
.text$x:00002F9C __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00002F9C                                         ; DATA XREF: .xdata$x:000061E0o
.text$x:00002F9C                 mov     ecx, [ebp-10h]  ; this
.text$x:00002F9F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00002F9F __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00002F9F
.text$x:00002FA4
.text$x:00002FA4 ; =============== S U B R O U T I N E =======================================
.text$x:00002FA4
.text$x:00002FA4
.text$x:00002FA4 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00002FA4                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00002FA4
.text$x:00002FA4 arg_4           = dword ptr  8
.text$x:00002FA4
.text$x:00002FA4                 mov     edx, [esp+arg_4]
.text$x:00002FA8                 lea     eax, [edx+0Ch]
.text$x:00002FAB                 mov     ecx, [edx-8]
.text$x:00002FAE                 xor     ecx, eax
.text$x:00002FB0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002FB5                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00002FBA                 jmp     ___CxxFrameHandler3
.text$x:00002FBA __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00002FBA
.text$x:00002FBA ; ---------------------------------------------------------------------------
.text$x:00002FBF                 align 10h
.text$x:00002FBF _text$x         ends
.text$x:00002FBF
.text$mn:00002FC0 ; ===========================================================================
.text$mn:00002FC0
.text$mn:00002FC0 ; Segment type: Pure code
.text$mn:00002FC0 ; Segment permissions: Read/Execute
.text$mn:00002FC0 _text$mn        segment para public 'CODE' use32
.text$mn:00002FC0                 assume cs:_text$mn
.text$mn:00002FC0                 ;org 2FC0h
.text$mn:00002FC0 ; COMDAT (pick any)
.text$mn:00002FC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002FC0
.text$mn:00002FC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002FC0
.text$mn:00002FC0 ; Attributes: bp-based frame
.text$mn:00002FC0
.text$mn:00002FC0 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>>::_Vector_alloc<0, struct std::_Vec_base_types<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>>(class std::allocator<struct std::pair<int, int>> const &)
.text$mn:00002FC0                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@HH@std@@@1@@Z
.text$mn:00002FC0 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@HH@std@@@1@@Z proc near
.text$mn:00002FC0                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>(std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>> &&)+38p
.text$mn:00002FC0                                         ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>(void)+34p
.text$mn:00002FC0
.text$mn:00002FC0 var_10          = dword ptr -10h
.text$mn:00002FC0 var_C           = dword ptr -0Ch
.text$mn:00002FC0 var_4           = dword ptr -4
.text$mn:00002FC0
.text$mn:00002FC0                 push    ebp
.text$mn:00002FC1                 mov     ebp, esp
.text$mn:00002FC3                 push    0FFFFFFFFh
.text$mn:00002FC5                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@HH@std@@@1@@Z
.text$mn:00002FCA                 mov     eax, large fs:0
.text$mn:00002FD0                 push    eax
.text$mn:00002FD1                 push    ecx
.text$mn:00002FD2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002FD7                 xor     eax, ebp
.text$mn:00002FD9                 push    eax
.text$mn:00002FDA                 lea     eax, [ebp+var_C]
.text$mn:00002FDD                 mov     large fs:0, eax
.text$mn:00002FE3                 mov     [ebp+var_10], ecx
.text$mn:00002FE6                 mov     ecx, [ebp+var_10]
.text$mn:00002FE9                 call    ??0?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::pair<int,int>>>::_Vector_val<std::_Simple_types<std::pair<int,int>>>(void)
.text$mn:00002FEE                 mov     [ebp+var_4], 0
.text$mn:00002FF5                 mov     ecx, [ebp+var_10]
.text$mn:00002FF8                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Alloc_proxy(void)
.text$mn:00002FFD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003004                 mov     eax, [ebp+var_10]
.text$mn:00003007                 mov     ecx, [ebp+var_C]
.text$mn:0000300A                 mov     large fs:0, ecx
.text$mn:00003011                 pop     ecx
.text$mn:00003012                 mov     esp, ebp
.text$mn:00003014                 pop     ebp
.text$mn:00003015                 retn    4
.text$mn:00003015 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@HH@std@@@1@@Z endp
.text$mn:00003015
.text$mn:00003015 _text$mn        ends
.text$mn:00003015
.text$x:00003018 ; ===========================================================================
.text$x:00003018
.text$x:00003018 ; Segment type: Pure code
.text$x:00003018 ; Segment permissions: Read/Execute
.text$x:00003018 _text$x         segment para public 'CODE' use32
.text$x:00003018                 assume cs:_text$x
.text$x:00003018                 ;org 3018h
.text$x:00003018 ; COMDAT (pick associative to section at 2FC0)
.text$x:00003018                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003018
.text$x:00003018 ; =============== S U B R O U T I N E =======================================
.text$x:00003018
.text$x:00003018
.text$x:00003018 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@HH@std@@@1@@Z$0 proc near
.text$x:00003018                                         ; DATA XREF: .xdata$x:00006794o
.text$x:00003018                 mov     ecx, [ebp-10h]
.text$x:0000301B                 jmp     ??1?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::pair<int,int>>>::~_Vector_val<std::_Simple_types<std::pair<int,int>>>(void)
.text$x:0000301B __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@HH@std@@@1@@Z$0 endp
.text$x:0000301B
.text$x:00003020
.text$x:00003020 ; =============== S U B R O U T I N E =======================================
.text$x:00003020
.text$x:00003020
.text$x:00003020 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@HH@std@@@1@@Z proc near
.text$x:00003020                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>(std::allocator<std::pair<int,int>> const &)+5o
.text$x:00003020
.text$x:00003020 arg_4           = dword ptr  8
.text$x:00003020
.text$x:00003020                 mov     edx, [esp+arg_4]
.text$x:00003024                 lea     eax, [edx+0Ch]
.text$x:00003027                 mov     ecx, [edx-8]
.text$x:0000302A                 xor     ecx, eax
.text$x:0000302C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003031                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@HH@std@@@1@@Z
.text$x:00003036                 jmp     ___CxxFrameHandler3
.text$x:00003036 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@HH@std@@@1@@Z endp
.text$x:00003036
.text$x:00003036 ; ---------------------------------------------------------------------------
.text$x:0000303B                 align 4
.text$x:0000303B _text$x         ends
.text$x:0000303B
.text$mn:0000303C ; ===========================================================================
.text$mn:0000303C
.text$mn:0000303C ; Segment type: Pure code
.text$mn:0000303C ; Segment permissions: Read/Execute
.text$mn:0000303C _text$mn        segment para public 'CODE' use32
.text$mn:0000303C                 assume cs:_text$mn
.text$mn:0000303C                 ;org 303Ch
.text$mn:0000303C ; COMDAT (pick any)
.text$mn:0000303C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000303C
.text$mn:0000303C ; =============== S U B R O U T I N E =======================================
.text$mn:0000303C
.text$mn:0000303C ; Attributes: bp-based frame
.text$mn:0000303C
.text$mn:0000303C ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct std::pair<int, int>>>::_Vector_val<struct std::_Simple_types<struct std::pair<int, int>>>(void)
.text$mn:0000303C                 public ??0?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ
.text$mn:0000303C ??0?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000303C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>(std::allocator<std::pair<int,int>> const &)+29p
.text$mn:0000303C
.text$mn:0000303C var_10          = dword ptr -10h
.text$mn:0000303C var_C           = dword ptr -0Ch
.text$mn:0000303C var_4           = dword ptr -4
.text$mn:0000303C
.text$mn:0000303C                 push    ebp
.text$mn:0000303D                 mov     ebp, esp
.text$mn:0000303F                 push    0FFFFFFFFh
.text$mn:00003041                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ
.text$mn:00003046                 mov     eax, large fs:0
.text$mn:0000304C                 push    eax
.text$mn:0000304D                 push    ecx
.text$mn:0000304E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003053                 xor     eax, ebp
.text$mn:00003055                 push    eax
.text$mn:00003056                 lea     eax, [ebp+var_C]
.text$mn:00003059                 mov     large fs:0, eax
.text$mn:0000305F                 mov     [ebp+var_10], ecx
.text$mn:00003062                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003065                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000306A                 mov     [ebp+var_4], 0
.text$mn:00003071                 mov     eax, [ebp+var_10]
.text$mn:00003074                 mov     dword ptr [eax+4], 0
.text$mn:0000307B                 mov     ecx, [ebp+var_10]
.text$mn:0000307E                 mov     dword ptr [ecx+8], 0
.text$mn:00003085                 mov     edx, [ebp+var_10]
.text$mn:00003088                 mov     dword ptr [edx+0Ch], 0
.text$mn:0000308F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003096                 mov     eax, [ebp+var_10]
.text$mn:00003099                 mov     ecx, [ebp+var_C]
.text$mn:0000309C                 mov     large fs:0, ecx
.text$mn:000030A3                 pop     ecx
.text$mn:000030A4                 mov     esp, ebp
.text$mn:000030A6                 pop     ebp
.text$mn:000030A7                 retn
.text$mn:000030A7 ??0?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ endp
.text$mn:000030A7
.text$mn:000030A7 _text$mn        ends
.text$mn:000030A7
.text$x:000030A8 ; ===========================================================================
.text$x:000030A8
.text$x:000030A8 ; Segment type: Pure code
.text$x:000030A8 ; Segment permissions: Read/Execute
.text$x:000030A8 _text$x         segment para public 'CODE' use32
.text$x:000030A8                 assume cs:_text$x
.text$x:000030A8                 ;org 30A8h
.text$x:000030A8 ; COMDAT (pick associative to section at 303C)
.text$x:000030A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000030A8
.text$x:000030A8 ; =============== S U B R O U T I N E =======================================
.text$x:000030A8
.text$x:000030A8
.text$x:000030A8 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000030A8                                         ; DATA XREF: .xdata$x:0000673Co
.text$x:000030A8                 mov     ecx, [ebp-10h]  ; this
.text$x:000030AB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000030AB __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000030AB
.text$x:000030B0
.text$x:000030B0 ; =============== S U B R O U T I N E =======================================
.text$x:000030B0
.text$x:000030B0
.text$x:000030B0 __ehhandler$??0?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ proc near
.text$x:000030B0                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<std::pair<int,int>>>::_Vector_val<std::_Simple_types<std::pair<int,int>>>(void)+5o
.text$x:000030B0
.text$x:000030B0 arg_4           = dword ptr  8
.text$x:000030B0
.text$x:000030B0                 mov     edx, [esp+arg_4]
.text$x:000030B4                 lea     eax, [edx+0Ch]
.text$x:000030B7                 mov     ecx, [edx-8]
.text$x:000030BA                 xor     ecx, eax
.text$x:000030BC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000030C1                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ
.text$x:000030C6                 jmp     ___CxxFrameHandler3
.text$x:000030C6 __ehhandler$??0?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ endp
.text$x:000030C6
.text$x:000030C6 ; ---------------------------------------------------------------------------
.text$x:000030CB                 align 4
.text$x:000030CB _text$x         ends
.text$x:000030CB
.text$mn:000030CC ; ===========================================================================
.text$mn:000030CC
.text$mn:000030CC ; Segment type: Pure code
.text$mn:000030CC ; Segment permissions: Read/Execute
.text$mn:000030CC _text$mn        segment para public 'CODE' use32
.text$mn:000030CC                 assume cs:_text$mn
.text$mn:000030CC                 ;org 30CCh
.text$mn:000030CC ; COMDAT (pick any)
.text$mn:000030CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000030CC
.text$mn:000030CC ; =============== S U B R O U T I N E =======================================
.text$mn:000030CC
.text$mn:000030CC ; Attributes: bp-based frame
.text$mn:000030CC
.text$mn:000030CC ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:000030CC                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:000030CC ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:000030CC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:000030CC
.text$mn:000030CC var_4           = dword ptr -4
.text$mn:000030CC
.text$mn:000030CC                 push    ebp
.text$mn:000030CD                 mov     ebp, esp
.text$mn:000030CF                 push    ecx
.text$mn:000030D0                 mov     [ebp+var_4], ecx
.text$mn:000030D3                 mov     ecx, [ebp+var_4]
.text$mn:000030D6                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000030DB                 mov     eax, [ebp+var_4]
.text$mn:000030DE                 mov     esp, ebp
.text$mn:000030E0                 pop     ebp
.text$mn:000030E1                 retn
.text$mn:000030E1 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:000030E1
.text$mn:000030E1 ; ---------------------------------------------------------------------------
.text$mn:000030E2                 align 4
.text$mn:000030E2 _text$mn        ends
.text$mn:000030E2
.text$mn:000030E4 ; ===========================================================================
.text$mn:000030E4
.text$mn:000030E4 ; Segment type: Pure code
.text$mn:000030E4 ; Segment permissions: Read/Execute
.text$mn:000030E4 _text$mn        segment para public 'CODE' use32
.text$mn:000030E4                 assume cs:_text$mn
.text$mn:000030E4                 ;org 30E4h
.text$mn:000030E4 ; COMDAT (pick any)
.text$mn:000030E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000030E4
.text$mn:000030E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000030E4
.text$mn:000030E4 ; Attributes: bp-based frame
.text$mn:000030E4
.text$mn:000030E4 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct std::pair<int, int>>>::_Wrap_alloc<class std::allocator<struct std::pair<int, int>>>(void)
.text$mn:000030E4                 public ??0?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAE@XZ
.text$mn:000030E4 ??0?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000030E4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Getal(void)+Ap
.text$mn:000030E4
.text$mn:000030E4 var_4           = dword ptr -4
.text$mn:000030E4
.text$mn:000030E4                 push    ebp
.text$mn:000030E5                 mov     ebp, esp
.text$mn:000030E7                 push    ecx
.text$mn:000030E8                 mov     [ebp+var_4], ecx
.text$mn:000030EB                 mov     ecx, [ebp+var_4]
.text$mn:000030EE                 call    ??0?$allocator@U?$pair@HH@std@@@std@@QAE@XZ ; std::allocator<std::pair<int,int>>::allocator<std::pair<int,int>>(void)
.text$mn:000030F3                 mov     eax, [ebp+var_4]
.text$mn:000030F6                 mov     esp, ebp
.text$mn:000030F8                 pop     ebp
.text$mn:000030F9                 retn
.text$mn:000030F9 ??0?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAE@XZ endp
.text$mn:000030F9
.text$mn:000030F9 ; ---------------------------------------------------------------------------
.text$mn:000030FA                 align 4
.text$mn:000030FA _text$mn        ends
.text$mn:000030FA
.text$mn:000030FC ; ===========================================================================
.text$mn:000030FC
.text$mn:000030FC ; Segment type: Pure code
.text$mn:000030FC ; Segment permissions: Read/Execute
.text$mn:000030FC _text$mn        segment para public 'CODE' use32
.text$mn:000030FC                 assume cs:_text$mn
.text$mn:000030FC                 ;org 30FCh
.text$mn:000030FC ; COMDAT (pick any)
.text$mn:000030FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000030FC
.text$mn:000030FC ; =============== S U B R O U T I N E =======================================
.text$mn:000030FC
.text$mn:000030FC ; Attributes: bp-based frame
.text$mn:000030FC
.text$mn:000030FC ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>(void)
.text$mn:000030FC                 public ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
.text$mn:000030FC ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000030FC                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Alloc_proxy(void)+Cp
.text$mn:000030FC                                         ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Free_proxy(void)+Cp
.text$mn:000030FC
.text$mn:000030FC var_4           = dword ptr -4
.text$mn:000030FC
.text$mn:000030FC                 push    ebp
.text$mn:000030FD                 mov     ebp, esp
.text$mn:000030FF                 push    ecx
.text$mn:00003100                 mov     [ebp+var_4], ecx
.text$mn:00003103                 mov     ecx, [ebp+var_4]
.text$mn:00003106                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:0000310B                 mov     eax, [ebp+var_4]
.text$mn:0000310E                 mov     esp, ebp
.text$mn:00003110                 pop     ebp
.text$mn:00003111                 retn
.text$mn:00003111 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ endp
.text$mn:00003111
.text$mn:00003111 ; ---------------------------------------------------------------------------
.text$mn:00003112                 align 4
.text$mn:00003112 _text$mn        ends
.text$mn:00003112
.text$mn:00003114 ; ===========================================================================
.text$mn:00003114
.text$mn:00003114 ; Segment type: Pure code
.text$mn:00003114 ; Segment permissions: Read/Execute
.text$mn:00003114 _text$mn        segment para public 'CODE' use32
.text$mn:00003114                 assume cs:_text$mn
.text$mn:00003114                 ;org 3114h
.text$mn:00003114 ; COMDAT (pick any)
.text$mn:00003114                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003114
.text$mn:00003114 ; =============== S U B R O U T I N E =======================================
.text$mn:00003114
.text$mn:00003114 ; Attributes: bp-based frame
.text$mn:00003114
.text$mn:00003114 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00003114                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00003114 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00003114                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp ...
.text$mn:00003114
.text$mn:00003114 var_4           = dword ptr -4
.text$mn:00003114
.text$mn:00003114                 push    ebp
.text$mn:00003115                 mov     ebp, esp
.text$mn:00003117                 push    ecx
.text$mn:00003118                 mov     [ebp+var_4], ecx
.text$mn:0000311B                 mov     eax, [ebp+var_4]
.text$mn:0000311E                 mov     esp, ebp
.text$mn:00003120                 pop     ebp
.text$mn:00003121                 retn
.text$mn:00003121 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00003121
.text$mn:00003121 ; ---------------------------------------------------------------------------
.text$mn:00003122                 align 4
.text$mn:00003122 _text$mn        ends
.text$mn:00003122
.text$mn:00003124 ; ===========================================================================
.text$mn:00003124
.text$mn:00003124 ; Segment type: Pure code
.text$mn:00003124 ; Segment permissions: Read/Execute
.text$mn:00003124 _text$mn        segment para public 'CODE' use32
.text$mn:00003124                 assume cs:_text$mn
.text$mn:00003124                 ;org 3124h
.text$mn:00003124 ; COMDAT (pick any)
.text$mn:00003124                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003124
.text$mn:00003124 ; =============== S U B R O U T I N E =======================================
.text$mn:00003124
.text$mn:00003124 ; Attributes: bp-based frame
.text$mn:00003124
.text$mn:00003124 ; public: __thiscall std::allocator<struct std::pair<int, int>>::allocator<struct std::pair<int, int>>(void)
.text$mn:00003124                 public ??0?$allocator@U?$pair@HH@std@@@std@@QAE@XZ
.text$mn:00003124 ??0?$allocator@U?$pair@HH@std@@@std@@QAE@XZ proc near
.text$mn:00003124                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::pair<int,int>>>::_Wrap_alloc<std::allocator<std::pair<int,int>>>(void)+Ap
.text$mn:00003124                                         ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>(void)+2Bp
.text$mn:00003124
.text$mn:00003124 var_4           = dword ptr -4
.text$mn:00003124
.text$mn:00003124                 push    ebp
.text$mn:00003125                 mov     ebp, esp
.text$mn:00003127                 push    ecx
.text$mn:00003128                 mov     [ebp+var_4], ecx
.text$mn:0000312B                 mov     eax, [ebp+var_4]
.text$mn:0000312E                 mov     esp, ebp
.text$mn:00003130                 pop     ebp
.text$mn:00003131                 retn
.text$mn:00003131 ??0?$allocator@U?$pair@HH@std@@@std@@QAE@XZ endp
.text$mn:00003131
.text$mn:00003131 ; ---------------------------------------------------------------------------
.text$mn:00003132                 align 4
.text$mn:00003132 _text$mn        ends
.text$mn:00003132
.text$mn:00003134 ; ===========================================================================
.text$mn:00003134
.text$mn:00003134 ; Segment type: Pure code
.text$mn:00003134 ; Segment permissions: Read/Execute
.text$mn:00003134 _text$mn        segment para public 'CODE' use32
.text$mn:00003134                 assume cs:_text$mn
.text$mn:00003134                 ;org 3134h
.text$mn:00003134 ; COMDAT (pick any)
.text$mn:00003134                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003134
.text$mn:00003134 ; =============== S U B R O U T I N E =======================================
.text$mn:00003134
.text$mn:00003134 ; Attributes: bp-based frame
.text$mn:00003134
.text$mn:00003134 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00003134                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00003134 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00003134                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)+Ap
.text$mn:00003134                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp ...
.text$mn:00003134
.text$mn:00003134 var_4           = dword ptr -4
.text$mn:00003134
.text$mn:00003134                 push    ebp
.text$mn:00003135                 mov     ebp, esp
.text$mn:00003137                 push    ecx
.text$mn:00003138                 mov     [ebp+var_4], ecx
.text$mn:0000313B                 mov     eax, [ebp+var_4]
.text$mn:0000313E                 mov     esp, ebp
.text$mn:00003140                 pop     ebp
.text$mn:00003141                 retn
.text$mn:00003141 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00003141
.text$mn:00003141 ; ---------------------------------------------------------------------------
.text$mn:00003142                 align 4
.text$mn:00003142 _text$mn        ends
.text$mn:00003142
.text$mn:00003144 ; ===========================================================================
.text$mn:00003144
.text$mn:00003144 ; Segment type: Pure code
.text$mn:00003144 ; Segment permissions: Read/Execute
.text$mn:00003144 _text$mn        segment para public 'CODE' use32
.text$mn:00003144                 assume cs:_text$mn
.text$mn:00003144                 ;org 3144h
.text$mn:00003144 ; COMDAT (pick any)
.text$mn:00003144                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003144
.text$mn:00003144 ; =============== S U B R O U T I N E =======================================
.text$mn:00003144
.text$mn:00003144 ; Attributes: bp-based frame
.text$mn:00003144
.text$mn:00003144 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00003144                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00003144 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00003144                                         ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+BAp
.text$mn:00003144                                         ; XmlMatchedTagsHighlighter::tagMatch(bool)+ECp ...
.text$mn:00003144
.text$mn:00003144 var_14          = dword ptr -14h
.text$mn:00003144 var_D           = byte ptr -0Dh
.text$mn:00003144 var_C           = dword ptr -0Ch
.text$mn:00003144 var_4           = dword ptr -4
.text$mn:00003144 Str             = dword ptr  8
.text$mn:00003144
.text$mn:00003144                 push    ebp
.text$mn:00003145                 mov     ebp, esp
.text$mn:00003147                 push    0FFFFFFFFh
.text$mn:00003149                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:0000314E                 mov     eax, large fs:0
.text$mn:00003154                 push    eax
.text$mn:00003155                 sub     esp, 8
.text$mn:00003158                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000315D                 xor     eax, ebp
.text$mn:0000315F                 push    eax
.text$mn:00003160                 lea     eax, [ebp+var_C]
.text$mn:00003163                 mov     large fs:0, eax
.text$mn:00003169                 mov     [ebp+var_14], ecx
.text$mn:0000316C                 lea     ecx, [ebp+var_D]
.text$mn:0000316F                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00003174                 push    eax
.text$mn:00003175                 mov     ecx, [ebp+var_14]
.text$mn:00003178                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:0000317D                 mov     [ebp+var_4], 0
.text$mn:00003184                 push    0               ; Size
.text$mn:00003186                 push    0               ; char
.text$mn:00003188                 mov     ecx, [ebp+var_14]
.text$mn:0000318B                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00003190                 mov     eax, [ebp+Str]
.text$mn:00003193                 push    eax             ; Str
.text$mn:00003194                 mov     ecx, [ebp+var_14]
.text$mn:00003197                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:0000319C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000031A3                 mov     eax, [ebp+var_14]
.text$mn:000031A6                 mov     ecx, [ebp+var_C]
.text$mn:000031A9                 mov     large fs:0, ecx
.text$mn:000031B0                 pop     ecx
.text$mn:000031B1                 mov     esp, ebp
.text$mn:000031B3                 pop     ebp
.text$mn:000031B4                 retn    4
.text$mn:000031B4 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:000031B4
.text$mn:000031B4 ; ---------------------------------------------------------------------------
.text$mn:000031B7                 align 4
.text$mn:000031B7 _text$mn        ends
.text$mn:000031B7
.text$x:000031B8 ; ===========================================================================
.text$x:000031B8
.text$x:000031B8 ; Segment type: Pure code
.text$x:000031B8 ; Segment permissions: Read/Execute
.text$x:000031B8 _text$x         segment para public 'CODE' use32
.text$x:000031B8                 assume cs:_text$x
.text$x:000031B8                 ;org 31B8h
.text$x:000031B8 ; COMDAT (pick associative to section at 3144)
.text$x:000031B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000031B8
.text$x:000031B8 ; =============== S U B R O U T I N E =======================================
.text$x:000031B8
.text$x:000031B8
.text$x:000031B8 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:000031B8                                         ; DATA XREF: .xdata$x:000062BCo
.text$x:000031B8                 mov     ecx, [ebp-14h]
.text$x:000031BB                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:000031BB __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:000031BB
.text$x:000031C0
.text$x:000031C0 ; =============== S U B R O U T I N E =======================================
.text$x:000031C0
.text$x:000031C0
.text$x:000031C0 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:000031C0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:000031C0
.text$x:000031C0 arg_4           = dword ptr  8
.text$x:000031C0
.text$x:000031C0                 mov     edx, [esp+arg_4]
.text$x:000031C4                 lea     eax, [edx+0Ch]
.text$x:000031C7                 mov     ecx, [edx-0Ch]
.text$x:000031CA                 xor     ecx, eax
.text$x:000031CC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000031D1                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:000031D6                 jmp     ___CxxFrameHandler3
.text$x:000031D6 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:000031D6
.text$x:000031D6 ; ---------------------------------------------------------------------------
.text$x:000031DB                 align 4
.text$x:000031DB _text$x         ends
.text$x:000031DB
.text$mn:000031DC ; ===========================================================================
.text$mn:000031DC
.text$mn:000031DC ; Segment type: Pure code
.text$mn:000031DC ; Segment permissions: Read/Execute
.text$mn:000031DC _text$mn        segment para public 'CODE' use32
.text$mn:000031DC                 assume cs:_text$mn
.text$mn:000031DC                 ;org 31DCh
.text$mn:000031DC ; COMDAT (pick any)
.text$mn:000031DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000031DC
.text$mn:000031DC ; =============== S U B R O U T I N E =======================================
.text$mn:000031DC
.text$mn:000031DC ; Attributes: bp-based frame
.text$mn:000031DC
.text$mn:000031DC ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:000031DC                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:000031DC ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:000031DC                                         ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+230p
.text$mn:000031DC                                         ; XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+4E4p
.text$mn:000031DC
.text$mn:000031DC var_14          = dword ptr -14h
.text$mn:000031DC var_D           = byte ptr -0Dh
.text$mn:000031DC var_C           = dword ptr -0Ch
.text$mn:000031DC var_4           = dword ptr -4
.text$mn:000031DC
.text$mn:000031DC                 push    ebp
.text$mn:000031DD                 mov     ebp, esp
.text$mn:000031DF                 push    0FFFFFFFFh
.text$mn:000031E1                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:000031E6                 mov     eax, large fs:0
.text$mn:000031EC                 push    eax
.text$mn:000031ED                 sub     esp, 8
.text$mn:000031F0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000031F5                 xor     eax, ebp
.text$mn:000031F7                 push    eax
.text$mn:000031F8                 lea     eax, [ebp+var_C]
.text$mn:000031FB                 mov     large fs:0, eax
.text$mn:00003201                 mov     [ebp+var_14], ecx
.text$mn:00003204                 lea     ecx, [ebp+var_D]
.text$mn:00003207                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:0000320C                 push    eax
.text$mn:0000320D                 mov     ecx, [ebp+var_14]
.text$mn:00003210                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00003215                 mov     [ebp+var_4], 0
.text$mn:0000321C                 push    0               ; Size
.text$mn:0000321E                 push    0               ; char
.text$mn:00003220                 mov     ecx, [ebp+var_14]
.text$mn:00003223                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00003228                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000322F                 mov     eax, [ebp+var_14]
.text$mn:00003232                 mov     ecx, [ebp+var_C]
.text$mn:00003235                 mov     large fs:0, ecx
.text$mn:0000323C                 pop     ecx
.text$mn:0000323D                 mov     esp, ebp
.text$mn:0000323F                 pop     ebp
.text$mn:00003240                 retn
.text$mn:00003240 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00003240
.text$mn:00003240 ; ---------------------------------------------------------------------------
.text$mn:00003241                 align 4
.text$mn:00003241 _text$mn        ends
.text$mn:00003241
.text$x:00003244 ; ===========================================================================
.text$x:00003244
.text$x:00003244 ; Segment type: Pure code
.text$x:00003244 ; Segment permissions: Read/Execute
.text$x:00003244 _text$x         segment para public 'CODE' use32
.text$x:00003244                 assume cs:_text$x
.text$x:00003244                 ;org 3244h
.text$x:00003244 ; COMDAT (pick associative to section at 31DC)
.text$x:00003244                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003244
.text$x:00003244 ; =============== S U B R O U T I N E =======================================
.text$x:00003244
.text$x:00003244
.text$x:00003244 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00003244                                         ; DATA XREF: .xdata$x:00006290o
.text$x:00003244                 mov     ecx, [ebp-14h]
.text$x:00003247                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00003247 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00003247
.text$x:0000324C
.text$x:0000324C ; =============== S U B R O U T I N E =======================================
.text$x:0000324C
.text$x:0000324C
.text$x:0000324C __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:0000324C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:0000324C
.text$x:0000324C arg_4           = dword ptr  8
.text$x:0000324C
.text$x:0000324C                 mov     edx, [esp+arg_4]
.text$x:00003250                 lea     eax, [edx+0Ch]
.text$x:00003253                 mov     ecx, [edx-0Ch]
.text$x:00003256                 xor     ecx, eax
.text$x:00003258                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000325D                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00003262                 jmp     ___CxxFrameHandler3
.text$x:00003262 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00003262
.text$x:00003262 ; ---------------------------------------------------------------------------
.text$x:00003267                 align 4
.text$x:00003267 _text$x         ends
.text$x:00003267
.text$mn:00003268 ; ===========================================================================
.text$mn:00003268
.text$mn:00003268 ; Segment type: Pure code
.text$mn:00003268 ; Segment permissions: Read/Execute
.text$mn:00003268 _text$mn        segment para public 'CODE' use32
.text$mn:00003268                 assume cs:_text$mn
.text$mn:00003268                 ;org 3268h
.text$mn:00003268 ; COMDAT (pick any)
.text$mn:00003268                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003268
.text$mn:00003268 ; =============== S U B R O U T I N E =======================================
.text$mn:00003268
.text$mn:00003268 ; Attributes: bp-based frame
.text$mn:00003268
.text$mn:00003268 ; public: __thiscall std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>(class std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>> &&)
.text$mn:00003268                 public ??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@$$QAV01@@Z
.text$mn:00003268 ??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@$$QAV01@@Z proc near
.text$mn:00003268                                         ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+22Cp
.text$mn:00003268
.text$mn:00003268 var_14          = dword ptr -14h
.text$mn:00003268 var_E           = byte ptr -0Eh
.text$mn:00003268 var_D           = byte ptr -0Dh
.text$mn:00003268 var_C           = dword ptr -0Ch
.text$mn:00003268 var_4           = dword ptr -4
.text$mn:00003268 arg_0           = dword ptr  8
.text$mn:00003268
.text$mn:00003268                 push    ebp
.text$mn:00003269                 mov     ebp, esp
.text$mn:0000326B                 push    0FFFFFFFFh
.text$mn:0000326D                 push    offset __ehhandler$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@$$QAV01@@Z
.text$mn:00003272                 mov     eax, large fs:0
.text$mn:00003278                 push    eax
.text$mn:00003279                 sub     esp, 8
.text$mn:0000327C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003281                 xor     eax, ebp
.text$mn:00003283                 push    eax
.text$mn:00003284                 lea     eax, [ebp+var_C]
.text$mn:00003287                 mov     large fs:0, eax
.text$mn:0000328D                 mov     [ebp+var_14], ecx
.text$mn:00003290                 lea     eax, [ebp+var_E]
.text$mn:00003293                 push    eax
.text$mn:00003294                 mov     ecx, [ebp+arg_0]
.text$mn:00003297                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Getal(void)
.text$mn:0000329C                 push    eax
.text$mn:0000329D                 mov     ecx, [ebp+var_14]
.text$mn:000032A0                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@HH@std@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>(std::allocator<std::pair<int,int>> const &)
.text$mn:000032A5                 mov     [ebp+var_4], 0
.text$mn:000032AC                 xor     ecx, ecx
.text$mn:000032AE                 mov     [ebp+var_D], cl
.text$mn:000032B1                 movzx   edx, [ebp+var_D]
.text$mn:000032B5                 push    edx             ; int
.text$mn:000032B6                 mov     eax, [ebp+arg_0]
.text$mn:000032B9                 push    eax
.text$mn:000032BA                 call    ??$forward@V?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@YA$$QAV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@0@AAV10@@Z ; std::forward<std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>>(std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>> &)
.text$mn:000032BF                 add     esp, 4
.text$mn:000032C2                 push    eax             ; struct std::_Container_base12 *
.text$mn:000032C3                 mov     ecx, [ebp+var_14]
.text$mn:000032C6                 call    ?_Assign_rv@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Assign_rv(std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>> &&,std::integral_constant<bool,1>)
.text$mn:000032CB                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000032D2                 mov     eax, [ebp+var_14]
.text$mn:000032D5                 mov     ecx, [ebp+var_C]
.text$mn:000032D8                 mov     large fs:0, ecx
.text$mn:000032DF                 pop     ecx
.text$mn:000032E0                 mov     esp, ebp
.text$mn:000032E2                 pop     ebp
.text$mn:000032E3                 retn    4
.text$mn:000032E3 ??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@$$QAV01@@Z endp
.text$mn:000032E3
.text$mn:000032E3 ; ---------------------------------------------------------------------------
.text$mn:000032E6                 align 4
.text$mn:000032E6 _text$mn        ends
.text$mn:000032E6
.text$x:000032E8 ; ===========================================================================
.text$x:000032E8
.text$x:000032E8 ; Segment type: Pure code
.text$x:000032E8 ; Segment permissions: Read/Execute
.text$x:000032E8 _text$x         segment para public 'CODE' use32
.text$x:000032E8                 assume cs:_text$x
.text$x:000032E8                 ;org 32E8h
.text$x:000032E8 ; COMDAT (pick associative to section at 3268)
.text$x:000032E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000032E8
.text$x:000032E8 ; =============== S U B R O U T I N E =======================================
.text$x:000032E8
.text$x:000032E8
.text$x:000032E8 __unwindfunclet$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@$$QAV01@@Z$0 proc near
.text$x:000032E8                                         ; DATA XREF: .xdata$x:00006818o
.text$x:000032E8                 mov     ecx, [ebp-14h]
.text$x:000032EB                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>(void)
.text$x:000032EB __unwindfunclet$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@$$QAV01@@Z$0 endp
.text$x:000032EB
.text$x:000032F0
.text$x:000032F0 ; =============== S U B R O U T I N E =======================================
.text$x:000032F0
.text$x:000032F0
.text$x:000032F0 __ehhandler$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@$$QAV01@@Z proc near
.text$x:000032F0                                         ; DATA XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>(std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>> &&)+5o
.text$x:000032F0
.text$x:000032F0 arg_4           = dword ptr  8
.text$x:000032F0
.text$x:000032F0                 mov     edx, [esp+arg_4]
.text$x:000032F4                 lea     eax, [edx+0Ch]
.text$x:000032F7                 mov     ecx, [edx-0Ch]
.text$x:000032FA                 xor     ecx, eax
.text$x:000032FC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003301                 mov     eax, offset __ehfuncinfo$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@$$QAV01@@Z
.text$x:00003306                 jmp     ___CxxFrameHandler3
.text$x:00003306 __ehhandler$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@$$QAV01@@Z endp
.text$x:00003306
.text$x:00003306 ; ---------------------------------------------------------------------------
.text$x:0000330B                 align 4
.text$x:0000330B _text$x         ends
.text$x:0000330B
.text$mn:0000330C ; ===========================================================================
.text$mn:0000330C
.text$mn:0000330C ; Segment type: Pure code
.text$mn:0000330C ; Segment permissions: Read/Execute
.text$mn:0000330C _text$mn        segment para public 'CODE' use32
.text$mn:0000330C                 assume cs:_text$mn
.text$mn:0000330C                 ;org 330Ch
.text$mn:0000330C ; COMDAT (pick any)
.text$mn:0000330C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000330C
.text$mn:0000330C ; =============== S U B R O U T I N E =======================================
.text$mn:0000330C
.text$mn:0000330C ; Attributes: bp-based frame
.text$mn:0000330C
.text$mn:0000330C ; public: __thiscall std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>(void)
.text$mn:0000330C                 public ??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ
.text$mn:0000330C ??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ proc near
.text$mn:0000330C                                         ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+32p
.text$mn:0000330C
.text$mn:0000330C var_14          = dword ptr -14h
.text$mn:0000330C var_D           = byte ptr -0Dh
.text$mn:0000330C var_C           = dword ptr -0Ch
.text$mn:0000330C var_4           = dword ptr -4
.text$mn:0000330C
.text$mn:0000330C                 push    ebp
.text$mn:0000330D                 mov     ebp, esp
.text$mn:0000330F                 push    0FFFFFFFFh
.text$mn:00003311                 push    offset __ehhandler$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ
.text$mn:00003316                 mov     eax, large fs:0
.text$mn:0000331C                 push    eax
.text$mn:0000331D                 sub     esp, 8
.text$mn:00003320                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003325                 xor     eax, ebp
.text$mn:00003327                 push    eax
.text$mn:00003328                 lea     eax, [ebp+var_C]
.text$mn:0000332B                 mov     large fs:0, eax
.text$mn:00003331                 mov     [ebp+var_14], ecx
.text$mn:00003334                 lea     ecx, [ebp+var_D]
.text$mn:00003337                 call    ??0?$allocator@U?$pair@HH@std@@@std@@QAE@XZ ; std::allocator<std::pair<int,int>>::allocator<std::pair<int,int>>(void)
.text$mn:0000333C                 push    eax
.text$mn:0000333D                 mov     ecx, [ebp+var_14]
.text$mn:00003340                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@HH@std@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>(std::allocator<std::pair<int,int>> const &)
.text$mn:00003345                 mov     [ebp+var_4], 0
.text$mn:0000334C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003353                 mov     eax, [ebp+var_14]
.text$mn:00003356                 mov     ecx, [ebp+var_C]
.text$mn:00003359                 mov     large fs:0, ecx
.text$mn:00003360                 pop     ecx
.text$mn:00003361                 mov     esp, ebp
.text$mn:00003363                 pop     ebp
.text$mn:00003364                 retn
.text$mn:00003364 ??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ endp
.text$mn:00003364
.text$mn:00003364 ; ---------------------------------------------------------------------------
.text$mn:00003365                 align 4
.text$mn:00003365 _text$mn        ends
.text$mn:00003365
.text$x:00003368 ; ===========================================================================
.text$x:00003368
.text$x:00003368 ; Segment type: Pure code
.text$x:00003368 ; Segment permissions: Read/Execute
.text$x:00003368 _text$x         segment para public 'CODE' use32
.text$x:00003368                 assume cs:_text$x
.text$x:00003368                 ;org 3368h
.text$x:00003368 ; COMDAT (pick associative to section at 330C)
.text$x:00003368                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003368
.text$x:00003368 ; =============== S U B R O U T I N E =======================================
.text$x:00003368
.text$x:00003368
.text$x:00003368 __unwindfunclet$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ$0 proc near
.text$x:00003368                                         ; DATA XREF: .xdata$x:000067ECo
.text$x:00003368                 mov     ecx, [ebp-14h]
.text$x:0000336B                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>(void)
.text$x:0000336B __unwindfunclet$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ$0 endp
.text$x:0000336B
.text$x:00003370
.text$x:00003370 ; =============== S U B R O U T I N E =======================================
.text$x:00003370
.text$x:00003370
.text$x:00003370 __ehhandler$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ proc near
.text$x:00003370                                         ; DATA XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>(void)+5o
.text$x:00003370
.text$x:00003370 arg_4           = dword ptr  8
.text$x:00003370
.text$x:00003370                 mov     edx, [esp+arg_4]
.text$x:00003374                 lea     eax, [edx+0Ch]
.text$x:00003377                 mov     ecx, [edx-0Ch]
.text$x:0000337A                 xor     ecx, eax
.text$x:0000337C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003381                 mov     eax, offset __ehfuncinfo$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ
.text$x:00003386                 jmp     ___CxxFrameHandler3
.text$x:00003386 __ehhandler$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ endp
.text$x:00003386
.text$x:00003386 ; ---------------------------------------------------------------------------
.text$x:0000338B                 align 4
.text$x:0000338B _text$x         ends
.text$x:0000338B
.text$mn:0000338C ; ===========================================================================
.text$mn:0000338C
.text$mn:0000338C ; Segment type: Pure code
.text$mn:0000338C ; Segment permissions: Read/Execute
.text$mn:0000338C _text$mn        segment para public 'CODE' use32
.text$mn:0000338C                 assume cs:_text$mn
.text$mn:0000338C                 ;org 338Ch
.text$mn:0000338C ; COMDAT (pick any)
.text$mn:0000338C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000338C
.text$mn:0000338C ; =============== S U B R O U T I N E =======================================
.text$mn:0000338C
.text$mn:0000338C ; Attributes: bp-based frame
.text$mn:0000338C
.text$mn:0000338C ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:0000338C                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:0000338C ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:0000338C                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:0000338C                                         ; std::_Vector_val<std::_Simple_types<std::pair<int,int>>>::_Vector_val<std::_Simple_types<std::pair<int,int>>>(void)+29p
.text$mn:0000338C
.text$mn:0000338C var_4           = dword ptr -4
.text$mn:0000338C
.text$mn:0000338C                 push    ebp
.text$mn:0000338D                 mov     ebp, esp
.text$mn:0000338F                 push    ecx
.text$mn:00003390                 mov     [ebp+var_4], ecx
.text$mn:00003393                 mov     eax, [ebp+var_4]
.text$mn:00003396                 mov     dword ptr [eax], 0
.text$mn:0000339C                 mov     eax, [ebp+var_4]
.text$mn:0000339F                 mov     esp, ebp
.text$mn:000033A1                 pop     ebp
.text$mn:000033A2                 retn
.text$mn:000033A2 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:000033A2
.text$mn:000033A2 ; ---------------------------------------------------------------------------
.text$mn:000033A3                 align 4
.text$mn:000033A3 _text$mn        ends
.text$mn:000033A3
.text$mn:000033A4 ; ===========================================================================
.text$mn:000033A4
.text$mn:000033A4 ; Segment type: Pure code
.text$mn:000033A4 ; Segment permissions: Read/Execute
.text$mn:000033A4 _text$mn        segment para public 'CODE' use32
.text$mn:000033A4                 assume cs:_text$mn
.text$mn:000033A4                 ;org 33A4h
.text$mn:000033A4 ; COMDAT (pick any)
.text$mn:000033A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000033A4
.text$mn:000033A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000033A4
.text$mn:000033A4 ; Attributes: bp-based frame
.text$mn:000033A4
.text$mn:000033A4 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:000033A4                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:000033A4 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:000033A4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:000033A4                                         ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Alloc_proxy(void)+23p
.text$mn:000033A4
.text$mn:000033A4 var_4           = dword ptr -4
.text$mn:000033A4
.text$mn:000033A4                 push    ebp
.text$mn:000033A5                 mov     ebp, esp
.text$mn:000033A7                 push    ecx
.text$mn:000033A8                 mov     [ebp+var_4], ecx
.text$mn:000033AB                 mov     eax, [ebp+var_4]
.text$mn:000033AE                 mov     dword ptr [eax], 0
.text$mn:000033B4                 mov     ecx, [ebp+var_4]
.text$mn:000033B7                 mov     dword ptr [ecx+4], 0
.text$mn:000033BE                 mov     eax, [ebp+var_4]
.text$mn:000033C1                 mov     esp, ebp
.text$mn:000033C3                 pop     ebp
.text$mn:000033C4                 retn
.text$mn:000033C4 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:000033C4
.text$mn:000033C4 ; ---------------------------------------------------------------------------
.text$mn:000033C5                 align 4
.text$mn:000033C5 _text$mn        ends
.text$mn:000033C5
.text$mn:000033C8 ; ===========================================================================
.text$mn:000033C8
.text$mn:000033C8 ; Segment type: Pure code
.text$mn:000033C8 ; Segment permissions: Read/Execute
.text$mn:000033C8 _text$mn        segment para public 'CODE' use32
.text$mn:000033C8                 assume cs:_text$mn
.text$mn:000033C8                 ;org 33C8h
.text$mn:000033C8 ; COMDAT (pick any)
.text$mn:000033C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000033C8
.text$mn:000033C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000033C8
.text$mn:000033C8 ; Attributes: bp-based frame
.text$mn:000033C8
.text$mn:000033C8 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:000033C8                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:000033C8 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:000033C8                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:000033C8                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:000033C8
.text$mn:000033C8 var_10          = dword ptr -10h
.text$mn:000033C8 var_C           = dword ptr -0Ch
.text$mn:000033C8 var_4           = dword ptr -4
.text$mn:000033C8
.text$mn:000033C8                 push    ebp
.text$mn:000033C9                 mov     ebp, esp
.text$mn:000033CB                 push    0FFFFFFFFh
.text$mn:000033CD                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:000033D2                 mov     eax, large fs:0
.text$mn:000033D8                 push    eax
.text$mn:000033D9                 push    ecx
.text$mn:000033DA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000033DF                 xor     eax, ebp
.text$mn:000033E1                 push    eax
.text$mn:000033E2                 lea     eax, [ebp+var_C]
.text$mn:000033E5                 mov     large fs:0, eax
.text$mn:000033EB                 mov     [ebp+var_10], ecx
.text$mn:000033EE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000033F1                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:000033F6                 mov     [ebp+var_4], 0
.text$mn:000033FD                 mov     eax, [ebp+var_10]
.text$mn:00003400                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00003406                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000340D                 mov     eax, [ebp+var_10]
.text$mn:00003410                 mov     ecx, [ebp+var_C]
.text$mn:00003413                 mov     large fs:0, ecx
.text$mn:0000341A                 pop     ecx
.text$mn:0000341B                 mov     esp, ebp
.text$mn:0000341D                 pop     ebp
.text$mn:0000341E                 retn
.text$mn:0000341E ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:0000341E
.text$mn:0000341E ; ---------------------------------------------------------------------------
.text$mn:0000341F                 align 10h
.text$mn:0000341F _text$mn        ends
.text$mn:0000341F
.text$x:00003420 ; ===========================================================================
.text$x:00003420
.text$x:00003420 ; Segment type: Pure code
.text$x:00003420 ; Segment permissions: Read/Execute
.text$x:00003420 _text$x         segment para public 'CODE' use32
.text$x:00003420                 assume cs:_text$x
.text$x:00003420                 ;org 3420h
.text$x:00003420 ; COMDAT (pick associative to section at 33C8)
.text$x:00003420                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003420
.text$x:00003420 ; =============== S U B R O U T I N E =======================================
.text$x:00003420
.text$x:00003420
.text$x:00003420 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00003420                                         ; DATA XREF: .xdata$x:000064B4o
.text$x:00003420                 mov     ecx, [ebp-10h]  ; this
.text$x:00003423                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00003423 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00003423
.text$x:00003428
.text$x:00003428 ; =============== S U B R O U T I N E =======================================
.text$x:00003428
.text$x:00003428
.text$x:00003428 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00003428                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00003428
.text$x:00003428 arg_4           = dword ptr  8
.text$x:00003428
.text$x:00003428                 mov     edx, [esp+arg_4]
.text$x:0000342C                 lea     eax, [edx+0Ch]
.text$x:0000342F                 mov     ecx, [edx-8]
.text$x:00003432                 xor     ecx, eax
.text$x:00003434                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003439                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:0000343E                 jmp     ___CxxFrameHandler3
.text$x:0000343E __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:0000343E
.text$x:0000343E ; ---------------------------------------------------------------------------
.text$x:00003443                 align 4
.text$x:00003443 _text$x         ends
.text$x:00003443
.text$mn:00003444 ; ===========================================================================
.text$mn:00003444
.text$mn:00003444 ; Segment type: Pure code
.text$mn:00003444 ; Segment permissions: Read/Execute
.text$mn:00003444 _text$mn        segment para public 'CODE' use32
.text$mn:00003444                 assume cs:_text$mn
.text$mn:00003444                 ;org 3444h
.text$mn:00003444 ; COMDAT (pick any)
.text$mn:00003444                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003444
.text$mn:00003444 ; =============== S U B R O U T I N E =======================================
.text$mn:00003444
.text$mn:00003444 ; Attributes: bp-based frame
.text$mn:00003444
.text$mn:00003444 ; _DWORD __thiscall std::_Ignore::_Ignore(std::_Ignore *__hidden this)
.text$mn:00003444                 public ??0_Ignore@std@@QAE@XZ
.text$mn:00003444 ??0_Ignore@std@@QAE@XZ proc near        ; CODE XREF: std::`dynamic initializer for 'ignore''(void)+8p
.text$mn:00003444
.text$mn:00003444 var_4           = dword ptr -4
.text$mn:00003444
.text$mn:00003444                 push    ebp
.text$mn:00003445                 mov     ebp, esp
.text$mn:00003447                 push    ecx
.text$mn:00003448                 mov     [ebp+var_4], ecx
.text$mn:0000344B                 mov     eax, [ebp+var_4]
.text$mn:0000344E                 mov     esp, ebp
.text$mn:00003450                 pop     ebp
.text$mn:00003451                 retn
.text$mn:00003451 ??0_Ignore@std@@QAE@XZ endp
.text$mn:00003451
.text$mn:00003451 ; ---------------------------------------------------------------------------
.text$mn:00003452                 align 4
.text$mn:00003452 _text$mn        ends
.text$mn:00003452
.text$mn:00003454 ; ===========================================================================
.text$mn:00003454
.text$mn:00003454 ; Segment type: Pure code
.text$mn:00003454 ; Segment permissions: Read/Execute
.text$mn:00003454 _text$mn        segment para public 'CODE' use32
.text$mn:00003454                 assume cs:_text$mn
.text$mn:00003454                 ;org 3454h
.text$mn:00003454 ; COMDAT (pick any)
.text$mn:00003454                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003454
.text$mn:00003454 ; =============== S U B R O U T I N E =======================================
.text$mn:00003454
.text$mn:00003454 ; Attributes: bp-based frame
.text$mn:00003454
.text$mn:00003454 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00003454                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00003454 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00003454                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00003454
.text$mn:00003454 var_10          = dword ptr -10h
.text$mn:00003454 var_C           = dword ptr -0Ch
.text$mn:00003454 var_4           = dword ptr -4
.text$mn:00003454
.text$mn:00003454                 push    ebp
.text$mn:00003455                 mov     ebp, esp
.text$mn:00003457                 push    0FFFFFFFFh
.text$mn:00003459                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:0000345E                 mov     eax, large fs:0
.text$mn:00003464                 push    eax
.text$mn:00003465                 push    ecx
.text$mn:00003466                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000346B                 xor     eax, ebp
.text$mn:0000346D                 push    eax
.text$mn:0000346E                 lea     eax, [ebp+var_C]
.text$mn:00003471                 mov     large fs:0, eax
.text$mn:00003477                 mov     [ebp+var_10], ecx
.text$mn:0000347A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000347D                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00003482                 mov     [ebp+var_4], 0
.text$mn:00003489                 mov     eax, [ebp+var_10]
.text$mn:0000348C                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00003492                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003499                 mov     eax, [ebp+var_10]
.text$mn:0000349C                 mov     ecx, [ebp+var_C]
.text$mn:0000349F                 mov     large fs:0, ecx
.text$mn:000034A6                 pop     ecx
.text$mn:000034A7                 mov     esp, ebp
.text$mn:000034A9                 pop     ebp
.text$mn:000034AA                 retn
.text$mn:000034AA ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:000034AA
.text$mn:000034AA ; ---------------------------------------------------------------------------
.text$mn:000034AB                 align 4
.text$mn:000034AB _text$mn        ends
.text$mn:000034AB
.text$x:000034AC ; ===========================================================================
.text$x:000034AC
.text$x:000034AC ; Segment type: Pure code
.text$x:000034AC ; Segment permissions: Read/Execute
.text$x:000034AC _text$x         segment para public 'CODE' use32
.text$x:000034AC                 assume cs:_text$x
.text$x:000034AC                 ;org 34ACh
.text$x:000034AC ; COMDAT (pick associative to section at 3454)
.text$x:000034AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000034AC
.text$x:000034AC ; =============== S U B R O U T I N E =======================================
.text$x:000034AC
.text$x:000034AC
.text$x:000034AC __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:000034AC                                         ; DATA XREF: .xdata$x:00006538o
.text$x:000034AC                 mov     ecx, [ebp-10h]  ; this
.text$x:000034AF                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000034AF __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:000034AF
.text$x:000034B4
.text$x:000034B4 ; =============== S U B R O U T I N E =======================================
.text$x:000034B4
.text$x:000034B4
.text$x:000034B4 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:000034B4                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:000034B4
.text$x:000034B4 arg_4           = dword ptr  8
.text$x:000034B4
.text$x:000034B4                 mov     edx, [esp+arg_4]
.text$x:000034B8                 lea     eax, [edx+0Ch]
.text$x:000034BB                 mov     ecx, [edx-8]
.text$x:000034BE                 xor     ecx, eax
.text$x:000034C0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000034C5                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:000034CA                 jmp     ___CxxFrameHandler3
.text$x:000034CA __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:000034CA
.text$x:000034CA ; ---------------------------------------------------------------------------
.text$x:000034CF                 align 10h
.text$x:000034CF _text$x         ends
.text$x:000034CF
.text$mn:000034D0 ; ===========================================================================
.text$mn:000034D0
.text$mn:000034D0 ; Segment type: Pure code
.text$mn:000034D0 ; Segment permissions: Read/Execute
.text$mn:000034D0 _text$mn        segment para public 'CODE' use32
.text$mn:000034D0                 assume cs:_text$mn
.text$mn:000034D0                 ;org 34D0h
.text$mn:000034D0 ; COMDAT (pick any)
.text$mn:000034D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000034D0
.text$mn:000034D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000034D0
.text$mn:000034D0 ; Attributes: bp-based frame
.text$mn:000034D0
.text$mn:000034D0 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *this, const struct std::_Iterator_base12 *)
.text$mn:000034D0                 public ??0_Iterator_base12@std@@QAE@ABU01@@Z
.text$mn:000034D0 ??0_Iterator_base12@std@@QAE@ABU01@@Z proc near
.text$mn:000034D0                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12> const &)+2Dp
.text$mn:000034D0
.text$mn:000034D0 var_4           = dword ptr -4
.text$mn:000034D0 arg_0           = dword ptr  8
.text$mn:000034D0
.text$mn:000034D0                 push    ebp
.text$mn:000034D1                 mov     ebp, esp
.text$mn:000034D3                 push    ecx
.text$mn:000034D4                 mov     [ebp+var_4], ecx
.text$mn:000034D7                 mov     eax, [ebp+var_4]
.text$mn:000034DA                 mov     dword ptr [eax], 0
.text$mn:000034E0                 mov     ecx, [ebp+var_4]
.text$mn:000034E3                 mov     dword ptr [ecx+4], 0
.text$mn:000034EA                 mov     edx, [ebp+arg_0]
.text$mn:000034ED                 push    edx
.text$mn:000034EE                 mov     ecx, [ebp+var_4]
.text$mn:000034F1                 call    ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)
.text$mn:000034F6                 mov     eax, [ebp+var_4]
.text$mn:000034F9                 mov     esp, ebp
.text$mn:000034FB                 pop     ebp
.text$mn:000034FC                 retn    4
.text$mn:000034FC ??0_Iterator_base12@std@@QAE@ABU01@@Z endp
.text$mn:000034FC
.text$mn:000034FC ; ---------------------------------------------------------------------------
.text$mn:000034FF                 align 10h
.text$mn:000034FF _text$mn        ends
.text$mn:000034FF
.text$mn:00003500 ; ===========================================================================
.text$mn:00003500
.text$mn:00003500 ; Segment type: Pure code
.text$mn:00003500 ; Segment permissions: Read/Execute
.text$mn:00003500 _text$mn        segment para public 'CODE' use32
.text$mn:00003500                 assume cs:_text$mn
.text$mn:00003500                 ;org 3500h
.text$mn:00003500 ; COMDAT (pick any)
.text$mn:00003500                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003500
.text$mn:00003500 ; =============== S U B R O U T I N E =======================================
.text$mn:00003500
.text$mn:00003500 ; Attributes: bp-based frame
.text$mn:00003500
.text$mn:00003500 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00003500                 public ??0_Iterator_base12@std@@QAE@XZ
.text$mn:00003500 ??0_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00003500                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>(void)+29p
.text$mn:00003500
.text$mn:00003500 var_4           = dword ptr -4
.text$mn:00003500
.text$mn:00003500                 push    ebp
.text$mn:00003501                 mov     ebp, esp
.text$mn:00003503                 push    ecx
.text$mn:00003504                 mov     [ebp+var_4], ecx
.text$mn:00003507                 mov     eax, [ebp+var_4]
.text$mn:0000350A                 mov     dword ptr [eax], 0
.text$mn:00003510                 mov     ecx, [ebp+var_4]
.text$mn:00003513                 mov     dword ptr [ecx+4], 0
.text$mn:0000351A                 mov     eax, [ebp+var_4]
.text$mn:0000351D                 mov     esp, ebp
.text$mn:0000351F                 pop     ebp
.text$mn:00003520                 retn
.text$mn:00003520 ??0_Iterator_base12@std@@QAE@XZ endp
.text$mn:00003520
.text$mn:00003520 ; ---------------------------------------------------------------------------
.text$mn:00003521                 align 4
.text$mn:00003521 _text$mn        ends
.text$mn:00003521
.text$mn:00003524 ; ===========================================================================
.text$mn:00003524
.text$mn:00003524 ; Segment type: Pure code
.text$mn:00003524 ; Segment permissions: Read/Execute
.text$mn:00003524 _text$mn        segment para public 'CODE' use32
.text$mn:00003524                 assume cs:_text$mn
.text$mn:00003524                 ;org 3524h
.text$mn:00003524 ; COMDAT (pick any)
.text$mn:00003524                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003524
.text$mn:00003524 ; =============== S U B R O U T I N E =======================================
.text$mn:00003524
.text$mn:00003524 ; Attributes: bp-based frame
.text$mn:00003524
.text$mn:00003524 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00003524                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00003524 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00003524                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00003524
.text$mn:00003524 var_10          = dword ptr -10h
.text$mn:00003524 var_C           = dword ptr -0Ch
.text$mn:00003524 var_4           = dword ptr -4
.text$mn:00003524
.text$mn:00003524                 push    ebp
.text$mn:00003525                 mov     ebp, esp
.text$mn:00003527                 push    0FFFFFFFFh
.text$mn:00003529                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:0000352E                 mov     eax, large fs:0
.text$mn:00003534                 push    eax
.text$mn:00003535                 push    ecx
.text$mn:00003536                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000353B                 xor     eax, ebp
.text$mn:0000353D                 push    eax
.text$mn:0000353E                 lea     eax, [ebp+var_C]
.text$mn:00003541                 mov     large fs:0, eax
.text$mn:00003547                 mov     [ebp+var_10], ecx
.text$mn:0000354A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000354D                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00003552                 mov     [ebp+var_4], 0
.text$mn:00003559                 mov     eax, [ebp+var_10]
.text$mn:0000355C                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00003562                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003569                 mov     eax, [ebp+var_10]
.text$mn:0000356C                 mov     ecx, [ebp+var_C]
.text$mn:0000356F                 mov     large fs:0, ecx
.text$mn:00003576                 pop     ecx
.text$mn:00003577                 mov     esp, ebp
.text$mn:00003579                 pop     ebp
.text$mn:0000357A                 retn
.text$mn:0000357A ??0_System_error_category@std@@QAE@XZ endp
.text$mn:0000357A
.text$mn:0000357A ; ---------------------------------------------------------------------------
.text$mn:0000357B                 align 4
.text$mn:0000357B _text$mn        ends
.text$mn:0000357B
.text$x:0000357C ; ===========================================================================
.text$x:0000357C
.text$x:0000357C ; Segment type: Pure code
.text$x:0000357C ; Segment permissions: Read/Execute
.text$x:0000357C _text$x         segment para public 'CODE' use32
.text$x:0000357C                 assume cs:_text$x
.text$x:0000357C                 ;org 357Ch
.text$x:0000357C ; COMDAT (pick associative to section at 3524)
.text$x:0000357C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000357C
.text$x:0000357C ; =============== S U B R O U T I N E =======================================
.text$x:0000357C
.text$x:0000357C
.text$x:0000357C __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:0000357C                                         ; DATA XREF: .xdata$x:000065BCo
.text$x:0000357C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000357F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000357F __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:0000357F
.text$x:00003584
.text$x:00003584 ; =============== S U B R O U T I N E =======================================
.text$x:00003584
.text$x:00003584
.text$x:00003584 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00003584                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00003584
.text$x:00003584 arg_4           = dword ptr  8
.text$x:00003584
.text$x:00003584                 mov     edx, [esp+arg_4]
.text$x:00003588                 lea     eax, [edx+0Ch]
.text$x:0000358B                 mov     ecx, [edx-8]
.text$x:0000358E                 xor     ecx, eax
.text$x:00003590                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003595                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:0000359A                 jmp     ___CxxFrameHandler3
.text$x:0000359A __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:0000359A
.text$x:0000359A ; ---------------------------------------------------------------------------
.text$x:0000359F                 align 10h
.text$x:0000359F _text$x         ends
.text$x:0000359F
.text$mn:000035A0 ; ===========================================================================
.text$mn:000035A0
.text$mn:000035A0 ; Segment type: Pure code
.text$mn:000035A0 ; Segment permissions: Read/Execute
.text$mn:000035A0 _text$mn        segment para public 'CODE' use32
.text$mn:000035A0                 assume cs:_text$mn
.text$mn:000035A0                 ;org 35A0h
.text$mn:000035A0 ; COMDAT (pick any)
.text$mn:000035A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000035A0
.text$mn:000035A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000035A0
.text$mn:000035A0 ; Attributes: bp-based frame
.text$mn:000035A0
.text$mn:000035A0 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:000035A0                 public ??0error_category@std@@QAE@XZ
.text$mn:000035A0 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:000035A0
.text$mn:000035A0 var_4           = dword ptr -4
.text$mn:000035A0
.text$mn:000035A0                 push    ebp
.text$mn:000035A1                 mov     ebp, esp
.text$mn:000035A3                 push    ecx
.text$mn:000035A4                 mov     [ebp+var_4], ecx
.text$mn:000035A7                 mov     eax, [ebp+var_4]
.text$mn:000035AA                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:000035B0                 mov     eax, [ebp+var_4]
.text$mn:000035B3                 mov     esp, ebp
.text$mn:000035B5                 pop     ebp
.text$mn:000035B6                 retn
.text$mn:000035B6 ??0error_category@std@@QAE@XZ endp
.text$mn:000035B6
.text$mn:000035B6 ; ---------------------------------------------------------------------------
.text$mn:000035B7                 align 4
.text$mn:000035B7 _text$mn        ends
.text$mn:000035B7
.text$mn:000035B8 ; ===========================================================================
.text$mn:000035B8
.text$mn:000035B8 ; Segment type: Pure code
.text$mn:000035B8 ; Segment permissions: Read/Execute
.text$mn:000035B8 _text$mn        segment para public 'CODE' use32
.text$mn:000035B8                 assume cs:_text$mn
.text$mn:000035B8                 ;org 35B8h
.text$mn:000035B8 ; COMDAT (pick any)
.text$mn:000035B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000035B8
.text$mn:000035B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000035B8
.text$mn:000035B8 ; Attributes: bp-based frame
.text$mn:000035B8
.text$mn:000035B8 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:000035B8                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:000035B8 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:000035B8                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:000035B8                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:000035B8
.text$mn:000035B8 var_4           = dword ptr -4
.text$mn:000035B8 arg_0           = dword ptr  8
.text$mn:000035B8 arg_4           = dword ptr  0Ch
.text$mn:000035B8
.text$mn:000035B8                 push    ebp
.text$mn:000035B9                 mov     ebp, esp
.text$mn:000035BB                 push    ecx
.text$mn:000035BC                 mov     [ebp+var_4], ecx
.text$mn:000035BF                 mov     eax, [ebp+var_4]
.text$mn:000035C2                 mov     ecx, [ebp+arg_0]
.text$mn:000035C5                 mov     [eax], ecx
.text$mn:000035C7                 mov     edx, [ebp+var_4]
.text$mn:000035CA                 mov     eax, [ebp+arg_4]
.text$mn:000035CD                 mov     [edx+4], eax
.text$mn:000035D0                 mov     eax, [ebp+var_4]
.text$mn:000035D3                 mov     esp, ebp
.text$mn:000035D5                 pop     ebp
.text$mn:000035D6                 retn    8
.text$mn:000035D6 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:000035D6
.text$mn:000035D6 ; ---------------------------------------------------------------------------
.text$mn:000035D9                 align 4
.text$mn:000035D9 _text$mn        ends
.text$mn:000035D9
.text$mn:000035DC ; ===========================================================================
.text$mn:000035DC
.text$mn:000035DC ; Segment type: Pure code
.text$mn:000035DC ; Segment permissions: Read/Execute
.text$mn:000035DC _text$mn        segment para public 'CODE' use32
.text$mn:000035DC                 assume cs:_text$mn
.text$mn:000035DC                 ;org 35DCh
.text$mn:000035DC ; COMDAT (pick any)
.text$mn:000035DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000035DC
.text$mn:000035DC ; =============== S U B R O U T I N E =======================================
.text$mn:000035DC
.text$mn:000035DC ; Attributes: bp-based frame
.text$mn:000035DC
.text$mn:000035DC ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:000035DC                 public ??0id@locale@std@@QAE@I@Z
.text$mn:000035DC ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:000035DC                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:000035DC
.text$mn:000035DC var_4           = dword ptr -4
.text$mn:000035DC arg_0           = dword ptr  8
.text$mn:000035DC
.text$mn:000035DC                 push    ebp
.text$mn:000035DD                 mov     ebp, esp
.text$mn:000035DF                 push    ecx
.text$mn:000035E0                 mov     [ebp+var_4], ecx
.text$mn:000035E3                 mov     eax, [ebp+var_4]
.text$mn:000035E6                 mov     ecx, [ebp+arg_0]
.text$mn:000035E9                 mov     [eax], ecx
.text$mn:000035EB                 mov     eax, [ebp+var_4]
.text$mn:000035EE                 mov     esp, ebp
.text$mn:000035F0                 pop     ebp
.text$mn:000035F1                 retn    4
.text$mn:000035F1 ??0id@locale@std@@QAE@I@Z endp
.text$mn:000035F1
.text$mn:000035F1 _text$mn        ends
.text$mn:000035F1
.text$mn:000035F4 ; ===========================================================================
.text$mn:000035F4
.text$mn:000035F4 ; Segment type: Pure code
.text$mn:000035F4 ; Segment permissions: Read/Execute
.text$mn:000035F4 _text$mn        segment para public 'CODE' use32
.text$mn:000035F4                 assume cs:_text$mn
.text$mn:000035F4                 ;org 35F4h
.text$mn:000035F4 ; COMDAT (pick any)
.text$mn:000035F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000035F4
.text$mn:000035F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000035F4
.text$mn:000035F4 ; Attributes: bp-based frame
.text$mn:000035F4
.text$mn:000035F4 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, char, int, char const *, char const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, char, int, char const *, char const &, struct std::_Iterator_base12>(void)
.text$mn:000035F4                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000035F4 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:000035F4                                         ; CODE XREF: __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:000035F4                                         ; __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z$0+3j ...
.text$mn:000035F4
.text$mn:000035F4 var_10          = dword ptr -10h
.text$mn:000035F4 var_C           = dword ptr -0Ch
.text$mn:000035F4 var_4           = dword ptr -4
.text$mn:000035F4
.text$mn:000035F4                 push    ebp
.text$mn:000035F5                 mov     ebp, esp
.text$mn:000035F7                 push    0FFFFFFFFh
.text$mn:000035F9                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:000035FE                 mov     eax, large fs:0
.text$mn:00003604                 push    eax
.text$mn:00003605                 push    ecx
.text$mn:00003606                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000360B                 xor     eax, ebp
.text$mn:0000360D                 push    eax
.text$mn:0000360E                 lea     eax, [ebp+var_C]
.text$mn:00003611                 mov     large fs:0, eax
.text$mn:00003617                 mov     [ebp+var_10], ecx
.text$mn:0000361A                 mov     [ebp+var_4], 0
.text$mn:00003621                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003628                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000362B                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:00003630                 mov     ecx, [ebp+var_C]
.text$mn:00003633                 mov     large fs:0, ecx
.text$mn:0000363A                 pop     ecx
.text$mn:0000363B                 mov     esp, ebp
.text$mn:0000363D                 pop     ebp
.text$mn:0000363E                 retn
.text$mn:0000363E ??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:0000363E
.text$mn:0000363E ; ---------------------------------------------------------------------------
.text$mn:0000363F                 align 10h
.text$mn:0000363F _text$mn        ends
.text$mn:0000363F
.text$x:00003640 ; ===========================================================================
.text$x:00003640
.text$x:00003640 ; Segment type: Pure code
.text$x:00003640 ; Segment permissions: Read/Execute
.text$x:00003640 _text$x         segment para public 'CODE' use32
.text$x:00003640                 assume cs:_text$x
.text$x:00003640                 ;org 3640h
.text$x:00003640 ; COMDAT (pick associative to section at 35F4)
.text$x:00003640                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003640
.text$x:00003640 ; =============== S U B R O U T I N E =======================================
.text$x:00003640
.text$x:00003640
.text$x:00003640 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00003640                                         ; DATA XREF: .xdata$x:00006920o
.text$x:00003640                 mov     ecx, [ebp-10h]  ; this
.text$x:00003643                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00003643 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00003643
.text$x:00003648
.text$x:00003648 ; =============== S U B R O U T I N E =======================================
.text$x:00003648
.text$x:00003648
.text$x:00003648 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00003648                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>(void)+5o
.text$x:00003648
.text$x:00003648 arg_4           = dword ptr  8
.text$x:00003648
.text$x:00003648                 mov     edx, [esp+arg_4]
.text$x:0000364C                 lea     eax, [edx+0Ch]
.text$x:0000364F                 mov     ecx, [edx-8]
.text$x:00003652                 xor     ecx, eax
.text$x:00003654                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003659                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ
.text$x:0000365E                 jmp     ___CxxFrameHandler3
.text$x:0000365E __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:0000365E
.text$x:0000365E ; ---------------------------------------------------------------------------
.text$x:00003663                 align 4
.text$x:00003663 _text$x         ends
.text$x:00003663
.text$mn:00003664 ; ===========================================================================
.text$mn:00003664
.text$mn:00003664 ; Segment type: Pure code
.text$mn:00003664 ; Segment permissions: Read/Execute
.text$mn:00003664 _text$mn        segment para public 'CODE' use32
.text$mn:00003664                 assume cs:_text$mn
.text$mn:00003664                 ;org 3664h
.text$mn:00003664 ; COMDAT (pick any)
.text$mn:00003664                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003664
.text$mn:00003664 ; =============== S U B R O U T I N E =======================================
.text$mn:00003664
.text$mn:00003664 ; Attributes: bp-based frame
.text$mn:00003664
.text$mn:00003664 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00003664                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00003664 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00003664                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00003664                                         ; __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0+3j ...
.text$mn:00003664
.text$mn:00003664 var_10          = dword ptr -10h
.text$mn:00003664 var_C           = dword ptr -0Ch
.text$mn:00003664 var_4           = dword ptr -4
.text$mn:00003664
.text$mn:00003664                 push    ebp
.text$mn:00003665                 mov     ebp, esp
.text$mn:00003667                 push    0FFFFFFFFh
.text$mn:00003669                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:0000366E                 mov     eax, large fs:0
.text$mn:00003674                 push    eax
.text$mn:00003675                 push    ecx
.text$mn:00003676                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000367B                 xor     eax, ebp
.text$mn:0000367D                 push    eax
.text$mn:0000367E                 lea     eax, [ebp+var_C]
.text$mn:00003681                 mov     large fs:0, eax
.text$mn:00003687                 mov     [ebp+var_10], ecx
.text$mn:0000368A                 mov     [ebp+var_4], 0
.text$mn:00003691                 mov     ecx, [ebp+var_10]
.text$mn:00003694                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00003699                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000036A0                 mov     ecx, [ebp+var_10]
.text$mn:000036A3                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:000036A8                 mov     ecx, [ebp+var_C]
.text$mn:000036AB                 mov     large fs:0, ecx
.text$mn:000036B2                 pop     ecx
.text$mn:000036B3                 mov     esp, ebp
.text$mn:000036B5                 pop     ebp
.text$mn:000036B6                 retn
.text$mn:000036B6 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:000036B6
.text$mn:000036B6 ; ---------------------------------------------------------------------------
.text$mn:000036B7                 align 4
.text$mn:000036B7 _text$mn        ends
.text$mn:000036B7
.text$x:000036B8 ; ===========================================================================
.text$x:000036B8
.text$x:000036B8 ; Segment type: Pure code
.text$x:000036B8 ; Segment permissions: Read/Execute
.text$x:000036B8 _text$x         segment para public 'CODE' use32
.text$x:000036B8                 assume cs:_text$x
.text$x:000036B8                 ;org 36B8h
.text$x:000036B8 ; COMDAT (pick associative to section at 3664)
.text$x:000036B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000036B8
.text$x:000036B8 ; =============== S U B R O U T I N E =======================================
.text$x:000036B8
.text$x:000036B8
.text$x:000036B8 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000036B8                                         ; DATA XREF: .xdata$x:00006264o
.text$x:000036B8                 mov     ecx, [ebp-10h]
.text$x:000036BB                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:000036BB __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000036BB
.text$x:000036C0
.text$x:000036C0 ; =============== S U B R O U T I N E =======================================
.text$x:000036C0
.text$x:000036C0
.text$x:000036C0 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:000036C0                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:000036C0
.text$x:000036C0 arg_4           = dword ptr  8
.text$x:000036C0
.text$x:000036C0                 mov     edx, [esp+arg_4]
.text$x:000036C4                 lea     eax, [edx+0Ch]
.text$x:000036C7                 mov     ecx, [edx-8]
.text$x:000036CA                 xor     ecx, eax
.text$x:000036CC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000036D1                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:000036D6                 jmp     ___CxxFrameHandler3
.text$x:000036D6 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:000036D6
.text$x:000036D6 ; ---------------------------------------------------------------------------
.text$x:000036DB                 align 4
.text$x:000036DB _text$x         ends
.text$x:000036DB
.text$mn:000036DC ; ===========================================================================
.text$mn:000036DC
.text$mn:000036DC ; Segment type: Pure code
.text$mn:000036DC ; Segment permissions: Read/Execute
.text$mn:000036DC _text$mn        segment para public 'CODE' use32
.text$mn:000036DC                 assume cs:_text$mn
.text$mn:000036DC                 ;org 36DCh
.text$mn:000036DC ; COMDAT (pick any)
.text$mn:000036DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000036DC
.text$mn:000036DC ; =============== S U B R O U T I N E =======================================
.text$mn:000036DC
.text$mn:000036DC ; Attributes: bp-based frame
.text$mn:000036DC
.text$mn:000036DC ; public: __thiscall std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<char>>>::~_String_const_iterator<class std::_String_val<struct std::_Simple_types<char>>>(void)
.text$mn:000036DC                 public ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
.text$mn:000036DC ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000036DC                                         ; CODE XREF: __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:000036DC                                         ; __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z$0+3j ...
.text$mn:000036DC
.text$mn:000036DC var_10          = dword ptr -10h
.text$mn:000036DC var_C           = dword ptr -0Ch
.text$mn:000036DC var_4           = dword ptr -4
.text$mn:000036DC
.text$mn:000036DC                 push    ebp
.text$mn:000036DD                 mov     ebp, esp
.text$mn:000036DF                 push    0FFFFFFFFh
.text$mn:000036E1                 push    offset __ehhandler$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
.text$mn:000036E6                 mov     eax, large fs:0
.text$mn:000036EC                 push    eax
.text$mn:000036ED                 push    ecx
.text$mn:000036EE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000036F3                 xor     eax, ebp
.text$mn:000036F5                 push    eax
.text$mn:000036F6                 lea     eax, [ebp+var_C]
.text$mn:000036F9                 mov     large fs:0, eax
.text$mn:000036FF                 mov     [ebp+var_10], ecx
.text$mn:00003702                 mov     [ebp+var_4], 0
.text$mn:00003709                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003710                 mov     ecx, [ebp+var_10]
.text$mn:00003713                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>(void)
.text$mn:00003718                 mov     ecx, [ebp+var_C]
.text$mn:0000371B                 mov     large fs:0, ecx
.text$mn:00003722                 pop     ecx
.text$mn:00003723                 mov     esp, ebp
.text$mn:00003725                 pop     ebp
.text$mn:00003726                 retn
.text$mn:00003726 ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00003726
.text$mn:00003726 ; ---------------------------------------------------------------------------
.text$mn:00003727                 align 4
.text$mn:00003727 _text$mn        ends
.text$mn:00003727
.text$x:00003728 ; ===========================================================================
.text$x:00003728
.text$x:00003728 ; Segment type: Pure code
.text$x:00003728 ; Segment permissions: Read/Execute
.text$x:00003728 _text$x         segment para public 'CODE' use32
.text$x:00003728                 assume cs:_text$x
.text$x:00003728                 ;org 3728h
.text$x:00003728 ; COMDAT (pick associative to section at 36DC)
.text$x:00003728                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003728
.text$x:00003728 ; =============== S U B R O U T I N E =======================================
.text$x:00003728
.text$x:00003728
.text$x:00003728 __unwindfunclet$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003728                                         ; DATA XREF: .xdata$x:000069A4o
.text$x:00003728                 mov     ecx, [ebp-10h]
.text$x:0000372B                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base12>(void)
.text$x:0000372B __unwindfunclet$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000372B
.text$x:00003730
.text$x:00003730 ; =============== S U B R O U T I N E =======================================
.text$x:00003730
.text$x:00003730
.text$x:00003730 __ehhandler$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00003730                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(void)+5o
.text$x:00003730
.text$x:00003730 arg_4           = dword ptr  8
.text$x:00003730
.text$x:00003730                 mov     edx, [esp+arg_4]
.text$x:00003734                 lea     eax, [edx+0Ch]
.text$x:00003737                 mov     ecx, [edx-8]
.text$x:0000373A                 xor     ecx, eax
.text$x:0000373C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003741                 mov     eax, offset __ehfuncinfo$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
.text$x:00003746                 jmp     ___CxxFrameHandler3
.text$x:00003746 __ehhandler$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00003746
.text$x:00003746 ; ---------------------------------------------------------------------------
.text$x:0000374B                 align 4
.text$x:0000374B _text$x         ends
.text$x:0000374B
.text$mn:0000374C ; ===========================================================================
.text$mn:0000374C
.text$mn:0000374C ; Segment type: Pure code
.text$mn:0000374C ; Segment permissions: Read/Execute
.text$mn:0000374C _text$mn        segment para public 'CODE' use32
.text$mn:0000374C                 assume cs:_text$mn
.text$mn:0000374C                 ;org 374Ch
.text$mn:0000374C ; COMDAT (pick any)
.text$mn:0000374C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000374C
.text$mn:0000374C ; =============== S U B R O U T I N E =======================================
.text$mn:0000374C
.text$mn:0000374C ; Attributes: bp-based frame
.text$mn:0000374C
.text$mn:0000374C ; public: __thiscall std::_String_iterator<class std::_String_val<struct std::_Simple_types<char>>>::~_String_iterator<class std::_String_val<struct std::_Simple_types<char>>>(void)
.text$mn:0000374C                 public ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
.text$mn:0000374C ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:0000374C                                         ; CODE XREF: std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::operator+(int)+67p
.text$mn:0000374C                                         ; __unwindfunclet$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE?AV01@H@Z$0+3j ...
.text$mn:0000374C
.text$mn:0000374C var_10          = dword ptr -10h
.text$mn:0000374C var_C           = dword ptr -0Ch
.text$mn:0000374C var_4           = dword ptr -4
.text$mn:0000374C
.text$mn:0000374C                 push    ebp
.text$mn:0000374D                 mov     ebp, esp
.text$mn:0000374F                 push    0FFFFFFFFh
.text$mn:00003751                 push    offset __ehhandler$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
.text$mn:00003756                 mov     eax, large fs:0
.text$mn:0000375C                 push    eax
.text$mn:0000375D                 push    ecx
.text$mn:0000375E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003763                 xor     eax, ebp
.text$mn:00003765                 push    eax
.text$mn:00003766                 lea     eax, [ebp+var_C]
.text$mn:00003769                 mov     large fs:0, eax
.text$mn:0000376F                 mov     [ebp+var_10], ecx
.text$mn:00003772                 mov     [ebp+var_4], 0
.text$mn:00003779                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003780                 mov     ecx, [ebp+var_10]
.text$mn:00003783                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$mn:00003788                 mov     ecx, [ebp+var_C]
.text$mn:0000378B                 mov     large fs:0, ecx
.text$mn:00003792                 pop     ecx
.text$mn:00003793                 mov     esp, ebp
.text$mn:00003795                 pop     ebp
.text$mn:00003796                 retn
.text$mn:00003796 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00003796
.text$mn:00003796 ; ---------------------------------------------------------------------------
.text$mn:00003797                 align 4
.text$mn:00003797 _text$mn        ends
.text$mn:00003797
.text$x:00003798 ; ===========================================================================
.text$x:00003798
.text$x:00003798 ; Segment type: Pure code
.text$x:00003798 ; Segment permissions: Read/Execute
.text$x:00003798 _text$x         segment para public 'CODE' use32
.text$x:00003798                 assume cs:_text$x
.text$x:00003798                 ;org 3798h
.text$x:00003798 ; COMDAT (pick associative to section at 374C)
.text$x:00003798                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003798
.text$x:00003798 ; =============== S U B R O U T I N E =======================================
.text$x:00003798
.text$x:00003798
.text$x:00003798 __unwindfunclet$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003798                                         ; DATA XREF: .xdata$x:00006A5Co
.text$x:00003798                 mov     ecx, [ebp-10h]
.text$x:0000379B                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$x:0000379B __unwindfunclet$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000379B
.text$x:000037A0
.text$x:000037A0 ; =============== S U B R O U T I N E =======================================
.text$x:000037A0
.text$x:000037A0
.text$x:000037A0 __ehhandler$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:000037A0                                         ; DATA XREF: std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_iterator<std::_String_val<std::_Simple_types<char>>>(void)+5o
.text$x:000037A0
.text$x:000037A0 arg_4           = dword ptr  8
.text$x:000037A0
.text$x:000037A0                 mov     edx, [esp+arg_4]
.text$x:000037A4                 lea     eax, [edx+0Ch]
.text$x:000037A7                 mov     ecx, [edx-8]
.text$x:000037AA                 xor     ecx, eax
.text$x:000037AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000037B1                 mov     eax, offset __ehfuncinfo$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
.text$x:000037B6                 jmp     ___CxxFrameHandler3
.text$x:000037B6 __ehhandler$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ endp
.text$x:000037B6
.text$x:000037B6 ; ---------------------------------------------------------------------------
.text$x:000037BB                 align 4
.text$x:000037BB _text$x         ends
.text$x:000037BB
.text$mn:000037BC ; ===========================================================================
.text$mn:000037BC
.text$mn:000037BC ; Segment type: Pure code
.text$mn:000037BC ; Segment permissions: Read/Execute
.text$mn:000037BC _text$mn        segment para public 'CODE' use32
.text$mn:000037BC                 assume cs:_text$mn
.text$mn:000037BC                 ;org 37BCh
.text$mn:000037BC ; COMDAT (pick any)
.text$mn:000037BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000037BC
.text$mn:000037BC ; =============== S U B R O U T I N E =======================================
.text$mn:000037BC
.text$mn:000037BC ; Attributes: bp-based frame
.text$mn:000037BC
.text$mn:000037BC ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000037BC                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000037BC ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000037BC                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:000037BC                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:000037BC
.text$mn:000037BC var_10          = dword ptr -10h
.text$mn:000037BC var_C           = dword ptr -0Ch
.text$mn:000037BC var_4           = dword ptr -4
.text$mn:000037BC
.text$mn:000037BC                 push    ebp
.text$mn:000037BD                 mov     ebp, esp
.text$mn:000037BF                 push    0FFFFFFFFh
.text$mn:000037C1                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000037C6                 mov     eax, large fs:0
.text$mn:000037CC                 push    eax
.text$mn:000037CD                 push    ecx
.text$mn:000037CE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000037D3                 xor     eax, ebp
.text$mn:000037D5                 push    eax
.text$mn:000037D6                 lea     eax, [ebp+var_C]
.text$mn:000037D9                 mov     large fs:0, eax
.text$mn:000037DF                 mov     [ebp+var_10], ecx
.text$mn:000037E2                 mov     [ebp+var_4], 0
.text$mn:000037E9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000037F0                 mov     ecx, [ebp+var_10] ; this
.text$mn:000037F3                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000037F8                 mov     ecx, [ebp+var_C]
.text$mn:000037FB                 mov     large fs:0, ecx
.text$mn:00003802                 pop     ecx
.text$mn:00003803                 mov     esp, ebp
.text$mn:00003805                 pop     ebp
.text$mn:00003806                 retn
.text$mn:00003806 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00003806
.text$mn:00003806 ; ---------------------------------------------------------------------------
.text$mn:00003807                 align 4
.text$mn:00003807 _text$mn        ends
.text$mn:00003807
.text$x:00003808 ; ===========================================================================
.text$x:00003808
.text$x:00003808 ; Segment type: Pure code
.text$x:00003808 ; Segment permissions: Read/Execute
.text$x:00003808 _text$x         segment para public 'CODE' use32
.text$x:00003808                 assume cs:_text$x
.text$x:00003808                 ;org 3808h
.text$x:00003808 ; COMDAT (pick associative to section at 37BC)
.text$x:00003808                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003808
.text$x:00003808 ; =============== S U B R O U T I N E =======================================
.text$x:00003808
.text$x:00003808
.text$x:00003808 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00003808                                         ; DATA XREF: .xdata$x:0000620Co
.text$x:00003808                 mov     ecx, [ebp-10h]  ; this
.text$x:0000380B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000380B __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:0000380B
.text$x:00003810
.text$x:00003810 ; =============== S U B R O U T I N E =======================================
.text$x:00003810
.text$x:00003810
.text$x:00003810 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00003810                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00003810
.text$x:00003810 arg_4           = dword ptr  8
.text$x:00003810
.text$x:00003810                 mov     edx, [esp+arg_4]
.text$x:00003814                 lea     eax, [edx+0Ch]
.text$x:00003817                 mov     ecx, [edx-8]
.text$x:0000381A                 xor     ecx, eax
.text$x:0000381C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003821                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00003826                 jmp     ___CxxFrameHandler3
.text$x:00003826 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00003826
.text$x:00003826 ; ---------------------------------------------------------------------------
.text$x:0000382B                 align 4
.text$x:0000382B _text$x         ends
.text$x:0000382B
.text$mn:0000382C ; ===========================================================================
.text$mn:0000382C
.text$mn:0000382C ; Segment type: Pure code
.text$mn:0000382C ; Segment permissions: Read/Execute
.text$mn:0000382C _text$mn        segment para public 'CODE' use32
.text$mn:0000382C                 assume cs:_text$mn
.text$mn:0000382C                 ;org 382Ch
.text$mn:0000382C ; COMDAT (pick any)
.text$mn:0000382C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000382C
.text$mn:0000382C ; =============== S U B R O U T I N E =======================================
.text$mn:0000382C
.text$mn:0000382C ; Attributes: bp-based frame
.text$mn:0000382C
.text$mn:0000382C ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>>::~_Vector_alloc<0, struct std::_Vec_base_types<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>>(void)
.text$mn:0000382C                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@XZ
.text$mn:0000382C ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@XZ proc near
.text$mn:0000382C                                         ; CODE XREF: __unwindfunclet$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@$$QAV01@@Z$0+3j
.text$mn:0000382C                                         ; __unwindfunclet$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ$0+3j ...
.text$mn:0000382C
.text$mn:0000382C var_10          = dword ptr -10h
.text$mn:0000382C var_C           = dword ptr -0Ch
.text$mn:0000382C var_4           = dword ptr -4
.text$mn:0000382C
.text$mn:0000382C                 push    ebp
.text$mn:0000382D                 mov     ebp, esp
.text$mn:0000382F                 push    0FFFFFFFFh
.text$mn:00003831                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@XZ
.text$mn:00003836                 mov     eax, large fs:0
.text$mn:0000383C                 push    eax
.text$mn:0000383D                 push    ecx
.text$mn:0000383E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003843                 xor     eax, ebp
.text$mn:00003845                 push    eax
.text$mn:00003846                 lea     eax, [ebp+var_C]
.text$mn:00003849                 mov     large fs:0, eax
.text$mn:0000384F                 mov     [ebp+var_10], ecx
.text$mn:00003852                 mov     [ebp+var_4], 0
.text$mn:00003859                 mov     ecx, [ebp+var_10]
.text$mn:0000385C                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Free_proxy(void)
.text$mn:00003861                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003868                 mov     ecx, [ebp+var_10]
.text$mn:0000386B                 call    ??1?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::pair<int,int>>>::~_Vector_val<std::_Simple_types<std::pair<int,int>>>(void)
.text$mn:00003870                 mov     ecx, [ebp+var_C]
.text$mn:00003873                 mov     large fs:0, ecx
.text$mn:0000387A                 pop     ecx
.text$mn:0000387B                 mov     esp, ebp
.text$mn:0000387D                 pop     ebp
.text$mn:0000387E                 retn
.text$mn:0000387E ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@XZ endp
.text$mn:0000387E
.text$mn:0000387E ; ---------------------------------------------------------------------------
.text$mn:0000387F                 align 10h
.text$mn:0000387F _text$mn        ends
.text$mn:0000387F
.text$x:00003880 ; ===========================================================================
.text$x:00003880
.text$x:00003880 ; Segment type: Pure code
.text$x:00003880 ; Segment permissions: Read/Execute
.text$x:00003880 _text$x         segment para public 'CODE' use32
.text$x:00003880                 assume cs:_text$x
.text$x:00003880                 ;org 3880h
.text$x:00003880 ; COMDAT (pick associative to section at 382C)
.text$x:00003880                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003880
.text$x:00003880 ; =============== S U B R O U T I N E =======================================
.text$x:00003880
.text$x:00003880
.text$x:00003880 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003880                                         ; DATA XREF: .xdata$x:000067C0o
.text$x:00003880                 mov     ecx, [ebp-10h]
.text$x:00003883                 jmp     ??1?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::pair<int,int>>>::~_Vector_val<std::_Simple_types<std::pair<int,int>>>(void)
.text$x:00003883 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@XZ$0 endp
.text$x:00003883
.text$x:00003888
.text$x:00003888 ; =============== S U B R O U T I N E =======================================
.text$x:00003888
.text$x:00003888
.text$x:00003888 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@XZ proc near
.text$x:00003888                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>(void)+5o
.text$x:00003888
.text$x:00003888 arg_4           = dword ptr  8
.text$x:00003888
.text$x:00003888                 mov     edx, [esp+arg_4]
.text$x:0000388C                 lea     eax, [edx+0Ch]
.text$x:0000388F                 mov     ecx, [edx-8]
.text$x:00003892                 xor     ecx, eax
.text$x:00003894                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003899                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@XZ
.text$x:0000389E                 jmp     ___CxxFrameHandler3
.text$x:0000389E __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@XZ endp
.text$x:0000389E
.text$x:0000389E ; ---------------------------------------------------------------------------
.text$x:000038A3                 align 4
.text$x:000038A3 _text$x         ends
.text$x:000038A3
.text$mn:000038A4 ; ===========================================================================
.text$mn:000038A4
.text$mn:000038A4 ; Segment type: Pure code
.text$mn:000038A4 ; Segment permissions: Read/Execute
.text$mn:000038A4 _text$mn        segment para public 'CODE' use32
.text$mn:000038A4                 assume cs:_text$mn
.text$mn:000038A4                 ;org 38A4h
.text$mn:000038A4 ; COMDAT (pick any)
.text$mn:000038A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000038A4
.text$mn:000038A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000038A4
.text$mn:000038A4 ; Attributes: bp-based frame
.text$mn:000038A4
.text$mn:000038A4 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct std::pair<int, int>>>::~_Vector_val<struct std::_Simple_types<struct std::pair<int, int>>>(void)
.text$mn:000038A4                 public ??1?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ
.text$mn:000038A4 ??1?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000038A4                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@HH@std@@@1@@Z$0+3j
.text$mn:000038A4                                         ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>(void)+3Fp ...
.text$mn:000038A4
.text$mn:000038A4 var_10          = dword ptr -10h
.text$mn:000038A4 var_C           = dword ptr -0Ch
.text$mn:000038A4 var_4           = dword ptr -4
.text$mn:000038A4
.text$mn:000038A4                 push    ebp
.text$mn:000038A5                 mov     ebp, esp
.text$mn:000038A7                 push    0FFFFFFFFh
.text$mn:000038A9                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ
.text$mn:000038AE                 mov     eax, large fs:0
.text$mn:000038B4                 push    eax
.text$mn:000038B5                 push    ecx
.text$mn:000038B6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000038BB                 xor     eax, ebp
.text$mn:000038BD                 push    eax
.text$mn:000038BE                 lea     eax, [ebp+var_C]
.text$mn:000038C1                 mov     large fs:0, eax
.text$mn:000038C7                 mov     [ebp+var_10], ecx
.text$mn:000038CA                 mov     [ebp+var_4], 0
.text$mn:000038D1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000038D8                 mov     ecx, [ebp+var_10] ; this
.text$mn:000038DB                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000038E0                 mov     ecx, [ebp+var_C]
.text$mn:000038E3                 mov     large fs:0, ecx
.text$mn:000038EA                 pop     ecx
.text$mn:000038EB                 mov     esp, ebp
.text$mn:000038ED                 pop     ebp
.text$mn:000038EE                 retn
.text$mn:000038EE ??1?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ endp
.text$mn:000038EE
.text$mn:000038EE ; ---------------------------------------------------------------------------
.text$mn:000038EF                 align 10h
.text$mn:000038EF _text$mn        ends
.text$mn:000038EF
.text$x:000038F0 ; ===========================================================================
.text$x:000038F0
.text$x:000038F0 ; Segment type: Pure code
.text$x:000038F0 ; Segment permissions: Read/Execute
.text$x:000038F0 _text$x         segment para public 'CODE' use32
.text$x:000038F0                 assume cs:_text$x
.text$x:000038F0                 ;org 38F0h
.text$x:000038F0 ; COMDAT (pick associative to section at 38A4)
.text$x:000038F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000038F0
.text$x:000038F0 ; =============== S U B R O U T I N E =======================================
.text$x:000038F0
.text$x:000038F0
.text$x:000038F0 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000038F0                                         ; DATA XREF: .xdata$x:00006768o
.text$x:000038F0                 mov     ecx, [ebp-10h]  ; this
.text$x:000038F3                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000038F3 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000038F3
.text$x:000038F8
.text$x:000038F8 ; =============== S U B R O U T I N E =======================================
.text$x:000038F8
.text$x:000038F8
.text$x:000038F8 __ehhandler$??1?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ proc near
.text$x:000038F8                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<std::pair<int,int>>>::~_Vector_val<std::_Simple_types<std::pair<int,int>>>(void)+5o
.text$x:000038F8
.text$x:000038F8 arg_4           = dword ptr  8
.text$x:000038F8
.text$x:000038F8                 mov     edx, [esp+arg_4]
.text$x:000038FC                 lea     eax, [edx+0Ch]
.text$x:000038FF                 mov     ecx, [edx-8]
.text$x:00003902                 xor     ecx, eax
.text$x:00003904                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003909                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ
.text$x:0000390E                 jmp     ___CxxFrameHandler3
.text$x:0000390E __ehhandler$??1?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ endp
.text$x:0000390E
.text$x:0000390E ; ---------------------------------------------------------------------------
.text$x:00003913                 align 4
.text$x:00003913 _text$x         ends
.text$x:00003913
.text$mn:00003914 ; ===========================================================================
.text$mn:00003914
.text$mn:00003914 ; Segment type: Pure code
.text$mn:00003914 ; Segment permissions: Read/Execute
.text$mn:00003914 _text$mn        segment para public 'CODE' use32
.text$mn:00003914                 assume cs:_text$mn
.text$mn:00003914                 ;org 3914h
.text$mn:00003914 ; COMDAT (pick any)
.text$mn:00003914                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003914
.text$mn:00003914 ; =============== S U B R O U T I N E =======================================
.text$mn:00003914
.text$mn:00003914 ; Attributes: bp-based frame
.text$mn:00003914
.text$mn:00003914 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00003914                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00003914 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00003914                                         ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+168p
.text$mn:00003914                                         ; XmlMatchedTagsHighlighter::tagMatch(bool)+177p ...
.text$mn:00003914
.text$mn:00003914 var_10          = dword ptr -10h
.text$mn:00003914 var_C           = dword ptr -0Ch
.text$mn:00003914 var_4           = dword ptr -4
.text$mn:00003914
.text$mn:00003914                 push    ebp
.text$mn:00003915                 mov     ebp, esp
.text$mn:00003917                 push    0FFFFFFFFh
.text$mn:00003919                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:0000391E                 mov     eax, large fs:0
.text$mn:00003924                 push    eax
.text$mn:00003925                 push    ecx
.text$mn:00003926                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000392B                 xor     eax, ebp
.text$mn:0000392D                 push    eax
.text$mn:0000392E                 lea     eax, [ebp+var_C]
.text$mn:00003931                 mov     large fs:0, eax
.text$mn:00003937                 mov     [ebp+var_10], ecx
.text$mn:0000393A                 mov     [ebp+var_4], 0
.text$mn:00003941                 push    0               ; Size
.text$mn:00003943                 push    1               ; char
.text$mn:00003945                 mov     ecx, [ebp+var_10]
.text$mn:00003948                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000394D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003954                 mov     ecx, [ebp+var_10]
.text$mn:00003957                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:0000395C                 mov     ecx, [ebp+var_C]
.text$mn:0000395F                 mov     large fs:0, ecx
.text$mn:00003966                 pop     ecx
.text$mn:00003967                 mov     esp, ebp
.text$mn:00003969                 pop     ebp
.text$mn:0000396A                 retn
.text$mn:0000396A ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:0000396A
.text$mn:0000396A ; ---------------------------------------------------------------------------
.text$mn:0000396B                 align 4
.text$mn:0000396B _text$mn        ends
.text$mn:0000396B
.text$x:0000396C ; ===========================================================================
.text$x:0000396C
.text$x:0000396C ; Segment type: Pure code
.text$x:0000396C ; Segment permissions: Read/Execute
.text$x:0000396C _text$x         segment para public 'CODE' use32
.text$x:0000396C                 assume cs:_text$x
.text$x:0000396C                 ;org 396Ch
.text$x:0000396C ; COMDAT (pick associative to section at 3914)
.text$x:0000396C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000396C
.text$x:0000396C ; =============== S U B R O U T I N E =======================================
.text$x:0000396C
.text$x:0000396C
.text$x:0000396C __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:0000396C                                         ; DATA XREF: .xdata$x:000062E8o
.text$x:0000396C                 mov     ecx, [ebp-10h]
.text$x:0000396F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000396F __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:0000396F
.text$x:00003974
.text$x:00003974 ; =============== S U B R O U T I N E =======================================
.text$x:00003974
.text$x:00003974
.text$x:00003974 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00003974                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00003974
.text$x:00003974 arg_4           = dword ptr  8
.text$x:00003974
.text$x:00003974                 mov     edx, [esp+arg_4]
.text$x:00003978                 lea     eax, [edx+0Ch]
.text$x:0000397B                 mov     ecx, [edx-8]
.text$x:0000397E                 xor     ecx, eax
.text$x:00003980                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003985                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:0000398A                 jmp     ___CxxFrameHandler3
.text$x:0000398A __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:0000398A
.text$x:0000398A ; ---------------------------------------------------------------------------
.text$x:0000398F                 align 10h
.text$x:0000398F _text$x         ends
.text$x:0000398F
.text$mn:00003990 ; ===========================================================================
.text$mn:00003990
.text$mn:00003990 ; Segment type: Pure code
.text$mn:00003990 ; Segment permissions: Read/Execute
.text$mn:00003990 _text$mn        segment para public 'CODE' use32
.text$mn:00003990                 assume cs:_text$mn
.text$mn:00003990                 ;org 3990h
.text$mn:00003990 ; COMDAT (pick any)
.text$mn:00003990                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003990
.text$mn:00003990 ; =============== S U B R O U T I N E =======================================
.text$mn:00003990
.text$mn:00003990 ; Attributes: bp-based frame
.text$mn:00003990
.text$mn:00003990 ; public: __thiscall std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>::~vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>(void)
.text$mn:00003990                 public ??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ
.text$mn:00003990 ??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ proc near
.text$mn:00003990                                         ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+37Ep
.text$mn:00003990                                         ; XmlMatchedTagsHighlighter::getAttributesPos(int,int)+241p ...
.text$mn:00003990
.text$mn:00003990 var_10          = dword ptr -10h
.text$mn:00003990 var_C           = dword ptr -0Ch
.text$mn:00003990 var_4           = dword ptr -4
.text$mn:00003990
.text$mn:00003990                 push    ebp
.text$mn:00003991                 mov     ebp, esp
.text$mn:00003993                 push    0FFFFFFFFh
.text$mn:00003995                 push    offset __ehhandler$??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ
.text$mn:0000399A                 mov     eax, large fs:0
.text$mn:000039A0                 push    eax
.text$mn:000039A1                 push    ecx
.text$mn:000039A2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000039A7                 xor     eax, ebp
.text$mn:000039A9                 push    eax
.text$mn:000039AA                 lea     eax, [ebp+var_C]
.text$mn:000039AD                 mov     large fs:0, eax
.text$mn:000039B3                 mov     [ebp+var_10], ecx
.text$mn:000039B6                 mov     [ebp+var_4], 0
.text$mn:000039BD                 mov     ecx, [ebp+var_10]
.text$mn:000039C0                 call    ?_Tidy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Tidy(void)
.text$mn:000039C5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000039CC                 mov     ecx, [ebp+var_10]
.text$mn:000039CF                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>(void)
.text$mn:000039D4                 mov     ecx, [ebp+var_C]
.text$mn:000039D7                 mov     large fs:0, ecx
.text$mn:000039DE                 pop     ecx
.text$mn:000039DF                 mov     esp, ebp
.text$mn:000039E1                 pop     ebp
.text$mn:000039E2                 retn
.text$mn:000039E2 ??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ endp
.text$mn:000039E2
.text$mn:000039E2 ; ---------------------------------------------------------------------------
.text$mn:000039E3                 align 4
.text$mn:000039E3 _text$mn        ends
.text$mn:000039E3
.text$x:000039E4 ; ===========================================================================
.text$x:000039E4
.text$x:000039E4 ; Segment type: Pure code
.text$x:000039E4 ; Segment permissions: Read/Execute
.text$x:000039E4 _text$x         segment para public 'CODE' use32
.text$x:000039E4                 assume cs:_text$x
.text$x:000039E4                 ;org 39E4h
.text$x:000039E4 ; COMDAT (pick associative to section at 3990)
.text$x:000039E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000039E4
.text$x:000039E4 ; =============== S U B R O U T I N E =======================================
.text$x:000039E4
.text$x:000039E4
.text$x:000039E4 __unwindfunclet$??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ$0 proc near
.text$x:000039E4                                         ; DATA XREF: .xdata$x:00006844o
.text$x:000039E4                 mov     ecx, [ebp-10h]
.text$x:000039E7                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>(void)
.text$x:000039E7 __unwindfunclet$??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ$0 endp
.text$x:000039E7
.text$x:000039EC
.text$x:000039EC ; =============== S U B R O U T I N E =======================================
.text$x:000039EC
.text$x:000039EC
.text$x:000039EC __ehhandler$??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ proc near
.text$x:000039EC                                         ; DATA XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::~vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>(void)+5o
.text$x:000039EC
.text$x:000039EC arg_4           = dword ptr  8
.text$x:000039EC
.text$x:000039EC                 mov     edx, [esp+arg_4]
.text$x:000039F0                 lea     eax, [edx+0Ch]
.text$x:000039F3                 mov     ecx, [edx-8]
.text$x:000039F6                 xor     ecx, eax
.text$x:000039F8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000039FD                 mov     eax, offset __ehfuncinfo$??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ
.text$x:00003A02                 jmp     ___CxxFrameHandler3
.text$x:00003A02 __ehhandler$??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ endp
.text$x:00003A02
.text$x:00003A02 ; ---------------------------------------------------------------------------
.text$x:00003A07                 align 4
.text$x:00003A07 _text$x         ends
.text$x:00003A07
.text$mn:00003A08 ; ===========================================================================
.text$mn:00003A08
.text$mn:00003A08 ; Segment type: Pure code
.text$mn:00003A08 ; Segment permissions: Read/Execute
.text$mn:00003A08 _text$mn        segment para public 'CODE' use32
.text$mn:00003A08                 assume cs:_text$mn
.text$mn:00003A08                 ;org 3A08h
.text$mn:00003A08 ; COMDAT (pick any)
.text$mn:00003A08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A08
.text$mn:00003A08 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A08
.text$mn:00003A08 ; Attributes: bp-based frame
.text$mn:00003A08
.text$mn:00003A08 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00003A08                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00003A08 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00003A08                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00003A08                                         ; __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ$0+3j ...
.text$mn:00003A08
.text$mn:00003A08 var_4           = dword ptr -4
.text$mn:00003A08
.text$mn:00003A08                 push    ebp
.text$mn:00003A09                 mov     ebp, esp
.text$mn:00003A0B                 push    ecx
.text$mn:00003A0C                 mov     [ebp+var_4], ecx
.text$mn:00003A0F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003A12                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00003A17                 mov     esp, ebp
.text$mn:00003A19                 pop     ebp
.text$mn:00003A1A                 retn
.text$mn:00003A1A ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00003A1A
.text$mn:00003A1A ; ---------------------------------------------------------------------------
.text$mn:00003A1B                 align 4
.text$mn:00003A1B _text$mn        ends
.text$mn:00003A1B
.text$mn:00003A1C ; ===========================================================================
.text$mn:00003A1C
.text$mn:00003A1C ; Segment type: Pure code
.text$mn:00003A1C ; Segment permissions: Read/Execute
.text$mn:00003A1C _text$mn        segment para public 'CODE' use32
.text$mn:00003A1C                 assume cs:_text$mn
.text$mn:00003A1C                 ;org 3A1Ch
.text$mn:00003A1C ; COMDAT (pick any)
.text$mn:00003A1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A1C
.text$mn:00003A1C ; =============== S U B R O U T I N E =======================================
.text$mn:00003A1C
.text$mn:00003A1C ; Attributes: bp-based frame
.text$mn:00003A1C
.text$mn:00003A1C ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00003A1C                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00003A1C ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00003A1C                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00003A1C                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00003A1C
.text$mn:00003A1C var_10          = dword ptr -10h
.text$mn:00003A1C var_C           = dword ptr -0Ch
.text$mn:00003A1C var_4           = dword ptr -4
.text$mn:00003A1C
.text$mn:00003A1C                 push    ebp
.text$mn:00003A1D                 mov     ebp, esp
.text$mn:00003A1F                 push    0FFFFFFFFh
.text$mn:00003A21                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00003A26                 mov     eax, large fs:0
.text$mn:00003A2C                 push    eax
.text$mn:00003A2D                 push    ecx
.text$mn:00003A2E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003A33                 xor     eax, ebp
.text$mn:00003A35                 push    eax
.text$mn:00003A36                 lea     eax, [ebp+var_C]
.text$mn:00003A39                 mov     large fs:0, eax
.text$mn:00003A3F                 mov     [ebp+var_10], ecx
.text$mn:00003A42                 mov     [ebp+var_4], 0
.text$mn:00003A49                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003A50                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003A53                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00003A58                 mov     ecx, [ebp+var_C]
.text$mn:00003A5B                 mov     large fs:0, ecx
.text$mn:00003A62                 pop     ecx
.text$mn:00003A63                 mov     esp, ebp
.text$mn:00003A65                 pop     ebp
.text$mn:00003A66                 retn
.text$mn:00003A66 ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00003A66
.text$mn:00003A66 ; ---------------------------------------------------------------------------
.text$mn:00003A67                 align 4
.text$mn:00003A67 _text$mn        ends
.text$mn:00003A67
.text$x:00003A68 ; ===========================================================================
.text$x:00003A68
.text$x:00003A68 ; Segment type: Pure code
.text$x:00003A68 ; Segment permissions: Read/Execute
.text$x:00003A68 _text$x         segment para public 'CODE' use32
.text$x:00003A68                 assume cs:_text$x
.text$x:00003A68                 ;org 3A68h
.text$x:00003A68 ; COMDAT (pick associative to section at 3A1C)
.text$x:00003A68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003A68
.text$x:00003A68 ; =============== S U B R O U T I N E =======================================
.text$x:00003A68
.text$x:00003A68
.text$x:00003A68 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00003A68                                         ; DATA XREF: .xdata$x:0000650Co
.text$x:00003A68                 mov     ecx, [ebp-10h]  ; this
.text$x:00003A6B                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00003A6B __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00003A6B
.text$x:00003A70
.text$x:00003A70 ; =============== S U B R O U T I N E =======================================
.text$x:00003A70
.text$x:00003A70
.text$x:00003A70 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00003A70                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00003A70
.text$x:00003A70 arg_4           = dword ptr  8
.text$x:00003A70
.text$x:00003A70                 mov     edx, [esp+arg_4]
.text$x:00003A74                 lea     eax, [edx+0Ch]
.text$x:00003A77                 mov     ecx, [edx-8]
.text$x:00003A7A                 xor     ecx, eax
.text$x:00003A7C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003A81                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00003A86                 jmp     ___CxxFrameHandler3
.text$x:00003A86 __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00003A86
.text$x:00003A86 ; ---------------------------------------------------------------------------
.text$x:00003A8B                 align 4
.text$x:00003A8B _text$x         ends
.text$x:00003A8B
.text$mn:00003A8C ; ===========================================================================
.text$mn:00003A8C
.text$mn:00003A8C ; Segment type: Pure code
.text$mn:00003A8C ; Segment permissions: Read/Execute
.text$mn:00003A8C _text$mn        segment para public 'CODE' use32
.text$mn:00003A8C                 assume cs:_text$mn
.text$mn:00003A8C                 ;org 3A8Ch
.text$mn:00003A8C ; COMDAT (pick any)
.text$mn:00003A8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003A8C
.text$mn:00003A8C ; =============== S U B R O U T I N E =======================================
.text$mn:00003A8C
.text$mn:00003A8C ; Attributes: bp-based frame
.text$mn:00003A8C
.text$mn:00003A8C ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00003A8C                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00003A8C ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00003A8C                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00003A8C                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00003A8C
.text$mn:00003A8C var_10          = dword ptr -10h
.text$mn:00003A8C var_C           = dword ptr -0Ch
.text$mn:00003A8C var_4           = dword ptr -4
.text$mn:00003A8C
.text$mn:00003A8C                 push    ebp
.text$mn:00003A8D                 mov     ebp, esp
.text$mn:00003A8F                 push    0FFFFFFFFh
.text$mn:00003A91                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00003A96                 mov     eax, large fs:0
.text$mn:00003A9C                 push    eax
.text$mn:00003A9D                 push    ecx
.text$mn:00003A9E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003AA3                 xor     eax, ebp
.text$mn:00003AA5                 push    eax
.text$mn:00003AA6                 lea     eax, [ebp+var_C]
.text$mn:00003AA9                 mov     large fs:0, eax
.text$mn:00003AAF                 mov     [ebp+var_10], ecx
.text$mn:00003AB2                 mov     [ebp+var_4], 0
.text$mn:00003AB9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003AC0                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003AC3                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00003AC8                 mov     ecx, [ebp+var_C]
.text$mn:00003ACB                 mov     large fs:0, ecx
.text$mn:00003AD2                 pop     ecx
.text$mn:00003AD3                 mov     esp, ebp
.text$mn:00003AD5                 pop     ebp
.text$mn:00003AD6                 retn
.text$mn:00003AD6 ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00003AD6
.text$mn:00003AD6 ; ---------------------------------------------------------------------------
.text$mn:00003AD7                 align 4
.text$mn:00003AD7 _text$mn        ends
.text$mn:00003AD7
.text$x:00003AD8 ; ===========================================================================
.text$x:00003AD8
.text$x:00003AD8 ; Segment type: Pure code
.text$x:00003AD8 ; Segment permissions: Read/Execute
.text$x:00003AD8 _text$x         segment para public 'CODE' use32
.text$x:00003AD8                 assume cs:_text$x
.text$x:00003AD8                 ;org 3AD8h
.text$x:00003AD8 ; COMDAT (pick associative to section at 3A8C)
.text$x:00003AD8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003AD8
.text$x:00003AD8 ; =============== S U B R O U T I N E =======================================
.text$x:00003AD8
.text$x:00003AD8
.text$x:00003AD8 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00003AD8                                         ; DATA XREF: .xdata$x:00006590o
.text$x:00003AD8                 mov     ecx, [ebp-10h]  ; this
.text$x:00003ADB                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00003ADB __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00003ADB
.text$x:00003AE0
.text$x:00003AE0 ; =============== S U B R O U T I N E =======================================
.text$x:00003AE0
.text$x:00003AE0
.text$x:00003AE0 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00003AE0                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00003AE0
.text$x:00003AE0 arg_4           = dword ptr  8
.text$x:00003AE0
.text$x:00003AE0                 mov     edx, [esp+arg_4]
.text$x:00003AE4                 lea     eax, [edx+0Ch]
.text$x:00003AE7                 mov     ecx, [edx-8]
.text$x:00003AEA                 xor     ecx, eax
.text$x:00003AEC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003AF1                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00003AF6                 jmp     ___CxxFrameHandler3
.text$x:00003AF6 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00003AF6
.text$x:00003AF6 ; ---------------------------------------------------------------------------
.text$x:00003AFB                 align 4
.text$x:00003AFB _text$x         ends
.text$x:00003AFB
.text$mn:00003AFC ; ===========================================================================
.text$mn:00003AFC
.text$mn:00003AFC ; Segment type: Pure code
.text$mn:00003AFC ; Segment permissions: Read/Execute
.text$mn:00003AFC _text$mn        segment para public 'CODE' use32
.text$mn:00003AFC                 assume cs:_text$mn
.text$mn:00003AFC                 ;org 3AFCh
.text$mn:00003AFC ; COMDAT (pick any)
.text$mn:00003AFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003AFC
.text$mn:00003AFC ; =============== S U B R O U T I N E =======================================
.text$mn:00003AFC
.text$mn:00003AFC ; Attributes: bp-based frame
.text$mn:00003AFC
.text$mn:00003AFC ; _DWORD __thiscall std::_Iterator_base12::~_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00003AFC                 public ??1_Iterator_base12@std@@QAE@XZ
.text$mn:00003AFC ??1_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00003AFC                                         ; CODE XREF: __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0+3j
.text$mn:00003AFC                                         ; __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ$0+3j ...
.text$mn:00003AFC
.text$mn:00003AFC var_14          = byte ptr -14h
.text$mn:00003AFC var_10          = dword ptr -10h
.text$mn:00003AFC var_C           = dword ptr -0Ch
.text$mn:00003AFC var_4           = dword ptr -4
.text$mn:00003AFC
.text$mn:00003AFC                 push    ebp
.text$mn:00003AFD                 mov     ebp, esp
.text$mn:00003AFF                 push    0FFFFFFFFh
.text$mn:00003B01                 push    offset __ehhandler$??1_Iterator_base12@std@@QAE@XZ
.text$mn:00003B06                 mov     eax, large fs:0
.text$mn:00003B0C                 push    eax
.text$mn:00003B0D                 sub     esp, 8
.text$mn:00003B10                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003B15                 xor     eax, ebp
.text$mn:00003B17                 push    eax
.text$mn:00003B18                 lea     eax, [ebp+var_C]
.text$mn:00003B1B                 mov     large fs:0, eax
.text$mn:00003B21                 mov     [ebp+var_10], ecx
.text$mn:00003B24                 push    3               ; int
.text$mn:00003B26                 lea     ecx, [ebp+var_14] ; this
.text$mn:00003B29                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00003B2E                 mov     [ebp+var_4], 0
.text$mn:00003B35                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003B38                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00003B3D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003B44                 lea     ecx, [ebp+var_14] ; this
.text$mn:00003B47                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00003B4C                 mov     ecx, [ebp+var_C]
.text$mn:00003B4F                 mov     large fs:0, ecx
.text$mn:00003B56                 pop     ecx
.text$mn:00003B57                 mov     esp, ebp
.text$mn:00003B59                 pop     ebp
.text$mn:00003B5A                 retn
.text$mn:00003B5A ??1_Iterator_base12@std@@QAE@XZ endp
.text$mn:00003B5A
.text$mn:00003B5A ; ---------------------------------------------------------------------------
.text$mn:00003B5B                 align 4
.text$mn:00003B5B _text$mn        ends
.text$mn:00003B5B
.text$x:00003B5C ; ===========================================================================
.text$x:00003B5C
.text$x:00003B5C ; Segment type: Pure code
.text$x:00003B5C ; Segment permissions: Read/Execute
.text$x:00003B5C _text$x         segment para public 'CODE' use32
.text$x:00003B5C                 assume cs:_text$x
.text$x:00003B5C                 ;org 3B5Ch
.text$x:00003B5C ; COMDAT (pick associative to section at 3AFC)
.text$x:00003B5C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003B5C
.text$x:00003B5C ; =============== S U B R O U T I N E =======================================
.text$x:00003B5C
.text$x:00003B5C
.text$x:00003B5C __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 proc near
.text$x:00003B5C                                         ; DATA XREF: .xdata$x:00006180o
.text$x:00003B5C                 lea     ecx, [ebp-14h]  ; this
.text$x:00003B5F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00003B5F __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 endp
.text$x:00003B5F
.text$x:00003B64
.text$x:00003B64 ; =============== S U B R O U T I N E =======================================
.text$x:00003B64
.text$x:00003B64
.text$x:00003B64 __ehhandler$??1_Iterator_base12@std@@QAE@XZ proc near
.text$x:00003B64                                         ; DATA XREF: std::_Iterator_base12::~_Iterator_base12(void)+5o
.text$x:00003B64
.text$x:00003B64 arg_4           = dword ptr  8
.text$x:00003B64
.text$x:00003B64                 mov     edx, [esp+arg_4]
.text$x:00003B68                 lea     eax, [edx+0Ch]
.text$x:00003B6B                 mov     ecx, [edx-0Ch]
.text$x:00003B6E                 xor     ecx, eax
.text$x:00003B70                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003B75                 mov     eax, offset __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ
.text$x:00003B7A                 jmp     ___CxxFrameHandler3
.text$x:00003B7A __ehhandler$??1_Iterator_base12@std@@QAE@XZ endp
.text$x:00003B7A
.text$x:00003B7A ; ---------------------------------------------------------------------------
.text$x:00003B7F                 align 10h
.text$x:00003B7F _text$x         ends
.text$x:00003B7F
.text$mn:00003B80 ; ===========================================================================
.text$mn:00003B80
.text$mn:00003B80 ; Segment type: Pure code
.text$mn:00003B80 ; Segment permissions: Read/Execute
.text$mn:00003B80 _text$mn        segment para public 'CODE' use32
.text$mn:00003B80                 assume cs:_text$mn
.text$mn:00003B80                 ;org 3B80h
.text$mn:00003B80 ; COMDAT (pick any)
.text$mn:00003B80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003B80
.text$mn:00003B80 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B80
.text$mn:00003B80 ; Attributes: bp-based frame
.text$mn:00003B80
.text$mn:00003B80 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00003B80                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00003B80 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00003B80                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00003B80                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00003B80
.text$mn:00003B80 var_10          = dword ptr -10h
.text$mn:00003B80 var_C           = dword ptr -0Ch
.text$mn:00003B80 var_4           = dword ptr -4
.text$mn:00003B80
.text$mn:00003B80                 push    ebp
.text$mn:00003B81                 mov     ebp, esp
.text$mn:00003B83                 push    0FFFFFFFFh
.text$mn:00003B85                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00003B8A                 mov     eax, large fs:0
.text$mn:00003B90                 push    eax
.text$mn:00003B91                 push    ecx
.text$mn:00003B92                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003B97                 xor     eax, ebp
.text$mn:00003B99                 push    eax
.text$mn:00003B9A                 lea     eax, [ebp+var_C]
.text$mn:00003B9D                 mov     large fs:0, eax
.text$mn:00003BA3                 mov     [ebp+var_10], ecx
.text$mn:00003BA6                 mov     [ebp+var_4], 0
.text$mn:00003BAD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003BB4                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003BB7                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00003BBC                 mov     ecx, [ebp+var_C]
.text$mn:00003BBF                 mov     large fs:0, ecx
.text$mn:00003BC6                 pop     ecx
.text$mn:00003BC7                 mov     esp, ebp
.text$mn:00003BC9                 pop     ebp
.text$mn:00003BCA                 retn
.text$mn:00003BCA ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00003BCA
.text$mn:00003BCA ; ---------------------------------------------------------------------------
.text$mn:00003BCB                 align 4
.text$mn:00003BCB _text$mn        ends
.text$mn:00003BCB
.text$x:00003BCC ; ===========================================================================
.text$x:00003BCC
.text$x:00003BCC ; Segment type: Pure code
.text$x:00003BCC ; Segment permissions: Read/Execute
.text$x:00003BCC _text$x         segment para public 'CODE' use32
.text$x:00003BCC                 assume cs:_text$x
.text$x:00003BCC                 ;org 3BCCh
.text$x:00003BCC ; COMDAT (pick associative to section at 3B80)
.text$x:00003BCC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003BCC
.text$x:00003BCC ; =============== S U B R O U T I N E =======================================
.text$x:00003BCC
.text$x:00003BCC
.text$x:00003BCC __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00003BCC                                         ; DATA XREF: .xdata$x:00006614o
.text$x:00003BCC                 mov     ecx, [ebp-10h]  ; this
.text$x:00003BCF                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00003BCF __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00003BCF
.text$x:00003BD4
.text$x:00003BD4 ; =============== S U B R O U T I N E =======================================
.text$x:00003BD4
.text$x:00003BD4
.text$x:00003BD4 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00003BD4                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00003BD4
.text$x:00003BD4 arg_4           = dword ptr  8
.text$x:00003BD4
.text$x:00003BD4                 mov     edx, [esp+arg_4]
.text$x:00003BD8                 lea     eax, [edx+0Ch]
.text$x:00003BDB                 mov     ecx, [edx-8]
.text$x:00003BDE                 xor     ecx, eax
.text$x:00003BE0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003BE5                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00003BEA                 jmp     ___CxxFrameHandler3
.text$x:00003BEA __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00003BEA
.text$x:00003BEA ; ---------------------------------------------------------------------------
.text$x:00003BEF                 align 10h
.text$x:00003BEF _text$x         ends
.text$x:00003BEF
.text$mn:00003BF0 ; ===========================================================================
.text$mn:00003BF0
.text$mn:00003BF0 ; Segment type: Pure code
.text$mn:00003BF0 ; Segment permissions: Read/Execute
.text$mn:00003BF0 _text$mn        segment para public 'CODE' use32
.text$mn:00003BF0                 assume cs:_text$mn
.text$mn:00003BF0                 ;org 3BF0h
.text$mn:00003BF0 ; COMDAT (pick any)
.text$mn:00003BF0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003BF0
.text$mn:00003BF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003BF0
.text$mn:00003BF0 ; Attributes: bp-based frame
.text$mn:00003BF0
.text$mn:00003BF0 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00003BF0                 public ??1error_category@std@@UAE@XZ
.text$mn:00003BF0 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00003BF0                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00003BF0
.text$mn:00003BF0 var_4           = dword ptr -4
.text$mn:00003BF0
.text$mn:00003BF0                 push    ebp
.text$mn:00003BF1                 mov     ebp, esp
.text$mn:00003BF3                 push    ecx
.text$mn:00003BF4                 mov     [ebp+var_4], ecx
.text$mn:00003BF7                 mov     eax, [ebp+var_4]
.text$mn:00003BFA                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00003C00                 mov     esp, ebp
.text$mn:00003C02                 pop     ebp
.text$mn:00003C03                 retn
.text$mn:00003C03 ??1error_category@std@@UAE@XZ endp
.text$mn:00003C03
.text$mn:00003C03 _text$mn        ends
.text$mn:00003C03
.text$mn:00003C04 ; ===========================================================================
.text$mn:00003C04
.text$mn:00003C04 ; Segment type: Pure code
.text$mn:00003C04 ; Segment permissions: Read/Execute
.text$mn:00003C04 _text$mn        segment para public 'CODE' use32
.text$mn:00003C04                 assume cs:_text$mn
.text$mn:00003C04                 ;org 3C04h
.text$mn:00003C04 ; COMDAT (pick any)
.text$mn:00003C04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003C04
.text$mn:00003C04 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C04
.text$mn:00003C04 ; Attributes: bp-based frame
.text$mn:00003C04
.text$mn:00003C04 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00003C04                 public ??2@YAPAXIPAX@Z
.text$mn:00003C04 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00003C04                                         ; std::allocator<std::pair<int,int>>::construct<std::pair<int,int>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> &&)+2Ep ...
.text$mn:00003C04
.text$mn:00003C04 arg_4           = dword ptr  0Ch
.text$mn:00003C04
.text$mn:00003C04                 push    ebp
.text$mn:00003C05                 mov     ebp, esp
.text$mn:00003C07                 mov     eax, [ebp+arg_4]
.text$mn:00003C0A                 pop     ebp
.text$mn:00003C0B                 retn
.text$mn:00003C0B ??2@YAPAXIPAX@Z endp
.text$mn:00003C0B
.text$mn:00003C0B _text$mn        ends
.text$mn:00003C0B
.text$mn:00003C0C ; ===========================================================================
.text$mn:00003C0C
.text$mn:00003C0C ; Segment type: Pure code
.text$mn:00003C0C ; Segment permissions: Read/Execute
.text$mn:00003C0C _text$mn        segment para public 'CODE' use32
.text$mn:00003C0C                 assume cs:_text$mn
.text$mn:00003C0C                 ;org 3C0Ch
.text$mn:00003C0C ; COMDAT (pick any)
.text$mn:00003C0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003C0C
.text$mn:00003C0C ; =============== S U B R O U T I N E =======================================
.text$mn:00003C0C
.text$mn:00003C0C ; Attributes: bp-based frame
.text$mn:00003C0C
.text$mn:00003C0C ; void __cdecl operator delete(void *)
.text$mn:00003C0C                 public ??3@YAXPAX0@Z
.text$mn:00003C0C ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00003C0C                                         ; __unwindfunclet$??$construct@U?$pair@HH@std@@U12@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@$$QAU21@@Z$0+8p ...
.text$mn:00003C0C                 push    ebp
.text$mn:00003C0D                 mov     ebp, esp
.text$mn:00003C0F                 pop     ebp
.text$mn:00003C10                 retn
.text$mn:00003C10 ??3@YAXPAX0@Z   endp
.text$mn:00003C10
.text$mn:00003C10 ; ---------------------------------------------------------------------------
.text$mn:00003C11                 align 4
.text$mn:00003C11 _text$mn        ends
.text$mn:00003C11
.text$mn:00003C14 ; ===========================================================================
.text$mn:00003C14
.text$mn:00003C14 ; Segment type: Pure code
.text$mn:00003C14 ; Segment permissions: Read/Execute
.text$mn:00003C14 _text$mn        segment para public 'CODE' use32
.text$mn:00003C14                 assume cs:_text$mn
.text$mn:00003C14                 ;org 3C14h
.text$mn:00003C14 ; COMDAT (pick any)
.text$mn:00003C14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003C14
.text$mn:00003C14 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C14
.text$mn:00003C14 ; Attributes: bp-based frame
.text$mn:00003C14
.text$mn:00003C14 ; public: struct std::_Iterator_base12 & __thiscall std::_Iterator_base12::operator=(struct std::_Iterator_base12 const &)
.text$mn:00003C14                 public ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:00003C14 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$mn:00003C14                                         ; CODE XREF: std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)+21p
.text$mn:00003C14
.text$mn:00003C14 var_14          = byte ptr -14h
.text$mn:00003C14 var_10          = dword ptr -10h
.text$mn:00003C14 var_C           = dword ptr -0Ch
.text$mn:00003C14 var_4           = dword ptr -4
.text$mn:00003C14 arg_0           = dword ptr  8
.text$mn:00003C14
.text$mn:00003C14                 push    ebp
.text$mn:00003C15                 mov     ebp, esp
.text$mn:00003C17                 push    0FFFFFFFFh
.text$mn:00003C19                 push    offset __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:00003C1E                 mov     eax, large fs:0
.text$mn:00003C24                 push    eax
.text$mn:00003C25                 sub     esp, 8
.text$mn:00003C28                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003C2D                 xor     eax, ebp
.text$mn:00003C2F                 push    eax
.text$mn:00003C30                 lea     eax, [ebp+var_C]
.text$mn:00003C33                 mov     large fs:0, eax
.text$mn:00003C39                 mov     [ebp+var_10], ecx
.text$mn:00003C3C                 mov     eax, [ebp+var_10]
.text$mn:00003C3F                 mov     ecx, [ebp+arg_0]
.text$mn:00003C42                 mov     edx, [eax]
.text$mn:00003C44                 cmp     edx, [ecx]
.text$mn:00003C46                 jnz     short loc_3C4A
.text$mn:00003C48                 jmp     short loc_3C8C
.text$mn:00003C4A ; ---------------------------------------------------------------------------
.text$mn:00003C4A
.text$mn:00003C4A loc_3C4A:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+32j
.text$mn:00003C4A                 mov     eax, [ebp+arg_0]
.text$mn:00003C4D                 cmp     dword ptr [eax], 0
.text$mn:00003C50                 jz      short loc_3C64
.text$mn:00003C52                 mov     ecx, [ebp+arg_0]
.text$mn:00003C55                 mov     edx, [ecx]
.text$mn:00003C57                 mov     eax, [edx]
.text$mn:00003C59                 push    eax             ; struct std::_Container_base12 *
.text$mn:00003C5A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003C5D                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:00003C62                 jmp     short loc_3C8C
.text$mn:00003C64 ; ---------------------------------------------------------------------------
.text$mn:00003C64
.text$mn:00003C64 loc_3C64:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+3Cj
.text$mn:00003C64                 push    3               ; int
.text$mn:00003C66                 lea     ecx, [ebp+var_14] ; this
.text$mn:00003C69                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00003C6E                 mov     [ebp+var_4], 0
.text$mn:00003C75                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003C78                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00003C7D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003C84                 lea     ecx, [ebp+var_14] ; this
.text$mn:00003C87                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00003C8C
.text$mn:00003C8C loc_3C8C:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+34j
.text$mn:00003C8C                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+4Ej
.text$mn:00003C8C                 mov     eax, [ebp+var_10]
.text$mn:00003C8F                 mov     ecx, [ebp+var_C]
.text$mn:00003C92                 mov     large fs:0, ecx
.text$mn:00003C99                 pop     ecx
.text$mn:00003C9A                 mov     esp, ebp
.text$mn:00003C9C                 pop     ebp
.text$mn:00003C9D                 retn    4
.text$mn:00003C9D ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$mn:00003C9D
.text$mn:00003C9D _text$mn        ends
.text$mn:00003C9D
.text$x:00003CA0 ; ===========================================================================
.text$x:00003CA0
.text$x:00003CA0 ; Segment type: Pure code
.text$x:00003CA0 ; Segment permissions: Read/Execute
.text$x:00003CA0 _text$x         segment para public 'CODE' use32
.text$x:00003CA0                 assume cs:_text$x
.text$x:00003CA0                 ;org 3CA0h
.text$x:00003CA0 ; COMDAT (pick associative to section at 3C14)
.text$x:00003CA0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003CA0
.text$x:00003CA0 ; =============== S U B R O U T I N E =======================================
.text$x:00003CA0
.text$x:00003CA0
.text$x:00003CA0 __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 proc near
.text$x:00003CA0                                         ; DATA XREF: .xdata$x:00006154o
.text$x:00003CA0                 lea     ecx, [ebp-14h]  ; this
.text$x:00003CA3                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00003CA3 __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 endp
.text$x:00003CA3
.text$x:00003CA8
.text$x:00003CA8 ; =============== S U B R O U T I N E =======================================
.text$x:00003CA8
.text$x:00003CA8
.text$x:00003CA8 __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$x:00003CA8                                         ; DATA XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+5o
.text$x:00003CA8
.text$x:00003CA8 arg_4           = dword ptr  8
.text$x:00003CA8
.text$x:00003CA8                 mov     edx, [esp+arg_4]
.text$x:00003CAC                 lea     eax, [edx+0Ch]
.text$x:00003CAF                 mov     ecx, [edx-0Ch]
.text$x:00003CB2                 xor     ecx, eax
.text$x:00003CB4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003CB9                 mov     eax, offset __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$x:00003CBE                 jmp     ___CxxFrameHandler3
.text$x:00003CBE __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$x:00003CBE
.text$x:00003CBE ; ---------------------------------------------------------------------------
.text$x:00003CC3                 align 4
.text$x:00003CC3 _text$x         ends
.text$x:00003CC3
.text$mn:00003CC4 ; ===========================================================================
.text$mn:00003CC4
.text$mn:00003CC4 ; Segment type: Pure code
.text$mn:00003CC4 ; Segment permissions: Read/Execute
.text$mn:00003CC4 _text$mn        segment para public 'CODE' use32
.text$mn:00003CC4                 assume cs:_text$mn
.text$mn:00003CC4                 ;org 3CC4h
.text$mn:00003CC4 ; COMDAT (pick any)
.text$mn:00003CC4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003CC4
.text$mn:00003CC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CC4
.text$mn:00003CC4 ; Attributes: bp-based frame
.text$mn:00003CC4
.text$mn:00003CC4 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00003CC4                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00003CC4 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00003CC4                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00003CC4                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00003CC4
.text$mn:00003CC4 var_8           = dword ptr -8
.text$mn:00003CC4 var_4           = dword ptr -4
.text$mn:00003CC4 arg_0           = dword ptr  8
.text$mn:00003CC4
.text$mn:00003CC4                 push    ebp
.text$mn:00003CC5                 mov     ebp, esp
.text$mn:00003CC7                 sub     esp, 8
.text$mn:00003CCA                 mov     [ebp+var_8], ecx
.text$mn:00003CCD                 mov     eax, [ebp+var_8]
.text$mn:00003CD0                 cmp     eax, [ebp+arg_0]
.text$mn:00003CD3                 jnz     short loc_3CDE
.text$mn:00003CD5                 mov     [ebp+var_4], 1
.text$mn:00003CDC                 jmp     short loc_3CE5
.text$mn:00003CDE ; ---------------------------------------------------------------------------
.text$mn:00003CDE
.text$mn:00003CDE loc_3CDE:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00003CDE                 mov     [ebp+var_4], 0
.text$mn:00003CE5
.text$mn:00003CE5 loc_3CE5:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00003CE5                 mov     al, byte ptr [ebp+var_4]
.text$mn:00003CE8                 mov     esp, ebp
.text$mn:00003CEA                 pop     ebp
.text$mn:00003CEB                 retn    4
.text$mn:00003CEB ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00003CEB
.text$mn:00003CEB ; ---------------------------------------------------------------------------
.text$mn:00003CEE                 align 10h
.text$mn:00003CEE _text$mn        ends
.text$mn:00003CEE
.text$mn:00003CF0 ; ===========================================================================
.text$mn:00003CF0
.text$mn:00003CF0 ; Segment type: Pure code
.text$mn:00003CF0 ; Segment permissions: Read/Execute
.text$mn:00003CF0 _text$mn        segment para public 'CODE' use32
.text$mn:00003CF0                 assume cs:_text$mn
.text$mn:00003CF0                 ;org 3CF0h
.text$mn:00003CF0 ; COMDAT (pick any)
.text$mn:00003CF0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003CF0
.text$mn:00003CF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CF0
.text$mn:00003CF0 ; Attributes: bp-based frame
.text$mn:00003CF0
.text$mn:00003CF0 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00003CF0                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00003CF0 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00003CF0                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00003CF0
.text$mn:00003CF0 var_8           = dword ptr -8
.text$mn:00003CF0 var_4           = dword ptr -4
.text$mn:00003CF0 arg_0           = dword ptr  8
.text$mn:00003CF0
.text$mn:00003CF0                 push    ebp
.text$mn:00003CF1                 mov     ebp, esp
.text$mn:00003CF3                 sub     esp, 8
.text$mn:00003CF6                 push    esi
.text$mn:00003CF7                 mov     [ebp+var_4], ecx
.text$mn:00003CFA                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003CFD                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00003D02                 push    eax
.text$mn:00003D03                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003D06                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00003D0B                 mov     ecx, eax
.text$mn:00003D0D                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00003D12                 movzx   eax, al
.text$mn:00003D15                 test    eax, eax
.text$mn:00003D17                 jz      short loc_3D38
.text$mn:00003D19                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003D1C                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00003D21                 mov     esi, eax
.text$mn:00003D23                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003D26                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00003D2B                 cmp     esi, eax
.text$mn:00003D2D                 jnz     short loc_3D38
.text$mn:00003D2F                 mov     [ebp+var_8], 1
.text$mn:00003D36                 jmp     short loc_3D3F
.text$mn:00003D38 ; ---------------------------------------------------------------------------
.text$mn:00003D38
.text$mn:00003D38 loc_3D38:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00003D38                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00003D38                 mov     [ebp+var_8], 0
.text$mn:00003D3F
.text$mn:00003D3F loc_3D3F:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00003D3F                 mov     al, byte ptr [ebp+var_8]
.text$mn:00003D42                 pop     esi
.text$mn:00003D43                 mov     esp, ebp
.text$mn:00003D45                 pop     ebp
.text$mn:00003D46                 retn    4
.text$mn:00003D46 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00003D46
.text$mn:00003D46 ; ---------------------------------------------------------------------------
.text$mn:00003D49                 align 4
.text$mn:00003D49 _text$mn        ends
.text$mn:00003D49
.text$mn:00003D4C ; ===========================================================================
.text$mn:00003D4C
.text$mn:00003D4C ; Segment type: Pure code
.text$mn:00003D4C ; Segment permissions: Read/Execute
.text$mn:00003D4C _text$mn        segment para public 'CODE' use32
.text$mn:00003D4C                 assume cs:_text$mn
.text$mn:00003D4C                 ;org 3D4Ch
.text$mn:00003D4C ; COMDAT (pick any)
.text$mn:00003D4C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003D4C
.text$mn:00003D4C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D4C
.text$mn:00003D4C ; Attributes: bp-based frame
.text$mn:00003D4C
.text$mn:00003D4C ; public: struct std::pair<int, int> & __thiscall std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>::operator[](unsigned int)
.text$mn:00003D4C                 public ??A?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEAAU?$pair@HH@1@I@Z
.text$mn:00003D4C ??A?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEAAU?$pair@HH@1@I@Z proc near
.text$mn:00003D4C                                         ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+332p
.text$mn:00003D4C                                         ; XmlMatchedTagsHighlighter::tagMatch(bool)+343p ...
.text$mn:00003D4C
.text$mn:00003D4C var_4           = dword ptr -4
.text$mn:00003D4C arg_0           = dword ptr  8
.text$mn:00003D4C
.text$mn:00003D4C                 push    ebp
.text$mn:00003D4D                 mov     ebp, esp
.text$mn:00003D4F                 push    ecx
.text$mn:00003D50                 mov     [ebp+var_4], ecx
.text$mn:00003D53                 mov     ecx, [ebp+var_4]
.text$mn:00003D56                 call    ?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::size(void)
.text$mn:00003D5B                 cmp     eax, [ebp+arg_0]
.text$mn:00003D5E                 ja      short loc_3DC8
.text$mn:00003D60                 push    4B1h            ; unsigned int
.text$mn:00003D65                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003D6A                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:00003D6F                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003D74                 add     esp, 0Ch
.text$mn:00003D77                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00003D7C                 test    eax, eax
.text$mn:00003D7E                 jz      short loc_3D84
.text$mn:00003D80                 xor     ecx, ecx
.text$mn:00003D82                 jnz     short loc_3DAA
.text$mn:00003D84
.text$mn:00003D84 loc_3D84:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::operator[](uint)+32j
.text$mn:00003D84                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00003D89                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00003D8E                 push    0
.text$mn:00003D90                 push    4B2h
.text$mn:00003D95                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003D9A                 push    2
.text$mn:00003D9C                 call    __CrtDbgReportW
.text$mn:00003DA1                 add     esp, 18h
.text$mn:00003DA4                 cmp     eax, 1
.text$mn:00003DA7                 jnz     short loc_3DAA
.text$mn:00003DA9                 int     3               ; Trap to Debugger
.text$mn:00003DAA
.text$mn:00003DAA loc_3DAA:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::operator[](uint)+36j
.text$mn:00003DAA                                         ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::operator[](uint)+5Bj
.text$mn:00003DAA                 push    0
.text$mn:00003DAC                 push    4B2h
.text$mn:00003DB1                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003DB6                 push    offset ??_C@_1MM@CFLCIPDM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAp?$AAa?$AAi?$AAr?$AA?$DM?$AAi?$AAn?$AAt@ ; "std::vector<struct std::pair<int,int>,c"...
.text$mn:00003DBB                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00003DC0                 call    __invalid_parameter
.text$mn:00003DC5                 add     esp, 14h
.text$mn:00003DC8
.text$mn:00003DC8 loc_3DC8:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::operator[](uint)+12j
.text$mn:00003DC8                 mov     eax, [ebp+var_4]
.text$mn:00003DCB                 mov     ecx, [eax+4]
.text$mn:00003DCE                 mov     edx, [ebp+arg_0]
.text$mn:00003DD1                 lea     eax, [ecx+edx*8]
.text$mn:00003DD4                 mov     esp, ebp
.text$mn:00003DD6                 pop     ebp
.text$mn:00003DD7                 retn    4
.text$mn:00003DD7 ??A?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEAAU?$pair@HH@1@I@Z endp
.text$mn:00003DD7
.text$mn:00003DD7 ; ---------------------------------------------------------------------------
.text$mn:00003DDA                 align 4
.text$mn:00003DDA _text$mn        ends
.text$mn:00003DDA
.text$mn:00003DDC ; ===========================================================================
.text$mn:00003DDC
.text$mn:00003DDC ; Segment type: Pure code
.text$mn:00003DDC ; Segment permissions: Read/Execute
.text$mn:00003DDC _text$mn        segment para public 'CODE' use32
.text$mn:00003DDC                 assume cs:_text$mn
.text$mn:00003DDC                 ;org 3DDCh
.text$mn:00003DDC ; COMDAT (pick any)
.text$mn:00003DDC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003DDC
.text$mn:00003DDC ; =============== S U B R O U T I N E =======================================
.text$mn:00003DDC
.text$mn:00003DDC ; Attributes: bp-based frame
.text$mn:00003DDC
.text$mn:00003DDC ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator-(std::_Iterator_base12 *)
.text$mn:00003DDC                 public ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z
.text$mn:00003DDC ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z proc near
.text$mn:00003DDC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>)+42p
.text$mn:00003DDC
.text$mn:00003DDC var_4           = dword ptr -4
.text$mn:00003DDC arg_0           = dword ptr  8
.text$mn:00003DDC
.text$mn:00003DDC                 push    ebp
.text$mn:00003DDD                 mov     ebp, esp
.text$mn:00003DDF                 push    ecx
.text$mn:00003DE0                 mov     [ebp+var_4], ecx
.text$mn:00003DE3                 mov     eax, [ebp+arg_0]
.text$mn:00003DE6                 push    eax             ; std::_Iterator_base12 *
.text$mn:00003DE7                 mov     ecx, [ebp+var_4]
.text$mn:00003DEA                 call    ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>> const &)
.text$mn:00003DEF                 mov     ecx, [ebp+var_4]
.text$mn:00003DF2                 mov     edx, [ebp+arg_0]
.text$mn:00003DF5                 mov     eax, [ecx+8]
.text$mn:00003DF8                 sub     eax, [edx+8]
.text$mn:00003DFB                 mov     esp, ebp
.text$mn:00003DFD                 pop     ebp
.text$mn:00003DFE                 retn    4
.text$mn:00003DFE ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z endp
.text$mn:00003DFE
.text$mn:00003DFE ; ---------------------------------------------------------------------------
.text$mn:00003E01                 align 4
.text$mn:00003E01 _text$mn        ends
.text$mn:00003E01
.text$mn:00003E04 ; ===========================================================================
.text$mn:00003E04
.text$mn:00003E04 ; Segment type: Pure code
.text$mn:00003E04 ; Segment permissions: Read/Execute
.text$mn:00003E04 _text$mn        segment para public 'CODE' use32
.text$mn:00003E04                 assume cs:_text$mn
.text$mn:00003E04                 ;org 3E04h
.text$mn:00003E04 ; COMDAT (pick any)
.text$mn:00003E04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003E04
.text$mn:00003E04 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E04
.text$mn:00003E04 ; Attributes: bp-based frame
.text$mn:00003E04
.text$mn:00003E04 ; public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<char>>> __thiscall std::_String_iterator<class std::_String_val<struct std::_Simple_types<char>>>::operator+(int)const
.text$mn:00003E04                 public ??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:00003E04 ??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$mn:00003E04                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::insert(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>,char)+E3p
.text$mn:00003E04
.text$mn:00003E04 var_20          = byte ptr -20h
.text$mn:00003E04 var_14          = dword ptr -14h
.text$mn:00003E04 var_10          = dword ptr -10h
.text$mn:00003E04 var_C           = dword ptr -0Ch
.text$mn:00003E04 var_4           = dword ptr -4
.text$mn:00003E04 arg_0           = dword ptr  8
.text$mn:00003E04 arg_4           = dword ptr  0Ch
.text$mn:00003E04
.text$mn:00003E04                 push    ebp
.text$mn:00003E05                 mov     ebp, esp
.text$mn:00003E07                 push    0FFFFFFFFh
.text$mn:00003E09                 push    offset __ehhandler$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:00003E0E                 mov     eax, large fs:0
.text$mn:00003E14                 push    eax
.text$mn:00003E15                 sub     esp, 14h
.text$mn:00003E18                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003E1D                 xor     eax, ebp
.text$mn:00003E1F                 push    eax
.text$mn:00003E20                 lea     eax, [ebp+var_C]
.text$mn:00003E23
.text$mn:00003E23 loc_3E23:                               ; DATA XREF: .rdata:$SG152770o
.text$mn:00003E23                 mov     large fs:0, eax
.text$mn:00003E29                 mov     [ebp+var_14], ecx
.text$mn:00003E2C                 mov     [ebp+var_10], 0
.text$mn:00003E33                 mov     eax, [ebp+var_14]
.text$mn:00003E36                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00003E37                 lea     ecx, [ebp+var_20]
.text$mn:00003E3A                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::_String_iterator<std::_String_val<std::_Simple_types<char>>>(std::_String_iterator<std::_String_val<std::_Simple_types<char>>> const &)
.text$mn:00003E3F
.text$mn:00003E3F loc_3E3F:                               ; DATA XREF: .rdata:$SG152769o
.text$mn:00003E3F                 mov     [ebp+var_4], 1
.text$mn:00003E46                 mov     ecx, [ebp+arg_4]
.text$mn:00003E49                 push    ecx
.text$mn:00003E4A                 lea     ecx, [ebp+var_20]
.text$mn:00003E4D                 call    ??Y?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAEAAV01@H@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int)
.text$mn:00003E52                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00003E53                 mov     ecx, [ebp+arg_0]
.text$mn:00003E56                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::_String_iterator<std::_String_val<std::_Simple_types<char>>>(std::_String_iterator<std::_String_val<std::_Simple_types<char>>> const &)
.text$mn:00003E5B                 mov     edx, [ebp+var_10]
.text$mn:00003E5E                 or      edx, 1
.text$mn:00003E61                 mov     [ebp+var_10], edx
.text$mn:00003E64                 mov     byte ptr [ebp+var_4], 0
.text$mn:00003E68                 lea     ecx, [ebp+var_20]
.text$mn:00003E6B                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$mn:00003E70                 mov     eax, [ebp+arg_0]
.text$mn:00003E73                 mov     ecx, [ebp+var_C]
.text$mn:00003E76                 mov     large fs:0, ecx
.text$mn:00003E7D                 pop     ecx
.text$mn:00003E7E                 mov     esp, ebp
.text$mn:00003E80                 pop     ebp
.text$mn:00003E81                 retn    8
.text$mn:00003E81 ??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$mn:00003E81
.text$mn:00003E81 _text$mn        ends
.text$mn:00003E81
.text$x:00003E84 ; ===========================================================================
.text$x:00003E84
.text$x:00003E84 ; Segment type: Pure code
.text$x:00003E84 ; Segment permissions: Read/Execute
.text$x:00003E84 _text$x         segment para public 'CODE' use32
.text$x:00003E84                 assume cs:_text$x
.text$x:00003E84                 ;org 3E84h
.text$x:00003E84 ; COMDAT (pick associative to section at 3E04)
.text$x:00003E84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00003E84
.text$x:00003E84 ; =============== S U B R O U T I N E =======================================
.text$x:00003E84
.text$x:00003E84
.text$x:00003E84 __unwindfunclet$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE?AV01@H@Z$0 proc near
.text$x:00003E84                                         ; DATA XREF: .xdata$x:00006A30o
.text$x:00003E84                 lea     ecx, [ebp-20h]
.text$x:00003E87                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$x:00003E87 __unwindfunclet$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE?AV01@H@Z$0 endp
.text$x:00003E87
.text$x:00003E8C
.text$x:00003E8C ; =============== S U B R O U T I N E =======================================
.text$x:00003E8C
.text$x:00003E8C
.text$x:00003E8C __unwindfunclet$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE?AV01@H@Z$1 proc near
.text$x:00003E8C                                         ; DATA XREF: .xdata$x:00006A28o
.text$x:00003E8C                 mov     eax, [ebp-10h]
.text$x:00003E8F                 and     eax, 1
.text$x:00003E92                 jz      $LN5
.text$x:00003E98                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00003E9C                 mov     ecx, [ebp+8]
.text$x:00003E9F                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$x:00003EA4 ; ---------------------------------------------------------------------------
.text$x:00003EA4
.text$x:00003EA4 $LN5:                                   ; CODE XREF: __unwindfunclet$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE?AV01@H@Z$1+6j
.text$x:00003EA4                 retn
.text$x:00003EA4 __unwindfunclet$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE?AV01@H@Z$1 endp
.text$x:00003EA4
.text$x:00003EA5
.text$x:00003EA5 ; =============== S U B R O U T I N E =======================================
.text$x:00003EA5
.text$x:00003EA5
.text$x:00003EA5 __ehhandler$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$x:00003EA5                                         ; DATA XREF: std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::operator+(int)+5o
.text$x:00003EA5
.text$x:00003EA5 arg_4           = dword ptr  8
.text$x:00003EA5
.text$x:00003EA5                 mov     edx, [esp+arg_4]
.text$x:00003EA9                 lea     eax, [edx+0Ch]
.text$x:00003EAC                 mov     ecx, [edx-18h]
.text$x:00003EAF                 xor     ecx, eax
.text$x:00003EB1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003EB6                 mov     eax, offset __ehfuncinfo$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE?AV01@H@Z
.text$x:00003EBB                 jmp     ___CxxFrameHandler3
.text$x:00003EBB __ehhandler$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$x:00003EBB
.text$x:00003EBB _text$x         ends
.text$x:00003EBB
.text$mn:00003EC0 ; ===========================================================================
.text$mn:00003EC0
.text$mn:00003EC0 ; Segment type: Pure code
.text$mn:00003EC0 ; Segment permissions: Read/Execute
.text$mn:00003EC0 _text$mn        segment para public 'CODE' use32
.text$mn:00003EC0                 assume cs:_text$mn
.text$mn:00003EC0                 ;org 3EC0h
.text$mn:00003EC0 ; COMDAT (pick any)
.text$mn:00003EC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003EC0
.text$mn:00003EC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003EC0
.text$mn:00003EC0 ; Attributes: bp-based frame
.text$mn:00003EC0
.text$mn:00003EC0 ; public: class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<char>>> & __thiscall std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<char>>>::operator+=(int)
.text$mn:00003EC0                 public ??Y?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:00003EC0 ??Y?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:00003EC0                                         ; CODE XREF: std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int)+Ep
.text$mn:00003EC0
.text$mn:00003EC0 var_4           = dword ptr -4
.text$mn:00003EC0 arg_0           = dword ptr  8
.text$mn:00003EC0
.text$mn:00003EC0                 push    ebp
.text$mn:00003EC1                 mov     ebp, esp
.text$mn:00003EC3                 push    ecx
.text$mn:00003EC4                 push    esi
.text$mn:00003EC5                 mov     [ebp+var_4], ecx
.text$mn:00003EC8                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003ECB                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00003ED0                 test    eax, eax
.text$mn:00003ED2                 jz      short loc_3F22
.text$mn:00003ED4                 mov     eax, [ebp+var_4]
.text$mn:00003ED7                 cmp     dword ptr [eax+8], 0
.text$mn:00003EDB                 jz      short loc_3F22
.text$mn:00003EDD                 mov     ecx, [ebp+var_4]
.text$mn:00003EE0                 mov     esi, [ecx+8]
.text$mn:00003EE3                 add     esi, [ebp+arg_0]
.text$mn:00003EE6                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003EE9                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00003EEE                 mov     ecx, eax
.text$mn:00003EF0                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00003EF5                 cmp     esi, eax
.text$mn:00003EF7                 jb      short loc_3F22
.text$mn:00003EF9                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003EFC                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00003F01                 mov     ecx, eax
.text$mn:00003F03                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00003F08                 mov     esi, eax
.text$mn:00003F0A                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003F0D                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00003F12                 add     esi, [eax+14h]
.text$mn:00003F15                 mov     edx, [ebp+var_4]
.text$mn:00003F18                 mov     eax, [edx+8]
.text$mn:00003F1B                 add     eax, [ebp+arg_0]
.text$mn:00003F1E                 cmp     esi, eax
.text$mn:00003F20                 jnb     short loc_3F8A
.text$mn:00003F22
.text$mn:00003F22 loc_3F22:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int)+12j
.text$mn:00003F22                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int)+1Bj ...
.text$mn:00003F22                 push    0A8h ; '¿'      ; unsigned int
.text$mn:00003F27                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003F2C                 push    offset ??_C@_1EM@MEFKBKGF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@ ; "string iterator + offset out of range"
.text$mn:00003F31                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003F36                 add     esp, 0Ch
.text$mn:00003F39
.text$mn:00003F39 loc_3F39:                               ; DATA XREF: .rdata:$SG152750o
.text$mn:00003F39                 mov     ecx, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00003F3E                 test    ecx, ecx
.text$mn:00003F40                 jz      short loc_3F46
.text$mn:00003F42                 xor     edx, edx
.text$mn:00003F44                 jnz     short loc_3F6C
.text$mn:00003F46
.text$mn:00003F46 loc_3F46:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int)+80j
.text$mn:00003F46                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00003F4B                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00003F50                 push    0
.text$mn:00003F52                 push    0A9h ; '¬'
.text$mn:00003F57                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003F5C                 push    2
.text$mn:00003F5E                 call    __CrtDbgReportW
.text$mn:00003F63                 add     esp, 18h
.text$mn:00003F66                 cmp     eax, 1
.text$mn:00003F69                 jnz     short loc_3F6C
.text$mn:00003F6B                 int     3               ; Trap to Debugger
.text$mn:00003F6C
.text$mn:00003F6C loc_3F6C:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int)+84j
.text$mn:00003F6C                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int)+A9j
.text$mn:00003F6C                 push    0
.text$mn:00003F6E                 push    0A9h ; '¬'
.text$mn:00003F73                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003F78                 push    offset ??_C@_1MI@HNCOPGEL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_String_const_iterator<class std::"...
.text$mn:00003F7D                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00003F82                 call    __invalid_parameter
.text$mn:00003F87                 add     esp, 14h
.text$mn:00003F8A
.text$mn:00003F8A loc_3F8A:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int)+60j
.text$mn:00003F8A                 mov     ecx, [ebp+var_4]
.text$mn:00003F8D                 mov     edx, [ecx+8]
.text$mn:00003F90                 add     edx, [ebp+arg_0]
.text$mn:00003F93                 mov     eax, [ebp+var_4]
.text$mn:00003F96                 mov     [eax+8], edx
.text$mn:00003F99                 mov     eax, [ebp+var_4]
.text$mn:00003F9C                 pop     esi
.text$mn:00003F9D                 mov     esp, ebp
.text$mn:00003F9F                 pop     ebp
.text$mn:00003FA0                 retn    4
.text$mn:00003FA0 ??Y?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:00003FA0
.text$mn:00003FA0 ; ---------------------------------------------------------------------------
.text$mn:00003FA3                 align 4
.text$mn:00003FA3 _text$mn        ends
.text$mn:00003FA3
.text$mn:00003FA4 ; ===========================================================================
.text$mn:00003FA4
.text$mn:00003FA4 ; Segment type: Pure code
.text$mn:00003FA4 ; Segment permissions: Read/Execute
.text$mn:00003FA4 _text$mn        segment para public 'CODE' use32
.text$mn:00003FA4                 assume cs:_text$mn
.text$mn:00003FA4                 ;org 3FA4h
.text$mn:00003FA4 ; COMDAT (pick any)
.text$mn:00003FA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003FA4
.text$mn:00003FA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003FA4
.text$mn:00003FA4 ; Attributes: bp-based frame
.text$mn:00003FA4
.text$mn:00003FA4 ; public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<char>>> & __thiscall std::_String_iterator<class std::_String_val<struct std::_Simple_types<char>>>::operator+=(int)
.text$mn:00003FA4                 public ??Y?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:00003FA4 ??Y?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:00003FA4                                         ; CODE XREF: std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::operator+(int)+49p
.text$mn:00003FA4
.text$mn:00003FA4 var_4           = dword ptr -4
.text$mn:00003FA4 arg_0           = dword ptr  8
.text$mn:00003FA4
.text$mn:00003FA4                 push    ebp
.text$mn:00003FA5                 mov     ebp, esp
.text$mn:00003FA7                 push    ecx
.text$mn:00003FA8                 mov     [ebp+var_4], ecx
.text$mn:00003FAB                 mov     eax, [ebp+arg_0]
.text$mn:00003FAE                 push    eax
.text$mn:00003FAF                 mov     ecx, [ebp+var_4]
.text$mn:00003FB2                 call    ??Y?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAEAAV01@H@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int)
.text$mn:00003FB7                 mov     eax, [ebp+var_4]
.text$mn:00003FBA                 mov     esp, ebp
.text$mn:00003FBC                 pop     ebp
.text$mn:00003FBD                 retn    4
.text$mn:00003FBD ??Y?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:00003FBD
.text$mn:00003FBD _text$mn        ends
.text$mn:00003FBD
.text$mn:00003FC0 ; ===========================================================================
.text$mn:00003FC0
.text$mn:00003FC0 ; Segment type: Pure code
.text$mn:00003FC0 ; Segment permissions: Read/Execute
.text$mn:00003FC0 _text$mn        segment para public 'CODE' use32
.text$mn:00003FC0                 assume cs:_text$mn
.text$mn:00003FC0                 ;org 3FC0h
.text$mn:00003FC0 ; COMDAT (pick any)
.text$mn:00003FC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003FC0
.text$mn:00003FC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003FC0
.text$mn:00003FC0 ; Attributes: bp-based frame
.text$mn:00003FC0
.text$mn:00003FC0 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00003FC0                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00003FC0 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00003FC0
.text$mn:00003FC0 var_4           = dword ptr -4
.text$mn:00003FC0 arg_0           = dword ptr  8
.text$mn:00003FC0
.text$mn:00003FC0                 push    ebp
.text$mn:00003FC1                 mov     ebp, esp
.text$mn:00003FC3                 push    ecx
.text$mn:00003FC4                 mov     [ebp+var_4], ecx
.text$mn:00003FC7                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003FCA                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00003FCF                 mov     eax, [ebp+arg_0]
.text$mn:00003FD2                 and     eax, 1
.text$mn:00003FD5                 jz      short loc_3FE3
.text$mn:00003FD7                 mov     ecx, [ebp+var_4]
.text$mn:00003FDA                 push    ecx             ; void *
.text$mn:00003FDB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00003FE0                 add     esp, 4
.text$mn:00003FE3
.text$mn:00003FE3 loc_3FE3:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00003FE3                 mov     eax, [ebp+var_4]
.text$mn:00003FE6                 mov     esp, ebp
.text$mn:00003FE8                 pop     ebp
.text$mn:00003FE9                 retn    4
.text$mn:00003FE9 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00003FE9
.text$mn:00003FE9 _text$mn        ends
.text$mn:00003FE9
.text$mn:00003FEC ; ===========================================================================
.text$mn:00003FEC
.text$mn:00003FEC ; Segment type: Pure code
.text$mn:00003FEC ; Segment permissions: Read/Execute
.text$mn:00003FEC _text$mn        segment para public 'CODE' use32
.text$mn:00003FEC                 assume cs:_text$mn
.text$mn:00003FEC                 ;org 3FECh
.text$mn:00003FEC ; COMDAT (pick any)
.text$mn:00003FEC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00003FEC
.text$mn:00003FEC ; =============== S U B R O U T I N E =======================================
.text$mn:00003FEC
.text$mn:00003FEC ; Attributes: bp-based frame
.text$mn:00003FEC
.text$mn:00003FEC ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00003FEC                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00003FEC ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00003FEC
.text$mn:00003FEC var_4           = dword ptr -4
.text$mn:00003FEC arg_0           = dword ptr  8
.text$mn:00003FEC
.text$mn:00003FEC                 push    ebp
.text$mn:00003FED                 mov     ebp, esp
.text$mn:00003FEF                 push    ecx
.text$mn:00003FF0                 mov     [ebp+var_4], ecx
.text$mn:00003FF3                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003FF6                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00003FFB                 mov     eax, [ebp+arg_0]
.text$mn:00003FFE                 and     eax, 1
.text$mn:00004001                 jz      short loc_400F
.text$mn:00004003                 mov     ecx, [ebp+var_4]
.text$mn:00004006                 push    ecx             ; void *
.text$mn:00004007                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000400C                 add     esp, 4
.text$mn:0000400F
.text$mn:0000400F loc_400F:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000400F                 mov     eax, [ebp+var_4]
.text$mn:00004012                 mov     esp, ebp
.text$mn:00004014                 pop     ebp
.text$mn:00004015                 retn    4
.text$mn:00004015 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00004015
.text$mn:00004015 _text$mn        ends
.text$mn:00004015
.text$mn:00004018 ; ===========================================================================
.text$mn:00004018
.text$mn:00004018 ; Segment type: Pure code
.text$mn:00004018 ; Segment permissions: Read/Execute
.text$mn:00004018 _text$mn        segment para public 'CODE' use32
.text$mn:00004018                 assume cs:_text$mn
.text$mn:00004018                 ;org 4018h
.text$mn:00004018 ; COMDAT (pick any)
.text$mn:00004018                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004018
.text$mn:00004018 ; =============== S U B R O U T I N E =======================================
.text$mn:00004018
.text$mn:00004018 ; Attributes: bp-based frame
.text$mn:00004018
.text$mn:00004018 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00004018                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00004018 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00004018
.text$mn:00004018 var_4           = dword ptr -4
.text$mn:00004018 arg_0           = dword ptr  8
.text$mn:00004018
.text$mn:00004018                 push    ebp
.text$mn:00004019                 mov     ebp, esp
.text$mn:0000401B                 push    ecx
.text$mn:0000401C                 mov     [ebp+var_4], ecx
.text$mn:0000401F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004022                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00004027                 mov     eax, [ebp+arg_0]
.text$mn:0000402A                 and     eax, 1
.text$mn:0000402D                 jz      short loc_403B
.text$mn:0000402F                 mov     ecx, [ebp+var_4]
.text$mn:00004032                 push    ecx             ; void *
.text$mn:00004033                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004038                 add     esp, 4
.text$mn:0000403B
.text$mn:0000403B loc_403B:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000403B                 mov     eax, [ebp+var_4]
.text$mn:0000403E                 mov     esp, ebp
.text$mn:00004040                 pop     ebp
.text$mn:00004041                 retn    4
.text$mn:00004041 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00004041
.text$mn:00004041 _text$mn        ends
.text$mn:00004041
.text$mn:00004044 ; ===========================================================================
.text$mn:00004044
.text$mn:00004044 ; Segment type: Pure code
.text$mn:00004044 ; Segment permissions: Read/Execute
.text$mn:00004044 _text$mn        segment para public 'CODE' use32
.text$mn:00004044                 assume cs:_text$mn
.text$mn:00004044                 ;org 4044h
.text$mn:00004044 ; COMDAT (pick any)
.text$mn:00004044                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004044
.text$mn:00004044 ; =============== S U B R O U T I N E =======================================
.text$mn:00004044
.text$mn:00004044 ; Attributes: bp-based frame
.text$mn:00004044
.text$mn:00004044 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00004044                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00004044 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00004044
.text$mn:00004044 var_4           = dword ptr -4
.text$mn:00004044 arg_0           = dword ptr  8
.text$mn:00004044
.text$mn:00004044                 push    ebp
.text$mn:00004045                 mov     ebp, esp
.text$mn:00004047                 push    ecx
.text$mn:00004048                 mov     [ebp+var_4], ecx
.text$mn:0000404B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000404E                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00004053                 mov     eax, [ebp+arg_0]
.text$mn:00004056                 and     eax, 1
.text$mn:00004059                 jz      short loc_4067
.text$mn:0000405B                 mov     ecx, [ebp+var_4]
.text$mn:0000405E                 push    ecx             ; void *
.text$mn:0000405F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004064                 add     esp, 4
.text$mn:00004067
.text$mn:00004067 loc_4067:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00004067                 mov     eax, [ebp+var_4]
.text$mn:0000406A                 mov     esp, ebp
.text$mn:0000406C                 pop     ebp
.text$mn:0000406D                 retn    4
.text$mn:0000406D ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:0000406D
.text$mn:0000406D _text$mn        ends
.text$mn:0000406D
.text$di:00004070 ; ===========================================================================
.text$di:00004070
.text$di:00004070 ; Segment type: Pure code
.text$di:00004070 ; Segment permissions: Read/Execute
.text$di:00004070 _text$di        segment para public 'CODE' use32
.text$di:00004070                 assume cs:_text$di
.text$di:00004070                 ;org 4070h
.text$di:00004070 ; COMDAT (pick any)
.text$di:00004070                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00004070
.text$di:00004070 ; =============== S U B R O U T I N E =======================================
.text$di:00004070
.text$di:00004070 ; Attributes: bp-based frame
.text$di:00004070
.text$di:00004070 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00004070 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00004070                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00004070                 push    ebp
.text$di:00004071                 mov     ebp, esp
.text$di:00004073                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00004078                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:0000407D                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00004082                 call    _atexit
.text$di:00004087                 add     esp, 4
.text$di:0000408A                 pop     ebp
.text$di:0000408B                 retn
.text$di:0000408B ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:0000408B
.text$di:0000408B _text$di        ends
.text$di:0000408B
.text$di:0000408C ; ===========================================================================
.text$di:0000408C
.text$di:0000408C ; Segment type: Pure code
.text$di:0000408C ; Segment permissions: Read/Execute
.text$di:0000408C _text$di        segment para public 'CODE' use32
.text$di:0000408C                 assume cs:_text$di
.text$di:0000408C                 ;org 408Ch
.text$di:0000408C ; COMDAT (pick any)
.text$di:0000408C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:0000408C
.text$di:0000408C ; =============== S U B R O U T I N E =======================================
.text$di:0000408C
.text$di:0000408C ; Attributes: bp-based frame
.text$di:0000408C
.text$di:0000408C ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:0000408C ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:0000408C                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:0000408C                 push    ebp
.text$di:0000408D                 mov     ebp, esp
.text$di:0000408F                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00004094                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00004099                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:0000409E                 call    _atexit
.text$di:000040A3                 add     esp, 4
.text$di:000040A6                 pop     ebp
.text$di:000040A7                 retn
.text$di:000040A7 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:000040A7
.text$di:000040A7 _text$di        ends
.text$di:000040A7
.text$di:000040A8 ; ===========================================================================
.text$di:000040A8
.text$di:000040A8 ; Segment type: Pure code
.text$di:000040A8 ; Segment permissions: Read/Execute
.text$di:000040A8 _text$di        segment para public 'CODE' use32
.text$di:000040A8                 assume cs:_text$di
.text$di:000040A8                 ;org 40A8h
.text$di:000040A8 ; COMDAT (pick any)
.text$di:000040A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000040A8
.text$di:000040A8 ; =============== S U B R O U T I N E =======================================
.text$di:000040A8
.text$di:000040A8 ; Attributes: bp-based frame
.text$di:000040A8
.text$di:000040A8 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:000040A8 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:000040A8                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:000040A8                 push    ebp
.text$di:000040A9                 mov     ebp, esp
.text$di:000040AB                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:000040B0                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:000040B5                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000040BA                 call    _atexit
.text$di:000040BF                 add     esp, 4
.text$di:000040C2                 pop     ebp
.text$di:000040C3                 retn
.text$di:000040C3 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:000040C3
.text$di:000040C3 _text$di        ends
.text$di:000040C3
.text$di:000040C4 ; ===========================================================================
.text$di:000040C4
.text$di:000040C4 ; Segment type: Pure code
.text$di:000040C4 ; Segment permissions: Read/Execute
.text$di:000040C4 _text$di        segment para public 'CODE' use32
.text$di:000040C4                 assume cs:_text$di
.text$di:000040C4                 ;org 40C4h
.text$di:000040C4 ; COMDAT (pick any)
.text$di:000040C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000040C4
.text$di:000040C4 ; =============== S U B R O U T I N E =======================================
.text$di:000040C4
.text$di:000040C4 ; Attributes: bp-based frame
.text$di:000040C4
.text$di:000040C4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:000040C4 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000040C4                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:000040C4                 push    ebp
.text$di:000040C5                 mov     ebp, esp
.text$di:000040C7                 push    0               ; unsigned int
.text$di:000040C9                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:000040CE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000040D3                 pop     ebp
.text$di:000040D4                 retn
.text$di:000040D4 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000040D4
.text$di:000040D4 ; ---------------------------------------------------------------------------
.text$di:000040D5                 align 4
.text$di:000040D5 _text$di        ends
.text$di:000040D5
.text$di:000040D8 ; ===========================================================================
.text$di:000040D8
.text$di:000040D8 ; Segment type: Pure code
.text$di:000040D8 ; Segment permissions: Read/Execute
.text$di:000040D8 _text$di        segment para public 'CODE' use32
.text$di:000040D8                 assume cs:_text$di
.text$di:000040D8                 ;org 40D8h
.text$di:000040D8 ; COMDAT (pick any)
.text$di:000040D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000040D8
.text$di:000040D8 ; =============== S U B R O U T I N E =======================================
.text$di:000040D8
.text$di:000040D8 ; Attributes: bp-based frame
.text$di:000040D8
.text$di:000040D8 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:000040D8 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000040D8                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:000040D8                 push    ebp
.text$di:000040D9                 mov     ebp, esp
.text$di:000040DB                 push    0               ; unsigned int
.text$di:000040DD                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:000040E2                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000040E7                 pop     ebp
.text$di:000040E8                 retn
.text$di:000040E8 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000040E8
.text$di:000040E8 ; ---------------------------------------------------------------------------
.text$di:000040E9                 align 4
.text$di:000040E9 _text$di        ends
.text$di:000040E9
.text$di:000040EC ; ===========================================================================
.text$di:000040EC
.text$di:000040EC ; Segment type: Pure code
.text$di:000040EC ; Segment permissions: Read/Execute
.text$di:000040EC _text$di        segment para public 'CODE' use32
.text$di:000040EC                 assume cs:_text$di
.text$di:000040EC                 ;org 40ECh
.text$di:000040EC ; COMDAT (pick any)
.text$di:000040EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000040EC
.text$di:000040EC ; =============== S U B R O U T I N E =======================================
.text$di:000040EC
.text$di:000040EC ; Attributes: bp-based frame
.text$di:000040EC
.text$di:000040EC ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:000040EC ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000040EC                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:000040EC                 push    ebp
.text$di:000040ED                 mov     ebp, esp
.text$di:000040EF                 push    0               ; unsigned int
.text$di:000040F1                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:000040F6                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000040FB                 pop     ebp
.text$di:000040FC                 retn
.text$di:000040FC ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000040FC
.text$di:000040FC ; ---------------------------------------------------------------------------
.text$di:000040FD                 align 10h
.text$di:000040FD _text$di        ends
.text$di:000040FD
.text$di:00004100 ; ===========================================================================
.text$di:00004100
.text$di:00004100 ; Segment type: Pure code
.text$di:00004100 ; Segment permissions: Read/Execute
.text$di:00004100 _text$di        segment para public 'CODE' use32
.text$di:00004100                 assume cs:_text$di
.text$di:00004100                 ;org 4100h
.text$di:00004100 ; COMDAT (pick any)
.text$di:00004100                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00004100
.text$di:00004100 ; =============== S U B R O U T I N E =======================================
.text$di:00004100
.text$di:00004100 ; Attributes: bp-based frame
.text$di:00004100
.text$di:00004100 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00004100 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00004100                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00004100                 push    ebp
.text$di:00004101                 mov     ebp, esp
.text$di:00004103                 push    0               ; unsigned int
.text$di:00004105                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:0000410A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000410F                 pop     ebp
.text$di:00004110                 retn
.text$di:00004110 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00004110
.text$di:00004110 ; ---------------------------------------------------------------------------
.text$di:00004111                 align 4
.text$di:00004111 _text$di        ends
.text$di:00004111
.text$di:00004114 ; ===========================================================================
.text$di:00004114
.text$di:00004114 ; Segment type: Pure code
.text$di:00004114 ; Segment permissions: Read/Execute
.text$di:00004114 _text$di        segment para public 'CODE' use32
.text$di:00004114                 assume cs:_text$di
.text$di:00004114                 ;org 4114h
.text$di:00004114 ; COMDAT (pick any)
.text$di:00004114                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00004114
.text$di:00004114 ; =============== S U B R O U T I N E =======================================
.text$di:00004114
.text$di:00004114 ; Attributes: bp-based frame
.text$di:00004114
.text$di:00004114 ; void __cdecl std::`dynamic initializer for '_Tuple_alloc''(void)
.text$di:00004114 ??__E_Tuple_alloc@std@@YAXXZ proc near  ; DATA XREF: .CRT$XCU:__Tuple_alloc$initializer$o
.text$di:00004114
.text$di:00004114 var_1           = byte ptr -1
.text$di:00004114
.text$di:00004114                 push    ebp
.text$di:00004115                 mov     ebp, esp
.text$di:00004117                 push    ecx
.text$di:00004118                 xor     eax, eax
.text$di:0000411A                 mov     [ebp+var_1], al
.text$di:0000411D                 mov     esp, ebp
.text$di:0000411F                 pop     ebp
.text$di:00004120                 retn
.text$di:00004120 ??__E_Tuple_alloc@std@@YAXXZ endp
.text$di:00004120
.text$di:00004120 ; ---------------------------------------------------------------------------
.text$di:00004121                 align 4
.text$di:00004121 _text$di        ends
.text$di:00004121
.text$di:00004124 ; ===========================================================================
.text$di:00004124
.text$di:00004124 ; Segment type: Pure code
.text$di:00004124 ; Segment permissions: Read/Execute
.text$di:00004124 _text$di        segment para public 'CODE' use32
.text$di:00004124                 assume cs:_text$di
.text$di:00004124                 ;org 4124h
.text$di:00004124 ; COMDAT (pick any)
.text$di:00004124                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00004124
.text$di:00004124 ; =============== S U B R O U T I N E =======================================
.text$di:00004124
.text$di:00004124 ; Attributes: bp-based frame
.text$di:00004124
.text$di:00004124 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00004124 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00004124
.text$di:00004124 var_1           = byte ptr -1
.text$di:00004124
.text$di:00004124                 push    ebp
.text$di:00004125                 mov     ebp, esp
.text$di:00004127                 push    ecx
.text$di:00004128                 xor     eax, eax
.text$di:0000412A                 mov     [ebp+var_1], al
.text$di:0000412D                 mov     esp, ebp
.text$di:0000412F                 pop     ebp
.text$di:00004130                 retn
.text$di:00004130 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00004130
.text$di:00004130 ; ---------------------------------------------------------------------------
.text$di:00004131                 align 4
.text$di:00004131 _text$di        ends
.text$di:00004131
.text$di:00004134 ; ===========================================================================
.text$di:00004134
.text$di:00004134 ; Segment type: Pure code
.text$di:00004134 ; Segment permissions: Read/Execute
.text$di:00004134 _text$di        segment para public 'CODE' use32
.text$di:00004134                 assume cs:_text$di
.text$di:00004134                 ;org 4134h
.text$di:00004134 ; COMDAT (pick any)
.text$di:00004134                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00004134
.text$di:00004134 ; =============== S U B R O U T I N E =======================================
.text$di:00004134
.text$di:00004134 ; Attributes: bp-based frame
.text$di:00004134
.text$di:00004134 ; void __cdecl std::`dynamic initializer for 'ignore''(void)
.text$di:00004134 ??__Eignore@std@@YAXXZ proc near        ; DATA XREF: .CRT$XCU:_ignore$initializer$o
.text$di:00004134                 push    ebp
.text$di:00004135                 mov     ebp, esp
.text$di:00004137                 mov     ecx, offset _ignore ; this
.text$di:0000413C                 call    ??0_Ignore@std@@QAE@XZ ; std::_Ignore::_Ignore(void)
.text$di:00004141                 pop     ebp
.text$di:00004142                 retn
.text$di:00004142 ??__Eignore@std@@YAXXZ endp
.text$di:00004142
.text$di:00004142 ; ---------------------------------------------------------------------------
.text$di:00004143                 align 4
.text$di:00004143 _text$di        ends
.text$di:00004143
.text$di:00004144 ; ===========================================================================
.text$di:00004144
.text$di:00004144 ; Segment type: Pure code
.text$di:00004144 ; Segment permissions: Read/Execute
.text$di:00004144 _text$di        segment para public 'CODE' use32
.text$di:00004144                 assume cs:_text$di
.text$di:00004144                 ;org 4144h
.text$di:00004144 ; COMDAT (pick any)
.text$di:00004144                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00004144
.text$di:00004144 ; =============== S U B R O U T I N E =======================================
.text$di:00004144
.text$di:00004144 ; Attributes: bp-based frame
.text$di:00004144
.text$di:00004144 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00004144 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00004144                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00004144
.text$di:00004144 var_1           = byte ptr -1
.text$di:00004144
.text$di:00004144                 push    ebp
.text$di:00004145                 mov     ebp, esp
.text$di:00004147                 push    ecx
.text$di:00004148                 xor     eax, eax
.text$di:0000414A                 mov     [ebp+var_1], al
.text$di:0000414D                 mov     esp, ebp
.text$di:0000414F                 pop     ebp
.text$di:00004150                 retn
.text$di:00004150 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00004150
.text$di:00004150 ; ---------------------------------------------------------------------------
.text$di:00004151                 align 4
.text$di:00004151 _text$di        ends
.text$di:00004151
.text$yd:00004154 ; ===========================================================================
.text$yd:00004154
.text$yd:00004154 ; Segment type: Pure code
.text$yd:00004154 ; Segment permissions: Read/Execute
.text$yd:00004154 _text$yd        segment para public 'CODE' use32
.text$yd:00004154                 assume cs:_text$yd
.text$yd:00004154                 ;org 4154h
.text$yd:00004154 ; COMDAT (pick any)
.text$yd:00004154                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00004154
.text$yd:00004154 ; =============== S U B R O U T I N E =======================================
.text$yd:00004154
.text$yd:00004154 ; Attributes: bp-based frame
.text$yd:00004154
.text$yd:00004154 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00004154 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00004154                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00004154                 push    ebp
.text$yd:00004155                 mov     ebp, esp
.text$yd:00004157                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:0000415C                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00004161                 pop     ebp
.text$yd:00004162                 retn
.text$yd:00004162 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00004162
.text$yd:00004162 ; ---------------------------------------------------------------------------
.text$yd:00004163                 align 4
.text$yd:00004163 _text$yd        ends
.text$yd:00004163
.text$yd:00004164 ; ===========================================================================
.text$yd:00004164
.text$yd:00004164 ; Segment type: Pure code
.text$yd:00004164 ; Segment permissions: Read/Execute
.text$yd:00004164 _text$yd        segment para public 'CODE' use32
.text$yd:00004164                 assume cs:_text$yd
.text$yd:00004164                 ;org 4164h
.text$yd:00004164 ; COMDAT (pick any)
.text$yd:00004164                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00004164
.text$yd:00004164 ; =============== S U B R O U T I N E =======================================
.text$yd:00004164
.text$yd:00004164 ; Attributes: bp-based frame
.text$yd:00004164
.text$yd:00004164 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00004164 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00004164                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00004164                 push    ebp
.text$yd:00004165                 mov     ebp, esp
.text$yd:00004167                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:0000416C                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00004171                 pop     ebp
.text$yd:00004172                 retn
.text$yd:00004172 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00004172
.text$yd:00004172 ; ---------------------------------------------------------------------------
.text$yd:00004173                 align 4
.text$yd:00004173 _text$yd        ends
.text$yd:00004173
.text$yd:00004174 ; ===========================================================================
.text$yd:00004174
.text$yd:00004174 ; Segment type: Pure code
.text$yd:00004174 ; Segment permissions: Read/Execute
.text$yd:00004174 _text$yd        segment para public 'CODE' use32
.text$yd:00004174                 assume cs:_text$yd
.text$yd:00004174                 ;org 4174h
.text$yd:00004174 ; COMDAT (pick any)
.text$yd:00004174                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00004174
.text$yd:00004174 ; =============== S U B R O U T I N E =======================================
.text$yd:00004174
.text$yd:00004174 ; Attributes: bp-based frame
.text$yd:00004174
.text$yd:00004174 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00004174 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00004174                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00004174                 push    ebp
.text$yd:00004175                 mov     ebp, esp
.text$yd:00004177                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:0000417C                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00004181                 pop     ebp
.text$yd:00004182                 retn
.text$yd:00004182 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00004182
.text$yd:00004182 ; ---------------------------------------------------------------------------
.text$yd:00004183                 align 4
.text$yd:00004183 _text$yd        ends
.text$yd:00004183
.text$mn:00004184 ; ===========================================================================
.text$mn:00004184
.text$mn:00004184 ; Segment type: Pure code
.text$mn:00004184 ; Segment permissions: Read/Execute
.text$mn:00004184 _text$mn        segment para public 'CODE' use32
.text$mn:00004184                 assume cs:_text$mn
.text$mn:00004184                 ;org 4184h
.text$mn:00004184 ; COMDAT (pick any)
.text$mn:00004184                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004184
.text$mn:00004184 ; =============== S U B R O U T I N E =======================================
.text$mn:00004184
.text$mn:00004184 ; Attributes: bp-based frame
.text$mn:00004184
.text$mn:00004184 ; void __thiscall std::_Iterator_base12::_Adopt(std::_Iterator_base12 *this, const struct std::_Container_base12 *)
.text$mn:00004184                 public ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:00004184 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$mn:00004184                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(char const *,std::_Container_base12 const *)+3Cp
.text$mn:00004184                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+49p
.text$mn:00004184
.text$mn:00004184 var_1C          = byte ptr -1Ch
.text$mn:00004184 var_18          = byte ptr -18h
.text$mn:00004184 var_14          = dword ptr -14h
.text$mn:00004184 var_10          = dword ptr -10h
.text$mn:00004184 var_C           = dword ptr -0Ch
.text$mn:00004184 var_4           = dword ptr -4
.text$mn:00004184 arg_0           = dword ptr  8
.text$mn:00004184
.text$mn:00004184                 push    ebp
.text$mn:00004185                 mov     ebp, esp
.text$mn:00004187                 push    0FFFFFFFFh
.text$mn:00004189                 push    offset __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:0000418E                 mov     eax, large fs:0
.text$mn:00004194                 push    eax
.text$mn:00004195                 sub     esp, 10h
.text$mn:00004198                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000419D                 xor     eax, ebp
.text$mn:0000419F                 push    eax
.text$mn:000041A0                 lea     eax, [ebp+var_C]
.text$mn:000041A3                 mov     large fs:0, eax
.text$mn:000041A9                 mov     [ebp+var_10], ecx
.text$mn:000041AC                 cmp     [ebp+arg_0], 0
.text$mn:000041B0                 jnz     short loc_41DC
.text$mn:000041B2                 push    3               ; int
.text$mn:000041B4                 lea     ecx, [ebp+var_18] ; this
.text$mn:000041B7                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000041BC                 mov     [ebp+var_4], 0
.text$mn:000041C3                 mov     ecx, [ebp+var_10] ; this
.text$mn:000041C6                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:000041CB                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000041D2                 lea     ecx, [ebp+var_18] ; this
.text$mn:000041D5                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000041DA                 jmp     short loc_4233
.text$mn:000041DC ; ---------------------------------------------------------------------------
.text$mn:000041DC
.text$mn:000041DC loc_41DC:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+2Cj
.text$mn:000041DC                 mov     eax, [ebp+arg_0]
.text$mn:000041DF                 mov     ecx, [eax]
.text$mn:000041E1                 mov     [ebp+var_14], ecx
.text$mn:000041E4                 mov     edx, [ebp+var_10]
.text$mn:000041E7                 mov     eax, [edx]
.text$mn:000041E9                 cmp     eax, [ebp+var_14]
.text$mn:000041EC                 jz      short loc_4233
.text$mn:000041EE                 push    3               ; int
.text$mn:000041F0                 lea     ecx, [ebp+var_1C] ; this
.text$mn:000041F3                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000041F8                 mov     [ebp+var_4], 1
.text$mn:000041FF                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004202                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00004207                 mov     ecx, [ebp+var_10]
.text$mn:0000420A                 mov     edx, [ebp+var_14]
.text$mn:0000420D                 mov     eax, [edx+4]
.text$mn:00004210                 mov     [ecx+4], eax
.text$mn:00004213                 mov     ecx, [ebp+var_14]
.text$mn:00004216                 mov     edx, [ebp+var_10]
.text$mn:00004219                 mov     [ecx+4], edx
.text$mn:0000421C                 mov     eax, [ebp+var_10]
.text$mn:0000421F                 mov     ecx, [ebp+var_14]
.text$mn:00004222                 mov     [eax], ecx
.text$mn:00004224                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000422B                 lea     ecx, [ebp+var_1C] ; this
.text$mn:0000422E                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00004233
.text$mn:00004233 loc_4233:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+56j
.text$mn:00004233                                         ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+68j
.text$mn:00004233                 mov     ecx, [ebp+var_C]
.text$mn:00004236                 mov     large fs:0, ecx
.text$mn:0000423D                 pop     ecx
.text$mn:0000423E                 mov     esp, ebp
.text$mn:00004240                 pop     ebp
.text$mn:00004241                 retn    4
.text$mn:00004241 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$mn:00004241
.text$mn:00004241 _text$mn        ends
.text$mn:00004241
.text$x:00004244 ; ===========================================================================
.text$x:00004244
.text$x:00004244 ; Segment type: Pure code
.text$x:00004244 ; Segment permissions: Read/Execute
.text$x:00004244 _text$x         segment para public 'CODE' use32
.text$x:00004244                 assume cs:_text$x
.text$x:00004244                 ;org 4244h
.text$x:00004244 ; COMDAT (pick associative to section at 4184)
.text$x:00004244                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004244
.text$x:00004244 ; =============== S U B R O U T I N E =======================================
.text$x:00004244
.text$x:00004244
.text$x:00004244 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 proc near
.text$x:00004244                                         ; DATA XREF: .xdata$x:000061ACo
.text$x:00004244                 lea     ecx, [ebp-18h]  ; this
.text$x:00004247                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00004247 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 endp
.text$x:00004247
.text$x:0000424C
.text$x:0000424C ; =============== S U B R O U T I N E =======================================
.text$x:0000424C
.text$x:0000424C
.text$x:0000424C __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 proc near
.text$x:0000424C                                         ; DATA XREF: .xdata$x:000061B4o
.text$x:0000424C                 lea     ecx, [ebp-1Ch]  ; this
.text$x:0000424F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000424F __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 endp
.text$x:0000424F
.text$x:00004254
.text$x:00004254 ; =============== S U B R O U T I N E =======================================
.text$x:00004254
.text$x:00004254
.text$x:00004254 __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$x:00004254                                         ; DATA XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+5o
.text$x:00004254
.text$x:00004254 arg_4           = dword ptr  8
.text$x:00004254
.text$x:00004254                 mov     edx, [esp+arg_4]
.text$x:00004258                 lea     eax, [edx+0Ch]
.text$x:0000425B                 mov     ecx, [edx-14h]
.text$x:0000425E                 xor     ecx, eax
.text$x:00004260                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004265                 mov     eax, offset __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$x:0000426A                 jmp     ___CxxFrameHandler3
.text$x:0000426A __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$x:0000426A
.text$x:0000426A ; ---------------------------------------------------------------------------
.text$x:0000426F                 align 10h
.text$x:0000426F _text$x         ends
.text$x:0000426F
.text$mn:00004270 ; ===========================================================================
.text$mn:00004270
.text$mn:00004270 ; Segment type: Pure code
.text$mn:00004270 ; Segment permissions: Read/Execute
.text$mn:00004270 _text$mn        segment para public 'CODE' use32
.text$mn:00004270                 assume cs:_text$mn
.text$mn:00004270                 ;org 4270h
.text$mn:00004270 ; COMDAT (pick any)
.text$mn:00004270                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004270
.text$mn:00004270 ; =============== S U B R O U T I N E =======================================
.text$mn:00004270
.text$mn:00004270 ; Attributes: bp-based frame
.text$mn:00004270
.text$mn:00004270 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00004270                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00004270 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00004270                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00004270
.text$mn:00004270 var_10          = byte ptr -10h
.text$mn:00004270 var_8           = dword ptr -8
.text$mn:00004270 var_1           = byte ptr -1
.text$mn:00004270
.text$mn:00004270                 push    ebp
.text$mn:00004271                 mov     ebp, esp
.text$mn:00004273                 sub     esp, 10h
.text$mn:00004276                 mov     [ebp+var_8], ecx
.text$mn:00004279                 lea     ecx, [ebp+var_1]
.text$mn:0000427C                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00004281                 push    1
.text$mn:00004283                 lea     ecx, [ebp+var_1]
.text$mn:00004286                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:0000428B                 mov     ecx, [ebp+var_8]
.text$mn:0000428E                 mov     [ecx], eax
.text$mn:00004290                 lea     ecx, [ebp+var_10] ; this
.text$mn:00004293                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00004298                 push    eax             ; int
.text$mn:00004299                 mov     edx, [ebp+var_8]
.text$mn:0000429C                 mov     eax, [edx]
.text$mn:0000429E                 push    eax             ; void *
.text$mn:0000429F                 lea     ecx, [ebp+var_1]
.text$mn:000042A2                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000042A7                 mov     ecx, [ebp+var_8]
.text$mn:000042AA                 mov     edx, [ecx]
.text$mn:000042AC                 mov     eax, [ebp+var_8]
.text$mn:000042AF                 mov     [edx], eax
.text$mn:000042B1                 mov     esp, ebp
.text$mn:000042B3                 pop     ebp
.text$mn:000042B4                 retn
.text$mn:000042B4 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000042B4
.text$mn:000042B4 ; ---------------------------------------------------------------------------
.text$mn:000042B5                 align 4
.text$mn:000042B5 _text$mn        ends
.text$mn:000042B5
.text$mn:000042B8 ; ===========================================================================
.text$mn:000042B8
.text$mn:000042B8 ; Segment type: Pure code
.text$mn:000042B8 ; Segment permissions: Read/Execute
.text$mn:000042B8 _text$mn        segment para public 'CODE' use32
.text$mn:000042B8                 assume cs:_text$mn
.text$mn:000042B8                 ;org 42B8h
.text$mn:000042B8 ; COMDAT (pick any)
.text$mn:000042B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000042B8
.text$mn:000042B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000042B8
.text$mn:000042B8 ; Attributes: bp-based frame
.text$mn:000042B8
.text$mn:000042B8 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>>::_Alloc_proxy(void)
.text$mn:000042B8                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAEXXZ
.text$mn:000042B8 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAEXXZ proc near
.text$mn:000042B8                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>(std::allocator<std::pair<int,int>> const &)+38p
.text$mn:000042B8
.text$mn:000042B8 var_10          = byte ptr -10h
.text$mn:000042B8 var_8           = dword ptr -8
.text$mn:000042B8 var_1           = byte ptr -1
.text$mn:000042B8
.text$mn:000042B8                 push    ebp
.text$mn:000042B9                 mov     ebp, esp
.text$mn:000042BB                 sub     esp, 10h
.text$mn:000042BE                 mov     [ebp+var_8], ecx
.text$mn:000042C1                 lea     ecx, [ebp+var_1]
.text$mn:000042C4                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:000042C9                 push    1
.text$mn:000042CB                 lea     ecx, [ebp+var_1]
.text$mn:000042CE                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:000042D3                 mov     ecx, [ebp+var_8]
.text$mn:000042D6                 mov     [ecx], eax
.text$mn:000042D8                 lea     ecx, [ebp+var_10] ; this
.text$mn:000042DB                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000042E0                 push    eax             ; int
.text$mn:000042E1                 mov     edx, [ebp+var_8]
.text$mn:000042E4                 mov     eax, [edx]
.text$mn:000042E6                 push    eax             ; void *
.text$mn:000042E7                 lea     ecx, [ebp+var_1]
.text$mn:000042EA                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000042EF                 mov     ecx, [ebp+var_8]
.text$mn:000042F2                 mov     edx, [ecx]
.text$mn:000042F4                 mov     eax, [ebp+var_8]
.text$mn:000042F7                 mov     [edx], eax
.text$mn:000042F9                 mov     esp, ebp
.text$mn:000042FB                 pop     ebp
.text$mn:000042FC                 retn
.text$mn:000042FC ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAEXXZ endp
.text$mn:000042FC
.text$mn:000042FC ; ---------------------------------------------------------------------------
.text$mn:000042FD                 align 10h
.text$mn:000042FD _text$mn        ends
.text$mn:000042FD
.text$mn:00004300 ; ===========================================================================
.text$mn:00004300
.text$mn:00004300 ; Segment type: Pure code
.text$mn:00004300 ; Segment permissions: Read/Execute
.text$mn:00004300 _text$mn        segment para public 'CODE' use32
.text$mn:00004300                 assume cs:_text$mn
.text$mn:00004300                 ;org 4300h
.text$mn:00004300 ; COMDAT (pick any)
.text$mn:00004300                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004300
.text$mn:00004300 ; =============== S U B R O U T I N E =======================================
.text$mn:00004300
.text$mn:00004300 ; Attributes: bp-based frame
.text$mn:00004300
.text$mn:00004300 ; int __stdcall std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Assign_rv(struct std::_Container_base12 *, int)
.text$mn:00004300                 public ?_Assign_rv@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
.text$mn:00004300 ?_Assign_rv@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z proc near
.text$mn:00004300                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>(std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>> &&)+5Ep
.text$mn:00004300
.text$mn:00004300 var_4           = dword ptr -4
.text$mn:00004300 arg_0           = dword ptr  8
.text$mn:00004300
.text$mn:00004300                 push    ebp
.text$mn:00004301                 mov     ebp, esp
.text$mn:00004303                 push    ecx
.text$mn:00004304                 mov     [ebp+var_4], ecx
.text$mn:00004307                 mov     eax, [ebp+arg_0]
.text$mn:0000430A                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000430B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000430E                 call    ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z ; std::_Container_base12::_Swap_all(std::_Container_base12 &)
.text$mn:00004313                 mov     ecx, [ebp+var_4]
.text$mn:00004316                 mov     edx, [ebp+arg_0]
.text$mn:00004319                 mov     eax, [edx+4]
.text$mn:0000431C                 mov     [ecx+4], eax
.text$mn:0000431F                 mov     ecx, [ebp+var_4]
.text$mn:00004322                 mov     edx, [ebp+arg_0]
.text$mn:00004325                 mov     eax, [edx+8]
.text$mn:00004328                 mov     [ecx+8], eax
.text$mn:0000432B                 mov     ecx, [ebp+var_4]
.text$mn:0000432E                 mov     edx, [ebp+arg_0]
.text$mn:00004331                 mov     eax, [edx+0Ch]
.text$mn:00004334                 mov     [ecx+0Ch], eax
.text$mn:00004337                 mov     ecx, [ebp+arg_0]
.text$mn:0000433A                 mov     dword ptr [ecx+4], 0
.text$mn:00004341                 mov     edx, [ebp+arg_0]
.text$mn:00004344                 mov     dword ptr [edx+8], 0
.text$mn:0000434B                 mov     eax, [ebp+arg_0]
.text$mn:0000434E                 mov     dword ptr [eax+0Ch], 0
.text$mn:00004355                 mov     esp, ebp
.text$mn:00004357                 pop     ebp
.text$mn:00004358                 retn    8
.text$mn:00004358 ?_Assign_rv@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z endp
.text$mn:00004358
.text$mn:00004358 ; ---------------------------------------------------------------------------
.text$mn:0000435B                 align 4
.text$mn:0000435B _text$mn        ends
.text$mn:0000435B
.text$mn:0000435C ; ===========================================================================
.text$mn:0000435C
.text$mn:0000435C ; Segment type: Pure code
.text$mn:0000435C ; Segment permissions: Read/Execute
.text$mn:0000435C _text$mn        segment para public 'CODE' use32
.text$mn:0000435C                 assume cs:_text$mn
.text$mn:0000435C                 ;org 435Ch
.text$mn:0000435C ; COMDAT (pick any)
.text$mn:0000435C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000435C
.text$mn:0000435C ; =============== S U B R O U T I N E =======================================
.text$mn:0000435C
.text$mn:0000435C ; Attributes: bp-based frame
.text$mn:0000435C
.text$mn:0000435C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Chassign(int, size_t Size, char)
.text$mn:0000435C                 public ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z
.text$mn:0000435C ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z proc near
.text$mn:0000435C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::insert(uint,uint,char)+98p
.text$mn:0000435C
.text$mn:0000435C var_4           = dword ptr -4
.text$mn:0000435C arg_0           = dword ptr  8
.text$mn:0000435C Size            = dword ptr  0Ch
.text$mn:0000435C arg_8           = byte ptr  10h
.text$mn:0000435C
.text$mn:0000435C                 push    ebp
.text$mn:0000435D                 mov     ebp, esp
.text$mn:0000435F                 push    ecx
.text$mn:00004360                 mov     [ebp+var_4], ecx
.text$mn:00004363                 cmp     [ebp+Size], 1
.text$mn:00004367                 jnz     short loc_4383
.text$mn:00004369                 lea     eax, [ebp+arg_8]
.text$mn:0000436C                 push    eax
.text$mn:0000436D                 mov     ecx, [ebp+var_4]
.text$mn:00004370                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00004375                 add     eax, [ebp+arg_0]
.text$mn:00004378                 push    eax
.text$mn:00004379                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:0000437E                 add     esp, 8
.text$mn:00004381                 jmp     short loc_43A0
.text$mn:00004383 ; ---------------------------------------------------------------------------
.text$mn:00004383
.text$mn:00004383 loc_4383:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Chassign(uint,uint,char)+Bj
.text$mn:00004383                 movzx   ecx, [ebp+arg_8]
.text$mn:00004387                 push    ecx             ; char
.text$mn:00004388                 mov     edx, [ebp+Size]
.text$mn:0000438B                 push    edx             ; Size
.text$mn:0000438C                 mov     ecx, [ebp+var_4]
.text$mn:0000438F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00004394                 add     eax, [ebp+arg_0]
.text$mn:00004397                 push    eax             ; Dst
.text$mn:00004398                 call    ?assign@?$char_traits@D@std@@SAPADPADID@Z ; std::char_traits<char>::assign(char *,uint,char)
.text$mn:0000439D                 add     esp, 0Ch
.text$mn:000043A0
.text$mn:000043A0 loc_43A0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Chassign(uint,uint,char)+25j
.text$mn:000043A0                 mov     esp, ebp
.text$mn:000043A2                 pop     ebp
.text$mn:000043A3                 retn    0Ch
.text$mn:000043A3 ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z endp
.text$mn:000043A3
.text$mn:000043A3 ; ---------------------------------------------------------------------------
.text$mn:000043A6                 align 4
.text$mn:000043A6 _text$mn        ends
.text$mn:000043A6
.text$mn:000043A8 ; ===========================================================================
.text$mn:000043A8
.text$mn:000043A8 ; Segment type: Pure code
.text$mn:000043A8 ; Segment permissions: Read/Execute
.text$mn:000043A8 _text$mn        segment para public 'CODE' use32
.text$mn:000043A8                 assume cs:_text$mn
.text$mn:000043A8                 ;org 43A8h
.text$mn:000043A8 ; COMDAT (pick any)
.text$mn:000043A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000043A8
.text$mn:000043A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000043A8
.text$mn:000043A8 ; Attributes: bp-based frame
.text$mn:000043A8
.text$mn:000043A8 ; void __thiscall std::_Iterator_base12::_Clrcont(std::_Iterator_base12 *__hidden this)
.text$mn:000043A8                 public ?_Clrcont@_Iterator_base12@std@@QAEXXZ
.text$mn:000043A8 ?_Clrcont@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:000043A8                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Orphan_range(std::pair<int,int> *,std::pair<int,int> *)+80p
.text$mn:000043A8
.text$mn:000043A8 var_4           = dword ptr -4
.text$mn:000043A8
.text$mn:000043A8                 push    ebp
.text$mn:000043A9                 mov     ebp, esp
.text$mn:000043AB                 push    ecx
.text$mn:000043AC                 mov     [ebp+var_4], ecx
.text$mn:000043AF                 mov     eax, [ebp+var_4]
.text$mn:000043B2                 mov     dword ptr [eax], 0
.text$mn:000043B8                 mov     esp, ebp
.text$mn:000043BA                 pop     ebp
.text$mn:000043BB                 retn
.text$mn:000043BB ?_Clrcont@_Iterator_base12@std@@QAEXXZ endp
.text$mn:000043BB
.text$mn:000043BB _text$mn        ends
.text$mn:000043BB
.text$mn:000043BC ; ===========================================================================
.text$mn:000043BC
.text$mn:000043BC ; Segment type: Pure code
.text$mn:000043BC ; Segment permissions: Read/Execute
.text$mn:000043BC _text$mn        segment para public 'CODE' use32
.text$mn:000043BC                 assume cs:_text$mn
.text$mn:000043BC                 ;org 43BCh
.text$mn:000043BC ; COMDAT (pick any)
.text$mn:000043BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000043BC
.text$mn:000043BC ; =============== S U B R O U T I N E =======================================
.text$mn:000043BC
.text$mn:000043BC ; Attributes: bp-based frame
.text$mn:000043BC
.text$mn:000043BC ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_Compat(std::_Iterator_base12 *)
.text$mn:000043BC                 public ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z
.text$mn:000043BC ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z proc near
.text$mn:000043BC                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>> const &)+Ep
.text$mn:000043BC
.text$mn:000043BC var_4           = dword ptr -4
.text$mn:000043BC arg_0           = dword ptr  8
.text$mn:000043BC
.text$mn:000043BC                 push    ebp
.text$mn:000043BD                 mov     ebp, esp
.text$mn:000043BF                 push    ecx
.text$mn:000043C0                 push    esi
.text$mn:000043C1                 mov     [ebp+var_4], ecx
.text$mn:000043C4                 mov     ecx, [ebp+var_4] ; this
.text$mn:000043C7                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000043CC                 test    eax, eax
.text$mn:000043CE                 jz      short loc_43E6
.text$mn:000043D0                 mov     ecx, [ebp+var_4] ; this
.text$mn:000043D3                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000043D8                 mov     esi, eax
.text$mn:000043DA                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000043DD                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000043E2                 cmp     esi, eax
.text$mn:000043E4                 jz      short loc_444E
.text$mn:000043E6
.text$mn:000043E6 loc_43E6:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>> const &)+12j
.text$mn:000043E6                 push    0FAh ; '·'      ; unsigned int
.text$mn:000043EB                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000043F0                 push    offset ??_C@_1DM@KDEKGMPF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ ; "string iterators incompatible"
.text$mn:000043F5                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000043FA                 add     esp, 0Ch
.text$mn:000043FD                 mov     eax, offset ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; "Standard C++ Libraries Invalid Argument"
.text$mn:00004402                 test    eax, eax
.text$mn:00004404                 jz      short loc_440A
.text$mn:00004406                 xor     ecx, ecx
.text$mn:00004408                 jnz     short loc_4430
.text$mn:0000440A
.text$mn:0000440A loc_440A:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>> const &)+48j
.text$mn:0000440A                 push    offset ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; "\"Standard C++ Libraries Invalid Argume"...
.text$mn:0000440F                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00004414                 push    0
.text$mn:00004416                 push    0FBh ; 'v'
.text$mn:0000441B                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004420                 push    2
.text$mn:00004422                 call    __CrtDbgReportW
.text$mn:00004427                 add     esp, 18h
.text$mn:0000442A                 cmp     eax, 1
.text$mn:0000442D                 jnz     short loc_4430
.text$mn:0000442F                 int     3               ; Trap to Debugger
.text$mn:00004430
.text$mn:00004430 loc_4430:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>> const &)+4Cj
.text$mn:00004430                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>> const &)+71j
.text$mn:00004430                 push    0
.text$mn:00004432                 push    0FBh ; 'v'
.text$mn:00004437                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000443C                 push    offset ??_C@_1MA@BDELDFHB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_String_const_iterator<class std::"...
.text$mn:00004441                 push    offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
.text$mn:00004446                 call    __invalid_parameter
.text$mn:0000444B                 add     esp, 14h
.text$mn:0000444E
.text$mn:0000444E loc_444E:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>> const &)+28j
.text$mn:0000444E                 pop     esi
.text$mn:0000444F                 mov     esp, ebp
.text$mn:00004451                 pop     ebp
.text$mn:00004452                 retn    4
.text$mn:00004452 ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z endp
.text$mn:00004452
.text$mn:00004452 ; ---------------------------------------------------------------------------
.text$mn:00004455                 align 4
.text$mn:00004455 _text$mn        ends
.text$mn:00004455
.text$mn:00004458 ; ===========================================================================
.text$mn:00004458
.text$mn:00004458 ; Segment type: Pure code
.text$mn:00004458 ; Segment permissions: Read/Execute
.text$mn:00004458 _text$mn        segment para public 'CODE' use32
.text$mn:00004458                 assume cs:_text$mn
.text$mn:00004458                 ;org 4458h
.text$mn:00004458 ; COMDAT (pick any)
.text$mn:00004458                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004458
.text$mn:00004458 ; =============== S U B R O U T I N E =======================================
.text$mn:00004458
.text$mn:00004458 ; Attributes: bp-based frame
.text$mn:00004458
.text$mn:00004458 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00004458                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00004458 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00004458                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00004458
.text$mn:00004458 var_20          = dword ptr -20h
.text$mn:00004458 var_1C          = dword ptr -1Ch
.text$mn:00004458 var_18          = dword ptr -18h
.text$mn:00004458 var_11          = byte ptr -11h
.text$mn:00004458 var_10          = dword ptr -10h
.text$mn:00004458 var_C           = byte ptr -0Ch
.text$mn:00004458 var_4           = dword ptr -4
.text$mn:00004458 arg_0           = dword ptr  8
.text$mn:00004458
.text$mn:00004458 ; FUNCTION CHUNK AT .text$mn:0000457A SIZE 00000009 BYTES
.text$mn:00004458
.text$mn:00004458                 push    ebp
.text$mn:00004459                 mov     ebp, esp
.text$mn:0000445B                 push    0FFFFFFFFh
.text$mn:0000445D                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00004462                 mov     eax, large fs:0
.text$mn:00004468                 push    eax
.text$mn:00004469                 push    ecx
.text$mn:0000446A                 sub     esp, 10h
.text$mn:0000446D                 push    ebx
.text$mn:0000446E                 push    esi
.text$mn:0000446F                 push    edi
.text$mn:00004470                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004475                 xor     eax, ebp
.text$mn:00004477                 push    eax
.text$mn:00004478                 lea     eax, [ebp+var_C]
.text$mn:0000447B                 mov     large fs:0, eax
.text$mn:00004481                 mov     [ebp+var_10], esp
.text$mn:00004484                 mov     [ebp+var_18], ecx
.text$mn:00004487                 mov     eax, [ebp+arg_0]
.text$mn:0000448A                 or      eax, 0Fh
.text$mn:0000448D                 mov     [ebp+var_1C], eax
.text$mn:00004490                 mov     ecx, [ebp+var_18]
.text$mn:00004493                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00004498                 cmp     eax, [ebp+var_1C]
.text$mn:0000449B                 jnb     short loc_44A5
.text$mn:0000449D                 mov     ecx, [ebp+arg_0]
.text$mn:000044A0                 mov     [ebp+var_1C], ecx
.text$mn:000044A3                 jmp     short loc_44F7
.text$mn:000044A5 ; ---------------------------------------------------------------------------
.text$mn:000044A5
.text$mn:000044A5 loc_44A5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:000044A5                 mov     edx, [ebp+var_18]
.text$mn:000044A8                 mov     ecx, [edx+18h]
.text$mn:000044AB                 shr     ecx, 1
.text$mn:000044AD                 mov     eax, [ebp+var_1C]
.text$mn:000044B0                 xor     edx, edx
.text$mn:000044B2                 mov     esi, 3
.text$mn:000044B7                 div     esi
.text$mn:000044B9                 cmp     ecx, eax
.text$mn:000044BB                 ja      short loc_44BF
.text$mn:000044BD                 jmp     short loc_44F7
.text$mn:000044BF ; ---------------------------------------------------------------------------
.text$mn:000044BF
.text$mn:000044BF loc_44BF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:000044BF                 mov     ecx, [ebp+var_18]
.text$mn:000044C2                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000044C7                 mov     edx, [ebp+var_18]
.text$mn:000044CA                 mov     ecx, [edx+18h]
.text$mn:000044CD                 shr     ecx, 1
.text$mn:000044CF                 sub     eax, ecx
.text$mn:000044D1                 mov     edx, [ebp+var_18]
.text$mn:000044D4                 cmp     [edx+18h], eax
.text$mn:000044D7                 ja      short loc_44EC
.text$mn:000044D9                 mov     eax, [ebp+var_18]
.text$mn:000044DC                 mov     ecx, [eax+18h]
.text$mn:000044DF                 shr     ecx, 1
.text$mn:000044E1                 mov     edx, [ebp+var_18]
.text$mn:000044E4                 add     ecx, [edx+18h]
.text$mn:000044E7                 mov     [ebp+var_1C], ecx
.text$mn:000044EA                 jmp     short loc_44F7
.text$mn:000044EC ; ---------------------------------------------------------------------------
.text$mn:000044EC
.text$mn:000044EC loc_44EC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:000044EC                 mov     ecx, [ebp+var_18]
.text$mn:000044EF                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000044F4                 mov     [ebp+var_1C], eax
.text$mn:000044F7
.text$mn:000044F7 loc_44F7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:000044F7                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:000044F7                 mov     [ebp+var_4], 0
.text$mn:000044FE                 mov     eax, [ebp+var_1C]
.text$mn:00004501                 add     eax, 1
.text$mn:00004504                 push    eax
.text$mn:00004505                 lea     ecx, [ebp+var_11]
.text$mn:00004508                 push    ecx
.text$mn:00004509                 mov     ecx, [ebp+var_18]
.text$mn:0000450C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00004511                 mov     ecx, eax
.text$mn:00004513                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00004518                 mov     [ebp+var_20], eax
.text$mn:0000451B                 jmp     short loc_457A
.text$mn:0000451B ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:0000451B
.text$mn:0000451D
.text$mn:0000451D ; =============== S U B R O U T I N E =======================================
.text$mn:0000451D
.text$mn:0000451D
.text$mn:0000451D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:0000451D                                         ; DATA XREF: .xdata$x:000063FCo
.text$mn:0000451D
.text$mn:0000451D ; FUNCTION CHUNK AT .text$mn:00004564 SIZE 00000009 BYTES
.text$mn:0000451D ; FUNCTION CHUNK AT .text$mn:00004574 SIZE 00000006 BYTES
.text$mn:0000451D
.text$mn:0000451D                 mov     [ebp-10h], esp
.text$mn:00004520                 mov     edx, [ebp+8]
.text$mn:00004523                 mov     [ebp-1Ch], edx
.text$mn:00004526                 mov     byte ptr [ebp-4], 2
.text$mn:0000452A                 mov     eax, [ebp-1Ch]
.text$mn:0000452D                 add     eax, 1
.text$mn:00004530                 push    eax
.text$mn:00004531                 lea     ecx, [ebp-12h]
.text$mn:00004534                 push    ecx
.text$mn:00004535                 mov     ecx, [ebp-18h]
.text$mn:00004538                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000453D                 mov     ecx, eax
.text$mn:0000453F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00004544                 mov     [ebp-20h], eax
.text$mn:00004547                 jmp     short loc_4564
.text$mn:00004547 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00004547
.text$mn:00004549
.text$mn:00004549 ; =============== S U B R O U T I N E =======================================
.text$mn:00004549
.text$mn:00004549 ; Attributes: noreturn
.text$mn:00004549
.text$mn:00004549 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00004549                                         ; DATA XREF: .xdata$x:0000640Co
.text$mn:00004549                 push    0               ; Size
.text$mn:0000454B                 push    1               ; char
.text$mn:0000454D                 mov     ecx, [ebp-18h]
.text$mn:00004550                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00004555                 push    0
.text$mn:00004557                 push    0
.text$mn:00004559                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00004559 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00004559
.text$mn:0000455E ; ---------------------------------------------------------------------------
.text$mn:0000455E                 mov     eax, offset $LN17
.text$mn:00004563                 retn
.text$mn:00004564 ; ---------------------------------------------------------------------------
.text$mn:00004564 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00004564
.text$mn:00004564 loc_4564:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00004564                 mov     dword ptr [ebp-4], 1
.text$mn:0000456B                 jmp     short loc_4574
.text$mn:0000456B ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000456D
.text$mn:0000456D ; =============== S U B R O U T I N E =======================================
.text$mn:0000456D
.text$mn:0000456D
.text$mn:0000456D $LN17           proc near               ; DATA XREF: .text$mn:0000455Eo
.text$mn:0000456D                 mov     dword ptr [ebp-4], 1
.text$mn:0000456D $LN17           endp ; sp-analysis failed
.text$mn:0000456D
.text$mn:00004574 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00004574
.text$mn:00004574 loc_4574:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00004574                 mov     eax, offset $LN19
.text$mn:00004579                 retn
.text$mn:00004579 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000457A ; ---------------------------------------------------------------------------
.text$mn:0000457A ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000457A
.text$mn:0000457A loc_457A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:0000457A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004581                 jmp     short loc_458A
.text$mn:00004581 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00004583
.text$mn:00004583 ; =============== S U B R O U T I N E =======================================
.text$mn:00004583
.text$mn:00004583
.text$mn:00004583 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_4574o
.text$mn:00004583                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000458A
.text$mn:0000458A loc_458A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:0000458A                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:0000458E                 jbe     short loc_45A9
.text$mn:00004590                 mov     edx, [ebp+0Ch]
.text$mn:00004593                 push    edx             ; Size
.text$mn:00004594                 mov     ecx, [ebp-18h]
.text$mn:00004597                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000459C                 push    eax             ; Src
.text$mn:0000459D                 mov     eax, [ebp-20h]
.text$mn:000045A0                 push    eax             ; Dst
.text$mn:000045A1                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000045A6                 add     esp, 0Ch
.text$mn:000045A9
.text$mn:000045A9 loc_45A9:                               ; CODE XREF: $LN19+Bj
.text$mn:000045A9                 push    0               ; Size
.text$mn:000045AB                 push    1               ; char
.text$mn:000045AD                 mov     ecx, [ebp-18h]
.text$mn:000045B0                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000045B5                 lea     ecx, [ebp-20h]
.text$mn:000045B8                 push    ecx             ; int
.text$mn:000045B9                 mov     edx, [ebp-18h]
.text$mn:000045BC                 add     edx, 4
.text$mn:000045BF                 push    edx             ; void *
.text$mn:000045C0                 lea     eax, [ebp-13h]
.text$mn:000045C3                 push    eax
.text$mn:000045C4                 mov     ecx, [ebp-18h]
.text$mn:000045C7                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000045CC                 mov     ecx, eax
.text$mn:000045CE                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:000045D3                 mov     ecx, [ebp-18h]
.text$mn:000045D6                 mov     edx, [ebp-1Ch]
.text$mn:000045D9                 mov     [ecx+18h], edx
.text$mn:000045DC                 mov     eax, [ebp+0Ch]
.text$mn:000045DF                 push    eax
.text$mn:000045E0                 mov     ecx, [ebp-18h]
.text$mn:000045E3                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000045E8                 mov     ecx, [ebp-0Ch]
.text$mn:000045EB                 mov     large fs:0, ecx
.text$mn:000045F2                 pop     ecx
.text$mn:000045F3                 pop     edi
.text$mn:000045F4                 pop     esi
.text$mn:000045F5                 pop     ebx
.text$mn:000045F6                 mov     esp, ebp
.text$mn:000045F8                 pop     ebp
.text$mn:000045F9                 retn    8
.text$mn:000045F9 $LN19           endp ; sp-analysis failed
.text$mn:000045F9
.text$mn:000045F9 _text$mn        ends
.text$mn:000045F9
.text$x:000045FC ; ===========================================================================
.text$x:000045FC
.text$x:000045FC ; Segment type: Pure code
.text$x:000045FC ; Segment permissions: Read/Execute
.text$x:000045FC _text$x         segment para public 'CODE' use32
.text$x:000045FC                 assume cs:_text$x
.text$x:000045FC                 ;org 45FCh
.text$x:000045FC ; COMDAT (pick associative to section at 4458)
.text$x:000045FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000045FC
.text$x:000045FC ; =============== S U B R O U T I N E =======================================
.text$x:000045FC
.text$x:000045FC
.text$x:000045FC __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:000045FC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:000045FC
.text$x:000045FC arg_4           = dword ptr  8
.text$x:000045FC
.text$x:000045FC                 mov     edx, [esp+arg_4]
.text$x:00004600                 lea     eax, [edx+0Ch]
.text$x:00004603                 mov     ecx, [edx-24h]
.text$x:00004606                 xor     ecx, eax
.text$x:00004608                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000460D                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00004612                 jmp     ___CxxFrameHandler3
.text$x:00004612 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00004612
.text$x:00004612 ; ---------------------------------------------------------------------------
.text$x:00004617                 align 4
.text$x:00004617 _text$x         ends
.text$x:00004617
.text$mn:00004618 ; ===========================================================================
.text$mn:00004618
.text$mn:00004618 ; Segment type: Pure code
.text$mn:00004618 ; Segment permissions: Read/Execute
.text$mn:00004618 _text$mn        segment para public 'CODE' use32
.text$mn:00004618                 assume cs:_text$mn
.text$mn:00004618                 ;org 4618h
.text$mn:00004618 ; COMDAT (pick any)
.text$mn:00004618                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004618
.text$mn:00004618 ; =============== S U B R O U T I N E =======================================
.text$mn:00004618
.text$mn:00004618 ; Attributes: bp-based frame
.text$mn:00004618
.text$mn:00004618 ; protected: void __thiscall std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>::_Destroy(struct std::pair<int, int> *, struct std::pair<int, int> *)
.text$mn:00004618                 public ?_Destroy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXPAU?$pair@HH@2@0@Z
.text$mn:00004618 ?_Destroy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXPAU?$pair@HH@2@0@Z proc near
.text$mn:00004618                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Reallocate(uint)+CBp
.text$mn:00004618                                         ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Tidy(void)+2Bp
.text$mn:00004618
.text$mn:00004618 var_8           = dword ptr -8
.text$mn:00004618 var_1           = byte ptr -1
.text$mn:00004618 arg_0           = dword ptr  8
.text$mn:00004618 arg_4           = dword ptr  0Ch
.text$mn:00004618
.text$mn:00004618                 push    ebp
.text$mn:00004619                 mov     ebp, esp
.text$mn:0000461B                 sub     esp, 8
.text$mn:0000461E                 mov     [ebp+var_8], ecx
.text$mn:00004621                 lea     eax, [ebp+var_1]
.text$mn:00004624                 push    eax
.text$mn:00004625                 mov     ecx, [ebp+var_8]
.text$mn:00004628                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Getal(void)
.text$mn:0000462D                 lea     ecx, [ebp+var_1]
.text$mn:00004630                 push    ecx
.text$mn:00004631                 mov     edx, [ebp+arg_4]
.text$mn:00004634                 push    edx
.text$mn:00004635                 mov     eax, [ebp+arg_0]
.text$mn:00004638                 push    eax
.text$mn:00004639                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@@std@@YAXPAU?$pair@HH@0@0AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::pair<int,int>>>>(std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &)
.text$mn:0000463E                 add     esp, 0Ch
.text$mn:00004641                 mov     esp, ebp
.text$mn:00004643                 pop     ebp
.text$mn:00004644                 retn    8
.text$mn:00004644 ?_Destroy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXPAU?$pair@HH@2@0@Z endp
.text$mn:00004644
.text$mn:00004644 ; ---------------------------------------------------------------------------
.text$mn:00004647                 align 4
.text$mn:00004647 _text$mn        ends
.text$mn:00004647
.text$mn:00004648 ; ===========================================================================
.text$mn:00004648
.text$mn:00004648 ; Segment type: Pure code
.text$mn:00004648 ; Segment permissions: Read/Execute
.text$mn:00004648 _text$mn        segment para public 'CODE' use32
.text$mn:00004648                 assume cs:_text$mn
.text$mn:00004648                 ;org 4648h
.text$mn:00004648 ; COMDAT (pick any)
.text$mn:00004648                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004648
.text$mn:00004648 ; =============== S U B R O U T I N E =======================================
.text$mn:00004648
.text$mn:00004648 ; Attributes: bp-based frame
.text$mn:00004648
.text$mn:00004648 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00004648                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00004648 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00004648                                         ; CODE XREF: $LN19+60p
.text$mn:00004648                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00004648
.text$mn:00004648 var_8           = dword ptr -8
.text$mn:00004648 var_1           = byte ptr -1
.text$mn:00004648 arg_0           = dword ptr  8
.text$mn:00004648
.text$mn:00004648                 push    ebp
.text$mn:00004649                 mov     ebp, esp
.text$mn:0000464B                 sub     esp, 8
.text$mn:0000464E                 mov     [ebp+var_8], ecx
.text$mn:00004651                 mov     [ebp+var_1], 0
.text$mn:00004655                 mov     eax, [ebp+var_8]
.text$mn:00004658                 mov     ecx, [ebp+arg_0]
.text$mn:0000465B                 mov     [eax+14h], ecx
.text$mn:0000465E                 lea     edx, [ebp+var_1]
.text$mn:00004661                 push    edx
.text$mn:00004662                 mov     ecx, [ebp+var_8]
.text$mn:00004665                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000466A                 add     eax, [ebp+arg_0]
.text$mn:0000466D                 push    eax
.text$mn:0000466E                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00004673                 add     esp, 8
.text$mn:00004676                 mov     esp, ebp
.text$mn:00004678                 pop     ebp
.text$mn:00004679                 retn    4
.text$mn:00004679 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00004679
.text$mn:00004679 _text$mn        ends
.text$mn:00004679
.text$mn:0000467C ; ===========================================================================
.text$mn:0000467C
.text$mn:0000467C ; Segment type: Pure code
.text$mn:0000467C ; Segment permissions: Read/Execute
.text$mn:0000467C _text$mn        segment para public 'CODE' use32
.text$mn:0000467C                 assume cs:_text$mn
.text$mn:0000467C                 ;org 467Ch
.text$mn:0000467C ; COMDAT (pick any)
.text$mn:0000467C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000467C
.text$mn:0000467C ; =============== S U B R O U T I N E =======================================
.text$mn:0000467C
.text$mn:0000467C ; Attributes: bp-based frame
.text$mn:0000467C
.text$mn:0000467C ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:0000467C                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:0000467C ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:0000467C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:0000467C
.text$mn:0000467C var_8           = dword ptr -8
.text$mn:0000467C var_1           = byte ptr -1
.text$mn:0000467C
.text$mn:0000467C                 push    ebp
.text$mn:0000467D                 mov     ebp, esp
.text$mn:0000467F                 sub     esp, 8
.text$mn:00004682                 mov     [ebp+var_8], ecx
.text$mn:00004685                 lea     ecx, [ebp+var_1]
.text$mn:00004688                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:0000468D                 mov     ecx, [ebp+var_8] ; this
.text$mn:00004690                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00004695                 mov     eax, [ebp+var_8]
.text$mn:00004698                 mov     ecx, [eax]
.text$mn:0000469A                 push    ecx
.text$mn:0000469B                 lea     ecx, [ebp+var_1]
.text$mn:0000469E                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000046A3                 push    1               ; int
.text$mn:000046A5                 mov     edx, [ebp+var_8]
.text$mn:000046A8                 mov     eax, [edx]
.text$mn:000046AA                 push    eax             ; void *
.text$mn:000046AB                 lea     ecx, [ebp+var_1]
.text$mn:000046AE                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:000046B3                 mov     ecx, [ebp+var_8]
.text$mn:000046B6                 mov     dword ptr [ecx], 0
.text$mn:000046BC                 mov     esp, ebp
.text$mn:000046BE                 pop     ebp
.text$mn:000046BF                 retn
.text$mn:000046BF ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000046BF
.text$mn:000046BF _text$mn        ends
.text$mn:000046BF
.text$mn:000046C0 ; ===========================================================================
.text$mn:000046C0
.text$mn:000046C0 ; Segment type: Pure code
.text$mn:000046C0 ; Segment permissions: Read/Execute
.text$mn:000046C0 _text$mn        segment para public 'CODE' use32
.text$mn:000046C0                 assume cs:_text$mn
.text$mn:000046C0                 ;org 46C0h
.text$mn:000046C0 ; COMDAT (pick any)
.text$mn:000046C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000046C0
.text$mn:000046C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000046C0
.text$mn:000046C0 ; Attributes: bp-based frame
.text$mn:000046C0
.text$mn:000046C0 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>>::_Free_proxy(void)
.text$mn:000046C0                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAEXXZ
.text$mn:000046C0 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAEXXZ proc near
.text$mn:000046C0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::~_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>(void)+30p
.text$mn:000046C0
.text$mn:000046C0 var_8           = dword ptr -8
.text$mn:000046C0 var_1           = byte ptr -1
.text$mn:000046C0
.text$mn:000046C0                 push    ebp
.text$mn:000046C1                 mov     ebp, esp
.text$mn:000046C3                 sub     esp, 8
.text$mn:000046C6                 mov     [ebp+var_8], ecx
.text$mn:000046C9                 lea     ecx, [ebp+var_1]
.text$mn:000046CC                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:000046D1                 mov     ecx, [ebp+var_8] ; this
.text$mn:000046D4                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000046D9                 mov     eax, [ebp+var_8]
.text$mn:000046DC                 mov     ecx, [eax]
.text$mn:000046DE                 push    ecx
.text$mn:000046DF                 lea     ecx, [ebp+var_1]
.text$mn:000046E2                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000046E7                 push    1               ; int
.text$mn:000046E9                 mov     edx, [ebp+var_8]
.text$mn:000046EC                 mov     eax, [edx]
.text$mn:000046EE                 push    eax             ; void *
.text$mn:000046EF                 lea     ecx, [ebp+var_1]
.text$mn:000046F2                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:000046F7                 mov     ecx, [ebp+var_8]
.text$mn:000046FA                 mov     dword ptr [ecx], 0
.text$mn:00004700                 mov     esp, ebp
.text$mn:00004702                 pop     ebp
.text$mn:00004703                 retn
.text$mn:00004703 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAEXXZ endp
.text$mn:00004703
.text$mn:00004703 _text$mn        ends
.text$mn:00004703
.text$mn:00004704 ; ===========================================================================
.text$mn:00004704
.text$mn:00004704 ; Segment type: Pure code
.text$mn:00004704 ; Segment permissions: Read/Execute
.text$mn:00004704 _text$mn        segment para public 'CODE' use32
.text$mn:00004704                 assume cs:_text$mn
.text$mn:00004704                 ;org 4704h
.text$mn:00004704 ; COMDAT (pick any)
.text$mn:00004704                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004704
.text$mn:00004704 ; =============== S U B R O U T I N E =======================================
.text$mn:00004704
.text$mn:00004704 ; Attributes: bp-based frame
.text$mn:00004704
.text$mn:00004704 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00004704                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00004704 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00004704                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00004704                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00004704
.text$mn:00004704 var_4           = dword ptr -4
.text$mn:00004704 arg_0           = dword ptr  8
.text$mn:00004704
.text$mn:00004704                 push    ebp
.text$mn:00004705                 mov     ebp, esp
.text$mn:00004707                 push    ecx
.text$mn:00004708                 mov     [ebp+var_4], ecx
.text$mn:0000470B                 mov     ecx, [ebp+arg_0]
.text$mn:0000470E                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00004713                 mov     eax, [ebp+arg_0]
.text$mn:00004716                 mov     esp, ebp
.text$mn:00004718                 pop     ebp
.text$mn:00004719                 retn    4
.text$mn:00004719 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00004719
.text$mn:00004719 _text$mn        ends
.text$mn:00004719
.text$mn:0000471C ; ===========================================================================
.text$mn:0000471C
.text$mn:0000471C ; Segment type: Pure code
.text$mn:0000471C ; Segment permissions: Read/Execute
.text$mn:0000471C _text$mn        segment para public 'CODE' use32
.text$mn:0000471C                 assume cs:_text$mn
.text$mn:0000471C                 ;org 471Ch
.text$mn:0000471C ; COMDAT (pick any)
.text$mn:0000471C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000471C
.text$mn:0000471C ; =============== S U B R O U T I N E =======================================
.text$mn:0000471C
.text$mn:0000471C ; Attributes: bp-based frame
.text$mn:0000471C
.text$mn:0000471C ; public: struct std::_Wrap_alloc<class std::allocator<struct std::pair<int, int>>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>>::_Getal(void)const
.text$mn:0000471C                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@2@XZ
.text$mn:0000471C ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@2@XZ proc near
.text$mn:0000471C                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Umove<std::pair<int,int> *>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *)+10p
.text$mn:0000471C                                         ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>(std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>> &&)+2Fp ...
.text$mn:0000471C
.text$mn:0000471C var_4           = dword ptr -4
.text$mn:0000471C arg_0           = dword ptr  8
.text$mn:0000471C
.text$mn:0000471C                 push    ebp
.text$mn:0000471D                 mov     ebp, esp
.text$mn:0000471F                 push    ecx
.text$mn:00004720                 mov     [ebp+var_4], ecx
.text$mn:00004723                 mov     ecx, [ebp+arg_0]
.text$mn:00004726                 call    ??0?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::pair<int,int>>>::_Wrap_alloc<std::allocator<std::pair<int,int>>>(void)
.text$mn:0000472B                 mov     eax, [ebp+arg_0]
.text$mn:0000472E                 mov     esp, ebp
.text$mn:00004730                 pop     ebp
.text$mn:00004731                 retn    4
.text$mn:00004731 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@2@XZ endp
.text$mn:00004731
.text$mn:00004731 _text$mn        ends
.text$mn:00004731
.text$mn:00004734 ; ===========================================================================
.text$mn:00004734
.text$mn:00004734 ; Segment type: Pure code
.text$mn:00004734 ; Segment permissions: Read/Execute
.text$mn:00004734 _text$mn        segment para public 'CODE' use32
.text$mn:00004734                 assume cs:_text$mn
.text$mn:00004734                 ;org 4734h
.text$mn:00004734 ; COMDAT (pick any)
.text$mn:00004734                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004734
.text$mn:00004734 ; =============== S U B R O U T I N E =======================================
.text$mn:00004734
.text$mn:00004734 ; Attributes: bp-based frame
.text$mn:00004734
.text$mn:00004734 ; const struct std::_Container_base12 *__thiscall std::_Iterator_base12::_Getcont(std::_Iterator_base12 *__hidden this)
.text$mn:00004734                 public ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
.text$mn:00004734 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ proc near
.text$mn:00004734                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int)+Bp
.text$mn:00004734                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int)+29p ...
.text$mn:00004734
.text$mn:00004734 var_8           = dword ptr -8
.text$mn:00004734 var_4           = dword ptr -4
.text$mn:00004734
.text$mn:00004734                 push    ebp
.text$mn:00004735                 mov     ebp, esp
.text$mn:00004737                 sub     esp, 8
.text$mn:0000473A                 mov     [ebp+var_4], ecx
.text$mn:0000473D                 mov     eax, [ebp+var_4]
.text$mn:00004740                 cmp     dword ptr [eax], 0
.text$mn:00004743                 jnz     short loc_474E
.text$mn:00004745                 mov     [ebp+var_8], 0
.text$mn:0000474C                 jmp     short loc_4758
.text$mn:0000474E ; ---------------------------------------------------------------------------
.text$mn:0000474E
.text$mn:0000474E loc_474E:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+Fj
.text$mn:0000474E                 mov     ecx, [ebp+var_4]
.text$mn:00004751                 mov     edx, [ecx]
.text$mn:00004753                 mov     eax, [edx]
.text$mn:00004755                 mov     [ebp+var_8], eax
.text$mn:00004758
.text$mn:00004758 loc_4758:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+18j
.text$mn:00004758                 mov     eax, [ebp+var_8]
.text$mn:0000475B                 mov     esp, ebp
.text$mn:0000475D                 pop     ebp
.text$mn:0000475E                 retn
.text$mn:0000475E ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ endp
.text$mn:0000475E
.text$mn:0000475E ; ---------------------------------------------------------------------------
.text$mn:0000475F                 align 10h
.text$mn:0000475F _text$mn        ends
.text$mn:0000475F
.text$mn:00004760 ; ===========================================================================
.text$mn:00004760
.text$mn:00004760 ; Segment type: Pure code
.text$mn:00004760 ; Segment permissions: Read/Execute
.text$mn:00004760 _text$mn        segment para public 'CODE' use32
.text$mn:00004760                 assume cs:_text$mn
.text$mn:00004760                 ;org 4760h
.text$mn:00004760 ; COMDAT (pick any)
.text$mn:00004760                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004760
.text$mn:00004760 ; =============== S U B R O U T I N E =======================================
.text$mn:00004760
.text$mn:00004760 ; Attributes: bp-based frame
.text$mn:00004760
.text$mn:00004760 ; struct std::_Iterator_base12 **__thiscall std::_Container_base12::_Getpfirst(std::_Container_base12 *__hidden this)
.text$mn:00004760                 public ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
.text$mn:00004760 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ proc near
.text$mn:00004760                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Orphan_range(std::pair<int,int> *,std::pair<int,int> *)+3Cp
.text$mn:00004760
.text$mn:00004760 var_8           = dword ptr -8
.text$mn:00004760 var_4           = dword ptr -4
.text$mn:00004760
.text$mn:00004760                 push    ebp
.text$mn:00004761                 mov     ebp, esp
.text$mn:00004763                 sub     esp, 8
.text$mn:00004766                 mov     [ebp+var_4], ecx
.text$mn:00004769                 mov     eax, [ebp+var_4]
.text$mn:0000476C                 cmp     dword ptr [eax], 0
.text$mn:0000476F                 jnz     short loc_477A
.text$mn:00004771                 mov     [ebp+var_8], 0
.text$mn:00004778                 jmp     short loc_4785
.text$mn:0000477A ; ---------------------------------------------------------------------------
.text$mn:0000477A
.text$mn:0000477A loc_477A:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+Fj
.text$mn:0000477A                 mov     ecx, [ebp+var_4]
.text$mn:0000477D                 mov     edx, [ecx]
.text$mn:0000477F                 add     edx, 4
.text$mn:00004782                 mov     [ebp+var_8], edx
.text$mn:00004785
.text$mn:00004785 loc_4785:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+18j
.text$mn:00004785                 mov     eax, [ebp+var_8]
.text$mn:00004788                 mov     esp, ebp
.text$mn:0000478A                 pop     ebp
.text$mn:0000478B                 retn
.text$mn:0000478B ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ endp
.text$mn:0000478B
.text$mn:0000478B _text$mn        ends
.text$mn:0000478B
.text$mn:0000478C ; ===========================================================================
.text$mn:0000478C
.text$mn:0000478C ; Segment type: Pure code
.text$mn:0000478C ; Segment permissions: Read/Execute
.text$mn:0000478C _text$mn        segment para public 'CODE' use32
.text$mn:0000478C                 assume cs:_text$mn
.text$mn:0000478C                 ;org 478Ch
.text$mn:0000478C ; COMDAT (pick any)
.text$mn:0000478C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000478C
.text$mn:0000478C ; =============== S U B R O U T I N E =======================================
.text$mn:0000478C
.text$mn:0000478C ; Attributes: bp-based frame
.text$mn:0000478C
.text$mn:0000478C ; struct std::_Iterator_base12 **__thiscall std::_Iterator_base12::_Getpnext(std::_Iterator_base12 *__hidden this)
.text$mn:0000478C                 public ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
.text$mn:0000478C ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ proc near
.text$mn:0000478C                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Orphan_range(std::pair<int,int> *,std::pair<int,int> *)+71p
.text$mn:0000478C                                         ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Orphan_range(std::pair<int,int> *,std::pair<int,int> *)+8Ap
.text$mn:0000478C
.text$mn:0000478C var_4           = dword ptr -4
.text$mn:0000478C
.text$mn:0000478C                 push    ebp
.text$mn:0000478D                 mov     ebp, esp
.text$mn:0000478F                 push    ecx
.text$mn:00004790                 mov     [ebp+var_4], ecx
.text$mn:00004793                 mov     eax, [ebp+var_4]
.text$mn:00004796                 add     eax, 4
.text$mn:00004799                 mov     esp, ebp
.text$mn:0000479B                 pop     ebp
.text$mn:0000479C                 retn
.text$mn:0000479C ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ endp
.text$mn:0000479C
.text$mn:0000479C ; ---------------------------------------------------------------------------
.text$mn:0000479D                 align 10h
.text$mn:0000479D _text$mn        ends
.text$mn:0000479D
.text$mn:000047A0 ; ===========================================================================
.text$mn:000047A0
.text$mn:000047A0 ; Segment type: Pure code
.text$mn:000047A0 ; Segment permissions: Read/Execute
.text$mn:000047A0 _text$mn        segment para public 'CODE' use32
.text$mn:000047A0                 assume cs:_text$mn
.text$mn:000047A0                 ;org 47A0h
.text$mn:000047A0 ; COMDAT (pick any)
.text$mn:000047A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000047A0
.text$mn:000047A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000047A0
.text$mn:000047A0 ; Attributes: bp-based frame
.text$mn:000047A0
.text$mn:000047A0 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:000047A0                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:000047A0 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:000047A0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Dp
.text$mn:000047A0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap ...
.text$mn:000047A0
.text$mn:000047A0 var_C           = dword ptr -0Ch
.text$mn:000047A0 Size            = dword ptr -8
.text$mn:000047A0 var_4           = dword ptr -4
.text$mn:000047A0 arg_0           = dword ptr  8
.text$mn:000047A0 arg_4           = byte ptr  0Ch
.text$mn:000047A0
.text$mn:000047A0                 push    ebp
.text$mn:000047A1                 mov     ebp, esp
.text$mn:000047A3                 sub     esp, 0Ch
.text$mn:000047A6                 mov     [ebp+var_4], ecx
.text$mn:000047A9                 mov     ecx, [ebp+var_4]
.text$mn:000047AC                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000047B1                 cmp     eax, [ebp+arg_0]
.text$mn:000047B4                 jnb     short loc_47BE
.text$mn:000047B6                 mov     ecx, [ebp+var_4]
.text$mn:000047B9                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:000047BE
.text$mn:000047BE loc_47BE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:000047BE                 mov     eax, [ebp+var_4]
.text$mn:000047C1                 mov     ecx, [eax+18h]
.text$mn:000047C4                 cmp     ecx, [ebp+arg_0]
.text$mn:000047C7                 jnb     short loc_47DE
.text$mn:000047C9                 mov     edx, [ebp+var_4]
.text$mn:000047CC                 mov     eax, [edx+14h]
.text$mn:000047CF                 push    eax
.text$mn:000047D0                 mov     ecx, [ebp+arg_0]
.text$mn:000047D3                 push    ecx
.text$mn:000047D4                 mov     ecx, [ebp+var_4]
.text$mn:000047D7                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:000047DC                 jmp     short loc_4828
.text$mn:000047DE ; ---------------------------------------------------------------------------
.text$mn:000047DE
.text$mn:000047DE loc_47DE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:000047DE                 movzx   edx, [ebp+arg_4]
.text$mn:000047E2                 test    edx, edx
.text$mn:000047E4                 jz      short loc_4818
.text$mn:000047E6                 cmp     [ebp+arg_0], 10h
.text$mn:000047EA                 jnb     short loc_4818
.text$mn:000047EC                 mov     eax, [ebp+var_4]
.text$mn:000047EF                 mov     ecx, [ebp+arg_0]
.text$mn:000047F2                 cmp     ecx, [eax+14h]
.text$mn:000047F5                 jnb     short loc_47FF
.text$mn:000047F7                 mov     edx, [ebp+arg_0]
.text$mn:000047FA                 mov     [ebp+Size], edx
.text$mn:000047FD                 jmp     short loc_4808
.text$mn:000047FF ; ---------------------------------------------------------------------------
.text$mn:000047FF
.text$mn:000047FF loc_47FF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:000047FF                 mov     eax, [ebp+var_4]
.text$mn:00004802                 mov     ecx, [eax+14h]
.text$mn:00004805                 mov     [ebp+Size], ecx
.text$mn:00004808
.text$mn:00004808 loc_4808:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00004808                 mov     edx, [ebp+Size]
.text$mn:0000480B                 push    edx             ; Size
.text$mn:0000480C                 push    1               ; char
.text$mn:0000480E                 mov     ecx, [ebp+var_4]
.text$mn:00004811                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00004816                 jmp     short loc_4828
.text$mn:00004818 ; ---------------------------------------------------------------------------
.text$mn:00004818
.text$mn:00004818 loc_4818:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00004818                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00004818                 cmp     [ebp+arg_0], 0
.text$mn:0000481C                 jnz     short loc_4828
.text$mn:0000481E                 push    0
.text$mn:00004820                 mov     ecx, [ebp+var_4]
.text$mn:00004823                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00004828
.text$mn:00004828 loc_4828:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00004828                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00004828                 cmp     [ebp+arg_0], 0
.text$mn:0000482C                 jbe     short loc_4837
.text$mn:0000482E                 mov     [ebp+var_C], 1
.text$mn:00004835                 jmp     short loc_483E
.text$mn:00004837 ; ---------------------------------------------------------------------------
.text$mn:00004837
.text$mn:00004837 loc_4837:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00004837                 mov     [ebp+var_C], 0
.text$mn:0000483E
.text$mn:0000483E loc_483E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:0000483E                 mov     al, byte ptr [ebp+var_C]
.text$mn:00004841                 mov     esp, ebp
.text$mn:00004843                 pop     ebp
.text$mn:00004844                 retn    8
.text$mn:00004844 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00004844
.text$mn:00004844 ; ---------------------------------------------------------------------------
.text$mn:00004847                 align 4
.text$mn:00004847 _text$mn        ends
.text$mn:00004847
.text$mn:00004848 ; ===========================================================================
.text$mn:00004848
.text$mn:00004848 ; Segment type: Pure code
.text$mn:00004848 ; Segment permissions: Read/Execute
.text$mn:00004848 _text$mn        segment para public 'CODE' use32
.text$mn:00004848                 assume cs:_text$mn
.text$mn:00004848                 ;org 4848h
.text$mn:00004848 ; COMDAT (pick any)
.text$mn:00004848                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004848
.text$mn:00004848 ; =============== S U B R O U T I N E =======================================
.text$mn:00004848
.text$mn:00004848 ; Attributes: bp-based frame
.text$mn:00004848
.text$mn:00004848 ; protected: unsigned int __thiscall std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>::_Grow_to(unsigned int)const
.text$mn:00004848                 public ?_Grow_to@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEII@Z
.text$mn:00004848 ?_Grow_to@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEII@Z proc near
.text$mn:00004848                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Reserve(uint)+45p
.text$mn:00004848
.text$mn:00004848 var_C           = dword ptr -0Ch
.text$mn:00004848 var_8           = dword ptr -8
.text$mn:00004848 var_4           = dword ptr -4
.text$mn:00004848 arg_0           = dword ptr  8
.text$mn:00004848
.text$mn:00004848                 push    ebp
.text$mn:00004849                 mov     ebp, esp
.text$mn:0000484B                 sub     esp, 0Ch
.text$mn:0000484E                 mov     [ebp+var_8], ecx
.text$mn:00004851                 mov     ecx, [ebp+var_8]
.text$mn:00004854                 call    ?capacity@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::capacity(void)
.text$mn:00004859                 mov     [ebp+var_4], eax
.text$mn:0000485C                 mov     ecx, [ebp+var_8]
.text$mn:0000485F                 call    ?max_size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::max_size(void)
.text$mn:00004864                 mov     ecx, [ebp+var_4]
.text$mn:00004867                 shr     ecx, 1
.text$mn:00004869                 sub     eax, ecx
.text$mn:0000486B                 cmp     eax, [ebp+var_4]
.text$mn:0000486E                 jnb     short loc_4879
.text$mn:00004870                 mov     [ebp+var_C], 0
.text$mn:00004877                 jmp     short loc_4884
.text$mn:00004879 ; ---------------------------------------------------------------------------
.text$mn:00004879
.text$mn:00004879 loc_4879:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Grow_to(uint)+26j
.text$mn:00004879                 mov     edx, [ebp+var_4]
.text$mn:0000487C                 shr     edx, 1
.text$mn:0000487E                 add     edx, [ebp+var_4]
.text$mn:00004881                 mov     [ebp+var_C], edx
.text$mn:00004884
.text$mn:00004884 loc_4884:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Grow_to(uint)+2Fj
.text$mn:00004884                 mov     eax, [ebp+var_C]
.text$mn:00004887                 mov     [ebp+var_4], eax
.text$mn:0000488A                 mov     ecx, [ebp+var_4]
.text$mn:0000488D                 cmp     ecx, [ebp+arg_0]
.text$mn:00004890                 jnb     short loc_4898
.text$mn:00004892                 mov     edx, [ebp+arg_0]
.text$mn:00004895                 mov     [ebp+var_4], edx
.text$mn:00004898
.text$mn:00004898 loc_4898:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Grow_to(uint)+48j
.text$mn:00004898                 mov     eax, [ebp+var_4]
.text$mn:0000489B                 mov     esp, ebp
.text$mn:0000489D                 pop     ebp
.text$mn:0000489E                 retn    4
.text$mn:0000489E ?_Grow_to@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEII@Z endp
.text$mn:0000489E
.text$mn:0000489E ; ---------------------------------------------------------------------------
.text$mn:000048A1                 align 4
.text$mn:000048A1 _text$mn        ends
.text$mn:000048A1
.text$mn:000048A4 ; ===========================================================================
.text$mn:000048A4
.text$mn:000048A4 ; Segment type: Pure code
.text$mn:000048A4 ; Segment permissions: Read/Execute
.text$mn:000048A4 _text$mn        segment para public 'CODE' use32
.text$mn:000048A4                 assume cs:_text$mn
.text$mn:000048A4                 ;org 48A4h
.text$mn:000048A4 ; COMDAT (pick any)
.text$mn:000048A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000048A4
.text$mn:000048A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000048A4
.text$mn:000048A4 ; Attributes: bp-based frame
.text$mn:000048A4
.text$mn:000048A4 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:000048A4                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:000048A4 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:000048A4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:000048A4
.text$mn:000048A4 var_4           = dword ptr -4
.text$mn:000048A4 arg_0           = dword ptr  8
.text$mn:000048A4
.text$mn:000048A4                 push    ebp
.text$mn:000048A5                 mov     ebp, esp
.text$mn:000048A7                 push    ecx
.text$mn:000048A8                 mov     [ebp+var_4], ecx
.text$mn:000048AB                 cmp     [ebp+arg_0], 0
.text$mn:000048AF                 jz      short loc_48D1
.text$mn:000048B1                 mov     ecx, [ebp+var_4]
.text$mn:000048B4                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000048B9                 cmp     [ebp+arg_0], eax
.text$mn:000048BC                 jb      short loc_48D1
.text$mn:000048BE                 mov     ecx, [ebp+var_4]
.text$mn:000048C1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000048C6                 mov     ecx, [ebp+var_4]
.text$mn:000048C9                 add     eax, [ecx+14h]
.text$mn:000048CC                 cmp     eax, [ebp+arg_0]
.text$mn:000048CF                 ja      short loc_48D7
.text$mn:000048D1
.text$mn:000048D1 loc_48D1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:000048D1                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:000048D1                 xor     al, al
.text$mn:000048D3                 jmp     short loc_48D9
.text$mn:000048D5 ; ---------------------------------------------------------------------------
.text$mn:000048D5                 jmp     short loc_48D9
.text$mn:000048D7 ; ---------------------------------------------------------------------------
.text$mn:000048D7
.text$mn:000048D7 loc_48D7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:000048D7                 mov     al, 1
.text$mn:000048D9
.text$mn:000048D9 loc_48D9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:000048D9                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:000048D9                 mov     esp, ebp
.text$mn:000048DB                 pop     ebp
.text$mn:000048DC                 retn    4
.text$mn:000048DC ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:000048DC
.text$mn:000048DC ; ---------------------------------------------------------------------------
.text$mn:000048DF                 align 10h
.text$mn:000048DF _text$mn        ends
.text$mn:000048DF
.text$mn:000048E0 ; ===========================================================================
.text$mn:000048E0
.text$mn:000048E0 ; Segment type: Pure code
.text$mn:000048E0 ; Segment permissions: Read/Execute
.text$mn:000048E0 _text$mn        segment para public 'CODE' use32
.text$mn:000048E0                 assume cs:_text$mn
.text$mn:000048E0                 ;org 48E0h
.text$mn:000048E0 ; COMDAT (pick any)
.text$mn:000048E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000048E0
.text$mn:000048E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000048E0
.text$mn:000048E0 ; Attributes: bp-based frame
.text$mn:000048E0
.text$mn:000048E0 ; protected: bool __thiscall std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>::_Inside(struct std::pair<int, int> const *)const
.text$mn:000048E0                 public ?_Inside@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBE_NPBU?$pair@HH@2@@Z
.text$mn:000048E0 ?_Inside@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBE_NPBU?$pair@HH@2@@Z proc near
.text$mn:000048E0                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::push_back(std::pair<int,int> &&)+19p
.text$mn:000048E0
.text$mn:000048E0 var_8           = dword ptr -8
.text$mn:000048E0 var_4           = dword ptr -4
.text$mn:000048E0 arg_0           = dword ptr  8
.text$mn:000048E0
.text$mn:000048E0                 push    ebp
.text$mn:000048E1                 mov     ebp, esp
.text$mn:000048E3                 sub     esp, 8
.text$mn:000048E6                 mov     [ebp+var_4], ecx
.text$mn:000048E9                 mov     eax, [ebp+var_4]
.text$mn:000048EC                 mov     ecx, [ebp+arg_0]
.text$mn:000048EF                 cmp     ecx, [eax+8]
.text$mn:000048F2                 jnb     short loc_4908
.text$mn:000048F4                 mov     edx, [ebp+var_4]
.text$mn:000048F7                 mov     eax, [edx+4]
.text$mn:000048FA                 cmp     eax, [ebp+arg_0]
.text$mn:000048FD                 ja      short loc_4908
.text$mn:000048FF                 mov     [ebp+var_8], 1
.text$mn:00004906                 jmp     short loc_490F
.text$mn:00004908 ; ---------------------------------------------------------------------------
.text$mn:00004908
.text$mn:00004908 loc_4908:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Inside(std::pair<int,int> const *)+12j
.text$mn:00004908                                         ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Inside(std::pair<int,int> const *)+1Dj
.text$mn:00004908                 mov     [ebp+var_8], 0
.text$mn:0000490F
.text$mn:0000490F loc_490F:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Inside(std::pair<int,int> const *)+26j
.text$mn:0000490F                 mov     al, byte ptr [ebp+var_8]
.text$mn:00004912                 mov     esp, ebp
.text$mn:00004914                 pop     ebp
.text$mn:00004915                 retn    4
.text$mn:00004915 ?_Inside@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBE_NPBU?$pair@HH@2@@Z endp
.text$mn:00004915
.text$mn:00004915 _text$mn        ends
.text$mn:00004915
.text$mn:00004918 ; ===========================================================================
.text$mn:00004918
.text$mn:00004918 ; Segment type: Pure code
.text$mn:00004918 ; Segment permissions: Read/Execute
.text$mn:00004918 _text$mn        segment para public 'CODE' use32
.text$mn:00004918                 assume cs:_text$mn
.text$mn:00004918                 ;org 4918h
.text$mn:00004918 ; COMDAT (pick any)
.text$mn:00004918                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004918
.text$mn:00004918 ; =============== S U B R O U T I N E =======================================
.text$mn:00004918
.text$mn:00004918 ; Attributes: bp-based frame
.text$mn:00004918
.text$mn:00004918 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00004918                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00004918 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00004918                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int)+30p
.text$mn:00004918                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int)+43p ...
.text$mn:00004918
.text$mn:00004918 var_8           = dword ptr -8
.text$mn:00004918 var_4           = dword ptr -4
.text$mn:00004918
.text$mn:00004918                 push    ebp
.text$mn:00004919                 mov     ebp, esp
.text$mn:0000491B                 sub     esp, 8
.text$mn:0000491E                 mov     [ebp+var_4], ecx
.text$mn:00004921                 mov     eax, [ebp+var_4]
.text$mn:00004924                 cmp     dword ptr [eax+18h], 10h
.text$mn:00004928                 jb      short loc_493E
.text$mn:0000492A                 mov     ecx, [ebp+var_4]
.text$mn:0000492D                 mov     edx, [ecx+4]
.text$mn:00004930                 push    edx
.text$mn:00004931                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00004936                 add     esp, 4
.text$mn:00004939                 mov     [ebp+var_8], eax
.text$mn:0000493C                 jmp     short loc_4947
.text$mn:0000493E ; ---------------------------------------------------------------------------
.text$mn:0000493E
.text$mn:0000493E loc_493E:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000493E                 mov     eax, [ebp+var_4]
.text$mn:00004941                 add     eax, 4
.text$mn:00004944                 mov     [ebp+var_8], eax
.text$mn:00004947
.text$mn:00004947 loc_4947:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00004947                 mov     eax, [ebp+var_8]
.text$mn:0000494A                 mov     esp, ebp
.text$mn:0000494C                 pop     ebp
.text$mn:0000494D                 retn
.text$mn:0000494D ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:0000494D
.text$mn:0000494D ; ---------------------------------------------------------------------------
.text$mn:0000494E                 align 10h
.text$mn:0000494E _text$mn        ends
.text$mn:0000494E
.text$mn:00004950 ; ===========================================================================
.text$mn:00004950
.text$mn:00004950 ; Segment type: Pure code
.text$mn:00004950 ; Segment permissions: Read/Execute
.text$mn:00004950 _text$mn        segment para public 'CODE' use32
.text$mn:00004950                 assume cs:_text$mn
.text$mn:00004950                 ;org 4950h
.text$mn:00004950 ; COMDAT (pick any)
.text$mn:00004950                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004950
.text$mn:00004950 ; =============== S U B R O U T I N E =======================================
.text$mn:00004950
.text$mn:00004950 ; Attributes: bp-based frame
.text$mn:00004950
.text$mn:00004950 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00004950                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00004950 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00004950                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+80p
.text$mn:00004950                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp ...
.text$mn:00004950
.text$mn:00004950 var_8           = dword ptr -8
.text$mn:00004950 var_4           = dword ptr -4
.text$mn:00004950
.text$mn:00004950                 push    ebp
.text$mn:00004951                 mov     ebp, esp
.text$mn:00004953                 sub     esp, 8
.text$mn:00004956                 mov     [ebp+var_4], ecx
.text$mn:00004959                 mov     eax, [ebp+var_4]
.text$mn:0000495C                 cmp     dword ptr [eax+18h], 10h
.text$mn:00004960                 jb      short loc_4976
.text$mn:00004962                 mov     ecx, [ebp+var_4]
.text$mn:00004965                 mov     edx, [ecx+4]
.text$mn:00004968                 push    edx
.text$mn:00004969                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000496E                 add     esp, 4
.text$mn:00004971                 mov     [ebp+var_8], eax
.text$mn:00004974                 jmp     short loc_497F
.text$mn:00004976 ; ---------------------------------------------------------------------------
.text$mn:00004976
.text$mn:00004976 loc_4976:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00004976                 mov     eax, [ebp+var_4]
.text$mn:00004979                 add     eax, 4
.text$mn:0000497C                 mov     [ebp+var_8], eax
.text$mn:0000497F
.text$mn:0000497F loc_497F:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000497F                 mov     eax, [ebp+var_8]
.text$mn:00004982                 mov     esp, ebp
.text$mn:00004984                 pop     ebp
.text$mn:00004985                 retn
.text$mn:00004985 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00004985
.text$mn:00004985 ; ---------------------------------------------------------------------------
.text$mn:00004986                 align 4
.text$mn:00004986 _text$mn        ends
.text$mn:00004986
.text$mn:00004988 ; ===========================================================================
.text$mn:00004988
.text$mn:00004988 ; Segment type: Pure code
.text$mn:00004988 ; Segment permissions: Read/Execute
.text$mn:00004988 _text$mn        segment para public 'CODE' use32
.text$mn:00004988                 assume cs:_text$mn
.text$mn:00004988                 ;org 4988h
.text$mn:00004988 ; COMDAT (pick any)
.text$mn:00004988                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004988
.text$mn:00004988 ; =============== S U B R O U T I N E =======================================
.text$mn:00004988
.text$mn:00004988 ; Attributes: bp-based frame
.text$mn:00004988
.text$mn:00004988 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00004988                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00004988 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00004988                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00004988                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p ...
.text$mn:00004988
.text$mn:00004988 var_18          = byte ptr -18h
.text$mn:00004988 var_14          = dword ptr -14h
.text$mn:00004988 var_10          = dword ptr -10h
.text$mn:00004988 var_C           = dword ptr -0Ch
.text$mn:00004988 var_4           = dword ptr -4
.text$mn:00004988
.text$mn:00004988                 push    ebp
.text$mn:00004989                 mov     ebp, esp
.text$mn:0000498B                 push    0FFFFFFFFh
.text$mn:0000498D                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00004992                 mov     eax, large fs:0
.text$mn:00004998                 push    eax
.text$mn:00004999                 sub     esp, 0Ch
.text$mn:0000499C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000049A1                 xor     eax, ebp
.text$mn:000049A3                 push    eax
.text$mn:000049A4                 lea     eax, [ebp+var_C]
.text$mn:000049A7                 mov     large fs:0, eax
.text$mn:000049AD                 mov     [ebp+var_14], ecx
.text$mn:000049B0                 mov     eax, [ebp+var_14]
.text$mn:000049B3                 cmp     dword ptr [eax], 0
.text$mn:000049B6                 jz      short loc_4A13
.text$mn:000049B8                 push    3               ; int
.text$mn:000049BA                 lea     ecx, [ebp+var_18] ; this
.text$mn:000049BD                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000049C2                 mov     [ebp+var_4], 0
.text$mn:000049C9                 mov     ecx, [ebp+var_14]
.text$mn:000049CC                 mov     edx, [ecx]
.text$mn:000049CE                 add     edx, 4
.text$mn:000049D1                 mov     [ebp+var_10], edx
.text$mn:000049D4                 jmp     short loc_49E3
.text$mn:000049D6 ; ---------------------------------------------------------------------------
.text$mn:000049D6
.text$mn:000049D6 loc_49D6:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:000049D6                 mov     eax, [ebp+var_10]
.text$mn:000049D9                 mov     ecx, [eax]
.text$mn:000049DB                 mov     edx, [ebp+var_10]
.text$mn:000049DE                 mov     eax, [ecx+4]
.text$mn:000049E1                 mov     [edx], eax
.text$mn:000049E3
.text$mn:000049E3 loc_49E3:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:000049E3                 mov     ecx, [ebp+var_10]
.text$mn:000049E6                 cmp     dword ptr [ecx], 0
.text$mn:000049E9                 jz      short loc_49F8
.text$mn:000049EB                 mov     edx, [ebp+var_10]
.text$mn:000049EE                 mov     eax, [edx]
.text$mn:000049F0                 mov     dword ptr [eax], 0
.text$mn:000049F6                 jmp     short loc_49D6
.text$mn:000049F8 ; ---------------------------------------------------------------------------
.text$mn:000049F8
.text$mn:000049F8 loc_49F8:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:000049F8                 mov     ecx, [ebp+var_14]
.text$mn:000049FB                 mov     edx, [ecx]
.text$mn:000049FD                 mov     dword ptr [edx+4], 0
.text$mn:00004A04                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004A0B                 lea     ecx, [ebp+var_18] ; this
.text$mn:00004A0E                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00004A13
.text$mn:00004A13 loc_4A13:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00004A13                 mov     ecx, [ebp+var_C]
.text$mn:00004A16                 mov     large fs:0, ecx
.text$mn:00004A1D                 pop     ecx
.text$mn:00004A1E                 mov     esp, ebp
.text$mn:00004A20                 pop     ebp
.text$mn:00004A21                 retn
.text$mn:00004A21 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00004A21
.text$mn:00004A21 ; ---------------------------------------------------------------------------
.text$mn:00004A22                 align 4
.text$mn:00004A22 _text$mn        ends
.text$mn:00004A22
.text$x:00004A24 ; ===========================================================================
.text$x:00004A24
.text$x:00004A24 ; Segment type: Pure code
.text$x:00004A24 ; Segment permissions: Read/Execute
.text$x:00004A24 _text$x         segment para public 'CODE' use32
.text$x:00004A24                 assume cs:_text$x
.text$x:00004A24                 ;org 4A24h
.text$x:00004A24 ; COMDAT (pick associative to section at 4988)
.text$x:00004A24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004A24
.text$x:00004A24 ; =============== S U B R O U T I N E =======================================
.text$x:00004A24
.text$x:00004A24
.text$x:00004A24 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00004A24                                         ; DATA XREF: .xdata$x:000060FCo
.text$x:00004A24                 lea     ecx, [ebp-18h]  ; this
.text$x:00004A27                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00004A27 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:00004A27
.text$x:00004A2C
.text$x:00004A2C ; =============== S U B R O U T I N E =======================================
.text$x:00004A2C
.text$x:00004A2C
.text$x:00004A2C __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00004A2C                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00004A2C
.text$x:00004A2C arg_4           = dword ptr  8
.text$x:00004A2C
.text$x:00004A2C                 mov     edx, [esp+arg_4]
.text$x:00004A30                 lea     eax, [edx+0Ch]
.text$x:00004A33                 mov     ecx, [edx-10h]
.text$x:00004A36                 xor     ecx, eax
.text$x:00004A38                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004A3D                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00004A42                 jmp     ___CxxFrameHandler3
.text$x:00004A42 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00004A42
.text$x:00004A42 ; ---------------------------------------------------------------------------
.text$x:00004A47                 align 4
.text$x:00004A47 _text$x         ends
.text$x:00004A47
.text$mn:00004A48 ; ===========================================================================
.text$mn:00004A48
.text$mn:00004A48 ; Segment type: Pure code
.text$mn:00004A48 ; Segment permissions: Read/Execute
.text$mn:00004A48 _text$mn        segment para public 'CODE' use32
.text$mn:00004A48                 assume cs:_text$mn
.text$mn:00004A48                 ;org 4A48h
.text$mn:00004A48 ; COMDAT (pick any)
.text$mn:00004A48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004A48
.text$mn:00004A48 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A48
.text$mn:00004A48 ; Attributes: bp-based frame
.text$mn:00004A48
.text$mn:00004A48 ; void __thiscall std::_Iterator_base12::_Orphan_me(std::_Iterator_base12 *__hidden this)
.text$mn:00004A48                 public ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
.text$mn:00004A48 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:00004A48                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+3Cp
.text$mn:00004A48                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+64p ...
.text$mn:00004A48
.text$mn:00004A48 var_8           = dword ptr -8
.text$mn:00004A48 var_4           = dword ptr -4
.text$mn:00004A48
.text$mn:00004A48                 push    ebp
.text$mn:00004A49                 mov     ebp, esp
.text$mn:00004A4B                 sub     esp, 8
.text$mn:00004A4E                 mov     [ebp+var_8], ecx
.text$mn:00004A51                 mov     eax, [ebp+var_8]
.text$mn:00004A54                 cmp     dword ptr [eax], 0
.text$mn:00004A57                 jz      short loc_4AB6
.text$mn:00004A59                 mov     ecx, [ebp+var_8]
.text$mn:00004A5C                 mov     edx, [ecx]
.text$mn:00004A5E                 add     edx, 4
.text$mn:00004A61                 mov     [ebp+var_4], edx
.text$mn:00004A64
.text$mn:00004A64 loc_4A64:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+39j
.text$mn:00004A64                 mov     eax, [ebp+var_4]
.text$mn:00004A67                 cmp     dword ptr [eax], 0
.text$mn:00004A6A                 jz      short loc_4A83
.text$mn:00004A6C                 mov     ecx, [ebp+var_4]
.text$mn:00004A6F                 mov     edx, [ecx]
.text$mn:00004A71                 cmp     edx, [ebp+var_8]
.text$mn:00004A74                 jz      short loc_4A83
.text$mn:00004A76                 mov     eax, [ebp+var_4]
.text$mn:00004A79                 mov     ecx, [eax]
.text$mn:00004A7B                 add     ecx, 4
.text$mn:00004A7E                 mov     [ebp+var_4], ecx
.text$mn:00004A81                 jmp     short loc_4A64
.text$mn:00004A83 ; ---------------------------------------------------------------------------
.text$mn:00004A83
.text$mn:00004A83 loc_4A83:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+22j
.text$mn:00004A83                                         ; std::_Iterator_base12::_Orphan_me(void)+2Cj
.text$mn:00004A83                 mov     edx, [ebp+var_4]
.text$mn:00004A86                 cmp     dword ptr [edx], 0
.text$mn:00004A89                 jnz     short loc_4AA2
.text$mn:00004A8B                 push    0C9h ; '+'      ; unsigned int
.text$mn:00004A90                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004A95                 push    offset ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; "ITERATOR LIST CORRUPTED!"
.text$mn:00004A9A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00004A9F                 add     esp, 0Ch
.text$mn:00004AA2
.text$mn:00004AA2 loc_4AA2:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+41j
.text$mn:00004AA2                 mov     eax, [ebp+var_4]
.text$mn:00004AA5                 mov     ecx, [ebp+var_8]
.text$mn:00004AA8                 mov     edx, [ecx+4]
.text$mn:00004AAB                 mov     [eax], edx
.text$mn:00004AAD                 mov     eax, [ebp+var_8]
.text$mn:00004AB0                 mov     dword ptr [eax], 0
.text$mn:00004AB6
.text$mn:00004AB6 loc_4AB6:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+Fj
.text$mn:00004AB6                 mov     esp, ebp
.text$mn:00004AB8                 pop     ebp
.text$mn:00004AB9                 retn
.text$mn:00004AB9 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ endp
.text$mn:00004AB9
.text$mn:00004AB9 ; ---------------------------------------------------------------------------
.text$mn:00004ABA                 align 4
.text$mn:00004ABA _text$mn        ends
.text$mn:00004ABA
.text$mn:00004ABC ; ===========================================================================
.text$mn:00004ABC
.text$mn:00004ABC ; Segment type: Pure code
.text$mn:00004ABC ; Segment permissions: Read/Execute
.text$mn:00004ABC _text$mn        segment para public 'CODE' use32
.text$mn:00004ABC                 assume cs:_text$mn
.text$mn:00004ABC                 ;org 4ABCh
.text$mn:00004ABC ; COMDAT (pick any)
.text$mn:00004ABC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004ABC
.text$mn:00004ABC ; =============== S U B R O U T I N E =======================================
.text$mn:00004ABC
.text$mn:00004ABC ; Attributes: bp-based frame
.text$mn:00004ABC
.text$mn:00004ABC ; protected: void __thiscall std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>::_Orphan_range(struct std::pair<int, int> *, struct std::pair<int, int> *)const
.text$mn:00004ABC                 public ?_Orphan_range@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXPAU?$pair@HH@2@0@Z
.text$mn:00004ABC ?_Orphan_range@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXPAU?$pair@HH@2@0@Z proc near
.text$mn:00004ABC                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::push_back(std::pair<int,int> &&)+6Ap
.text$mn:00004ABC                                         ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::push_back(std::pair<int,int> &&)+D9p
.text$mn:00004ABC
.text$mn:00004ABC var_18          = byte ptr -18h
.text$mn:00004ABC var_14          = dword ptr -14h
.text$mn:00004ABC var_10          = dword ptr -10h
.text$mn:00004ABC var_C           = dword ptr -0Ch
.text$mn:00004ABC var_4           = dword ptr -4
.text$mn:00004ABC arg_0           = dword ptr  8
.text$mn:00004ABC arg_4           = dword ptr  0Ch
.text$mn:00004ABC
.text$mn:00004ABC                 push    ebp
.text$mn:00004ABD                 mov     ebp, esp
.text$mn:00004ABF                 push    0FFFFFFFFh
.text$mn:00004AC1                 push    offset __ehhandler$?_Orphan_range@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXPAU?$pair@HH@2@0@Z
.text$mn:00004AC6                 mov     eax, large fs:0
.text$mn:00004ACC                 push    eax
.text$mn:00004ACD                 sub     esp, 0Ch
.text$mn:00004AD0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004AD5                 xor     eax, ebp
.text$mn:00004AD7                 push    eax
.text$mn:00004AD8                 lea     eax, [ebp+var_C]
.text$mn:00004ADB                 mov     large fs:0, eax
.text$mn:00004AE1                 mov     [ebp+var_14], ecx
.text$mn:00004AE4                 push    3               ; int
.text$mn:00004AE6                 lea     ecx, [ebp+var_18] ; this
.text$mn:00004AE9                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00004AEE                 mov     [ebp+var_4], 0
.text$mn:00004AF5                 mov     ecx, [ebp+var_14] ; this
.text$mn:00004AF8                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00004AFD                 mov     [ebp+var_10], eax
.text$mn:00004B00                 cmp     [ebp+var_10], 0
.text$mn:00004B04                 jz      short loc_4B54
.text$mn:00004B06
.text$mn:00004B06 loc_4B06:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Orphan_range(std::pair<int,int> *,std::pair<int,int> *):loc_4B52j
.text$mn:00004B06                 mov     eax, [ebp+var_10]
.text$mn:00004B09                 cmp     dword ptr [eax], 0
.text$mn:00004B0C                 jz      short loc_4B54
.text$mn:00004B0E                 mov     ecx, [ebp+var_10]
.text$mn:00004B11                 mov     edx, [ecx]
.text$mn:00004B13                 mov     eax, [edx+8]
.text$mn:00004B16                 cmp     eax, [ebp+arg_0]
.text$mn:00004B19                 jb      short loc_4B28
.text$mn:00004B1B                 mov     ecx, [ebp+var_10]
.text$mn:00004B1E                 mov     edx, [ecx]
.text$mn:00004B20                 mov     eax, [ebp+arg_4]
.text$mn:00004B23                 cmp     eax, [edx+8]
.text$mn:00004B26                 jnb     short loc_4B37
.text$mn:00004B28
.text$mn:00004B28 loc_4B28:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Orphan_range(std::pair<int,int> *,std::pair<int,int> *)+5Dj
.text$mn:00004B28                 mov     ecx, [ebp+var_10]
.text$mn:00004B2B                 mov     ecx, [ecx]      ; this
.text$mn:00004B2D                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00004B32                 mov     [ebp+var_10], eax
.text$mn:00004B35                 jmp     short loc_4B52
.text$mn:00004B37 ; ---------------------------------------------------------------------------
.text$mn:00004B37
.text$mn:00004B37 loc_4B37:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Orphan_range(std::pair<int,int> *,std::pair<int,int> *)+6Aj
.text$mn:00004B37                 mov     edx, [ebp+var_10]
.text$mn:00004B3A                 mov     ecx, [edx]      ; this
.text$mn:00004B3C                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00004B41                 mov     eax, [ebp+var_10]
.text$mn:00004B44                 mov     ecx, [eax]      ; this
.text$mn:00004B46                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00004B4B                 mov     ecx, [ebp+var_10]
.text$mn:00004B4E                 mov     edx, [eax]
.text$mn:00004B50                 mov     [ecx], edx
.text$mn:00004B52
.text$mn:00004B52 loc_4B52:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Orphan_range(std::pair<int,int> *,std::pair<int,int> *)+79j
.text$mn:00004B52                 jmp     short loc_4B06
.text$mn:00004B54 ; ---------------------------------------------------------------------------
.text$mn:00004B54
.text$mn:00004B54 loc_4B54:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Orphan_range(std::pair<int,int> *,std::pair<int,int> *)+48j
.text$mn:00004B54                                         ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Orphan_range(std::pair<int,int> *,std::pair<int,int> *)+50j
.text$mn:00004B54                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004B5B                 lea     ecx, [ebp+var_18] ; this
.text$mn:00004B5E                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00004B63                 mov     ecx, [ebp+var_C]
.text$mn:00004B66                 mov     large fs:0, ecx
.text$mn:00004B6D                 pop     ecx
.text$mn:00004B6E                 mov     esp, ebp
.text$mn:00004B70                 pop     ebp
.text$mn:00004B71                 retn    8
.text$mn:00004B71 ?_Orphan_range@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXPAU?$pair@HH@2@0@Z endp
.text$mn:00004B71
.text$mn:00004B71 _text$mn        ends
.text$mn:00004B71
.text$x:00004B74 ; ===========================================================================
.text$x:00004B74
.text$x:00004B74 ; Segment type: Pure code
.text$x:00004B74 ; Segment permissions: Read/Execute
.text$x:00004B74 _text$x         segment para public 'CODE' use32
.text$x:00004B74                 assume cs:_text$x
.text$x:00004B74                 ;org 4B74h
.text$x:00004B74 ; COMDAT (pick associative to section at 4ABC)
.text$x:00004B74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004B74
.text$x:00004B74 ; =============== S U B R O U T I N E =======================================
.text$x:00004B74
.text$x:00004B74
.text$x:00004B74 __unwindfunclet$?_Orphan_range@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXPAU?$pair@HH@2@0@Z$0 proc near
.text$x:00004B74                                         ; DATA XREF: .xdata$x:000068C8o
.text$x:00004B74                 lea     ecx, [ebp-18h]  ; this
.text$x:00004B77                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00004B77 __unwindfunclet$?_Orphan_range@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXPAU?$pair@HH@2@0@Z$0 endp
.text$x:00004B77
.text$x:00004B7C
.text$x:00004B7C ; =============== S U B R O U T I N E =======================================
.text$x:00004B7C
.text$x:00004B7C
.text$x:00004B7C __ehhandler$?_Orphan_range@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXPAU?$pair@HH@2@0@Z proc near
.text$x:00004B7C                                         ; DATA XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Orphan_range(std::pair<int,int> *,std::pair<int,int> *)+5o
.text$x:00004B7C
.text$x:00004B7C arg_4           = dword ptr  8
.text$x:00004B7C
.text$x:00004B7C                 mov     edx, [esp+arg_4]
.text$x:00004B80                 lea     eax, [edx+0Ch]
.text$x:00004B83                 mov     ecx, [edx-10h]
.text$x:00004B86                 xor     ecx, eax
.text$x:00004B88                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004B8D                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXPAU?$pair@HH@2@0@Z
.text$x:00004B92                 jmp     ___CxxFrameHandler3
.text$x:00004B92 __ehhandler$?_Orphan_range@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXPAU?$pair@HH@2@0@Z endp
.text$x:00004B92
.text$x:00004B92 ; ---------------------------------------------------------------------------
.text$x:00004B97                 align 4
.text$x:00004B97 _text$x         ends
.text$x:00004B97
.text$mn:00004B98 ; ===========================================================================
.text$mn:00004B98
.text$mn:00004B98 ; Segment type: Pure code
.text$mn:00004B98 ; Segment permissions: Read/Execute
.text$mn:00004B98 _text$mn        segment para public 'CODE' use32
.text$mn:00004B98                 assume cs:_text$mn
.text$mn:00004B98                 ;org 4B98h
.text$mn:00004B98 ; COMDAT (pick any)
.text$mn:00004B98                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004B98
.text$mn:00004B98 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B98
.text$mn:00004B98 ; Attributes: bp-based frame
.text$mn:00004B98
.text$mn:00004B98 ; public: static unsigned int __cdecl std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Pdif(class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<char>>>, class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<char>>>)
.text$mn:00004B98                 public ?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0@Z
.text$mn:00004B98 ?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0@Z proc near
.text$mn:00004B98                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::insert(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>,char)+8Fp
.text$mn:00004B98
.text$mn:00004B98 var_14          = dword ptr -14h
.text$mn:00004B98 var_10          = dword ptr -10h
.text$mn:00004B98 var_C           = dword ptr -0Ch
.text$mn:00004B98 var_4           = dword ptr -4
.text$mn:00004B98 arg_0           = byte ptr  8
.text$mn:00004B98 arg_8           = dword ptr  10h
.text$mn:00004B98 arg_C           = byte ptr  14h
.text$mn:00004B98
.text$mn:00004B98                 push    ebp
.text$mn:00004B99                 mov     ebp, esp
.text$mn:00004B9B                 push    0FFFFFFFFh
.text$mn:00004B9D                 push    offset __ehhandler$?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0@Z
.text$mn:00004BA2                 mov     eax, large fs:0
.text$mn:00004BA8                 push    eax
.text$mn:00004BA9                 sub     esp, 8
.text$mn:00004BAC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004BB1                 xor     eax, ebp
.text$mn:00004BB3                 push    eax
.text$mn:00004BB4                 lea     eax, [ebp+var_C]
.text$mn:00004BB7                 mov     large fs:0, eax
.text$mn:00004BBD                 mov     [ebp+var_4], 1
.text$mn:00004BC4                 cmp     [ebp+arg_8], 0
.text$mn:00004BC8                 jnz     short loc_4BD3
.text$mn:00004BCA                 mov     [ebp+var_10], 0
.text$mn:00004BD1                 jmp     short loc_4BE2
.text$mn:00004BD3 ; ---------------------------------------------------------------------------
.text$mn:00004BD3
.text$mn:00004BD3 loc_4BD3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>)+30j
.text$mn:00004BD3                 lea     eax, [ebp+arg_C]
.text$mn:00004BD6                 push    eax             ; std::_Iterator_base12 *
.text$mn:00004BD7                 lea     ecx, [ebp+arg_0]
.text$mn:00004BDA                 call    ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>> const &)
.text$mn:00004BDF                 mov     [ebp+var_10], eax
.text$mn:00004BE2
.text$mn:00004BE2 loc_4BE2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>)+39j
.text$mn:00004BE2                 mov     ecx, [ebp+var_10]
.text$mn:00004BE5                 mov     [ebp+var_14], ecx
.text$mn:00004BE8                 mov     byte ptr [ebp+var_4], 0
.text$mn:00004BEC                 lea     ecx, [ebp+arg_0]
.text$mn:00004BEF                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$mn:00004BF4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004BFB                 lea     ecx, [ebp+arg_C]
.text$mn:00004BFE                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$mn:00004C03                 mov     eax, [ebp+var_14]
.text$mn:00004C06                 mov     ecx, [ebp+var_C]
.text$mn:00004C09                 mov     large fs:0, ecx
.text$mn:00004C10                 pop     ecx
.text$mn:00004C11                 mov     esp, ebp
.text$mn:00004C13                 pop     ebp
.text$mn:00004C14                 retn
.text$mn:00004C14 ?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0@Z endp
.text$mn:00004C14
.text$mn:00004C14 ; ---------------------------------------------------------------------------
.text$mn:00004C15                 align 4
.text$mn:00004C15 _text$mn        ends
.text$mn:00004C15
.text$x:00004C18 ; ===========================================================================
.text$x:00004C18
.text$x:00004C18 ; Segment type: Pure code
.text$x:00004C18 ; Segment permissions: Read/Execute
.text$x:00004C18 _text$x         segment para public 'CODE' use32
.text$x:00004C18                 assume cs:_text$x
.text$x:00004C18                 ;org 4C18h
.text$x:00004C18 ; COMDAT (pick associative to section at 4B98)
.text$x:00004C18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004C18
.text$x:00004C18 ; =============== S U B R O U T I N E =======================================
.text$x:00004C18
.text$x:00004C18
.text$x:00004C18 __unwindfunclet$?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0@Z$0 proc near
.text$x:00004C18                                         ; DATA XREF: .xdata$x:00006480o
.text$x:00004C18                 lea     ecx, [ebp+14h]
.text$x:00004C1B                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$x:00004C1B __unwindfunclet$?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0@Z$0 endp
.text$x:00004C1B
.text$x:00004C20
.text$x:00004C20 ; =============== S U B R O U T I N E =======================================
.text$x:00004C20
.text$x:00004C20
.text$x:00004C20 __unwindfunclet$?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0@Z$1 proc near
.text$x:00004C20                                         ; DATA XREF: .xdata$x:00006488o
.text$x:00004C20                 lea     ecx, [ebp+8]
.text$x:00004C23                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$x:00004C23 __unwindfunclet$?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0@Z$1 endp
.text$x:00004C23
.text$x:00004C28
.text$x:00004C28 ; =============== S U B R O U T I N E =======================================
.text$x:00004C28
.text$x:00004C28
.text$x:00004C28 __ehhandler$?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0@Z proc near
.text$x:00004C28                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>)+5o
.text$x:00004C28
.text$x:00004C28 arg_4           = dword ptr  8
.text$x:00004C28
.text$x:00004C28                 mov     edx, [esp+arg_4]
.text$x:00004C2C                 lea     eax, [edx+0Ch]
.text$x:00004C2F                 mov     ecx, [edx-0Ch]
.text$x:00004C32                 xor     ecx, eax
.text$x:00004C34                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004C39                 mov     eax, offset __ehfuncinfo$?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0@Z
.text$x:00004C3E                 jmp     ___CxxFrameHandler3
.text$x:00004C3E __ehhandler$?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0@Z endp
.text$x:00004C3E
.text$x:00004C3E ; ---------------------------------------------------------------------------
.text$x:00004C43                 align 4
.text$x:00004C43 _text$x         ends
.text$x:00004C43
.text$mn:00004C44 ; ===========================================================================
.text$mn:00004C44
.text$mn:00004C44 ; Segment type: Pure code
.text$mn:00004C44 ; Segment permissions: Read/Execute
.text$mn:00004C44 _text$mn        segment para public 'CODE' use32
.text$mn:00004C44                 assume cs:_text$mn
.text$mn:00004C44                 ;org 4C44h
.text$mn:00004C44 ; COMDAT (pick any)
.text$mn:00004C44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004C44
.text$mn:00004C44 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C44
.text$mn:00004C44 ; Attributes: bp-based frame
.text$mn:00004C44
.text$mn:00004C44 ; protected: void __thiscall std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>::_Reallocate(unsigned int)
.text$mn:00004C44                 public ?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z
.text$mn:00004C44 ?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z proc near
.text$mn:00004C44                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Reserve(uint)+4Ep
.text$mn:00004C44
.text$mn:00004C44 var_20          = dword ptr -20h
.text$mn:00004C44 var_1C          = dword ptr -1Ch
.text$mn:00004C44 var_18          = dword ptr -18h
.text$mn:00004C44 var_13          = byte ptr -13h
.text$mn:00004C44 var_11          = byte ptr -11h
.text$mn:00004C44 var_10          = dword ptr -10h
.text$mn:00004C44 var_C           = dword ptr -0Ch
.text$mn:00004C44 var_4           = dword ptr -4
.text$mn:00004C44 arg_0           = dword ptr  8
.text$mn:00004C44
.text$mn:00004C44 ; FUNCTION CHUNK AT .text$mn:00004CDA SIZE 00000009 BYTES
.text$mn:00004C44 ; FUNCTION CHUNK AT .text$mn:00004CEA SIZE 00000097 BYTES
.text$mn:00004C44
.text$mn:00004C44                 push    ebp
.text$mn:00004C45                 mov     ebp, esp
.text$mn:00004C47                 push    0FFFFFFFFh
.text$mn:00004C49                 push    offset __ehhandler$?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z
.text$mn:00004C4E                 mov     eax, large fs:0
.text$mn:00004C54                 push    eax
.text$mn:00004C55                 push    ecx
.text$mn:00004C56                 sub     esp, 10h
.text$mn:00004C59                 push    ebx
.text$mn:00004C5A                 push    esi
.text$mn:00004C5B                 push    edi
.text$mn:00004C5C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004C61                 xor     eax, ebp
.text$mn:00004C63                 push    eax
.text$mn:00004C64                 lea     eax, [ebp+var_C]
.text$mn:00004C67                 mov     large fs:0, eax
.text$mn:00004C6D                 mov     [ebp+var_10], esp
.text$mn:00004C70                 mov     [ebp+var_18], ecx
.text$mn:00004C73                 mov     eax, [ebp+arg_0]
.text$mn:00004C76                 push    eax
.text$mn:00004C77                 lea     ecx, [ebp+var_11]
.text$mn:00004C7A                 push    ecx
.text$mn:00004C7B                 mov     ecx, [ebp+var_18]
.text$mn:00004C7E                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Getal(void)
.text$mn:00004C83                 mov     ecx, eax
.text$mn:00004C85                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAEPAU?$pair@HH@2@I@Z ; std::_Wrap_alloc<std::allocator<std::pair<int,int>>>::allocate(uint)
.text$mn:00004C8A                 mov     [ebp+var_1C], eax
.text$mn:00004C8D                 mov     [ebp+var_4], 0
.text$mn:00004C94                 mov     edx, [ebp+var_1C]
.text$mn:00004C97                 push    edx
.text$mn:00004C98                 mov     eax, [ebp+var_18]
.text$mn:00004C9B                 mov     ecx, [eax+8]
.text$mn:00004C9E                 push    ecx
.text$mn:00004C9F                 mov     edx, [ebp+var_18]
.text$mn:00004CA2                 mov     eax, [edx+4]
.text$mn:00004CA5                 push    eax
.text$mn:00004CA6                 mov     ecx, [ebp+var_18]
.text$mn:00004CA9                 call    ??$_Umove@PAU?$pair@HH@std@@@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEPAU?$pair@HH@1@PAU21@00@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Umove<std::pair<int,int> *>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *)
.text$mn:00004CAE                 jmp     short loc_4CDA
.text$mn:00004CAE ?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z endp
.text$mn:00004CAE
.text$mn:00004CB0
.text$mn:00004CB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004CB0
.text$mn:00004CB0 ; Attributes: noreturn
.text$mn:00004CB0
.text$mn:00004CB0 __catch$?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z$0 proc near
.text$mn:00004CB0                                         ; DATA XREF: .xdata$x:00006878o
.text$mn:00004CB0                 mov     ecx, [ebp+8]
.text$mn:00004CB3                 push    ecx             ; int
.text$mn:00004CB4                 mov     edx, [ebp-1Ch]
.text$mn:00004CB7                 push    edx             ; void *
.text$mn:00004CB8                 lea     eax, [ebp-12h]
.text$mn:00004CBB                 push    eax
.text$mn:00004CBC                 mov     ecx, [ebp-18h]
.text$mn:00004CBF                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Getal(void)
.text$mn:00004CC4                 mov     ecx, eax
.text$mn:00004CC6                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAEXPAU?$pair@HH@2@I@Z ; std::_Wrap_alloc<std::allocator<std::pair<int,int>>>::deallocate(std::pair<int,int> *,uint)
.text$mn:00004CCB                 push    0
.text$mn:00004CCD                 push    0
.text$mn:00004CCF                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00004CCF __catch$?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z$0 endp
.text$mn:00004CCF
.text$mn:00004CD4 ; ---------------------------------------------------------------------------
.text$mn:00004CD4                 mov     eax, offset $LN8_0
.text$mn:00004CD9                 retn
.text$mn:00004CDA ; ---------------------------------------------------------------------------
.text$mn:00004CDA ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z
.text$mn:00004CDA
.text$mn:00004CDA loc_4CDA:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Reallocate(uint)+6Aj
.text$mn:00004CDA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004CE1                 jmp     short loc_4CEA
.text$mn:00004CE1 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z
.text$mn:00004CE3
.text$mn:00004CE3 ; =============== S U B R O U T I N E =======================================
.text$mn:00004CE3
.text$mn:00004CE3
.text$mn:00004CE3 $LN8_0          proc near               ; DATA XREF: .text$mn:00004CD4o
.text$mn:00004CE3                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00004CE3 $LN8_0          endp ; sp-analysis failed
.text$mn:00004CE3
.text$mn:00004CEA ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z
.text$mn:00004CEA
.text$mn:00004CEA loc_4CEA:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Reallocate(uint)+9Dj
.text$mn:00004CEA                 mov     ecx, [ebp+var_18]
.text$mn:00004CED                 call    ?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::size(void)
.text$mn:00004CF2                 mov     [ebp+var_20], eax
.text$mn:00004CF5                 mov     ecx, [ebp+var_18]
.text$mn:00004CF8                 cmp     dword ptr [ecx+4], 0
.text$mn:00004CFC                 jz      short loc_4D3E
.text$mn:00004CFE                 mov     edx, [ebp+var_18]
.text$mn:00004D01                 mov     eax, [edx+8]
.text$mn:00004D04                 push    eax
.text$mn:00004D05                 mov     ecx, [ebp+var_18]
.text$mn:00004D08                 mov     edx, [ecx+4]
.text$mn:00004D0B                 push    edx
.text$mn:00004D0C                 mov     ecx, [ebp+var_18]
.text$mn:00004D0F                 call    ?_Destroy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXPAU?$pair@HH@2@0@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Destroy(std::pair<int,int> *,std::pair<int,int> *)
.text$mn:00004D14                 mov     eax, [ebp+var_18]
.text$mn:00004D17                 mov     ecx, [ebp+var_18]
.text$mn:00004D1A                 mov     edx, [eax+0Ch]
.text$mn:00004D1D                 sub     edx, [ecx+4]
.text$mn:00004D20                 sar     edx, 3
.text$mn:00004D23                 push    edx             ; int
.text$mn:00004D24                 mov     eax, [ebp+var_18]
.text$mn:00004D27                 mov     ecx, [eax+4]
.text$mn:00004D2A                 push    ecx             ; void *
.text$mn:00004D2B                 lea     edx, [ebp+var_13]
.text$mn:00004D2E                 push    edx
.text$mn:00004D2F                 mov     ecx, [ebp+var_18]
.text$mn:00004D32                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Getal(void)
.text$mn:00004D37                 mov     ecx, eax
.text$mn:00004D39                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAEXPAU?$pair@HH@2@I@Z ; std::_Wrap_alloc<std::allocator<std::pair<int,int>>>::deallocate(std::pair<int,int> *,uint)
.text$mn:00004D3E
.text$mn:00004D3E loc_4D3E:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Reallocate(uint)+B8j
.text$mn:00004D3E                 mov     ecx, [ebp+var_18] ; this
.text$mn:00004D41                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00004D46                 mov     eax, [ebp+arg_0]
.text$mn:00004D49                 mov     ecx, [ebp+var_1C]
.text$mn:00004D4C                 lea     edx, [ecx+eax*8]
.text$mn:00004D4F                 mov     eax, [ebp+var_18]
.text$mn:00004D52                 mov     [eax+0Ch], edx
.text$mn:00004D55                 mov     ecx, [ebp+var_20]
.text$mn:00004D58                 mov     edx, [ebp+var_1C]
.text$mn:00004D5B                 lea     eax, [edx+ecx*8]
.text$mn:00004D5E                 mov     ecx, [ebp+var_18]
.text$mn:00004D61                 mov     [ecx+8], eax
.text$mn:00004D64                 mov     edx, [ebp+var_18]
.text$mn:00004D67                 mov     eax, [ebp+var_1C]
.text$mn:00004D6A                 mov     [edx+4], eax
.text$mn:00004D6D                 mov     ecx, [ebp+var_C]
.text$mn:00004D70                 mov     large fs:0, ecx
.text$mn:00004D77                 pop     ecx
.text$mn:00004D78                 pop     edi
.text$mn:00004D79                 pop     esi
.text$mn:00004D7A                 pop     ebx
.text$mn:00004D7B                 mov     esp, ebp
.text$mn:00004D7D                 pop     ebp
.text$mn:00004D7E                 retn    4
.text$mn:00004D7E ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z
.text$mn:00004D7E ; ---------------------------------------------------------------------------
.text$mn:00004D81                 align 4
.text$mn:00004D81 _text$mn        ends
.text$mn:00004D81
.text$x:00004D84 ; ===========================================================================
.text$x:00004D84
.text$x:00004D84 ; Segment type: Pure code
.text$x:00004D84 ; Segment permissions: Read/Execute
.text$x:00004D84 _text$x         segment para public 'CODE' use32
.text$x:00004D84                 assume cs:_text$x
.text$x:00004D84                 ;org 4D84h
.text$x:00004D84 ; COMDAT (pick associative to section at 4C44)
.text$x:00004D84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004D84
.text$x:00004D84 ; =============== S U B R O U T I N E =======================================
.text$x:00004D84
.text$x:00004D84
.text$x:00004D84 __ehhandler$?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z proc near
.text$x:00004D84                                         ; DATA XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Reallocate(uint)+5o
.text$x:00004D84
.text$x:00004D84 arg_4           = dword ptr  8
.text$x:00004D84
.text$x:00004D84                 mov     edx, [esp+arg_4]
.text$x:00004D88                 lea     eax, [edx+0Ch]
.text$x:00004D8B                 mov     ecx, [edx-24h]
.text$x:00004D8E                 xor     ecx, eax
.text$x:00004D90                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004D95                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z
.text$x:00004D9A                 jmp     ___CxxFrameHandler3
.text$x:00004D9A __ehhandler$?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z endp
.text$x:00004D9A
.text$x:00004D9A ; ---------------------------------------------------------------------------
.text$x:00004D9F                 align 10h
.text$x:00004D9F _text$x         ends
.text$x:00004D9F
.text$mn:00004DA0 ; ===========================================================================
.text$mn:00004DA0
.text$mn:00004DA0 ; Segment type: Pure code
.text$mn:00004DA0 ; Segment permissions: Read/Execute
.text$mn:00004DA0 _text$mn        segment para public 'CODE' use32
.text$mn:00004DA0                 assume cs:_text$mn
.text$mn:00004DA0                 ;org 4DA0h
.text$mn:00004DA0 ; COMDAT (pick any)
.text$mn:00004DA0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004DA0
.text$mn:00004DA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004DA0
.text$mn:00004DA0 ; Attributes: bp-based frame
.text$mn:00004DA0
.text$mn:00004DA0 ; protected: void __thiscall std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>::_Reserve(unsigned int)
.text$mn:00004DA0                 public ?_Reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z
.text$mn:00004DA0 ?_Reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z proc near
.text$mn:00004DA0                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::push_back(std::pair<int,int> &&)+54p
.text$mn:00004DA0                                         ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::push_back(std::pair<int,int> &&)+C3p
.text$mn:00004DA0
.text$mn:00004DA0 var_4           = dword ptr -4
.text$mn:00004DA0 arg_0           = dword ptr  8
.text$mn:00004DA0
.text$mn:00004DA0                 push    ebp
.text$mn:00004DA1                 mov     ebp, esp
.text$mn:00004DA3                 push    ecx
.text$mn:00004DA4                 push    esi
.text$mn:00004DA5                 mov     [ebp+var_4], ecx
.text$mn:00004DA8                 mov     ecx, [ebp+var_4]
.text$mn:00004DAB                 call    ?_Unused_capacity@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Unused_capacity(void)
.text$mn:00004DB0                 cmp     eax, [ebp+arg_0]
.text$mn:00004DB3                 jnb     short loc_4DF3
.text$mn:00004DB5                 mov     ecx, [ebp+var_4]
.text$mn:00004DB8                 call    ?max_size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::max_size(void)
.text$mn:00004DBD                 mov     esi, eax
.text$mn:00004DBF                 mov     ecx, [ebp+var_4]
.text$mn:00004DC2                 call    ?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::size(void)
.text$mn:00004DC7                 sub     esi, eax
.text$mn:00004DC9                 cmp     esi, [ebp+arg_0]
.text$mn:00004DCC                 jnb     short loc_4DD6
.text$mn:00004DCE                 mov     ecx, [ebp+var_4]
.text$mn:00004DD1                 call    ?_Xlen@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Xlen(void)
.text$mn:00004DD6
.text$mn:00004DD6 loc_4DD6:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Reserve(uint)+2Cj
.text$mn:00004DD6                 mov     ecx, [ebp+var_4]
.text$mn:00004DD9                 call    ?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::size(void)
.text$mn:00004DDE                 add     eax, [ebp+arg_0]
.text$mn:00004DE1                 push    eax
.text$mn:00004DE2                 mov     ecx, [ebp+var_4]
.text$mn:00004DE5                 call    ?_Grow_to@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEII@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Grow_to(uint)
.text$mn:00004DEA                 push    eax
.text$mn:00004DEB                 mov     ecx, [ebp+var_4]
.text$mn:00004DEE                 call    ?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Reallocate(uint)
.text$mn:00004DF3
.text$mn:00004DF3 loc_4DF3:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Reserve(uint)+13j
.text$mn:00004DF3                 pop     esi
.text$mn:00004DF4                 mov     esp, ebp
.text$mn:00004DF6                 pop     ebp
.text$mn:00004DF7                 retn    4
.text$mn:00004DF7 ?_Reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z endp
.text$mn:00004DF7
.text$mn:00004DF7 ; ---------------------------------------------------------------------------
.text$mn:00004DFA                 align 4
.text$mn:00004DFA _text$mn        ends
.text$mn:00004DFA
.text$mn:00004DFC ; ===========================================================================
.text$mn:00004DFC
.text$mn:00004DFC ; Segment type: Pure code
.text$mn:00004DFC ; Segment permissions: Read/Execute
.text$mn:00004DFC _text$mn        segment para public 'CODE' use32
.text$mn:00004DFC                 assume cs:_text$mn
.text$mn:00004DFC                 ;org 4DFCh
.text$mn:00004DFC ; COMDAT (pick any)
.text$mn:00004DFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004DFC
.text$mn:00004DFC ; =============== S U B R O U T I N E =======================================
.text$mn:00004DFC
.text$mn:00004DFC ; Attributes: bp-based frame
.text$mn:00004DFC
.text$mn:00004DFC ; void __thiscall std::_Container_base12::_Swap_all(std::_Container_base12 *this, struct std::_Container_base12 *)
.text$mn:00004DFC                 public ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
.text$mn:00004DFC ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z proc near
.text$mn:00004DFC                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Assign_rv(std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>> &&,std::integral_constant<bool,1>)+Ep
.text$mn:00004DFC
.text$mn:00004DFC var_18          = byte ptr -18h
.text$mn:00004DFC var_14          = dword ptr -14h
.text$mn:00004DFC var_10          = dword ptr -10h
.text$mn:00004DFC var_C           = dword ptr -0Ch
.text$mn:00004DFC var_4           = dword ptr -4
.text$mn:00004DFC arg_0           = dword ptr  8
.text$mn:00004DFC
.text$mn:00004DFC                 push    ebp
.text$mn:00004DFD                 mov     ebp, esp
.text$mn:00004DFF                 push    0FFFFFFFFh
.text$mn:00004E01                 push    offset __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
.text$mn:00004E06                 mov     eax, large fs:0
.text$mn:00004E0C                 push    eax
.text$mn:00004E0D                 sub     esp, 0Ch
.text$mn:00004E10                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004E15                 xor     eax, ebp
.text$mn:00004E17                 push    eax
.text$mn:00004E18                 lea     eax, [ebp+var_C]
.text$mn:00004E1B                 mov     large fs:0, eax
.text$mn:00004E21                 mov     [ebp+var_10], ecx
.text$mn:00004E24                 push    3               ; int
.text$mn:00004E26                 lea     ecx, [ebp+var_18] ; this
.text$mn:00004E29                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00004E2E                 mov     [ebp+var_4], 0
.text$mn:00004E35                 mov     eax, [ebp+var_10]
.text$mn:00004E38                 mov     ecx, [eax]
.text$mn:00004E3A                 mov     [ebp+var_14], ecx
.text$mn:00004E3D                 mov     edx, [ebp+var_10]
.text$mn:00004E40                 mov     eax, [ebp+arg_0]
.text$mn:00004E43                 mov     ecx, [eax]
.text$mn:00004E45                 mov     [edx], ecx
.text$mn:00004E47                 mov     edx, [ebp+arg_0]
.text$mn:00004E4A                 mov     eax, [ebp+var_14]
.text$mn:00004E4D                 mov     [edx], eax
.text$mn:00004E4F                 mov     ecx, [ebp+var_10]
.text$mn:00004E52                 cmp     dword ptr [ecx], 0
.text$mn:00004E55                 jz      short loc_4E61
.text$mn:00004E57                 mov     edx, [ebp+var_10]
.text$mn:00004E5A                 mov     eax, [edx]
.text$mn:00004E5C                 mov     ecx, [ebp+var_10]
.text$mn:00004E5F                 mov     [eax], ecx
.text$mn:00004E61
.text$mn:00004E61 loc_4E61:                               ; CODE XREF: std::_Container_base12::_Swap_all(std::_Container_base12 &)+59j
.text$mn:00004E61                 mov     edx, [ebp+arg_0]
.text$mn:00004E64                 cmp     dword ptr [edx], 0
.text$mn:00004E67                 jz      short loc_4E73
.text$mn:00004E69                 mov     eax, [ebp+arg_0]
.text$mn:00004E6C                 mov     ecx, [eax]
.text$mn:00004E6E                 mov     edx, [ebp+arg_0]
.text$mn:00004E71                 mov     [ecx], edx
.text$mn:00004E73
.text$mn:00004E73 loc_4E73:                               ; CODE XREF: std::_Container_base12::_Swap_all(std::_Container_base12 &)+6Bj
.text$mn:00004E73                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004E7A                 lea     ecx, [ebp+var_18] ; this
.text$mn:00004E7D                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00004E82                 mov     ecx, [ebp+var_C]
.text$mn:00004E85                 mov     large fs:0, ecx
.text$mn:00004E8C                 pop     ecx
.text$mn:00004E8D                 mov     esp, ebp
.text$mn:00004E8F                 pop     ebp
.text$mn:00004E90                 retn    4
.text$mn:00004E90 ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z endp
.text$mn:00004E90
.text$mn:00004E90 ; ---------------------------------------------------------------------------
.text$mn:00004E93                 align 4
.text$mn:00004E93 _text$mn        ends
.text$mn:00004E93
.text$x:00004E94 ; ===========================================================================
.text$x:00004E94
.text$x:00004E94 ; Segment type: Pure code
.text$x:00004E94 ; Segment permissions: Read/Execute
.text$x:00004E94 _text$x         segment para public 'CODE' use32
.text$x:00004E94                 assume cs:_text$x
.text$x:00004E94                 ;org 4E94h
.text$x:00004E94 ; COMDAT (pick associative to section at 4DFC)
.text$x:00004E94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00004E94
.text$x:00004E94 ; =============== S U B R O U T I N E =======================================
.text$x:00004E94
.text$x:00004E94
.text$x:00004E94 __unwindfunclet$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z$0 proc near
.text$x:00004E94                                         ; DATA XREF: .xdata$x:00006128o
.text$x:00004E94                 lea     ecx, [ebp-18h]  ; this
.text$x:00004E97                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00004E97 __unwindfunclet$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z$0 endp
.text$x:00004E97
.text$x:00004E9C
.text$x:00004E9C ; =============== S U B R O U T I N E =======================================
.text$x:00004E9C
.text$x:00004E9C
.text$x:00004E9C __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z proc near
.text$x:00004E9C                                         ; DATA XREF: std::_Container_base12::_Swap_all(std::_Container_base12 &)+5o
.text$x:00004E9C
.text$x:00004E9C arg_4           = dword ptr  8
.text$x:00004E9C
.text$x:00004E9C                 mov     edx, [esp+arg_4]
.text$x:00004EA0                 lea     eax, [edx+0Ch]
.text$x:00004EA3                 mov     ecx, [edx-10h]
.text$x:00004EA6                 xor     ecx, eax
.text$x:00004EA8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004EAD                 mov     eax, offset __ehfuncinfo$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
.text$x:00004EB2                 jmp     ___CxxFrameHandler3
.text$x:00004EB2 __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z endp
.text$x:00004EB2
.text$x:00004EB2 ; ---------------------------------------------------------------------------
.text$x:00004EB7                 align 4
.text$x:00004EB7 _text$x         ends
.text$x:00004EB7
.text$mn:00004EB8 ; ===========================================================================
.text$mn:00004EB8
.text$mn:00004EB8 ; Segment type: Pure code
.text$mn:00004EB8 ; Segment permissions: Read/Execute
.text$mn:00004EB8 _text$mn        segment para public 'CODE' use32
.text$mn:00004EB8                 assume cs:_text$mn
.text$mn:00004EB8                 ;org 4EB8h
.text$mn:00004EB8 ; COMDAT (pick any)
.text$mn:00004EB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004EB8
.text$mn:00004EB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004EB8
.text$mn:00004EB8 ; Attributes: bp-based frame
.text$mn:00004EB8
.text$mn:00004EB8 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00004EB8                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00004EB8 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00004EB8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00004EB8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+47p ...
.text$mn:00004EB8
.text$mn:00004EB8 var_C           = dword ptr -0Ch
.text$mn:00004EB8 var_8           = dword ptr -8
.text$mn:00004EB8 var_2           = byte ptr -2
.text$mn:00004EB8 var_1           = byte ptr -1
.text$mn:00004EB8 arg_0           = byte ptr  8
.text$mn:00004EB8 Size            = dword ptr  0Ch
.text$mn:00004EB8
.text$mn:00004EB8                 push    ebp
.text$mn:00004EB9                 mov     ebp, esp
.text$mn:00004EBB                 sub     esp, 0Ch
.text$mn:00004EBE                 mov     [ebp+var_8], ecx
.text$mn:00004EC1                 movzx   eax, [ebp+arg_0]
.text$mn:00004EC5                 test    eax, eax
.text$mn:00004EC7                 jnz     short loc_4ECB
.text$mn:00004EC9                 jmp     short loc_4F3E
.text$mn:00004ECB ; ---------------------------------------------------------------------------
.text$mn:00004ECB
.text$mn:00004ECB loc_4ECB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00004ECB                 mov     ecx, [ebp+var_8]
.text$mn:00004ECE                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00004ED2                 jb      short loc_4F3E
.text$mn:00004ED4                 mov     edx, [ebp+var_8]
.text$mn:00004ED7                 mov     eax, [edx+4]
.text$mn:00004EDA                 mov     [ebp+var_C], eax
.text$mn:00004EDD                 mov     ecx, [ebp+var_8]
.text$mn:00004EE0                 add     ecx, 4
.text$mn:00004EE3                 push    ecx
.text$mn:00004EE4                 lea     edx, [ebp+var_1]
.text$mn:00004EE7                 push    edx
.text$mn:00004EE8                 mov     ecx, [ebp+var_8]
.text$mn:00004EEB                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00004EF0                 mov     ecx, eax
.text$mn:00004EF2                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00004EF7                 cmp     [ebp+Size], 0
.text$mn:00004EFB                 jbe     short loc_4F1D
.text$mn:00004EFD                 mov     eax, [ebp+Size]
.text$mn:00004F00                 push    eax             ; Size
.text$mn:00004F01                 mov     ecx, [ebp+var_C]
.text$mn:00004F04                 push    ecx
.text$mn:00004F05                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00004F0A                 add     esp, 4
.text$mn:00004F0D                 push    eax             ; Src
.text$mn:00004F0E                 mov     edx, [ebp+var_8]
.text$mn:00004F11                 add     edx, 4
.text$mn:00004F14                 push    edx             ; Dst
.text$mn:00004F15                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00004F1A                 add     esp, 0Ch
.text$mn:00004F1D
.text$mn:00004F1D loc_4F1D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00004F1D                 mov     eax, [ebp+var_8]
.text$mn:00004F20                 mov     ecx, [eax+18h]
.text$mn:00004F23                 add     ecx, 1
.text$mn:00004F26                 push    ecx             ; int
.text$mn:00004F27                 mov     edx, [ebp+var_C]
.text$mn:00004F2A                 push    edx             ; void *
.text$mn:00004F2B                 lea     eax, [ebp+var_2]
.text$mn:00004F2E                 push    eax
.text$mn:00004F2F                 mov     ecx, [ebp+var_8]
.text$mn:00004F32                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00004F37                 mov     ecx, eax
.text$mn:00004F39                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:00004F3E
.text$mn:00004F3E loc_4F3E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:00004F3E                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:00004F3E                 mov     ecx, [ebp+var_8]
.text$mn:00004F41                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00004F48                 mov     edx, [ebp+Size]
.text$mn:00004F4B                 push    edx
.text$mn:00004F4C                 mov     ecx, [ebp+var_8]
.text$mn:00004F4F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00004F54                 mov     esp, ebp
.text$mn:00004F56                 pop     ebp
.text$mn:00004F57                 retn    8
.text$mn:00004F57 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:00004F57
.text$mn:00004F57 ; ---------------------------------------------------------------------------
.text$mn:00004F5A                 align 4
.text$mn:00004F5A _text$mn        ends
.text$mn:00004F5A
.text$mn:00004F5C ; ===========================================================================
.text$mn:00004F5C
.text$mn:00004F5C ; Segment type: Pure code
.text$mn:00004F5C ; Segment permissions: Read/Execute
.text$mn:00004F5C _text$mn        segment para public 'CODE' use32
.text$mn:00004F5C                 assume cs:_text$mn
.text$mn:00004F5C                 ;org 4F5Ch
.text$mn:00004F5C ; COMDAT (pick any)
.text$mn:00004F5C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004F5C
.text$mn:00004F5C ; =============== S U B R O U T I N E =======================================
.text$mn:00004F5C
.text$mn:00004F5C ; Attributes: bp-based frame
.text$mn:00004F5C
.text$mn:00004F5C ; protected: void __thiscall std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>::_Tidy(void)
.text$mn:00004F5C                 public ?_Tidy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXXZ
.text$mn:00004F5C ?_Tidy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXXZ proc near
.text$mn:00004F5C                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::~vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>(void)+30p
.text$mn:00004F5C
.text$mn:00004F5C var_8           = dword ptr -8
.text$mn:00004F5C var_1           = byte ptr -1
.text$mn:00004F5C
.text$mn:00004F5C                 push    ebp
.text$mn:00004F5D                 mov     ebp, esp
.text$mn:00004F5F                 sub     esp, 8
.text$mn:00004F62                 mov     [ebp+var_8], ecx
.text$mn:00004F65                 mov     eax, [ebp+var_8]
.text$mn:00004F68                 cmp     dword ptr [eax+4], 0
.text$mn:00004F6C                 jz      short loc_4FD4
.text$mn:00004F6E                 mov     ecx, [ebp+var_8] ; this
.text$mn:00004F71                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00004F76                 mov     ecx, [ebp+var_8]
.text$mn:00004F79                 mov     edx, [ecx+8]
.text$mn:00004F7C                 push    edx
.text$mn:00004F7D                 mov     eax, [ebp+var_8]
.text$mn:00004F80                 mov     ecx, [eax+4]
.text$mn:00004F83                 push    ecx
.text$mn:00004F84                 mov     ecx, [ebp+var_8]
.text$mn:00004F87                 call    ?_Destroy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXPAU?$pair@HH@2@0@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Destroy(std::pair<int,int> *,std::pair<int,int> *)
.text$mn:00004F8C                 mov     edx, [ebp+var_8]
.text$mn:00004F8F                 mov     eax, [ebp+var_8]
.text$mn:00004F92                 mov     ecx, [edx+0Ch]
.text$mn:00004F95                 sub     ecx, [eax+4]
.text$mn:00004F98                 sar     ecx, 3
.text$mn:00004F9B                 push    ecx             ; int
.text$mn:00004F9C                 mov     edx, [ebp+var_8]
.text$mn:00004F9F                 mov     eax, [edx+4]
.text$mn:00004FA2                 push    eax             ; void *
.text$mn:00004FA3                 lea     ecx, [ebp+var_1]
.text$mn:00004FA6                 push    ecx
.text$mn:00004FA7                 mov     ecx, [ebp+var_8]
.text$mn:00004FAA                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Getal(void)
.text$mn:00004FAF                 mov     ecx, eax
.text$mn:00004FB1                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAEXPAU?$pair@HH@2@I@Z ; std::_Wrap_alloc<std::allocator<std::pair<int,int>>>::deallocate(std::pair<int,int> *,uint)
.text$mn:00004FB6                 mov     edx, [ebp+var_8]
.text$mn:00004FB9                 mov     dword ptr [edx+4], 0
.text$mn:00004FC0                 mov     eax, [ebp+var_8]
.text$mn:00004FC3                 mov     dword ptr [eax+8], 0
.text$mn:00004FCA                 mov     ecx, [ebp+var_8]
.text$mn:00004FCD                 mov     dword ptr [ecx+0Ch], 0
.text$mn:00004FD4
.text$mn:00004FD4 loc_4FD4:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Tidy(void)+10j
.text$mn:00004FD4                 mov     esp, ebp
.text$mn:00004FD6                 pop     ebp
.text$mn:00004FD7                 retn
.text$mn:00004FD7 ?_Tidy@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXXZ endp
.text$mn:00004FD7
.text$mn:00004FD7 _text$mn        ends
.text$mn:00004FD7
.text$mn:00004FD8 ; ===========================================================================
.text$mn:00004FD8
.text$mn:00004FD8 ; Segment type: Pure code
.text$mn:00004FD8 ; Segment permissions: Read/Execute
.text$mn:00004FD8 _text$mn        segment para public 'CODE' use32
.text$mn:00004FD8                 assume cs:_text$mn
.text$mn:00004FD8                 ;org 4FD8h
.text$mn:00004FD8 ; COMDAT (pick any)
.text$mn:00004FD8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004FD8
.text$mn:00004FD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004FD8
.text$mn:00004FD8 ; Attributes: bp-based frame
.text$mn:00004FD8
.text$mn:00004FD8 ; public: unsigned int __thiscall std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>::_Unused_capacity(void)const
.text$mn:00004FD8                 public ?_Unused_capacity@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ
.text$mn:00004FD8 ?_Unused_capacity@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ proc near
.text$mn:00004FD8                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Reserve(uint)+Bp
.text$mn:00004FD8
.text$mn:00004FD8 var_4           = dword ptr -4
.text$mn:00004FD8
.text$mn:00004FD8                 push    ebp
.text$mn:00004FD9                 mov     ebp, esp
.text$mn:00004FDB                 push    ecx
.text$mn:00004FDC                 mov     [ebp+var_4], ecx
.text$mn:00004FDF                 mov     eax, [ebp+var_4]
.text$mn:00004FE2                 mov     ecx, [ebp+var_4]
.text$mn:00004FE5                 mov     eax, [eax+0Ch]
.text$mn:00004FE8                 sub     eax, [ecx+8]
.text$mn:00004FEB                 sar     eax, 3
.text$mn:00004FEE                 mov     esp, ebp
.text$mn:00004FF0                 pop     ebp
.text$mn:00004FF1                 retn
.text$mn:00004FF1 ?_Unused_capacity@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ endp
.text$mn:00004FF1
.text$mn:00004FF1 ; ---------------------------------------------------------------------------
.text$mn:00004FF2                 align 4
.text$mn:00004FF2 _text$mn        ends
.text$mn:00004FF2
.text$mn:00004FF4 ; ===========================================================================
.text$mn:00004FF4
.text$mn:00004FF4 ; Segment type: Pure code
.text$mn:00004FF4 ; Segment permissions: Read/Execute
.text$mn:00004FF4 _text$mn        segment para public 'CODE' use32
.text$mn:00004FF4                 assume cs:_text$mn
.text$mn:00004FF4                 ;org 4FF4h
.text$mn:00004FF4 ; COMDAT (pick any)
.text$mn:00004FF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004FF4
.text$mn:00004FF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004FF4
.text$mn:00004FF4 ; Attributes: bp-based frame
.text$mn:00004FF4
.text$mn:00004FF4 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00004FF4                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00004FF4 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00004FF4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00004FF4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Dp ...
.text$mn:00004FF4
.text$mn:00004FF4 var_4           = dword ptr -4
.text$mn:00004FF4
.text$mn:00004FF4                 push    ebp
.text$mn:00004FF5                 mov     ebp, esp
.text$mn:00004FF7                 push    ecx
.text$mn:00004FF8                 mov     [ebp+var_4], ecx
.text$mn:00004FFB                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00005000                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00005005                 mov     esp, ebp
.text$mn:00005007                 pop     ebp
.text$mn:00005008                 retn
.text$mn:00005008 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00005008
.text$mn:00005008 ; ---------------------------------------------------------------------------
.text$mn:00005009                 align 4
.text$mn:00005009 _text$mn        ends
.text$mn:00005009
.text$mn:0000500C ; ===========================================================================
.text$mn:0000500C
.text$mn:0000500C ; Segment type: Pure code
.text$mn:0000500C ; Segment permissions: Read/Execute
.text$mn:0000500C _text$mn        segment para public 'CODE' use32
.text$mn:0000500C                 assume cs:_text$mn
.text$mn:0000500C                 ;org 500Ch
.text$mn:0000500C ; COMDAT (pick any)
.text$mn:0000500C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000500C
.text$mn:0000500C ; =============== S U B R O U T I N E =======================================
.text$mn:0000500C
.text$mn:0000500C ; Attributes: bp-based frame
.text$mn:0000500C
.text$mn:0000500C ; protected: void __thiscall std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>::_Xlen(void)const
.text$mn:0000500C                 public ?_Xlen@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXXZ
.text$mn:0000500C ?_Xlen@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXXZ proc near
.text$mn:0000500C                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Reserve(uint)+31p
.text$mn:0000500C
.text$mn:0000500C var_4           = dword ptr -4
.text$mn:0000500C
.text$mn:0000500C                 push    ebp
.text$mn:0000500D                 mov     ebp, esp
.text$mn:0000500F                 push    ecx
.text$mn:00005010                 mov     [ebp+var_4], ecx
.text$mn:00005013                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:00005018                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000501D                 mov     esp, ebp
.text$mn:0000501F                 pop     ebp
.text$mn:00005020                 retn
.text$mn:00005020 ?_Xlen@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXXZ endp
.text$mn:00005020
.text$mn:00005020 ; ---------------------------------------------------------------------------
.text$mn:00005021                 align 4
.text$mn:00005021 _text$mn        ends
.text$mn:00005021
.text$mn:00005024 ; ===========================================================================
.text$mn:00005024
.text$mn:00005024 ; Segment type: Pure code
.text$mn:00005024 ; Segment permissions: Read/Execute
.text$mn:00005024 _text$mn        segment para public 'CODE' use32
.text$mn:00005024                 assume cs:_text$mn
.text$mn:00005024                 ;org 5024h
.text$mn:00005024 ; COMDAT (pick any)
.text$mn:00005024                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005024
.text$mn:00005024 ; =============== S U B R O U T I N E =======================================
.text$mn:00005024
.text$mn:00005024 ; Attributes: bp-based frame
.text$mn:00005024
.text$mn:00005024 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00005024                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00005024 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00005024                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00005024                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p ...
.text$mn:00005024
.text$mn:00005024 var_4           = dword ptr -4
.text$mn:00005024
.text$mn:00005024                 push    ebp
.text$mn:00005025                 mov     ebp, esp
.text$mn:00005027                 push    ecx
.text$mn:00005028                 mov     [ebp+var_4], ecx
.text$mn:0000502B                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00005030                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00005035                 mov     esp, ebp
.text$mn:00005037                 pop     ebp
.text$mn:00005038                 retn
.text$mn:00005038 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00005038
.text$mn:00005038 ; ---------------------------------------------------------------------------
.text$mn:00005039                 align 4
.text$mn:00005039 _text$mn        ends
.text$mn:00005039
.text$mn:0000503C ; ===========================================================================
.text$mn:0000503C
.text$mn:0000503C ; Segment type: Pure code
.text$mn:0000503C ; Segment permissions: Read/Execute
.text$mn:0000503C _text$mn        segment para public 'CODE' use32
.text$mn:0000503C                 assume cs:_text$mn
.text$mn:0000503C                 ;org 503Ch
.text$mn:0000503C ; COMDAT (pick any)
.text$mn:0000503C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000503C
.text$mn:0000503C ; =============== S U B R O U T I N E =======================================
.text$mn:0000503C
.text$mn:0000503C ; Attributes: bp-based frame
.text$mn:0000503C
.text$mn:0000503C ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:0000503C                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:0000503C ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:0000503C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:0000503C                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:0000503C
.text$mn:0000503C var_4           = dword ptr -4
.text$mn:0000503C arg_0           = dword ptr  8
.text$mn:0000503C
.text$mn:0000503C                 push    ebp
.text$mn:0000503D                 mov     ebp, esp
.text$mn:0000503F                 push    ecx
.text$mn:00005040                 mov     [ebp+var_4], ecx
.text$mn:00005043                 mov     eax, [ebp+arg_0]
.text$mn:00005046                 push    eax
.text$mn:00005047                 mov     ecx, [ebp+var_4]
.text$mn:0000504A                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:0000504F                 mov     esp, ebp
.text$mn:00005051                 pop     ebp
.text$mn:00005052                 retn    4
.text$mn:00005052 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00005052
.text$mn:00005052 ; ---------------------------------------------------------------------------
.text$mn:00005055                 align 4
.text$mn:00005055 _text$mn        ends
.text$mn:00005055
.text$mn:00005058 ; ===========================================================================
.text$mn:00005058
.text$mn:00005058 ; Segment type: Pure code
.text$mn:00005058 ; Segment permissions: Read/Execute
.text$mn:00005058 _text$mn        segment para public 'CODE' use32
.text$mn:00005058                 assume cs:_text$mn
.text$mn:00005058                 ;org 5058h
.text$mn:00005058 ; COMDAT (pick any)
.text$mn:00005058                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005058
.text$mn:00005058 ; =============== S U B R O U T I N E =======================================
.text$mn:00005058
.text$mn:00005058 ; Attributes: bp-based frame
.text$mn:00005058
.text$mn:00005058 ; public: struct std::pair<int, int> * __thiscall std::_Wrap_alloc<class std::allocator<struct std::pair<int, int>>>::allocate(unsigned int)
.text$mn:00005058                 public ?allocate@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAEPAU?$pair@HH@2@I@Z
.text$mn:00005058 ?allocate@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAEPAU?$pair@HH@2@I@Z proc near
.text$mn:00005058                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Reallocate(uint)+41p
.text$mn:00005058
.text$mn:00005058 var_4           = dword ptr -4
.text$mn:00005058 arg_0           = dword ptr  8
.text$mn:00005058
.text$mn:00005058                 push    ebp
.text$mn:00005059                 mov     ebp, esp
.text$mn:0000505B                 push    ecx
.text$mn:0000505C                 mov     [ebp+var_4], ecx
.text$mn:0000505F                 mov     eax, [ebp+arg_0]
.text$mn:00005062                 push    eax
.text$mn:00005063                 mov     ecx, [ebp+var_4]
.text$mn:00005066                 call    ?allocate@?$allocator@U?$pair@HH@std@@@std@@QAEPAU?$pair@HH@2@I@Z ; std::allocator<std::pair<int,int>>::allocate(uint)
.text$mn:0000506B                 mov     esp, ebp
.text$mn:0000506D                 pop     ebp
.text$mn:0000506E                 retn    4
.text$mn:0000506E ?allocate@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAEPAU?$pair@HH@2@I@Z endp
.text$mn:0000506E
.text$mn:0000506E ; ---------------------------------------------------------------------------
.text$mn:00005071                 align 4
.text$mn:00005071 _text$mn        ends
.text$mn:00005071
.text$mn:00005074 ; ===========================================================================
.text$mn:00005074
.text$mn:00005074 ; Segment type: Pure code
.text$mn:00005074 ; Segment permissions: Read/Execute
.text$mn:00005074 _text$mn        segment para public 'CODE' use32
.text$mn:00005074                 assume cs:_text$mn
.text$mn:00005074                 ;org 5074h
.text$mn:00005074 ; COMDAT (pick any)
.text$mn:00005074                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005074
.text$mn:00005074 ; =============== S U B R O U T I N E =======================================
.text$mn:00005074
.text$mn:00005074 ; Attributes: bp-based frame
.text$mn:00005074
.text$mn:00005074 ; public: struct std::_Container_proxy * __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::allocate(unsigned int)
.text$mn:00005074                 public ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00005074 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00005074                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Alloc_proxy(void)+16p
.text$mn:00005074
.text$mn:00005074 var_4           = dword ptr -4
.text$mn:00005074 arg_0           = dword ptr  8
.text$mn:00005074
.text$mn:00005074                 push    ebp
.text$mn:00005075                 mov     ebp, esp
.text$mn:00005077                 push    ecx
.text$mn:00005078                 mov     [ebp+var_4], ecx
.text$mn:0000507B                 mov     eax, [ebp+arg_0]
.text$mn:0000507E                 push    eax
.text$mn:0000507F                 mov     ecx, [ebp+var_4]
.text$mn:00005082                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00005087                 mov     esp, ebp
.text$mn:00005089                 pop     ebp
.text$mn:0000508A                 retn    4
.text$mn:0000508A ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:0000508A
.text$mn:0000508A ; ---------------------------------------------------------------------------
.text$mn:0000508D                 align 10h
.text$mn:0000508D _text$mn        ends
.text$mn:0000508D
.text$mn:00005090 ; ===========================================================================
.text$mn:00005090
.text$mn:00005090 ; Segment type: Pure code
.text$mn:00005090 ; Segment permissions: Read/Execute
.text$mn:00005090 _text$mn        segment para public 'CODE' use32
.text$mn:00005090                 assume cs:_text$mn
.text$mn:00005090                 ;org 5090h
.text$mn:00005090 ; COMDAT (pick any)
.text$mn:00005090                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005090
.text$mn:00005090 ; =============== S U B R O U T I N E =======================================
.text$mn:00005090
.text$mn:00005090 ; Attributes: bp-based frame
.text$mn:00005090
.text$mn:00005090 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00005090                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00005090 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00005090                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00005090
.text$mn:00005090 var_4           = dword ptr -4
.text$mn:00005090 arg_0           = dword ptr  8
.text$mn:00005090
.text$mn:00005090                 push    ebp
.text$mn:00005091                 mov     ebp, esp
.text$mn:00005093                 push    ecx
.text$mn:00005094                 mov     [ebp+var_4], ecx
.text$mn:00005097                 push    0
.text$mn:00005099                 mov     eax, [ebp+arg_0]
.text$mn:0000509C                 push    eax
.text$mn:0000509D                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:000050A2                 add     esp, 8
.text$mn:000050A5                 mov     esp, ebp
.text$mn:000050A7                 pop     ebp
.text$mn:000050A8                 retn    4
.text$mn:000050A8 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:000050A8
.text$mn:000050A8 ; ---------------------------------------------------------------------------
.text$mn:000050AB                 align 4
.text$mn:000050AB _text$mn        ends
.text$mn:000050AB
.text$mn:000050AC ; ===========================================================================
.text$mn:000050AC
.text$mn:000050AC ; Segment type: Pure code
.text$mn:000050AC ; Segment permissions: Read/Execute
.text$mn:000050AC _text$mn        segment para public 'CODE' use32
.text$mn:000050AC                 assume cs:_text$mn
.text$mn:000050AC                 ;org 50ACh
.text$mn:000050AC ; COMDAT (pick any)
.text$mn:000050AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000050AC
.text$mn:000050AC ; =============== S U B R O U T I N E =======================================
.text$mn:000050AC
.text$mn:000050AC ; Attributes: bp-based frame
.text$mn:000050AC
.text$mn:000050AC ; public: struct std::pair<int, int> * __thiscall std::allocator<struct std::pair<int, int>>::allocate(unsigned int)
.text$mn:000050AC                 public ?allocate@?$allocator@U?$pair@HH@std@@@std@@QAEPAU?$pair@HH@2@I@Z
.text$mn:000050AC ?allocate@?$allocator@U?$pair@HH@std@@@std@@QAEPAU?$pair@HH@2@I@Z proc near
.text$mn:000050AC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::pair<int,int>>>::allocate(uint)+Ep
.text$mn:000050AC
.text$mn:000050AC var_4           = dword ptr -4
.text$mn:000050AC arg_0           = dword ptr  8
.text$mn:000050AC
.text$mn:000050AC                 push    ebp
.text$mn:000050AD                 mov     ebp, esp
.text$mn:000050AF                 push    ecx
.text$mn:000050B0                 mov     [ebp+var_4], ecx
.text$mn:000050B3                 push    0
.text$mn:000050B5                 mov     eax, [ebp+arg_0]
.text$mn:000050B8                 push    eax
.text$mn:000050B9                 call    ??$_Allocate@U?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@IPAU10@@Z ; std::_Allocate<std::pair<int,int>>(uint,std::pair<int,int> *)
.text$mn:000050BE                 add     esp, 8
.text$mn:000050C1                 mov     esp, ebp
.text$mn:000050C3                 pop     ebp
.text$mn:000050C4                 retn    4
.text$mn:000050C4 ?allocate@?$allocator@U?$pair@HH@std@@@std@@QAEPAU?$pair@HH@2@I@Z endp
.text$mn:000050C4
.text$mn:000050C4 ; ---------------------------------------------------------------------------
.text$mn:000050C7                 align 4
.text$mn:000050C7 _text$mn        ends
.text$mn:000050C7
.text$mn:000050C8 ; ===========================================================================
.text$mn:000050C8
.text$mn:000050C8 ; Segment type: Pure code
.text$mn:000050C8 ; Segment permissions: Read/Execute
.text$mn:000050C8 _text$mn        segment para public 'CODE' use32
.text$mn:000050C8                 assume cs:_text$mn
.text$mn:000050C8                 ;org 50C8h
.text$mn:000050C8 ; COMDAT (pick any)
.text$mn:000050C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000050C8
.text$mn:000050C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000050C8
.text$mn:000050C8 ; Attributes: bp-based frame
.text$mn:000050C8
.text$mn:000050C8 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:000050C8                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:000050C8 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:000050C8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:000050C8                                         ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)+Ep
.text$mn:000050C8
.text$mn:000050C8 var_4           = dword ptr -4
.text$mn:000050C8 arg_0           = dword ptr  8
.text$mn:000050C8
.text$mn:000050C8                 push    ebp
.text$mn:000050C9                 mov     ebp, esp
.text$mn:000050CB                 push    ecx
.text$mn:000050CC                 mov     [ebp+var_4], ecx
.text$mn:000050CF                 push    0
.text$mn:000050D1                 mov     eax, [ebp+arg_0]
.text$mn:000050D4                 push    eax
.text$mn:000050D5                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:000050DA                 add     esp, 8
.text$mn:000050DD                 mov     esp, ebp
.text$mn:000050DF                 pop     ebp
.text$mn:000050E0                 retn    4
.text$mn:000050E0 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:000050E0
.text$mn:000050E0 ; ---------------------------------------------------------------------------
.text$mn:000050E3                 align 4
.text$mn:000050E3 _text$mn        ends
.text$mn:000050E3
.text$mn:000050E4 ; ===========================================================================
.text$mn:000050E4
.text$mn:000050E4 ; Segment type: Pure code
.text$mn:000050E4 ; Segment permissions: Read/Execute
.text$mn:000050E4 _text$mn        segment para public 'CODE' use32
.text$mn:000050E4                 assume cs:_text$mn
.text$mn:000050E4                 ;org 50E4h
.text$mn:000050E4 ; COMDAT (pick any)
.text$mn:000050E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000050E4
.text$mn:000050E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000050E4
.text$mn:000050E4 ; Attributes: bp-based frame
.text$mn:000050E4
.text$mn:000050E4 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::append(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &)
.text$mn:000050E4                 public ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
.text$mn:000050E4 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z proc near
.text$mn:000050E4                                         ; CODE XREF: XmlMatchedTagsHighlighter::findOpenTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+46p
.text$mn:000050E4                                         ; XmlMatchedTagsHighlighter::findCloseTag(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,int,int)+46p
.text$mn:000050E4
.text$mn:000050E4 var_4           = dword ptr -4
.text$mn:000050E4 arg_0           = dword ptr  8
.text$mn:000050E4
.text$mn:000050E4                 push    ebp
.text$mn:000050E5                 mov     ebp, esp
.text$mn:000050E7                 push    ecx
.text$mn:000050E8                 mov     [ebp+var_4], ecx
.text$mn:000050EB                 mov     eax, ds:?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; uint const std::basic_string<char,std::char_traits<char>,std::allocator<char>>::npos
.text$mn:000050F0                 push    eax             ; Size
.text$mn:000050F1                 push    0               ; int
.text$mn:000050F3                 mov     ecx, [ebp+arg_0]
.text$mn:000050F6                 push    ecx             ; int
.text$mn:000050F7                 mov     ecx, [ebp+var_4]
.text$mn:000050FA                 call    ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:000050FF                 mov     esp, ebp
.text$mn:00005101                 pop     ebp
.text$mn:00005102                 retn    4
.text$mn:00005102 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z endp
.text$mn:00005102
.text$mn:00005102 ; ---------------------------------------------------------------------------
.text$mn:00005105                 align 4
.text$mn:00005105 _text$mn        ends
.text$mn:00005105
.text$mn:00005108 ; ===========================================================================
.text$mn:00005108
.text$mn:00005108 ; Segment type: Pure code
.text$mn:00005108 ; Segment permissions: Read/Execute
.text$mn:00005108 _text$mn        segment para public 'CODE' use32
.text$mn:00005108                 assume cs:_text$mn
.text$mn:00005108                 ;org 5108h
.text$mn:00005108 ; COMDAT (pick any)
.text$mn:00005108                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005108
.text$mn:00005108 ; =============== S U B R O U T I N E =======================================
.text$mn:00005108
.text$mn:00005108 ; Attributes: bp-based frame
.text$mn:00005108
.text$mn:00005108 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(int, int, size_t Size)
.text$mn:00005108                 public ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00005108 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00005108                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+16p
.text$mn:00005108
.text$mn:00005108 var_8           = dword ptr -8
.text$mn:00005108 var_4           = dword ptr -4
.text$mn:00005108 arg_0           = dword ptr  8
.text$mn:00005108 arg_4           = dword ptr  0Ch
.text$mn:00005108 Size            = dword ptr  10h
.text$mn:00005108
.text$mn:00005108                 push    ebp
.text$mn:00005109                 mov     ebp, esp
.text$mn:0000510B                 sub     esp, 8
.text$mn:0000510E                 mov     [ebp+var_4], ecx
.text$mn:00005111                 mov     ecx, [ebp+arg_0]
.text$mn:00005114                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00005119                 cmp     eax, [ebp+arg_4]
.text$mn:0000511C                 jnb     short loc_5126
.text$mn:0000511E                 mov     ecx, [ebp+var_4]
.text$mn:00005121                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00005126
.text$mn:00005126 loc_5126:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00005126                 mov     ecx, [ebp+arg_0]
.text$mn:00005129                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000512E                 sub     eax, [ebp+arg_4]
.text$mn:00005131                 mov     [ebp+var_8], eax
.text$mn:00005134                 mov     eax, [ebp+var_8]
.text$mn:00005137                 cmp     eax, [ebp+Size]
.text$mn:0000513A                 jnb     short loc_5142
.text$mn:0000513C                 mov     ecx, [ebp+var_8]
.text$mn:0000513F                 mov     [ebp+Size], ecx
.text$mn:00005142
.text$mn:00005142 loc_5142:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00005142                 mov     edx, [ebp+var_4]
.text$mn:00005145                 mov     eax, ds:?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; uint const std::basic_string<char,std::char_traits<char>,std::allocator<char>>::npos
.text$mn:0000514A                 sub     eax, [edx+14h]
.text$mn:0000514D                 cmp     eax, [ebp+Size]
.text$mn:00005150                 ja      short loc_515A
.text$mn:00005152                 mov     ecx, [ebp+var_4]
.text$mn:00005155                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:0000515A
.text$mn:0000515A loc_515A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+48j
.text$mn:0000515A                 cmp     [ebp+Size], 0
.text$mn:0000515E                 jbe     short loc_51B4
.text$mn:00005160                 mov     ecx, [ebp+var_4]
.text$mn:00005163                 mov     edx, [ecx+14h]
.text$mn:00005166                 add     edx, [ebp+Size]
.text$mn:00005169                 mov     [ebp+var_8], edx
.text$mn:0000516C                 push    0
.text$mn:0000516E                 mov     eax, [ebp+var_8]
.text$mn:00005171                 push    eax
.text$mn:00005172                 mov     ecx, [ebp+var_4]
.text$mn:00005175                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000517A                 movzx   ecx, al
.text$mn:0000517D                 test    ecx, ecx
.text$mn:0000517F                 jz      short loc_51B4
.text$mn:00005181                 mov     edx, [ebp+Size]
.text$mn:00005184                 push    edx             ; Size
.text$mn:00005185                 mov     ecx, [ebp+arg_0]
.text$mn:00005188                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000518D                 add     eax, [ebp+arg_4]
.text$mn:00005190                 push    eax             ; Src
.text$mn:00005191                 mov     ecx, [ebp+var_4]
.text$mn:00005194                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00005199                 mov     ecx, [ebp+var_4]
.text$mn:0000519C                 add     eax, [ecx+14h]
.text$mn:0000519F                 push    eax             ; Dst
.text$mn:000051A0                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000051A5                 add     esp, 0Ch
.text$mn:000051A8                 mov     edx, [ebp+var_8]
.text$mn:000051AB                 push    edx
.text$mn:000051AC                 mov     ecx, [ebp+var_4]
.text$mn:000051AF                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000051B4
.text$mn:000051B4 loc_51B4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+56j
.text$mn:000051B4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+77j
.text$mn:000051B4                 mov     eax, [ebp+var_4]
.text$mn:000051B7                 mov     esp, ebp
.text$mn:000051B9                 pop     ebp
.text$mn:000051BA                 retn    0Ch
.text$mn:000051BA ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:000051BA
.text$mn:000051BA ; ---------------------------------------------------------------------------
.text$mn:000051BD                 align 10h
.text$mn:000051BD _text$mn        ends
.text$mn:000051BD
.text$mn:000051C0 ; ===========================================================================
.text$mn:000051C0
.text$mn:000051C0 ; Segment type: Pure code
.text$mn:000051C0 ; Segment permissions: Read/Execute
.text$mn:000051C0 _text$mn        segment para public 'CODE' use32
.text$mn:000051C0                 assume cs:_text$mn
.text$mn:000051C0                 ;org 51C0h
.text$mn:000051C0 ; COMDAT (pick any)
.text$mn:000051C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000051C0
.text$mn:000051C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000051C0
.text$mn:000051C0 ; Attributes: bp-based frame
.text$mn:000051C0
.text$mn:000051C0 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:000051C0                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:000051C0 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:000051C0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:000051C0
.text$mn:000051C0 Size            = dword ptr -8
.text$mn:000051C0 var_4           = dword ptr -4
.text$mn:000051C0 arg_0           = dword ptr  8
.text$mn:000051C0 arg_4           = dword ptr  0Ch
.text$mn:000051C0 arg_8           = dword ptr  10h
.text$mn:000051C0
.text$mn:000051C0                 push    ebp
.text$mn:000051C1                 mov     ebp, esp
.text$mn:000051C3                 sub     esp, 8
.text$mn:000051C6                 mov     [ebp+var_4], ecx
.text$mn:000051C9                 mov     ecx, [ebp+arg_0]
.text$mn:000051CC                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:000051D1                 cmp     eax, [ebp+arg_4]
.text$mn:000051D4                 jnb     short loc_51DE
.text$mn:000051D6                 mov     ecx, [ebp+var_4]
.text$mn:000051D9                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000051DE
.text$mn:000051DE loc_51DE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:000051DE                 mov     ecx, [ebp+arg_0]
.text$mn:000051E1                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:000051E6                 sub     eax, [ebp+arg_4]
.text$mn:000051E9                 mov     [ebp+Size], eax
.text$mn:000051EC                 mov     eax, [ebp+arg_8]
.text$mn:000051EF                 cmp     eax, [ebp+Size]
.text$mn:000051F2                 jnb     short loc_51FA
.text$mn:000051F4                 mov     ecx, [ebp+arg_8]
.text$mn:000051F7                 mov     [ebp+Size], ecx
.text$mn:000051FA
.text$mn:000051FA loc_51FA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:000051FA                 mov     edx, [ebp+var_4]
.text$mn:000051FD                 cmp     edx, [ebp+arg_0]
.text$mn:00005200                 jnz     short loc_5221
.text$mn:00005202                 mov     eax, [ebp+arg_4]
.text$mn:00005205                 add     eax, [ebp+Size]
.text$mn:00005208                 push    eax
.text$mn:00005209                 mov     ecx, [ebp+var_4]
.text$mn:0000520C                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00005211                 mov     ecx, [ebp+arg_4]
.text$mn:00005214                 push    ecx
.text$mn:00005215                 push    0
.text$mn:00005217                 mov     ecx, [ebp+var_4]
.text$mn:0000521A                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:0000521F                 jmp     short loc_5263
.text$mn:00005221 ; ---------------------------------------------------------------------------
.text$mn:00005221
.text$mn:00005221 loc_5221:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00005221                 push    0
.text$mn:00005223                 mov     edx, [ebp+Size]
.text$mn:00005226                 push    edx
.text$mn:00005227                 mov     ecx, [ebp+var_4]
.text$mn:0000522A                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000522F                 movzx   eax, al
.text$mn:00005232                 test    eax, eax
.text$mn:00005234                 jz      short loc_5263
.text$mn:00005236                 mov     ecx, [ebp+Size]
.text$mn:00005239                 push    ecx             ; Size
.text$mn:0000523A                 mov     ecx, [ebp+arg_0]
.text$mn:0000523D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00005242                 add     eax, [ebp+arg_4]
.text$mn:00005245                 push    eax             ; Src
.text$mn:00005246                 mov     ecx, [ebp+var_4]
.text$mn:00005249                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000524E                 push    eax             ; Dst
.text$mn:0000524F                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00005254                 add     esp, 0Ch
.text$mn:00005257                 mov     edx, [ebp+Size]
.text$mn:0000525A                 push    edx
.text$mn:0000525B                 mov     ecx, [ebp+var_4]
.text$mn:0000525E                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00005263
.text$mn:00005263 loc_5263:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00005263                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00005263                 mov     eax, [ebp+var_4]
.text$mn:00005266                 mov     esp, ebp
.text$mn:00005268                 pop     ebp
.text$mn:00005269                 retn    0Ch
.text$mn:00005269 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00005269
.text$mn:00005269 _text$mn        ends
.text$mn:00005269
.text$mn:0000526C ; ===========================================================================
.text$mn:0000526C
.text$mn:0000526C ; Segment type: Pure code
.text$mn:0000526C ; Segment permissions: Read/Execute
.text$mn:0000526C _text$mn        segment para public 'CODE' use32
.text$mn:0000526C                 assume cs:_text$mn
.text$mn:0000526C                 ;org 526Ch
.text$mn:0000526C ; COMDAT (pick any)
.text$mn:0000526C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000526C
.text$mn:0000526C ; =============== S U B R O U T I N E =======================================
.text$mn:0000526C
.text$mn:0000526C ; Attributes: bp-based frame
.text$mn:0000526C
.text$mn:0000526C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:0000526C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:0000526C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:0000526C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:0000526C
.text$mn:0000526C var_4           = dword ptr -4
.text$mn:0000526C Str             = dword ptr  8
.text$mn:0000526C
.text$mn:0000526C                 push    ebp
.text$mn:0000526D                 mov     ebp, esp
.text$mn:0000526F                 push    ecx
.text$mn:00005270                 mov     [ebp+var_4], ecx
.text$mn:00005273                 push    490h            ; unsigned int
.text$mn:00005278                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000527D                 mov     eax, [ebp+Str]
.text$mn:00005280                 push    eax             ; int
.text$mn:00005281                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00005286                 add     esp, 0Ch
.text$mn:00005289                 mov     ecx, [ebp+Str]
.text$mn:0000528C                 push    ecx             ; Str
.text$mn:0000528D                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00005292                 add     esp, 4
.text$mn:00005295                 push    eax             ; Size
.text$mn:00005296                 mov     edx, [ebp+Str]
.text$mn:00005299                 push    edx             ; Src
.text$mn:0000529A                 mov     ecx, [ebp+var_4]
.text$mn:0000529D                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:000052A2                 mov     esp, ebp
.text$mn:000052A4                 pop     ebp
.text$mn:000052A5                 retn    4
.text$mn:000052A5 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:000052A5
.text$mn:000052A5 _text$mn        ends
.text$mn:000052A5
.text$mn:000052A8 ; ===========================================================================
.text$mn:000052A8
.text$mn:000052A8 ; Segment type: Pure code
.text$mn:000052A8 ; Segment permissions: Read/Execute
.text$mn:000052A8 _text$mn        segment para public 'CODE' use32
.text$mn:000052A8                 assume cs:_text$mn
.text$mn:000052A8                 ;org 52A8h
.text$mn:000052A8 ; COMDAT (pick any)
.text$mn:000052A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000052A8
.text$mn:000052A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000052A8
.text$mn:000052A8 ; Attributes: bp-based frame
.text$mn:000052A8
.text$mn:000052A8 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:000052A8                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:000052A8 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:000052A8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:000052A8
.text$mn:000052A8 var_4           = dword ptr -4
.text$mn:000052A8 Src             = dword ptr  8
.text$mn:000052A8 Size            = dword ptr  0Ch
.text$mn:000052A8
.text$mn:000052A8                 push    ebp
.text$mn:000052A9                 mov     ebp, esp
.text$mn:000052AB                 push    ecx
.text$mn:000052AC                 mov     [ebp+var_4], ecx
.text$mn:000052AF                 cmp     [ebp+Size], 0
.text$mn:000052B3                 jz      short loc_52CB
.text$mn:000052B5                 push    47Fh            ; unsigned int
.text$mn:000052BA                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000052BF                 mov     eax, [ebp+Src]
.text$mn:000052C2                 push    eax             ; int
.text$mn:000052C3                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:000052C8                 add     esp, 0Ch
.text$mn:000052CB
.text$mn:000052CB loc_52CB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:000052CB                 mov     ecx, [ebp+Src]
.text$mn:000052CE                 push    ecx
.text$mn:000052CF                 mov     ecx, [ebp+var_4]
.text$mn:000052D2                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:000052D7                 movzx   edx, al
.text$mn:000052DA                 test    edx, edx
.text$mn:000052DC                 jz      short loc_52FE
.text$mn:000052DE                 mov     eax, [ebp+Size]
.text$mn:000052E1                 push    eax
.text$mn:000052E2                 mov     ecx, [ebp+var_4]
.text$mn:000052E5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000052EA                 mov     ecx, [ebp+Src]
.text$mn:000052ED                 sub     ecx, eax
.text$mn:000052EF                 push    ecx
.text$mn:000052F0                 mov     edx, [ebp+var_4]
.text$mn:000052F3                 push    edx
.text$mn:000052F4                 mov     ecx, [ebp+var_4]
.text$mn:000052F7                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:000052FC                 jmp     short loc_533B
.text$mn:000052FE ; ---------------------------------------------------------------------------
.text$mn:000052FE
.text$mn:000052FE loc_52FE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:000052FE                 push    0
.text$mn:00005300                 mov     eax, [ebp+Size]
.text$mn:00005303                 push    eax
.text$mn:00005304                 mov     ecx, [ebp+var_4]
.text$mn:00005307                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000530C                 movzx   ecx, al
.text$mn:0000530F                 test    ecx, ecx
.text$mn:00005311                 jz      short loc_5338
.text$mn:00005313                 mov     edx, [ebp+Size]
.text$mn:00005316                 push    edx             ; Size
.text$mn:00005317                 mov     eax, [ebp+Src]
.text$mn:0000531A                 push    eax             ; Src
.text$mn:0000531B                 mov     ecx, [ebp+var_4]
.text$mn:0000531E                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00005323                 push    eax             ; Dst
.text$mn:00005324                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00005329                 add     esp, 0Ch
.text$mn:0000532C                 mov     ecx, [ebp+Size]
.text$mn:0000532F                 push    ecx
.text$mn:00005330                 mov     ecx, [ebp+var_4]
.text$mn:00005333                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00005338
.text$mn:00005338 loc_5338:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00005338                 mov     eax, [ebp+var_4]
.text$mn:0000533B
.text$mn:0000533B loc_533B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:0000533B                 mov     esp, ebp
.text$mn:0000533D                 pop     ebp
.text$mn:0000533E                 retn    8
.text$mn:0000533E ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:0000533E
.text$mn:0000533E ; ---------------------------------------------------------------------------
.text$mn:00005341                 align 4
.text$mn:00005341 _text$mn        ends
.text$mn:00005341
.text$mn:00005344 ; ===========================================================================
.text$mn:00005344
.text$mn:00005344 ; Segment type: Pure code
.text$mn:00005344 ; Segment permissions: Read/Execute
.text$mn:00005344 _text$mn        segment para public 'CODE' use32
.text$mn:00005344                 assume cs:_text$mn
.text$mn:00005344                 ;org 5344h
.text$mn:00005344 ; COMDAT (pick any)
.text$mn:00005344                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005344
.text$mn:00005344 ; =============== S U B R O U T I N E =======================================
.text$mn:00005344
.text$mn:00005344 ; Attributes: bp-based frame
.text$mn:00005344
.text$mn:00005344 ; int __cdecl std::char_traits<char>::assign(void *Dst, size_t Size, char)
.text$mn:00005344                 public ?assign@?$char_traits@D@std@@SAPADPADID@Z
.text$mn:00005344 ?assign@?$char_traits@D@std@@SAPADPADID@Z proc near
.text$mn:00005344                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Chassign(uint,uint,char)+3Cp
.text$mn:00005344
.text$mn:00005344 Dst             = dword ptr  8
.text$mn:00005344 Size            = dword ptr  0Ch
.text$mn:00005344 arg_8           = byte ptr  10h
.text$mn:00005344
.text$mn:00005344                 push    ebp
.text$mn:00005345                 mov     ebp, esp
.text$mn:00005347                 mov     eax, [ebp+Size]
.text$mn:0000534A                 push    eax             ; Size
.text$mn:0000534B                 movsx   ecx, [ebp+arg_8]
.text$mn:0000534F                 push    ecx             ; Val
.text$mn:00005350                 mov     edx, [ebp+Dst]
.text$mn:00005353                 push    edx             ; Dst
.text$mn:00005354                 call    _memset
.text$mn:00005359                 add     esp, 0Ch
.text$mn:0000535C                 pop     ebp
.text$mn:0000535D                 retn
.text$mn:0000535D ?assign@?$char_traits@D@std@@SAPADPADID@Z endp
.text$mn:0000535D
.text$mn:0000535D ; ---------------------------------------------------------------------------
.text$mn:0000535E                 align 10h
.text$mn:0000535E _text$mn        ends
.text$mn:0000535E
.text$mn:00005360 ; ===========================================================================
.text$mn:00005360
.text$mn:00005360 ; Segment type: Pure code
.text$mn:00005360 ; Segment permissions: Read/Execute
.text$mn:00005360 _text$mn        segment para public 'CODE' use32
.text$mn:00005360                 assume cs:_text$mn
.text$mn:00005360                 ;org 5360h
.text$mn:00005360 ; COMDAT (pick any)
.text$mn:00005360                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005360
.text$mn:00005360 ; =============== S U B R O U T I N E =======================================
.text$mn:00005360
.text$mn:00005360 ; Attributes: bp-based frame
.text$mn:00005360
.text$mn:00005360 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00005360                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00005360 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00005360                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Chassign(uint,uint,char)+1Dp
.text$mn:00005360                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00005360
.text$mn:00005360 arg_0           = dword ptr  8
.text$mn:00005360 arg_4           = dword ptr  0Ch
.text$mn:00005360
.text$mn:00005360                 push    ebp
.text$mn:00005361                 mov     ebp, esp
.text$mn:00005363                 mov     eax, [ebp+arg_0]
.text$mn:00005366                 mov     ecx, [ebp+arg_4]
.text$mn:00005369                 mov     dl, [ecx]
.text$mn:0000536B                 mov     [eax], dl
.text$mn:0000536D                 pop     ebp
.text$mn:0000536E                 retn
.text$mn:0000536E ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:0000536E
.text$mn:0000536E ; ---------------------------------------------------------------------------
.text$mn:0000536F                 align 10h
.text$mn:0000536F _text$mn        ends
.text$mn:0000536F
.text$mn:00005370 ; ===========================================================================
.text$mn:00005370
.text$mn:00005370 ; Segment type: Pure code
.text$mn:00005370 ; Segment permissions: Read/Execute
.text$mn:00005370 _text$mn        segment para public 'CODE' use32
.text$mn:00005370                 assume cs:_text$mn
.text$mn:00005370                 ;org 5370h
.text$mn:00005370 ; COMDAT (pick any)
.text$mn:00005370                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005370
.text$mn:00005370 ; =============== S U B R O U T I N E =======================================
.text$mn:00005370
.text$mn:00005370 ; Attributes: bp-based frame
.text$mn:00005370
.text$mn:00005370 ; public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<char>>> __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::begin(void)
.text$mn:00005370                 public ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
.text$mn:00005370 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ proc near
.text$mn:00005370                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::insert(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>,char)+3Dp
.text$mn:00005370                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::insert(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>,char)+CEp
.text$mn:00005370
.text$mn:00005370 var_14          = dword ptr -14h
.text$mn:00005370 var_10          = dword ptr -10h
.text$mn:00005370 var_C           = dword ptr -0Ch
.text$mn:00005370 var_4           = dword ptr -4
.text$mn:00005370 arg_0           = dword ptr  8
.text$mn:00005370
.text$mn:00005370                 push    ebp
.text$mn:00005371                 mov     ebp, esp
.text$mn:00005373                 push    0FFFFFFFFh
.text$mn:00005375                 push    offset __ehhandler$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
.text$mn:0000537A                 mov     eax, large fs:0
.text$mn:00005380                 push    eax
.text$mn:00005381                 sub     esp, 8
.text$mn:00005384                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005389                 xor     eax, ebp
.text$mn:0000538B                 push    eax
.text$mn:0000538C                 lea     eax, [ebp+var_C]
.text$mn:0000538F                 mov     large fs:0, eax
.text$mn:00005395                 mov     [ebp+var_10], ecx
.text$mn:00005398                 mov     [ebp+var_14], 0
.text$mn:0000539F                 mov     eax, [ebp+var_10]
.text$mn:000053A2                 push    eax             ; struct std::_Container_base12 *
.text$mn:000053A3                 mov     ecx, [ebp+var_10]
.text$mn:000053A6                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000053AB                 push    eax             ; int
.text$mn:000053AC                 mov     ecx, [ebp+arg_0]
.text$mn:000053AF                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::_String_iterator<std::_String_val<std::_Simple_types<char>>>(char *,std::_Container_base12 const *)
.text$mn:000053B4                 mov     [ebp+var_4], 0
.text$mn:000053BB                 mov     ecx, [ebp+var_14]
.text$mn:000053BE                 or      ecx, 1
.text$mn:000053C1                 mov     [ebp+var_14], ecx
.text$mn:000053C4                 mov     eax, [ebp+arg_0]
.text$mn:000053C7                 mov     ecx, [ebp+var_C]
.text$mn:000053CA                 mov     large fs:0, ecx
.text$mn:000053D1                 pop     ecx
.text$mn:000053D2                 mov     esp, ebp
.text$mn:000053D4                 pop     ebp
.text$mn:000053D5                 retn    4
.text$mn:000053D5 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ endp
.text$mn:000053D5
.text$mn:000053D5 _text$mn        ends
.text$mn:000053D5
.text$x:000053D8 ; ===========================================================================
.text$x:000053D8
.text$x:000053D8 ; Segment type: Pure code
.text$x:000053D8 ; Segment permissions: Read/Execute
.text$x:000053D8 _text$x         segment para public 'CODE' use32
.text$x:000053D8                 assume cs:_text$x
.text$x:000053D8                 ;org 53D8h
.text$x:000053D8 ; COMDAT (pick associative to section at 5370)
.text$x:000053D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000053D8
.text$x:000053D8 ; =============== S U B R O U T I N E =======================================
.text$x:000053D8
.text$x:000053D8
.text$x:000053D8 __unwindfunclet$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ$0 proc near
.text$x:000053D8                                         ; DATA XREF: .xdata$x:00006368o
.text$x:000053D8                 mov     eax, [ebp-14h]
.text$x:000053DB                 and     eax, 1
.text$x:000053DE                 jz      $LN4
.text$x:000053E4                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:000053E8                 mov     ecx, [ebp+8]
.text$x:000053EB                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$x:000053F0 ; ---------------------------------------------------------------------------
.text$x:000053F0
.text$x:000053F0 $LN4:                                   ; CODE XREF: __unwindfunclet$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ$0+6j
.text$x:000053F0                 retn
.text$x:000053F0 __unwindfunclet$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ$0 endp
.text$x:000053F0
.text$x:000053F1
.text$x:000053F1 ; =============== S U B R O U T I N E =======================================
.text$x:000053F1
.text$x:000053F1
.text$x:000053F1 __ehhandler$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ proc near
.text$x:000053F1                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::begin(void)+5o
.text$x:000053F1
.text$x:000053F1 arg_4           = dword ptr  8
.text$x:000053F1
.text$x:000053F1                 mov     edx, [esp+arg_4]
.text$x:000053F5                 lea     eax, [edx+0Ch]
.text$x:000053F8                 mov     ecx, [edx-0Ch]
.text$x:000053FB                 xor     ecx, eax
.text$x:000053FD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005402                 mov     eax, offset __ehfuncinfo$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
.text$x:00005407                 jmp     ___CxxFrameHandler3
.text$x:00005407 __ehhandler$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ endp
.text$x:00005407
.text$x:00005407 _text$x         ends
.text$x:00005407
.text$mn:0000540C ; ===========================================================================
.text$mn:0000540C
.text$mn:0000540C ; Segment type: Pure code
.text$mn:0000540C ; Segment permissions: Read/Execute
.text$mn:0000540C _text$mn        segment para public 'CODE' use32
.text$mn:0000540C                 assume cs:_text$mn
.text$mn:0000540C                 ;org 540Ch
.text$mn:0000540C ; COMDAT (pick any)
.text$mn:0000540C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000540C
.text$mn:0000540C ; =============== S U B R O U T I N E =======================================
.text$mn:0000540C
.text$mn:0000540C ; Attributes: bp-based frame
.text$mn:0000540C
.text$mn:0000540C ; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::c_str(void)const
.text$mn:0000540C                 public ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
.text$mn:0000540C ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
.text$mn:0000540C                                         ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+11Fp
.text$mn:0000540C                                         ; XmlMatchedTagsHighlighter::tagMatch(bool)+13Fp ...
.text$mn:0000540C
.text$mn:0000540C var_4           = dword ptr -4
.text$mn:0000540C
.text$mn:0000540C                 push    ebp
.text$mn:0000540D                 mov     ebp, esp
.text$mn:0000540F                 push    ecx
.text$mn:00005410                 mov     [ebp+var_4], ecx
.text$mn:00005413                 mov     ecx, [ebp+var_4]
.text$mn:00005416                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000541B                 mov     esp, ebp
.text$mn:0000541D                 pop     ebp
.text$mn:0000541E                 retn
.text$mn:0000541E ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp
.text$mn:0000541E
.text$mn:0000541E ; ---------------------------------------------------------------------------
.text$mn:0000541F                 align 10h
.text$mn:0000541F _text$mn        ends
.text$mn:0000541F
.text$mn:00005420 ; ===========================================================================
.text$mn:00005420
.text$mn:00005420 ; Segment type: Pure code
.text$mn:00005420 ; Segment permissions: Read/Execute
.text$mn:00005420 _text$mn        segment para public 'CODE' use32
.text$mn:00005420                 assume cs:_text$mn
.text$mn:00005420                 ;org 5420h
.text$mn:00005420 ; COMDAT (pick any)
.text$mn:00005420                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005420
.text$mn:00005420 ; =============== S U B R O U T I N E =======================================
.text$mn:00005420
.text$mn:00005420 ; Attributes: bp-based frame
.text$mn:00005420
.text$mn:00005420 ; public: unsigned int __thiscall std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>::capacity(void)const
.text$mn:00005420                 public ?capacity@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ
.text$mn:00005420 ?capacity@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ proc near
.text$mn:00005420                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Grow_to(uint)+Cp
.text$mn:00005420
.text$mn:00005420 var_4           = dword ptr -4
.text$mn:00005420
.text$mn:00005420                 push    ebp
.text$mn:00005421                 mov     ebp, esp
.text$mn:00005423                 push    ecx
.text$mn:00005424                 mov     [ebp+var_4], ecx
.text$mn:00005427                 mov     eax, [ebp+var_4]
.text$mn:0000542A                 mov     ecx, [ebp+var_4]
.text$mn:0000542D                 mov     eax, [eax+0Ch]
.text$mn:00005430                 sub     eax, [ecx+4]
.text$mn:00005433                 sar     eax, 3
.text$mn:00005436                 mov     esp, ebp
.text$mn:00005438                 pop     ebp
.text$mn:00005439                 retn
.text$mn:00005439 ?capacity@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ endp
.text$mn:00005439
.text$mn:00005439 ; ---------------------------------------------------------------------------
.text$mn:0000543A                 align 4
.text$mn:0000543A _text$mn        ends
.text$mn:0000543A
.text$mn:0000543C ; ===========================================================================
.text$mn:0000543C
.text$mn:0000543C ; Segment type: Pure code
.text$mn:0000543C ; Segment permissions: Read/Execute
.text$mn:0000543C _text$mn        segment para public 'CODE' use32
.text$mn:0000543C                 assume cs:_text$mn
.text$mn:0000543C                 ;org 543Ch
.text$mn:0000543C ; COMDAT (pick any)
.text$mn:0000543C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000543C
.text$mn:0000543C ; =============== S U B R O U T I N E =======================================
.text$mn:0000543C
.text$mn:0000543C ; Attributes: bp-based frame
.text$mn:0000543C
.text$mn:0000543C ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:0000543C                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:0000543C ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:0000543C                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:0000543C
.text$mn:0000543C var_4           = dword ptr -4
.text$mn:0000543C
.text$mn:0000543C                 push    ebp
.text$mn:0000543D                 mov     ebp, esp
.text$mn:0000543F                 push    ecx
.text$mn:00005440                 mov     [ebp+var_4], ecx
.text$mn:00005443                 mov     eax, [ebp+var_4]
.text$mn:00005446                 mov     eax, [eax+4]
.text$mn:00005449                 mov     esp, ebp
.text$mn:0000544B                 pop     ebp
.text$mn:0000544C                 retn
.text$mn:0000544C ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:0000544C
.text$mn:0000544C ; ---------------------------------------------------------------------------
.text$mn:0000544D                 align 10h
.text$mn:0000544D _text$mn        ends
.text$mn:0000544D
.text$mn:00005450 ; ===========================================================================
.text$mn:00005450
.text$mn:00005450 ; Segment type: Pure code
.text$mn:00005450 ; Segment permissions: Read/Execute
.text$mn:00005450 _text$mn        segment para public 'CODE' use32
.text$mn:00005450                 assume cs:_text$mn
.text$mn:00005450                 ;org 5450h
.text$mn:00005450 ; COMDAT (pick any)
.text$mn:00005450                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005450
.text$mn:00005450 ; =============== S U B R O U T I N E =======================================
.text$mn:00005450
.text$mn:00005450 ; Attributes: bp-based frame
.text$mn:00005450
.text$mn:00005450 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00005450                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00005450 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00005450                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00005450                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00005450
.text$mn:00005450 var_4           = dword ptr -4
.text$mn:00005450
.text$mn:00005450                 push    ebp
.text$mn:00005451                 mov     ebp, esp
.text$mn:00005453                 push    ecx
.text$mn:00005454                 mov     [ebp+var_4], ecx
.text$mn:00005457                 mov     eax, [ebp+var_4]
.text$mn:0000545A                 mov     eax, [eax+4]
.text$mn:0000545D                 mov     esp, ebp
.text$mn:0000545F                 pop     ebp
.text$mn:00005460                 retn
.text$mn:00005460 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00005460
.text$mn:00005460 ; ---------------------------------------------------------------------------
.text$mn:00005461                 align 4
.text$mn:00005461 _text$mn        ends
.text$mn:00005461
.text$mn:00005464 ; ===========================================================================
.text$mn:00005464
.text$mn:00005464 ; Segment type: Pure code
.text$mn:00005464 ; Segment permissions: Read/Execute
.text$mn:00005464 _text$mn        segment para public 'CODE' use32
.text$mn:00005464                 assume cs:_text$mn
.text$mn:00005464                 ;org 5464h
.text$mn:00005464 ; COMDAT (pick any)
.text$mn:00005464                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005464
.text$mn:00005464 ; =============== S U B R O U T I N E =======================================
.text$mn:00005464
.text$mn:00005464 ; Attributes: bp-based frame
.text$mn:00005464
.text$mn:00005464 ; void __thiscall ScintillaEditView::clearIndicator(ScintillaEditView *this, int)
.text$mn:00005464                 public ?clearIndicator@ScintillaEditView@@QAEXH@Z
.text$mn:00005464 ?clearIndicator@ScintillaEditView@@QAEXH@Z proc near
.text$mn:00005464                                         ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+36p
.text$mn:00005464                                         ; XmlMatchedTagsHighlighter::tagMatch(bool)+42p
.text$mn:00005464
.text$mn:00005464 var_C           = dword ptr -0Ch
.text$mn:00005464 var_8           = dword ptr -8
.text$mn:00005464 var_4           = dword ptr -4
.text$mn:00005464 arg_0           = dword ptr  8
.text$mn:00005464
.text$mn:00005464                 push    ebp
.text$mn:00005465                 mov     ebp, esp
.text$mn:00005467                 sub     esp, 0Ch
.text$mn:0000546A                 mov     [ebp+var_4], ecx
.text$mn:0000546D                 mov     [ebp+var_8], 0
.text$mn:00005474                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005477                 call    ?getCurrentDocLen@ScintillaEditView@@QBEHXZ ; ScintillaEditView::getCurrentDocLen(void)
.text$mn:0000547C                 mov     [ebp+var_C], eax
.text$mn:0000547F                 push    0               ; __int32
.text$mn:00005481                 mov     eax, [ebp+arg_0]
.text$mn:00005484                 push    eax             ; unsigned int
.text$mn:00005485                 push    9C4h            ; unsigned int
.text$mn:0000548A                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000548D                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00005492                 mov     ecx, [ebp+var_C]
.text$mn:00005495                 sub     ecx, [ebp+var_8]
.text$mn:00005498                 push    ecx             ; __int32
.text$mn:00005499                 mov     edx, [ebp+var_8]
.text$mn:0000549C                 push    edx             ; unsigned int
.text$mn:0000549D                 push    9C9h            ; unsigned int
.text$mn:000054A2                 mov     ecx, [ebp+var_4] ; this
.text$mn:000054A5                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000054AA                 mov     esp, ebp
.text$mn:000054AC                 pop     ebp
.text$mn:000054AD                 retn    4
.text$mn:000054AD ?clearIndicator@ScintillaEditView@@QAEXH@Z endp
.text$mn:000054AD
.text$mn:000054AD _text$mn        ends
.text$mn:000054AD
.text$mn:000054B0 ; ===========================================================================
.text$mn:000054B0
.text$mn:000054B0 ; Segment type: Pure code
.text$mn:000054B0 ; Segment permissions: Read/Execute
.text$mn:000054B0 _text$mn        segment para public 'CODE' use32
.text$mn:000054B0                 assume cs:_text$mn
.text$mn:000054B0                 ;org 54B0h
.text$mn:000054B0 ; COMDAT (pick any)
.text$mn:000054B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054B0
.text$mn:000054B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000054B0
.text$mn:000054B0 ; Attributes: bp-based frame
.text$mn:000054B0
.text$mn:000054B0 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:000054B0                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000054B0 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:000054B0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:000054B0
.text$mn:000054B0 var_4           = dword ptr -4
.text$mn:000054B0 Dst             = dword ptr  8
.text$mn:000054B0 Src             = dword ptr  0Ch
.text$mn:000054B0 Size            = dword ptr  10h
.text$mn:000054B0
.text$mn:000054B0                 push    ebp
.text$mn:000054B1                 mov     ebp, esp
.text$mn:000054B3                 push    ecx
.text$mn:000054B4                 cmp     [ebp+Size], 0
.text$mn:000054B8                 jnz     short loc_54C2
.text$mn:000054BA                 mov     eax, [ebp+Dst]
.text$mn:000054BD                 mov     [ebp+var_4], eax
.text$mn:000054C0                 jmp     short loc_54D9
.text$mn:000054C2 ; ---------------------------------------------------------------------------
.text$mn:000054C2
.text$mn:000054C2 loc_54C2:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:000054C2                 mov     ecx, [ebp+Size]
.text$mn:000054C5                 push    ecx             ; Size
.text$mn:000054C6                 mov     edx, [ebp+Src]
.text$mn:000054C9                 push    edx             ; Src
.text$mn:000054CA                 mov     eax, [ebp+Dst]
.text$mn:000054CD                 push    eax             ; Dst
.text$mn:000054CE                 call    _memcpy
.text$mn:000054D3                 add     esp, 0Ch
.text$mn:000054D6                 mov     [ebp+var_4], eax
.text$mn:000054D9
.text$mn:000054D9 loc_54D9:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:000054D9                 mov     eax, [ebp+var_4]
.text$mn:000054DC                 mov     esp, ebp
.text$mn:000054DE                 pop     ebp
.text$mn:000054DF                 retn
.text$mn:000054DF ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:000054DF
.text$mn:000054DF _text$mn        ends
.text$mn:000054DF
.text$mn:000054E0 ; ===========================================================================
.text$mn:000054E0
.text$mn:000054E0 ; Segment type: Pure code
.text$mn:000054E0 ; Segment permissions: Read/Execute
.text$mn:000054E0 _text$mn        segment para public 'CODE' use32
.text$mn:000054E0                 assume cs:_text$mn
.text$mn:000054E0                 ;org 54E0h
.text$mn:000054E0 ; COMDAT (pick any)
.text$mn:000054E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054E0
.text$mn:000054E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000054E0
.text$mn:000054E0 ; Attributes: bp-based frame
.text$mn:000054E0
.text$mn:000054E0 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:000054E0                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:000054E0 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:000054E0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:000054E0
.text$mn:000054E0 var_4           = dword ptr -4
.text$mn:000054E0 arg_0           = dword ptr  8
.text$mn:000054E0 arg_4           = dword ptr  0Ch
.text$mn:000054E0
.text$mn:000054E0                 push    ebp
.text$mn:000054E1                 mov     ebp, esp
.text$mn:000054E3                 push    ecx
.text$mn:000054E4                 mov     [ebp+var_4], ecx
.text$mn:000054E7                 mov     eax, [ebp+arg_4]
.text$mn:000054EA                 push    eax             ; int
.text$mn:000054EB                 mov     ecx, [ebp+arg_0]
.text$mn:000054EE                 push    ecx             ; void *
.text$mn:000054EF                 mov     ecx, [ebp+var_4]
.text$mn:000054F2                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:000054F7                 mov     esp, ebp
.text$mn:000054F9                 pop     ebp
.text$mn:000054FA                 retn    8
.text$mn:000054FA ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:000054FA
.text$mn:000054FA ; ---------------------------------------------------------------------------
.text$mn:000054FD                 align 10h
.text$mn:000054FD _text$mn        ends
.text$mn:000054FD
.text$mn:00005500 ; ===========================================================================
.text$mn:00005500
.text$mn:00005500 ; Segment type: Pure code
.text$mn:00005500 ; Segment permissions: Read/Execute
.text$mn:00005500 _text$mn        segment para public 'CODE' use32
.text$mn:00005500                 assume cs:_text$mn
.text$mn:00005500                 ;org 5500h
.text$mn:00005500 ; COMDAT (pick any)
.text$mn:00005500                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005500
.text$mn:00005500 ; =============== S U B R O U T I N E =======================================
.text$mn:00005500
.text$mn:00005500 ; Attributes: bp-based frame
.text$mn:00005500
.text$mn:00005500 ; int __stdcall std::_Wrap_alloc<std::allocator<std::pair<int,int>>>::deallocate(void *, int)
.text$mn:00005500                 public ?deallocate@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAEXPAU?$pair@HH@2@I@Z
.text$mn:00005500 ?deallocate@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAEXPAU?$pair@HH@2@I@Z proc near
.text$mn:00005500                                         ; CODE XREF: __catch$?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z$0+16p
.text$mn:00005500                                         ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Reallocate(uint)+F5p ...
.text$mn:00005500
.text$mn:00005500 var_4           = dword ptr -4
.text$mn:00005500 arg_0           = dword ptr  8
.text$mn:00005500 arg_4           = dword ptr  0Ch
.text$mn:00005500
.text$mn:00005500                 push    ebp
.text$mn:00005501                 mov     ebp, esp
.text$mn:00005503                 push    ecx
.text$mn:00005504                 mov     [ebp+var_4], ecx
.text$mn:00005507                 mov     eax, [ebp+arg_4]
.text$mn:0000550A                 push    eax             ; int
.text$mn:0000550B                 mov     ecx, [ebp+arg_0]
.text$mn:0000550E                 push    ecx             ; void *
.text$mn:0000550F                 mov     ecx, [ebp+var_4]
.text$mn:00005512                 call    ?deallocate@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@I@Z ; std::allocator<std::pair<int,int>>::deallocate(std::pair<int,int> *,uint)
.text$mn:00005517                 mov     esp, ebp
.text$mn:00005519                 pop     ebp
.text$mn:0000551A                 retn    8
.text$mn:0000551A ?deallocate@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAEXPAU?$pair@HH@2@I@Z endp
.text$mn:0000551A
.text$mn:0000551A ; ---------------------------------------------------------------------------
.text$mn:0000551D                 align 10h
.text$mn:0000551D _text$mn        ends
.text$mn:0000551D
.text$mn:00005520 ; ===========================================================================
.text$mn:00005520
.text$mn:00005520 ; Segment type: Pure code
.text$mn:00005520 ; Segment permissions: Read/Execute
.text$mn:00005520 _text$mn        segment para public 'CODE' use32
.text$mn:00005520                 assume cs:_text$mn
.text$mn:00005520                 ;org 5520h
.text$mn:00005520 ; COMDAT (pick any)
.text$mn:00005520                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005520
.text$mn:00005520 ; =============== S U B R O U T I N E =======================================
.text$mn:00005520
.text$mn:00005520 ; Attributes: bp-based frame
.text$mn:00005520
.text$mn:00005520 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(void *, int)
.text$mn:00005520                 public ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00005520 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00005520                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Free_proxy(void)+32p
.text$mn:00005520
.text$mn:00005520 var_4           = dword ptr -4
.text$mn:00005520 arg_0           = dword ptr  8
.text$mn:00005520 arg_4           = dword ptr  0Ch
.text$mn:00005520
.text$mn:00005520                 push    ebp
.text$mn:00005521                 mov     ebp, esp
.text$mn:00005523                 push    ecx
.text$mn:00005524                 mov     [ebp+var_4], ecx
.text$mn:00005527                 mov     eax, [ebp+arg_4]
.text$mn:0000552A                 push    eax             ; int
.text$mn:0000552B                 mov     ecx, [ebp+arg_0]
.text$mn:0000552E                 push    ecx             ; void *
.text$mn:0000552F                 mov     ecx, [ebp+var_4]
.text$mn:00005532                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00005537                 mov     esp, ebp
.text$mn:00005539                 pop     ebp
.text$mn:0000553A                 retn    8
.text$mn:0000553A ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:0000553A
.text$mn:0000553A ; ---------------------------------------------------------------------------
.text$mn:0000553D                 align 10h
.text$mn:0000553D _text$mn        ends
.text$mn:0000553D
.text$mn:00005540 ; ===========================================================================
.text$mn:00005540
.text$mn:00005540 ; Segment type: Pure code
.text$mn:00005540 ; Segment permissions: Read/Execute
.text$mn:00005540 _text$mn        segment para public 'CODE' use32
.text$mn:00005540                 assume cs:_text$mn
.text$mn:00005540                 ;org 5540h
.text$mn:00005540 ; COMDAT (pick any)
.text$mn:00005540                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005540
.text$mn:00005540 ; =============== S U B R O U T I N E =======================================
.text$mn:00005540
.text$mn:00005540 ; Attributes: bp-based frame
.text$mn:00005540
.text$mn:00005540 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00005540                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00005540 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00005540                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00005540
.text$mn:00005540 var_4           = dword ptr -4
.text$mn:00005540 arg_0           = dword ptr  8
.text$mn:00005540
.text$mn:00005540                 push    ebp
.text$mn:00005541                 mov     ebp, esp
.text$mn:00005543                 push    ecx
.text$mn:00005544                 mov     [ebp+var_4], ecx
.text$mn:00005547                 mov     eax, [ebp+arg_0]
.text$mn:0000554A                 push    eax             ; void *
.text$mn:0000554B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005550                 add     esp, 4
.text$mn:00005553                 mov     esp, ebp
.text$mn:00005555                 pop     ebp
.text$mn:00005556                 retn    8
.text$mn:00005556 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:00005556
.text$mn:00005556 ; ---------------------------------------------------------------------------
.text$mn:00005559                 align 4
.text$mn:00005559 _text$mn        ends
.text$mn:00005559
.text$mn:0000555C ; ===========================================================================
.text$mn:0000555C
.text$mn:0000555C ; Segment type: Pure code
.text$mn:0000555C ; Segment permissions: Read/Execute
.text$mn:0000555C _text$mn        segment para public 'CODE' use32
.text$mn:0000555C                 assume cs:_text$mn
.text$mn:0000555C                 ;org 555Ch
.text$mn:0000555C ; COMDAT (pick any)
.text$mn:0000555C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000555C
.text$mn:0000555C ; =============== S U B R O U T I N E =======================================
.text$mn:0000555C
.text$mn:0000555C ; Attributes: bp-based frame
.text$mn:0000555C
.text$mn:0000555C ; int __stdcall std::allocator<std::pair<int,int>>::deallocate(void *, int)
.text$mn:0000555C                 public ?deallocate@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@I@Z
.text$mn:0000555C ?deallocate@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@I@Z proc near
.text$mn:0000555C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::pair<int,int>>>::deallocate(std::pair<int,int> *,uint)+12p
.text$mn:0000555C
.text$mn:0000555C var_4           = dword ptr -4
.text$mn:0000555C arg_0           = dword ptr  8
.text$mn:0000555C
.text$mn:0000555C                 push    ebp
.text$mn:0000555D                 mov     ebp, esp
.text$mn:0000555F                 push    ecx
.text$mn:00005560                 mov     [ebp+var_4], ecx
.text$mn:00005563                 mov     eax, [ebp+arg_0]
.text$mn:00005566                 push    eax             ; void *
.text$mn:00005567                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000556C                 add     esp, 4
.text$mn:0000556F                 mov     esp, ebp
.text$mn:00005571                 pop     ebp
.text$mn:00005572                 retn    8
.text$mn:00005572 ?deallocate@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@2@I@Z endp
.text$mn:00005572
.text$mn:00005572 ; ---------------------------------------------------------------------------
.text$mn:00005575                 align 4
.text$mn:00005575 _text$mn        ends
.text$mn:00005575
.text$mn:00005578 ; ===========================================================================
.text$mn:00005578
.text$mn:00005578 ; Segment type: Pure code
.text$mn:00005578 ; Segment permissions: Read/Execute
.text$mn:00005578 _text$mn        segment para public 'CODE' use32
.text$mn:00005578                 assume cs:_text$mn
.text$mn:00005578                 ;org 5578h
.text$mn:00005578 ; COMDAT (pick any)
.text$mn:00005578                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005578
.text$mn:00005578 ; =============== S U B R O U T I N E =======================================
.text$mn:00005578
.text$mn:00005578 ; Attributes: bp-based frame
.text$mn:00005578
.text$mn:00005578 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00005578                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00005578 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00005578                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00005578                                         ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)+12p
.text$mn:00005578
.text$mn:00005578 var_4           = dword ptr -4
.text$mn:00005578 arg_0           = dword ptr  8
.text$mn:00005578
.text$mn:00005578                 push    ebp
.text$mn:00005579                 mov     ebp, esp
.text$mn:0000557B                 push    ecx
.text$mn:0000557C                 mov     [ebp+var_4], ecx
.text$mn:0000557F                 mov     eax, [ebp+arg_0]
.text$mn:00005582                 push    eax             ; void *
.text$mn:00005583                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00005588                 add     esp, 4
.text$mn:0000558B                 mov     esp, ebp
.text$mn:0000558D                 pop     ebp
.text$mn:0000558E                 retn    8
.text$mn:0000558E ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:0000558E
.text$mn:0000558E ; ---------------------------------------------------------------------------
.text$mn:00005591                 align 4
.text$mn:00005591 _text$mn        ends
.text$mn:00005591
.text$mn:00005594 ; ===========================================================================
.text$mn:00005594
.text$mn:00005594 ; Segment type: Pure code
.text$mn:00005594 ; Segment permissions: Read/Execute
.text$mn:00005594 _text$mn        segment para public 'CODE' use32
.text$mn:00005594                 assume cs:_text$mn
.text$mn:00005594                 ;org 5594h
.text$mn:00005594 ; COMDAT (pick any)
.text$mn:00005594                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005594
.text$mn:00005594 ; =============== S U B R O U T I N E =======================================
.text$mn:00005594
.text$mn:00005594 ; Attributes: bp-based frame
.text$mn:00005594
.text$mn:00005594 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00005594                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00005594 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00005594                                         ; DATA XREF: .rdata:00006CF8o
.text$mn:00005594
.text$mn:00005594 var_4           = dword ptr -4
.text$mn:00005594 arg_0           = dword ptr  8
.text$mn:00005594 arg_4           = dword ptr  0Ch
.text$mn:00005594
.text$mn:00005594                 push    ebp
.text$mn:00005595                 mov     ebp, esp
.text$mn:00005597                 push    ecx
.text$mn:00005598                 mov     [ebp+var_4], ecx
.text$mn:0000559B                 mov     eax, [ebp+arg_4]
.text$mn:0000559E                 push    eax             ; int
.text$mn:0000559F                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000055A4                 add     esp, 4
.text$mn:000055A7                 test    eax, eax
.text$mn:000055A9                 jz      short loc_55C4
.text$mn:000055AB                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:000055B0                 push    eax             ; struct std::error_category *
.text$mn:000055B1                 mov     ecx, [ebp+arg_4]
.text$mn:000055B4                 push    ecx             ; int
.text$mn:000055B5                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000055B8                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000055BD                 mov     eax, [ebp+arg_0]
.text$mn:000055C0                 jmp     short loc_55D9
.text$mn:000055C2 ; ---------------------------------------------------------------------------
.text$mn:000055C2                 jmp     short loc_55D9
.text$mn:000055C4 ; ---------------------------------------------------------------------------
.text$mn:000055C4
.text$mn:000055C4 loc_55C4:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:000055C4                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:000055C9                 push    eax             ; struct std::error_category *
.text$mn:000055CA                 mov     edx, [ebp+arg_4]
.text$mn:000055CD                 push    edx             ; int
.text$mn:000055CE                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000055D1                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000055D6                 mov     eax, [ebp+arg_0]
.text$mn:000055D9
.text$mn:000055D9 loc_55D9:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:000055D9                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:000055D9                 mov     esp, ebp
.text$mn:000055DB                 pop     ebp
.text$mn:000055DC                 retn    8
.text$mn:000055DC ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000055DC
.text$mn:000055DC ; ---------------------------------------------------------------------------
.text$mn:000055DF                 align 10h
.text$mn:000055DF _text$mn        ends
.text$mn:000055DF
.text$mn:000055E0 ; ===========================================================================
.text$mn:000055E0
.text$mn:000055E0 ; Segment type: Pure code
.text$mn:000055E0 ; Segment permissions: Read/Execute
.text$mn:000055E0 _text$mn        segment para public 'CODE' use32
.text$mn:000055E0                 assume cs:_text$mn
.text$mn:000055E0                 ;org 55E0h
.text$mn:000055E0 ; COMDAT (pick any)
.text$mn:000055E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000055E0
.text$mn:000055E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000055E0
.text$mn:000055E0 ; Attributes: bp-based frame
.text$mn:000055E0
.text$mn:000055E0 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:000055E0                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:000055E0 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:000055E0                                         ; DATA XREF: .rdata:00006C68o
.text$mn:000055E0                                         ; .rdata:00006C84o ...
.text$mn:000055E0
.text$mn:000055E0 var_4           = dword ptr -4
.text$mn:000055E0 arg_0           = dword ptr  8
.text$mn:000055E0 arg_4           = dword ptr  0Ch
.text$mn:000055E0
.text$mn:000055E0                 push    ebp
.text$mn:000055E1                 mov     ebp, esp
.text$mn:000055E3                 push    ecx
.text$mn:000055E4                 mov     [ebp+var_4], ecx
.text$mn:000055E7                 mov     eax, [ebp+var_4]
.text$mn:000055EA                 push    eax             ; struct std::error_category *
.text$mn:000055EB                 mov     ecx, [ebp+arg_4]
.text$mn:000055EE                 push    ecx             ; int
.text$mn:000055EF                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000055F2                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000055F7                 mov     eax, [ebp+arg_0]
.text$mn:000055FA                 mov     esp, ebp
.text$mn:000055FC                 pop     ebp
.text$mn:000055FD                 retn    8
.text$mn:000055FD ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000055FD
.text$mn:000055FD _text$mn        ends
.text$mn:000055FD
.text$mn:00005600 ; ===========================================================================
.text$mn:00005600
.text$mn:00005600 ; Segment type: Pure code
.text$mn:00005600 ; Segment permissions: Read/Execute
.text$mn:00005600 _text$mn        segment para public 'CODE' use32
.text$mn:00005600                 assume cs:_text$mn
.text$mn:00005600                 ;org 5600h
.text$mn:00005600 ; COMDAT (pick any)
.text$mn:00005600                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005600
.text$mn:00005600 ; =============== S U B R O U T I N E =======================================
.text$mn:00005600
.text$mn:00005600 ; Attributes: bp-based frame
.text$mn:00005600
.text$mn:00005600 ; public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<char>>> __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::end(void)
.text$mn:00005600                 public ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
.text$mn:00005600 ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ proc near
.text$mn:00005600                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::push_back(char)+34p
.text$mn:00005600
.text$mn:00005600 var_14          = dword ptr -14h
.text$mn:00005600 var_10          = dword ptr -10h
.text$mn:00005600 var_C           = dword ptr -0Ch
.text$mn:00005600 var_4           = dword ptr -4
.text$mn:00005600 arg_0           = dword ptr  8
.text$mn:00005600
.text$mn:00005600                 push    ebp
.text$mn:00005601                 mov     ebp, esp
.text$mn:00005603                 push    0FFFFFFFFh
.text$mn:00005605                 push    offset __ehhandler$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
.text$mn:0000560A                 mov     eax, large fs:0
.text$mn:00005610                 push    eax
.text$mn:00005611                 sub     esp, 8
.text$mn:00005614                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005619                 xor     eax, ebp
.text$mn:0000561B                 push    eax
.text$mn:0000561C                 lea     eax, [ebp+var_C]
.text$mn:0000561F                 mov     large fs:0, eax
.text$mn:00005625                 mov     [ebp+var_10], ecx
.text$mn:00005628                 mov     [ebp+var_14], 0
.text$mn:0000562F                 mov     eax, [ebp+var_10]
.text$mn:00005632                 push    eax             ; struct std::_Container_base12 *
.text$mn:00005633                 mov     ecx, [ebp+var_10]
.text$mn:00005636                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000563B                 mov     ecx, [ebp+var_10]
.text$mn:0000563E                 add     eax, [ecx+14h]
.text$mn:00005641                 push    eax             ; int
.text$mn:00005642                 mov     ecx, [ebp+arg_0]
.text$mn:00005645                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::_String_iterator<std::_String_val<std::_Simple_types<char>>>(char *,std::_Container_base12 const *)
.text$mn:0000564A                 mov     [ebp+var_4], 0
.text$mn:00005651                 mov     edx, [ebp+var_14]
.text$mn:00005654                 or      edx, 1
.text$mn:00005657                 mov     [ebp+var_14], edx
.text$mn:0000565A                 mov     eax, [ebp+arg_0]
.text$mn:0000565D                 mov     ecx, [ebp+var_C]
.text$mn:00005660                 mov     large fs:0, ecx
.text$mn:00005667                 pop     ecx
.text$mn:00005668                 mov     esp, ebp
.text$mn:0000566A                 pop     ebp
.text$mn:0000566B                 retn    4
.text$mn:0000566B ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ endp
.text$mn:0000566B
.text$mn:0000566B ; ---------------------------------------------------------------------------
.text$mn:0000566E                 align 10h
.text$mn:0000566E _text$mn        ends
.text$mn:0000566E
.text$x:00005670 ; ===========================================================================
.text$x:00005670
.text$x:00005670 ; Segment type: Pure code
.text$x:00005670 ; Segment permissions: Read/Execute
.text$x:00005670 _text$x         segment para public 'CODE' use32
.text$x:00005670                 assume cs:_text$x
.text$x:00005670                 ;org 5670h
.text$x:00005670 ; COMDAT (pick associative to section at 5600)
.text$x:00005670                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005670
.text$x:00005670 ; =============== S U B R O U T I N E =======================================
.text$x:00005670
.text$x:00005670
.text$x:00005670 __unwindfunclet$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ$0 proc near
.text$x:00005670                                         ; DATA XREF: .xdata$x:00006394o
.text$x:00005670                 mov     eax, [ebp-14h]
.text$x:00005673                 and     eax, 1
.text$x:00005676                 jz      $LN4_0
.text$x:0000567C                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00005680                 mov     ecx, [ebp+8]
.text$x:00005683                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$x:00005688 ; ---------------------------------------------------------------------------
.text$x:00005688
.text$x:00005688 $LN4_0:                                 ; CODE XREF: __unwindfunclet$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ$0+6j
.text$x:00005688                 retn
.text$x:00005688 __unwindfunclet$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ$0 endp
.text$x:00005688
.text$x:00005689
.text$x:00005689 ; =============== S U B R O U T I N E =======================================
.text$x:00005689
.text$x:00005689
.text$x:00005689 __ehhandler$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ proc near
.text$x:00005689                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::end(void)+5o
.text$x:00005689
.text$x:00005689 arg_4           = dword ptr  8
.text$x:00005689
.text$x:00005689                 mov     edx, [esp+arg_4]
.text$x:0000568D                 lea     eax, [edx+0Ch]
.text$x:00005690                 mov     ecx, [edx-0Ch]
.text$x:00005693                 xor     ecx, eax
.text$x:00005695                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000569A                 mov     eax, offset __ehfuncinfo$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
.text$x:0000569F                 jmp     ___CxxFrameHandler3
.text$x:0000569F __ehhandler$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ endp
.text$x:0000569F
.text$x:0000569F _text$x         ends
.text$x:0000569F
.text$mn:000056A4 ; ===========================================================================
.text$mn:000056A4
.text$mn:000056A4 ; Segment type: Pure code
.text$mn:000056A4 ; Segment permissions: Read/Execute
.text$mn:000056A4 _text$mn        segment para public 'CODE' use32
.text$mn:000056A4                 assume cs:_text$mn
.text$mn:000056A4                 ;org 56A4h
.text$mn:000056A4 ; COMDAT (pick any)
.text$mn:000056A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000056A4
.text$mn:000056A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000056A4
.text$mn:000056A4 ; Attributes: bp-based frame
.text$mn:000056A4
.text$mn:000056A4 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:000056A4                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:000056A4 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:000056A4                                         ; DATA XREF: .rdata:00006C6Co
.text$mn:000056A4                                         ; .rdata:00006C88o ...
.text$mn:000056A4
.text$mn:000056A4 var_8           = dword ptr -8
.text$mn:000056A4 var_4           = dword ptr -4
.text$mn:000056A4 arg_0           = dword ptr  8
.text$mn:000056A4 arg_4           = dword ptr  0Ch
.text$mn:000056A4
.text$mn:000056A4                 push    ebp
.text$mn:000056A5                 mov     ebp, esp
.text$mn:000056A7                 sub     esp, 8
.text$mn:000056AA                 mov     [ebp+var_8], ecx
.text$mn:000056AD                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000056B0                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:000056B5                 push    eax
.text$mn:000056B6                 mov     ecx, [ebp+var_8]
.text$mn:000056B9                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:000056BE                 movzx   eax, al
.text$mn:000056C1                 test    eax, eax
.text$mn:000056C3                 jz      short loc_56DB
.text$mn:000056C5                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000056C8                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:000056CD                 cmp     eax, [ebp+arg_4]
.text$mn:000056D0                 jnz     short loc_56DB
.text$mn:000056D2                 mov     [ebp+var_4], 1
.text$mn:000056D9                 jmp     short loc_56E2
.text$mn:000056DB ; ---------------------------------------------------------------------------
.text$mn:000056DB
.text$mn:000056DB loc_56DB:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:000056DB                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:000056DB                 mov     [ebp+var_4], 0
.text$mn:000056E2
.text$mn:000056E2 loc_56E2:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:000056E2                 mov     al, byte ptr [ebp+var_4]
.text$mn:000056E5                 mov     esp, ebp
.text$mn:000056E7                 pop     ebp
.text$mn:000056E8                 retn    8
.text$mn:000056E8 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:000056E8
.text$mn:000056E8 ; ---------------------------------------------------------------------------
.text$mn:000056EB                 align 4
.text$mn:000056EB _text$mn        ends
.text$mn:000056EB
.text$mn:000056EC ; ===========================================================================
.text$mn:000056EC
.text$mn:000056EC ; Segment type: Pure code
.text$mn:000056EC ; Segment permissions: Read/Execute
.text$mn:000056EC _text$mn        segment para public 'CODE' use32
.text$mn:000056EC                 assume cs:_text$mn
.text$mn:000056EC                 ;org 56ECh
.text$mn:000056EC ; COMDAT (pick any)
.text$mn:000056EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000056EC
.text$mn:000056EC ; =============== S U B R O U T I N E =======================================
.text$mn:000056EC
.text$mn:000056EC ; Attributes: bp-based frame
.text$mn:000056EC
.text$mn:000056EC ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:000056EC                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:000056EC ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:000056EC                                         ; DATA XREF: .rdata:00006C70o
.text$mn:000056EC                                         ; .rdata:00006C8Co ...
.text$mn:000056EC
.text$mn:000056EC var_C           = byte ptr -0Ch
.text$mn:000056EC var_4           = dword ptr -4
.text$mn:000056EC arg_0           = dword ptr  8
.text$mn:000056EC arg_4           = dword ptr  0Ch
.text$mn:000056EC
.text$mn:000056EC                 push    ebp
.text$mn:000056ED                 mov     ebp, esp
.text$mn:000056EF                 sub     esp, 0Ch
.text$mn:000056F2                 mov     [ebp+var_4], ecx
.text$mn:000056F5                 mov     eax, [ebp+arg_4]
.text$mn:000056F8                 push    eax             ; std::error_condition *
.text$mn:000056F9                 mov     ecx, [ebp+arg_0]
.text$mn:000056FC                 push    ecx
.text$mn:000056FD                 lea     edx, [ebp+var_C]
.text$mn:00005700                 push    edx
.text$mn:00005701                 mov     eax, [ebp+var_4]
.text$mn:00005704                 mov     edx, [eax]
.text$mn:00005706                 mov     ecx, [ebp+var_4]
.text$mn:00005709                 mov     eax, [edx+0Ch]
.text$mn:0000570C                 call    eax
.text$mn:0000570E                 mov     ecx, eax
.text$mn:00005710                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00005715                 mov     esp, ebp
.text$mn:00005717                 pop     ebp
.text$mn:00005718                 retn    8
.text$mn:00005718 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00005718
.text$mn:00005718 ; ---------------------------------------------------------------------------
.text$mn:0000571B                 align 4
.text$mn:0000571B _text$mn        ends
.text$mn:0000571B
.text$mn:0000571C ; ===========================================================================
.text$mn:0000571C
.text$mn:0000571C ; Segment type: Pure code
.text$mn:0000571C ; Segment permissions: Read/Execute
.text$mn:0000571C _text$mn        segment para public 'CODE' use32
.text$mn:0000571C                 assume cs:_text$mn
.text$mn:0000571C                 ;org 571Ch
.text$mn:0000571C ; COMDAT (pick any)
.text$mn:0000571C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000571C
.text$mn:0000571C ; =============== S U B R O U T I N E =======================================
.text$mn:0000571C
.text$mn:0000571C ; Attributes: bp-based frame
.text$mn:0000571C
.text$mn:0000571C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:0000571C                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:0000571C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:0000571C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:0000571C
.text$mn:0000571C var_4           = dword ptr -4
.text$mn:0000571C arg_0           = dword ptr  8
.text$mn:0000571C
.text$mn:0000571C                 push    ebp
.text$mn:0000571D                 mov     ebp, esp
.text$mn:0000571F                 push    ecx
.text$mn:00005720                 mov     [ebp+var_4], ecx
.text$mn:00005723                 mov     eax, [ebp+var_4]
.text$mn:00005726                 mov     ecx, [eax+14h]
.text$mn:00005729                 cmp     ecx, [ebp+arg_0]
.text$mn:0000572C                 jnb     short loc_5736
.text$mn:0000572E                 mov     ecx, [ebp+var_4]
.text$mn:00005731                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00005736
.text$mn:00005736 loc_5736:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00005736                 mov     edx, [ebp+arg_0]
.text$mn:00005739                 push    edx
.text$mn:0000573A                 mov     ecx, [ebp+var_4]
.text$mn:0000573D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00005742                 mov     eax, [ebp+var_4]
.text$mn:00005745                 mov     esp, ebp
.text$mn:00005747                 pop     ebp
.text$mn:00005748                 retn    4
.text$mn:00005748 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00005748
.text$mn:00005748 ; ---------------------------------------------------------------------------
.text$mn:0000574B                 align 4
.text$mn:0000574B _text$mn        ends
.text$mn:0000574B
.text$mn:0000574C ; ===========================================================================
.text$mn:0000574C
.text$mn:0000574C ; Segment type: Pure code
.text$mn:0000574C ; Segment permissions: Read/Execute
.text$mn:0000574C _text$mn        segment para public 'CODE' use32
.text$mn:0000574C                 assume cs:_text$mn
.text$mn:0000574C                 ;org 574Ch
.text$mn:0000574C ; COMDAT (pick any)
.text$mn:0000574C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000574C
.text$mn:0000574C ; =============== S U B R O U T I N E =======================================
.text$mn:0000574C
.text$mn:0000574C ; Attributes: bp-based frame
.text$mn:0000574C
.text$mn:0000574C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:0000574C                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:0000574C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:0000574C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:0000574C
.text$mn:0000574C var_C           = dword ptr -0Ch
.text$mn:0000574C Dst             = dword ptr -8
.text$mn:0000574C var_4           = dword ptr -4
.text$mn:0000574C arg_0           = dword ptr  8
.text$mn:0000574C arg_4           = dword ptr  0Ch
.text$mn:0000574C
.text$mn:0000574C                 push    ebp
.text$mn:0000574D                 mov     ebp, esp
.text$mn:0000574F                 sub     esp, 0Ch
.text$mn:00005752                 mov     [ebp+var_4], ecx
.text$mn:00005755                 mov     eax, [ebp+var_4]
.text$mn:00005758                 mov     ecx, [eax+14h]
.text$mn:0000575B                 cmp     ecx, [ebp+arg_0]
.text$mn:0000575E                 jnb     short loc_5768
.text$mn:00005760                 mov     ecx, [ebp+var_4]
.text$mn:00005763                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00005768
.text$mn:00005768 loc_5768:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00005768                 mov     edx, [ebp+var_4]
.text$mn:0000576B                 mov     eax, [edx+14h]
.text$mn:0000576E                 sub     eax, [ebp+arg_0]
.text$mn:00005771                 cmp     eax, [ebp+arg_4]
.text$mn:00005774                 ja      short loc_5784
.text$mn:00005776                 mov     ecx, [ebp+arg_0]
.text$mn:00005779                 push    ecx
.text$mn:0000577A                 mov     ecx, [ebp+var_4]
.text$mn:0000577D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00005782                 jmp     short loc_57CA
.text$mn:00005784 ; ---------------------------------------------------------------------------
.text$mn:00005784
.text$mn:00005784 loc_5784:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00005784                 cmp     [ebp+arg_4], 0
.text$mn:00005788                 jbe     short loc_57CA
.text$mn:0000578A                 mov     ecx, [ebp+var_4]
.text$mn:0000578D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00005792                 add     eax, [ebp+arg_0]
.text$mn:00005795                 mov     [ebp+Dst], eax
.text$mn:00005798                 mov     edx, [ebp+var_4]
.text$mn:0000579B                 mov     eax, [edx+14h]
.text$mn:0000579E                 sub     eax, [ebp+arg_4]
.text$mn:000057A1                 mov     [ebp+var_C], eax
.text$mn:000057A4                 mov     ecx, [ebp+var_C]
.text$mn:000057A7                 sub     ecx, [ebp+arg_0]
.text$mn:000057AA                 push    ecx             ; Size
.text$mn:000057AB                 mov     edx, [ebp+Dst]
.text$mn:000057AE                 add     edx, [ebp+arg_4]
.text$mn:000057B1                 push    edx             ; Src
.text$mn:000057B2                 mov     eax, [ebp+Dst]
.text$mn:000057B5                 push    eax             ; Dst
.text$mn:000057B6                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:000057BB                 add     esp, 0Ch
.text$mn:000057BE                 mov     ecx, [ebp+var_C]
.text$mn:000057C1                 push    ecx
.text$mn:000057C2                 mov     ecx, [ebp+var_4]
.text$mn:000057C5                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000057CA
.text$mn:000057CA loc_57CA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:000057CA                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:000057CA                 mov     eax, [ebp+var_4]
.text$mn:000057CD                 mov     esp, ebp
.text$mn:000057CF                 pop     ebp
.text$mn:000057D0                 retn    8
.text$mn:000057D0 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:000057D0
.text$mn:000057D0 ; ---------------------------------------------------------------------------
.text$mn:000057D3                 align 4
.text$mn:000057D3 _text$mn        ends
.text$mn:000057D3
.text$mn:000057D4 ; ===========================================================================
.text$mn:000057D4
.text$mn:000057D4 ; Segment type: Pure code
.text$mn:000057D4 ; Segment permissions: Read/Execute
.text$mn:000057D4 _text$mn        segment para public 'CODE' use32
.text$mn:000057D4                 assume cs:_text$mn
.text$mn:000057D4                 ;org 57D4h
.text$mn:000057D4 ; COMDAT (pick any)
.text$mn:000057D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000057D4
.text$mn:000057D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000057D4
.text$mn:000057D4 ; Attributes: bp-based frame
.text$mn:000057D4
.text$mn:000057D4 ; __int32 __thiscall ScintillaEditView::execute(ScintillaEditView *this, unsigned int, unsigned int, __int32)
.text$mn:000057D4                 public ?execute@ScintillaEditView@@QBEJIIJ@Z
.text$mn:000057D4 ?execute@ScintillaEditView@@QBEJIIJ@Z proc near
.text$mn:000057D4                                         ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+103p
.text$mn:000057D4                                         ; XmlMatchedTagsHighlighter::tagMatch(bool)+1DCp ...
.text$mn:000057D4
.text$mn:000057D4 var_4           = dword ptr -4
.text$mn:000057D4 arg_0           = dword ptr  8
.text$mn:000057D4 arg_4           = dword ptr  0Ch
.text$mn:000057D4 arg_8           = dword ptr  10h
.text$mn:000057D4
.text$mn:000057D4                 push    ebp
.text$mn:000057D5                 mov     ebp, esp
.text$mn:000057D7                 push    ecx
.text$mn:000057D8                 mov     [ebp+var_4], ecx
.text$mn:000057DB                 mov     eax, [ebp+arg_8]
.text$mn:000057DE                 push    eax
.text$mn:000057DF                 mov     ecx, [ebp+arg_4]
.text$mn:000057E2                 push    ecx
.text$mn:000057E3                 mov     edx, [ebp+arg_0]
.text$mn:000057E6                 push    edx
.text$mn:000057E7                 mov     eax, [ebp+var_4]
.text$mn:000057EA                 mov     ecx, [eax+14h]
.text$mn:000057ED                 push    ecx
.text$mn:000057EE                 mov     edx, [ebp+var_4]
.text$mn:000057F1                 mov     eax, [edx+10h]
.text$mn:000057F4                 call    eax
.text$mn:000057F6                 add     esp, 10h
.text$mn:000057F9                 mov     esp, ebp
.text$mn:000057FB                 pop     ebp
.text$mn:000057FC                 retn    0Ch
.text$mn:000057FC ?execute@ScintillaEditView@@QBEJIIJ@Z endp
.text$mn:000057FC
.text$mn:000057FC ; ---------------------------------------------------------------------------
.text$mn:000057FF                 align 10h
.text$mn:000057FF _text$mn        ends
.text$mn:000057FF
.text$mn:00005800 ; ===========================================================================
.text$mn:00005800
.text$mn:00005800 ; Segment type: Pure code
.text$mn:00005800 ; Segment permissions: Read/Execute
.text$mn:00005800 _text$mn        segment para public 'CODE' use32
.text$mn:00005800                 assume cs:_text$mn
.text$mn:00005800                 ;org 5800h
.text$mn:00005800 ; COMDAT (pick any)
.text$mn:00005800                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005800
.text$mn:00005800 ; =============== S U B R O U T I N E =======================================
.text$mn:00005800
.text$mn:00005800 ; Attributes: bp-based frame
.text$mn:00005800
.text$mn:00005800 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00005800                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00005800 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00005800                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00005800                 push    ebp
.text$mn:00005801                 mov     ebp, esp
.text$mn:00005803                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00005808                 pop     ebp
.text$mn:00005809                 retn
.text$mn:00005809 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00005809
.text$mn:00005809 ; ---------------------------------------------------------------------------
.text$mn:0000580A                 align 4
.text$mn:0000580A _text$mn        ends
.text$mn:0000580A
.text$mn:0000580C ; ===========================================================================
.text$mn:0000580C
.text$mn:0000580C ; Segment type: Pure code
.text$mn:0000580C ; Segment permissions: Read/Execute
.text$mn:0000580C _text$mn        segment para public 'CODE' use32
.text$mn:0000580C                 assume cs:_text$mn
.text$mn:0000580C                 ;org 580Ch
.text$mn:0000580C ; COMDAT (pick any)
.text$mn:0000580C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000580C
.text$mn:0000580C ; =============== S U B R O U T I N E =======================================
.text$mn:0000580C
.text$mn:0000580C ; Attributes: bp-based frame
.text$mn:0000580C
.text$mn:0000580C ; struct Buffer *__thiscall ScintillaEditView::getCurrentBuffer(ScintillaEditView *__hidden this)
.text$mn:0000580C                 public ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ
.text$mn:0000580C ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ proc near
.text$mn:0000580C                                         ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+4Cp
.text$mn:0000580C
.text$mn:0000580C var_4           = dword ptr -4
.text$mn:0000580C
.text$mn:0000580C                 push    ebp
.text$mn:0000580D                 mov     ebp, esp
.text$mn:0000580F                 push    ecx
.text$mn:00005810                 mov     [ebp+var_4], ecx
.text$mn:00005813                 mov     eax, [ebp+var_4]
.text$mn:00005816                 mov     eax, [eax+20h]
.text$mn:00005819                 mov     esp, ebp
.text$mn:0000581B                 pop     ebp
.text$mn:0000581C                 retn
.text$mn:0000581C ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ endp
.text$mn:0000581C
.text$mn:0000581C ; ---------------------------------------------------------------------------
.text$mn:0000581D                 align 10h
.text$mn:0000581D _text$mn        ends
.text$mn:0000581D
.text$mn:00005820 ; ===========================================================================
.text$mn:00005820
.text$mn:00005820 ; Segment type: Pure code
.text$mn:00005820 ; Segment permissions: Read/Execute
.text$mn:00005820 _text$mn        segment para public 'CODE' use32
.text$mn:00005820                 assume cs:_text$mn
.text$mn:00005820                 ;org 5820h
.text$mn:00005820 ; COMDAT (pick any)
.text$mn:00005820                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005820
.text$mn:00005820 ; =============== S U B R O U T I N E =======================================
.text$mn:00005820
.text$mn:00005820 ; Attributes: bp-based frame
.text$mn:00005820
.text$mn:00005820 ; int __thiscall ScintillaEditView::getCurrentDocLen(ScintillaEditView *__hidden this)
.text$mn:00005820                 public ?getCurrentDocLen@ScintillaEditView@@QBEHXZ
.text$mn:00005820 ?getCurrentDocLen@ScintillaEditView@@QBEHXZ proc near
.text$mn:00005820                                         ; CODE XREF: ScintillaEditView::clearIndicator(int)+13p
.text$mn:00005820
.text$mn:00005820 var_4           = dword ptr -4
.text$mn:00005820
.text$mn:00005820                 push    ebp
.text$mn:00005821                 mov     ebp, esp
.text$mn:00005823                 push    ecx
.text$mn:00005824                 mov     [ebp+var_4], ecx
.text$mn:00005827                 push    0               ; __int32
.text$mn:00005829                 push    0               ; unsigned int
.text$mn:0000582B                 push    7D6h            ; unsigned int
.text$mn:00005830                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005833                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00005838                 mov     esp, ebp
.text$mn:0000583A                 pop     ebp
.text$mn:0000583B                 retn
.text$mn:0000583B ?getCurrentDocLen@ScintillaEditView@@QBEHXZ endp
.text$mn:0000583B
.text$mn:0000583B _text$mn        ends
.text$mn:0000583B
.text$mn:0000583C ; ===========================================================================
.text$mn:0000583C
.text$mn:0000583C ; Segment type: Pure code
.text$mn:0000583C ; Segment permissions: Read/Execute
.text$mn:0000583C _text$mn        segment para public 'CODE' use32
.text$mn:0000583C                 assume cs:_text$mn
.text$mn:0000583C                 ;org 583Ch
.text$mn:0000583C ; COMDAT (pick any)
.text$mn:0000583C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000583C
.text$mn:0000583C ; =============== S U B R O U T I N E =======================================
.text$mn:0000583C
.text$mn:0000583C ; Attributes: bp-based frame
.text$mn:0000583C
.text$mn:0000583C ; public: enum  LangType __thiscall Buffer::getLangType(void)const
.text$mn:0000583C                 public ?getLangType@Buffer@@QBE?AW4LangType@@XZ
.text$mn:0000583C ?getLangType@Buffer@@QBE?AW4LangType@@XZ proc near
.text$mn:0000583C                                         ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+53p
.text$mn:0000583C
.text$mn:0000583C var_4           = dword ptr -4
.text$mn:0000583C
.text$mn:0000583C                 push    ebp
.text$mn:0000583D                 mov     ebp, esp
.text$mn:0000583F                 push    ecx
.text$mn:00005840                 mov     [ebp+var_4], ecx
.text$mn:00005843                 mov     eax, [ebp+var_4]
.text$mn:00005846                 mov     eax, [eax+14h]
.text$mn:00005849                 mov     esp, ebp
.text$mn:0000584B                 pop     ebp
.text$mn:0000584C                 retn
.text$mn:0000584C ?getLangType@Buffer@@QBE?AW4LangType@@XZ endp
.text$mn:0000584C
.text$mn:0000584C ; ---------------------------------------------------------------------------
.text$mn:0000584D                 align 10h
.text$mn:0000584D _text$mn        ends
.text$mn:0000584D
.text$mn:00005850 ; ===========================================================================
.text$mn:00005850
.text$mn:00005850 ; Segment type: Pure code
.text$mn:00005850 ; Segment permissions: Read/Execute
.text$mn:00005850 _text$mn        segment para public 'CODE' use32
.text$mn:00005850                 assume cs:_text$mn
.text$mn:00005850                 ;org 5850h
.text$mn:00005850 ; COMDAT (pick any)
.text$mn:00005850                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005850
.text$mn:00005850 ; =============== S U B R O U T I N E =======================================
.text$mn:00005850
.text$mn:00005850 ; Attributes: bp-based frame
.text$mn:00005850
.text$mn:00005850 ; public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<char>>> __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::insert(class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<char>>>, char)
.text$mn:00005850                 public ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z
.text$mn:00005850 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z proc near
.text$mn:00005850                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::push_back(char)+72p
.text$mn:00005850
.text$mn:00005850 var_5C          = byte ptr -5Ch
.text$mn:00005850 var_50          = byte ptr -50h
.text$mn:00005850 var_44          = dword ptr -44h
.text$mn:00005850 var_40          = dword ptr -40h
.text$mn:00005850 var_3C          = dword ptr -3Ch
.text$mn:00005850 var_38          = dword ptr -38h
.text$mn:00005850 var_34          = dword ptr -34h
.text$mn:00005850 var_30          = dword ptr -30h
.text$mn:00005850 var_2C          = dword ptr -2Ch
.text$mn:00005850 var_28          = dword ptr -28h
.text$mn:00005850 var_24          = dword ptr -24h
.text$mn:00005850 var_20          = dword ptr -20h
.text$mn:00005850 var_1C          = dword ptr -1Ch
.text$mn:00005850 var_18          = dword ptr -18h
.text$mn:00005850 var_14          = dword ptr -14h
.text$mn:00005850 var_10          = dword ptr -10h
.text$mn:00005850 var_C           = dword ptr -0Ch
.text$mn:00005850 var_4           = dword ptr -4
.text$mn:00005850 arg_0           = dword ptr  8
.text$mn:00005850 arg_4           = byte ptr  0Ch
.text$mn:00005850 arg_10          = byte ptr  18h
.text$mn:00005850
.text$mn:00005850                 push    ebp
.text$mn:00005851                 mov     ebp, esp
.text$mn:00005853                 push    0FFFFFFFFh
.text$mn:00005855                 push    offset __ehhandler$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z
.text$mn:0000585A                 mov     eax, large fs:0
.text$mn:00005860                 push    eax
.text$mn:00005861                 sub     esp, 50h
.text$mn:00005864                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005869                 xor     eax, ebp
.text$mn:0000586B                 push    eax
.text$mn:0000586C                 lea     eax, [ebp+var_C]
.text$mn:0000586F                 mov     large fs:0, eax
.text$mn:00005875                 mov     [ebp+var_10], ecx
.text$mn:00005878                 mov     [ebp+var_18], 0
.text$mn:0000587F                 mov     [ebp+var_4], 1
.text$mn:00005886                 lea     eax, [ebp+var_50]
.text$mn:00005889                 push    eax
.text$mn:0000588A                 mov     ecx, [ebp+var_10]
.text$mn:0000588D                 call    ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::begin(void)
.text$mn:00005892                 mov     [ebp+var_1C], eax
.text$mn:00005895                 mov     ecx, [ebp+var_1C]
.text$mn:00005898                 mov     [ebp+var_20], ecx
.text$mn:0000589B                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000589F                 sub     esp, 0Ch
.text$mn:000058A2                 mov     ecx, esp
.text$mn:000058A4                 mov     [ebp+var_38], esp
.text$mn:000058A7                 mov     edx, [ebp+var_20]
.text$mn:000058AA                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000058AB                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>> const &)
.text$mn:000058B0                 mov     [ebp+var_24], eax
.text$mn:000058B3                 mov     eax, [ebp+var_24]
.text$mn:000058B6                 mov     [ebp+var_3C], eax
.text$mn:000058B9                 mov     byte ptr [ebp+var_4], 3
.text$mn:000058BD                 sub     esp, 0Ch
.text$mn:000058C0                 mov     ecx, esp
.text$mn:000058C2                 mov     [ebp+var_40], esp
.text$mn:000058C5                 lea     edx, [ebp+arg_4]
.text$mn:000058C8                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000058C9                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>> const &)
.text$mn:000058CE                 mov     [ebp+var_28], eax
.text$mn:000058D1                 mov     eax, [ebp+var_28]
.text$mn:000058D4                 mov     [ebp+var_44], eax
.text$mn:000058D7                 mov     byte ptr [ebp+var_4], 4
.text$mn:000058DB                 mov     byte ptr [ebp+var_4], 2
.text$mn:000058DF                 call    ?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>)
.text$mn:000058E4                 add     esp, 18h
.text$mn:000058E7                 mov     [ebp+var_2C], eax
.text$mn:000058EA                 mov     ecx, [ebp+var_2C]
.text$mn:000058ED                 mov     [ebp+var_14], ecx
.text$mn:000058F0                 mov     byte ptr [ebp+var_4], 1
.text$mn:000058F4                 lea     ecx, [ebp+var_50]
.text$mn:000058F7                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$mn:000058FC                 movzx   edx, [ebp+arg_10]
.text$mn:00005900                 push    edx             ; char
.text$mn:00005901                 push    1               ; Size
.text$mn:00005903                 mov     eax, [ebp+var_14]
.text$mn:00005906                 push    eax             ; int
.text$mn:00005907                 mov     ecx, [ebp+var_10]
.text$mn:0000590A                 call    ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::insert(uint,uint,char)
.text$mn:0000590F                 mov     ecx, [ebp+var_14]
.text$mn:00005912                 push    ecx
.text$mn:00005913                 mov     edx, [ebp+arg_0]
.text$mn:00005916                 push    edx
.text$mn:00005917                 lea     eax, [ebp+var_5C]
.text$mn:0000591A                 push    eax
.text$mn:0000591B                 mov     ecx, [ebp+var_10]
.text$mn:0000591E                 call    ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::begin(void)
.text$mn:00005923                 mov     [ebp+var_30], eax
.text$mn:00005926                 mov     ecx, [ebp+var_30]
.text$mn:00005929                 mov     [ebp+var_34], ecx
.text$mn:0000592C                 mov     byte ptr [ebp+var_4], 5
.text$mn:00005930                 mov     ecx, [ebp+var_34]
.text$mn:00005933                 call    ??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE?AV01@H@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::operator+(int)
.text$mn:00005938                 mov     edx, [ebp+var_18]
.text$mn:0000593B                 or      edx, 1
.text$mn:0000593E                 mov     [ebp+var_18], edx
.text$mn:00005941                 mov     byte ptr [ebp+var_4], 1
.text$mn:00005945                 lea     ecx, [ebp+var_5C]
.text$mn:00005948                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$mn:0000594D                 mov     byte ptr [ebp+var_4], 0
.text$mn:00005951                 lea     ecx, [ebp+arg_4]
.text$mn:00005954                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$mn:00005959                 mov     eax, [ebp+arg_0]
.text$mn:0000595C                 mov     ecx, [ebp+var_C]
.text$mn:0000595F                 mov     large fs:0, ecx
.text$mn:00005966                 pop     ecx
.text$mn:00005967                 mov     esp, ebp
.text$mn:00005969                 pop     ebp
.text$mn:0000596A                 retn    14h
.text$mn:0000596A ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z endp
.text$mn:0000596A
.text$mn:0000596A ; ---------------------------------------------------------------------------
.text$mn:0000596D                 align 10h
.text$mn:0000596D _text$mn        ends
.text$mn:0000596D
.text$x:00005970 ; ===========================================================================
.text$x:00005970
.text$x:00005970 ; Segment type: Pure code
.text$x:00005970 ; Segment permissions: Read/Execute
.text$x:00005970 _text$x         segment para public 'CODE' use32
.text$x:00005970                 assume cs:_text$x
.text$x:00005970                 ;org 5970h
.text$x:00005970 ; COMDAT (pick associative to section at 5850)
.text$x:00005970                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005970
.text$x:00005970 ; =============== S U B R O U T I N E =======================================
.text$x:00005970
.text$x:00005970
.text$x:00005970 __unwindfunclet$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z$0 proc near
.text$x:00005970                                         ; DATA XREF: .xdata$x:00006340o
.text$x:00005970                 lea     ecx, [ebp+0Ch]
.text$x:00005973                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$x:00005973 __unwindfunclet$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z$0 endp
.text$x:00005973
.text$x:00005978
.text$x:00005978 ; =============== S U B R O U T I N E =======================================
.text$x:00005978
.text$x:00005978
.text$x:00005978 __unwindfunclet$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z$1 proc near
.text$x:00005978                                         ; DATA XREF: .xdata$x:00006348o
.text$x:00005978                 lea     ecx, [ebp-50h]
.text$x:0000597B                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$x:0000597B __unwindfunclet$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z$1 endp
.text$x:0000597B
.text$x:00005980
.text$x:00005980 ; =============== S U B R O U T I N E =======================================
.text$x:00005980
.text$x:00005980
.text$x:00005980 __unwindfunclet$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z$2 proc near
.text$x:00005980                                         ; DATA XREF: .xdata$x:00006350o
.text$x:00005980                 mov     ecx, [ebp-38h]
.text$x:00005983                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$x:00005983 __unwindfunclet$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z$2 endp
.text$x:00005983
.text$x:00005988
.text$x:00005988 ; =============== S U B R O U T I N E =======================================
.text$x:00005988
.text$x:00005988
.text$x:00005988 __unwindfunclet$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z$3 proc near
.text$x:00005988                                         ; DATA XREF: .xdata$x:00006358o
.text$x:00005988                 mov     ecx, [ebp-40h]
.text$x:0000598B                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$x:0000598B __unwindfunclet$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z$3 endp
.text$x:0000598B
.text$x:00005990
.text$x:00005990 ; =============== S U B R O U T I N E =======================================
.text$x:00005990
.text$x:00005990
.text$x:00005990 __unwindfunclet$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z$4 proc near
.text$x:00005990                                         ; DATA XREF: .xdata$x:00006360o
.text$x:00005990                 lea     ecx, [ebp-5Ch]
.text$x:00005993                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$x:00005993 __unwindfunclet$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z$4 endp
.text$x:00005993
.text$x:00005998
.text$x:00005998 ; =============== S U B R O U T I N E =======================================
.text$x:00005998
.text$x:00005998
.text$x:00005998 __unwindfunclet$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z$5 proc near
.text$x:00005998                                         ; DATA XREF: .xdata$x:00006338o
.text$x:00005998                 mov     eax, [ebp-18h]
.text$x:0000599B                 and     eax, 1
.text$x:0000599E                 jz      $LN9
.text$x:000059A4                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:000059A8                 mov     ecx, [ebp+8]
.text$x:000059AB                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$x:000059B0 ; ---------------------------------------------------------------------------
.text$x:000059B0
.text$x:000059B0 $LN9:                                   ; CODE XREF: __unwindfunclet$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z$5+6j
.text$x:000059B0                 retn
.text$x:000059B0 __unwindfunclet$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z$5 endp
.text$x:000059B0
.text$x:000059B1
.text$x:000059B1 ; =============== S U B R O U T I N E =======================================
.text$x:000059B1
.text$x:000059B1
.text$x:000059B1 __ehhandler$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z proc near
.text$x:000059B1                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::insert(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>,char)+5o
.text$x:000059B1
.text$x:000059B1 arg_4           = dword ptr  8
.text$x:000059B1
.text$x:000059B1                 mov     edx, [esp+arg_4]
.text$x:000059B5                 lea     eax, [edx+0Ch]
.text$x:000059B8                 mov     ecx, [edx-54h]
.text$x:000059BB                 xor     ecx, eax
.text$x:000059BD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000059C2                 mov     eax, offset __ehfuncinfo$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z
.text$x:000059C7                 jmp     ___CxxFrameHandler3
.text$x:000059C7 __ehhandler$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z endp
.text$x:000059C7
.text$x:000059C7 _text$x         ends
.text$x:000059C7
.text$mn:000059CC ; ===========================================================================
.text$mn:000059CC
.text$mn:000059CC ; Segment type: Pure code
.text$mn:000059CC ; Segment permissions: Read/Execute
.text$mn:000059CC _text$mn        segment para public 'CODE' use32
.text$mn:000059CC                 assume cs:_text$mn
.text$mn:000059CC                 ;org 59CCh
.text$mn:000059CC ; COMDAT (pick any)
.text$mn:000059CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000059CC
.text$mn:000059CC ; =============== S U B R O U T I N E =======================================
.text$mn:000059CC
.text$mn:000059CC ; Attributes: bp-based frame
.text$mn:000059CC
.text$mn:000059CC ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::insert(int, size_t Size, char)
.text$mn:000059CC                 public ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z
.text$mn:000059CC ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z proc near
.text$mn:000059CC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::insert(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>,char)+BAp
.text$mn:000059CC
.text$mn:000059CC var_8           = dword ptr -8
.text$mn:000059CC var_4           = dword ptr -4
.text$mn:000059CC arg_0           = dword ptr  8
.text$mn:000059CC Size            = dword ptr  0Ch
.text$mn:000059CC arg_8           = byte ptr  10h
.text$mn:000059CC
.text$mn:000059CC                 push    ebp
.text$mn:000059CD                 mov     ebp, esp
.text$mn:000059CF                 sub     esp, 8
.text$mn:000059D2                 mov     [ebp+var_4], ecx
.text$mn:000059D5                 mov     eax, [ebp+var_4]
.text$mn:000059D8                 mov     ecx, [eax+14h]
.text$mn:000059DB                 cmp     ecx, [ebp+arg_0]
.text$mn:000059DE                 jnb     short loc_59E8
.text$mn:000059E0                 mov     ecx, [ebp+var_4]
.text$mn:000059E3                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000059E8
.text$mn:000059E8 loc_59E8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::insert(uint,uint,char)+12j
.text$mn:000059E8                 mov     edx, [ebp+var_4]
.text$mn:000059EB                 mov     eax, ds:?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; uint const std::basic_string<char,std::char_traits<char>,std::allocator<char>>::npos
.text$mn:000059F0                 sub     eax, [edx+14h]
.text$mn:000059F3                 cmp     eax, [ebp+Size]
.text$mn:000059F6                 ja      short loc_5A00
.text$mn:000059F8                 mov     ecx, [ebp+var_4]
.text$mn:000059FB                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00005A00
.text$mn:00005A00 loc_5A00:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::insert(uint,uint,char)+2Aj
.text$mn:00005A00                 cmp     [ebp+Size], 0
.text$mn:00005A04                 jbe     short loc_5A75
.text$mn:00005A06                 mov     ecx, [ebp+var_4]
.text$mn:00005A09                 mov     edx, [ecx+14h]
.text$mn:00005A0C                 add     edx, [ebp+Size]
.text$mn:00005A0F                 mov     [ebp+var_8], edx
.text$mn:00005A12                 push    0
.text$mn:00005A14                 mov     eax, [ebp+var_8]
.text$mn:00005A17                 push    eax
.text$mn:00005A18                 mov     ecx, [ebp+var_4]
.text$mn:00005A1B                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00005A20                 movzx   ecx, al
.text$mn:00005A23                 test    ecx, ecx
.text$mn:00005A25                 jz      short loc_5A75
.text$mn:00005A27                 mov     edx, [ebp+var_4]
.text$mn:00005A2A                 mov     eax, [edx+14h]
.text$mn:00005A2D                 sub     eax, [ebp+arg_0]
.text$mn:00005A30                 push    eax             ; Size
.text$mn:00005A31                 mov     ecx, [ebp+var_4]
.text$mn:00005A34                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00005A39                 add     eax, [ebp+arg_0]
.text$mn:00005A3C                 push    eax             ; Src
.text$mn:00005A3D                 mov     ecx, [ebp+var_4]
.text$mn:00005A40                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00005A45                 add     eax, [ebp+arg_0]
.text$mn:00005A48                 add     eax, [ebp+Size]
.text$mn:00005A4B                 push    eax             ; Dst
.text$mn:00005A4C                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00005A51                 add     esp, 0Ch
.text$mn:00005A54                 movzx   ecx, [ebp+arg_8]
.text$mn:00005A58                 push    ecx             ; char
.text$mn:00005A59                 mov     edx, [ebp+Size]
.text$mn:00005A5C                 push    edx             ; Size
.text$mn:00005A5D                 mov     eax, [ebp+arg_0]
.text$mn:00005A60                 push    eax             ; int
.text$mn:00005A61                 mov     ecx, [ebp+var_4]
.text$mn:00005A64                 call    ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Chassign(uint,uint,char)
.text$mn:00005A69                 mov     ecx, [ebp+var_8]
.text$mn:00005A6C                 push    ecx
.text$mn:00005A6D                 mov     ecx, [ebp+var_4]
.text$mn:00005A70                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00005A75
.text$mn:00005A75 loc_5A75:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::insert(uint,uint,char)+38j
.text$mn:00005A75                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::insert(uint,uint,char)+59j
.text$mn:00005A75                 mov     eax, [ebp+var_4]
.text$mn:00005A78                 mov     esp, ebp
.text$mn:00005A7A                 pop     ebp
.text$mn:00005A7B                 retn    0Ch
.text$mn:00005A7B ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z endp
.text$mn:00005A7B
.text$mn:00005A7B ; ---------------------------------------------------------------------------
.text$mn:00005A7E                 align 10h
.text$mn:00005A7E _text$mn        ends
.text$mn:00005A7E
.text$mn:00005A80 ; ===========================================================================
.text$mn:00005A80
.text$mn:00005A80 ; Segment type: Pure code
.text$mn:00005A80 ; Segment permissions: Read/Execute
.text$mn:00005A80 _text$mn        segment para public 'CODE' use32
.text$mn:00005A80                 assume cs:_text$mn
.text$mn:00005A80                 ;org 5A80h
.text$mn:00005A80 ; COMDAT (pick any)
.text$mn:00005A80                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A80
.text$mn:00005A80 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A80
.text$mn:00005A80 ; Attributes: bp-based frame
.text$mn:00005A80
.text$mn:00005A80 ; bool __thiscall ScintillaEditView::isShownIndentGuide(ScintillaEditView *__hidden this)
.text$mn:00005A80                 public ?isShownIndentGuide@ScintillaEditView@@QBE_NXZ
.text$mn:00005A80 ?isShownIndentGuide@ScintillaEditView@@QBE_NXZ proc near
.text$mn:00005A80                                         ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+388p
.text$mn:00005A80
.text$mn:00005A80 var_8           = dword ptr -8
.text$mn:00005A80 var_4           = dword ptr -4
.text$mn:00005A80
.text$mn:00005A80                 push    ebp
.text$mn:00005A81                 mov     ebp, esp
.text$mn:00005A83                 sub     esp, 8
.text$mn:00005A86                 mov     [ebp+var_8], ecx
.text$mn:00005A89                 push    0               ; __int32
.text$mn:00005A8B                 push    0               ; unsigned int
.text$mn:00005A8D                 push    855h            ; unsigned int
.text$mn:00005A92                 mov     ecx, [ebp+var_8] ; this
.text$mn:00005A95                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00005A9A                 test    eax, eax
.text$mn:00005A9C                 jz      short loc_5AA7
.text$mn:00005A9E                 mov     [ebp+var_4], 1
.text$mn:00005AA5                 jmp     short loc_5AAE
.text$mn:00005AA7 ; ---------------------------------------------------------------------------
.text$mn:00005AA7
.text$mn:00005AA7 loc_5AA7:                               ; CODE XREF: ScintillaEditView::isShownIndentGuide(void)+1Cj
.text$mn:00005AA7                 mov     [ebp+var_4], 0
.text$mn:00005AAE
.text$mn:00005AAE loc_5AAE:                               ; CODE XREF: ScintillaEditView::isShownIndentGuide(void)+25j
.text$mn:00005AAE                 mov     al, byte ptr [ebp+var_4]
.text$mn:00005AB1                 mov     esp, ebp
.text$mn:00005AB3                 pop     ebp
.text$mn:00005AB4                 retn
.text$mn:00005AB4 ?isShownIndentGuide@ScintillaEditView@@QBE_NXZ endp
.text$mn:00005AB4
.text$mn:00005AB4 ; ---------------------------------------------------------------------------
.text$mn:00005AB5                 align 4
.text$mn:00005AB5 _text$mn        ends
.text$mn:00005AB5
.text$mn:00005AB8 ; ===========================================================================
.text$mn:00005AB8
.text$mn:00005AB8 ; Segment type: Pure code
.text$mn:00005AB8 ; Segment permissions: Read/Execute
.text$mn:00005AB8 _text$mn        segment para public 'CODE' use32
.text$mn:00005AB8                 assume cs:_text$mn
.text$mn:00005AB8                 ;org 5AB8h
.text$mn:00005AB8 ; COMDAT (pick any)
.text$mn:00005AB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005AB8
.text$mn:00005AB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005AB8
.text$mn:00005AB8 ; Attributes: bp-based frame
.text$mn:00005AB8
.text$mn:00005AB8 ; bool __thiscall XmlMatchedTagsHighlighter::isWhitespace(XmlMatchedTagsHighlighter *this, int)
.text$mn:00005AB8                 public ?isWhitespace@XmlMatchedTagsHighlighter@@AAE_NH@Z
.text$mn:00005AB8 ?isWhitespace@XmlMatchedTagsHighlighter@@AAE_NH@Z proc near
.text$mn:00005AB8                                         ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+27Cp
.text$mn:00005AB8                                         ; XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+530p ...
.text$mn:00005AB8
.text$mn:00005AB8 var_8           = dword ptr -8
.text$mn:00005AB8 var_4           = dword ptr -4
.text$mn:00005AB8 arg_0           = dword ptr  8
.text$mn:00005AB8
.text$mn:00005AB8                 push    ebp
.text$mn:00005AB9                 mov     ebp, esp
.text$mn:00005ABB                 sub     esp, 8
.text$mn:00005ABE                 mov     [ebp+var_8], ecx
.text$mn:00005AC1                 cmp     [ebp+arg_0], 20h ; ' '
.text$mn:00005AC5                 jz      short loc_5AE2
.text$mn:00005AC7                 cmp     [ebp+arg_0], 9
.text$mn:00005ACB                 jz      short loc_5AE2
.text$mn:00005ACD                 cmp     [ebp+arg_0], 0Dh
.text$mn:00005AD1                 jz      short loc_5AE2
.text$mn:00005AD3                 cmp     [ebp+arg_0], 0Ah
.text$mn:00005AD7                 jz      short loc_5AE2
.text$mn:00005AD9                 mov     [ebp+var_4], 0
.text$mn:00005AE0                 jmp     short loc_5AE9
.text$mn:00005AE2 ; ---------------------------------------------------------------------------
.text$mn:00005AE2
.text$mn:00005AE2 loc_5AE2:                               ; CODE XREF: XmlMatchedTagsHighlighter::isWhitespace(int)+Dj
.text$mn:00005AE2                                         ; XmlMatchedTagsHighlighter::isWhitespace(int)+13j ...
.text$mn:00005AE2                 mov     [ebp+var_4], 1
.text$mn:00005AE9
.text$mn:00005AE9 loc_5AE9:                               ; CODE XREF: XmlMatchedTagsHighlighter::isWhitespace(int)+28j
.text$mn:00005AE9                 mov     al, byte ptr [ebp+var_4]
.text$mn:00005AEC                 mov     esp, ebp
.text$mn:00005AEE                 pop     ebp
.text$mn:00005AEF                 retn    4
.text$mn:00005AEF ?isWhitespace@XmlMatchedTagsHighlighter@@AAE_NH@Z endp
.text$mn:00005AEF
.text$mn:00005AEF ; ---------------------------------------------------------------------------
.text$mn:00005AF2                 align 4
.text$mn:00005AF2 _text$mn        ends
.text$mn:00005AF2
.text$mn:00005AF4 ; ===========================================================================
.text$mn:00005AF4
.text$mn:00005AF4 ; Segment type: Pure code
.text$mn:00005AF4 ; Segment permissions: Read/Execute
.text$mn:00005AF4 _text$mn        segment para public 'CODE' use32
.text$mn:00005AF4                 assume cs:_text$mn
.text$mn:00005AF4                 ;org 5AF4h
.text$mn:00005AF4 ; COMDAT (pick any)
.text$mn:00005AF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005AF4
.text$mn:00005AF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005AF4
.text$mn:00005AF4 ; Attributes: bp-based frame
.text$mn:00005AF4
.text$mn:00005AF4 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00005AF4                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00005AF4 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00005AF4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00005AF4
.text$mn:00005AF4 var_4           = dword ptr -4
.text$mn:00005AF4 Str             = dword ptr  8
.text$mn:00005AF4
.text$mn:00005AF4                 push    ebp
.text$mn:00005AF5                 mov     ebp, esp
.text$mn:00005AF7                 push    ecx
.text$mn:00005AF8                 mov     eax, [ebp+Str]
.text$mn:00005AFB                 movsx   ecx, byte ptr [eax]
.text$mn:00005AFE                 test    ecx, ecx
.text$mn:00005B00                 jnz     short loc_5B0B
.text$mn:00005B02                 mov     [ebp+var_4], 0
.text$mn:00005B09                 jmp     short loc_5B1A
.text$mn:00005B0B ; ---------------------------------------------------------------------------
.text$mn:00005B0B
.text$mn:00005B0B loc_5B0B:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00005B0B                 mov     edx, [ebp+Str]
.text$mn:00005B0E                 push    edx             ; Str
.text$mn:00005B0F                 call    _strlen
.text$mn:00005B14                 add     esp, 4
.text$mn:00005B17                 mov     [ebp+var_4], eax
.text$mn:00005B1A
.text$mn:00005B1A loc_5B1A:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00005B1A                 mov     eax, [ebp+var_4]
.text$mn:00005B1D                 mov     esp, ebp
.text$mn:00005B1F                 pop     ebp
.text$mn:00005B20                 retn
.text$mn:00005B20 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00005B20
.text$mn:00005B20 ; ---------------------------------------------------------------------------
.text$mn:00005B21                 align 4
.text$mn:00005B21 _text$mn        ends
.text$mn:00005B21
.text$mn:00005B24 ; ===========================================================================
.text$mn:00005B24
.text$mn:00005B24 ; Segment type: Pure code
.text$mn:00005B24 ; Segment permissions: Read/Execute
.text$mn:00005B24 _text$mn        segment para public 'CODE' use32
.text$mn:00005B24                 assume cs:_text$mn
.text$mn:00005B24                 ;org 5B24h
.text$mn:00005B24 ; COMDAT (pick any)
.text$mn:00005B24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005B24
.text$mn:00005B24 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B24
.text$mn:00005B24 ; Attributes: bp-based frame
.text$mn:00005B24
.text$mn:00005B24 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00005B24                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00005B24 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00005B24                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00005B24
.text$mn:00005B24 var_4           = dword ptr -4
.text$mn:00005B24
.text$mn:00005B24                 push    ebp
.text$mn:00005B25                 mov     ebp, esp
.text$mn:00005B27                 push    ecx
.text$mn:00005B28                 mov     [ebp+var_4], ecx
.text$mn:00005B2B                 mov     eax, [ebp+var_4]
.text$mn:00005B2E                 push    eax
.text$mn:00005B2F                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00005B34                 add     esp, 4
.text$mn:00005B37                 mov     esp, ebp
.text$mn:00005B39                 pop     ebp
.text$mn:00005B3A                 retn
.text$mn:00005B3A ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:00005B3A
.text$mn:00005B3A ; ---------------------------------------------------------------------------
.text$mn:00005B3B                 align 4
.text$mn:00005B3B _text$mn        ends
.text$mn:00005B3B
.text$mn:00005B3C ; ===========================================================================
.text$mn:00005B3C
.text$mn:00005B3C ; Segment type: Pure code
.text$mn:00005B3C ; Segment permissions: Read/Execute
.text$mn:00005B3C _text$mn        segment para public 'CODE' use32
.text$mn:00005B3C                 assume cs:_text$mn
.text$mn:00005B3C                 ;org 5B3Ch
.text$mn:00005B3C ; COMDAT (pick any)
.text$mn:00005B3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005B3C
.text$mn:00005B3C ; =============== S U B R O U T I N E =======================================
.text$mn:00005B3C
.text$mn:00005B3C ; Attributes: bp-based frame
.text$mn:00005B3C
.text$mn:00005B3C ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<struct std::pair<int, int>>>::max_size(void)const
.text$mn:00005B3C                 public ?max_size@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QBEIXZ
.text$mn:00005B3C ?max_size@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QBEIXZ proc near
.text$mn:00005B3C                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::max_size(void)+17p
.text$mn:00005B3C
.text$mn:00005B3C var_4           = dword ptr -4
.text$mn:00005B3C
.text$mn:00005B3C                 push    ebp
.text$mn:00005B3D                 mov     ebp, esp
.text$mn:00005B3F                 push    ecx
.text$mn:00005B40                 mov     [ebp+var_4], ecx
.text$mn:00005B43                 mov     eax, [ebp+var_4]
.text$mn:00005B46                 push    eax
.text$mn:00005B47                 call    ?max_size@?$allocator_traits@V?$allocator@U?$pair@HH@std@@@std@@@std@@SAIABV?$allocator@U?$pair@HH@std@@@2@@Z ; std::allocator_traits<std::allocator<std::pair<int,int>>>::max_size(std::allocator<std::pair<int,int>> const &)
.text$mn:00005B4C                 add     esp, 4
.text$mn:00005B4F                 mov     esp, ebp
.text$mn:00005B51                 pop     ebp
.text$mn:00005B52                 retn
.text$mn:00005B52 ?max_size@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QBEIXZ endp
.text$mn:00005B52
.text$mn:00005B52 ; ---------------------------------------------------------------------------
.text$mn:00005B53                 align 4
.text$mn:00005B53 _text$mn        ends
.text$mn:00005B53
.text$mn:00005B54 ; ===========================================================================
.text$mn:00005B54
.text$mn:00005B54 ; Segment type: Pure code
.text$mn:00005B54 ; Segment permissions: Read/Execute
.text$mn:00005B54 _text$mn        segment para public 'CODE' use32
.text$mn:00005B54                 assume cs:_text$mn
.text$mn:00005B54                 ;org 5B54h
.text$mn:00005B54 ; COMDAT (pick any)
.text$mn:00005B54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005B54
.text$mn:00005B54 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B54
.text$mn:00005B54 ; Attributes: bp-based frame
.text$mn:00005B54
.text$mn:00005B54 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00005B54                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00005B54 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00005B54                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00005B54
.text$mn:00005B54 var_4           = dword ptr -4
.text$mn:00005B54
.text$mn:00005B54                 push    ebp
.text$mn:00005B55                 mov     ebp, esp
.text$mn:00005B57                 push    ecx
.text$mn:00005B58                 mov     [ebp+var_4], ecx
.text$mn:00005B5B                 or      eax, 0FFFFFFFFh
.text$mn:00005B5E                 mov     esp, ebp
.text$mn:00005B60                 pop     ebp
.text$mn:00005B61                 retn
.text$mn:00005B61 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00005B61
.text$mn:00005B61 ; ---------------------------------------------------------------------------
.text$mn:00005B62                 align 4
.text$mn:00005B62 _text$mn        ends
.text$mn:00005B62
.text$mn:00005B64 ; ===========================================================================
.text$mn:00005B64
.text$mn:00005B64 ; Segment type: Pure code
.text$mn:00005B64 ; Segment permissions: Read/Execute
.text$mn:00005B64 _text$mn        segment para public 'CODE' use32
.text$mn:00005B64                 assume cs:_text$mn
.text$mn:00005B64                 ;org 5B64h
.text$mn:00005B64 ; COMDAT (pick any)
.text$mn:00005B64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005B64
.text$mn:00005B64 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B64
.text$mn:00005B64 ; Attributes: bp-based frame
.text$mn:00005B64
.text$mn:00005B64 ; public: unsigned int __thiscall std::allocator<struct std::pair<int, int>>::max_size(void)const
.text$mn:00005B64                 public ?max_size@?$allocator@U?$pair@HH@std@@@std@@QBEIXZ
.text$mn:00005B64 ?max_size@?$allocator@U?$pair@HH@std@@@std@@QBEIXZ proc near
.text$mn:00005B64                                         ; CODE XREF: std::allocator_traits<std::allocator<std::pair<int,int>>>::max_size(std::allocator<std::pair<int,int>> const &)+6p
.text$mn:00005B64
.text$mn:00005B64 var_4           = dword ptr -4
.text$mn:00005B64
.text$mn:00005B64                 push    ebp
.text$mn:00005B65                 mov     ebp, esp
.text$mn:00005B67                 push    ecx
.text$mn:00005B68                 mov     [ebp+var_4], ecx
.text$mn:00005B6B                 mov     eax, 1FFFFFFFh
.text$mn:00005B70                 mov     esp, ebp
.text$mn:00005B72                 pop     ebp
.text$mn:00005B73                 retn
.text$mn:00005B73 ?max_size@?$allocator@U?$pair@HH@std@@@std@@QBEIXZ endp
.text$mn:00005B73
.text$mn:00005B73 _text$mn        ends
.text$mn:00005B73
.text$mn:00005B74 ; ===========================================================================
.text$mn:00005B74
.text$mn:00005B74 ; Segment type: Pure code
.text$mn:00005B74 ; Segment permissions: Read/Execute
.text$mn:00005B74 _text$mn        segment para public 'CODE' use32
.text$mn:00005B74                 assume cs:_text$mn
.text$mn:00005B74                 ;org 5B74h
.text$mn:00005B74 ; COMDAT (pick any)
.text$mn:00005B74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005B74
.text$mn:00005B74 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B74
.text$mn:00005B74 ; Attributes: bp-based frame
.text$mn:00005B74
.text$mn:00005B74 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:00005B74                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:00005B74 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:00005B74                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:00005B74
.text$mn:00005B74 arg_0           = dword ptr  8
.text$mn:00005B74
.text$mn:00005B74                 push    ebp
.text$mn:00005B75                 mov     ebp, esp
.text$mn:00005B77                 mov     ecx, [ebp+arg_0]
.text$mn:00005B7A                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:00005B7F                 pop     ebp
.text$mn:00005B80                 retn
.text$mn:00005B80 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00005B80
.text$mn:00005B80 ; ---------------------------------------------------------------------------
.text$mn:00005B81                 align 4
.text$mn:00005B81 _text$mn        ends
.text$mn:00005B81
.text$mn:00005B84 ; ===========================================================================
.text$mn:00005B84
.text$mn:00005B84 ; Segment type: Pure code
.text$mn:00005B84 ; Segment permissions: Read/Execute
.text$mn:00005B84 _text$mn        segment para public 'CODE' use32
.text$mn:00005B84                 assume cs:_text$mn
.text$mn:00005B84                 ;org 5B84h
.text$mn:00005B84 ; COMDAT (pick any)
.text$mn:00005B84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005B84
.text$mn:00005B84 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B84
.text$mn:00005B84 ; Attributes: bp-based frame
.text$mn:00005B84
.text$mn:00005B84 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<struct std::pair<int, int>>>::max_size(class std::allocator<struct std::pair<int, int>> const &)
.text$mn:00005B84                 public ?max_size@?$allocator_traits@V?$allocator@U?$pair@HH@std@@@std@@@std@@SAIABV?$allocator@U?$pair@HH@std@@@2@@Z
.text$mn:00005B84 ?max_size@?$allocator_traits@V?$allocator@U?$pair@HH@std@@@std@@@std@@SAIABV?$allocator@U?$pair@HH@std@@@2@@Z proc near
.text$mn:00005B84                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::pair<int,int>>>::max_size(void)+Bp
.text$mn:00005B84
.text$mn:00005B84 arg_0           = dword ptr  8
.text$mn:00005B84
.text$mn:00005B84                 push    ebp
.text$mn:00005B85                 mov     ebp, esp
.text$mn:00005B87                 mov     ecx, [ebp+arg_0]
.text$mn:00005B8A                 call    ?max_size@?$allocator@U?$pair@HH@std@@@std@@QBEIXZ ; std::allocator<std::pair<int,int>>::max_size(void)
.text$mn:00005B8F                 pop     ebp
.text$mn:00005B90                 retn
.text$mn:00005B90 ?max_size@?$allocator_traits@V?$allocator@U?$pair@HH@std@@@std@@@std@@SAIABV?$allocator@U?$pair@HH@std@@@2@@Z endp
.text$mn:00005B90
.text$mn:00005B90 ; ---------------------------------------------------------------------------
.text$mn:00005B91                 align 4
.text$mn:00005B91 _text$mn        ends
.text$mn:00005B91
.text$mn:00005B94 ; ===========================================================================
.text$mn:00005B94
.text$mn:00005B94 ; Segment type: Pure code
.text$mn:00005B94 ; Segment permissions: Read/Execute
.text$mn:00005B94 _text$mn        segment para public 'CODE' use32
.text$mn:00005B94                 assume cs:_text$mn
.text$mn:00005B94                 ;org 5B94h
.text$mn:00005B94 ; COMDAT (pick any)
.text$mn:00005B94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005B94
.text$mn:00005B94 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B94
.text$mn:00005B94 ; Attributes: bp-based frame
.text$mn:00005B94
.text$mn:00005B94 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:00005B94                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00005B94 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00005B94                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:00005B94                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:00005B94
.text$mn:00005B94 var_10          = dword ptr -10h
.text$mn:00005B94 var_C           = dword ptr -0Ch
.text$mn:00005B94 var_8           = dword ptr -8
.text$mn:00005B94 var_1           = byte ptr -1
.text$mn:00005B94
.text$mn:00005B94                 push    ebp
.text$mn:00005B95                 mov     ebp, esp
.text$mn:00005B97                 sub     esp, 10h
.text$mn:00005B9A                 mov     [ebp+var_10], ecx
.text$mn:00005B9D                 lea     eax, [ebp+var_1]
.text$mn:00005BA0                 push    eax
.text$mn:00005BA1                 mov     ecx, [ebp+var_10]
.text$mn:00005BA4                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00005BA9                 mov     ecx, eax
.text$mn:00005BAB                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00005BB0                 mov     [ebp+var_8], eax
.text$mn:00005BB3                 cmp     [ebp+var_8], 1
.text$mn:00005BB7                 ja      short loc_5BC2
.text$mn:00005BB9                 mov     [ebp+var_C], 1
.text$mn:00005BC0                 jmp     short loc_5BCB
.text$mn:00005BC2 ; ---------------------------------------------------------------------------
.text$mn:00005BC2
.text$mn:00005BC2 loc_5BC2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:00005BC2                 mov     ecx, [ebp+var_8]
.text$mn:00005BC5                 sub     ecx, 1
.text$mn:00005BC8                 mov     [ebp+var_C], ecx
.text$mn:00005BCB
.text$mn:00005BCB loc_5BCB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00005BCB                 mov     eax, [ebp+var_C]
.text$mn:00005BCE                 mov     esp, ebp
.text$mn:00005BD0                 pop     ebp
.text$mn:00005BD1                 retn
.text$mn:00005BD1 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00005BD1
.text$mn:00005BD1 ; ---------------------------------------------------------------------------
.text$mn:00005BD2                 align 4
.text$mn:00005BD2 _text$mn        ends
.text$mn:00005BD2
.text$mn:00005BD4 ; ===========================================================================
.text$mn:00005BD4
.text$mn:00005BD4 ; Segment type: Pure code
.text$mn:00005BD4 ; Segment permissions: Read/Execute
.text$mn:00005BD4 _text$mn        segment para public 'CODE' use32
.text$mn:00005BD4                 assume cs:_text$mn
.text$mn:00005BD4                 ;org 5BD4h
.text$mn:00005BD4 ; COMDAT (pick any)
.text$mn:00005BD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005BD4
.text$mn:00005BD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005BD4
.text$mn:00005BD4 ; Attributes: bp-based frame
.text$mn:00005BD4
.text$mn:00005BD4 ; public: unsigned int __thiscall std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>::max_size(void)const
.text$mn:00005BD4                 public ?max_size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ
.text$mn:00005BD4 ?max_size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ proc near
.text$mn:00005BD4                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Grow_to(uint)+17p
.text$mn:00005BD4                                         ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Reserve(uint)+18p
.text$mn:00005BD4
.text$mn:00005BD4 var_8           = dword ptr -8
.text$mn:00005BD4 var_1           = byte ptr -1
.text$mn:00005BD4
.text$mn:00005BD4                 push    ebp
.text$mn:00005BD5                 mov     ebp, esp
.text$mn:00005BD7                 sub     esp, 8
.text$mn:00005BDA                 mov     [ebp+var_8], ecx
.text$mn:00005BDD                 lea     eax, [ebp+var_1]
.text$mn:00005BE0                 push    eax
.text$mn:00005BE1                 mov     ecx, [ebp+var_8]
.text$mn:00005BE4                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Getal(void)
.text$mn:00005BE9                 mov     ecx, eax
.text$mn:00005BEB                 call    ?max_size@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::pair<int,int>>>::max_size(void)
.text$mn:00005BF0                 mov     esp, ebp
.text$mn:00005BF2                 pop     ebp
.text$mn:00005BF3                 retn
.text$mn:00005BF3 ?max_size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ endp
.text$mn:00005BF3
.text$mn:00005BF3 _text$mn        ends
.text$mn:00005BF3
.text$mn:00005BF4 ; ===========================================================================
.text$mn:00005BF4
.text$mn:00005BF4 ; Segment type: Pure code
.text$mn:00005BF4 ; Segment permissions: Read/Execute
.text$mn:00005BF4 _text$mn        segment para public 'CODE' use32
.text$mn:00005BF4                 assume cs:_text$mn
.text$mn:00005BF4                 ;org 5BF4h
.text$mn:00005BF4 ; COMDAT (pick any)
.text$mn:00005BF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005BF4
.text$mn:00005BF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005BF4
.text$mn:00005BF4 ; Attributes: bp-based frame
.text$mn:00005BF4
.text$mn:00005BF4 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00005BF4                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00005BF4 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00005BF4                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00005BF4                                         ; DATA XREF: .rdata:00006C80o
.text$mn:00005BF4
.text$mn:00005BF4 var_1C          = dword ptr -1Ch
.text$mn:00005BF4 var_18          = dword ptr -18h
.text$mn:00005BF4 Str             = dword ptr -14h
.text$mn:00005BF4 var_10          = dword ptr -10h
.text$mn:00005BF4 var_C           = dword ptr -0Ch
.text$mn:00005BF4 var_4           = dword ptr -4
.text$mn:00005BF4 arg_0           = dword ptr  8
.text$mn:00005BF4 arg_4           = dword ptr  0Ch
.text$mn:00005BF4
.text$mn:00005BF4                 push    ebp
.text$mn:00005BF5                 mov     ebp, esp
.text$mn:00005BF7                 push    0FFFFFFFFh
.text$mn:00005BF9                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00005BFE                 mov     eax, large fs:0
.text$mn:00005C04                 push    eax
.text$mn:00005C05                 sub     esp, 10h
.text$mn:00005C08                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005C0D                 xor     eax, ebp
.text$mn:00005C0F                 push    eax
.text$mn:00005C10                 lea     eax, [ebp+var_C]
.text$mn:00005C13                 mov     large fs:0, eax
.text$mn:00005C19                 mov     [ebp+var_1C], ecx
.text$mn:00005C1C                 mov     [ebp+var_18], 0
.text$mn:00005C23                 mov     eax, [ebp+arg_4]
.text$mn:00005C26                 push    eax             ; int
.text$mn:00005C27                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00005C2C                 add     esp, 4
.text$mn:00005C2F                 mov     [ebp+var_10], eax
.text$mn:00005C32                 cmp     [ebp+var_10], 0
.text$mn:00005C36                 jz      short loc_5C40
.text$mn:00005C38                 mov     ecx, [ebp+var_10]
.text$mn:00005C3B                 mov     [ebp+Str], ecx
.text$mn:00005C3E                 jmp     short loc_5C47
.text$mn:00005C40 ; ---------------------------------------------------------------------------
.text$mn:00005C40
.text$mn:00005C40 loc_5C40:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00005C40                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00005C47
.text$mn:00005C47 loc_5C47:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:00005C47                 mov     edx, [ebp+Str]
.text$mn:00005C4A                 push    edx             ; Str
.text$mn:00005C4B                 mov     ecx, [ebp+arg_0]
.text$mn:00005C4E                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00005C53                 mov     [ebp+var_4], 0
.text$mn:00005C5A                 mov     eax, [ebp+var_18]
.text$mn:00005C5D                 or      eax, 1
.text$mn:00005C60                 mov     [ebp+var_18], eax
.text$mn:00005C63                 mov     eax, [ebp+arg_0]
.text$mn:00005C66                 mov     ecx, [ebp+var_C]
.text$mn:00005C69                 mov     large fs:0, ecx
.text$mn:00005C70                 pop     ecx
.text$mn:00005C71                 mov     esp, ebp
.text$mn:00005C73                 pop     ebp
.text$mn:00005C74                 retn    8
.text$mn:00005C74 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00005C74
.text$mn:00005C74 ; ---------------------------------------------------------------------------
.text$mn:00005C77                 align 4
.text$mn:00005C77 _text$mn        ends
.text$mn:00005C77
.text$x:00005C78 ; ===========================================================================
.text$x:00005C78
.text$x:00005C78 ; Segment type: Pure code
.text$x:00005C78 ; Segment permissions: Read/Execute
.text$x:00005C78 _text$x         segment para public 'CODE' use32
.text$x:00005C78                 assume cs:_text$x
.text$x:00005C78                 ;org 5C78h
.text$x:00005C78 ; COMDAT (pick associative to section at 5BF4)
.text$x:00005C78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005C78
.text$x:00005C78 ; =============== S U B R O U T I N E =======================================
.text$x:00005C78
.text$x:00005C78
.text$x:00005C78 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00005C78                                         ; DATA XREF: .xdata$x:000064E0o
.text$x:00005C78                 mov     eax, [ebp-18h]
.text$x:00005C7B                 and     eax, 1
.text$x:00005C7E                 jz      $LN6
.text$x:00005C84                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00005C88                 mov     ecx, [ebp+8]
.text$x:00005C8B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00005C90 ; ---------------------------------------------------------------------------
.text$x:00005C90
.text$x:00005C90 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00005C90                 retn
.text$x:00005C90 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00005C90
.text$x:00005C91
.text$x:00005C91 ; =============== S U B R O U T I N E =======================================
.text$x:00005C91
.text$x:00005C91
.text$x:00005C91 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00005C91                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00005C91
.text$x:00005C91 arg_4           = dword ptr  8
.text$x:00005C91
.text$x:00005C91                 mov     edx, [esp+arg_4]
.text$x:00005C95                 lea     eax, [edx+0Ch]
.text$x:00005C98                 mov     ecx, [edx-14h]
.text$x:00005C9B                 xor     ecx, eax
.text$x:00005C9D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005CA2                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00005CA7                 jmp     ___CxxFrameHandler3
.text$x:00005CA7 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00005CA7
.text$x:00005CA7 _text$x         ends
.text$x:00005CA7
.text$mn:00005CAC ; ===========================================================================
.text$mn:00005CAC
.text$mn:00005CAC ; Segment type: Pure code
.text$mn:00005CAC ; Segment permissions: Read/Execute
.text$mn:00005CAC _text$mn        segment para public 'CODE' use32
.text$mn:00005CAC                 assume cs:_text$mn
.text$mn:00005CAC                 ;org 5CACh
.text$mn:00005CAC ; COMDAT (pick any)
.text$mn:00005CAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005CAC
.text$mn:00005CAC ; =============== S U B R O U T I N E =======================================
.text$mn:00005CAC
.text$mn:00005CAC ; Attributes: bp-based frame
.text$mn:00005CAC
.text$mn:00005CAC ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00005CAC                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00005CAC ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00005CAC                                         ; DATA XREF: .rdata:00006CB4o
.text$mn:00005CAC
.text$mn:00005CAC var_14          = dword ptr -14h
.text$mn:00005CAC var_10          = dword ptr -10h
.text$mn:00005CAC var_C           = dword ptr -0Ch
.text$mn:00005CAC var_4           = dword ptr -4
.text$mn:00005CAC arg_0           = dword ptr  8
.text$mn:00005CAC arg_4           = dword ptr  0Ch
.text$mn:00005CAC
.text$mn:00005CAC                 push    ebp
.text$mn:00005CAD                 mov     ebp, esp
.text$mn:00005CAF                 push    0FFFFFFFFh
.text$mn:00005CB1                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00005CB6                 mov     eax, large fs:0
.text$mn:00005CBC                 push    eax
.text$mn:00005CBD                 sub     esp, 8
.text$mn:00005CC0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005CC5                 xor     eax, ebp
.text$mn:00005CC7                 push    eax
.text$mn:00005CC8                 lea     eax, [ebp+var_C]
.text$mn:00005CCB                 mov     large fs:0, eax
.text$mn:00005CD1                 mov     [ebp+var_14], ecx
.text$mn:00005CD4                 mov     [ebp+var_10], 0
.text$mn:00005CDB                 cmp     [ebp+arg_4], 1
.text$mn:00005CDF                 jnz     short loc_5D05
.text$mn:00005CE1                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00005CE6                 mov     ecx, [ebp+arg_0]
.text$mn:00005CE9                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00005CEE                 mov     [ebp+var_4], 0
.text$mn:00005CF5                 mov     eax, [ebp+var_10]
.text$mn:00005CF8                 or      eax, 1
.text$mn:00005CFB                 mov     [ebp+var_10], eax
.text$mn:00005CFE                 mov     eax, [ebp+arg_0]
.text$mn:00005D01                 jmp     short loc_5D28
.text$mn:00005D03 ; ---------------------------------------------------------------------------
.text$mn:00005D03                 jmp     short loc_5D28
.text$mn:00005D05 ; ---------------------------------------------------------------------------
.text$mn:00005D05
.text$mn:00005D05 loc_5D05:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00005D05                 mov     ecx, [ebp+arg_4]
.text$mn:00005D08                 push    ecx
.text$mn:00005D09                 mov     edx, [ebp+arg_0]
.text$mn:00005D0C                 push    edx
.text$mn:00005D0D                 mov     ecx, [ebp+var_14]
.text$mn:00005D10                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00005D15                 mov     [ebp+var_4], 0
.text$mn:00005D1C                 mov     eax, [ebp+var_10]
.text$mn:00005D1F                 or      eax, 1
.text$mn:00005D22                 mov     [ebp+var_10], eax
.text$mn:00005D25                 mov     eax, [ebp+arg_0]
.text$mn:00005D28
.text$mn:00005D28 loc_5D28:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00005D28                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00005D28                 mov     ecx, [ebp+var_C]
.text$mn:00005D2B                 mov     large fs:0, ecx
.text$mn:00005D32                 pop     ecx
.text$mn:00005D33                 mov     esp, ebp
.text$mn:00005D35                 pop     ebp
.text$mn:00005D36                 retn    8
.text$mn:00005D36 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00005D36
.text$mn:00005D36 ; ---------------------------------------------------------------------------
.text$mn:00005D39                 align 4
.text$mn:00005D39 _text$mn        ends
.text$mn:00005D39
.text$x:00005D3C ; ===========================================================================
.text$x:00005D3C
.text$x:00005D3C ; Segment type: Pure code
.text$x:00005D3C ; Segment permissions: Read/Execute
.text$x:00005D3C _text$x         segment para public 'CODE' use32
.text$x:00005D3C                 assume cs:_text$x
.text$x:00005D3C                 ;org 5D3Ch
.text$x:00005D3C ; COMDAT (pick associative to section at 5CAC)
.text$x:00005D3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005D3C
.text$x:00005D3C ; =============== S U B R O U T I N E =======================================
.text$x:00005D3C
.text$x:00005D3C
.text$x:00005D3C __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00005D3C                                         ; DATA XREF: .xdata$x:00006564o
.text$x:00005D3C                 mov     eax, [ebp-10h]
.text$x:00005D3F                 and     eax, 1
.text$x:00005D42                 jz      $LN6_0
.text$x:00005D48                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00005D4C                 mov     ecx, [ebp+8]
.text$x:00005D4F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00005D54 ; ---------------------------------------------------------------------------
.text$x:00005D54
.text$x:00005D54 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00005D54                 retn
.text$x:00005D54 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00005D54
.text$x:00005D55
.text$x:00005D55 ; =============== S U B R O U T I N E =======================================
.text$x:00005D55
.text$x:00005D55
.text$x:00005D55 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00005D55                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00005D55
.text$x:00005D55 arg_4           = dword ptr  8
.text$x:00005D55
.text$x:00005D55                 mov     edx, [esp+arg_4]
.text$x:00005D59                 lea     eax, [edx+0Ch]
.text$x:00005D5C                 mov     ecx, [edx-0Ch]
.text$x:00005D5F                 xor     ecx, eax
.text$x:00005D61                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005D66                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00005D6B                 jmp     ___CxxFrameHandler3
.text$x:00005D6B __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00005D6B
.text$x:00005D6B _text$x         ends
.text$x:00005D6B
.text$mn:00005D70 ; ===========================================================================
.text$mn:00005D70
.text$mn:00005D70 ; Segment type: Pure code
.text$mn:00005D70 ; Segment permissions: Read/Execute
.text$mn:00005D70 _text$mn        segment para public 'CODE' use32
.text$mn:00005D70                 assume cs:_text$mn
.text$mn:00005D70                 ;org 5D70h
.text$mn:00005D70 ; COMDAT (pick any)
.text$mn:00005D70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005D70
.text$mn:00005D70 ; =============== S U B R O U T I N E =======================================
.text$mn:00005D70
.text$mn:00005D70 ; Attributes: bp-based frame
.text$mn:00005D70
.text$mn:00005D70 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00005D70                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00005D70 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00005D70                                         ; DATA XREF: .rdata:00006CF4o
.text$mn:00005D70
.text$mn:00005D70 var_1C          = dword ptr -1Ch
.text$mn:00005D70 var_18          = dword ptr -18h
.text$mn:00005D70 Str             = dword ptr -14h
.text$mn:00005D70 var_10          = dword ptr -10h
.text$mn:00005D70 var_C           = dword ptr -0Ch
.text$mn:00005D70 var_4           = dword ptr -4
.text$mn:00005D70 arg_0           = dword ptr  8
.text$mn:00005D70 arg_4           = dword ptr  0Ch
.text$mn:00005D70
.text$mn:00005D70                 push    ebp
.text$mn:00005D71                 mov     ebp, esp
.text$mn:00005D73                 push    0FFFFFFFFh
.text$mn:00005D75                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00005D7A                 mov     eax, large fs:0
.text$mn:00005D80                 push    eax
.text$mn:00005D81                 sub     esp, 10h
.text$mn:00005D84                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005D89                 xor     eax, ebp
.text$mn:00005D8B                 push    eax
.text$mn:00005D8C                 lea     eax, [ebp+var_C]
.text$mn:00005D8F                 mov     large fs:0, eax
.text$mn:00005D95                 mov     [ebp+var_1C], ecx
.text$mn:00005D98                 mov     [ebp+var_18], 0
.text$mn:00005D9F                 mov     eax, [ebp+arg_4]
.text$mn:00005DA2                 push    eax             ; int
.text$mn:00005DA3                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00005DA8                 add     esp, 4
.text$mn:00005DAB                 mov     [ebp+var_10], eax
.text$mn:00005DAE                 cmp     [ebp+var_10], 0
.text$mn:00005DB2                 jz      short loc_5DBC
.text$mn:00005DB4                 mov     ecx, [ebp+var_10]
.text$mn:00005DB7                 mov     [ebp+Str], ecx
.text$mn:00005DBA                 jmp     short loc_5DC3
.text$mn:00005DBC ; ---------------------------------------------------------------------------
.text$mn:00005DBC
.text$mn:00005DBC loc_5DBC:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00005DBC                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00005DC3
.text$mn:00005DC3 loc_5DC3:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00005DC3                 mov     edx, [ebp+Str]
.text$mn:00005DC6                 push    edx             ; Str
.text$mn:00005DC7                 mov     ecx, [ebp+arg_0]
.text$mn:00005DCA                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00005DCF                 mov     [ebp+var_4], 0
.text$mn:00005DD6                 mov     eax, [ebp+var_18]
.text$mn:00005DD9                 or      eax, 1
.text$mn:00005DDC                 mov     [ebp+var_18], eax
.text$mn:00005DDF                 mov     eax, [ebp+arg_0]
.text$mn:00005DE2                 mov     ecx, [ebp+var_C]
.text$mn:00005DE5                 mov     large fs:0, ecx
.text$mn:00005DEC                 pop     ecx
.text$mn:00005DED                 mov     esp, ebp
.text$mn:00005DEF                 pop     ebp
.text$mn:00005DF0                 retn    8
.text$mn:00005DF0 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00005DF0
.text$mn:00005DF0 ; ---------------------------------------------------------------------------
.text$mn:00005DF3                 align 4
.text$mn:00005DF3 _text$mn        ends
.text$mn:00005DF3
.text$x:00005DF4 ; ===========================================================================
.text$x:00005DF4
.text$x:00005DF4 ; Segment type: Pure code
.text$x:00005DF4 ; Segment permissions: Read/Execute
.text$x:00005DF4 _text$x         segment para public 'CODE' use32
.text$x:00005DF4                 assume cs:_text$x
.text$x:00005DF4                 ;org 5DF4h
.text$x:00005DF4 ; COMDAT (pick associative to section at 5D70)
.text$x:00005DF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005DF4
.text$x:00005DF4 ; =============== S U B R O U T I N E =======================================
.text$x:00005DF4
.text$x:00005DF4
.text$x:00005DF4 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00005DF4                                         ; DATA XREF: .xdata$x:000065E8o
.text$x:00005DF4                 mov     eax, [ebp-18h]
.text$x:00005DF7                 and     eax, 1
.text$x:00005DFA                 jz      $LN6_1
.text$x:00005E00                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00005E04                 mov     ecx, [ebp+8]
.text$x:00005E07                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00005E0C ; ---------------------------------------------------------------------------
.text$x:00005E0C
.text$x:00005E0C $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00005E0C                 retn
.text$x:00005E0C __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00005E0C
.text$x:00005E0D
.text$x:00005E0D ; =============== S U B R O U T I N E =======================================
.text$x:00005E0D
.text$x:00005E0D
.text$x:00005E0D __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00005E0D                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00005E0D
.text$x:00005E0D arg_4           = dword ptr  8
.text$x:00005E0D
.text$x:00005E0D                 mov     edx, [esp+arg_4]
.text$x:00005E11                 lea     eax, [edx+0Ch]
.text$x:00005E14                 mov     ecx, [edx-14h]
.text$x:00005E17                 xor     ecx, eax
.text$x:00005E19                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005E1E                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00005E23                 jmp     ___CxxFrameHandler3
.text$x:00005E23 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00005E23
.text$x:00005E23 _text$x         ends
.text$x:00005E23
.text$mn:00005E28 ; ===========================================================================
.text$mn:00005E28
.text$mn:00005E28 ; Segment type: Pure code
.text$mn:00005E28 ; Segment permissions: Read/Execute
.text$mn:00005E28 _text$mn        segment para public 'CODE' use32
.text$mn:00005E28                 assume cs:_text$mn
.text$mn:00005E28                 ;org 5E28h
.text$mn:00005E28 ; COMDAT (pick any)
.text$mn:00005E28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005E28
.text$mn:00005E28 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E28
.text$mn:00005E28 ; Attributes: bp-based frame
.text$mn:00005E28
.text$mn:00005E28 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00005E28                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00005E28 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00005E28                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00005E28                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::insert(uint,uint,char)+80p
.text$mn:00005E28
.text$mn:00005E28 var_4           = dword ptr -4
.text$mn:00005E28 Dst             = dword ptr  8
.text$mn:00005E28 Src             = dword ptr  0Ch
.text$mn:00005E28 Size            = dword ptr  10h
.text$mn:00005E28
.text$mn:00005E28                 push    ebp
.text$mn:00005E29                 mov     ebp, esp
.text$mn:00005E2B                 push    ecx
.text$mn:00005E2C                 cmp     [ebp+Size], 0
.text$mn:00005E30                 jnz     short loc_5E3A
.text$mn:00005E32                 mov     eax, [ebp+Dst]
.text$mn:00005E35                 mov     [ebp+var_4], eax
.text$mn:00005E38                 jmp     short loc_5E51
.text$mn:00005E3A ; ---------------------------------------------------------------------------
.text$mn:00005E3A
.text$mn:00005E3A loc_5E3A:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00005E3A                 mov     ecx, [ebp+Size]
.text$mn:00005E3D                 push    ecx             ; Size
.text$mn:00005E3E                 mov     edx, [ebp+Src]
.text$mn:00005E41                 push    edx             ; Src
.text$mn:00005E42                 mov     eax, [ebp+Dst]
.text$mn:00005E45                 push    eax             ; Dst
.text$mn:00005E46                 call    _memmove
.text$mn:00005E4B                 add     esp, 0Ch
.text$mn:00005E4E                 mov     [ebp+var_4], eax
.text$mn:00005E51
.text$mn:00005E51 loc_5E51:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00005E51                 mov     eax, [ebp+var_4]
.text$mn:00005E54                 mov     esp, ebp
.text$mn:00005E56                 pop     ebp
.text$mn:00005E57                 retn
.text$mn:00005E57 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00005E57
.text$mn:00005E57 _text$mn        ends
.text$mn:00005E57
.text$mn:00005E58 ; ===========================================================================
.text$mn:00005E58
.text$mn:00005E58 ; Segment type: Pure code
.text$mn:00005E58 ; Segment permissions: Read/Execute
.text$mn:00005E58 _text$mn        segment para public 'CODE' use32
.text$mn:00005E58                 assume cs:_text$mn
.text$mn:00005E58                 ;org 5E58h
.text$mn:00005E58 ; COMDAT (pick any)
.text$mn:00005E58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005E58
.text$mn:00005E58 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E58
.text$mn:00005E58 ; Attributes: bp-based frame
.text$mn:00005E58
.text$mn:00005E58 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00005E58                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00005E58 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00005E58                                         ; DATA XREF: .rdata:00006C7Co
.text$mn:00005E58
.text$mn:00005E58 var_4           = dword ptr -4
.text$mn:00005E58
.text$mn:00005E58                 push    ebp
.text$mn:00005E59                 mov     ebp, esp
.text$mn:00005E5B                 push    ecx
.text$mn:00005E5C                 mov     [ebp+var_4], ecx
.text$mn:00005E5F                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00005E64                 mov     esp, ebp
.text$mn:00005E66                 pop     ebp
.text$mn:00005E67                 retn
.text$mn:00005E67 ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00005E67
.text$mn:00005E67 _text$mn        ends
.text$mn:00005E67
.text$mn:00005E68 ; ===========================================================================
.text$mn:00005E68
.text$mn:00005E68 ; Segment type: Pure code
.text$mn:00005E68 ; Segment permissions: Read/Execute
.text$mn:00005E68 _text$mn        segment para public 'CODE' use32
.text$mn:00005E68                 assume cs:_text$mn
.text$mn:00005E68                 ;org 5E68h
.text$mn:00005E68 ; COMDAT (pick any)
.text$mn:00005E68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005E68
.text$mn:00005E68 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E68
.text$mn:00005E68 ; Attributes: bp-based frame
.text$mn:00005E68
.text$mn:00005E68 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00005E68                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00005E68 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00005E68                                         ; DATA XREF: .rdata:00006CB0o
.text$mn:00005E68
.text$mn:00005E68 var_4           = dword ptr -4
.text$mn:00005E68
.text$mn:00005E68                 push    ebp
.text$mn:00005E69                 mov     ebp, esp
.text$mn:00005E6B                 push    ecx
.text$mn:00005E6C                 mov     [ebp+var_4], ecx
.text$mn:00005E6F                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00005E74                 mov     esp, ebp
.text$mn:00005E76                 pop     ebp
.text$mn:00005E77                 retn
.text$mn:00005E77 ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00005E77
.text$mn:00005E77 _text$mn        ends
.text$mn:00005E77
.text$mn:00005E78 ; ===========================================================================
.text$mn:00005E78
.text$mn:00005E78 ; Segment type: Pure code
.text$mn:00005E78 ; Segment permissions: Read/Execute
.text$mn:00005E78 _text$mn        segment para public 'CODE' use32
.text$mn:00005E78                 assume cs:_text$mn
.text$mn:00005E78                 ;org 5E78h
.text$mn:00005E78 ; COMDAT (pick any)
.text$mn:00005E78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005E78
.text$mn:00005E78 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E78
.text$mn:00005E78 ; Attributes: bp-based frame
.text$mn:00005E78
.text$mn:00005E78 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00005E78                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00005E78 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00005E78                                         ; DATA XREF: .rdata:00006CF0o
.text$mn:00005E78
.text$mn:00005E78 var_4           = dword ptr -4
.text$mn:00005E78
.text$mn:00005E78                 push    ebp
.text$mn:00005E79                 mov     ebp, esp
.text$mn:00005E7B                 push    ecx
.text$mn:00005E7C                 mov     [ebp+var_4], ecx
.text$mn:00005E7F                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00005E84                 mov     esp, ebp
.text$mn:00005E86                 pop     ebp
.text$mn:00005E87                 retn
.text$mn:00005E87 ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00005E87
.text$mn:00005E87 _text$mn        ends
.text$mn:00005E87
.text$mn:00005E88 ; ===========================================================================
.text$mn:00005E88
.text$mn:00005E88 ; Segment type: Pure code
.text$mn:00005E88 ; Segment permissions: Read/Execute
.text$mn:00005E88 _text$mn        segment para public 'CODE' use32
.text$mn:00005E88                 assume cs:_text$mn
.text$mn:00005E88                 ;org 5E88h
.text$mn:00005E88 ; COMDAT (pick any)
.text$mn:00005E88                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005E88
.text$mn:00005E88 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E88
.text$mn:00005E88 ; Attributes: bp-based frame
.text$mn:00005E88
.text$mn:00005E88 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::push_back(char)
.text$mn:00005E88                 public ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z
.text$mn:00005E88 ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z proc near
.text$mn:00005E88                                         ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+2B7p
.text$mn:00005E88                                         ; XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+56Ep
.text$mn:00005E88
.text$mn:00005E88 var_40          = byte ptr -40h
.text$mn:00005E88 var_34          = byte ptr -34h
.text$mn:00005E88 var_28          = dword ptr -28h
.text$mn:00005E88 var_24          = dword ptr -24h
.text$mn:00005E88 var_20          = dword ptr -20h
.text$mn:00005E88 var_1C          = dword ptr -1Ch
.text$mn:00005E88 var_18          = dword ptr -18h
.text$mn:00005E88 var_14          = dword ptr -14h
.text$mn:00005E88 var_10          = dword ptr -10h
.text$mn:00005E88 var_C           = dword ptr -0Ch
.text$mn:00005E88 var_4           = dword ptr -4
.text$mn:00005E88 arg_0           = byte ptr  8
.text$mn:00005E88
.text$mn:00005E88                 push    ebp
.text$mn:00005E89                 mov     ebp, esp
.text$mn:00005E8B                 push    0FFFFFFFFh
.text$mn:00005E8D                 push    offset __ehhandler$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z
.text$mn:00005E92                 mov     eax, large fs:0
.text$mn:00005E98                 push    eax
.text$mn:00005E99                 sub     esp, 34h
.text$mn:00005E9C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005EA1                 xor     eax, ebp
.text$mn:00005EA3                 push    eax
.text$mn:00005EA4                 lea     eax, [ebp+var_C]
.text$mn:00005EA7                 mov     large fs:0, eax
.text$mn:00005EAD                 mov     [ebp+var_10], ecx
.text$mn:00005EB0                 movzx   eax, [ebp+arg_0]
.text$mn:00005EB4                 push    eax
.text$mn:00005EB5                 lea     ecx, [ebp+var_40]
.text$mn:00005EB8                 push    ecx
.text$mn:00005EB9                 mov     ecx, [ebp+var_10]
.text$mn:00005EBC                 call    ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::end(void)
.text$mn:00005EC1                 mov     [ebp+var_14], eax
.text$mn:00005EC4                 mov     edx, [ebp+var_14]
.text$mn:00005EC7                 mov     [ebp+var_18], edx
.text$mn:00005ECA                 mov     [ebp+var_4], 0
.text$mn:00005ED1                 sub     esp, 0Ch
.text$mn:00005ED4                 mov     ecx, esp
.text$mn:00005ED6                 mov     [ebp+var_20], esp
.text$mn:00005ED9                 mov     eax, [ebp+var_18]
.text$mn:00005EDC                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005EDD                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>> const &)
.text$mn:00005EE2                 mov     [ebp+var_1C], eax
.text$mn:00005EE5                 mov     ecx, [ebp+var_1C]
.text$mn:00005EE8                 mov     [ebp+var_24], ecx
.text$mn:00005EEB                 mov     byte ptr [ebp+var_4], 1
.text$mn:00005EEF                 lea     edx, [ebp+var_34]
.text$mn:00005EF2                 push    edx
.text$mn:00005EF3                 mov     byte ptr [ebp+var_4], 0
.text$mn:00005EF7                 mov     ecx, [ebp+var_10]
.text$mn:00005EFA                 call    ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::insert(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>,char)
.text$mn:00005EFF                 mov     [ebp+var_28], eax
.text$mn:00005F02                 lea     ecx, [ebp+var_34]
.text$mn:00005F05                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$mn:00005F0A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005F11                 lea     ecx, [ebp+var_40]
.text$mn:00005F14                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$mn:00005F19                 mov     ecx, [ebp+var_C]
.text$mn:00005F1C                 mov     large fs:0, ecx
.text$mn:00005F23                 pop     ecx
.text$mn:00005F24                 mov     esp, ebp
.text$mn:00005F26                 pop     ebp
.text$mn:00005F27                 retn    4
.text$mn:00005F27 ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z endp
.text$mn:00005F27
.text$mn:00005F27 ; ---------------------------------------------------------------------------
.text$mn:00005F2A                 align 4
.text$mn:00005F2A _text$mn        ends
.text$mn:00005F2A
.text$x:00005F2C ; ===========================================================================
.text$x:00005F2C
.text$x:00005F2C ; Segment type: Pure code
.text$x:00005F2C ; Segment permissions: Read/Execute
.text$x:00005F2C _text$x         segment para public 'CODE' use32
.text$x:00005F2C                 assume cs:_text$x
.text$x:00005F2C                 ;org 5F2Ch
.text$x:00005F2C ; COMDAT (pick associative to section at 5E88)
.text$x:00005F2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005F2C
.text$x:00005F2C ; =============== S U B R O U T I N E =======================================
.text$x:00005F2C
.text$x:00005F2C
.text$x:00005F2C __unwindfunclet$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z$0 proc near
.text$x:00005F2C                                         ; DATA XREF: .xdata$x:000063C0o
.text$x:00005F2C                 lea     ecx, [ebp-40h]
.text$x:00005F2F                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$x:00005F2F __unwindfunclet$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z$0 endp
.text$x:00005F2F
.text$x:00005F34
.text$x:00005F34 ; =============== S U B R O U T I N E =======================================
.text$x:00005F34
.text$x:00005F34
.text$x:00005F34 __unwindfunclet$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z$1 proc near
.text$x:00005F34                                         ; DATA XREF: .xdata$x:000063C8o
.text$x:00005F34                 mov     ecx, [ebp-20h]
.text$x:00005F37                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<char>>>(void)
.text$x:00005F37 __unwindfunclet$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z$1 endp
.text$x:00005F37
.text$x:00005F3C
.text$x:00005F3C ; =============== S U B R O U T I N E =======================================
.text$x:00005F3C
.text$x:00005F3C
.text$x:00005F3C __ehhandler$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z proc near
.text$x:00005F3C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::push_back(char)+5o
.text$x:00005F3C
.text$x:00005F3C arg_4           = dword ptr  8
.text$x:00005F3C
.text$x:00005F3C                 mov     edx, [esp+arg_4]
.text$x:00005F40                 lea     eax, [edx+0Ch]
.text$x:00005F43                 mov     ecx, [edx-38h]
.text$x:00005F46                 xor     ecx, eax
.text$x:00005F48                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005F4D                 mov     eax, offset __ehfuncinfo$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z
.text$x:00005F52                 jmp     ___CxxFrameHandler3
.text$x:00005F52 __ehhandler$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z endp
.text$x:00005F52
.text$x:00005F52 ; ---------------------------------------------------------------------------
.text$x:00005F57                 align 4
.text$x:00005F57 _text$x         ends
.text$x:00005F57
.text$mn:00005F58 ; ===========================================================================
.text$mn:00005F58
.text$mn:00005F58 ; Segment type: Pure code
.text$mn:00005F58 ; Segment permissions: Read/Execute
.text$mn:00005F58 _text$mn        segment para public 'CODE' use32
.text$mn:00005F58                 assume cs:_text$mn
.text$mn:00005F58                 ;org 5F58h
.text$mn:00005F58 ; COMDAT (pick any)
.text$mn:00005F58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005F58
.text$mn:00005F58 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F58
.text$mn:00005F58 ; Attributes: bp-based frame
.text$mn:00005F58
.text$mn:00005F58 ; public: void __thiscall std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>::push_back(struct std::pair<int, int> &&)
.text$mn:00005F58                 public ?push_back@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEX$$QAU?$pair@HH@2@@Z
.text$mn:00005F58 ?push_back@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEX$$QAU?$pair@HH@2@@Z proc near
.text$mn:00005F58                                         ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+1CDp
.text$mn:00005F58                                         ; XmlMatchedTagsHighlighter::getAttributesPos(int,int)+20Ep
.text$mn:00005F58
.text$mn:00005F58 var_C           = dword ptr -0Ch
.text$mn:00005F58 var_8           = dword ptr -8
.text$mn:00005F58 var_2           = byte ptr -2
.text$mn:00005F58 var_1           = byte ptr -1
.text$mn:00005F58 arg_0           = dword ptr  8
.text$mn:00005F58
.text$mn:00005F58                 push    ebp
.text$mn:00005F59                 mov     ebp, esp
.text$mn:00005F5B                 sub     esp, 0Ch
.text$mn:00005F5E                 mov     [ebp+var_8], ecx
.text$mn:00005F61                 mov     eax, [ebp+arg_0]
.text$mn:00005F64                 push    eax
.text$mn:00005F65                 call    ??$addressof@U?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@AAU10@@Z ; std::addressof<std::pair<int,int>>(std::pair<int,int> &)
.text$mn:00005F6A                 add     esp, 4
.text$mn:00005F6D                 push    eax
.text$mn:00005F6E                 mov     ecx, [ebp+var_8]
.text$mn:00005F71                 call    ?_Inside@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBE_NPBU?$pair@HH@2@@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Inside(std::pair<int,int> const *)
.text$mn:00005F76                 movzx   ecx, al
.text$mn:00005F79                 test    ecx, ecx
.text$mn:00005F7B                 jz      loc_6008
.text$mn:00005F81                 mov     edx, [ebp+arg_0]
.text$mn:00005F84                 push    edx
.text$mn:00005F85                 call    ??$addressof@U?$pair@HH@std@@@std@@YAPAU?$pair@HH@0@AAU10@@Z ; std::addressof<std::pair<int,int>>(std::pair<int,int> &)
.text$mn:00005F8A                 add     esp, 4
.text$mn:00005F8D                 mov     ecx, [ebp+var_8]
.text$mn:00005F90                 sub     eax, [ecx+4]
.text$mn:00005F93                 sar     eax, 3
.text$mn:00005F96                 mov     [ebp+var_C], eax
.text$mn:00005F99                 mov     edx, [ebp+var_8]
.text$mn:00005F9C                 mov     eax, [ebp+var_8]
.text$mn:00005F9F                 mov     ecx, [edx+8]
.text$mn:00005FA2                 cmp     ecx, [eax+0Ch]
.text$mn:00005FA5                 jnz     short loc_5FB1
.text$mn:00005FA7                 push    1
.text$mn:00005FA9                 mov     ecx, [ebp+var_8]
.text$mn:00005FAC                 call    ?_Reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Reserve(uint)
.text$mn:00005FB1
.text$mn:00005FB1 loc_5FB1:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::push_back(std::pair<int,int> &&)+4Dj
.text$mn:00005FB1                 mov     edx, [ebp+var_8]
.text$mn:00005FB4                 mov     eax, [edx+8]
.text$mn:00005FB7                 push    eax
.text$mn:00005FB8                 mov     ecx, [ebp+var_8]
.text$mn:00005FBB                 mov     edx, [ecx+8]
.text$mn:00005FBE                 push    edx
.text$mn:00005FBF                 mov     ecx, [ebp+var_8]
.text$mn:00005FC2                 call    ?_Orphan_range@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXPAU?$pair@HH@2@0@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Orphan_range(std::pair<int,int> *,std::pair<int,int> *)
.text$mn:00005FC7                 mov     eax, [ebp+var_8]
.text$mn:00005FCA                 mov     ecx, [eax+4]
.text$mn:00005FCD                 mov     edx, [ebp+var_C]
.text$mn:00005FD0                 lea     eax, [ecx+edx*8]
.text$mn:00005FD3                 push    eax
.text$mn:00005FD4                 call    ??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z ; std::forward<std::pair<int,int>>(std::pair<int,int> &)
.text$mn:00005FD9                 add     esp, 4
.text$mn:00005FDC                 push    eax             ; int
.text$mn:00005FDD                 mov     ecx, [ebp+var_8]
.text$mn:00005FE0                 mov     edx, [ecx+8]
.text$mn:00005FE3                 push    edx             ; void *
.text$mn:00005FE4                 lea     eax, [ebp+var_1]
.text$mn:00005FE7                 push    eax
.text$mn:00005FE8                 mov     ecx, [ebp+var_8]
.text$mn:00005FEB                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Getal(void)
.text$mn:00005FF0                 mov     ecx, eax
.text$mn:00005FF2                 call    ??$construct@U?$pair@HH@std@@U12@@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAEXPAU?$pair@HH@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::pair<int,int>>>::construct<std::pair<int,int>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> &&)
.text$mn:00005FF7                 mov     ecx, [ebp+var_8]
.text$mn:00005FFA                 mov     edx, [ecx+8]
.text$mn:00005FFD                 add     edx, 8
.text$mn:00006000                 mov     eax, [ebp+var_8]
.text$mn:00006003                 mov     [eax+8], edx
.text$mn:00006006                 jmp     short loc_606C
.text$mn:00006008 ; ---------------------------------------------------------------------------
.text$mn:00006008
.text$mn:00006008 loc_6008:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::push_back(std::pair<int,int> &&)+23j
.text$mn:00006008                 mov     ecx, [ebp+var_8]
.text$mn:0000600B                 mov     edx, [ebp+var_8]
.text$mn:0000600E                 mov     eax, [ecx+8]
.text$mn:00006011                 cmp     eax, [edx+0Ch]
.text$mn:00006014                 jnz     short loc_6020
.text$mn:00006016                 push    1
.text$mn:00006018                 mov     ecx, [ebp+var_8]
.text$mn:0000601B                 call    ?_Reserve@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Reserve(uint)
.text$mn:00006020
.text$mn:00006020 loc_6020:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::push_back(std::pair<int,int> &&)+BCj
.text$mn:00006020                 mov     ecx, [ebp+var_8]
.text$mn:00006023                 mov     edx, [ecx+8]
.text$mn:00006026                 push    edx
.text$mn:00006027                 mov     eax, [ebp+var_8]
.text$mn:0000602A                 mov     ecx, [eax+8]
.text$mn:0000602D                 push    ecx
.text$mn:0000602E                 mov     ecx, [ebp+var_8]
.text$mn:00006031                 call    ?_Orphan_range@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXPAU?$pair@HH@2@0@Z ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Orphan_range(std::pair<int,int> *,std::pair<int,int> *)
.text$mn:00006036                 mov     edx, [ebp+arg_0]
.text$mn:00006039                 push    edx
.text$mn:0000603A                 call    ??$forward@U?$pair@HH@std@@@std@@YA$$QAU?$pair@HH@0@AAU10@@Z ; std::forward<std::pair<int,int>>(std::pair<int,int> &)
.text$mn:0000603F                 add     esp, 4
.text$mn:00006042                 push    eax             ; int
.text$mn:00006043                 mov     eax, [ebp+var_8]
.text$mn:00006046                 mov     ecx, [eax+8]
.text$mn:00006049                 push    ecx             ; void *
.text$mn:0000604A                 lea     edx, [ebp+var_2]
.text$mn:0000604D                 push    edx
.text$mn:0000604E                 mov     ecx, [ebp+var_8]
.text$mn:00006051                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::pair<int,int>,std::allocator<std::pair<int,int>>>>::_Getal(void)
.text$mn:00006056                 mov     ecx, eax
.text$mn:00006058                 call    ??$construct@U?$pair@HH@std@@U12@@?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@std@@QAEXPAU?$pair@HH@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::pair<int,int>>>::construct<std::pair<int,int>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> &&)
.text$mn:0000605D                 mov     eax, [ebp+var_8]
.text$mn:00006060                 mov     ecx, [eax+8]
.text$mn:00006063                 add     ecx, 8
.text$mn:00006066                 mov     edx, [ebp+var_8]
.text$mn:00006069                 mov     [edx+8], ecx
.text$mn:0000606C
.text$mn:0000606C loc_606C:                               ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::push_back(std::pair<int,int> &&)+AEj
.text$mn:0000606C                 mov     esp, ebp
.text$mn:0000606E                 pop     ebp
.text$mn:0000606F                 retn    4
.text$mn:0000606F ?push_back@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAEX$$QAU?$pair@HH@2@@Z endp
.text$mn:0000606F
.text$mn:0000606F ; ---------------------------------------------------------------------------
.text$mn:00006072                 align 4
.text$mn:00006072 _text$mn        ends
.text$mn:00006072
.text$mn:00006074 ; ===========================================================================
.text$mn:00006074
.text$mn:00006074 ; Segment type: Pure code
.text$mn:00006074 ; Segment permissions: Read/Execute
.text$mn:00006074 _text$mn        segment para public 'CODE' use32
.text$mn:00006074                 assume cs:_text$mn
.text$mn:00006074                 ;org 6074h
.text$mn:00006074 ; COMDAT (pick any)
.text$mn:00006074                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006074
.text$mn:00006074 ; =============== S U B R O U T I N E =======================================
.text$mn:00006074
.text$mn:00006074 ; Attributes: bp-based frame
.text$mn:00006074
.text$mn:00006074 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00006074                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00006074 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00006074                                         ; CODE XREF: XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+2F4p
.text$mn:00006074                                         ; XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+444p ...
.text$mn:00006074
.text$mn:00006074 var_4           = dword ptr -4
.text$mn:00006074
.text$mn:00006074                 push    ebp
.text$mn:00006075                 mov     ebp, esp
.text$mn:00006077                 push    ecx
.text$mn:00006078                 mov     [ebp+var_4], ecx
.text$mn:0000607B                 mov     eax, [ebp+var_4]
.text$mn:0000607E                 mov     eax, [eax+14h]
.text$mn:00006081                 mov     esp, ebp
.text$mn:00006083                 pop     ebp
.text$mn:00006084                 retn
.text$mn:00006084 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00006084
.text$mn:00006084 ; ---------------------------------------------------------------------------
.text$mn:00006085                 align 4
.text$mn:00006085 _text$mn        ends
.text$mn:00006085
.text$mn:00006088 ; ===========================================================================
.text$mn:00006088
.text$mn:00006088 ; Segment type: Pure code
.text$mn:00006088 ; Segment permissions: Read/Execute
.text$mn:00006088 _text$mn        segment para public 'CODE' use32
.text$mn:00006088                 assume cs:_text$mn
.text$mn:00006088                 ;org 6088h
.text$mn:00006088 ; COMDAT (pick any)
.text$mn:00006088                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006088
.text$mn:00006088 ; =============== S U B R O U T I N E =======================================
.text$mn:00006088
.text$mn:00006088 ; Attributes: bp-based frame
.text$mn:00006088
.text$mn:00006088 ; public: unsigned int __thiscall std::vector<struct std::pair<int, int>, class std::allocator<struct std::pair<int, int>>>::size(void)const
.text$mn:00006088                 public ?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ
.text$mn:00006088 ?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ proc near
.text$mn:00006088                                         ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+307p
.text$mn:00006088                                         ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::operator[](uint)+Ap ...
.text$mn:00006088
.text$mn:00006088 var_4           = dword ptr -4
.text$mn:00006088
.text$mn:00006088                 push    ebp
.text$mn:00006089                 mov     ebp, esp
.text$mn:0000608B                 push    ecx
.text$mn:0000608C                 mov     [ebp+var_4], ecx
.text$mn:0000608F                 mov     eax, [ebp+var_4]
.text$mn:00006092                 mov     ecx, [ebp+var_4]
.text$mn:00006095                 mov     eax, [eax+8]
.text$mn:00006098                 sub     eax, [ecx+4]
.text$mn:0000609B                 sar     eax, 3
.text$mn:0000609E                 mov     esp, ebp
.text$mn:000060A0                 pop     ebp
.text$mn:000060A1                 retn
.text$mn:000060A1 ?size@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QBEIXZ endp
.text$mn:000060A1
.text$mn:000060A1 ; ---------------------------------------------------------------------------
.text$mn:000060A2                 align 4
.text$mn:000060A2 _text$mn        ends
.text$mn:000060A2
.text$mn:000060A4 ; ===========================================================================
.text$mn:000060A4
.text$mn:000060A4 ; Segment type: Pure code
.text$mn:000060A4 ; Segment permissions: Read/Execute
.text$mn:000060A4 _text$mn        segment para public 'CODE' use32
.text$mn:000060A4                 assume cs:_text$mn
.text$mn:000060A4                 ;org 60A4h
.text$mn:000060A4 ; COMDAT (pick any)
.text$mn:000060A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000060A4
.text$mn:000060A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000060A4
.text$mn:000060A4 ; Attributes: bp-based frame
.text$mn:000060A4
.text$mn:000060A4 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:000060A4                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:000060A4 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000060A4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_55C4p
.text$mn:000060A4                 push    ebp
.text$mn:000060A5                 mov     ebp, esp
.text$mn:000060A7                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:000060AC                 pop     ebp
.text$mn:000060AD                 retn
.text$mn:000060AD ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000060AD
.text$mn:000060AD ; ---------------------------------------------------------------------------
.text$mn:000060AE                 align 10h
.text$mn:000060AE _text$mn        ends
.text$mn:000060AE
.text$mn:000060B0 ; ===========================================================================
.text$mn:000060B0
.text$mn:000060B0 ; Segment type: Pure code
.text$mn:000060B0 ; Segment permissions: Read/Execute
.text$mn:000060B0 _text$mn        segment para public 'CODE' use32
.text$mn:000060B0                 assume cs:_text$mn
.text$mn:000060B0                 ;org 60B0h
.text$mn:000060B0 ; COMDAT (pick any)
.text$mn:000060B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000060B0
.text$mn:000060B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000060B0
.text$mn:000060B0 ; Attributes: bp-based frame
.text$mn:000060B0
.text$mn:000060B0 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:000060B0                 public ?value@error_code@std@@QBEHXZ
.text$mn:000060B0 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:000060B0
.text$mn:000060B0 var_4           = dword ptr -4
.text$mn:000060B0
.text$mn:000060B0                 push    ebp
.text$mn:000060B1                 mov     ebp, esp
.text$mn:000060B3                 push    ecx
.text$mn:000060B4                 mov     [ebp+var_4], ecx
.text$mn:000060B7                 mov     eax, [ebp+var_4]
.text$mn:000060BA                 mov     eax, [eax]
.text$mn:000060BC                 mov     esp, ebp
.text$mn:000060BE                 pop     ebp
.text$mn:000060BF                 retn
.text$mn:000060BF ?value@error_code@std@@QBEHXZ endp
.text$mn:000060BF
.text$mn:000060BF _text$mn        ends
.text$mn:000060BF
.text$mn:000060C0 ; ===========================================================================
.text$mn:000060C0
.text$mn:000060C0 ; Segment type: Pure code
.text$mn:000060C0 ; Segment permissions: Read/Execute
.text$mn:000060C0 _text$mn        segment para public 'CODE' use32
.text$mn:000060C0                 assume cs:_text$mn
.text$mn:000060C0                 ;org 60C0h
.text$mn:000060C0 ; COMDAT (pick any)
.text$mn:000060C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000060C0
.text$mn:000060C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000060C0
.text$mn:000060C0 ; Attributes: bp-based frame
.text$mn:000060C0
.text$mn:000060C0 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:000060C0                 public ?value@error_condition@std@@QBEHXZ
.text$mn:000060C0 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:000060C0                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:000060C0                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:000060C0
.text$mn:000060C0 var_4           = dword ptr -4
.text$mn:000060C0
.text$mn:000060C0                 push    ebp
.text$mn:000060C1                 mov     ebp, esp
.text$mn:000060C3                 push    ecx
.text$mn:000060C4                 mov     [ebp+var_4], ecx
.text$mn:000060C7                 mov     eax, [ebp+var_4]
.text$mn:000060CA                 mov     eax, [eax]
.text$mn:000060CC                 mov     esp, ebp
.text$mn:000060CE                 pop     ebp
.text$mn:000060CF                 retn
.text$mn:000060CF ?value@error_condition@std@@QBEHXZ endp
.text$mn:000060CF
.text$mn:000060CF _text$mn        ends
.text$mn:000060CF
.text$mn:000060D0 ; ===========================================================================
.text$mn:000060D0
.text$mn:000060D0 ; Segment type: Pure code
.text$mn:000060D0 ; Segment permissions: Read/Execute
.text$mn:000060D0 _text$mn        segment para public 'CODE' use32
.text$mn:000060D0                 assume cs:_text$mn
.text$mn:000060D0                 ;org 60D0h
.text$mn:000060D0 ; COMDAT (pick any)
.text$mn:000060D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000060D0
.text$mn:000060D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000060D0
.text$mn:000060D0 ; Attributes: bp-based frame
.text$mn:000060D0
.text$mn:000060D0                 public _hypot
.text$mn:000060D0 _hypot          proc near
.text$mn:000060D0
.text$mn:000060D0 var_10          = qword ptr -10h
.text$mn:000060D0 var_8           = qword ptr -8
.text$mn:000060D0 arg_0           = qword ptr  8
.text$mn:000060D0 arg_8           = qword ptr  10h
.text$mn:000060D0
.text$mn:000060D0                 push    ebp
.text$mn:000060D1                 mov     ebp, esp
.text$mn:000060D3                 sub     esp, 8
.text$mn:000060D6                 movsd   xmm0, [ebp+arg_8]
.text$mn:000060DB                 movsd   [esp+8+var_8], xmm0
.text$mn:000060E0                 sub     esp, 8
.text$mn:000060E3                 movsd   xmm0, [ebp+arg_0]
.text$mn:000060E8                 movsd   [esp+10h+var_10], xmm0
.text$mn:000060ED                 call    __hypot
.text$mn:000060F2                 add     esp, 10h
.text$mn:000060F5                 pop     ebp
.text$mn:000060F6                 retn
.text$mn:000060F6 _hypot          endp
.text$mn:000060F6
.text$mn:000060F6 ; ---------------------------------------------------------------------------
.text$mn:000060F7                 align 4
.text$mn:000060F7 _text$mn        ends
.text$mn:000060F7
.xdata$x:000060F8 ; ===========================================================================
.xdata$x:000060F8
.xdata$x:000060F8 ; Segment type: Pure data
.xdata$x:000060F8 ; Segment permissions: Read
.xdata$x:000060F8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000060F8                 assume cs:_xdata$x
.xdata$x:000060F8                 ;org 60F8h
.xdata$x:000060F8 ; COMDAT (pick associative to section at 4988)
.xdata$x:000060F8 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:000060F8                                         ; DATA XREF: .xdata$x:00006108o
.xdata$x:000060F9                 db 0FFh
.xdata$x:000060FA                 db 0FFh
.xdata$x:000060FB                 db 0FFh
.xdata$x:000060FC                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00006100 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00006100                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00006101                 db    5
.xdata$x:00006102                 db  93h ; ô
.xdata$x:00006103                 db  19h
.xdata$x:00006104                 db    1
.xdata$x:00006105                 db    0
.xdata$x:00006106                 db    0
.xdata$x:00006107                 db    0
.xdata$x:00006108                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:0000610C                 db    0
.xdata$x:0000610D                 db    0
.xdata$x:0000610E                 db    0
.xdata$x:0000610F                 db    0
.xdata$x:00006110                 db    0
.xdata$x:00006111                 db    0
.xdata$x:00006112                 db    0
.xdata$x:00006113                 db    0
.xdata$x:00006114                 db    0
.xdata$x:00006115                 db    0
.xdata$x:00006116                 db    0
.xdata$x:00006117                 db    0
.xdata$x:00006118                 db    0
.xdata$x:00006119                 db    0
.xdata$x:0000611A                 db    0
.xdata$x:0000611B                 db    0
.xdata$x:0000611C                 db    0
.xdata$x:0000611D                 db    0
.xdata$x:0000611E                 db    0
.xdata$x:0000611F                 db    0
.xdata$x:00006120                 db    0
.xdata$x:00006121                 db    0
.xdata$x:00006122                 db    0
.xdata$x:00006123                 db    0
.xdata$x:00006123 _xdata$x        ends
.xdata$x:00006123
.xdata$x:00006124 ; ===========================================================================
.xdata$x:00006124
.xdata$x:00006124 ; Segment type: Pure data
.xdata$x:00006124 ; Segment permissions: Read
.xdata$x:00006124 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006124                 assume cs:_xdata$x
.xdata$x:00006124                 ;org 6124h
.xdata$x:00006124 ; COMDAT (pick associative to section at 4DFC)
.xdata$x:00006124 __unwindtable$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z db 0FFh
.xdata$x:00006124                                         ; DATA XREF: .xdata$x:00006134o
.xdata$x:00006125                 db 0FFh
.xdata$x:00006126                 db 0FFh
.xdata$x:00006127                 db 0FFh
.xdata$x:00006128                 dd offset __unwindfunclet$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z$0
.xdata$x:0000612C __ehfuncinfo$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z db  22h ; "
.xdata$x:0000612C                                         ; DATA XREF: __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z+11o
.xdata$x:0000612D                 db    5
.xdata$x:0000612E                 db  93h ; ô
.xdata$x:0000612F                 db  19h
.xdata$x:00006130                 db    1
.xdata$x:00006131                 db    0
.xdata$x:00006132                 db    0
.xdata$x:00006133                 db    0
.xdata$x:00006134                 dd offset __unwindtable$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
.xdata$x:00006138                 db    0
.xdata$x:00006139                 db    0
.xdata$x:0000613A                 db    0
.xdata$x:0000613B                 db    0
.xdata$x:0000613C                 db    0
.xdata$x:0000613D                 db    0
.xdata$x:0000613E                 db    0
.xdata$x:0000613F                 db    0
.xdata$x:00006140                 db    0
.xdata$x:00006141                 db    0
.xdata$x:00006142                 db    0
.xdata$x:00006143                 db    0
.xdata$x:00006144                 db    0
.xdata$x:00006145                 db    0
.xdata$x:00006146                 db    0
.xdata$x:00006147                 db    0
.xdata$x:00006148                 db    0
.xdata$x:00006149                 db    0
.xdata$x:0000614A                 db    0
.xdata$x:0000614B                 db    0
.xdata$x:0000614C                 db    0
.xdata$x:0000614D                 db    0
.xdata$x:0000614E                 db    0
.xdata$x:0000614F                 db    0
.xdata$x:0000614F _xdata$x        ends
.xdata$x:0000614F
.xdata$x:00006150 ; ===========================================================================
.xdata$x:00006150
.xdata$x:00006150 ; Segment type: Pure data
.xdata$x:00006150 ; Segment permissions: Read
.xdata$x:00006150 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006150                 assume cs:_xdata$x
.xdata$x:00006150                 ;org 6150h
.xdata$x:00006150 ; COMDAT (pick associative to section at 3C14)
.xdata$x:00006150 __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db 0FFh
.xdata$x:00006150                                         ; DATA XREF: .xdata$x:00006160o
.xdata$x:00006151                 db 0FFh
.xdata$x:00006152                 db 0FFh
.xdata$x:00006153                 db 0FFh
.xdata$x:00006154                 dd offset __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0
.xdata$x:00006158 __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db  22h ; "
.xdata$x:00006158                                         ; DATA XREF: __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z+11o
.xdata$x:00006159                 db    5
.xdata$x:0000615A                 db  93h ; ô
.xdata$x:0000615B                 db  19h
.xdata$x:0000615C                 db    1
.xdata$x:0000615D                 db    0
.xdata$x:0000615E                 db    0
.xdata$x:0000615F                 db    0
.xdata$x:00006160                 dd offset __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.xdata$x:00006164                 db    0
.xdata$x:00006165                 db    0
.xdata$x:00006166                 db    0
.xdata$x:00006167                 db    0
.xdata$x:00006168                 db    0
.xdata$x:00006169                 db    0
.xdata$x:0000616A                 db    0
.xdata$x:0000616B                 db    0
.xdata$x:0000616C                 db    0
.xdata$x:0000616D                 db    0
.xdata$x:0000616E                 db    0
.xdata$x:0000616F                 db    0
.xdata$x:00006170                 db    0
.xdata$x:00006171                 db    0
.xdata$x:00006172                 db    0
.xdata$x:00006173                 db    0
.xdata$x:00006174                 db    0
.xdata$x:00006175                 db    0
.xdata$x:00006176                 db    0
.xdata$x:00006177                 db    0
.xdata$x:00006178                 db    0
.xdata$x:00006179                 db    0
.xdata$x:0000617A                 db    0
.xdata$x:0000617B                 db    0
.xdata$x:0000617B _xdata$x        ends
.xdata$x:0000617B
.xdata$x:0000617C ; ===========================================================================
.xdata$x:0000617C
.xdata$x:0000617C ; Segment type: Pure data
.xdata$x:0000617C ; Segment permissions: Read
.xdata$x:0000617C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000617C                 assume cs:_xdata$x
.xdata$x:0000617C                 ;org 617Ch
.xdata$x:0000617C ; COMDAT (pick associative to section at 3AFC)
.xdata$x:0000617C __unwindtable$??1_Iterator_base12@std@@QAE@XZ db 0FFh
.xdata$x:0000617C                                         ; DATA XREF: .xdata$x:0000618Co
.xdata$x:0000617D                 db 0FFh
.xdata$x:0000617E                 db 0FFh
.xdata$x:0000617F                 db 0FFh
.xdata$x:00006180                 dd offset __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0
.xdata$x:00006184 __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ db  22h ; "
.xdata$x:00006184                                         ; DATA XREF: __ehhandler$??1_Iterator_base12@std@@QAE@XZ+11o
.xdata$x:00006185                 db    5
.xdata$x:00006186                 db  93h ; ô
.xdata$x:00006187                 db  19h
.xdata$x:00006188                 db    1
.xdata$x:00006189                 db    0
.xdata$x:0000618A                 db    0
.xdata$x:0000618B                 db    0
.xdata$x:0000618C                 dd offset __unwindtable$??1_Iterator_base12@std@@QAE@XZ
.xdata$x:00006190                 db    0
.xdata$x:00006191                 db    0
.xdata$x:00006192                 db    0
.xdata$x:00006193                 db    0
.xdata$x:00006194                 db    0
.xdata$x:00006195                 db    0
.xdata$x:00006196                 db    0
.xdata$x:00006197                 db    0
.xdata$x:00006198                 db    0
.xdata$x:00006199                 db    0
.xdata$x:0000619A                 db    0
.xdata$x:0000619B                 db    0
.xdata$x:0000619C                 db    0
.xdata$x:0000619D                 db    0
.xdata$x:0000619E                 db    0
.xdata$x:0000619F                 db    0
.xdata$x:000061A0                 db    0
.xdata$x:000061A1                 db    0
.xdata$x:000061A2                 db    0
.xdata$x:000061A3                 db    0
.xdata$x:000061A4                 db    0
.xdata$x:000061A5                 db    0
.xdata$x:000061A6                 db    0
.xdata$x:000061A7                 db    0
.xdata$x:000061A7 _xdata$x        ends
.xdata$x:000061A7
.xdata$x:000061A8 ; ===========================================================================
.xdata$x:000061A8
.xdata$x:000061A8 ; Segment type: Pure data
.xdata$x:000061A8 ; Segment permissions: Read
.xdata$x:000061A8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000061A8                 assume cs:_xdata$x
.xdata$x:000061A8                 ;org 61A8h
.xdata$x:000061A8 ; COMDAT (pick associative to section at 4184)
.xdata$x:000061A8 __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db 0FFh
.xdata$x:000061A8                                         ; DATA XREF: .xdata$x:000061C0o
.xdata$x:000061A9                 db 0FFh
.xdata$x:000061AA                 db 0FFh
.xdata$x:000061AB                 db 0FFh
.xdata$x:000061AC                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
.xdata$x:000061B0                 db 0FFh
.xdata$x:000061B1                 db 0FFh
.xdata$x:000061B2                 db 0FFh
.xdata$x:000061B3                 db 0FFh
.xdata$x:000061B4                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
.xdata$x:000061B8 __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db  22h ; "
.xdata$x:000061B8                                         ; DATA XREF: __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z+11o
.xdata$x:000061B9                 db    5
.xdata$x:000061BA                 db  93h ; ô
.xdata$x:000061BB                 db  19h
.xdata$x:000061BC                 db    2
.xdata$x:000061BD                 db    0
.xdata$x:000061BE                 db    0
.xdata$x:000061BF                 db    0
.xdata$x:000061C0                 dd offset __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.xdata$x:000061C4                 db    0
.xdata$x:000061C5                 db    0
.xdata$x:000061C6                 db    0
.xdata$x:000061C7                 db    0
.xdata$x:000061C8                 db    0
.xdata$x:000061C9                 db    0
.xdata$x:000061CA                 db    0
.xdata$x:000061CB                 db    0
.xdata$x:000061CC                 db    0
.xdata$x:000061CD                 db    0
.xdata$x:000061CE                 db    0
.xdata$x:000061CF                 db    0
.xdata$x:000061D0                 db    0
.xdata$x:000061D1                 db    0
.xdata$x:000061D2                 db    0
.xdata$x:000061D3                 db    0
.xdata$x:000061D4                 db    0
.xdata$x:000061D5                 db    0
.xdata$x:000061D6                 db    0
.xdata$x:000061D7                 db    0
.xdata$x:000061D8                 db    0
.xdata$x:000061D9                 db    0
.xdata$x:000061DA                 db    0
.xdata$x:000061DB                 db    0
.xdata$x:000061DB _xdata$x        ends
.xdata$x:000061DB
.xdata$x:000061DC ; ===========================================================================
.xdata$x:000061DC
.xdata$x:000061DC ; Segment type: Pure data
.xdata$x:000061DC ; Segment permissions: Read
.xdata$x:000061DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000061DC                 assume cs:_xdata$x
.xdata$x:000061DC                 ;org 61DCh
.xdata$x:000061DC ; COMDAT (pick associative to section at 2F38)
.xdata$x:000061DC __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000061DC                                         ; DATA XREF: .xdata$x:000061ECo
.xdata$x:000061DD                 db 0FFh
.xdata$x:000061DE                 db 0FFh
.xdata$x:000061DF                 db 0FFh
.xdata$x:000061E0                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:000061E4 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000061E4                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:000061E5                 db    5
.xdata$x:000061E6                 db  93h ; ô
.xdata$x:000061E7                 db  19h
.xdata$x:000061E8                 db    1
.xdata$x:000061E9                 db    0
.xdata$x:000061EA                 db    0
.xdata$x:000061EB                 db    0
.xdata$x:000061EC                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:000061F0                 db    0
.xdata$x:000061F1                 db    0
.xdata$x:000061F2                 db    0
.xdata$x:000061F3                 db    0
.xdata$x:000061F4                 db    0
.xdata$x:000061F5                 db    0
.xdata$x:000061F6                 db    0
.xdata$x:000061F7                 db    0
.xdata$x:000061F8                 db    0
.xdata$x:000061F9                 db    0
.xdata$x:000061FA                 db    0
.xdata$x:000061FB                 db    0
.xdata$x:000061FC                 db    0
.xdata$x:000061FD                 db    0
.xdata$x:000061FE                 db    0
.xdata$x:000061FF                 db    0
.xdata$x:00006200                 db    0
.xdata$x:00006201                 db    0
.xdata$x:00006202                 db    0
.xdata$x:00006203                 db    0
.xdata$x:00006204                 db    0
.xdata$x:00006205                 db    0
.xdata$x:00006206                 db    0
.xdata$x:00006207                 db    0
.xdata$x:00006207 _xdata$x        ends
.xdata$x:00006207
.xdata$x:00006208 ; ===========================================================================
.xdata$x:00006208
.xdata$x:00006208 ; Segment type: Pure data
.xdata$x:00006208 ; Segment permissions: Read
.xdata$x:00006208 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006208                 assume cs:_xdata$x
.xdata$x:00006208                 ;org 6208h
.xdata$x:00006208 ; COMDAT (pick associative to section at 37BC)
.xdata$x:00006208 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00006208                                         ; DATA XREF: .xdata$x:00006218o
.xdata$x:00006209                 db 0FFh
.xdata$x:0000620A                 db 0FFh
.xdata$x:0000620B                 db 0FFh
.xdata$x:0000620C                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00006210 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00006210                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00006211                 db    5
.xdata$x:00006212                 db  93h ; ô
.xdata$x:00006213                 db  19h
.xdata$x:00006214                 db    1
.xdata$x:00006215                 db    0
.xdata$x:00006216                 db    0
.xdata$x:00006217                 db    0
.xdata$x:00006218                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:0000621C                 db    0
.xdata$x:0000621D                 db    0
.xdata$x:0000621E                 db    0
.xdata$x:0000621F                 db    0
.xdata$x:00006220                 db    0
.xdata$x:00006221                 db    0
.xdata$x:00006222                 db    0
.xdata$x:00006223                 db    0
.xdata$x:00006224                 db    0
.xdata$x:00006225                 db    0
.xdata$x:00006226                 db    0
.xdata$x:00006227                 db    0
.xdata$x:00006228                 db    0
.xdata$x:00006229                 db    0
.xdata$x:0000622A                 db    0
.xdata$x:0000622B                 db    0
.xdata$x:0000622C                 db    0
.xdata$x:0000622D                 db    0
.xdata$x:0000622E                 db    0
.xdata$x:0000622F                 db    0
.xdata$x:00006230                 db    0
.xdata$x:00006231                 db    0
.xdata$x:00006232                 db    0
.xdata$x:00006233                 db    0
.xdata$x:00006233 _xdata$x        ends
.xdata$x:00006233
.xdata$x:00006234 ; ===========================================================================
.xdata$x:00006234
.xdata$x:00006234 ; Segment type: Pure data
.xdata$x:00006234 ; Segment permissions: Read
.xdata$x:00006234 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006234                 assume cs:_xdata$x
.xdata$x:00006234                 ;org 6234h
.xdata$x:00006234 ; COMDAT (pick associative to section at 2CB8)
.xdata$x:00006234 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00006234                                         ; DATA XREF: .xdata$x:00006244o
.xdata$x:00006235                 db 0FFh
.xdata$x:00006236                 db 0FFh
.xdata$x:00006237                 db 0FFh
.xdata$x:00006238                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:0000623C __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:0000623C                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:0000623D                 db    5
.xdata$x:0000623E                 db  93h ; ô
.xdata$x:0000623F                 db  19h
.xdata$x:00006240                 db    1
.xdata$x:00006241                 db    0
.xdata$x:00006242                 db    0
.xdata$x:00006243                 db    0
.xdata$x:00006244                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00006248                 align 20h
.xdata$x:00006248 _xdata$x        ends
.xdata$x:00006248
.xdata$x:00006260 ; ===========================================================================
.xdata$x:00006260
.xdata$x:00006260 ; Segment type: Pure data
.xdata$x:00006260 ; Segment permissions: Read
.xdata$x:00006260 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006260                 assume cs:_xdata$x
.xdata$x:00006260                 ;org 6260h
.xdata$x:00006260 ; COMDAT (pick associative to section at 3664)
.xdata$x:00006260 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00006260                                         ; DATA XREF: .xdata$x:00006270o
.xdata$x:00006261                 db 0FFh
.xdata$x:00006262                 db 0FFh
.xdata$x:00006263                 db 0FFh
.xdata$x:00006264                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00006268 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00006268                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00006269                 db    5
.xdata$x:0000626A                 db  93h ; ô
.xdata$x:0000626B                 db  19h
.xdata$x:0000626C                 db    1
.xdata$x:0000626D                 db    0
.xdata$x:0000626E                 db    0
.xdata$x:0000626F                 db    0
.xdata$x:00006270                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00006274                 db    0
.xdata$x:00006275                 db    0
.xdata$x:00006276                 db    0
.xdata$x:00006277                 db    0
.xdata$x:00006278                 db    0
.xdata$x:00006279                 db    0
.xdata$x:0000627A                 db    0
.xdata$x:0000627B                 db    0
.xdata$x:0000627C                 db    0
.xdata$x:0000627D                 db    0
.xdata$x:0000627E                 db    0
.xdata$x:0000627F                 db    0
.xdata$x:00006280                 db    0
.xdata$x:00006281                 db    0
.xdata$x:00006282                 db    0
.xdata$x:00006283                 db    0
.xdata$x:00006284                 db    0
.xdata$x:00006285                 db    0
.xdata$x:00006286                 db    0
.xdata$x:00006287                 db    0
.xdata$x:00006288                 db    0
.xdata$x:00006289                 db    0
.xdata$x:0000628A                 db    0
.xdata$x:0000628B                 db    0
.xdata$x:0000628B _xdata$x        ends
.xdata$x:0000628B
.xdata$x:0000628C ; ===========================================================================
.xdata$x:0000628C
.xdata$x:0000628C ; Segment type: Pure data
.xdata$x:0000628C ; Segment permissions: Read
.xdata$x:0000628C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000628C                 assume cs:_xdata$x
.xdata$x:0000628C                 ;org 628Ch
.xdata$x:0000628C ; COMDAT (pick associative to section at 31DC)
.xdata$x:0000628C __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000628C                                         ; DATA XREF: .xdata$x:0000629Co
.xdata$x:0000628D                 db 0FFh
.xdata$x:0000628E                 db 0FFh
.xdata$x:0000628F                 db 0FFh
.xdata$x:00006290                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00006294 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00006294                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00006295                 db    5
.xdata$x:00006296                 db  93h ; ô
.xdata$x:00006297                 db  19h
.xdata$x:00006298                 db    1
.xdata$x:00006299                 db    0
.xdata$x:0000629A                 db    0
.xdata$x:0000629B                 db    0
.xdata$x:0000629C                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:000062A0                 db    0
.xdata$x:000062A1                 db    0
.xdata$x:000062A2                 db    0
.xdata$x:000062A3                 db    0
.xdata$x:000062A4                 db    0
.xdata$x:000062A5                 db    0
.xdata$x:000062A6                 db    0
.xdata$x:000062A7                 db    0
.xdata$x:000062A8                 db    0
.xdata$x:000062A9                 db    0
.xdata$x:000062AA                 db    0
.xdata$x:000062AB                 db    0
.xdata$x:000062AC                 db    0
.xdata$x:000062AD                 db    0
.xdata$x:000062AE                 db    0
.xdata$x:000062AF                 db    0
.xdata$x:000062B0                 db    0
.xdata$x:000062B1                 db    0
.xdata$x:000062B2                 db    0
.xdata$x:000062B3                 db    0
.xdata$x:000062B4                 db    0
.xdata$x:000062B5                 db    0
.xdata$x:000062B6                 db    0
.xdata$x:000062B7                 db    0
.xdata$x:000062B7 _xdata$x        ends
.xdata$x:000062B7
.xdata$x:000062B8 ; ===========================================================================
.xdata$x:000062B8
.xdata$x:000062B8 ; Segment type: Pure data
.xdata$x:000062B8 ; Segment permissions: Read
.xdata$x:000062B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000062B8                 assume cs:_xdata$x
.xdata$x:000062B8                 ;org 62B8h
.xdata$x:000062B8 ; COMDAT (pick associative to section at 3144)
.xdata$x:000062B8 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:000062B8                                         ; DATA XREF: .xdata$x:000062C8o
.xdata$x:000062B9                 db 0FFh
.xdata$x:000062BA                 db 0FFh
.xdata$x:000062BB                 db 0FFh
.xdata$x:000062BC                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:000062C0 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:000062C0                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:000062C1                 db    5
.xdata$x:000062C2                 db  93h ; ô
.xdata$x:000062C3                 db  19h
.xdata$x:000062C4                 db    1
.xdata$x:000062C5                 db    0
.xdata$x:000062C6                 db    0
.xdata$x:000062C7                 db    0
.xdata$x:000062C8                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:000062CC                 db    0
.xdata$x:000062CD                 db    0
.xdata$x:000062CE                 db    0
.xdata$x:000062CF                 db    0
.xdata$x:000062D0                 db    0
.xdata$x:000062D1                 db    0
.xdata$x:000062D2                 db    0
.xdata$x:000062D3                 db    0
.xdata$x:000062D4                 db    0
.xdata$x:000062D5                 db    0
.xdata$x:000062D6                 db    0
.xdata$x:000062D7                 db    0
.xdata$x:000062D8                 db    0
.xdata$x:000062D9                 db    0
.xdata$x:000062DA                 db    0
.xdata$x:000062DB                 db    0
.xdata$x:000062DC                 db    0
.xdata$x:000062DD                 db    0
.xdata$x:000062DE                 db    0
.xdata$x:000062DF                 db    0
.xdata$x:000062E0                 db    0
.xdata$x:000062E1                 db    0
.xdata$x:000062E2                 db    0
.xdata$x:000062E3                 db    0
.xdata$x:000062E3 _xdata$x        ends
.xdata$x:000062E3
.xdata$x:000062E4 ; ===========================================================================
.xdata$x:000062E4
.xdata$x:000062E4 ; Segment type: Pure data
.xdata$x:000062E4 ; Segment permissions: Read
.xdata$x:000062E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000062E4                 assume cs:_xdata$x
.xdata$x:000062E4                 ;org 62E4h
.xdata$x:000062E4 ; COMDAT (pick associative to section at 3914)
.xdata$x:000062E4 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:000062E4                                         ; DATA XREF: .xdata$x:000062F4o
.xdata$x:000062E5                 db 0FFh
.xdata$x:000062E6                 db 0FFh
.xdata$x:000062E7                 db 0FFh
.xdata$x:000062E8                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:000062EC __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:000062EC                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:000062ED                 db    5
.xdata$x:000062EE                 db  93h ; ô
.xdata$x:000062EF                 db  19h
.xdata$x:000062F0                 db    1
.xdata$x:000062F1                 db    0
.xdata$x:000062F2                 db    0
.xdata$x:000062F3                 db    0
.xdata$x:000062F4                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:000062F8                 db    0
.xdata$x:000062F9                 db    0
.xdata$x:000062FA                 db    0
.xdata$x:000062FB                 db    0
.xdata$x:000062FC                 db    0
.xdata$x:000062FD                 db    0
.xdata$x:000062FE                 db    0
.xdata$x:000062FF                 db    0
.xdata$x:00006300                 db    0
.xdata$x:00006301                 db    0
.xdata$x:00006302                 db    0
.xdata$x:00006303                 db    0
.xdata$x:00006304                 db    0
.xdata$x:00006305                 db    0
.xdata$x:00006306                 db    0
.xdata$x:00006307                 db    0
.xdata$x:00006308                 db    0
.xdata$x:00006309                 db    0
.xdata$x:0000630A                 db    0
.xdata$x:0000630B                 db    0
.xdata$x:0000630C                 db    0
.xdata$x:0000630D                 db    0
.xdata$x:0000630E                 db    0
.xdata$x:0000630F                 db    0
.xdata$x:0000630F _xdata$x        ends
.xdata$x:0000630F
.xdata$x:00006310 ; ===========================================================================
.xdata$x:00006310
.xdata$x:00006310 ; Segment type: Pure data
.xdata$x:00006310 ; Segment permissions: Read
.xdata$x:00006310 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006310                 assume cs:_xdata$x
.xdata$x:00006310                 ;org 6310h
.xdata$x:00006310 ; COMDAT (pick associative to section at 5850)
.xdata$x:00006310 __ehfuncinfo$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z db  22h ; "
.xdata$x:00006310                                         ; DATA XREF: __ehhandler$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z+11o
.xdata$x:00006311                 db    5
.xdata$x:00006312                 db  93h ; ô
.xdata$x:00006313                 db  19h
.xdata$x:00006314                 db    6
.xdata$x:00006315                 db    0
.xdata$x:00006316                 db    0
.xdata$x:00006317                 db    0
.xdata$x:00006318                 dd offset __unwindtable$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z
.xdata$x:0000631C                 db    0
.xdata$x:0000631D                 db    0
.xdata$x:0000631E                 db    0
.xdata$x:0000631F                 db    0
.xdata$x:00006320                 db    0
.xdata$x:00006321                 db    0
.xdata$x:00006322                 db    0
.xdata$x:00006323                 db    0
.xdata$x:00006324                 db    0
.xdata$x:00006325                 db    0
.xdata$x:00006326                 db    0
.xdata$x:00006327                 db    0
.xdata$x:00006328                 db    0
.xdata$x:00006329                 db    0
.xdata$x:0000632A                 db    0
.xdata$x:0000632B                 db    0
.xdata$x:0000632C                 db    0
.xdata$x:0000632D                 db    0
.xdata$x:0000632E                 db    0
.xdata$x:0000632F                 db    0
.xdata$x:00006330                 db    0
.xdata$x:00006331                 db    0
.xdata$x:00006332                 db    0
.xdata$x:00006333                 db    0
.xdata$x:00006334 __unwindtable$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z db 0FFh
.xdata$x:00006334                                         ; DATA XREF: .xdata$x:00006318o
.xdata$x:00006335                 db 0FFh
.xdata$x:00006336                 db 0FFh
.xdata$x:00006337                 db 0FFh
.xdata$x:00006338                 dd offset __unwindfunclet$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z$5
.xdata$x:0000633C                 align 10h
.xdata$x:00006340                 dd offset __unwindfunclet$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z$0
.xdata$x:00006344                 db    1
.xdata$x:00006345                 db    0
.xdata$x:00006346                 db    0
.xdata$x:00006347                 db    0
.xdata$x:00006348                 dd offset __unwindfunclet$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z$1
.xdata$x:0000634C                 db    2
.xdata$x:0000634D                 db    0
.xdata$x:0000634E                 db    0
.xdata$x:0000634F                 db    0
.xdata$x:00006350                 dd offset __unwindfunclet$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z$2
.xdata$x:00006354                 db    3
.xdata$x:00006355                 db    0
.xdata$x:00006356                 db    0
.xdata$x:00006357                 db    0
.xdata$x:00006358                 dd offset __unwindfunclet$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z$3
.xdata$x:0000635C                 db    1
.xdata$x:0000635D                 db    0
.xdata$x:0000635E                 db    0
.xdata$x:0000635F                 db    0
.xdata$x:00006360                 dd offset __unwindfunclet$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@D@Z$4
.xdata$x:00006360 _xdata$x        ends
.xdata$x:00006360
.xdata$x:00006364 ; ===========================================================================
.xdata$x:00006364
.xdata$x:00006364 ; Segment type: Pure data
.xdata$x:00006364 ; Segment permissions: Read
.xdata$x:00006364 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006364                 assume cs:_xdata$x
.xdata$x:00006364                 ;org 6364h
.xdata$x:00006364 ; COMDAT (pick associative to section at 5370)
.xdata$x:00006364 __unwindtable$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ db 0FFh
.xdata$x:00006364                                         ; DATA XREF: .xdata$x:00006374o
.xdata$x:00006365                 db 0FFh
.xdata$x:00006366                 db 0FFh
.xdata$x:00006367                 db 0FFh
.xdata$x:00006368                 dd offset __unwindfunclet$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ$0
.xdata$x:0000636C __ehfuncinfo$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000636C                                         ; DATA XREF: __ehhandler$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ+11o
.xdata$x:0000636D                 db    5
.xdata$x:0000636E                 db  93h ; ô
.xdata$x:0000636F                 db  19h
.xdata$x:00006370                 db    1
.xdata$x:00006371                 db    0
.xdata$x:00006372                 db    0
.xdata$x:00006373                 db    0
.xdata$x:00006374                 dd offset __unwindtable$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
.xdata$x:00006378                 db    0
.xdata$x:00006379                 db    0
.xdata$x:0000637A                 db    0
.xdata$x:0000637B                 db    0
.xdata$x:0000637C                 db    0
.xdata$x:0000637D                 db    0
.xdata$x:0000637E                 db    0
.xdata$x:0000637F                 db    0
.xdata$x:00006380                 db    0
.xdata$x:00006381                 db    0
.xdata$x:00006382                 db    0
.xdata$x:00006383                 db    0
.xdata$x:00006384                 db    0
.xdata$x:00006385                 db    0
.xdata$x:00006386                 db    0
.xdata$x:00006387                 db    0
.xdata$x:00006388                 db    0
.xdata$x:00006389                 db    0
.xdata$x:0000638A                 db    0
.xdata$x:0000638B                 db    0
.xdata$x:0000638C                 db    0
.xdata$x:0000638D                 db    0
.xdata$x:0000638E                 db    0
.xdata$x:0000638F                 db    0
.xdata$x:0000638F _xdata$x        ends
.xdata$x:0000638F
.xdata$x:00006390 ; ===========================================================================
.xdata$x:00006390
.xdata$x:00006390 ; Segment type: Pure data
.xdata$x:00006390 ; Segment permissions: Read
.xdata$x:00006390 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006390                 assume cs:_xdata$x
.xdata$x:00006390                 ;org 6390h
.xdata$x:00006390 ; COMDAT (pick associative to section at 5600)
.xdata$x:00006390 __unwindtable$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ db 0FFh
.xdata$x:00006390                                         ; DATA XREF: .xdata$x:000063A0o
.xdata$x:00006391                 db 0FFh
.xdata$x:00006392                 db 0FFh
.xdata$x:00006393                 db 0FFh
.xdata$x:00006394                 dd offset __unwindfunclet$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ$0
.xdata$x:00006398 __ehfuncinfo$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ db  22h ; "
.xdata$x:00006398                                         ; DATA XREF: __ehhandler$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ+11o
.xdata$x:00006399                 db    5
.xdata$x:0000639A                 db  93h ; ô
.xdata$x:0000639B                 db  19h
.xdata$x:0000639C                 db    1
.xdata$x:0000639D                 db    0
.xdata$x:0000639E                 db    0
.xdata$x:0000639F                 db    0
.xdata$x:000063A0                 dd offset __unwindtable$?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
.xdata$x:000063A4                 db    0
.xdata$x:000063A5                 db    0
.xdata$x:000063A6                 db    0
.xdata$x:000063A7                 db    0
.xdata$x:000063A8                 db    0
.xdata$x:000063A9                 db    0
.xdata$x:000063AA                 db    0
.xdata$x:000063AB                 db    0
.xdata$x:000063AC                 db    0
.xdata$x:000063AD                 db    0
.xdata$x:000063AE                 db    0
.xdata$x:000063AF                 db    0
.xdata$x:000063B0                 db    0
.xdata$x:000063B1                 db    0
.xdata$x:000063B2                 db    0
.xdata$x:000063B3                 db    0
.xdata$x:000063B4                 db    0
.xdata$x:000063B5                 db    0
.xdata$x:000063B6                 db    0
.xdata$x:000063B7                 db    0
.xdata$x:000063B8                 db    0
.xdata$x:000063B9                 db    0
.xdata$x:000063BA                 db    0
.xdata$x:000063BB                 db    0
.xdata$x:000063BB _xdata$x        ends
.xdata$x:000063BB
.xdata$x:000063BC ; ===========================================================================
.xdata$x:000063BC
.xdata$x:000063BC ; Segment type: Pure data
.xdata$x:000063BC ; Segment permissions: Read
.xdata$x:000063BC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000063BC                 assume cs:_xdata$x
.xdata$x:000063BC                 ;org 63BCh
.xdata$x:000063BC ; COMDAT (pick associative to section at 5E88)
.xdata$x:000063BC __unwindtable$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z db 0FFh
.xdata$x:000063BC                                         ; DATA XREF: .xdata$x:000063D4o
.xdata$x:000063BD                 db 0FFh
.xdata$x:000063BE                 db 0FFh
.xdata$x:000063BF                 db 0FFh
.xdata$x:000063C0                 dd offset __unwindfunclet$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z$0
.xdata$x:000063C4                 align 8
.xdata$x:000063C8                 dd offset __unwindfunclet$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z$1
.xdata$x:000063CC __ehfuncinfo$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z db  22h ; "
.xdata$x:000063CC                                         ; DATA XREF: __ehhandler$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z+11o
.xdata$x:000063CD                 db    5
.xdata$x:000063CE                 db  93h ; ô
.xdata$x:000063CF                 db  19h
.xdata$x:000063D0                 db    2
.xdata$x:000063D1                 db    0
.xdata$x:000063D2                 db    0
.xdata$x:000063D3                 db    0
.xdata$x:000063D4                 dd offset __unwindtable$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z
.xdata$x:000063D8                 db    0
.xdata$x:000063D9                 db    0
.xdata$x:000063DA                 db    0
.xdata$x:000063DB                 db    0
.xdata$x:000063DC                 db    0
.xdata$x:000063DD                 db    0
.xdata$x:000063DE                 db    0
.xdata$x:000063DF                 db    0
.xdata$x:000063E0                 db    0
.xdata$x:000063E1                 db    0
.xdata$x:000063E2                 db    0
.xdata$x:000063E3                 db    0
.xdata$x:000063E4                 db    0
.xdata$x:000063E5                 db    0
.xdata$x:000063E6                 db    0
.xdata$x:000063E7                 db    0
.xdata$x:000063E8                 db    0
.xdata$x:000063E9                 db    0
.xdata$x:000063EA                 db    0
.xdata$x:000063EB                 db    0
.xdata$x:000063EC                 db    0
.xdata$x:000063ED                 db    0
.xdata$x:000063EE                 db    0
.xdata$x:000063EF                 db    0
.xdata$x:000063EF _xdata$x        ends
.xdata$x:000063EF
.xdata$x:000063F0 ; ===========================================================================
.xdata$x:000063F0
.xdata$x:000063F0 ; Segment type: Pure data
.xdata$x:000063F0 ; Segment permissions: Read
.xdata$x:000063F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000063F0                 assume cs:_xdata$x
.xdata$x:000063F0                 ;org 63F0h
.xdata$x:000063F0 ; COMDAT (pick associative to section at 4458)
.xdata$x:000063F0 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:000063F0                                         ; DATA XREF: .xdata$x:00006478o
.xdata$x:000063F1                 db    0
.xdata$x:000063F2                 db    0
.xdata$x:000063F3                 db    0
.xdata$x:000063F4                 db    0
.xdata$x:000063F5                 db    0
.xdata$x:000063F6                 db    0
.xdata$x:000063F7                 db    0
.xdata$x:000063F8                 db    0
.xdata$x:000063F9                 db    0
.xdata$x:000063FA                 db    0
.xdata$x:000063FB                 db    0
.xdata$x:000063FC                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00006400 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00006400                                         ; DATA XREF: .xdata$x:00006464o
.xdata$x:00006401                 db    0
.xdata$x:00006402                 db    0
.xdata$x:00006403                 db    0
.xdata$x:00006404                 db    0
.xdata$x:00006405                 db    0
.xdata$x:00006406                 db    0
.xdata$x:00006407                 db    0
.xdata$x:00006408                 db    0
.xdata$x:00006409                 db    0
.xdata$x:0000640A                 db    0
.xdata$x:0000640B                 db    0
.xdata$x:0000640C                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00006410 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00006410                                         ; DATA XREF: .xdata$x:00006438o
.xdata$x:00006411                 db 0FFh
.xdata$x:00006412                 db 0FFh
.xdata$x:00006413                 db 0FFh
.xdata$x:00006414                 db    0
.xdata$x:00006415                 db    0
.xdata$x:00006416                 db    0
.xdata$x:00006417                 db    0
.xdata$x:00006418                 db 0FFh
.xdata$x:00006419                 db 0FFh
.xdata$x:0000641A                 db 0FFh
.xdata$x:0000641B                 db 0FFh
.xdata$x:0000641C                 db    0
.xdata$x:0000641D                 db    0
.xdata$x:0000641E                 db    0
.xdata$x:0000641F                 db    0
.xdata$x:00006420                 db    1
.xdata$x:00006421                 db    0
.xdata$x:00006422                 db    0
.xdata$x:00006423                 db    0
.xdata$x:00006424                 db    0
.xdata$x:00006425                 db    0
.xdata$x:00006426                 db    0
.xdata$x:00006427                 db    0
.xdata$x:00006428                 db    1
.xdata$x:00006429                 db    0
.xdata$x:0000642A                 db    0
.xdata$x:0000642B                 db    0
.xdata$x:0000642C                 db    0
.xdata$x:0000642D                 db    0
.xdata$x:0000642E                 db    0
.xdata$x:0000642F                 db    0
.xdata$x:00006430 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00006430                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00006431                 db    5
.xdata$x:00006432                 db  93h ; ô
.xdata$x:00006433                 db  19h
.xdata$x:00006434                 db    4
.xdata$x:00006435                 db    0
.xdata$x:00006436                 db    0
.xdata$x:00006437                 db    0
.xdata$x:00006438                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:0000643C                 db    2
.xdata$x:0000643D                 db    0
.xdata$x:0000643E                 db    0
.xdata$x:0000643F                 db    0
.xdata$x:00006440                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00006444                 db    0
.xdata$x:00006445                 db    0
.xdata$x:00006446                 db    0
.xdata$x:00006447                 db    0
.xdata$x:00006448                 db    0
.xdata$x:00006449                 db    0
.xdata$x:0000644A                 db    0
.xdata$x:0000644B                 db    0
.xdata$x:0000644C                 db    0
.xdata$x:0000644D                 db    0
.xdata$x:0000644E                 db    0
.xdata$x:0000644F                 db    0
.xdata$x:00006450                 db    0
.xdata$x:00006451                 db    0
.xdata$x:00006452                 db    0
.xdata$x:00006453                 db    0
.xdata$x:00006454 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00006454                                         ; DATA XREF: .xdata$x:00006440o
.xdata$x:00006455                 db    0
.xdata$x:00006456                 db    0
.xdata$x:00006457                 db    0
.xdata$x:00006458                 db    2
.xdata$x:00006459                 db    0
.xdata$x:0000645A                 db    0
.xdata$x:0000645B                 db    0
.xdata$x:0000645C                 db    3
.xdata$x:0000645D                 db    0
.xdata$x:0000645E                 db    0
.xdata$x:0000645F                 db    0
.xdata$x:00006460                 db    1
.xdata$x:00006461                 db    0
.xdata$x:00006462                 db    0
.xdata$x:00006463                 db    0
.xdata$x:00006464                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00006468                 align 10h
.xdata$x:00006470                 db    3
.xdata$x:00006471                 db    0
.xdata$x:00006472                 db    0
.xdata$x:00006473                 db    0
.xdata$x:00006474                 db    1
.xdata$x:00006475                 db    0
.xdata$x:00006476                 db    0
.xdata$x:00006477                 db    0
.xdata$x:00006478                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00006478 _xdata$x        ends
.xdata$x:00006478
.xdata$x:0000647C ; ===========================================================================
.xdata$x:0000647C
.xdata$x:0000647C ; Segment type: Pure data
.xdata$x:0000647C ; Segment permissions: Read
.xdata$x:0000647C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000647C                 assume cs:_xdata$x
.xdata$x:0000647C                 ;org 647Ch
.xdata$x:0000647C ; COMDAT (pick associative to section at 4B98)
.xdata$x:0000647C __unwindtable$?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0@Z db 0FFh
.xdata$x:0000647C                                         ; DATA XREF: .xdata$x:00006494o
.xdata$x:0000647D                 db 0FFh
.xdata$x:0000647E                 db 0FFh
.xdata$x:0000647F                 db 0FFh
.xdata$x:00006480                 dd offset __unwindfunclet$?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0@Z$0
.xdata$x:00006484                 align 8
.xdata$x:00006488                 dd offset __unwindfunclet$?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0@Z$1
.xdata$x:0000648C __ehfuncinfo$?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0@Z db  22h ; "
.xdata$x:0000648C                                         ; DATA XREF: __ehhandler$?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0@Z+11o
.xdata$x:0000648D                 db    5
.xdata$x:0000648E                 db  93h ; ô
.xdata$x:0000648F                 db  19h
.xdata$x:00006490                 db    2
.xdata$x:00006491                 db    0
.xdata$x:00006492                 db    0
.xdata$x:00006493                 db    0
.xdata$x:00006494                 dd offset __unwindtable$?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0@Z
.xdata$x:00006498                 db    0
.xdata$x:00006499                 db    0
.xdata$x:0000649A                 db    0
.xdata$x:0000649B                 db    0
.xdata$x:0000649C                 db    0
.xdata$x:0000649D                 db    0
.xdata$x:0000649E                 db    0
.xdata$x:0000649F                 db    0
.xdata$x:000064A0                 db    0
.xdata$x:000064A1                 db    0
.xdata$x:000064A2                 db    0
.xdata$x:000064A3                 db    0
.xdata$x:000064A4                 db    0
.xdata$x:000064A5                 db    0
.xdata$x:000064A6                 db    0
.xdata$x:000064A7                 db    0
.xdata$x:000064A8                 db    0
.xdata$x:000064A9                 db    0
.xdata$x:000064AA                 db    0
.xdata$x:000064AB                 db    0
.xdata$x:000064AC                 db    0
.xdata$x:000064AD                 db    0
.xdata$x:000064AE                 db    0
.xdata$x:000064AF                 db    0
.xdata$x:000064AF _xdata$x        ends
.xdata$x:000064AF
.xdata$x:000064B0 ; ===========================================================================
.xdata$x:000064B0
.xdata$x:000064B0 ; Segment type: Pure data
.xdata$x:000064B0 ; Segment permissions: Read
.xdata$x:000064B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000064B0                 assume cs:_xdata$x
.xdata$x:000064B0                 ;org 64B0h
.xdata$x:000064B0 ; COMDAT (pick associative to section at 33C8)
.xdata$x:000064B0 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000064B0                                         ; DATA XREF: .xdata$x:000064C0o
.xdata$x:000064B1                 db 0FFh
.xdata$x:000064B2                 db 0FFh
.xdata$x:000064B3                 db 0FFh
.xdata$x:000064B4                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:000064B8 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000064B8                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:000064B9                 db    5
.xdata$x:000064BA                 db  93h ; ô
.xdata$x:000064BB                 db  19h
.xdata$x:000064BC                 db    1
.xdata$x:000064BD                 db    0
.xdata$x:000064BE                 db    0
.xdata$x:000064BF                 db    0
.xdata$x:000064C0                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:000064C4                 db    0
.xdata$x:000064C5                 db    0
.xdata$x:000064C6                 db    0
.xdata$x:000064C7                 db    0
.xdata$x:000064C8                 db    0
.xdata$x:000064C9                 db    0
.xdata$x:000064CA                 db    0
.xdata$x:000064CB                 db    0
.xdata$x:000064CC                 db    0
.xdata$x:000064CD                 db    0
.xdata$x:000064CE                 db    0
.xdata$x:000064CF                 db    0
.xdata$x:000064D0                 db    0
.xdata$x:000064D1                 db    0
.xdata$x:000064D2                 db    0
.xdata$x:000064D3                 db    0
.xdata$x:000064D4                 db    0
.xdata$x:000064D5                 db    0
.xdata$x:000064D6                 db    0
.xdata$x:000064D7                 db    0
.xdata$x:000064D8                 db    0
.xdata$x:000064D9                 db    0
.xdata$x:000064DA                 db    0
.xdata$x:000064DB                 db    0
.xdata$x:000064DB _xdata$x        ends
.xdata$x:000064DB
.xdata$x:000064DC ; ===========================================================================
.xdata$x:000064DC
.xdata$x:000064DC ; Segment type: Pure data
.xdata$x:000064DC ; Segment permissions: Read
.xdata$x:000064DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000064DC                 assume cs:_xdata$x
.xdata$x:000064DC                 ;org 64DCh
.xdata$x:000064DC ; COMDAT (pick associative to section at 5BF4)
.xdata$x:000064DC __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000064DC                                         ; DATA XREF: .xdata$x:000064ECo
.xdata$x:000064DD                 db 0FFh
.xdata$x:000064DE                 db 0FFh
.xdata$x:000064DF                 db 0FFh
.xdata$x:000064E0                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000064E4 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000064E4                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000064E5                 db    5
.xdata$x:000064E6                 db  93h ; ô
.xdata$x:000064E7                 db  19h
.xdata$x:000064E8                 db    1
.xdata$x:000064E9                 db    0
.xdata$x:000064EA                 db    0
.xdata$x:000064EB                 db    0
.xdata$x:000064EC                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000064F0                 db    0
.xdata$x:000064F1                 db    0
.xdata$x:000064F2                 db    0
.xdata$x:000064F3                 db    0
.xdata$x:000064F4                 db    0
.xdata$x:000064F5                 db    0
.xdata$x:000064F6                 db    0
.xdata$x:000064F7                 db    0
.xdata$x:000064F8                 db    0
.xdata$x:000064F9                 db    0
.xdata$x:000064FA                 db    0
.xdata$x:000064FB                 db    0
.xdata$x:000064FC                 db    0
.xdata$x:000064FD                 db    0
.xdata$x:000064FE                 db    0
.xdata$x:000064FF                 db    0
.xdata$x:00006500                 db    0
.xdata$x:00006501                 db    0
.xdata$x:00006502                 db    0
.xdata$x:00006503                 db    0
.xdata$x:00006504                 db    0
.xdata$x:00006505                 db    0
.xdata$x:00006506                 db    0
.xdata$x:00006507                 db    0
.xdata$x:00006507 _xdata$x        ends
.xdata$x:00006507
.xdata$x:00006508 ; ===========================================================================
.xdata$x:00006508
.xdata$x:00006508 ; Segment type: Pure data
.xdata$x:00006508 ; Segment permissions: Read
.xdata$x:00006508 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006508                 assume cs:_xdata$x
.xdata$x:00006508                 ;org 6508h
.xdata$x:00006508 ; COMDAT (pick associative to section at 3A1C)
.xdata$x:00006508 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00006508                                         ; DATA XREF: .xdata$x:00006518o
.xdata$x:00006509                 db 0FFh
.xdata$x:0000650A                 db 0FFh
.xdata$x:0000650B                 db 0FFh
.xdata$x:0000650C                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00006510 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00006510                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00006511                 db    5
.xdata$x:00006512                 db  93h ; ô
.xdata$x:00006513                 db  19h
.xdata$x:00006514                 db    1
.xdata$x:00006515                 db    0
.xdata$x:00006516                 db    0
.xdata$x:00006517                 db    0
.xdata$x:00006518                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:0000651C                 db    0
.xdata$x:0000651D                 db    0
.xdata$x:0000651E                 db    0
.xdata$x:0000651F                 db    0
.xdata$x:00006520                 db    0
.xdata$x:00006521                 db    0
.xdata$x:00006522                 db    0
.xdata$x:00006523                 db    0
.xdata$x:00006524                 db    0
.xdata$x:00006525                 db    0
.xdata$x:00006526                 db    0
.xdata$x:00006527                 db    0
.xdata$x:00006528                 db    0
.xdata$x:00006529                 db    0
.xdata$x:0000652A                 db    0
.xdata$x:0000652B                 db    0
.xdata$x:0000652C                 db    0
.xdata$x:0000652D                 db    0
.xdata$x:0000652E                 db    0
.xdata$x:0000652F                 db    0
.xdata$x:00006530                 db    0
.xdata$x:00006531                 db    0
.xdata$x:00006532                 db    0
.xdata$x:00006533                 db    0
.xdata$x:00006533 _xdata$x        ends
.xdata$x:00006533
.xdata$x:00006534 ; ===========================================================================
.xdata$x:00006534
.xdata$x:00006534 ; Segment type: Pure data
.xdata$x:00006534 ; Segment permissions: Read
.xdata$x:00006534 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006534                 assume cs:_xdata$x
.xdata$x:00006534                 ;org 6534h
.xdata$x:00006534 ; COMDAT (pick associative to section at 3454)
.xdata$x:00006534 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00006534                                         ; DATA XREF: .xdata$x:00006544o
.xdata$x:00006535                 db 0FFh
.xdata$x:00006536                 db 0FFh
.xdata$x:00006537                 db 0FFh
.xdata$x:00006538                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:0000653C __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000653C                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:0000653D                 db    5
.xdata$x:0000653E                 db  93h ; ô
.xdata$x:0000653F                 db  19h
.xdata$x:00006540                 db    1
.xdata$x:00006541                 db    0
.xdata$x:00006542                 db    0
.xdata$x:00006543                 db    0
.xdata$x:00006544                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00006548                 align 20h
.xdata$x:00006548 _xdata$x        ends
.xdata$x:00006548
.xdata$x:00006560 ; ===========================================================================
.xdata$x:00006560
.xdata$x:00006560 ; Segment type: Pure data
.xdata$x:00006560 ; Segment permissions: Read
.xdata$x:00006560 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006560                 assume cs:_xdata$x
.xdata$x:00006560                 ;org 6560h
.xdata$x:00006560 ; COMDAT (pick associative to section at 5CAC)
.xdata$x:00006560 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00006560                                         ; DATA XREF: .xdata$x:00006570o
.xdata$x:00006561                 db 0FFh
.xdata$x:00006562                 db 0FFh
.xdata$x:00006563                 db 0FFh
.xdata$x:00006564                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00006568 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00006568                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00006569                 db    5
.xdata$x:0000656A                 db  93h ; ô
.xdata$x:0000656B                 db  19h
.xdata$x:0000656C                 db    1
.xdata$x:0000656D                 db    0
.xdata$x:0000656E                 db    0
.xdata$x:0000656F                 db    0
.xdata$x:00006570                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00006574                 db    0
.xdata$x:00006575                 db    0
.xdata$x:00006576                 db    0
.xdata$x:00006577                 db    0
.xdata$x:00006578                 db    0
.xdata$x:00006579                 db    0
.xdata$x:0000657A                 db    0
.xdata$x:0000657B                 db    0
.xdata$x:0000657C                 db    0
.xdata$x:0000657D                 db    0
.xdata$x:0000657E                 db    0
.xdata$x:0000657F                 db    0
.xdata$x:00006580                 db    0
.xdata$x:00006581                 db    0
.xdata$x:00006582                 db    0
.xdata$x:00006583                 db    0
.xdata$x:00006584                 db    0
.xdata$x:00006585                 db    0
.xdata$x:00006586                 db    0
.xdata$x:00006587                 db    0
.xdata$x:00006588                 db    0
.xdata$x:00006589                 db    0
.xdata$x:0000658A                 db    0
.xdata$x:0000658B                 db    0
.xdata$x:0000658B _xdata$x        ends
.xdata$x:0000658B
.xdata$x:0000658C ; ===========================================================================
.xdata$x:0000658C
.xdata$x:0000658C ; Segment type: Pure data
.xdata$x:0000658C ; Segment permissions: Read
.xdata$x:0000658C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000658C                 assume cs:_xdata$x
.xdata$x:0000658C                 ;org 658Ch
.xdata$x:0000658C ; COMDAT (pick associative to section at 3A8C)
.xdata$x:0000658C __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000658C                                         ; DATA XREF: .xdata$x:0000659Co
.xdata$x:0000658D                 db 0FFh
.xdata$x:0000658E                 db 0FFh
.xdata$x:0000658F                 db 0FFh
.xdata$x:00006590                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00006594 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00006594                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00006595                 db    5
.xdata$x:00006596                 db  93h ; ô
.xdata$x:00006597                 db  19h
.xdata$x:00006598                 db    1
.xdata$x:00006599                 db    0
.xdata$x:0000659A                 db    0
.xdata$x:0000659B                 db    0
.xdata$x:0000659C                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:000065A0                 db    0
.xdata$x:000065A1                 db    0
.xdata$x:000065A2                 db    0
.xdata$x:000065A3                 db    0
.xdata$x:000065A4                 db    0
.xdata$x:000065A5                 db    0
.xdata$x:000065A6                 db    0
.xdata$x:000065A7                 db    0
.xdata$x:000065A8                 db    0
.xdata$x:000065A9                 db    0
.xdata$x:000065AA                 db    0
.xdata$x:000065AB                 db    0
.xdata$x:000065AC                 db    0
.xdata$x:000065AD                 db    0
.xdata$x:000065AE                 db    0
.xdata$x:000065AF                 db    0
.xdata$x:000065B0                 db    0
.xdata$x:000065B1                 db    0
.xdata$x:000065B2                 db    0
.xdata$x:000065B3                 db    0
.xdata$x:000065B4                 db    0
.xdata$x:000065B5                 db    0
.xdata$x:000065B6                 db    0
.xdata$x:000065B7                 db    0
.xdata$x:000065B7 _xdata$x        ends
.xdata$x:000065B7
.xdata$x:000065B8 ; ===========================================================================
.xdata$x:000065B8
.xdata$x:000065B8 ; Segment type: Pure data
.xdata$x:000065B8 ; Segment permissions: Read
.xdata$x:000065B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000065B8                 assume cs:_xdata$x
.xdata$x:000065B8                 ;org 65B8h
.xdata$x:000065B8 ; COMDAT (pick associative to section at 3524)
.xdata$x:000065B8 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000065B8                                         ; DATA XREF: .xdata$x:000065C8o
.xdata$x:000065B9                 db 0FFh
.xdata$x:000065BA                 db 0FFh
.xdata$x:000065BB                 db 0FFh
.xdata$x:000065BC                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:000065C0 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000065C0                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:000065C1                 db    5
.xdata$x:000065C2                 db  93h ; ô
.xdata$x:000065C3                 db  19h
.xdata$x:000065C4                 db    1
.xdata$x:000065C5                 db    0
.xdata$x:000065C6                 db    0
.xdata$x:000065C7                 db    0
.xdata$x:000065C8                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:000065CC                 db    0
.xdata$x:000065CD                 db    0
.xdata$x:000065CE                 db    0
.xdata$x:000065CF                 db    0
.xdata$x:000065D0                 db    0
.xdata$x:000065D1                 db    0
.xdata$x:000065D2                 db    0
.xdata$x:000065D3                 db    0
.xdata$x:000065D4                 db    0
.xdata$x:000065D5                 db    0
.xdata$x:000065D6                 db    0
.xdata$x:000065D7                 db    0
.xdata$x:000065D8                 db    0
.xdata$x:000065D9                 db    0
.xdata$x:000065DA                 db    0
.xdata$x:000065DB                 db    0
.xdata$x:000065DC                 db    0
.xdata$x:000065DD                 db    0
.xdata$x:000065DE                 db    0
.xdata$x:000065DF                 db    0
.xdata$x:000065E0                 db    0
.xdata$x:000065E1                 db    0
.xdata$x:000065E2                 db    0
.xdata$x:000065E3                 db    0
.xdata$x:000065E3 _xdata$x        ends
.xdata$x:000065E3
.xdata$x:000065E4 ; ===========================================================================
.xdata$x:000065E4
.xdata$x:000065E4 ; Segment type: Pure data
.xdata$x:000065E4 ; Segment permissions: Read
.xdata$x:000065E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000065E4                 assume cs:_xdata$x
.xdata$x:000065E4                 ;org 65E4h
.xdata$x:000065E4 ; COMDAT (pick associative to section at 5D70)
.xdata$x:000065E4 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000065E4                                         ; DATA XREF: .xdata$x:000065F4o
.xdata$x:000065E5                 db 0FFh
.xdata$x:000065E6                 db 0FFh
.xdata$x:000065E7                 db 0FFh
.xdata$x:000065E8                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000065EC __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000065EC                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000065ED                 db    5
.xdata$x:000065EE                 db  93h ; ô
.xdata$x:000065EF                 db  19h
.xdata$x:000065F0                 db    1
.xdata$x:000065F1                 db    0
.xdata$x:000065F2                 db    0
.xdata$x:000065F3                 db    0
.xdata$x:000065F4                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000065F8                 db    0
.xdata$x:000065F9                 db    0
.xdata$x:000065FA                 db    0
.xdata$x:000065FB                 db    0
.xdata$x:000065FC                 db    0
.xdata$x:000065FD                 db    0
.xdata$x:000065FE                 db    0
.xdata$x:000065FF                 db    0
.xdata$x:00006600                 db    0
.xdata$x:00006601                 db    0
.xdata$x:00006602                 db    0
.xdata$x:00006603                 db    0
.xdata$x:00006604                 db    0
.xdata$x:00006605                 db    0
.xdata$x:00006606                 db    0
.xdata$x:00006607                 db    0
.xdata$x:00006608                 db    0
.xdata$x:00006609                 db    0
.xdata$x:0000660A                 db    0
.xdata$x:0000660B                 db    0
.xdata$x:0000660C                 db    0
.xdata$x:0000660D                 db    0
.xdata$x:0000660E                 db    0
.xdata$x:0000660F                 db    0
.xdata$x:0000660F _xdata$x        ends
.xdata$x:0000660F
.xdata$x:00006610 ; ===========================================================================
.xdata$x:00006610
.xdata$x:00006610 ; Segment type: Pure data
.xdata$x:00006610 ; Segment permissions: Read
.xdata$x:00006610 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006610                 assume cs:_xdata$x
.xdata$x:00006610                 ;org 6610h
.xdata$x:00006610 ; COMDAT (pick associative to section at 3B80)
.xdata$x:00006610 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00006610                                         ; DATA XREF: .xdata$x:00006620o
.xdata$x:00006611                 db 0FFh
.xdata$x:00006612                 db 0FFh
.xdata$x:00006613                 db 0FFh
.xdata$x:00006614                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00006618 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00006618                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00006619                 db    5
.xdata$x:0000661A                 db  93h ; ô
.xdata$x:0000661B                 db  19h
.xdata$x:0000661C                 db    1
.xdata$x:0000661D                 db    0
.xdata$x:0000661E                 db    0
.xdata$x:0000661F                 db    0
.xdata$x:00006620                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00006624                 db    0
.xdata$x:00006625                 db    0
.xdata$x:00006626                 db    0
.xdata$x:00006627                 db    0
.xdata$x:00006628                 db    0
.xdata$x:00006629                 db    0
.xdata$x:0000662A                 db    0
.xdata$x:0000662B                 db    0
.xdata$x:0000662C                 db    0
.xdata$x:0000662D                 db    0
.xdata$x:0000662E                 db    0
.xdata$x:0000662F                 db    0
.xdata$x:00006630                 db    0
.xdata$x:00006631                 db    0
.xdata$x:00006632                 db    0
.xdata$x:00006633                 db    0
.xdata$x:00006634                 db    0
.xdata$x:00006635                 db    0
.xdata$x:00006636                 db    0
.xdata$x:00006637                 db    0
.xdata$x:00006638                 db    0
.xdata$x:00006639                 db    0
.xdata$x:0000663A                 db    0
.xdata$x:0000663B                 db    0
.xdata$x:0000663B _xdata$x        ends
.xdata$x:0000663B
.xdata$x:0000663C ; ===========================================================================
.xdata$x:0000663C
.xdata$x:0000663C ; Segment type: Pure data
.xdata$x:0000663C ; Segment permissions: Read
.xdata$x:0000663C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000663C                 assume cs:_xdata$x
.xdata$x:0000663C                 ;org 663Ch
.xdata$x:0000663C __unwindtable$?findCloseTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z db 0FFh
.xdata$x:0000663C                                         ; DATA XREF: .xdata$x:000066B0o
.xdata$x:0000663D                 db 0FFh
.xdata$x:0000663E                 db 0FFh
.xdata$x:0000663F                 db 0FFh
.xdata$x:00006640                 dd offset __unwindfunclet$?findCloseTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z$0
.xdata$x:00006644 __unwindtable$?findOpenTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z db 0FFh
.xdata$x:00006644                                         ; DATA XREF: .xdata$x:000066D4o
.xdata$x:00006645                 db 0FFh
.xdata$x:00006646                 db 0FFh
.xdata$x:00006647                 db 0FFh
.xdata$x:00006648                 dd offset __unwindfunclet$?findOpenTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z$0
.xdata$x:0000664C __unwindtable$?getAttributesPos@XmlMatchedTagsHighlighter@@AAE?AV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@HH@Z db 0FFh
.xdata$x:0000664C                                         ; DATA XREF: .xdata$x:0000668Co
.xdata$x:0000664D                 db 0FFh
.xdata$x:0000664E                 db 0FFh
.xdata$x:0000664F                 db 0FFh
.xdata$x:00006650                 dd offset __unwindfunclet$?getAttributesPos@XmlMatchedTagsHighlighter@@AAE?AV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@HH@Z$1
.xdata$x:00006654                 align 8
.xdata$x:00006658                 dd offset __unwindfunclet$?getAttributesPos@XmlMatchedTagsHighlighter@@AAE?AV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@HH@Z$0
.xdata$x:0000665C __unwindtable$?getXmlMatchedTagsPos@XmlMatchedTagsHighlighter@@AAE_NAAUXmlMatchedTagsPos@1@@Z db 0FFh
.xdata$x:0000665C                                         ; DATA XREF: .xdata$x:000066F8o
.xdata$x:0000665D                 db 0FFh
.xdata$x:0000665E                 db 0FFh
.xdata$x:0000665F                 db 0FFh
.xdata$x:00006660                 dd offset __unwindfunclet$?getXmlMatchedTagsPos@XmlMatchedTagsHighlighter@@AAE_NAAUXmlMatchedTagsPos@1@@Z$0
.xdata$x:00006664                 db 0FFh
.xdata$x:00006665                 db 0FFh
.xdata$x:00006666                 db 0FFh
.xdata$x:00006667                 db 0FFh
.xdata$x:00006668                 dd offset __unwindfunclet$?getXmlMatchedTagsPos@XmlMatchedTagsHighlighter@@AAE_NAAUXmlMatchedTagsPos@1@@Z$1
.xdata$x:0000666C __unwindtable$?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z db 0FFh
.xdata$x:0000666C                                         ; DATA XREF: .xdata$x:0000671Co
.xdata$x:0000666D                 db 0FFh
.xdata$x:0000666E                 db 0FFh
.xdata$x:0000666F                 db 0FFh
.xdata$x:00006670                 dd offset __unwindfunclet$?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z$0
.xdata$x:00006674                 align 8
.xdata$x:00006678                 dd offset __unwindfunclet$?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z$1
.xdata$x:0000667C                 db 0FFh
.xdata$x:0000667D                 db 0FFh
.xdata$x:0000667E                 db 0FFh
.xdata$x:0000667F                 db 0FFh
.xdata$x:00006680                 dd offset __unwindfunclet$?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z$2
.xdata$x:00006684 __ehfuncinfo$?getAttributesPos@XmlMatchedTagsHighlighter@@AAE?AV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@HH@Z db  22h ; "
.xdata$x:00006684                                         ; DATA XREF: __ehhandler$?getAttributesPos@XmlMatchedTagsHighlighter@@AAE?AV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@HH@Z+11o
.xdata$x:00006685                 db    5
.xdata$x:00006686                 db  93h ; ô
.xdata$x:00006687                 db  19h
.xdata$x:00006688                 db    2
.xdata$x:00006689                 db    0
.xdata$x:0000668A                 db    0
.xdata$x:0000668B                 db    0
.xdata$x:0000668C                 dd offset __unwindtable$?getAttributesPos@XmlMatchedTagsHighlighter@@AAE?AV?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@HH@Z
.xdata$x:00006690                 db    0
.xdata$x:00006691                 db    0
.xdata$x:00006692                 db    0
.xdata$x:00006693                 db    0
.xdata$x:00006694                 db    0
.xdata$x:00006695                 db    0
.xdata$x:00006696                 db    0
.xdata$x:00006697                 db    0
.xdata$x:00006698                 db    0
.xdata$x:00006699                 db    0
.xdata$x:0000669A                 db    0
.xdata$x:0000669B                 db    0
.xdata$x:0000669C                 db    0
.xdata$x:0000669D                 db    0
.xdata$x:0000669E                 db    0
.xdata$x:0000669F                 db    0
.xdata$x:000066A0                 db    0
.xdata$x:000066A1                 db    0
.xdata$x:000066A2                 db    0
.xdata$x:000066A3                 db    0
.xdata$x:000066A4                 db    0
.xdata$x:000066A5                 db    0
.xdata$x:000066A6                 db    0
.xdata$x:000066A7                 db    0
.xdata$x:000066A8 __ehfuncinfo$?findCloseTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z db  22h ; "
.xdata$x:000066A8                                         ; DATA XREF: __ehhandler$?findCloseTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z+1Bo
.xdata$x:000066A9                 db    5
.xdata$x:000066AA                 db  93h ; ô
.xdata$x:000066AB                 db  19h
.xdata$x:000066AC                 db    1
.xdata$x:000066AD                 db    0
.xdata$x:000066AE                 db    0
.xdata$x:000066AF                 db    0
.xdata$x:000066B0                 dd offset __unwindtable$?findCloseTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z
.xdata$x:000066B4                 db    0
.xdata$x:000066B5                 db    0
.xdata$x:000066B6                 db    0
.xdata$x:000066B7                 db    0
.xdata$x:000066B8                 db    0
.xdata$x:000066B9                 db    0
.xdata$x:000066BA                 db    0
.xdata$x:000066BB                 db    0
.xdata$x:000066BC                 db    0
.xdata$x:000066BD                 db    0
.xdata$x:000066BE                 db    0
.xdata$x:000066BF                 db    0
.xdata$x:000066C0                 db    0
.xdata$x:000066C1                 db    0
.xdata$x:000066C2                 db    0
.xdata$x:000066C3                 db    0
.xdata$x:000066C4                 db    0
.xdata$x:000066C5                 db    0
.xdata$x:000066C6                 db    0
.xdata$x:000066C7                 db    0
.xdata$x:000066C8                 db    0
.xdata$x:000066C9                 db    0
.xdata$x:000066CA                 db    0
.xdata$x:000066CB                 db    0
.xdata$x:000066CC __ehfuncinfo$?findOpenTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z db  22h ; "
.xdata$x:000066CC                                         ; DATA XREF: __ehhandler$?findOpenTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z+1Bo
.xdata$x:000066CD                 db    5
.xdata$x:000066CE                 db  93h ; ô
.xdata$x:000066CF                 db  19h
.xdata$x:000066D0                 db    1
.xdata$x:000066D1                 db    0
.xdata$x:000066D2                 db    0
.xdata$x:000066D3                 db    0
.xdata$x:000066D4                 dd offset __unwindtable$?findOpenTag@XmlMatchedTagsHighlighter@@AAE?AUFindResult@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z
.xdata$x:000066D8                 db    0
.xdata$x:000066D9                 db    0
.xdata$x:000066DA                 db    0
.xdata$x:000066DB                 db    0
.xdata$x:000066DC                 db    0
.xdata$x:000066DD                 db    0
.xdata$x:000066DE                 db    0
.xdata$x:000066DF                 db    0
.xdata$x:000066E0                 db    0
.xdata$x:000066E1                 db    0
.xdata$x:000066E2                 db    0
.xdata$x:000066E3                 db    0
.xdata$x:000066E4                 db    0
.xdata$x:000066E5                 db    0
.xdata$x:000066E6                 db    0
.xdata$x:000066E7                 db    0
.xdata$x:000066E8                 db    0
.xdata$x:000066E9                 db    0
.xdata$x:000066EA                 db    0
.xdata$x:000066EB                 db    0
.xdata$x:000066EC                 db    0
.xdata$x:000066ED                 db    0
.xdata$x:000066EE                 db    0
.xdata$x:000066EF                 db    0
.xdata$x:000066F0 __ehfuncinfo$?getXmlMatchedTagsPos@XmlMatchedTagsHighlighter@@AAE_NAAUXmlMatchedTagsPos@1@@Z db  22h ; "
.xdata$x:000066F0                                         ; DATA XREF: __ehhandler$?getXmlMatchedTagsPos@XmlMatchedTagsHighlighter@@AAE_NAAUXmlMatchedTagsPos@1@@Z+1Eo
.xdata$x:000066F1                 db    5
.xdata$x:000066F2                 db  93h ; ô
.xdata$x:000066F3                 db  19h
.xdata$x:000066F4                 db    2
.xdata$x:000066F5                 db    0
.xdata$x:000066F6                 db    0
.xdata$x:000066F7                 db    0
.xdata$x:000066F8                 dd offset __unwindtable$?getXmlMatchedTagsPos@XmlMatchedTagsHighlighter@@AAE_NAAUXmlMatchedTagsPos@1@@Z
.xdata$x:000066FC                 db    0
.xdata$x:000066FD                 db    0
.xdata$x:000066FE                 db    0
.xdata$x:000066FF                 db    0
.xdata$x:00006700                 db    0
.xdata$x:00006701                 db    0
.xdata$x:00006702                 db    0
.xdata$x:00006703                 db    0
.xdata$x:00006704                 db    0
.xdata$x:00006705                 db    0
.xdata$x:00006706                 db    0
.xdata$x:00006707                 db    0
.xdata$x:00006708                 db    0
.xdata$x:00006709                 db    0
.xdata$x:0000670A                 db    0
.xdata$x:0000670B                 db    0
.xdata$x:0000670C                 db    0
.xdata$x:0000670D                 db    0
.xdata$x:0000670E                 db    0
.xdata$x:0000670F                 db    0
.xdata$x:00006710                 db    0
.xdata$x:00006711                 db    0
.xdata$x:00006712                 db    0
.xdata$x:00006713                 db    0
.xdata$x:00006714 __ehfuncinfo$?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z db  22h ; "
.xdata$x:00006714                                         ; DATA XREF: __ehhandler$?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z+1Eo
.xdata$x:00006715                 db    5
.xdata$x:00006716                 db  93h ; ô
.xdata$x:00006717                 db  19h
.xdata$x:00006718                 db    3
.xdata$x:00006719                 db    0
.xdata$x:0000671A                 db    0
.xdata$x:0000671B                 db    0
.xdata$x:0000671C                 dd offset __unwindtable$?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z
.xdata$x:00006720                 db    0
.xdata$x:00006721                 db    0
.xdata$x:00006722                 db    0
.xdata$x:00006723                 db    0
.xdata$x:00006724                 db    0
.xdata$x:00006725                 db    0
.xdata$x:00006726                 db    0
.xdata$x:00006727                 db    0
.xdata$x:00006728                 db    0
.xdata$x:00006729                 db    0
.xdata$x:0000672A                 db    0
.xdata$x:0000672B                 db    0
.xdata$x:0000672C                 db    0
.xdata$x:0000672D                 db    0
.xdata$x:0000672E                 db    0
.xdata$x:0000672F                 db    0
.xdata$x:00006730                 db    0
.xdata$x:00006731                 db    0
.xdata$x:00006732                 db    0
.xdata$x:00006733                 db    0
.xdata$x:00006734                 db    0
.xdata$x:00006735                 db    0
.xdata$x:00006736                 db    0
.xdata$x:00006737                 db    0
.xdata$x:00006737 _xdata$x        ends
.xdata$x:00006737
.xdata$x:00006738 ; ===========================================================================
.xdata$x:00006738
.xdata$x:00006738 ; Segment type: Pure data
.xdata$x:00006738 ; Segment permissions: Read
.xdata$x:00006738 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006738                 assume cs:_xdata$x
.xdata$x:00006738                 ;org 6738h
.xdata$x:00006738 ; COMDAT (pick associative to section at 303C)
.xdata$x:00006738 __unwindtable$??0?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00006738                                         ; DATA XREF: .xdata$x:00006748o
.xdata$x:00006739                 db 0FFh
.xdata$x:0000673A                 db 0FFh
.xdata$x:0000673B                 db 0FFh
.xdata$x:0000673C                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00006740 __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00006740                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00006741                 db    5
.xdata$x:00006742                 db  93h ; ô
.xdata$x:00006743                 db  19h
.xdata$x:00006744                 db    1
.xdata$x:00006745                 db    0
.xdata$x:00006746                 db    0
.xdata$x:00006747                 db    0
.xdata$x:00006748                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ
.xdata$x:0000674C                 db    0
.xdata$x:0000674D                 db    0
.xdata$x:0000674E                 db    0
.xdata$x:0000674F                 db    0
.xdata$x:00006750                 db    0
.xdata$x:00006751                 db    0
.xdata$x:00006752                 db    0
.xdata$x:00006753                 db    0
.xdata$x:00006754                 db    0
.xdata$x:00006755                 db    0
.xdata$x:00006756                 db    0
.xdata$x:00006757                 db    0
.xdata$x:00006758                 db    0
.xdata$x:00006759                 db    0
.xdata$x:0000675A                 db    0
.xdata$x:0000675B                 db    0
.xdata$x:0000675C                 db    0
.xdata$x:0000675D                 db    0
.xdata$x:0000675E                 db    0
.xdata$x:0000675F                 db    0
.xdata$x:00006760                 db    0
.xdata$x:00006761                 db    0
.xdata$x:00006762                 db    0
.xdata$x:00006763                 db    0
.xdata$x:00006763 _xdata$x        ends
.xdata$x:00006763
.xdata$x:00006764 ; ===========================================================================
.xdata$x:00006764
.xdata$x:00006764 ; Segment type: Pure data
.xdata$x:00006764 ; Segment permissions: Read
.xdata$x:00006764 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006764                 assume cs:_xdata$x
.xdata$x:00006764                 ;org 6764h
.xdata$x:00006764 ; COMDAT (pick associative to section at 38A4)
.xdata$x:00006764 __unwindtable$??1?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00006764                                         ; DATA XREF: .xdata$x:00006774o
.xdata$x:00006765                 db 0FFh
.xdata$x:00006766                 db 0FFh
.xdata$x:00006767                 db 0FFh
.xdata$x:00006768                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000676C __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000676C                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000676D                 db    5
.xdata$x:0000676E                 db  93h ; ô
.xdata$x:0000676F                 db  19h
.xdata$x:00006770                 db    1
.xdata$x:00006771                 db    0
.xdata$x:00006772                 db    0
.xdata$x:00006773                 db    0
.xdata$x:00006774                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@U?$pair@HH@std@@@std@@@std@@QAE@XZ
.xdata$x:00006778                 db    0
.xdata$x:00006779                 db    0
.xdata$x:0000677A                 db    0
.xdata$x:0000677B                 db    0
.xdata$x:0000677C                 db    0
.xdata$x:0000677D                 db    0
.xdata$x:0000677E                 db    0
.xdata$x:0000677F                 db    0
.xdata$x:00006780                 db    0
.xdata$x:00006781                 db    0
.xdata$x:00006782                 db    0
.xdata$x:00006783                 db    0
.xdata$x:00006784                 db    0
.xdata$x:00006785                 db    0
.xdata$x:00006786                 db    0
.xdata$x:00006787                 db    0
.xdata$x:00006788                 db    0
.xdata$x:00006789                 db    0
.xdata$x:0000678A                 db    0
.xdata$x:0000678B                 db    0
.xdata$x:0000678C                 db    0
.xdata$x:0000678D                 db    0
.xdata$x:0000678E                 db    0
.xdata$x:0000678F                 db    0
.xdata$x:0000678F _xdata$x        ends
.xdata$x:0000678F
.xdata$x:00006790 ; ===========================================================================
.xdata$x:00006790
.xdata$x:00006790 ; Segment type: Pure data
.xdata$x:00006790 ; Segment permissions: Read
.xdata$x:00006790 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006790                 assume cs:_xdata$x
.xdata$x:00006790                 ;org 6790h
.xdata$x:00006790 ; COMDAT (pick associative to section at 2FC0)
.xdata$x:00006790 __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@HH@std@@@1@@Z db 0FFh
.xdata$x:00006790                                         ; DATA XREF: .xdata$x:000067A0o
.xdata$x:00006791                 db 0FFh
.xdata$x:00006792                 db 0FFh
.xdata$x:00006793                 db 0FFh
.xdata$x:00006794                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@HH@std@@@1@@Z$0
.xdata$x:00006798 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@HH@std@@@1@@Z db  22h ; "
.xdata$x:00006798                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@HH@std@@@1@@Z+11o
.xdata$x:00006799                 db    5
.xdata$x:0000679A                 db  93h ; ô
.xdata$x:0000679B                 db  19h
.xdata$x:0000679C                 db    1
.xdata$x:0000679D                 db    0
.xdata$x:0000679E                 db    0
.xdata$x:0000679F                 db    0
.xdata$x:000067A0                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@HH@std@@@1@@Z
.xdata$x:000067A4                 db    0
.xdata$x:000067A5                 db    0
.xdata$x:000067A6                 db    0
.xdata$x:000067A7                 db    0
.xdata$x:000067A8                 db    0
.xdata$x:000067A9                 db    0
.xdata$x:000067AA                 db    0
.xdata$x:000067AB                 db    0
.xdata$x:000067AC                 db    0
.xdata$x:000067AD                 db    0
.xdata$x:000067AE                 db    0
.xdata$x:000067AF                 db    0
.xdata$x:000067B0                 db    0
.xdata$x:000067B1                 db    0
.xdata$x:000067B2                 db    0
.xdata$x:000067B3                 db    0
.xdata$x:000067B4                 db    0
.xdata$x:000067B5                 db    0
.xdata$x:000067B6                 db    0
.xdata$x:000067B7                 db    0
.xdata$x:000067B8                 db    0
.xdata$x:000067B9                 db    0
.xdata$x:000067BA                 db    0
.xdata$x:000067BB                 db    0
.xdata$x:000067BB _xdata$x        ends
.xdata$x:000067BB
.xdata$x:000067BC ; ===========================================================================
.xdata$x:000067BC
.xdata$x:000067BC ; Segment type: Pure data
.xdata$x:000067BC ; Segment permissions: Read
.xdata$x:000067BC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000067BC                 assume cs:_xdata$x
.xdata$x:000067BC                 ;org 67BCh
.xdata$x:000067BC ; COMDAT (pick associative to section at 382C)
.xdata$x:000067BC __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000067BC                                         ; DATA XREF: .xdata$x:000067CCo
.xdata$x:000067BD                 db 0FFh
.xdata$x:000067BE                 db 0FFh
.xdata$x:000067BF                 db 0FFh
.xdata$x:000067C0                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@XZ$0
.xdata$x:000067C4 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000067C4                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@XZ+11o
.xdata$x:000067C5                 db    5
.xdata$x:000067C6                 db  93h ; ô
.xdata$x:000067C7                 db  19h
.xdata$x:000067C8                 db    1
.xdata$x:000067C9                 db    0
.xdata$x:000067CA                 db    0
.xdata$x:000067CB                 db    0
.xdata$x:000067CC                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@@std@@QAE@XZ
.xdata$x:000067D0                 db    0
.xdata$x:000067D1                 db    0
.xdata$x:000067D2                 db    0
.xdata$x:000067D3                 db    0
.xdata$x:000067D4                 db    0
.xdata$x:000067D5                 db    0
.xdata$x:000067D6                 db    0
.xdata$x:000067D7                 db    0
.xdata$x:000067D8                 db    0
.xdata$x:000067D9                 db    0
.xdata$x:000067DA                 db    0
.xdata$x:000067DB                 db    0
.xdata$x:000067DC                 db    0
.xdata$x:000067DD                 db    0
.xdata$x:000067DE                 db    0
.xdata$x:000067DF                 db    0
.xdata$x:000067E0                 db    0
.xdata$x:000067E1                 db    0
.xdata$x:000067E2                 db    0
.xdata$x:000067E3                 db    0
.xdata$x:000067E4                 db    0
.xdata$x:000067E5                 db    0
.xdata$x:000067E6                 db    0
.xdata$x:000067E7                 db    0
.xdata$x:000067E7 _xdata$x        ends
.xdata$x:000067E7
.xdata$x:000067E8 ; ===========================================================================
.xdata$x:000067E8
.xdata$x:000067E8 ; Segment type: Pure data
.xdata$x:000067E8 ; Segment permissions: Read
.xdata$x:000067E8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000067E8                 assume cs:_xdata$x
.xdata$x:000067E8                 ;org 67E8h
.xdata$x:000067E8 ; COMDAT (pick associative to section at 330C)
.xdata$x:000067E8 __unwindtable$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ db 0FFh
.xdata$x:000067E8                                         ; DATA XREF: .xdata$x:000067F8o
.xdata$x:000067E9                 db 0FFh
.xdata$x:000067EA                 db 0FFh
.xdata$x:000067EB                 db 0FFh
.xdata$x:000067EC                 dd offset __unwindfunclet$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ$0
.xdata$x:000067F0 __ehfuncinfo$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ db  22h ; "
.xdata$x:000067F0                                         ; DATA XREF: __ehhandler$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ+11o
.xdata$x:000067F1                 db    5
.xdata$x:000067F2                 db  93h ; ô
.xdata$x:000067F3                 db  19h
.xdata$x:000067F4                 db    1
.xdata$x:000067F5                 db    0
.xdata$x:000067F6                 db    0
.xdata$x:000067F7                 db    0
.xdata$x:000067F8                 dd offset __unwindtable$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ
.xdata$x:000067FC                 db    0
.xdata$x:000067FD                 db    0
.xdata$x:000067FE                 db    0
.xdata$x:000067FF                 db    0
.xdata$x:00006800                 db    0
.xdata$x:00006801                 db    0
.xdata$x:00006802                 db    0
.xdata$x:00006803                 db    0
.xdata$x:00006804                 db    0
.xdata$x:00006805                 db    0
.xdata$x:00006806                 db    0
.xdata$x:00006807                 db    0
.xdata$x:00006808                 db    0
.xdata$x:00006809                 db    0
.xdata$x:0000680A                 db    0
.xdata$x:0000680B                 db    0
.xdata$x:0000680C                 db    0
.xdata$x:0000680D                 db    0
.xdata$x:0000680E                 db    0
.xdata$x:0000680F                 db    0
.xdata$x:00006810                 db    0
.xdata$x:00006811                 db    0
.xdata$x:00006812                 db    0
.xdata$x:00006813                 db    0
.xdata$x:00006813 _xdata$x        ends
.xdata$x:00006813
.xdata$x:00006814 ; ===========================================================================
.xdata$x:00006814
.xdata$x:00006814 ; Segment type: Pure data
.xdata$x:00006814 ; Segment permissions: Read
.xdata$x:00006814 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006814                 assume cs:_xdata$x
.xdata$x:00006814                 ;org 6814h
.xdata$x:00006814 ; COMDAT (pick associative to section at 3268)
.xdata$x:00006814 __unwindtable$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@$$QAV01@@Z db 0FFh
.xdata$x:00006814                                         ; DATA XREF: .xdata$x:00006824o
.xdata$x:00006815                 db 0FFh
.xdata$x:00006816                 db 0FFh
.xdata$x:00006817                 db 0FFh
.xdata$x:00006818                 dd offset __unwindfunclet$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@$$QAV01@@Z$0
.xdata$x:0000681C __ehfuncinfo$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@$$QAV01@@Z db  22h ; "
.xdata$x:0000681C                                         ; DATA XREF: __ehhandler$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@$$QAV01@@Z+11o
.xdata$x:0000681D                 db    5
.xdata$x:0000681E                 db  93h ; ô
.xdata$x:0000681F                 db  19h
.xdata$x:00006820                 db    1
.xdata$x:00006821                 db    0
.xdata$x:00006822                 db    0
.xdata$x:00006823                 db    0
.xdata$x:00006824                 dd offset __unwindtable$??0?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@$$QAV01@@Z
.xdata$x:00006828                 align 20h
.xdata$x:00006828 _xdata$x        ends
.xdata$x:00006828
.xdata$x:00006840 ; ===========================================================================
.xdata$x:00006840
.xdata$x:00006840 ; Segment type: Pure data
.xdata$x:00006840 ; Segment permissions: Read
.xdata$x:00006840 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006840                 assume cs:_xdata$x
.xdata$x:00006840                 ;org 6840h
.xdata$x:00006840 ; COMDAT (pick associative to section at 3990)
.xdata$x:00006840 __unwindtable$??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ db 0FFh
.xdata$x:00006840                                         ; DATA XREF: .xdata$x:00006850o
.xdata$x:00006841                 db 0FFh
.xdata$x:00006842                 db 0FFh
.xdata$x:00006843                 db 0FFh
.xdata$x:00006844                 dd offset __unwindfunclet$??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ$0
.xdata$x:00006848 __ehfuncinfo$??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00006848                                         ; DATA XREF: __ehhandler$??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ+11o
.xdata$x:00006849                 db    5
.xdata$x:0000684A                 db  93h ; ô
.xdata$x:0000684B                 db  19h
.xdata$x:0000684C                 db    1
.xdata$x:0000684D                 db    0
.xdata$x:0000684E                 db    0
.xdata$x:0000684F                 db    0
.xdata$x:00006850                 dd offset __unwindtable$??1?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@QAE@XZ
.xdata$x:00006854                 db    0
.xdata$x:00006855                 db    0
.xdata$x:00006856                 db    0
.xdata$x:00006857                 db    0
.xdata$x:00006858                 db    0
.xdata$x:00006859                 db    0
.xdata$x:0000685A                 db    0
.xdata$x:0000685B                 db    0
.xdata$x:0000685C                 db    0
.xdata$x:0000685D                 db    0
.xdata$x:0000685E                 db    0
.xdata$x:0000685F                 db    0
.xdata$x:00006860                 db    0
.xdata$x:00006861                 db    0
.xdata$x:00006862                 db    0
.xdata$x:00006863                 db    0
.xdata$x:00006864                 db    0
.xdata$x:00006865                 db    0
.xdata$x:00006866                 db    0
.xdata$x:00006867                 db    0
.xdata$x:00006868                 db    0
.xdata$x:00006869                 db    0
.xdata$x:0000686A                 db    0
.xdata$x:0000686B                 db    0
.xdata$x:0000686B _xdata$x        ends
.xdata$x:0000686B
.xdata$x:0000686C ; ===========================================================================
.xdata$x:0000686C
.xdata$x:0000686C ; Segment type: Pure data
.xdata$x:0000686C ; Segment permissions: Read
.xdata$x:0000686C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000686C                 assume cs:_xdata$x
.xdata$x:0000686C                 ;org 686Ch
.xdata$x:0000686C ; COMDAT (pick associative to section at 4C44)
.xdata$x:0000686C __catchsym$?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z$2 db    0
.xdata$x:0000686C                                         ; DATA XREF: .xdata$x:0000689Co
.xdata$x:0000686D                 db    0
.xdata$x:0000686E                 db    0
.xdata$x:0000686F                 db    0
.xdata$x:00006870                 db    0
.xdata$x:00006871                 db    0
.xdata$x:00006872                 db    0
.xdata$x:00006873                 db    0
.xdata$x:00006874                 db    0
.xdata$x:00006875                 db    0
.xdata$x:00006876                 db    0
.xdata$x:00006877                 db    0
.xdata$x:00006878                 dd offset __catch$?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z$0
.xdata$x:0000687C __unwindtable$?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z db 0FFh
.xdata$x:0000687C                                         ; DATA XREF: .xdata$x:000068A8o
.xdata$x:0000687D                 db 0FFh
.xdata$x:0000687E                 db 0FFh
.xdata$x:0000687F                 db 0FFh
.xdata$x:00006880                 db    0
.xdata$x:00006881                 db    0
.xdata$x:00006882                 db    0
.xdata$x:00006883                 db    0
.xdata$x:00006884                 db 0FFh
.xdata$x:00006885                 db 0FFh
.xdata$x:00006886                 db 0FFh
.xdata$x:00006887                 db 0FFh
.xdata$x:00006888                 db    0
.xdata$x:00006889                 db    0
.xdata$x:0000688A                 db    0
.xdata$x:0000688B                 db    0
.xdata$x:0000688C __tryblocktable$?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z db    0
.xdata$x:0000688C                                         ; DATA XREF: .xdata$x:000068B0o
.xdata$x:0000688D                 db    0
.xdata$x:0000688E                 db    0
.xdata$x:0000688F                 db    0
.xdata$x:00006890                 db    0
.xdata$x:00006891                 db    0
.xdata$x:00006892                 db    0
.xdata$x:00006893                 db    0
.xdata$x:00006894                 db    1
.xdata$x:00006895                 db    0
.xdata$x:00006896                 db    0
.xdata$x:00006897                 db    0
.xdata$x:00006898                 db    1
.xdata$x:00006899                 db    0
.xdata$x:0000689A                 db    0
.xdata$x:0000689B                 db    0
.xdata$x:0000689C                 dd offset __catchsym$?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z$2
.xdata$x:000068A0 __ehfuncinfo$?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z db  22h ; "
.xdata$x:000068A0                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z+11o
.xdata$x:000068A1                 db    5
.xdata$x:000068A2                 db  93h ; ô
.xdata$x:000068A3                 db  19h
.xdata$x:000068A4                 db    2
.xdata$x:000068A5                 db    0
.xdata$x:000068A6                 db    0
.xdata$x:000068A7                 db    0
.xdata$x:000068A8                 dd offset __unwindtable$?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z
.xdata$x:000068AC                 db    1
.xdata$x:000068AD                 db    0
.xdata$x:000068AE                 db    0
.xdata$x:000068AF                 db    0
.xdata$x:000068B0                 dd offset __tryblocktable$?_Reallocate@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IAEXI@Z
.xdata$x:000068B4                 db    0
.xdata$x:000068B5                 db    0
.xdata$x:000068B6                 db    0
.xdata$x:000068B7                 db    0
.xdata$x:000068B8                 db    0
.xdata$x:000068B9                 db    0
.xdata$x:000068BA                 db    0
.xdata$x:000068BB                 db    0
.xdata$x:000068BC                 db    0
.xdata$x:000068BD                 db    0
.xdata$x:000068BE                 db    0
.xdata$x:000068BF                 db    0
.xdata$x:000068C0                 db    0
.xdata$x:000068C1                 db    0
.xdata$x:000068C2                 db    0
.xdata$x:000068C3                 db    0
.xdata$x:000068C3 _xdata$x        ends
.xdata$x:000068C3
.xdata$x:000068C4 ; ===========================================================================
.xdata$x:000068C4
.xdata$x:000068C4 ; Segment type: Pure data
.xdata$x:000068C4 ; Segment permissions: Read
.xdata$x:000068C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000068C4                 assume cs:_xdata$x
.xdata$x:000068C4                 ;org 68C4h
.xdata$x:000068C4 ; COMDAT (pick associative to section at 4ABC)
.xdata$x:000068C4 __unwindtable$?_Orphan_range@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXPAU?$pair@HH@2@0@Z db 0FFh
.xdata$x:000068C4                                         ; DATA XREF: .xdata$x:000068D4o
.xdata$x:000068C5                 db 0FFh
.xdata$x:000068C6                 db 0FFh
.xdata$x:000068C7                 db 0FFh
.xdata$x:000068C8                 dd offset __unwindfunclet$?_Orphan_range@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXPAU?$pair@HH@2@0@Z$0
.xdata$x:000068CC __ehfuncinfo$?_Orphan_range@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXPAU?$pair@HH@2@0@Z db  22h ; "
.xdata$x:000068CC                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXPAU?$pair@HH@2@0@Z+11o
.xdata$x:000068CD                 db    5
.xdata$x:000068CE                 db  93h ; ô
.xdata$x:000068CF                 db  19h
.xdata$x:000068D0                 db    1
.xdata$x:000068D1                 db    0
.xdata$x:000068D2                 db    0
.xdata$x:000068D3                 db    0
.xdata$x:000068D4                 dd offset __unwindtable$?_Orphan_range@?$vector@U?$pair@HH@std@@V?$allocator@U?$pair@HH@std@@@2@@std@@IBEXPAU?$pair@HH@2@0@Z
.xdata$x:000068D8                 db    0
.xdata$x:000068D9                 db    0
.xdata$x:000068DA                 db    0
.xdata$x:000068DB                 db    0
.xdata$x:000068DC                 db    0
.xdata$x:000068DD                 db    0
.xdata$x:000068DE                 db    0
.xdata$x:000068DF                 db    0
.xdata$x:000068E0                 db    0
.xdata$x:000068E1                 db    0
.xdata$x:000068E2                 db    0
.xdata$x:000068E3                 db    0
.xdata$x:000068E4                 db    0
.xdata$x:000068E5                 db    0
.xdata$x:000068E6                 db    0
.xdata$x:000068E7                 db    0
.xdata$x:000068E8                 db    0
.xdata$x:000068E9                 db    0
.xdata$x:000068EA                 db    0
.xdata$x:000068EB                 db    0
.xdata$x:000068EC                 db    0
.xdata$x:000068ED                 db    0
.xdata$x:000068EE                 db    0
.xdata$x:000068EF                 db    0
.xdata$x:000068EF _xdata$x        ends
.xdata$x:000068EF
.xdata$x:000068F0 ; ===========================================================================
.xdata$x:000068F0
.xdata$x:000068F0 ; Segment type: Pure data
.xdata$x:000068F0 ; Segment permissions: Read
.xdata$x:000068F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000068F0                 assume cs:_xdata$x
.xdata$x:000068F0                 ;org 68F0h
.xdata$x:000068F0 ; COMDAT (pick associative to section at 2C44)
.xdata$x:000068F0 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:000068F0                                         ; DATA XREF: .xdata$x:00006900o
.xdata$x:000068F1                 db 0FFh
.xdata$x:000068F2                 db 0FFh
.xdata$x:000068F3                 db 0FFh
.xdata$x:000068F4                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:000068F8 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:000068F8                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:000068F9                 db    5
.xdata$x:000068FA                 db  93h ; ô
.xdata$x:000068FB                 db  19h
.xdata$x:000068FC                 db    1
.xdata$x:000068FD                 db    0
.xdata$x:000068FE                 db    0
.xdata$x:000068FF                 db    0
.xdata$x:00006900                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00006904                 db    0
.xdata$x:00006905                 db    0
.xdata$x:00006906                 db    0
.xdata$x:00006907                 db    0
.xdata$x:00006908                 db    0
.xdata$x:00006909                 db    0
.xdata$x:0000690A                 db    0
.xdata$x:0000690B                 db    0
.xdata$x:0000690C                 db    0
.xdata$x:0000690D                 db    0
.xdata$x:0000690E                 db    0
.xdata$x:0000690F                 db    0
.xdata$x:00006910                 db    0
.xdata$x:00006911                 db    0
.xdata$x:00006912                 db    0
.xdata$x:00006913                 db    0
.xdata$x:00006914                 db    0
.xdata$x:00006915                 db    0
.xdata$x:00006916                 db    0
.xdata$x:00006917                 db    0
.xdata$x:00006918                 db    0
.xdata$x:00006919                 db    0
.xdata$x:0000691A                 db    0
.xdata$x:0000691B                 db    0
.xdata$x:0000691B _xdata$x        ends
.xdata$x:0000691B
.xdata$x:0000691C ; ===========================================================================
.xdata$x:0000691C
.xdata$x:0000691C ; Segment type: Pure data
.xdata$x:0000691C ; Segment permissions: Read
.xdata$x:0000691C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000691C                 assume cs:_xdata$x
.xdata$x:0000691C                 ;org 691Ch
.xdata$x:0000691C ; COMDAT (pick associative to section at 35F4)
.xdata$x:0000691C __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000691C                                         ; DATA XREF: .xdata$x:0000692Co
.xdata$x:0000691D                 db 0FFh
.xdata$x:0000691E                 db 0FFh
.xdata$x:0000691F                 db 0FFh
.xdata$x:00006920                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:00006924 __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00006924                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:00006925                 db    5
.xdata$x:00006926                 db  93h ; ô
.xdata$x:00006927                 db  19h
.xdata$x:00006928                 db    1
.xdata$x:00006929                 db    0
.xdata$x:0000692A                 db    0
.xdata$x:0000692B                 db    0
.xdata$x:0000692C                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00006930                 db    0
.xdata$x:00006931                 db    0
.xdata$x:00006932                 db    0
.xdata$x:00006933                 db    0
.xdata$x:00006934                 db    0
.xdata$x:00006935                 db    0
.xdata$x:00006936                 db    0
.xdata$x:00006937                 db    0
.xdata$x:00006938                 db    0
.xdata$x:00006939                 db    0
.xdata$x:0000693A                 db    0
.xdata$x:0000693B                 db    0
.xdata$x:0000693C                 db    0
.xdata$x:0000693D                 db    0
.xdata$x:0000693E                 db    0
.xdata$x:0000693F                 db    0
.xdata$x:00006940                 db    0
.xdata$x:00006941                 db    0
.xdata$x:00006942                 db    0
.xdata$x:00006943                 db    0
.xdata$x:00006944                 db    0
.xdata$x:00006945                 db    0
.xdata$x:00006946                 db    0
.xdata$x:00006947                 db    0
.xdata$x:00006947 _xdata$x        ends
.xdata$x:00006947
.xdata$x:00006948 ; ===========================================================================
.xdata$x:00006948
.xdata$x:00006948 ; Segment type: Pure data
.xdata$x:00006948 ; Segment permissions: Read
.xdata$x:00006948 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006948                 assume cs:_xdata$x
.xdata$x:00006948                 ;org 6948h
.xdata$x:00006948 ; COMDAT (pick associative to section at 2BCC)
.xdata$x:00006948 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:00006948                                         ; DATA XREF: .xdata$x:00006958o
.xdata$x:00006949                 db 0FFh
.xdata$x:0000694A                 db 0FFh
.xdata$x:0000694B                 db 0FFh
.xdata$x:0000694C                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:00006950 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:00006950                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:00006951                 db    5
.xdata$x:00006952                 db  93h ; ô
.xdata$x:00006953                 db  19h
.xdata$x:00006954                 db    1
.xdata$x:00006955                 db    0
.xdata$x:00006956                 db    0
.xdata$x:00006957                 db    0
.xdata$x:00006958                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@DHPBDABDU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:0000695C                 db    0
.xdata$x:0000695D                 db    0
.xdata$x:0000695E                 db    0
.xdata$x:0000695F                 db    0
.xdata$x:00006960                 db    0
.xdata$x:00006961                 db    0
.xdata$x:00006962                 db    0
.xdata$x:00006963                 db    0
.xdata$x:00006964                 db    0
.xdata$x:00006965                 db    0
.xdata$x:00006966                 db    0
.xdata$x:00006967                 db    0
.xdata$x:00006968                 db    0
.xdata$x:00006969                 db    0
.xdata$x:0000696A                 db    0
.xdata$x:0000696B                 db    0
.xdata$x:0000696C                 db    0
.xdata$x:0000696D                 db    0
.xdata$x:0000696E                 db    0
.xdata$x:0000696F                 db    0
.xdata$x:00006970                 db    0
.xdata$x:00006971                 db    0
.xdata$x:00006972                 db    0
.xdata$x:00006973                 db    0
.xdata$x:00006973 _xdata$x        ends
.xdata$x:00006973
.xdata$x:00006974 ; ===========================================================================
.xdata$x:00006974
.xdata$x:00006974 ; Segment type: Pure data
.xdata$x:00006974 ; Segment permissions: Read
.xdata$x:00006974 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006974                 assume cs:_xdata$x
.xdata$x:00006974                 ;org 6974h
.xdata$x:00006974 ; COMDAT (pick associative to section at 2DB8)
.xdata$x:00006974 __unwindtable$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z db 0FFh
.xdata$x:00006974                                         ; DATA XREF: .xdata$x:00006984o
.xdata$x:00006975                 db 0FFh
.xdata$x:00006976                 db 0FFh
.xdata$x:00006977                 db 0FFh
.xdata$x:00006978                 dd offset __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z$0
.xdata$x:0000697C __ehfuncinfo$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000697C                                         ; DATA XREF: __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z+11o
.xdata$x:0000697D                 db    5
.xdata$x:0000697E                 db  93h ; ô
.xdata$x:0000697F                 db  19h
.xdata$x:00006980                 db    1
.xdata$x:00006981                 db    0
.xdata$x:00006982                 db    0
.xdata$x:00006983                 db    0
.xdata$x:00006984                 dd offset __unwindtable$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z
.xdata$x:00006988                 align 20h
.xdata$x:00006988 _xdata$x        ends
.xdata$x:00006988
.xdata$x:000069A0 ; ===========================================================================
.xdata$x:000069A0
.xdata$x:000069A0 ; Segment type: Pure data
.xdata$x:000069A0 ; Segment permissions: Read
.xdata$x:000069A0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000069A0                 assume cs:_xdata$x
.xdata$x:000069A0                 ;org 69A0h
.xdata$x:000069A0 ; COMDAT (pick associative to section at 36DC)
.xdata$x:000069A0 __unwindtable$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000069A0                                         ; DATA XREF: .xdata$x:000069B0o
.xdata$x:000069A1                 db 0FFh
.xdata$x:000069A2                 db 0FFh
.xdata$x:000069A3                 db 0FFh
.xdata$x:000069A4                 dd offset __unwindfunclet$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000069A8 __ehfuncinfo$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000069A8                                         ; DATA XREF: __ehhandler$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000069A9                 db    5
.xdata$x:000069AA                 db  93h ; ô
.xdata$x:000069AB                 db  19h
.xdata$x:000069AC                 db    1
.xdata$x:000069AD                 db    0
.xdata$x:000069AE                 db    0
.xdata$x:000069AF                 db    0
.xdata$x:000069B0                 dd offset __unwindtable$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
.xdata$x:000069B4                 db    0
.xdata$x:000069B5                 db    0
.xdata$x:000069B6                 db    0
.xdata$x:000069B7                 db    0
.xdata$x:000069B8                 db    0
.xdata$x:000069B9                 db    0
.xdata$x:000069BA                 db    0
.xdata$x:000069BB                 db    0
.xdata$x:000069BC                 db    0
.xdata$x:000069BD                 db    0
.xdata$x:000069BE                 db    0
.xdata$x:000069BF                 db    0
.xdata$x:000069C0                 db    0
.xdata$x:000069C1                 db    0
.xdata$x:000069C2                 db    0
.xdata$x:000069C3                 db    0
.xdata$x:000069C4                 db    0
.xdata$x:000069C5                 db    0
.xdata$x:000069C6                 db    0
.xdata$x:000069C7                 db    0
.xdata$x:000069C8                 db    0
.xdata$x:000069C9                 db    0
.xdata$x:000069CA                 db    0
.xdata$x:000069CB                 db    0
.xdata$x:000069CB _xdata$x        ends
.xdata$x:000069CB
.xdata$x:000069CC ; ===========================================================================
.xdata$x:000069CC
.xdata$x:000069CC ; Segment type: Pure data
.xdata$x:000069CC ; Segment permissions: Read
.xdata$x:000069CC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000069CC                 assume cs:_xdata$x
.xdata$x:000069CC                 ;org 69CCh
.xdata$x:000069CC ; COMDAT (pick associative to section at 2D34)
.xdata$x:000069CC __unwindtable$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:000069CC                                         ; DATA XREF: .xdata$x:000069DCo
.xdata$x:000069CD                 db 0FFh
.xdata$x:000069CE                 db 0FFh
.xdata$x:000069CF                 db 0FFh
.xdata$x:000069D0                 dd offset __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:000069D4 __ehfuncinfo$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:000069D4                                         ; DATA XREF: __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:000069D5                 db    5
.xdata$x:000069D6                 db  93h ; ô
.xdata$x:000069D7                 db  19h
.xdata$x:000069D8                 db    1
.xdata$x:000069D9                 db    0
.xdata$x:000069DA                 db    0
.xdata$x:000069DB                 db    0
.xdata$x:000069DC                 dd offset __unwindtable$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:000069E0                 db    0
.xdata$x:000069E1                 db    0
.xdata$x:000069E2                 db    0
.xdata$x:000069E3                 db    0
.xdata$x:000069E4                 db    0
.xdata$x:000069E5                 db    0
.xdata$x:000069E6                 db    0
.xdata$x:000069E7                 db    0
.xdata$x:000069E8                 db    0
.xdata$x:000069E9                 db    0
.xdata$x:000069EA                 db    0
.xdata$x:000069EB                 db    0
.xdata$x:000069EC                 db    0
.xdata$x:000069ED                 db    0
.xdata$x:000069EE                 db    0
.xdata$x:000069EF                 db    0
.xdata$x:000069F0                 db    0
.xdata$x:000069F1                 db    0
.xdata$x:000069F2                 db    0
.xdata$x:000069F3                 db    0
.xdata$x:000069F4                 db    0
.xdata$x:000069F5                 db    0
.xdata$x:000069F6                 db    0
.xdata$x:000069F7                 db    0
.xdata$x:000069F7 _xdata$x        ends
.xdata$x:000069F7
.xdata$x:000069F8 ; ===========================================================================
.xdata$x:000069F8
.xdata$x:000069F8 ; Segment type: Pure data
.xdata$x:000069F8 ; Segment permissions: Read
.xdata$x:000069F8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000069F8                 assume cs:_xdata$x
.xdata$x:000069F8                 ;org 69F8h
.xdata$x:000069F8 ; COMDAT (pick associative to section at 2EBC)
.xdata$x:000069F8 __unwindtable$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z db 0FFh
.xdata$x:000069F8                                         ; DATA XREF: .xdata$x:00006A08o
.xdata$x:000069F9                 db 0FFh
.xdata$x:000069FA                 db 0FFh
.xdata$x:000069FB                 db 0FFh
.xdata$x:000069FC                 dd offset __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z$0
.xdata$x:00006A00 __ehfuncinfo$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:00006A00                                         ; DATA XREF: __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z+11o
.xdata$x:00006A01                 db    5
.xdata$x:00006A02                 db  93h ; ô
.xdata$x:00006A03                 db  19h
.xdata$x:00006A04                 db    1
.xdata$x:00006A05                 db    0
.xdata$x:00006A06                 db    0
.xdata$x:00006A07                 db    0
.xdata$x:00006A08                 dd offset __unwindtable$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z
.xdata$x:00006A0C                 db    0
.xdata$x:00006A0D                 db    0
.xdata$x:00006A0E                 db    0
.xdata$x:00006A0F                 db    0
.xdata$x:00006A10                 db    0
.xdata$x:00006A11                 db    0
.xdata$x:00006A12                 db    0
.xdata$x:00006A13                 db    0
.xdata$x:00006A14                 db    0
.xdata$x:00006A15                 db    0
.xdata$x:00006A16                 db    0
.xdata$x:00006A17                 db    0
.xdata$x:00006A18                 db    0
.xdata$x:00006A19                 db    0
.xdata$x:00006A1A                 db    0
.xdata$x:00006A1B                 db    0
.xdata$x:00006A1C                 db    0
.xdata$x:00006A1D                 db    0
.xdata$x:00006A1E                 db    0
.xdata$x:00006A1F                 db    0
.xdata$x:00006A20                 db    0
.xdata$x:00006A21                 db    0
.xdata$x:00006A22                 db    0
.xdata$x:00006A23                 db    0
.xdata$x:00006A23 _xdata$x        ends
.xdata$x:00006A23
.xdata$x:00006A24 ; ===========================================================================
.xdata$x:00006A24
.xdata$x:00006A24 ; Segment type: Pure data
.xdata$x:00006A24 ; Segment permissions: Read
.xdata$x:00006A24 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006A24                 assume cs:_xdata$x
.xdata$x:00006A24                 ;org 6A24h
.xdata$x:00006A24 ; COMDAT (pick associative to section at 3E04)
.xdata$x:00006A24 __unwindtable$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE?AV01@H@Z db 0FFh
.xdata$x:00006A24                                         ; DATA XREF: .xdata$x:00006A3Co
.xdata$x:00006A25                 db 0FFh
.xdata$x:00006A26                 db 0FFh
.xdata$x:00006A27                 db 0FFh
.xdata$x:00006A28                 dd offset __unwindfunclet$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE?AV01@H@Z$1
.xdata$x:00006A2C                 align 10h
.xdata$x:00006A30                 dd offset __unwindfunclet$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE?AV01@H@Z$0
.xdata$x:00006A34 __ehfuncinfo$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE?AV01@H@Z db  22h ; "
.xdata$x:00006A34                                         ; DATA XREF: __ehhandler$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE?AV01@H@Z+11o
.xdata$x:00006A35                 db    5
.xdata$x:00006A36                 db  93h ; ô
.xdata$x:00006A37                 db  19h
.xdata$x:00006A38                 db    2
.xdata$x:00006A39                 db    0
.xdata$x:00006A3A                 db    0
.xdata$x:00006A3B                 db    0
.xdata$x:00006A3C                 dd offset __unwindtable$??H?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE?AV01@H@Z
.xdata$x:00006A40                 db    0
.xdata$x:00006A41                 db    0
.xdata$x:00006A42                 db    0
.xdata$x:00006A43                 db    0
.xdata$x:00006A44                 db    0
.xdata$x:00006A45                 db    0
.xdata$x:00006A46                 db    0
.xdata$x:00006A47                 db    0
.xdata$x:00006A48                 db    0
.xdata$x:00006A49                 db    0
.xdata$x:00006A4A                 db    0
.xdata$x:00006A4B                 db    0
.xdata$x:00006A4C                 db    0
.xdata$x:00006A4D                 db    0
.xdata$x:00006A4E                 db    0
.xdata$x:00006A4F                 db    0
.xdata$x:00006A50                 db    0
.xdata$x:00006A51                 db    0
.xdata$x:00006A52                 db    0
.xdata$x:00006A53                 db    0
.xdata$x:00006A54                 db    0
.xdata$x:00006A55                 db    0
.xdata$x:00006A56                 db    0
.xdata$x:00006A57                 db    0
.xdata$x:00006A57 _xdata$x        ends
.xdata$x:00006A57
.xdata$x:00006A58 ; ===========================================================================
.xdata$x:00006A58
.xdata$x:00006A58 ; Segment type: Pure data
.xdata$x:00006A58 ; Segment permissions: Read
.xdata$x:00006A58 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006A58                 assume cs:_xdata$x
.xdata$x:00006A58                 ;org 6A58h
.xdata$x:00006A58 ; COMDAT (pick associative to section at 374C)
.xdata$x:00006A58 __unwindtable$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00006A58                                         ; DATA XREF: .xdata$x:00006A68o
.xdata$x:00006A59                 db 0FFh
.xdata$x:00006A5A                 db 0FFh
.xdata$x:00006A5B                 db 0FFh
.xdata$x:00006A5C                 dd offset __unwindfunclet$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00006A60 __ehfuncinfo$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00006A60                                         ; DATA XREF: __ehhandler$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00006A61                 db    5
.xdata$x:00006A62                 db  93h ; ô
.xdata$x:00006A63                 db  19h
.xdata$x:00006A64                 db    1
.xdata$x:00006A65                 db    0
.xdata$x:00006A66                 db    0
.xdata$x:00006A67                 db    0
.xdata$x:00006A68                 dd offset __unwindtable$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00006A6C                 db    0
.xdata$x:00006A6D                 db    0
.xdata$x:00006A6E                 db    0
.xdata$x:00006A6F                 db    0
.xdata$x:00006A70                 db    0
.xdata$x:00006A71                 db    0
.xdata$x:00006A72                 db    0
.xdata$x:00006A73                 db    0
.xdata$x:00006A74                 db    0
.xdata$x:00006A75                 db    0
.xdata$x:00006A76                 db    0
.xdata$x:00006A77                 db    0
.xdata$x:00006A78                 db    0
.xdata$x:00006A79                 db    0
.xdata$x:00006A7A                 db    0
.xdata$x:00006A7B                 db    0
.xdata$x:00006A7C                 db    0
.xdata$x:00006A7D                 db    0
.xdata$x:00006A7E                 db    0
.xdata$x:00006A7F                 db    0
.xdata$x:00006A80                 db    0
.xdata$x:00006A81                 db    0
.xdata$x:00006A82                 db    0
.xdata$x:00006A83                 db    0
.xdata$x:00006A83 _xdata$x        ends
.xdata$x:00006A83
.xdata$x:00006A84 ; ===========================================================================
.xdata$x:00006A84
.xdata$x:00006A84 ; Segment type: Pure data
.xdata$x:00006A84 ; Segment permissions: Read
.xdata$x:00006A84 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006A84                 assume cs:_xdata$x
.xdata$x:00006A84                 ;org 6A84h
.xdata$x:00006A84 ; COMDAT (pick associative to section at 2E44)
.xdata$x:00006A84 __unwindtable$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00006A84                                         ; DATA XREF: .xdata$x:00006A94o
.xdata$x:00006A85                 db 0FFh
.xdata$x:00006A86                 db 0FFh
.xdata$x:00006A87                 db 0FFh
.xdata$x:00006A88                 dd offset __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00006A8C __ehfuncinfo$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00006A8C                                         ; DATA XREF: __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00006A8D                 db    5
.xdata$x:00006A8E                 db  93h ; ô
.xdata$x:00006A8F                 db  19h
.xdata$x:00006A90                 db    1
.xdata$x:00006A91                 db    0
.xdata$x:00006A92                 db    0
.xdata$x:00006A93                 db    0
.xdata$x:00006A94                 dd offset __unwindtable$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:00006A98                 db    0
.xdata$x:00006A99                 db    0
.xdata$x:00006A9A                 db    0
.xdata$x:00006A9B                 db    0
.xdata$x:00006A9C                 db    0
.xdata$x:00006A9D                 db    0
.xdata$x:00006A9E                 db    0
.xdata$x:00006A9F                 db    0
.xdata$x:00006AA0                 db    0
.xdata$x:00006AA1                 db    0
.xdata$x:00006AA2                 db    0
.xdata$x:00006AA3                 db    0
.xdata$x:00006AA4                 db    0
.xdata$x:00006AA5                 db    0
.xdata$x:00006AA6                 db    0
.xdata$x:00006AA7                 db    0
.xdata$x:00006AA8                 db    0
.xdata$x:00006AA9                 db    0
.xdata$x:00006AAA                 db    0
.xdata$x:00006AAB                 db    0
.xdata$x:00006AAC                 db    0
.xdata$x:00006AAD                 db    0
.xdata$x:00006AAE                 db    0
.xdata$x:00006AAF                 db    0
.xdata$x:00006AAF _xdata$x        ends
.xdata$x:00006AAF
.xdata$x:00006AB0 ; ===========================================================================
.xdata$x:00006AB0
.xdata$x:00006AB0 ; Segment type: Pure data
.xdata$x:00006AB0 ; Segment permissions: Read
.xdata$x:00006AB0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006AB0                 assume cs:_xdata$x
.xdata$x:00006AB0                 ;org 6AB0h
.xdata$x:00006AB0 ; COMDAT (pick associative to section at 2A00)
.xdata$x:00006AB0 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00006AB0                                         ; DATA XREF: .xdata$x:00006AC0o
.xdata$x:00006AB1                 db 0FFh
.xdata$x:00006AB2                 db 0FFh
.xdata$x:00006AB3                 db 0FFh
.xdata$x:00006AB4                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00006AB8 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00006AB8                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00006AB9                 db    5
.xdata$x:00006ABA                 db  93h ; ô
.xdata$x:00006ABB                 db  19h
.xdata$x:00006ABC                 db    1
.xdata$x:00006ABD                 db    0
.xdata$x:00006ABE                 db    0
.xdata$x:00006ABF                 db    0
.xdata$x:00006AC0                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00006AC4                 db    0
.xdata$x:00006AC5                 db    0
.xdata$x:00006AC6                 db    0
.xdata$x:00006AC7                 db    0
.xdata$x:00006AC8                 db    0
.xdata$x:00006AC9                 db    0
.xdata$x:00006ACA                 db    0
.xdata$x:00006ACB                 db    0
.xdata$x:00006ACC                 db    0
.xdata$x:00006ACD                 db    0
.xdata$x:00006ACE                 db    0
.xdata$x:00006ACF                 db    0
.xdata$x:00006AD0                 db    0
.xdata$x:00006AD1                 db    0
.xdata$x:00006AD2                 db    0
.xdata$x:00006AD3                 db    0
.xdata$x:00006AD4                 db    0
.xdata$x:00006AD5                 db    0
.xdata$x:00006AD6                 db    0
.xdata$x:00006AD7                 db    0
.xdata$x:00006AD8                 db    0
.xdata$x:00006AD9                 db    0
.xdata$x:00006ADA                 db    0
.xdata$x:00006ADB                 db    0
.xdata$x:00006ADB _xdata$x        ends
.xdata$x:00006ADB
.xdata$x:00006ADC ; ===========================================================================
.xdata$x:00006ADC
.xdata$x:00006ADC ; Segment type: Pure data
.xdata$x:00006ADC ; Segment permissions: Read
.xdata$x:00006ADC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006ADC                 assume cs:_xdata$x
.xdata$x:00006ADC                 ;org 6ADCh
.xdata$x:00006ADC ; COMDAT (pick associative to section at 2900)
.xdata$x:00006ADC __unwindtable$??$construct@U?$pair@HH@std@@U12@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@$$QAU21@@Z db 0FFh
.xdata$x:00006ADC                                         ; DATA XREF: .xdata$x:00006AECo
.xdata$x:00006ADD                 db 0FFh
.xdata$x:00006ADE                 db 0FFh
.xdata$x:00006ADF                 db 0FFh
.xdata$x:00006AE0                 dd offset __unwindfunclet$??$construct@U?$pair@HH@std@@U12@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@$$QAU21@@Z$0
.xdata$x:00006AE4 __ehfuncinfo$??$construct@U?$pair@HH@std@@U12@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@$$QAU21@@Z db  22h ; "
.xdata$x:00006AE4                                         ; DATA XREF: __ehhandler$??$construct@U?$pair@HH@std@@U12@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@$$QAU21@@Z+11o
.xdata$x:00006AE5                 db    5
.xdata$x:00006AE6                 db  93h ; ô
.xdata$x:00006AE7                 db  19h
.xdata$x:00006AE8                 db    1
.xdata$x:00006AE9                 db    0
.xdata$x:00006AEA                 db    0
.xdata$x:00006AEB                 db    0
.xdata$x:00006AEC                 dd offset __unwindtable$??$construct@U?$pair@HH@std@@U12@@?$allocator@U?$pair@HH@std@@@std@@QAEXPAU?$pair@HH@1@$$QAU21@@Z
.xdata$x:00006AF0                 db    0
.xdata$x:00006AF1                 db    0
.xdata$x:00006AF2                 db    0
.xdata$x:00006AF3                 db    0
.xdata$x:00006AF4                 db    0
.xdata$x:00006AF5                 db    0
.xdata$x:00006AF6                 db    0
.xdata$x:00006AF7                 db    0
.xdata$x:00006AF8                 db    0
.xdata$x:00006AF9                 db    0
.xdata$x:00006AFA                 db    0
.xdata$x:00006AFB                 db    0
.xdata$x:00006AFC                 db    0
.xdata$x:00006AFD                 db    0
.xdata$x:00006AFE                 db    0
.xdata$x:00006AFF                 db    0
.xdata$x:00006B00                 db    0
.xdata$x:00006B01                 db    0
.xdata$x:00006B02                 db    0
.xdata$x:00006B03                 db    0
.xdata$x:00006B04                 db    0
.xdata$x:00006B05                 db    0
.xdata$x:00006B06                 db    0
.xdata$x:00006B07                 db    0
.xdata$x:00006B07 _xdata$x        ends
.xdata$x:00006B07
.xdata$x:00006B08 ; ===========================================================================
.xdata$x:00006B08
.xdata$x:00006B08 ; Segment type: Pure data
.xdata$x:00006B08 ; Segment permissions: Read
.xdata$x:00006B08 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006B08                 assume cs:_xdata$x
.xdata$x:00006B08                 ;org 6B08h
.xdata$x:00006B08 ; COMDAT (pick associative to section at 2800)
.xdata$x:00006B08 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00006B08                                         ; DATA XREF: .xdata$x:00006B18o
.xdata$x:00006B09                 db 0FFh
.xdata$x:00006B0A                 db 0FFh
.xdata$x:00006B0B                 db 0FFh
.xdata$x:00006B0C                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00006B10 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00006B10                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00006B11                 db    5
.xdata$x:00006B12                 db  93h ; ô
.xdata$x:00006B13                 db  19h
.xdata$x:00006B14                 db    1
.xdata$x:00006B15                 db    0
.xdata$x:00006B16                 db    0
.xdata$x:00006B17                 db    0
.xdata$x:00006B18                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00006B1C                 db    0
.xdata$x:00006B1D                 db    0
.xdata$x:00006B1E                 db    0
.xdata$x:00006B1F                 db    0
.xdata$x:00006B20                 db    0
.xdata$x:00006B21                 db    0
.xdata$x:00006B22                 db    0
.xdata$x:00006B23                 db    0
.xdata$x:00006B24                 db    0
.xdata$x:00006B25                 db    0
.xdata$x:00006B26                 db    0
.xdata$x:00006B27                 db    0
.xdata$x:00006B28                 db    0
.xdata$x:00006B29                 db    0
.xdata$x:00006B2A                 db    0
.xdata$x:00006B2B                 db    0
.xdata$x:00006B2C                 db    0
.xdata$x:00006B2D                 db    0
.xdata$x:00006B2E                 db    0
.xdata$x:00006B2F                 db    0
.xdata$x:00006B30                 db    0
.xdata$x:00006B31                 db    0
.xdata$x:00006B32                 db    0
.xdata$x:00006B33                 db    0
.xdata$x:00006B33 _xdata$x        ends
.xdata$x:00006B33
.xdata$x:00006B34 ; ===========================================================================
.xdata$x:00006B34
.xdata$x:00006B34 ; Segment type: Pure data
.xdata$x:00006B34 ; Segment permissions: Read
.xdata$x:00006B34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00006B34                 assume cs:_xdata$x
.xdata$x:00006B34                 ;org 6B34h
.xdata$x:00006B34 ; COMDAT (pick associative to section at 266C)
.xdata$x:00006B34 __catchsym$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:00006B34                                         ; DATA XREF: .xdata$x:00006B64o
.xdata$x:00006B35                 db    0
.xdata$x:00006B36                 db    0
.xdata$x:00006B37                 db    0
.xdata$x:00006B38                 db    0
.xdata$x:00006B39                 db    0
.xdata$x:00006B3A                 db    0
.xdata$x:00006B3B                 db    0
.xdata$x:00006B3C                 db    0
.xdata$x:00006B3D                 db    0
.xdata$x:00006B3E                 db    0
.xdata$x:00006B3F                 db    0
.xdata$x:00006B40                 dd offset __catch$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:00006B44 __unwindtable$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:00006B44                                         ; DATA XREF: .xdata$x:00006B70o
.xdata$x:00006B45                 db 0FFh
.xdata$x:00006B46                 db 0FFh
.xdata$x:00006B47                 db 0FFh
.xdata$x:00006B48                 db    0
.xdata$x:00006B49                 db    0
.xdata$x:00006B4A                 db    0
.xdata$x:00006B4B                 db    0
.xdata$x:00006B4C                 db 0FFh
.xdata$x:00006B4D                 db 0FFh
.xdata$x:00006B4E                 db 0FFh
.xdata$x:00006B4F                 db 0FFh
.xdata$x:00006B50                 db    0
.xdata$x:00006B51                 db    0
.xdata$x:00006B52                 db    0
.xdata$x:00006B53                 db    0
.xdata$x:00006B54 __tryblocktable$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:00006B54                                         ; DATA XREF: .xdata$x:00006B78o
.xdata$x:00006B55                 db    0
.xdata$x:00006B56                 db    0
.xdata$x:00006B57                 db    0
.xdata$x:00006B58                 db    0
.xdata$x:00006B59                 db    0
.xdata$x:00006B5A                 db    0
.xdata$x:00006B5B                 db    0
.xdata$x:00006B5C                 db    1
.xdata$x:00006B5D                 db    0
.xdata$x:00006B5E                 db    0
.xdata$x:00006B5F                 db    0
.xdata$x:00006B60                 db    1
.xdata$x:00006B61                 db    0
.xdata$x:00006B62                 db    0
.xdata$x:00006B63                 db    0
.xdata$x:00006B64                 dd offset __catchsym$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:00006B68 __ehfuncinfo$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:00006B68                                         ; DATA XREF: __ehhandler$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:00006B69                 db    5
.xdata$x:00006B6A                 db  93h ; ô
.xdata$x:00006B6B                 db  19h
.xdata$x:00006B6C                 db    2
.xdata$x:00006B6D                 db    0
.xdata$x:00006B6E                 db    0
.xdata$x:00006B6F                 db    0
.xdata$x:00006B70                 dd offset __unwindtable$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:00006B74                 db    1
.xdata$x:00006B75                 db    0
.xdata$x:00006B76                 db    0
.xdata$x:00006B77                 db    0
.xdata$x:00006B78                 dd offset __tryblocktable$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:00006B7C                 db    0
.xdata$x:00006B7D                 db    0
.xdata$x:00006B7E                 db    0
.xdata$x:00006B7F                 db    0
.xdata$x:00006B80                 db    0
.xdata$x:00006B81                 db    0
.xdata$x:00006B82                 db    0
.xdata$x:00006B83                 db    0
.xdata$x:00006B84                 db    0
.xdata$x:00006B85                 db    0
.xdata$x:00006B86                 db    0
.xdata$x:00006B87                 db    0
.xdata$x:00006B88                 db    0
.xdata$x:00006B89                 db    0
.xdata$x:00006B8A                 db    0
.xdata$x:00006B8B                 db    0
.xdata$x:00006B8B _xdata$x        ends
.xdata$x:00006B8B
.bss:00006B8C ; ===========================================================================
.bss:00006B8C
.bss:00006B8C ; Segment type: Uninitialized
.bss:00006B8C ; Segment permissions: Read/Write
.bss:00006B8C _bss            segment byte public 'BSS' use32
.bss:00006B8C                 assume cs:_bss
.bss:00006B8C                 ;org 6B8Ch
.bss:00006B8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00006B8C __Tuple_alloc   db    ? ;
.bss:00006B8D ; std::_Ignore ignore
.bss:00006B8D _ignore         db    ? ;               ; DATA XREF: std::`dynamic initializer for 'ignore''(void)+3o
.bss:00006B8E _allocator_arg  db    ? ;
.bss:00006B8F _piecewise_construct db    ? ;
.bss:00006B8F _bss            ends
.bss:00006B8F
.rdata:00006B90 ; ===========================================================================
.rdata:00006B90
.rdata:00006B90 ; Segment type: Pure data
.rdata:00006B90 ; Segment permissions: Read
.rdata:00006B90 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00006B90 _rdata          segment para public 'DATA' use32
.rdata:00006B90                 assume cs:_rdata
.rdata:00006B90                 ;org 6B90h
.rdata:00006B90 ; COMDAT (pick any)
.rdata:00006B90                 public ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00006B90 ; wchar_t `string'
.rdata:00006B90 ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00006B90                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+48o
.rdata:00006B90                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00006B90                 unicode 0, <clude\xutility>,0
.rdata:00006B90 _rdata          ends
.rdata:00006B90
.rdata:00006C20 ; ===========================================================================
.rdata:00006C20
.rdata:00006C20 ; Segment type: Pure data
.rdata:00006C20 ; Segment permissions: Read
.rdata:00006C20 _rdata          segment dword public 'DATA' use32
.rdata:00006C20                 assume cs:_rdata
.rdata:00006C20                 ;org 6C20h
.rdata:00006C20 ; COMDAT (pick any)
.rdata:00006C20                 public ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
.rdata:00006C20 ; wchar_t `string'
.rdata:00006C20 ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@:
.rdata:00006C20                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+4Do
.rdata:00006C20                 unicode 0, <ITERATOR LIST CORRUPTED!>,0
.rdata:00006C52                 align 4
.rdata:00006C52 _rdata          ends
.rdata:00006C52
.rdata:00006C54 ; ===========================================================================
.rdata:00006C54
.rdata:00006C54 ; Segment type: Pure data
.rdata:00006C54 ; Segment permissions: Read
.rdata:00006C54 _rdata          segment dword public 'DATA' use32
.rdata:00006C54                 assume cs:_rdata
.rdata:00006C54                 ;org 6C54h
.rdata:00006C54 ; COMDAT (pick any)
.rdata:00006C54                 public ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
.rdata:00006C54 ; size_t std::basic_string<char,std::char_traits<char>,std::allocator<char>>::npos
.rdata:00006C54 ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB dd 0FFFFFFFFh
.rdata:00006C54                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &)+7r
.rdata:00006C54                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::append(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+3Dr ...
.rdata:00006C54 _rdata          ends
.rdata:00006C54
.rdata:00006C58 ; ===========================================================================
.rdata:00006C58
.rdata:00006C58 ; Segment type: Pure data
.rdata:00006C58 ; Segment permissions: Read
.rdata:00006C58 _rdata          segment dword public 'DATA' use32
.rdata:00006C58                 assume cs:_rdata
.rdata:00006C58                 ;org 6C58h
.rdata:00006C58 ; COMDAT (pick largest)
.rdata:00006C58                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00006C5C                 public ??_7error_category@std@@6B@
.rdata:00006C5C ; const std::error_category::`vftable'
.rdata:00006C5C ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00006C5C                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00006C5C                                         ; std::error_category::~error_category(void)+Ao
.rdata:00006C5C                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00006C60                 dd offset __purecall
.rdata:00006C64                 dd offset __purecall
.rdata:00006C68                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00006C6C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00006C70                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00006C70 _rdata          ends
.rdata:00006C70
.rdata:00006C74 ; ===========================================================================
.rdata:00006C74
.rdata:00006C74 ; Segment type: Pure data
.rdata:00006C74 ; Segment permissions: Read
.rdata:00006C74 _rdata          segment dword public 'DATA' use32
.rdata:00006C74                 assume cs:_rdata
.rdata:00006C74                 ;org 6C74h
.rdata:00006C74 ; COMDAT (pick largest)
.rdata:00006C74                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00006C78                 public ??_7_Generic_error_category@std@@6B@
.rdata:00006C78 ; const std::_Generic_error_category::`vftable'
.rdata:00006C78 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00006C78                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00006C78                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00006C7C                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00006C80                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00006C84                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00006C88                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00006C8C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00006C8C _rdata          ends
.rdata:00006C8C
.rdata:00006C90 ; ===========================================================================
.rdata:00006C90
.rdata:00006C90 ; Segment type: Pure data
.rdata:00006C90 ; Segment permissions: Read
.rdata:00006C90 _rdata          segment dword public 'DATA' use32
.rdata:00006C90                 assume cs:_rdata
.rdata:00006C90                 ;org 6C90h
.rdata:00006C90 ; COMDAT (pick any)
.rdata:00006C90                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00006C90 ; `string'
.rdata:00006C90 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00006C90                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00006C90 _rdata          ends
.rdata:00006C90
.rdata:00006C98 ; ===========================================================================
.rdata:00006C98
.rdata:00006C98 ; Segment type: Pure data
.rdata:00006C98 ; Segment permissions: Read
.rdata:00006C98 _rdata          segment dword public 'DATA' use32
.rdata:00006C98                 assume cs:_rdata
.rdata:00006C98                 ;org 6C98h
.rdata:00006C98 ; COMDAT (pick any)
.rdata:00006C98                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00006C98 ; `string'
.rdata:00006C98 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00006C98                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_5C40o
.rdata:00006C98                                         ; std::_System_error_category::message(int):loc_5DBCo
.rdata:00006CA6                 align 4
.rdata:00006CA6 _rdata          ends
.rdata:00006CA6
.rdata:00006CA8 ; ===========================================================================
.rdata:00006CA8
.rdata:00006CA8 ; Segment type: Pure data
.rdata:00006CA8 ; Segment permissions: Read
.rdata:00006CA8 _rdata          segment dword public 'DATA' use32
.rdata:00006CA8                 assume cs:_rdata
.rdata:00006CA8                 ;org 6CA8h
.rdata:00006CA8 ; COMDAT (pick largest)
.rdata:00006CA8                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00006CAC                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00006CAC ; const std::_Iostream_error_category::`vftable'
.rdata:00006CAC ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00006CAC                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00006CAC                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00006CB0                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00006CB4                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00006CB8                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00006CBC                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00006CC0                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00006CC0 _rdata          ends
.rdata:00006CC0
.rdata:00006CC4 ; ===========================================================================
.rdata:00006CC4
.rdata:00006CC4 ; Segment type: Pure data
.rdata:00006CC4 ; Segment permissions: Read
.rdata:00006CC4 _rdata          segment dword public 'DATA' use32
.rdata:00006CC4                 assume cs:_rdata
.rdata:00006CC4                 ;org 6CC4h
.rdata:00006CC4 ; COMDAT (pick any)
.rdata:00006CC4                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00006CC4 ; `string'
.rdata:00006CC4 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00006CC4                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00006CCD                 align 10h
.rdata:00006CCD _rdata          ends
.rdata:00006CCD
.rdata:00006CD0 ; ===========================================================================
.rdata:00006CD0
.rdata:00006CD0 ; Segment type: Pure data
.rdata:00006CD0 ; Segment permissions: Read
.rdata:00006CD0 _rdata          segment dword public 'DATA' use32
.rdata:00006CD0                 assume cs:_rdata
.rdata:00006CD0                 ;org 6CD0h
.rdata:00006CD0 ; COMDAT (pick any)
.rdata:00006CD0                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00006CD0 ; char `string'[]
.rdata:00006CD0 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00006CD0                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00006CE6                 align 4
.rdata:00006CE6 _rdata          ends
.rdata:00006CE6
.rdata:00006CE8 ; ===========================================================================
.rdata:00006CE8
.rdata:00006CE8 ; Segment type: Pure data
.rdata:00006CE8 ; Segment permissions: Read
.rdata:00006CE8 _rdata          segment dword public 'DATA' use32
.rdata:00006CE8                 assume cs:_rdata
.rdata:00006CE8                 ;org 6CE8h
.rdata:00006CE8 ; COMDAT (pick largest)
.rdata:00006CE8                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00006CEC                 public ??_7_System_error_category@std@@6B@
.rdata:00006CEC ; const std::_System_error_category::`vftable'
.rdata:00006CEC ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00006CEC                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00006CEC                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00006CF0                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00006CF4                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00006CF8                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00006CFC                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00006D00                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00006D00 _rdata          ends
.rdata:00006D00
.rdata:00006D04 ; ===========================================================================
.rdata:00006D04
.rdata:00006D04 ; Segment type: Pure data
.rdata:00006D04 ; Segment permissions: Read
.rdata:00006D04 _rdata          segment dword public 'DATA' use32
.rdata:00006D04                 assume cs:_rdata
.rdata:00006D04                 ;org 6D04h
.rdata:00006D04 ; COMDAT (pick any)
.rdata:00006D04                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00006D04 ; `string'
.rdata:00006D04 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00006D04                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00006D0B                 align 4
.rdata:00006D0B _rdata          ends
.rdata:00006D0B
.bss:00006D0C ; ===========================================================================
.bss:00006D0C
.bss:00006D0C ; Segment type: Uninitialized
.bss:00006D0C ; Segment permissions: Read/Write
.bss:00006D0C _bss            segment dword public 'BSS' use32
.bss:00006D0C                 assume cs:_bss
.bss:00006D0C                 ;org 6D0Ch
.bss:00006D0C ; COMDAT (pick any)
.bss:00006D0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00006D0C                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00006D0C ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00006D0C ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00006D0C                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00006D0C                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00006D0D                 db    ? ;
.bss:00006D0E                 db    ? ;
.bss:00006D0F                 db    ? ;
.bss:00006D0F _bss            ends
.bss:00006D0F
.bss:00006D10 ; ===========================================================================
.bss:00006D10
.bss:00006D10 ; Segment type: Uninitialized
.bss:00006D10 ; Segment permissions: Read/Write
.bss:00006D10 _bss            segment dword public 'BSS' use32
.bss:00006D10                 assume cs:_bss
.bss:00006D10                 ;org 6D10h
.bss:00006D10 ; COMDAT (pick any)
.bss:00006D10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00006D10                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00006D10 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00006D10 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00006D10                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00006D10                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00006D11                 db    ? ;
.bss:00006D12                 db    ? ;
.bss:00006D13                 db    ? ;
.bss:00006D13 _bss            ends
.bss:00006D13
.bss:00006D14 ; ===========================================================================
.bss:00006D14
.bss:00006D14 ; Segment type: Uninitialized
.bss:00006D14 ; Segment permissions: Read/Write
.bss:00006D14 _bss            segment dword public 'BSS' use32
.bss:00006D14                 assume cs:_bss
.bss:00006D14                 ;org 6D14h
.bss:00006D14 ; COMDAT (pick any)
.bss:00006D14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00006D14                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00006D14 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00006D14 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00006D14                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00006D14                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00006D15                 db    ? ;
.bss:00006D16                 db    ? ;
.bss:00006D17                 db    ? ;
.bss:00006D17 _bss            ends
.bss:00006D17
.bss:00006D18 ; ===========================================================================
.bss:00006D18
.bss:00006D18 ; Segment type: Uninitialized
.bss:00006D18 ; Segment permissions: Read/Write
.bss:00006D18 _bss            segment dword public 'BSS' use32
.bss:00006D18                 assume cs:_bss
.bss:00006D18                 ;org 6D18h
.bss:00006D18 ; COMDAT (pick any)
.bss:00006D18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00006D18                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00006D18 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00006D18 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00006D18                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00006D19                 db    ? ;
.bss:00006D1A                 db    ? ;
.bss:00006D1B                 db    ? ;
.bss:00006D1B _bss            ends
.bss:00006D1B
.bss:00006D1C ; ===========================================================================
.bss:00006D1C
.bss:00006D1C ; Segment type: Uninitialized
.bss:00006D1C ; Segment permissions: Read/Write
.bss:00006D1C _bss            segment dword public 'BSS' use32
.bss:00006D1C                 assume cs:_bss
.bss:00006D1C                 ;org 6D1Ch
.bss:00006D1C ; COMDAT (pick any)
.bss:00006D1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00006D1C                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00006D1C ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00006D1C ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00006D1C                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00006D1D                 db    ? ;
.bss:00006D1E                 db    ? ;
.bss:00006D1F                 db    ? ;
.bss:00006D1F _bss            ends
.bss:00006D1F
.rdata:00006D20 ; ===========================================================================
.rdata:00006D20
.rdata:00006D20 ; Segment type: Pure data
.rdata:00006D20 ; Segment permissions: Read
.rdata:00006D20 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00006D20 _rdata          segment para public 'DATA' use32
.rdata:00006D20                 assume cs:_rdata
.rdata:00006D20                 ;org 6D20h
.rdata:00006D20 ; COMDAT (pick any)
.rdata:00006D20                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00006D20 ; wchar_t `string'
.rdata:00006D20 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00006D20                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int)+67o
.rdata:00006D20                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int)+97o ...
.rdata:00006D20                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00006D20                 unicode 0, <clude\xstring>,0
.rdata:00006DAE                 align 10h
.rdata:00006DAE _rdata          ends
.rdata:00006DAE
.bss:00006DB0 ; ===========================================================================
.bss:00006DB0
.bss:00006DB0 ; Segment type: Uninitialized
.bss:00006DB0 ; Segment permissions: Read/Write
.bss:00006DB0 _bss            segment dword public 'BSS' use32
.bss:00006DB0                 assume cs:_bss
.bss:00006DB0                 ;org 6DB0h
.bss:00006DB0 ; COMDAT (pick any)
.bss:00006DB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00006DB0                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00006DB0 ; std::locale::id std::numpunct<char>::id
.bss:00006DB0 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00006DB0                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00006DB1                 db    ? ;
.bss:00006DB2                 db    ? ;
.bss:00006DB3                 db    ? ;
.bss:00006DB3 _bss            ends
.bss:00006DB3
.bss:00006DB4 ; ===========================================================================
.bss:00006DB4
.bss:00006DB4 ; Segment type: Uninitialized
.bss:00006DB4 ; Segment permissions: Read/Write
.bss:00006DB4 _bss            segment dword public 'BSS' use32
.bss:00006DB4                 assume cs:_bss
.bss:00006DB4                 ;org 6DB4h
.bss:00006DB4 ; COMDAT (pick any)
.bss:00006DB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00006DB4                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00006DB4 ; std::locale::id std::numpunct<wchar_t>::id
.bss:00006DB4 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00006DB4                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00006DB5                 db    ? ;
.bss:00006DB6                 db    ? ;
.bss:00006DB7                 db    ? ;
.bss:00006DB7 _bss            ends
.bss:00006DB7
.rdata:00006DB8 ; ===========================================================================
.rdata:00006DB8
.rdata:00006DB8 ; Segment type: Pure data
.rdata:00006DB8 ; Segment permissions: Read
.rdata:00006DB8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00006DB8 _rdata          segment para public 'DATA' use32
.rdata:00006DB8                 assume cs:_rdata
.rdata:00006DB8                 ;org 6DB8h
.rdata:00006DB8 ; COMDAT (pick any)
.rdata:00006DB8                 public ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00006DB8 ; wchar_t `string'
.rdata:00006DB8 ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00006DB8                                         ; DATA XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::operator[](uint)+19o
.rdata:00006DB8                                         ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::operator[](uint)+49o ...
.rdata:00006DB8                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00006DB8                 unicode 0, <clude\vector>,0
.rdata:00006DB8 _rdata          ends
.rdata:00006DB8
.rdata:00006E44 ; ===========================================================================
.rdata:00006E44
.rdata:00006E44 ; Segment type: Pure data
.rdata:00006E44 ; Segment permissions: Read
.rdata:00006E44 _rdata          segment dword public 'DATA' use32
.rdata:00006E44                 assume cs:_rdata
.rdata:00006E44                 ;org 6E44h
.rdata:00006E44 ; COMDAT (pick any)
.rdata:00006E44                 public ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:00006E44 ; wchar_t `string'
.rdata:00006E44 ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:00006E44                                         ; DATA XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::operator[](uint)+1Eo
.rdata:00006E44                 unicode 0, <vector subscript out of range>,0
.rdata:00006E44 _rdata          ends
.rdata:00006E44
.rdata:00006E80 ; ===========================================================================
.rdata:00006E80
.rdata:00006E80 ; Segment type: Pure data
.rdata:00006E80 ; Segment permissions: Read
.rdata:00006E80 _rdata          segment dword public 'DATA' use32
.rdata:00006E80                 assume cs:_rdata
.rdata:00006E80                 ;org 6E80h
.rdata:00006E80 ; COMDAT (pick any)
.rdata:00006E80                 public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
.rdata:00006E80 ; `string'
.rdata:00006E80 ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ db 'Standard C++ Libraries Out of Range',0
.rdata:00006E80                                         ; DATA XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::operator[](uint)+2Bo
.rdata:00006E80                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int):loc_3F39o
.rdata:00006E80 _rdata          ends
.rdata:00006E80
.rdata:00006EA4 ; ===========================================================================
.rdata:00006EA4
.rdata:00006EA4 ; Segment type: Pure data
.rdata:00006EA4 ; Segment permissions: Read
.rdata:00006EA4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00006EA4 _rdata          segment para public 'DATA' use32
.rdata:00006EA4                 assume cs:_rdata
.rdata:00006EA4                 ;org 6EA4h
.rdata:00006EA4 ; COMDAT (pick any)
.rdata:00006EA4                 public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
.rdata:00006EA4 ; `string'
.rdata:00006EA4 ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
.rdata:00006EA4                                         ; DATA XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::operator[](uint):loc_3D84o
.rdata:00006EA4                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int):loc_3F46o
.rdata:00006EA4                 unicode 0, <"Standard C++ Libraries Out of Range" && 0>,0
.rdata:00006EFA                 align 4
.rdata:00006EFA _rdata          ends
.rdata:00006EFA
.rdata:00006EFC ; ===========================================================================
.rdata:00006EFC
.rdata:00006EFC ; Segment type: Pure data
.rdata:00006EFC ; Segment permissions: Read
.rdata:00006EFC _rdata          segment dword public 'DATA' use32
.rdata:00006EFC                 assume cs:_rdata
.rdata:00006EFC                 ;org 6EFCh
.rdata:00006EFC ; COMDAT (pick any)
.rdata:00006EFC                 public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
.rdata:00006EFC ; `string'
.rdata:00006EFC ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
.rdata:00006EFC                                         ; DATA XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::operator[](uint)+3Do
.rdata:00006EFC                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int)+8Bo ...
.rdata:00006EFC                 unicode 0, <%s>,0
.rdata:00006F02                 align 4
.rdata:00006F02 _rdata          ends
.rdata:00006F02
.rdata:00006F04 ; ===========================================================================
.rdata:00006F04
.rdata:00006F04 ; Segment type: Pure data
.rdata:00006F04 ; Segment permissions: Read
.rdata:00006F04 _rdata          segment dword public 'DATA' use32
.rdata:00006F04                 assume cs:_rdata
.rdata:00006F04                 ;org 6F04h
.rdata:00006F04 ; COMDAT (pick any)
.rdata:00006F04                 public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
.rdata:00006F04 ; `string'
.rdata:00006F04 ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
.rdata:00006F04                                         ; DATA XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::operator[](uint)+6Fo
.rdata:00006F04                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int)+BDo
.rdata:00006F04                 unicode 0, <"out of range">,0
.rdata:00006F22                 align 4
.rdata:00006F22 _rdata          ends
.rdata:00006F22
.rdata:00006F24 ; ===========================================================================
.rdata:00006F24
.rdata:00006F24 ; Segment type: Pure data
.rdata:00006F24 ; Segment permissions: Read
.rdata:00006F24 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00006F24 _rdata          segment para public 'DATA' use32
.rdata:00006F24                 assume cs:_rdata
.rdata:00006F24                 ;org 6F24h
.rdata:00006F24 ; COMDAT (pick any)
.rdata:00006F24                 public ??_C@_1MM@CFLCIPDM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAp?$AAa?$AAi?$AAr?$AA?$DM?$AAi?$AAn?$AAt@
.rdata:00006F24 ; `string'
.rdata:00006F24 ??_C@_1MM@CFLCIPDM@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAp?$AAa?$AAi?$AAr?$AA?$DM?$AAi?$AAn?$AAt@:
.rdata:00006F24                                         ; DATA XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::operator[](uint)+6Ao
.rdata:00006F24                 unicode 0, <std::vector>
.rdata:00006F24                 dw 3Ch
.rdata:00006F24                 unicode 0, <struct std::pair>
.rdata:00006F24                 dw 3Ch
.rdata:00006F24                 unicode 0, <int,int>
.rdata:00006F24                 dw 3Eh
.rdata:00006F24                 unicode 0, <,class std::allocator>
.rdata:00006F24                 dw 3Ch
.rdata:00006F24                 unicode 0, <struct std::pair>
.rdata:00006F24                 dw 3Ch
.rdata:00006F24                 unicode 0, <int,int>
.rdata:00006F24                 dw 3Eh
.rdata:00006F24                 unicode 0, < >
.rdata:00006F24                 dw 3Eh
.rdata:00006F24                 unicode 0, < >
.rdata:00006F24                 dw 3Eh
.rdata:00006F24                 unicode 0, <::operator []>,0
.rdata:00006F24 _rdata          ends
.rdata:00006F24
.rdata:00006FF0 ; ===========================================================================
.rdata:00006FF0
.rdata:00006FF0 ; Segment type: Pure data
.rdata:00006FF0 ; Segment permissions: Read
.rdata:00006FF0 _rdata          segment dword public 'DATA' use32
.rdata:00006FF0                 assume cs:_rdata
.rdata:00006FF0                 ;org 6FF0h
.rdata:00006FF0 ; COMDAT (pick any)
.rdata:00006FF0                 public ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
.rdata:00006FF0 ; `string'
.rdata:00006FF0 ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ db 'Standard C++ Libraries Invalid Argument',0
.rdata:00006FF0                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>> const &)+41o
.rdata:00006FF0 _rdata          ends
.rdata:00006FF0
.rdata:00007018 ; ===========================================================================
.rdata:00007018
.rdata:00007018 ; Segment type: Pure data
.rdata:00007018 ; Segment permissions: Read
.rdata:00007018 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007018 _rdata          segment para public 'DATA' use32
.rdata:00007018                 assume cs:_rdata
.rdata:00007018                 ;org 7018h
.rdata:00007018 ; COMDAT (pick any)
.rdata:00007018                 public ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
.rdata:00007018 ; `string'
.rdata:00007018 ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@:
.rdata:00007018                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>> const &):loc_440Ao
.rdata:00007018                 unicode 0, <"Standard C++ Libraries Invalid Argument" && 0>,0
.rdata:00007076                 align 4
.rdata:00007076 _rdata          ends
.rdata:00007076
.rdata:00007078 ; ===========================================================================
.rdata:00007078
.rdata:00007078 ; Segment type: Pure data
.rdata:00007078 ; Segment permissions: Read
.rdata:00007078 _rdata          segment dword public 'DATA' use32
.rdata:00007078                 assume cs:_rdata
.rdata:00007078                 ;org 7078h
.rdata:00007078 ; COMDAT (pick any)
.rdata:00007078                 public ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
.rdata:00007078 ; `string'
.rdata:00007078 ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@:
.rdata:00007078                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>> const &)+85o
.rdata:00007078                 unicode 0, <"invalid argument">,0
.rdata:0000709E                 align 10h
.rdata:0000709E _rdata          ends
.rdata:0000709E
.rdata:000070A0 ; ===========================================================================
.rdata:000070A0
.rdata:000070A0 ; Segment type: Pure data
.rdata:000070A0 ; Segment permissions: Read
.rdata:000070A0 _rdata          segment dword public 'DATA' use32
.rdata:000070A0                 assume cs:_rdata
.rdata:000070A0                 ;org 70A0h
.rdata:000070A0 ; COMDAT (pick any)
.rdata:000070A0                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:000070A0 ; char `string'[]
.rdata:000070A0 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:000070A0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:000070A0 _rdata          ends
.rdata:000070A0
.rdata:000070B0 ; ===========================================================================
.rdata:000070B0
.rdata:000070B0 ; Segment type: Pure data
.rdata:000070B0 ; Segment permissions: Read
.rdata:000070B0 _rdata          segment dword public 'DATA' use32
.rdata:000070B0                 assume cs:_rdata
.rdata:000070B0                 ;org 70B0h
.rdata:000070B0 ; COMDAT (pick any)
.rdata:000070B0                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:000070B0 ; char `string'[]
.rdata:000070B0 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:000070B0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:000070B0 _rdata          ends
.rdata:000070B0
.rdata:000070C8 ; ===========================================================================
.rdata:000070C8
.rdata:000070C8 ; Segment type: Pure data
.rdata:000070C8 ; Segment permissions: Read
.rdata:000070C8 _rdata          segment dword public 'DATA' use32
.rdata:000070C8                 assume cs:_rdata
.rdata:000070C8                 ;org 70C8h
.rdata:000070C8 ; COMDAT (pick any)
.rdata:000070C8                 public ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
.rdata:000070C8 ; char `string'[]
.rdata:000070C8 ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ db 'vector<T> too long',0
.rdata:000070C8                                         ; DATA XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Xlen(void)+7o
.rdata:000070DB                 align 4
.rdata:000070DB _rdata          ends
.rdata:000070DB
.rdata:000070DC ; ===========================================================================
.rdata:000070DC
.rdata:000070DC ; Segment type: Pure data
.rdata:000070DC ; Segment permissions: Read
.rdata:000070DC ; Segment alignment 'qword' can not be represented in assembly
.rdata:000070DC _rdata          segment para public 'DATA' use32
.rdata:000070DC                 assume cs:_rdata
.rdata:000070DC                 ;org 70DCh
.rdata:000070DC ; COMDAT (pick any)
.rdata:000070DC                 public ??_C@_1EM@MEFKBKGF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
.rdata:000070DC ; wchar_t `string'
.rdata:000070DC ??_C@_1EM@MEFKBKGF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@:
.rdata:000070DC                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int)+6Co
.rdata:000070DC                 unicode 0, <string iterator + offset out of range>,0
.rdata:000070DC _rdata          ends
.rdata:000070DC
.rdata:00007128 ; ===========================================================================
.rdata:00007128
.rdata:00007128 ; Segment type: Pure data
.rdata:00007128 ; Segment permissions: Read
.rdata:00007128 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007128 _rdata          segment para public 'DATA' use32
.rdata:00007128                 assume cs:_rdata
.rdata:00007128                 ;org 7128h
.rdata:00007128 ; COMDAT (pick any)
.rdata:00007128                 public ??_C@_1MI@HNCOPGEL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:00007128 ; `string'
.rdata:00007128 ??_C@_1MI@HNCOPGEL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:00007128                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int)+B8o
.rdata:00007128                 unicode 0, <std::_String_const_iterator>
.rdata:00007128                 dw 3Ch
.rdata:00007128                 unicode 0, <class std::_String_val>
.rdata:00007128                 dw 3Ch
.rdata:00007128                 unicode 0, <struct std::_Simple_types>
.rdata:00007128                 dw 3Ch
.rdata:00007128                 unicode 0, <char>
.rdata:00007128                 dw 3Eh
.rdata:00007128                 unicode 0, < >
.rdata:00007128                 dw 3Eh
.rdata:00007128                 unicode 0, < >
.rdata:00007128                 dw 3Eh
.rdata:00007128                 unicode 0, <::operator +=>,0
.rdata:00007128 _rdata          ends
.rdata:00007128
.rdata:000071F0 ; ===========================================================================
.rdata:000071F0
.rdata:000071F0 ; Segment type: Pure data
.rdata:000071F0 ; Segment permissions: Read
.rdata:000071F0 _rdata          segment dword public 'DATA' use32
.rdata:000071F0                 assume cs:_rdata
.rdata:000071F0                 ;org 71F0h
.rdata:000071F0 ; COMDAT (pick any)
.rdata:000071F0                 public ??_C@_1DM@KDEKGMPF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
.rdata:000071F0 ; wchar_t `string'
.rdata:000071F0 ??_C@_1DM@KDEKGMPF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@:
.rdata:000071F0                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>> const &)+34o
.rdata:000071F0                 unicode 0, <string iterators incompatible>,0
.rdata:000071F0 _rdata          ends
.rdata:000071F0
.rdata:0000722C ; ===========================================================================
.rdata:0000722C
.rdata:0000722C ; Segment type: Pure data
.rdata:0000722C ; Segment permissions: Read
.rdata:0000722C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000722C _rdata          segment para public 'DATA' use32
.rdata:0000722C                 assume cs:_rdata
.rdata:0000722C                 ;org 722Ch
.rdata:0000722C ; COMDAT (pick any)
.rdata:0000722C                 public ??_C@_1MA@BDELDFHB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000722C ; `string'
.rdata:0000722C ??_C@_1MA@BDELDFHB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000722C                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>> const &)+80o
.rdata:0000722C                 unicode 0, <std::_String_const_iterator>
.rdata:0000722C                 dw 3Ch
.rdata:0000722C                 unicode 0, <class std::_String_val>
.rdata:0000722C                 dw 3Ch
.rdata:0000722C                 unicode 0, <struct std::_Simple_types>
.rdata:0000722C                 dw 3Ch
.rdata:0000722C                 unicode 0, <char>
.rdata:0000722C                 dw 3Eh
.rdata:0000722C                 unicode 0, < >
.rdata:0000722C                 dw 3Eh
.rdata:0000722C                 unicode 0, < >
.rdata:0000722C                 dw 3Eh
.rdata:0000722C                 unicode 0, <::_Compat>,0
.rdata:0000722C _rdata          ends
.rdata:0000722C
.rdata:000072EC ; ===========================================================================
.rdata:000072EC
.rdata:000072EC ; Segment type: Pure data
.rdata:000072EC ; Segment permissions: Read
.rdata:000072EC _rdata          segment dword public 'DATA' use32
.rdata:000072EC                 assume cs:_rdata
.rdata:000072EC                 ;org 72ECh
.rdata:000072EC ; COMDAT (pick any)
.rdata:000072EC                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:000072EC ; wchar_t `string'
.rdata:000072EC ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:000072EC                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:000072EC                                         ; std::_Debug_pointer<std::pair<int,int>>(std::pair<int,int> *,wchar_t const *,uint)+11o
.rdata:000072EC                 unicode 0, <invalid null pointer>,0
.rdata:00007316                 align 4
.rdata:00007316 _rdata          ends
.rdata:00007316
.rdata:00007318 ; ===========================================================================
.rdata:00007318
.rdata:00007318 ; Segment type: Pure data
.rdata:00007318 ; Segment permissions: Read
.rdata:00007318 _rdata          segment dword public 'DATA' use32
.rdata:00007318                 assume cs:_rdata
.rdata:00007318                 ;org 7318h
.rdata:00007318 ; COMDAT (pick any)
.rdata:00007318                 public ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:00007318 ; wchar_t `string'
.rdata:00007318 ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:00007318                                         ; DATA XREF: std::_Debug_range2<std::pair<int,int> *>(std::pair<int,int> *,std::pair<int,int> *,wchar_t const *,uint,std::random_access_iterator_tag)+43o
.rdata:00007318                 unicode 0, <invalid iterator range>,0
.rdata:00007346                 align 4
.rdata:00007346 _rdata          ends
.rdata:00007346
.rdata:00007348 ; ===========================================================================
.rdata:00007348
.rdata:00007348 ; Segment type: Pure data
.rdata:00007348 ; Segment permissions: Read
.rdata:00007348 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00007348 _rdata          segment para public 'DATA' use32
.rdata:00007348                 assume cs:_rdata
.rdata:00007348                 ;org 7348h
.rdata:00007348 ; COMDAT (pick any)
.rdata:00007348                 public ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00007348 ; wchar_t `string'
.rdata:00007348 ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00007348                                         ; DATA XREF: std::_Uninit_move<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int>>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &,std::pair<int,int> *,std::_Nonscalar_ptr_iterator_tag)+2Fo
.rdata:00007348                                         ; std::_Uninit_move<std::pair<int,int> *,std::pair<int,int> *,std::allocator<std::pair<int,int>>,std::pair<int,int>>(std::pair<int,int> *,std::pair<int,int> *,std::pair<int,int> *,std::_Wrap_alloc<std::allocator<std::pair<int,int>>> &,std::pair<int,int> *,std::_Nonscalar_ptr_iterator_tag)+49o
.rdata:00007348                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00007348                 unicode 0, <clude\xmemory>,0
.rdata:000073D6                 align 4
.rdata:000073D6 _rdata          ends
.rdata:000073D6
.rdata$r:000073D8 ; ===========================================================================
.rdata$r:000073D8
.rdata$r:000073D8 ; Segment type: Pure data
.rdata$r:000073D8 ; Segment permissions: Read
.rdata$r:000073D8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000073D8                 assume cs:_rdata$r
.rdata$r:000073D8                 ;org 73D8h
.rdata$r:000073D8 ; COMDAT (pick any)
.rdata$r:000073D8                 public ??_R4error_category@std@@6B@
.rdata$r:000073D8 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:000073D8 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00006C58o
.rdata$r:000073D9                 db    0
.rdata$r:000073DA                 db    0
.rdata$r:000073DB                 db    0
.rdata$r:000073DC                 db    0
.rdata$r:000073DD                 db    0
.rdata$r:000073DE                 db    0
.rdata$r:000073DF                 db    0
.rdata$r:000073E0                 db    0
.rdata$r:000073E1                 db    0
.rdata$r:000073E2                 db    0
.rdata$r:000073E3                 db    0
.rdata$r:000073E4                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:000073E8                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000073E8 _rdata$r        ends
.rdata$r:000073E8
.data$r:000073EC ; ===========================================================================
.data$r:000073EC
.data$r:000073EC ; Segment type: Pure data
.data$r:000073EC ; Segment permissions: Read/Write
.data$r:000073EC _data$r         segment dword public 'DATA' use32
.data$r:000073EC                 assume cs:_data$r
.data$r:000073EC                 ;org 73ECh
.data$r:000073EC ; COMDAT (pick any)
.data$r:000073EC                 public ??_R0?AVerror_category@std@@@8
.data$r:000073EC ; class std::error_category `RTTI Type Descriptor'
.data$r:000073EC ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000073EC                                         ; DATA XREF: .rdata$r:000073E4o
.data$r:000073EC                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000073EC                                         ; const type_info::`vftable'
.data$r:000073F0                 db    0
.data$r:000073F1                 db    0
.data$r:000073F2                 db    0
.data$r:000073F3                 db    0
.data$r:000073F4                 db  2Eh ; .
.data$r:000073F5                 db  3Fh ; ?
.data$r:000073F6                 db  41h ; A
.data$r:000073F7                 db  56h ; V
.data$r:000073F8                 db  65h ; e
.data$r:000073F9                 db  72h ; r
.data$r:000073FA                 db  72h ; r
.data$r:000073FB                 db  6Fh ; o
.data$r:000073FC                 db  72h ; r
.data$r:000073FD                 db  5Fh ; _
.data$r:000073FE                 db  63h ; c
.data$r:000073FF                 db  61h ; a
.data$r:00007400                 db  74h ; t
.data$r:00007401                 db  65h ; e
.data$r:00007402                 db  67h ; g
.data$r:00007403                 db  6Fh ; o
.data$r:00007404                 db  72h ; r
.data$r:00007405                 db  79h ; y
.data$r:00007406                 db  40h ; @
.data$r:00007407                 db  73h ; s
.data$r:00007408                 db  74h ; t
.data$r:00007409                 db  64h ; d
.data$r:0000740A                 db  40h ; @
.data$r:0000740B                 db  40h ; @
.data$r:0000740C                 db    0
.data$r:0000740D                 align 10h
.data$r:0000740D _data$r         ends
.data$r:0000740D
.rdata$r:00007410 ; ===========================================================================
.rdata$r:00007410
.rdata$r:00007410 ; Segment type: Pure data
.rdata$r:00007410 ; Segment permissions: Read
.rdata$r:00007410 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007410                 assume cs:_rdata$r
.rdata$r:00007410                 ;org 7410h
.rdata$r:00007410 ; COMDAT (pick any)
.rdata$r:00007410                 public ??_R3error_category@std@@8
.rdata$r:00007410 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007410 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:000073E8o
.rdata$r:00007410                                         ; .rdata$r:00007440o
.rdata$r:00007411                 db    0
.rdata$r:00007412                 db    0
.rdata$r:00007413                 db    0
.rdata$r:00007414                 db    0
.rdata$r:00007415                 db    0
.rdata$r:00007416                 db    0
.rdata$r:00007417                 db    0
.rdata$r:00007418                 db    1
.rdata$r:00007419                 db    0
.rdata$r:0000741A                 db    0
.rdata$r:0000741B                 db    0
.rdata$r:0000741C                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000741C _rdata$r        ends
.rdata$r:0000741C
.rdata$r:00007420 ; ===========================================================================
.rdata$r:00007420
.rdata$r:00007420 ; Segment type: Pure data
.rdata$r:00007420 ; Segment permissions: Read
.rdata$r:00007420 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007420                 assume cs:_rdata$r
.rdata$r:00007420                 ;org 7420h
.rdata$r:00007420 ; COMDAT (pick any)
.rdata$r:00007420                 public ??_R2error_category@std@@8
.rdata$r:00007420 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00007420 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00007420                                         ; DATA XREF: .rdata$r:0000741Co
.rdata$r:00007420                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00007424                 db    0
.rdata$r:00007425                 align 4
.rdata$r:00007425 _rdata$r        ends
.rdata$r:00007425
.rdata$r:00007428 ; ===========================================================================
.rdata$r:00007428
.rdata$r:00007428 ; Segment type: Pure data
.rdata$r:00007428 ; Segment permissions: Read
.rdata$r:00007428 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007428                 assume cs:_rdata$r
.rdata$r:00007428                 ;org 7428h
.rdata$r:00007428 ; COMDAT (pick any)
.rdata$r:00007428                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00007428 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00007428 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00007428                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00007428                                         ; .rdata$r:00007498o ...
.rdata$r:00007428                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000742C                 db    0
.rdata$r:0000742D                 db    0
.rdata$r:0000742E                 db    0
.rdata$r:0000742F                 db    0
.rdata$r:00007430                 db    0
.rdata$r:00007431                 db    0
.rdata$r:00007432                 db    0
.rdata$r:00007433                 db    0
.rdata$r:00007434                 db 0FFh
.rdata$r:00007435                 db 0FFh
.rdata$r:00007436                 db 0FFh
.rdata$r:00007437                 db 0FFh
.rdata$r:00007438                 db    0
.rdata$r:00007439                 db    0
.rdata$r:0000743A                 db    0
.rdata$r:0000743B                 db    0
.rdata$r:0000743C                 db  40h ; @
.rdata$r:0000743D                 db    0
.rdata$r:0000743E                 db    0
.rdata$r:0000743F                 db    0
.rdata$r:00007440                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007440 _rdata$r        ends
.rdata$r:00007440
.rdata$r:00007444 ; ===========================================================================
.rdata$r:00007444
.rdata$r:00007444 ; Segment type: Pure data
.rdata$r:00007444 ; Segment permissions: Read
.rdata$r:00007444 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007444                 assume cs:_rdata$r
.rdata$r:00007444                 ;org 7444h
.rdata$r:00007444 ; COMDAT (pick any)
.rdata$r:00007444                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00007444 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00007444 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00007444                                         ; DATA XREF: .rdata:00006C74o
.rdata$r:00007445                 db    0
.rdata$r:00007446                 db    0
.rdata$r:00007447                 db    0
.rdata$r:00007448                 db    0
.rdata$r:00007449                 db    0
.rdata$r:0000744A                 db    0
.rdata$r:0000744B                 db    0
.rdata$r:0000744C                 db    0
.rdata$r:0000744D                 db    0
.rdata$r:0000744E                 db    0
.rdata$r:0000744F                 db    0
.rdata$r:00007450                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00007454                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007454 _rdata$r        ends
.rdata$r:00007454
.data$r:00007458 ; ===========================================================================
.data$r:00007458
.data$r:00007458 ; Segment type: Pure data
.data$r:00007458 ; Segment permissions: Read/Write
.data$r:00007458 _data$r         segment dword public 'DATA' use32
.data$r:00007458                 assume cs:_data$r
.data$r:00007458                 ;org 7458h
.data$r:00007458 ; COMDAT (pick any)
.data$r:00007458                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00007458 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00007458 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00007458                                         ; DATA XREF: .rdata$r:00007450o
.data$r:00007458                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00007458                                         ; const type_info::`vftable'
.data$r:0000745C                 align 10h
.data$r:00007460 a_?av_generic_e db '.?AV_Generic_error_category@std@@',0
.data$r:00007482                 align 4
.data$r:00007482 _data$r         ends
.data$r:00007482
.rdata$r:00007484 ; ===========================================================================
.rdata$r:00007484
.rdata$r:00007484 ; Segment type: Pure data
.rdata$r:00007484 ; Segment permissions: Read
.rdata$r:00007484 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007484                 assume cs:_rdata$r
.rdata$r:00007484                 ;org 7484h
.rdata$r:00007484 ; COMDAT (pick any)
.rdata$r:00007484                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00007484 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007484 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00007484                                         ; DATA XREF: .rdata$r:00007454o
.rdata$r:00007484                                         ; .rdata$r:000074B8o
.rdata$r:00007485                 db    0
.rdata$r:00007486                 db    0
.rdata$r:00007487                 db    0
.rdata$r:00007488                 db    0
.rdata$r:00007489                 db    0
.rdata$r:0000748A                 db    0
.rdata$r:0000748B                 db    0
.rdata$r:0000748C                 db    2
.rdata$r:0000748D                 db    0
.rdata$r:0000748E                 db    0
.rdata$r:0000748F                 db    0
.rdata$r:00007490                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00007490 _rdata$r        ends
.rdata$r:00007490
.rdata$r:00007494 ; ===========================================================================
.rdata$r:00007494
.rdata$r:00007494 ; Segment type: Pure data
.rdata$r:00007494 ; Segment permissions: Read
.rdata$r:00007494 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007494                 assume cs:_rdata$r
.rdata$r:00007494                 ;org 7494h
.rdata$r:00007494 ; COMDAT (pick any)
.rdata$r:00007494                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00007494 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00007494 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00007494                                         ; DATA XREF: .rdata$r:00007490o
.rdata$r:00007494                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00007498                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000749C                 db    0
.rdata$r:0000749D                 align 10h
.rdata$r:0000749D _rdata$r        ends
.rdata$r:0000749D
.rdata$r:000074A0 ; ===========================================================================
.rdata$r:000074A0
.rdata$r:000074A0 ; Segment type: Pure data
.rdata$r:000074A0 ; Segment permissions: Read
.rdata$r:000074A0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000074A0                 assume cs:_rdata$r
.rdata$r:000074A0                 ;org 74A0h
.rdata$r:000074A0 ; COMDAT (pick any)
.rdata$r:000074A0                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:000074A0 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000074A0 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:000074A0                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:000074A0                                         ; .rdata$r:00007510o ...
.rdata$r:000074A0                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:000074A4                 db    1
.rdata$r:000074A5                 db    0
.rdata$r:000074A6                 db    0
.rdata$r:000074A7                 db    0
.rdata$r:000074A8                 db    0
.rdata$r:000074A9                 db    0
.rdata$r:000074AA                 db    0
.rdata$r:000074AB                 db    0
.rdata$r:000074AC                 db 0FFh
.rdata$r:000074AD                 db 0FFh
.rdata$r:000074AE                 db 0FFh
.rdata$r:000074AF                 db 0FFh
.rdata$r:000074B0                 db    0
.rdata$r:000074B1                 db    0
.rdata$r:000074B2                 db    0
.rdata$r:000074B3                 db    0
.rdata$r:000074B4                 db  40h ; @
.rdata$r:000074B5                 db    0
.rdata$r:000074B6                 db    0
.rdata$r:000074B7                 db    0
.rdata$r:000074B8                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000074B8 _rdata$r        ends
.rdata$r:000074B8
.rdata$r:000074BC ; ===========================================================================
.rdata$r:000074BC
.rdata$r:000074BC ; Segment type: Pure data
.rdata$r:000074BC ; Segment permissions: Read
.rdata$r:000074BC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000074BC                 assume cs:_rdata$r
.rdata$r:000074BC                 ;org 74BCh
.rdata$r:000074BC ; COMDAT (pick any)
.rdata$r:000074BC                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:000074BC ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:000074BC ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:000074BC                                         ; DATA XREF: .rdata:00006CA8o
.rdata$r:000074BD                 db    0
.rdata$r:000074BE                 db    0
.rdata$r:000074BF                 db    0
.rdata$r:000074C0                 db    0
.rdata$r:000074C1                 db    0
.rdata$r:000074C2                 db    0
.rdata$r:000074C3                 db    0
.rdata$r:000074C4                 db    0
.rdata$r:000074C5                 db    0
.rdata$r:000074C6                 db    0
.rdata$r:000074C7                 db    0
.rdata$r:000074C8                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:000074CC                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000074CC _rdata$r        ends
.rdata$r:000074CC
.data$r:000074D0 ; ===========================================================================
.data$r:000074D0
.data$r:000074D0 ; Segment type: Pure data
.data$r:000074D0 ; Segment permissions: Read/Write
.data$r:000074D0 _data$r         segment dword public 'DATA' use32
.data$r:000074D0                 assume cs:_data$r
.data$r:000074D0                 ;org 74D0h
.data$r:000074D0 ; COMDAT (pick any)
.data$r:000074D0                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:000074D0 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:000074D0 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000074D0                                         ; DATA XREF: .rdata$r:000074C8o
.data$r:000074D0                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000074D0                                         ; const type_info::`vftable'
.data$r:000074D4                 align 8
.data$r:000074D8 a_?av_iostream_ db '.?AV_Iostream_error_category@std@@',0
.data$r:000074FB                 align 4
.data$r:000074FB _data$r         ends
.data$r:000074FB
.rdata$r:000074FC ; ===========================================================================
.rdata$r:000074FC
.rdata$r:000074FC ; Segment type: Pure data
.rdata$r:000074FC ; Segment permissions: Read
.rdata$r:000074FC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000074FC                 assume cs:_rdata$r
.rdata$r:000074FC                 ;org 74FCh
.rdata$r:000074FC ; COMDAT (pick any)
.rdata$r:000074FC                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:000074FC ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000074FC ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:000074FC                                         ; DATA XREF: .rdata$r:000074CCo
.rdata$r:000074FC                                         ; .rdata$r:00007534o
.rdata$r:000074FD                 db    0
.rdata$r:000074FE                 db    0
.rdata$r:000074FF                 db    0
.rdata$r:00007500                 db    0
.rdata$r:00007501                 db    0
.rdata$r:00007502                 db    0
.rdata$r:00007503                 db    0
.rdata$r:00007504                 db    3
.rdata$r:00007505                 db    0
.rdata$r:00007506                 db    0
.rdata$r:00007507                 db    0
.rdata$r:00007508                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00007508 _rdata$r        ends
.rdata$r:00007508
.rdata$r:0000750C ; ===========================================================================
.rdata$r:0000750C
.rdata$r:0000750C ; Segment type: Pure data
.rdata$r:0000750C ; Segment permissions: Read
.rdata$r:0000750C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000750C                 assume cs:_rdata$r
.rdata$r:0000750C                 ;org 750Ch
.rdata$r:0000750C ; COMDAT (pick any)
.rdata$r:0000750C                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:0000750C ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000750C ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000750C                                         ; DATA XREF: .rdata$r:00007508o
.rdata$r:0000750C                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00007510                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00007514                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00007518                 db    0
.rdata$r:00007519                 align 4
.rdata$r:00007519 _rdata$r        ends
.rdata$r:00007519
.rdata$r:0000751C ; ===========================================================================
.rdata$r:0000751C
.rdata$r:0000751C ; Segment type: Pure data
.rdata$r:0000751C ; Segment permissions: Read
.rdata$r:0000751C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000751C                 assume cs:_rdata$r
.rdata$r:0000751C                 ;org 751Ch
.rdata$r:0000751C ; COMDAT (pick any)
.rdata$r:0000751C                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000751C ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000751C ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:0000751C                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:0000751C                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00007520                 db    2
.rdata$r:00007521                 db    0
.rdata$r:00007522                 db    0
.rdata$r:00007523                 db    0
.rdata$r:00007524                 db    0
.rdata$r:00007525                 db    0
.rdata$r:00007526                 db    0
.rdata$r:00007527                 db    0
.rdata$r:00007528                 db 0FFh
.rdata$r:00007529                 db 0FFh
.rdata$r:0000752A                 db 0FFh
.rdata$r:0000752B                 db 0FFh
.rdata$r:0000752C                 db    0
.rdata$r:0000752D                 db    0
.rdata$r:0000752E                 db    0
.rdata$r:0000752F                 db    0
.rdata$r:00007530                 db  40h ; @
.rdata$r:00007531                 db    0
.rdata$r:00007532                 db    0
.rdata$r:00007533                 db    0
.rdata$r:00007534                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007534 _rdata$r        ends
.rdata$r:00007534
.rdata$r:00007538 ; ===========================================================================
.rdata$r:00007538
.rdata$r:00007538 ; Segment type: Pure data
.rdata$r:00007538 ; Segment permissions: Read
.rdata$r:00007538 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007538                 assume cs:_rdata$r
.rdata$r:00007538                 ;org 7538h
.rdata$r:00007538 ; COMDAT (pick any)
.rdata$r:00007538                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00007538 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00007538 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00006CE8o
.rdata$r:00007539                 db    0
.rdata$r:0000753A                 db    0
.rdata$r:0000753B                 db    0
.rdata$r:0000753C                 db    0
.rdata$r:0000753D                 db    0
.rdata$r:0000753E                 db    0
.rdata$r:0000753F                 db    0
.rdata$r:00007540                 db    0
.rdata$r:00007541                 db    0
.rdata$r:00007542                 db    0
.rdata$r:00007543                 db    0
.rdata$r:00007544                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00007548                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007548 _rdata$r        ends
.rdata$r:00007548
.data$r:0000754C ; ===========================================================================
.data$r:0000754C
.data$r:0000754C ; Segment type: Pure data
.data$r:0000754C ; Segment permissions: Read/Write
.data$r:0000754C _data$r         segment dword public 'DATA' use32
.data$r:0000754C                 assume cs:_data$r
.data$r:0000754C                 ;org 754Ch
.data$r:0000754C ; COMDAT (pick any)
.data$r:0000754C                 public ??_R0?AV_System_error_category@std@@@8
.data$r:0000754C ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:0000754C ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000754C                                         ; DATA XREF: .rdata$r:00007544o
.data$r:0000754C                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000754C                                         ; const type_info::`vftable'
.data$r:00007550                 db    0
.data$r:00007551                 db    0
.data$r:00007552                 db    0
.data$r:00007553                 db    0
.data$r:00007554                 db  2Eh ; .
.data$r:00007555                 db  3Fh ; ?
.data$r:00007556                 db  41h ; A
.data$r:00007557                 db  56h ; V
.data$r:00007558                 db  5Fh ; _
.data$r:00007559                 db  53h ; S
.data$r:0000755A                 db  79h ; y
.data$r:0000755B                 db  73h ; s
.data$r:0000755C                 db  74h ; t
.data$r:0000755D                 db  65h ; e
.data$r:0000755E                 db  6Dh ; m
.data$r:0000755F                 db  5Fh ; _
.data$r:00007560                 db  65h ; e
.data$r:00007561                 db  72h ; r
.data$r:00007562                 db  72h ; r
.data$r:00007563                 db  6Fh ; o
.data$r:00007564                 db  72h ; r
.data$r:00007565                 db  5Fh ; _
.data$r:00007566                 db  63h ; c
.data$r:00007567                 db  61h ; a
.data$r:00007568                 db  74h ; t
.data$r:00007569                 db  65h ; e
.data$r:0000756A                 db  67h ; g
.data$r:0000756B                 db  6Fh ; o
.data$r:0000756C                 db  72h ; r
.data$r:0000756D                 db  79h ; y
.data$r:0000756E                 db  40h ; @
.data$r:0000756F                 db  73h ; s
.data$r:00007570                 db  74h ; t
.data$r:00007571                 db  64h ; d
.data$r:00007572                 db  40h ; @
.data$r:00007573                 db  40h ; @
.data$r:00007574                 db    0
.data$r:00007575                 align 4
.data$r:00007575 _data$r         ends
.data$r:00007575
.rdata$r:00007578 ; ===========================================================================
.rdata$r:00007578
.rdata$r:00007578 ; Segment type: Pure data
.rdata$r:00007578 ; Segment permissions: Read
.rdata$r:00007578 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007578                 assume cs:_rdata$r
.rdata$r:00007578                 ;org 7578h
.rdata$r:00007578 ; COMDAT (pick any)
.rdata$r:00007578                 public ??_R3_System_error_category@std@@8
.rdata$r:00007578 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00007578 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00007548o
.rdata$r:00007578                                         ; .rdata$r:000075B0o
.rdata$r:00007579                 db    0
.rdata$r:0000757A                 db    0
.rdata$r:0000757B                 db    0
.rdata$r:0000757C                 db    0
.rdata$r:0000757D                 db    0
.rdata$r:0000757E                 db    0
.rdata$r:0000757F                 db    0
.rdata$r:00007580                 db    3
.rdata$r:00007581                 db    0
.rdata$r:00007582                 db    0
.rdata$r:00007583                 db    0
.rdata$r:00007584                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00007584 _rdata$r        ends
.rdata$r:00007584
.rdata$r:00007588 ; ===========================================================================
.rdata$r:00007588
.rdata$r:00007588 ; Segment type: Pure data
.rdata$r:00007588 ; Segment permissions: Read
.rdata$r:00007588 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007588                 assume cs:_rdata$r
.rdata$r:00007588                 ;org 7588h
.rdata$r:00007588 ; COMDAT (pick any)
.rdata$r:00007588                 public ??_R2_System_error_category@std@@8
.rdata$r:00007588 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00007588 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00007588                                         ; DATA XREF: .rdata$r:00007584o
.rdata$r:00007588                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000758C                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00007590                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00007594                 db    0
.rdata$r:00007595                 align 4
.rdata$r:00007595 _rdata$r        ends
.rdata$r:00007595
.rdata$r:00007598 ; ===========================================================================
.rdata$r:00007598
.rdata$r:00007598 ; Segment type: Pure data
.rdata$r:00007598 ; Segment permissions: Read
.rdata$r:00007598 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00007598                 assume cs:_rdata$r
.rdata$r:00007598                 ;org 7598h
.rdata$r:00007598 ; COMDAT (pick any)
.rdata$r:00007598                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00007598 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00007598 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00007598                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00007598                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000759C                 db    2
.rdata$r:0000759D                 db    0
.rdata$r:0000759E                 db    0
.rdata$r:0000759F                 db    0
.rdata$r:000075A0                 db    0
.rdata$r:000075A1                 db    0
.rdata$r:000075A2                 db    0
.rdata$r:000075A3                 db    0
.rdata$r:000075A4                 db 0FFh
.rdata$r:000075A5                 db 0FFh
.rdata$r:000075A6                 db 0FFh
.rdata$r:000075A7                 db 0FFh
.rdata$r:000075A8                 db    0
.rdata$r:000075A9                 db    0
.rdata$r:000075AA                 db    0
.rdata$r:000075AB                 db    0
.rdata$r:000075AC                 db  40h ; @
.rdata$r:000075AD                 db    0
.rdata$r:000075AE                 db    0
.rdata$r:000075AF                 db    0
.rdata$r:000075B0                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000075B0 _rdata$r        ends
.rdata$r:000075B0
.CRT$XCU:000075B4 ; ===========================================================================
.CRT$XCU:000075B4
.CRT$XCU:000075B4 ; Segment type: Pure data
.CRT$XCU:000075B4 ; Segment permissions: Read
.CRT$XCU:000075B4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000075B4                 assume cs:_CRT$XCU
.CRT$XCU:000075B4                 ;org 75B4h
.CRT$XCU:000075B4 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:000075B8 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:000075BC _ignore$initializer$ dd offset ??__Eignore@std@@YAXXZ ; std::`dynamic initializer for 'ignore''(void)
.CRT$XCU:000075C0 __Tuple_alloc$initializer$ dd offset ??__E_Tuple_alloc@std@@YAXXZ ; std::`dynamic initializer for '_Tuple_alloc''(void)
.CRT$XCU:000075C0 _CRT$XCU        ends
.CRT$XCU:000075C0
.CRT$XCU:000075C4 ; ===========================================================================
.CRT$XCU:000075C4
.CRT$XCU:000075C4 ; Segment type: Pure data
.CRT$XCU:000075C4 ; Segment permissions: Read
.CRT$XCU:000075C4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000075C4                 assume cs:_CRT$XCU
.CRT$XCU:000075C4                 ;org 75C4h
.CRT$XCU:000075C4 ; COMDAT (pick associative to section at 6D0C)
.CRT$XCU:000075C4 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:000075C4 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:000075C4 _CRT$XCU        ends
.CRT$XCU:000075C4
.CRT$XCU:000075C8 ; ===========================================================================
.CRT$XCU:000075C8
.CRT$XCU:000075C8 ; Segment type: Pure data
.CRT$XCU:000075C8 ; Segment permissions: Read
.CRT$XCU:000075C8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000075C8                 assume cs:_CRT$XCU
.CRT$XCU:000075C8                 ;org 75C8h
.CRT$XCU:000075C8 ; COMDAT (pick associative to section at 6D10)
.CRT$XCU:000075C8 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:000075C8 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:000075C8 _CRT$XCU        ends
.CRT$XCU:000075C8
.CRT$XCU:000075CC ; ===========================================================================
.CRT$XCU:000075CC
.CRT$XCU:000075CC ; Segment type: Pure data
.CRT$XCU:000075CC ; Segment permissions: Read
.CRT$XCU:000075CC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000075CC                 assume cs:_CRT$XCU
.CRT$XCU:000075CC                 ;org 75CCh
.CRT$XCU:000075CC ; COMDAT (pick associative to section at 6D14)
.CRT$XCU:000075CC ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:000075CC ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:000075CC _CRT$XCU        ends
.CRT$XCU:000075CC
.CRT$XCU:000075D0 ; ===========================================================================
.CRT$XCU:000075D0
.CRT$XCU:000075D0 ; Segment type: Pure data
.CRT$XCU:000075D0 ; Segment permissions: Read
.CRT$XCU:000075D0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000075D0                 assume cs:_CRT$XCU
.CRT$XCU:000075D0                 ;org 75D0h
.CRT$XCU:000075D0 ; COMDAT (pick associative to section at 6D18)
.CRT$XCU:000075D0 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:000075D0 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:000075D0 _CRT$XCU        ends
.CRT$XCU:000075D0
.CRT$XCU:000075D4 ; ===========================================================================
.CRT$XCU:000075D4
.CRT$XCU:000075D4 ; Segment type: Pure data
.CRT$XCU:000075D4 ; Segment permissions: Read
.CRT$XCU:000075D4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000075D4                 assume cs:_CRT$XCU
.CRT$XCU:000075D4                 ;org 75D4h
.CRT$XCU:000075D4 ; COMDAT (pick associative to section at 6D1C)
.CRT$XCU:000075D4 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:000075D4 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:000075D4 _CRT$XCU        ends
.CRT$XCU:000075D4
.CRT$XCU:000075D8 ; ===========================================================================
.CRT$XCU:000075D8
.CRT$XCU:000075D8 ; Segment type: Pure data
.CRT$XCU:000075D8 ; Segment permissions: Read
.CRT$XCU:000075D8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000075D8                 assume cs:_CRT$XCU
.CRT$XCU:000075D8                 ;org 75D8h
.CRT$XCU:000075D8 ; COMDAT (pick associative to section at 6DB0)
.CRT$XCU:000075D8 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:000075D8 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:000075D8 _CRT$XCU        ends
.CRT$XCU:000075D8
.CRT$XCU:000075DC ; ===========================================================================
.CRT$XCU:000075DC
.CRT$XCU:000075DC ; Segment type: Pure data
.CRT$XCU:000075DC ; Segment permissions: Read
.CRT$XCU:000075DC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000075DC                 assume cs:_CRT$XCU
.CRT$XCU:000075DC                 ;org 75DCh
.CRT$XCU:000075DC ; COMDAT (pick associative to section at 6DB4)
.CRT$XCU:000075DC ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:000075DC ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:000075DC _CRT$XCU        ends
.CRT$XCU:000075DC
UNDEF:000075E0 ; ===========================================================================
UNDEF:000075E0
UNDEF:000075E0 ; Segment type: Externs
UNDEF:000075E0 ; UNDEF
UNDEF:000075E0                 extrn __purecall:near   ; DATA XREF: .rdata:00006C60o
UNDEF:000075E0                                         ; .rdata:00006C64o
UNDEF:000075E4 ; void *__cdecl operator new(unsigned int)
UNDEF:000075E4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:000075E4                                         ; std::_Allocate<std::pair<int,int>>(uint,std::pair<int,int> *)+23p ...
UNDEF:000075E8 ; void __cdecl operator delete(void *)
UNDEF:000075E8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:000075E8                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:000075EC ; int __cdecl atexit(void (__cdecl *)())
UNDEF:000075EC                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:000075EC                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:000075F0                 extrn __invalid_parameter:near
UNDEF:000075F0                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::operator[](uint)+74p
UNDEF:000075F0                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int)+C2p ...
UNDEF:000075F4 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:000075F4                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:000075F4                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+2Dp
UNDEF:000075F4                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+55p ...
UNDEF:000075F8 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:000075F8                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:000075F8                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+4Bp
UNDEF:000075F8                                         ; __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0+3j ...
UNDEF:000075FC                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00007600 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00007600                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00007604 ; void *__cdecl memset(void *Dst, int Val, size_t Size)
UNDEF:00007604                 extrn _memset:near      ; CODE XREF: std::char_traits<char>::assign(char *,uint,char)+10p
UNDEF:00007608 ; size_t __cdecl strlen(const char *Str)
UNDEF:00007608                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:0000760C ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:0000760C                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:00007610 ; void __cdecl operator delete[](void *)
UNDEF:00007610                 extrn ??_V@YAXPAX@Z:near
UNDEF:00007610                                         ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+21Dp
UNDEF:00007614 ; void *__cdecl operator new[](unsigned int)
UNDEF:00007614                 extrn ??_U@YAPAXI@Z:near
UNDEF:00007614                                         ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+51p
UNDEF:00007618                 extrn __CrtDbgReportW:near
UNDEF:00007618                                         ; CODE XREF: std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::operator[](uint)+50p
UNDEF:00007618                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char>>>::operator+=(int)+9Ep ...
UNDEF:0000761C ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:0000761C                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:0000761C                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:0000761C                                         ; std::_Debug_pointer<std::pair<int,int>>(std::pair<int,int> *,wchar_t const *,uint)+16p ...
UNDEF:00007620 ; void __cdecl std::_Xbad_alloc()
UNDEF:00007620                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00007620                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_2402p
UNDEF:00007620                                         ; std::_Allocate<std::pair<int,int>>(uint,std::pair<int,int> *):loc_2444p ...
UNDEF:00007624 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00007624                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00007624                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00007624                                         ; std::vector<std::pair<int,int>,std::allocator<std::pair<int,int>>>::_Xlen(void)+Cp
UNDEF:00007628 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00007628                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00007628                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:0000762C ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000762C                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000762C                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00007630 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00007630                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00007630                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00007630                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00007634 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00007634                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00007634                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00007638 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00007638                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00007638                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:0000763C ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000763C                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000763C                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00007640 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00007640                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00007640                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00007644 ; void __thiscall ScintillaEditView::getText(ScintillaEditView *__hidden this, char *, int, int)
UNDEF:00007644                 extrn ?getText@ScintillaEditView@@QBEXPADHH@Z:near
UNDEF:00007644                                         ; CODE XREF: XmlMatchedTagsHighlighter::getAttributesPos(int,int)+73p
UNDEF:00007648 ; __fastcall __security_check_cookie(x)
UNDEF:00007648                 extrn @__security_check_cookie@4:near
UNDEF:00007648                                         ; CODE XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+4CBp
UNDEF:00007648                                         ; XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+7C0p ...
UNDEF:0000764C ; __stdcall _CxxThrowException(x, x)
UNDEF:0000764C                 extrn __CxxThrowException@8:near
UNDEF:0000764C                                         ; CODE XREF: __catch$??$_Uninit_move@PAU?$pair@HH@std@@PAU12@V?$allocator@U?$pair@HH@std@@@2@U12@@std@@YAPAU?$pair@HH@0@PAU10@00AAU?$_Wrap_alloc@V?$allocator@U?$pair@HH@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+25p
UNDEF:0000764C                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p ...
UNDEF:00007650                 extrn ___CxxFrameHandler3:near
UNDEF:00007650                                         ; CODE XREF: __ehhandler$?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z+23j
UNDEF:00007650                                         ; __ehhandler$?getXmlMatchedTagsPos@XmlMatchedTagsHighlighter@@AAE_NAAUXmlMatchedTagsPos@1@@Z+23j ...
UNDEF:00007654 ; const type_info::`vftable'
UNDEF:00007654                 extrn ??_7type_info@@6B@:near
UNDEF:00007654                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:00007654                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:00007658                 extrn ___security_cookie:near
UNDEF:00007658                                         ; DATA XREF: XmlMatchedTagsHighlighter::tagMatch(bool)+17r
UNDEF:00007658                                         ; XmlMatchedTagsHighlighter::getXmlMatchedTagsPos(XmlMatchedTagsHighlighter::XmlMatchedTagsPos &)+17r ...
UNDEF:0000765C                 extrn __fltused:near
UNDEF:0000765C
UNDEF:0000765C
UNDEF:0000765C                 end