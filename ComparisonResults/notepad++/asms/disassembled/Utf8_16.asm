.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 5BE90B8F43C8D12716A0809559BC7A42
.rdata:00000000 ; Input CRC32 : CF9BC9E7
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\Utf8_16.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000                 public ?k_Boms@Utf8_16@@2QAY02$$CBEA
.rdata:00000000 ; public: static unsigned char const (* Utf8_16::k_Boms)[3]
.rdata:00000000 ?k_Boms@Utf8_16@@2QAY02$$CBEA db 0      ; DATA XREF: Utf8_16_Read::determineEncoding(uchar const *,int)+27r
.rdata:00000000                                         ; Utf8_16_Read::determineEncoding(uchar const *,int)+51r ...
.rdata:00000001                 db    0
.rdata:00000002                 db    0
.rdata:00000003                 db 0EFh ; n
.rdata:00000004                 db 0BBh ; +
.rdata:00000005                 db 0BFh ; +
.rdata:00000006                 db 0FEh ; ¦
.rdata:00000007                 db 0FFh
.rdata:00000008                 db    0
.rdata:00000009                 db 0FFh
.rdata:0000000A                 db 0FEh ; ¦
.rdata:0000000B                 db    0
.rdata:0000000C                 db    0
.rdata:0000000D                 db    0
.rdata:0000000E                 db    0
.rdata:0000000F                 db    0
.rdata:00000010                 db    0
.rdata:00000011                 db    0
.rdata:00000012                 db    0
.rdata:00000013                 db    0
.rdata:00000014                 db    0
.rdata:00000015                 db    0
.rdata:00000016                 db    0
.rdata:00000017                 db    0
.rdata:00000017 _rdata          ends
.rdata:00000017
.text$mn:00000018 ; ===========================================================================
.text$mn:00000018
.text$mn:00000018 ; Segment type: Pure code
.text$mn:00000018 ; Segment permissions: Read/Execute
.text$mn:00000018 _text$mn        segment para public 'CODE' use32
.text$mn:00000018                 assume cs:_text$mn
.text$mn:00000018                 ;org 18h
.text$mn:00000018                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000018
.text$mn:00000018 ; =============== S U B R O U T I N E =======================================
.text$mn:00000018
.text$mn:00000018 ; Attributes: bp-based frame
.text$mn:00000018
.text$mn:00000018 ; public: __thiscall Utf16_Iter::Utf16_Iter(void)
.text$mn:00000018                 public ??0Utf16_Iter@@QAE@XZ
.text$mn:00000018 ??0Utf16_Iter@@QAE@XZ proc near         ; CODE XREF: Utf8_16_Read::Utf8_16_Read(void)+Dp
.text$mn:00000018
.text$mn:00000018 var_4           = dword ptr -4
.text$mn:00000018
.text$mn:00000018                 push    ebp
.text$mn:00000019                 mov     ebp, esp
.text$mn:0000001B                 push    ecx
.text$mn:0000001C                 mov     [ebp+var_4], ecx
.text$mn:0000001F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000022                 call    ?reset@Utf16_Iter@@QAEXXZ ; Utf16_Iter::reset(void)
.text$mn:00000027                 mov     eax, [ebp+var_4]
.text$mn:0000002A                 mov     esp, ebp
.text$mn:0000002C                 pop     ebp
.text$mn:0000002D                 retn
.text$mn:0000002D ??0Utf16_Iter@@QAE@XZ endp
.text$mn:0000002D
.text$mn:0000002D ; ---------------------------------------------------------------------------
.text$mn:0000002E                 db 0Ah dup(0CCh)
.text$mn:00000038
.text$mn:00000038 ; =============== S U B R O U T I N E =======================================
.text$mn:00000038
.text$mn:00000038 ; Attributes: bp-based frame
.text$mn:00000038
.text$mn:00000038 ; void __thiscall Utf16_Iter::reset(Utf16_Iter *__hidden this)
.text$mn:00000038                 public ?reset@Utf16_Iter@@QAEXXZ
.text$mn:00000038 ?reset@Utf16_Iter@@QAEXXZ proc near     ; CODE XREF: Utf16_Iter::Utf16_Iter(void)+Ap
.text$mn:00000038
.text$mn:00000038 var_4           = dword ptr -4
.text$mn:00000038
.text$mn:00000038                 push    ebp
.text$mn:00000039                 mov     ebp, esp
.text$mn:0000003B                 push    ecx
.text$mn:0000003C                 mov     [ebp+var_4], ecx
.text$mn:0000003F                 mov     eax, [ebp+var_4]
.text$mn:00000042                 mov     dword ptr [eax+0Ch], 0
.text$mn:00000049                 mov     ecx, [ebp+var_4]
.text$mn:0000004C                 mov     dword ptr [ecx+10h], 0
.text$mn:00000053                 mov     edx, [ebp+var_4]
.text$mn:00000056                 mov     dword ptr [edx+14h], 0
.text$mn:0000005D                 mov     eax, [ebp+var_4]
.text$mn:00000060                 mov     dword ptr [eax+4], 0
.text$mn:00000067                 mov     ecx, [ebp+var_4]
.text$mn:0000006A                 mov     byte ptr [ecx+8], 0
.text$mn:0000006E                 xor     edx, edx
.text$mn:00000070                 mov     eax, [ebp+var_4]
.text$mn:00000073                 mov     [eax+0Ah], dx
.text$mn:00000077                 mov     ecx, [ebp+var_4]
.text$mn:0000007A                 mov     dword ptr [ecx], 0
.text$mn:00000080                 mov     esp, ebp
.text$mn:00000082                 pop     ebp
.text$mn:00000083                 retn
.text$mn:00000083 ?reset@Utf16_Iter@@QAEXXZ endp
.text$mn:00000083
.text$mn:00000083 ; ---------------------------------------------------------------------------
.text$mn:00000084                 align 8
.text$mn:00000088
.text$mn:00000088 ; =============== S U B R O U T I N E =======================================
.text$mn:00000088
.text$mn:00000088 ; Attributes: bp-based frame
.text$mn:00000088
.text$mn:00000088 ; public: void __thiscall Utf16_Iter::set(unsigned char const *, unsigned int, enum  UniMode)
.text$mn:00000088                 public ?set@Utf16_Iter@@QAEXPBEIW4UniMode@@@Z
.text$mn:00000088 ?set@Utf16_Iter@@QAEXPBEIW4UniMode@@@Z proc near
.text$mn:00000088                                         ; CODE XREF: Utf8_16_Read::convert(char *,uint)+14Bp
.text$mn:00000088
.text$mn:00000088 var_4           = dword ptr -4
.text$mn:00000088 arg_0           = dword ptr  8
.text$mn:00000088 arg_4           = dword ptr  0Ch
.text$mn:00000088 arg_8           = dword ptr  10h
.text$mn:00000088
.text$mn:00000088                 push    ebp
.text$mn:00000089                 mov     ebp, esp
.text$mn:0000008B                 push    ecx
.text$mn:0000008C                 mov     [ebp+var_4], ecx
.text$mn:0000008F                 mov     eax, [ebp+var_4]
.text$mn:00000092                 mov     ecx, [ebp+arg_0]
.text$mn:00000095                 mov     [eax+0Ch], ecx
.text$mn:00000098                 mov     edx, [ebp+var_4]
.text$mn:0000009B                 mov     eax, [ebp+arg_0]
.text$mn:0000009E                 mov     [edx+10h], eax
.text$mn:000000A1                 mov     ecx, [ebp+arg_0]
.text$mn:000000A4                 add     ecx, [ebp+arg_4]
.text$mn:000000A7                 mov     edx, [ebp+var_4]
.text$mn:000000AA                 mov     [edx+14h], ecx
.text$mn:000000AD                 mov     eax, [ebp+var_4]
.text$mn:000000B0                 mov     ecx, [ebp+arg_8]
.text$mn:000000B3                 mov     [eax], ecx
.text$mn:000000B5                 mov     edx, [ebp+var_4]
.text$mn:000000B8                 mov     dword ptr [edx+4], 0
.text$mn:000000BF                 mov     ecx, [ebp+var_4]
.text$mn:000000C2                 call    ??EUtf16_Iter@@QAEXXZ ; Utf16_Iter::operator++(void)
.text$mn:000000C7                 mov     esp, ebp
.text$mn:000000C9                 pop     ebp
.text$mn:000000CA                 retn    0Ch
.text$mn:000000CA ?set@Utf16_Iter@@QAEXPBEIW4UniMode@@@Z endp
.text$mn:000000CA
.text$mn:000000CA ; ---------------------------------------------------------------------------
.text$mn:000000CD                 db 0Bh dup(0CCh)
.text$mn:000000D8
.text$mn:000000D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000000D8
.text$mn:000000D8 ; Attributes: bp-based frame
.text$mn:000000D8
.text$mn:000000D8 ; public: void __thiscall Utf16_Iter::operator++(void)
.text$mn:000000D8                 public ??EUtf16_Iter@@QAEXXZ
.text$mn:000000D8 ??EUtf16_Iter@@QAEXXZ proc near         ; CODE XREF: Utf16_Iter::set(uchar const *,uint,UniMode)+3Ap
.text$mn:000000D8                                         ; Utf8_16_Read::convert(char *,uint)+158p
.text$mn:000000D8
.text$mn:000000D8 var_8           = dword ptr -8
.text$mn:000000D8 var_4           = dword ptr -4
.text$mn:000000D8
.text$mn:000000D8                 push    ebp
.text$mn:000000D9                 mov     ebp, esp
.text$mn:000000DB                 sub     esp, 8
.text$mn:000000DE                 mov     [ebp+var_4], ecx
.text$mn:000000E1                 mov     eax, [ebp+var_4]
.text$mn:000000E4                 mov     ecx, [eax+4]
.text$mn:000000E7                 mov     [ebp+var_8], ecx
.text$mn:000000EA                 cmp     [ebp+var_8], 3  ; switch 4 cases
.text$mn:000000EE                 ja      loc_25C         ; jumptable 000000F7 default case
.text$mn:000000F4                 mov     edx, [ebp+var_8]
.text$mn:000000F7                 jmp     ds:$LN15[edx*4] ; switch jump
.text$mn:000000FE ; ---------------------------------------------------------------------------
.text$mn:000000FE
.text$mn:000000FE $LN10:                                  ; CODE XREF: Utf16_Iter::operator++(void)+1Fj
.text$mn:000000FE                                         ; DATA XREF: .text$mn:$LN15o
.text$mn:000000FE                 mov     eax, [ebp+var_4] ; jumptable 000000F7 case 0
.text$mn:00000101                 cmp     dword ptr [eax], 3
.text$mn:00000104                 jz      short loc_10E
.text$mn:00000106                 mov     ecx, [ebp+var_4]
.text$mn:00000109                 cmp     dword ptr [ecx], 7
.text$mn:0000010C                 jnz     short loc_14F
.text$mn:0000010E
.text$mn:0000010E loc_10E:                                ; CODE XREF: Utf16_Iter::operator++(void)+2Cj
.text$mn:0000010E                 mov     edx, [ebp+var_4]
.text$mn:00000111                 mov     eax, [edx+10h]
.text$mn:00000114                 movzx   cx, byte ptr [eax]
.text$mn:00000118                 mov     edx, [ebp+var_4]
.text$mn:0000011B                 mov     [edx+0Ah], cx
.text$mn:0000011F                 mov     eax, [ebp+var_4]
.text$mn:00000122                 mov     ecx, [eax+10h]
.text$mn:00000125                 add     ecx, 1
.text$mn:00000128                 mov     edx, [ebp+var_4]
.text$mn:0000012B                 mov     [edx+10h], ecx
.text$mn:0000012E                 mov     eax, [ebp+var_4]
.text$mn:00000131                 mov     ecx, [eax+10h]
.text$mn:00000134                 movzx   edx, byte ptr [ecx]
.text$mn:00000137                 shl     edx, 8
.text$mn:0000013A                 movzx   eax, dx
.text$mn:0000013D                 mov     ecx, [ebp+var_4]
.text$mn:00000140                 movzx   edx, word ptr [ecx+0Ah]
.text$mn:00000144                 or      edx, eax
.text$mn:00000146                 mov     eax, [ebp+var_4]
.text$mn:00000149                 mov     [eax+0Ah], dx
.text$mn:0000014D                 jmp     short loc_18A
.text$mn:0000014F ; ---------------------------------------------------------------------------
.text$mn:0000014F
.text$mn:0000014F loc_14F:                                ; CODE XREF: Utf16_Iter::operator++(void)+34j
.text$mn:0000014F                 mov     ecx, [ebp+var_4]
.text$mn:00000152                 mov     edx, [ecx+10h]
.text$mn:00000155                 movzx   eax, byte ptr [edx]
.text$mn:00000158                 shl     eax, 8
.text$mn:0000015B                 mov     ecx, [ebp+var_4]
.text$mn:0000015E                 mov     [ecx+0Ah], ax
.text$mn:00000162                 mov     edx, [ebp+var_4]
.text$mn:00000165                 mov     eax, [edx+10h]
.text$mn:00000168                 add     eax, 1
.text$mn:0000016B                 mov     ecx, [ebp+var_4]
.text$mn:0000016E                 mov     [ecx+10h], eax
.text$mn:00000171                 mov     edx, [ebp+var_4]
.text$mn:00000174                 mov     eax, [edx+10h]
.text$mn:00000177                 movzx   ecx, byte ptr [eax]
.text$mn:0000017A                 mov     edx, [ebp+var_4]
.text$mn:0000017D                 movzx   eax, word ptr [edx+0Ah]
.text$mn:00000181                 or      eax, ecx
.text$mn:00000183                 mov     ecx, [ebp+var_4]
.text$mn:00000186                 mov     [ecx+0Ah], ax
.text$mn:0000018A
.text$mn:0000018A loc_18A:                                ; CODE XREF: Utf16_Iter::operator++(void)+75j
.text$mn:0000018A                 mov     edx, [ebp+var_4]
.text$mn:0000018D                 mov     eax, [edx+10h]
.text$mn:00000190                 add     eax, 1
.text$mn:00000193                 mov     ecx, [ebp+var_4]
.text$mn:00000196                 mov     [ecx+10h], eax
.text$mn:00000199                 mov     edx, [ebp+var_4]
.text$mn:0000019C                 movzx   eax, word ptr [edx+0Ah]
.text$mn:000001A0                 cmp     eax, 80h ; 'Ç'
.text$mn:000001A5                 jge     short loc_1C6
.text$mn:000001A7                 mov     ecx, [ebp+var_4]
.text$mn:000001AA                 movzx   edx, word ptr [ecx+0Ah]
.text$mn:000001AE                 and     edx, 0FFh
.text$mn:000001B4                 mov     eax, [ebp+var_4]
.text$mn:000001B7                 mov     [eax+8], dl
.text$mn:000001BA                 mov     ecx, [ebp+var_4]
.text$mn:000001BD                 mov     dword ptr [ecx+4], 0
.text$mn:000001C4                 jmp     short loc_215
.text$mn:000001C6 ; ---------------------------------------------------------------------------
.text$mn:000001C6
.text$mn:000001C6 loc_1C6:                                ; CODE XREF: Utf16_Iter::operator++(void)+CDj
.text$mn:000001C6                 mov     edx, [ebp+var_4]
.text$mn:000001C9                 movzx   eax, word ptr [edx+0Ah]
.text$mn:000001CD                 cmp     eax, 800h
.text$mn:000001D2                 jge     short loc_1F6
.text$mn:000001D4                 mov     ecx, [ebp+var_4]
.text$mn:000001D7                 movzx   edx, word ptr [ecx+0Ah]
.text$mn:000001DB                 sar     edx, 6
.text$mn:000001DE                 or      edx, 0C0h
.text$mn:000001E4                 mov     eax, [ebp+var_4]
.text$mn:000001E7                 mov     [eax+8], dl
.text$mn:000001EA                 mov     ecx, [ebp+var_4]
.text$mn:000001ED                 mov     dword ptr [ecx+4], 1
.text$mn:000001F4                 jmp     short loc_215
.text$mn:000001F6 ; ---------------------------------------------------------------------------
.text$mn:000001F6
.text$mn:000001F6 loc_1F6:                                ; CODE XREF: Utf16_Iter::operator++(void)+FAj
.text$mn:000001F6                 mov     edx, [ebp+var_4]
.text$mn:000001F9                 movzx   eax, word ptr [edx+0Ah]
.text$mn:000001FD                 sar     eax, 0Ch
.text$mn:00000200                 or      eax, 0E0h
.text$mn:00000205                 mov     ecx, [ebp+var_4]
.text$mn:00000208                 mov     [ecx+8], al
.text$mn:0000020B                 mov     edx, [ebp+var_4]
.text$mn:0000020E                 mov     dword ptr [edx+4], 2
.text$mn:00000215
.text$mn:00000215 loc_215:                                ; CODE XREF: Utf16_Iter::operator++(void)+ECj
.text$mn:00000215                                         ; Utf16_Iter::operator++(void)+11Cj
.text$mn:00000215                 jmp     short loc_25C   ; jumptable 000000F7 default case
.text$mn:00000217 ; ---------------------------------------------------------------------------
.text$mn:00000217
.text$mn:00000217 $LN2:                                   ; CODE XREF: Utf16_Iter::operator++(void)+1Fj
.text$mn:00000217                                         ; DATA XREF: .text$mn:$LN15o
.text$mn:00000217                 mov     eax, [ebp+var_4] ; jumptable 000000F7 cases 1,3
.text$mn:0000021A                 movzx   ecx, word ptr [eax+0Ah]
.text$mn:0000021E                 and     ecx, 3Fh
.text$mn:00000221                 or      ecx, 80h
.text$mn:00000227                 mov     edx, [ebp+var_4]
.text$mn:0000022A                 mov     [edx+8], cl
.text$mn:0000022D                 mov     eax, [ebp+var_4]
.text$mn:00000230                 mov     dword ptr [eax+4], 0
.text$mn:00000237                 jmp     short loc_25C   ; jumptable 000000F7 default case
.text$mn:00000239 ; ---------------------------------------------------------------------------
.text$mn:00000239
.text$mn:00000239 $LN1:                                   ; CODE XREF: Utf16_Iter::operator++(void)+1Fj
.text$mn:00000239                                         ; DATA XREF: .text$mn:$LN15o
.text$mn:00000239                 mov     ecx, [ebp+var_4] ; jumptable 000000F7 case 2
.text$mn:0000023C                 movzx   edx, word ptr [ecx+0Ah]
.text$mn:00000240                 sar     edx, 6
.text$mn:00000243                 and     edx, 3Fh
.text$mn:00000246                 or      edx, 80h
.text$mn:0000024C                 mov     eax, [ebp+var_4]
.text$mn:0000024F                 mov     [eax+8], dl
.text$mn:00000252                 mov     ecx, [ebp+var_4]
.text$mn:00000255                 mov     dword ptr [ecx+4], 3
.text$mn:0000025C
.text$mn:0000025C loc_25C:                                ; CODE XREF: Utf16_Iter::operator++(void)+16j
.text$mn:0000025C                                         ; Utf16_Iter::operator++(void):loc_215j ...
.text$mn:0000025C                 mov     esp, ebp        ; jumptable 000000F7 default case
.text$mn:0000025E                 pop     ebp
.text$mn:0000025F                 retn
.text$mn:0000025F ??EUtf16_Iter@@QAEXXZ endp
.text$mn:0000025F
.text$mn:0000025F ; ---------------------------------------------------------------------------
.text$mn:00000260 $LN15           dd offset $LN10         ; DATA XREF: Utf16_Iter::operator++(void)+1Fr
.text$mn:00000260                 dd offset $LN2          ; jump table for switch statement
.text$mn:00000260                 dd offset $LN1
.text$mn:00000260                 dd offset $LN2
.text$mn:00000270                 db 8 dup(0CCh)
.text$mn:00000278
.text$mn:00000278 ; =============== S U B R O U T I N E =======================================
.text$mn:00000278
.text$mn:00000278 ; Attributes: bp-based frame
.text$mn:00000278
.text$mn:00000278 ; public: __thiscall Utf8_Iter::Utf8_Iter(void)
.text$mn:00000278                 public ??0Utf8_Iter@@QAE@XZ
.text$mn:00000278 ??0Utf8_Iter@@QAE@XZ proc near          ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint)+12Ap
.text$mn:00000278                                         ; Utf8_16_Write::convert(char *,uint)+173p
.text$mn:00000278
.text$mn:00000278 var_4           = dword ptr -4
.text$mn:00000278
.text$mn:00000278                 push    ebp
.text$mn:00000279                 mov     ebp, esp
.text$mn:0000027B                 push    ecx
.text$mn:0000027C                 mov     [ebp+var_4], ecx
.text$mn:0000027F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000282                 call    ?reset@Utf8_Iter@@QAEXXZ ; Utf8_Iter::reset(void)
.text$mn:00000287                 mov     eax, [ebp+var_4]
.text$mn:0000028A                 mov     esp, ebp
.text$mn:0000028C                 pop     ebp
.text$mn:0000028D                 retn
.text$mn:0000028D ??0Utf8_Iter@@QAE@XZ endp
.text$mn:0000028D
.text$mn:0000028D ; ---------------------------------------------------------------------------
.text$mn:0000028E                 db 0Ah dup(0CCh)
.text$mn:00000298
.text$mn:00000298 ; =============== S U B R O U T I N E =======================================
.text$mn:00000298
.text$mn:00000298 ; Attributes: bp-based frame
.text$mn:00000298
.text$mn:00000298 ; void __thiscall Utf8_Iter::reset(Utf8_Iter *__hidden this)
.text$mn:00000298                 public ?reset@Utf8_Iter@@QAEXXZ
.text$mn:00000298 ?reset@Utf8_Iter@@QAEXXZ proc near      ; CODE XREF: Utf8_Iter::Utf8_Iter(void)+Ap
.text$mn:00000298
.text$mn:00000298 var_4           = dword ptr -4
.text$mn:00000298
.text$mn:00000298                 push    ebp
.text$mn:00000299                 mov     ebp, esp
.text$mn:0000029B                 push    ecx
.text$mn:0000029C                 mov     [ebp+var_4], ecx
.text$mn:0000029F                 mov     eax, [ebp+var_4]
.text$mn:000002A2                 mov     dword ptr [eax+0Ch], 0
.text$mn:000002A9                 mov     ecx, [ebp+var_4]
.text$mn:000002AC                 mov     dword ptr [ecx+10h], 0
.text$mn:000002B3                 mov     edx, [ebp+var_4]
.text$mn:000002B6                 mov     dword ptr [edx+14h], 0
.text$mn:000002BD                 mov     eax, [ebp+var_4]
.text$mn:000002C0                 mov     dword ptr [eax+4], 0
.text$mn:000002C7                 xor     ecx, ecx
.text$mn:000002C9                 mov     edx, [ebp+var_4]
.text$mn:000002CC                 mov     [edx+8], cx
.text$mn:000002D0                 mov     eax, [ebp+var_4]
.text$mn:000002D3                 mov     dword ptr [eax], 0
.text$mn:000002D9                 mov     esp, ebp
.text$mn:000002DB                 pop     ebp
.text$mn:000002DC                 retn
.text$mn:000002DC ?reset@Utf8_Iter@@QAEXXZ endp
.text$mn:000002DC
.text$mn:000002DC ; ---------------------------------------------------------------------------
.text$mn:000002DD                 db 0Bh dup(0CCh)
.text$mn:000002E8
.text$mn:000002E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000002E8
.text$mn:000002E8 ; Attributes: bp-based frame
.text$mn:000002E8
.text$mn:000002E8 ; public: void __thiscall Utf8_Iter::set(unsigned char const *, unsigned int, enum  UniMode)
.text$mn:000002E8                 public ?set@Utf8_Iter@@QAEXPBEIW4UniMode@@@Z
.text$mn:000002E8 ?set@Utf8_Iter@@QAEXPBEIW4UniMode@@@Z proc near
.text$mn:000002E8                                         ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint)+146p
.text$mn:000002E8                                         ; Utf8_16_Write::convert(char *,uint)+189p
.text$mn:000002E8
.text$mn:000002E8 var_4           = dword ptr -4
.text$mn:000002E8 arg_0           = dword ptr  8
.text$mn:000002E8 arg_4           = dword ptr  0Ch
.text$mn:000002E8 arg_8           = dword ptr  10h
.text$mn:000002E8
.text$mn:000002E8                 push    ebp
.text$mn:000002E9                 mov     ebp, esp
.text$mn:000002EB                 push    ecx
.text$mn:000002EC                 mov     [ebp+var_4], ecx
.text$mn:000002EF                 mov     eax, [ebp+var_4]
.text$mn:000002F2                 mov     ecx, [ebp+arg_0]
.text$mn:000002F5                 mov     [eax+0Ch], ecx
.text$mn:000002F8                 mov     edx, [ebp+var_4]
.text$mn:000002FB                 mov     eax, [ebp+arg_0]
.text$mn:000002FE                 mov     [edx+10h], eax
.text$mn:00000301                 mov     ecx, [ebp+arg_0]
.text$mn:00000304                 add     ecx, [ebp+arg_4]
.text$mn:00000307                 mov     edx, [ebp+var_4]
.text$mn:0000030A                 mov     [edx+14h], ecx
.text$mn:0000030D                 mov     eax, [ebp+var_4]
.text$mn:00000310                 mov     ecx, [ebp+arg_8]
.text$mn:00000313                 mov     [eax], ecx
.text$mn:00000315                 mov     ecx, [ebp+var_4]
.text$mn:00000318                 call    ??EUtf8_Iter@@QAEXXZ ; Utf8_Iter::operator++(void)
.text$mn:0000031D                 mov     esp, ebp
.text$mn:0000031F                 pop     ebp
.text$mn:00000320                 retn    0Ch
.text$mn:00000320 ?set@Utf8_Iter@@QAEXPBEIW4UniMode@@@Z endp
.text$mn:00000320
.text$mn:00000320 ; ---------------------------------------------------------------------------
.text$mn:00000323                 align 8
.text$mn:00000328
.text$mn:00000328 ; =============== S U B R O U T I N E =======================================
.text$mn:00000328
.text$mn:00000328 ; Attributes: bp-based frame
.text$mn:00000328
.text$mn:00000328 ; public: void __thiscall Utf8_Iter::operator++(void)
.text$mn:00000328                 public ??EUtf8_Iter@@QAEXXZ
.text$mn:00000328 ??EUtf8_Iter@@QAEXXZ proc near          ; CODE XREF: Utf8_Iter::set(uchar const *,uint,UniMode)+30p
.text$mn:00000328                                         ; Utf8_16_Write::fwrite(void const *,uint)+1ABp ...
.text$mn:00000328
.text$mn:00000328 var_8           = dword ptr -8
.text$mn:00000328 var_4           = dword ptr -4
.text$mn:00000328
.text$mn:00000328                 push    ebp
.text$mn:00000329                 mov     ebp, esp
.text$mn:0000032B                 sub     esp, 8
.text$mn:0000032E                 mov     [ebp+var_4], ecx
.text$mn:00000331                 mov     eax, [ebp+var_4]
.text$mn:00000334                 mov     ecx, [eax+4]
.text$mn:00000337                 mov     [ebp+var_8], ecx
.text$mn:0000033A                 cmp     [ebp+var_8], 3  ; switch 4 cases
.text$mn:0000033E                 ja      loc_423         ; jumptable 00000347 default case
.text$mn:00000344                 mov     edx, [ebp+var_8]
.text$mn:00000347                 jmp     ds:$LN12[edx*4] ; switch jump
.text$mn:0000034E ; ---------------------------------------------------------------------------
.text$mn:0000034E
.text$mn:0000034E $LN7:                                   ; CODE XREF: Utf8_Iter::operator++(void)+1Fj
.text$mn:0000034E                                         ; DATA XREF: .text$mn:$LN12o
.text$mn:0000034E                 mov     eax, [ebp+var_4] ; jumptable 00000347 case 0
.text$mn:00000351                 mov     ecx, [eax+10h]
.text$mn:00000354                 movzx   edx, byte ptr [ecx]
.text$mn:00000357                 cmp     edx, 80h ; 'Ç'
.text$mn:0000035D                 jge     short loc_37A
.text$mn:0000035F                 mov     eax, [ebp+var_4]
.text$mn:00000362                 mov     ecx, [eax+10h]
.text$mn:00000365                 movzx   dx, byte ptr [ecx]
.text$mn:00000369                 mov     eax, [ebp+var_4]
.text$mn:0000036C                 mov     [eax+8], dx
.text$mn:00000370                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000373                 call    ?toStart@Utf8_Iter@@IAEXXZ ; Utf8_Iter::toStart(void)
.text$mn:00000378                 jmp     short loc_3CC
.text$mn:0000037A ; ---------------------------------------------------------------------------
.text$mn:0000037A
.text$mn:0000037A loc_37A:                                ; CODE XREF: Utf8_Iter::operator++(void)+35j
.text$mn:0000037A                 mov     ecx, [ebp+var_4]
.text$mn:0000037D                 mov     edx, [ecx+10h]
.text$mn:00000380                 movzx   eax, byte ptr [edx]
.text$mn:00000383                 cmp     eax, 0E0h ; 'a'
.text$mn:00000388                 jge     short loc_3AC
.text$mn:0000038A                 mov     ecx, [ebp+var_4]
.text$mn:0000038D                 mov     edx, [ecx+10h]
.text$mn:00000390                 movzx   eax, byte ptr [edx]
.text$mn:00000393                 and     eax, 1Fh
.text$mn:00000396                 shl     eax, 6
.text$mn:00000399                 mov     ecx, [ebp+var_4]
.text$mn:0000039C                 mov     [ecx+8], ax
.text$mn:000003A0                 mov     edx, [ebp+var_4]
.text$mn:000003A3                 mov     dword ptr [edx+4], 1
.text$mn:000003AA                 jmp     short loc_3CC
.text$mn:000003AC ; ---------------------------------------------------------------------------
.text$mn:000003AC
.text$mn:000003AC loc_3AC:                                ; CODE XREF: Utf8_Iter::operator++(void)+60j
.text$mn:000003AC                 mov     eax, [ebp+var_4]
.text$mn:000003AF                 mov     ecx, [eax+10h]
.text$mn:000003B2                 movzx   edx, byte ptr [ecx]
.text$mn:000003B5                 and     edx, 0Fh
.text$mn:000003B8                 shl     edx, 0Ch
.text$mn:000003BB                 mov     eax, [ebp+var_4]
.text$mn:000003BE                 mov     [eax+8], dx
.text$mn:000003C2                 mov     ecx, [ebp+var_4]
.text$mn:000003C5                 mov     dword ptr [ecx+4], 2
.text$mn:000003CC
.text$mn:000003CC loc_3CC:                                ; CODE XREF: Utf8_Iter::operator++(void)+50j
.text$mn:000003CC                                         ; Utf8_Iter::operator++(void)+82j
.text$mn:000003CC                 jmp     short loc_423   ; jumptable 00000347 default case
.text$mn:000003CE ; ---------------------------------------------------------------------------
.text$mn:000003CE
.text$mn:000003CE $LN2_0:                                 ; CODE XREF: Utf8_Iter::operator++(void)+1Fj
.text$mn:000003CE                                         ; DATA XREF: .text$mn:$LN12o
.text$mn:000003CE                 mov     edx, [ebp+var_4] ; jumptable 00000347 cases 1,3
.text$mn:000003D1                 mov     eax, [edx+10h]
.text$mn:000003D4                 movzx   ecx, byte ptr [eax]
.text$mn:000003D7                 and     ecx, 3Fh
.text$mn:000003DA                 movzx   edx, cl
.text$mn:000003DD                 mov     eax, [ebp+var_4]
.text$mn:000003E0                 movzx   ecx, word ptr [eax+8]
.text$mn:000003E4                 or      ecx, edx
.text$mn:000003E6                 mov     edx, [ebp+var_4]
.text$mn:000003E9                 mov     [edx+8], cx
.text$mn:000003ED                 mov     ecx, [ebp+var_4] ; this
.text$mn:000003F0                 call    ?toStart@Utf8_Iter@@IAEXXZ ; Utf8_Iter::toStart(void)
.text$mn:000003F5                 jmp     short loc_423   ; jumptable 00000347 default case
.text$mn:000003F7 ; ---------------------------------------------------------------------------
.text$mn:000003F7
.text$mn:000003F7 $LN1_0:                                 ; CODE XREF: Utf8_Iter::operator++(void)+1Fj
.text$mn:000003F7                                         ; DATA XREF: .text$mn:$LN12o
.text$mn:000003F7                 mov     eax, [ebp+var_4] ; jumptable 00000347 case 2
.text$mn:000003FA                 mov     ecx, [eax+10h]
.text$mn:000003FD                 movzx   edx, byte ptr [ecx]
.text$mn:00000400                 and     edx, 3Fh
.text$mn:00000403                 shl     edx, 6
.text$mn:00000406                 movzx   eax, dx
.text$mn:00000409                 mov     ecx, [ebp+var_4]
.text$mn:0000040C                 movzx   edx, word ptr [ecx+8]
.text$mn:00000410                 or      edx, eax
.text$mn:00000412                 mov     eax, [ebp+var_4]
.text$mn:00000415                 mov     [eax+8], dx
.text$mn:00000419                 mov     ecx, [ebp+var_4]
.text$mn:0000041C                 mov     dword ptr [ecx+4], 3
.text$mn:00000423
.text$mn:00000423 loc_423:                                ; CODE XREF: Utf8_Iter::operator++(void)+16j
.text$mn:00000423                                         ; Utf8_Iter::operator++(void):loc_3CCj ...
.text$mn:00000423                 mov     edx, [ebp+var_4] ; jumptable 00000347 default case
.text$mn:00000426                 mov     eax, [edx+10h]
.text$mn:00000429                 add     eax, 1
.text$mn:0000042C                 mov     ecx, [ebp+var_4]
.text$mn:0000042F                 mov     [ecx+10h], eax
.text$mn:00000432                 mov     esp, ebp
.text$mn:00000434                 pop     ebp
.text$mn:00000435                 retn
.text$mn:00000435 ??EUtf8_Iter@@QAEXXZ endp
.text$mn:00000435
.text$mn:00000435 ; ---------------------------------------------------------------------------
.text$mn:00000436                 align 4
.text$mn:00000438 $LN12           dd offset $LN7          ; DATA XREF: Utf8_Iter::operator++(void)+1Fr
.text$mn:00000438                 dd offset $LN2_0        ; jump table for switch statement
.text$mn:00000438                 dd offset $LN1_0
.text$mn:00000438                 dd offset $LN2_0
.text$mn:00000448
.text$mn:00000448 ; =============== S U B R O U T I N E =======================================
.text$mn:00000448
.text$mn:00000448 ; Attributes: bp-based frame
.text$mn:00000448
.text$mn:00000448 ; void __thiscall Utf8_Iter::swap(Utf8_Iter *__hidden this)
.text$mn:00000448                 public ?swap@Utf8_Iter@@IAEXXZ
.text$mn:00000448 ?swap@Utf8_Iter@@IAEXXZ proc near       ; CODE XREF: Utf8_Iter::toStart(void)+24p
.text$mn:00000448
.text$mn:00000448 var_C           = dword ptr -0Ch
.text$mn:00000448 var_8           = dword ptr -8
.text$mn:00000448 var_1           = byte ptr -1
.text$mn:00000448
.text$mn:00000448                 push    ebp
.text$mn:00000449                 mov     ebp, esp
.text$mn:0000044B                 sub     esp, 0Ch
.text$mn:0000044E                 mov     [ebp+var_C], ecx
.text$mn:00000451                 mov     eax, [ebp+var_C]
.text$mn:00000454                 add     eax, 8
.text$mn:00000457                 mov     [ebp+var_8], eax
.text$mn:0000045A                 mov     ecx, [ebp+var_8]
.text$mn:0000045D                 mov     dl, [ecx]
.text$mn:0000045F                 mov     [ebp+var_1], dl
.text$mn:00000462                 mov     eax, [ebp+var_8]
.text$mn:00000465                 mov     ecx, [ebp+var_8]
.text$mn:00000468                 mov     dl, [ecx+1]
.text$mn:0000046B                 mov     [eax], dl
.text$mn:0000046D                 mov     eax, [ebp+var_8]
.text$mn:00000470                 mov     cl, [ebp+var_1]
.text$mn:00000473                 mov     [eax+1], cl
.text$mn:00000476                 mov     esp, ebp
.text$mn:00000478                 pop     ebp
.text$mn:00000479                 retn
.text$mn:00000479 ?swap@Utf8_Iter@@IAEXXZ endp
.text$mn:00000479
.text$mn:00000479 ; ---------------------------------------------------------------------------
.text$mn:0000047A                 db 0Eh dup(0CCh)
.text$mn:00000488
.text$mn:00000488 ; =============== S U B R O U T I N E =======================================
.text$mn:00000488
.text$mn:00000488 ; Attributes: bp-based frame
.text$mn:00000488
.text$mn:00000488 ; void __thiscall Utf8_Iter::toStart(Utf8_Iter *__hidden this)
.text$mn:00000488                 public ?toStart@Utf8_Iter@@IAEXXZ
.text$mn:00000488 ?toStart@Utf8_Iter@@IAEXXZ proc near    ; CODE XREF: Utf8_Iter::operator++(void)+4Bp
.text$mn:00000488                                         ; Utf8_Iter::operator++(void)+C8p
.text$mn:00000488
.text$mn:00000488 var_4           = dword ptr -4
.text$mn:00000488
.text$mn:00000488                 push    ebp
.text$mn:00000489                 mov     ebp, esp
.text$mn:0000048B                 push    ecx
.text$mn:0000048C                 mov     [ebp+var_4], ecx
.text$mn:0000048F                 mov     eax, [ebp+var_4]
.text$mn:00000492                 mov     dword ptr [eax+4], 0
.text$mn:00000499                 mov     ecx, [ebp+var_4]
.text$mn:0000049C                 cmp     dword ptr [ecx], 2
.text$mn:0000049F                 jz      short loc_4A9
.text$mn:000004A1                 mov     edx, [ebp+var_4]
.text$mn:000004A4                 cmp     dword ptr [edx], 6
.text$mn:000004A7                 jnz     short loc_4B1
.text$mn:000004A9
.text$mn:000004A9 loc_4A9:                                ; CODE XREF: Utf8_Iter::toStart(void)+17j
.text$mn:000004A9                 mov     ecx, [ebp+var_4] ; this
.text$mn:000004AC                 call    ?swap@Utf8_Iter@@IAEXXZ ; Utf8_Iter::swap(void)
.text$mn:000004B1
.text$mn:000004B1 loc_4B1:                                ; CODE XREF: Utf8_Iter::toStart(void)+1Fj
.text$mn:000004B1                 mov     esp, ebp
.text$mn:000004B3                 pop     ebp
.text$mn:000004B4                 retn
.text$mn:000004B4 ?toStart@Utf8_Iter@@IAEXXZ endp
.text$mn:000004B4
.text$mn:000004B4 ; ---------------------------------------------------------------------------
.text$mn:000004B5                 align 4
.text$mn:000004B8
.text$mn:000004B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000004B8
.text$mn:000004B8 ; Attributes: bp-based frame
.text$mn:000004B8
.text$mn:000004B8 ; _DWORD __thiscall Utf8_16_Read::Utf8_16_Read(Utf8_16_Read *__hidden this)
.text$mn:000004B8                 public ??0Utf8_16_Read@@QAE@XZ
.text$mn:000004B8 ??0Utf8_16_Read@@QAE@XZ proc near
.text$mn:000004B8
.text$mn:000004B8 var_4           = dword ptr -4
.text$mn:000004B8
.text$mn:000004B8                 push    ebp
.text$mn:000004B9                 mov     ebp, esp
.text$mn:000004BB                 push    ecx
.text$mn:000004BC                 mov     [ebp+var_4], ecx
.text$mn:000004BF                 mov     ecx, [ebp+var_4]
.text$mn:000004C2                 add     ecx, 20h ; ' '
.text$mn:000004C5                 call    ??0Utf16_Iter@@QAE@XZ ; Utf16_Iter::Utf16_Iter(void)
.text$mn:000004CA                 mov     eax, [ebp+var_4]
.text$mn:000004CD                 mov     dword ptr [eax], 0
.text$mn:000004D3                 mov     ecx, [ebp+var_4]
.text$mn:000004D6                 mov     dword ptr [ecx+10h], 0
.text$mn:000004DD                 mov     edx, [ebp+var_4]
.text$mn:000004E0                 mov     dword ptr [edx+0Ch], 0
.text$mn:000004E7                 mov     eax, [ebp+var_4]
.text$mn:000004EA                 mov     dword ptr [eax+8], 0
.text$mn:000004F1                 mov     ecx, [ebp+var_4]
.text$mn:000004F4                 mov     byte ptr [ecx+18h], 1
.text$mn:000004F8                 mov     eax, [ebp+var_4]
.text$mn:000004FB                 mov     esp, ebp
.text$mn:000004FD                 pop     ebp
.text$mn:000004FE                 retn
.text$mn:000004FE ??0Utf8_16_Read@@QAE@XZ endp
.text$mn:000004FE
.text$mn:000004FE ; ---------------------------------------------------------------------------
.text$mn:000004FF                 db 9 dup(0CCh)
.text$mn:00000508
.text$mn:00000508 ; =============== S U B R O U T I N E =======================================
.text$mn:00000508
.text$mn:00000508 ; Attributes: bp-based frame
.text$mn:00000508
.text$mn:00000508 ; _DWORD __thiscall Utf8_16_Read::~Utf8_16_Read(Utf8_16_Read *__hidden this)
.text$mn:00000508                 public ??1Utf8_16_Read@@QAE@XZ
.text$mn:00000508 ??1Utf8_16_Read@@QAE@XZ proc near
.text$mn:00000508
.text$mn:00000508 var_8           = dword ptr -8
.text$mn:00000508 var_4           = dword ptr -4
.text$mn:00000508
.text$mn:00000508                 push    ebp
.text$mn:00000509                 mov     ebp, esp
.text$mn:0000050B                 sub     esp, 8
.text$mn:0000050E                 mov     [ebp+var_4], ecx
.text$mn:00000511                 mov     eax, [ebp+var_4]
.text$mn:00000514                 cmp     dword ptr [eax], 2
.text$mn:00000517                 jz      short loc_531
.text$mn:00000519                 mov     ecx, [ebp+var_4]
.text$mn:0000051C                 cmp     dword ptr [ecx], 3
.text$mn:0000051F                 jz      short loc_531
.text$mn:00000521                 mov     edx, [ebp+var_4]
.text$mn:00000524                 cmp     dword ptr [edx], 6
.text$mn:00000527                 jz      short loc_531
.text$mn:00000529                 mov     eax, [ebp+var_4]
.text$mn:0000052C                 cmp     dword ptr [eax], 7
.text$mn:0000052F                 jnz     short loc_550
.text$mn:00000531
.text$mn:00000531 loc_531:                                ; CODE XREF: Utf8_16_Read::~Utf8_16_Read(void)+Fj
.text$mn:00000531                                         ; Utf8_16_Read::~Utf8_16_Read(void)+17j ...
.text$mn:00000531                 mov     ecx, [ebp+var_4]
.text$mn:00000534                 mov     edx, [ecx+8]
.text$mn:00000537                 mov     [ebp+var_8], edx
.text$mn:0000053A                 mov     eax, [ebp+var_8]
.text$mn:0000053D                 push    eax             ; void *
.text$mn:0000053E                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:00000543                 add     esp, 4
.text$mn:00000546                 mov     ecx, [ebp+var_4]
.text$mn:00000549                 mov     dword ptr [ecx+8], 0
.text$mn:00000550
.text$mn:00000550 loc_550:                                ; CODE XREF: Utf8_16_Read::~Utf8_16_Read(void)+27j
.text$mn:00000550                 mov     esp, ebp
.text$mn:00000552                 pop     ebp
.text$mn:00000553                 retn
.text$mn:00000553 ??1Utf8_16_Read@@QAE@XZ endp
.text$mn:00000553
.text$mn:00000553 ; ---------------------------------------------------------------------------
.text$mn:00000554                 align 8
.text$mn:00000558
.text$mn:00000558 ; =============== S U B R O U T I N E =======================================
.text$mn:00000558
.text$mn:00000558 ; Attributes: bp-based frame
.text$mn:00000558
.text$mn:00000558 ; unsigned int __thiscall Utf8_16_Read::convert(Utf8_16_Read *this, char *, unsigned int)
.text$mn:00000558                 public ?convert@Utf8_16_Read@@QAEIPADI@Z
.text$mn:00000558 ?convert@Utf8_16_Read@@QAEIPADI@Z proc near
.text$mn:00000558
.text$mn:00000558 var_18          = dword ptr -18h
.text$mn:00000558 var_14          = dword ptr -14h
.text$mn:00000558 var_10          = dword ptr -10h
.text$mn:00000558 var_C           = dword ptr -0Ch
.text$mn:00000558 var_8           = dword ptr -8
.text$mn:00000558 var_4           = dword ptr -4
.text$mn:00000558 arg_0           = dword ptr  8
.text$mn:00000558 arg_4           = dword ptr  0Ch
.text$mn:00000558
.text$mn:00000558                 push    ebp
.text$mn:00000559                 mov     ebp, esp
.text$mn:0000055B                 sub     esp, 18h
.text$mn:0000055E                 mov     [ebp+var_4], ecx
.text$mn:00000561                 mov     eax, [ebp+var_4]
.text$mn:00000564                 mov     ecx, [ebp+arg_0]
.text$mn:00000567                 mov     [eax+4], ecx
.text$mn:0000056A                 mov     edx, [ebp+var_4]
.text$mn:0000056D                 mov     eax, [ebp+arg_4]
.text$mn:00000570                 mov     [edx+1Ch], eax
.text$mn:00000573                 mov     ecx, [ebp+var_4]
.text$mn:00000576                 mov     dword ptr [ecx+0Ch], 0
.text$mn:0000057D                 mov     edx, [ebp+var_4]
.text$mn:00000580                 movzx   eax, byte ptr [edx+18h]
.text$mn:00000584                 cmp     eax, 1
.text$mn:00000587                 jnz     short loc_5A4
.text$mn:00000589                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000058C                 call    ?determineEncoding@Utf8_16_Read@@IAEXXZ ; Utf8_16_Read::determineEncoding(void)
.text$mn:00000591                 mov     ecx, [ebp+var_4]
.text$mn:00000594                 mov     edx, [ecx+14h]
.text$mn:00000597                 mov     ds:?nSkip@?1??convert@Utf8_16_Read@@QAEIPADI@Z@4IA, edx ; uint `Utf8_16_Read::convert(char *,uint)'::`2'::nSkip
.text$mn:0000059D                 mov     eax, [ebp+var_4]
.text$mn:000005A0                 mov     byte ptr [eax+18h], 0
.text$mn:000005A4
.text$mn:000005A4 loc_5A4:                                ; CODE XREF: Utf8_16_Read::convert(char *,uint)+2Fj
.text$mn:000005A4                 mov     ecx, [ebp+var_4]
.text$mn:000005A7                 mov     edx, [ecx]
.text$mn:000005A9                 mov     [ebp+var_10], edx
.text$mn:000005AC                 cmp     [ebp+var_10], 7 ; switch 8 cases
.text$mn:000005B0                 ja      loc_6F1         ; jumptable 000005B9 default case
.text$mn:000005B6                 mov     eax, [ebp+var_10]
.text$mn:000005B9                 jmp     ds:$LN15_0[eax*4] ; switch jump
.text$mn:000005C0 ; ---------------------------------------------------------------------------
.text$mn:000005C0
.text$mn:000005C0 $LN9:                                   ; CODE XREF: Utf8_16_Read::convert(char *,uint)+61j
.text$mn:000005C0                                         ; DATA XREF: .text$mn:$LN15_0o
.text$mn:000005C0                 mov     ecx, [ebp+var_4] ; jumptable 000005B9 cases 0,4,5
.text$mn:000005C3                 mov     dword ptr [ecx+10h], 0
.text$mn:000005CA                 mov     edx, [ebp+var_4]
.text$mn:000005CD                 mov     eax, [ebp+var_4]
.text$mn:000005D0                 mov     ecx, [eax+4]
.text$mn:000005D3                 mov     [edx+8], ecx
.text$mn:000005D6                 mov     edx, [ebp+var_4]
.text$mn:000005D9                 mov     eax, [ebp+arg_4]
.text$mn:000005DC                 mov     [edx+0Ch], eax
.text$mn:000005DF                 jmp     loc_6F1         ; jumptable 000005B9 default case
.text$mn:000005E4 ; ---------------------------------------------------------------------------
.text$mn:000005E4
.text$mn:000005E4 $LN8:                                   ; CODE XREF: Utf8_16_Read::convert(char *,uint)+61j
.text$mn:000005E4                                         ; DATA XREF: .text$mn:$LN15_0o
.text$mn:000005E4                 mov     ecx, [ebp+var_4] ; jumptable 000005B9 case 1
.text$mn:000005E7                 mov     dword ptr [ecx+10h], 0
.text$mn:000005EE                 mov     edx, [ebp+var_4]
.text$mn:000005F1                 mov     eax, [edx+4]
.text$mn:000005F4                 add     eax, ds:?nSkip@?1??convert@Utf8_16_Read@@QAEIPADI@Z@4IA ; uint `Utf8_16_Read::convert(char *,uint)'::`2'::nSkip
.text$mn:000005FA                 mov     ecx, [ebp+var_4]
.text$mn:000005FD                 mov     [ecx+8], eax
.text$mn:00000600                 mov     edx, [ebp+arg_4]
.text$mn:00000603                 sub     edx, ds:?nSkip@?1??convert@Utf8_16_Read@@QAEIPADI@Z@4IA ; uint `Utf8_16_Read::convert(char *,uint)'::`2'::nSkip
.text$mn:00000609                 mov     eax, [ebp+var_4]
.text$mn:0000060C                 mov     [eax+0Ch], edx
.text$mn:0000060F                 jmp     loc_6F1         ; jumptable 000005B9 default case
.text$mn:00000614 ; ---------------------------------------------------------------------------
.text$mn:00000614
.text$mn:00000614 $LN7_0:                                 ; CODE XREF: Utf8_16_Read::convert(char *,uint)+61j
.text$mn:00000614                                         ; DATA XREF: .text$mn:$LN15_0o
.text$mn:00000614                 mov     ecx, [ebp+arg_4] ; jumptable 000005B9 cases 2,3,6,7
.text$mn:00000617                 shr     ecx, 1
.text$mn:00000619                 mov     edx, [ebp+arg_4]
.text$mn:0000061C                 lea     eax, [edx+ecx+1]
.text$mn:00000620                 mov     [ebp+var_C], eax
.text$mn:00000623                 mov     ecx, [ebp+var_4]
.text$mn:00000626                 mov     edx, [ecx+10h]
.text$mn:00000629                 cmp     edx, [ebp+var_C]
.text$mn:0000062C                 jz      short loc_677
.text$mn:0000062E                 mov     eax, [ebp+var_4]
.text$mn:00000631                 cmp     dword ptr [eax+8], 0
.text$mn:00000635                 jz      short loc_64C
.text$mn:00000637                 mov     ecx, [ebp+var_4]
.text$mn:0000063A                 mov     edx, [ecx+8]
.text$mn:0000063D                 mov     [ebp+var_14], edx
.text$mn:00000640                 mov     eax, [ebp+var_14]
.text$mn:00000643                 push    eax             ; void *
.text$mn:00000644                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:00000649                 add     esp, 4
.text$mn:0000064C
.text$mn:0000064C loc_64C:                                ; CODE XREF: Utf8_16_Read::convert(char *,uint)+DDj
.text$mn:0000064C                 mov     ecx, [ebp+var_4]
.text$mn:0000064F                 mov     dword ptr [ecx+8], 0
.text$mn:00000656                 mov     edx, [ebp+var_C]
.text$mn:00000659                 push    edx             ; unsigned int
.text$mn:0000065A                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:0000065F                 add     esp, 4
.text$mn:00000662                 mov     [ebp+var_18], eax
.text$mn:00000665                 mov     eax, [ebp+var_4]
.text$mn:00000668                 mov     ecx, [ebp+var_18]
.text$mn:0000066B                 mov     [eax+8], ecx
.text$mn:0000066E                 mov     edx, [ebp+var_4]
.text$mn:00000671                 mov     eax, [ebp+var_C]
.text$mn:00000674                 mov     [edx+10h], eax
.text$mn:00000677
.text$mn:00000677 loc_677:                                ; CODE XREF: Utf8_16_Read::convert(char *,uint)+D4j
.text$mn:00000677                 mov     ecx, [ebp+var_4]
.text$mn:0000067A                 mov     edx, [ecx+8]
.text$mn:0000067D                 mov     [ebp+var_8], edx
.text$mn:00000680                 mov     eax, [ebp+var_4]
.text$mn:00000683                 mov     ecx, [eax]
.text$mn:00000685                 push    ecx
.text$mn:00000686                 mov     edx, [ebp+arg_4]
.text$mn:00000689                 sub     edx, ds:?nSkip@?1??convert@Utf8_16_Read@@QAEIPADI@Z@4IA ; uint `Utf8_16_Read::convert(char *,uint)'::`2'::nSkip
.text$mn:0000068F                 push    edx
.text$mn:00000690                 mov     eax, [ebp+var_4]
.text$mn:00000693                 mov     ecx, [eax+4]
.text$mn:00000696                 add     ecx, ds:?nSkip@?1??convert@Utf8_16_Read@@QAEIPADI@Z@4IA ; uint `Utf8_16_Read::convert(char *,uint)'::`2'::nSkip
.text$mn:0000069C                 push    ecx
.text$mn:0000069D                 mov     ecx, [ebp+var_4]
.text$mn:000006A0                 add     ecx, 20h ; ' '
.text$mn:000006A3                 call    ?set@Utf16_Iter@@QAEXPBEIW4UniMode@@@Z ; Utf16_Iter::set(uchar const *,uint,UniMode)
.text$mn:000006A8                 jmp     short loc_6B5
.text$mn:000006AA ; ---------------------------------------------------------------------------
.text$mn:000006AA
.text$mn:000006AA loc_6AA:                                ; CODE XREF: Utf8_16_Read::convert(char *,uint)+188j
.text$mn:000006AA                 mov     ecx, [ebp+var_4]
.text$mn:000006AD                 add     ecx, 20h ; ' '
.text$mn:000006B0                 call    ??EUtf16_Iter@@QAEXXZ ; Utf16_Iter::operator++(void)
.text$mn:000006B5
.text$mn:000006B5 loc_6B5:                                ; CODE XREF: Utf8_16_Read::convert(char *,uint)+150j
.text$mn:000006B5                 mov     ecx, [ebp+var_4]
.text$mn:000006B8                 add     ecx, 20h ; ' '
.text$mn:000006BB                 call    ??BUtf16_Iter@@QAE_NXZ ; Utf16_Iter::operator bool(void)
.text$mn:000006C0                 movzx   edx, al
.text$mn:000006C3                 test    edx, edx
.text$mn:000006C5                 jz      short loc_6E2
.text$mn:000006C7                 mov     ecx, [ebp+var_4]
.text$mn:000006CA                 add     ecx, 20h ; ' '  ; this
.text$mn:000006CD                 call    ?get@Utf16_Iter@@QBEEXZ ; Utf16_Iter::get(void)
.text$mn:000006D2                 mov     ecx, [ebp+var_8]
.text$mn:000006D5                 mov     [ecx], al
.text$mn:000006D7                 mov     edx, [ebp+var_8]
.text$mn:000006DA                 add     edx, 1
.text$mn:000006DD                 mov     [ebp+var_8], edx
.text$mn:000006E0                 jmp     short loc_6AA
.text$mn:000006E2 ; ---------------------------------------------------------------------------
.text$mn:000006E2
.text$mn:000006E2 loc_6E2:                                ; CODE XREF: Utf8_16_Read::convert(char *,uint)+16Dj
.text$mn:000006E2                 mov     eax, [ebp+var_4]
.text$mn:000006E5                 mov     ecx, [ebp+var_8]
.text$mn:000006E8                 sub     ecx, [eax+8]
.text$mn:000006EB                 mov     edx, [ebp+var_4]
.text$mn:000006EE                 mov     [edx+0Ch], ecx
.text$mn:000006F1
.text$mn:000006F1 loc_6F1:                                ; CODE XREF: Utf8_16_Read::convert(char *,uint)+58j
.text$mn:000006F1                                         ; Utf8_16_Read::convert(char *,uint)+87j ...
.text$mn:000006F1                 mov     ds:?nSkip@?1??convert@Utf8_16_Read@@QAEIPADI@Z@4IA, 0 ; jumptable 000005B9 default case
.text$mn:000006FB                 mov     eax, [ebp+var_4]
.text$mn:000006FE                 mov     eax, [eax+0Ch]
.text$mn:00000701                 mov     esp, ebp
.text$mn:00000703                 pop     ebp
.text$mn:00000704                 retn    8
.text$mn:00000704 ?convert@Utf8_16_Read@@QAEIPADI@Z endp
.text$mn:00000704
.text$mn:00000704 ; ---------------------------------------------------------------------------
.text$mn:00000707                 align 4
.text$mn:00000708 $LN15_0         dd offset $LN9          ; DATA XREF: Utf8_16_Read::convert(char *,uint)+61r
.text$mn:00000708                 dd offset $LN8          ; jump table for switch statement
.text$mn:00000708                 dd offset $LN7_0
.text$mn:00000708                 dd offset $LN7_0
.text$mn:00000708                 dd offset $LN9
.text$mn:00000708                 dd offset $LN9
.text$mn:00000708                 dd offset $LN7_0
.text$mn:00000708                 dd offset $LN7_0
.text$mn:00000728
.text$mn:00000728 ; =============== S U B R O U T I N E =======================================
.text$mn:00000728
.text$mn:00000728 ; Attributes: bp-based frame
.text$mn:00000728
.text$mn:00000728 ; public: static enum  UniMode __cdecl Utf8_16_Read::determineEncoding(unsigned char const *, int)
.text$mn:00000728                 public ?determineEncoding@Utf8_16_Read@@SA?AW4UniMode@@PBEH@Z
.text$mn:00000728 ?determineEncoding@Utf8_16_Read@@SA?AW4UniMode@@PBEH@Z proc near
.text$mn:00000728
.text$mn:00000728 arg_0           = dword ptr  8
.text$mn:00000728 arg_4           = dword ptr  0Ch
.text$mn:00000728
.text$mn:00000728                 push    ebp
.text$mn:00000729                 mov     ebp, esp
.text$mn:0000072B                 cmp     [ebp+arg_4], 1
.text$mn:0000072F                 jle     short loc_78F
.text$mn:00000731                 mov     eax, 1
.text$mn:00000736                 imul    ecx, eax, 0
.text$mn:00000739                 mov     edx, [ebp+arg_0]
.text$mn:0000073C                 movzx   eax, byte ptr [edx+ecx]
.text$mn:00000740                 mov     ecx, 3
.text$mn:00000745                 shl     ecx, 1
.text$mn:00000747                 mov     edx, 1
.text$mn:0000074C                 imul    edx, 0
.text$mn:0000074F                 movzx   ecx, ?k_Boms@Utf8_16@@2QAY02$$CBEA[ecx+edx] ; uchar const (* Utf8_16::k_Boms)[3]
.text$mn:00000757                 cmp     eax, ecx
.text$mn:00000759                 jnz     short loc_78F
.text$mn:0000075B                 mov     edx, 1
.text$mn:00000760                 shl     edx, 0
.text$mn:00000763                 mov     eax, [ebp+arg_0]
.text$mn:00000766                 movzx   ecx, byte ptr [eax+edx]
.text$mn:0000076A                 mov     edx, 3
.text$mn:0000076F                 shl     edx, 1
.text$mn:00000771                 mov     eax, 1
.text$mn:00000776                 shl     eax, 0
.text$mn:00000779                 movzx   edx, ?k_Boms@Utf8_16@@2QAY02$$CBEA[edx+eax] ; uchar const (* Utf8_16::k_Boms)[3]
.text$mn:00000781                 cmp     ecx, edx
.text$mn:00000783                 jnz     short loc_78F
.text$mn:00000785                 mov     eax, 2
.text$mn:0000078A                 jmp     loc_887
.text$mn:0000078F ; ---------------------------------------------------------------------------
.text$mn:0000078F
.text$mn:0000078F loc_78F:                                ; CODE XREF: Utf8_16_Read::determineEncoding(uchar const *,int)+7j
.text$mn:0000078F                                         ; Utf8_16_Read::determineEncoding(uchar const *,int)+31j ...
.text$mn:0000078F                 cmp     [ebp+arg_4], 1
.text$mn:00000793                 jle     short loc_7F5
.text$mn:00000795                 mov     eax, 1
.text$mn:0000079A                 imul    ecx, eax, 0
.text$mn:0000079D                 mov     edx, [ebp+arg_0]
.text$mn:000007A0                 movzx   eax, byte ptr [edx+ecx]
.text$mn:000007A4                 mov     ecx, 3
.text$mn:000007A9                 imul    edx, ecx, 3
.text$mn:000007AC                 mov     ecx, 1
.text$mn:000007B1                 imul    ecx, 0
.text$mn:000007B4                 movzx   edx, ?k_Boms@Utf8_16@@2QAY02$$CBEA[edx+ecx] ; uchar const (* Utf8_16::k_Boms)[3]
.text$mn:000007BC                 cmp     eax, edx
.text$mn:000007BE                 jnz     short loc_7F5
.text$mn:000007C0                 mov     eax, 1
.text$mn:000007C5                 shl     eax, 0
.text$mn:000007C8                 mov     ecx, [ebp+arg_0]
.text$mn:000007CB                 movzx   edx, byte ptr [ecx+eax]
.text$mn:000007CF                 mov     eax, 3
.text$mn:000007D4                 imul    ecx, eax, 3
.text$mn:000007D7                 mov     eax, 1
.text$mn:000007DC                 shl     eax, 0
.text$mn:000007DF                 movzx   ecx, ?k_Boms@Utf8_16@@2QAY02$$CBEA[ecx+eax] ; uchar const (* Utf8_16::k_Boms)[3]
.text$mn:000007E7                 cmp     edx, ecx
.text$mn:000007E9                 jnz     short loc_7F5
.text$mn:000007EB                 mov     eax, 3
.text$mn:000007F0                 jmp     loc_887
.text$mn:000007F5 ; ---------------------------------------------------------------------------
.text$mn:000007F5
.text$mn:000007F5 loc_7F5:                                ; CODE XREF: Utf8_16_Read::determineEncoding(uchar const *,int)+6Bj
.text$mn:000007F5                                         ; Utf8_16_Read::determineEncoding(uchar const *,int)+96j ...
.text$mn:000007F5                 cmp     [ebp+arg_4], 2
.text$mn:000007F9                 jle     loc_885
.text$mn:000007FF                 mov     edx, 1
.text$mn:00000804                 imul    eax, edx, 0
.text$mn:00000807                 mov     ecx, [ebp+arg_0]
.text$mn:0000080A                 movzx   edx, byte ptr [ecx+eax]
.text$mn:0000080E                 mov     eax, 3
.text$mn:00000813                 shl     eax, 0
.text$mn:00000816                 mov     ecx, 1
.text$mn:0000081B                 imul    ecx, 0
.text$mn:0000081E                 movzx   eax, ?k_Boms@Utf8_16@@2QAY02$$CBEA[eax+ecx] ; uchar const (* Utf8_16::k_Boms)[3]
.text$mn:00000826                 cmp     edx, eax
.text$mn:00000828                 jnz     short loc_885
.text$mn:0000082A                 mov     ecx, 1
.text$mn:0000082F                 shl     ecx, 0
.text$mn:00000832                 mov     edx, [ebp+arg_0]
.text$mn:00000835                 movzx   eax, byte ptr [edx+ecx]
.text$mn:00000839                 mov     ecx, 3
.text$mn:0000083E                 shl     ecx, 0
.text$mn:00000841                 mov     edx, 1
.text$mn:00000846                 shl     edx, 0
.text$mn:00000849                 movzx   ecx, ?k_Boms@Utf8_16@@2QAY02$$CBEA[ecx+edx] ; uchar const (* Utf8_16::k_Boms)[3]
.text$mn:00000851                 cmp     eax, ecx
.text$mn:00000853                 jnz     short loc_885
.text$mn:00000855                 mov     edx, 1
.text$mn:0000085A                 shl     edx, 1
.text$mn:0000085C                 mov     eax, [ebp+arg_0]
.text$mn:0000085F                 movzx   ecx, byte ptr [eax+edx]
.text$mn:00000863                 mov     edx, 3
.text$mn:00000868                 shl     edx, 0
.text$mn:0000086B                 mov     eax, 1
.text$mn:00000870                 shl     eax, 1
.text$mn:00000872                 movzx   edx, ?k_Boms@Utf8_16@@2QAY02$$CBEA[edx+eax] ; uchar const (* Utf8_16::k_Boms)[3]
.text$mn:0000087A                 cmp     ecx, edx
.text$mn:0000087C                 jnz     short loc_885
.text$mn:0000087E                 mov     eax, 1
.text$mn:00000883                 jmp     short loc_887
.text$mn:00000885 ; ---------------------------------------------------------------------------
.text$mn:00000885
.text$mn:00000885 loc_885:                                ; CODE XREF: Utf8_16_Read::determineEncoding(uchar const *,int)+D1j
.text$mn:00000885                                         ; Utf8_16_Read::determineEncoding(uchar const *,int)+100j ...
.text$mn:00000885                 xor     eax, eax
.text$mn:00000887
.text$mn:00000887 loc_887:                                ; CODE XREF: Utf8_16_Read::determineEncoding(uchar const *,int)+62j
.text$mn:00000887                                         ; Utf8_16_Read::determineEncoding(uchar const *,int)+C8j ...
.text$mn:00000887                 pop     ebp
.text$mn:00000888                 retn
.text$mn:00000888 ?determineEncoding@Utf8_16_Read@@SA?AW4UniMode@@PBEH@Z endp
.text$mn:00000888
.text$mn:00000888 ; ---------------------------------------------------------------------------
.text$mn:00000889                 db 0Fh dup(0CCh)
.text$mn:00000898
.text$mn:00000898 ; =============== S U B R O U T I N E =======================================
.text$mn:00000898
.text$mn:00000898 ; Attributes: bp-based frame
.text$mn:00000898
.text$mn:00000898 ; void __thiscall Utf8_16_Read::determineEncoding(Utf8_16_Read *__hidden this)
.text$mn:00000898                 public ?determineEncoding@Utf8_16_Read@@IAEXXZ
.text$mn:00000898 ?determineEncoding@Utf8_16_Read@@IAEXXZ proc near
.text$mn:00000898                                         ; CODE XREF: Utf8_16_Read::convert(char *,uint)+34p
.text$mn:00000898
.text$mn:00000898 iResult         = dword ptr -0Ch
.text$mn:00000898 var_8           = dword ptr -8
.text$mn:00000898 var_4           = dword ptr -4
.text$mn:00000898
.text$mn:00000898                 push    ebp
.text$mn:00000899                 mov     ebp, esp
.text$mn:0000089B                 sub     esp, 0Ch
.text$mn:0000089E                 mov     [ebp+var_4], ecx
.text$mn:000008A1                 mov     [ebp+iResult], 2
.text$mn:000008A8                 mov     eax, [ebp+var_4]
.text$mn:000008AB                 mov     dword ptr [eax], 0
.text$mn:000008B1                 mov     ecx, [ebp+var_4]
.text$mn:000008B4                 mov     dword ptr [ecx+14h], 0
.text$mn:000008BB                 mov     edx, [ebp+var_4]
.text$mn:000008BE                 cmp     dword ptr [edx+1Ch], 1
.text$mn:000008C2                 jbe     short loc_936
.text$mn:000008C4                 mov     eax, 1
.text$mn:000008C9                 imul    ecx, eax, 0
.text$mn:000008CC                 mov     edx, [ebp+var_4]
.text$mn:000008CF                 mov     eax, [edx+4]
.text$mn:000008D2                 movzx   ecx, byte ptr [eax+ecx]
.text$mn:000008D6                 mov     edx, 3
.text$mn:000008DB                 shl     edx, 1
.text$mn:000008DD                 mov     eax, 1
.text$mn:000008E2                 imul    eax, 0
.text$mn:000008E5                 movzx   edx, ?k_Boms@Utf8_16@@2QAY02$$CBEA[edx+eax] ; uchar const (* Utf8_16::k_Boms)[3]
.text$mn:000008ED                 cmp     ecx, edx
.text$mn:000008EF                 jnz     short loc_936
.text$mn:000008F1                 mov     eax, 1
.text$mn:000008F6                 shl     eax, 0
.text$mn:000008F9                 mov     ecx, [ebp+var_4]
.text$mn:000008FC                 mov     edx, [ecx+4]
.text$mn:000008FF                 movzx   eax, byte ptr [edx+eax]
.text$mn:00000903                 mov     ecx, 3
.text$mn:00000908                 shl     ecx, 1
.text$mn:0000090A                 mov     edx, 1
.text$mn:0000090F                 shl     edx, 0
.text$mn:00000912                 movzx   ecx, ?k_Boms@Utf8_16@@2QAY02$$CBEA[ecx+edx] ; uchar const (* Utf8_16::k_Boms)[3]
.text$mn:0000091A                 cmp     eax, ecx
.text$mn:0000091C                 jnz     short loc_936
.text$mn:0000091E                 mov     edx, [ebp+var_4]
.text$mn:00000921                 mov     dword ptr [edx], 2
.text$mn:00000927                 mov     eax, [ebp+var_4]
.text$mn:0000092A                 mov     dword ptr [eax+14h], 2
.text$mn:00000931                 jmp     loc_B06
.text$mn:00000936 ; ---------------------------------------------------------------------------
.text$mn:00000936
.text$mn:00000936 loc_936:                                ; CODE XREF: Utf8_16_Read::determineEncoding(void)+2Aj
.text$mn:00000936                                         ; Utf8_16_Read::determineEncoding(void)+57j ...
.text$mn:00000936                 mov     ecx, [ebp+var_4]
.text$mn:00000939                 cmp     dword ptr [ecx+1Ch], 1
.text$mn:0000093D                 jbe     short loc_9B3
.text$mn:0000093F                 mov     edx, 1
.text$mn:00000944                 imul    eax, edx, 0
.text$mn:00000947                 mov     ecx, [ebp+var_4]
.text$mn:0000094A                 mov     edx, [ecx+4]
.text$mn:0000094D                 movzx   eax, byte ptr [edx+eax]
.text$mn:00000951                 mov     ecx, 3
.text$mn:00000956                 imul    edx, ecx, 3
.text$mn:00000959                 mov     ecx, 1
.text$mn:0000095E                 imul    ecx, 0
.text$mn:00000961                 movzx   edx, ?k_Boms@Utf8_16@@2QAY02$$CBEA[edx+ecx] ; uchar const (* Utf8_16::k_Boms)[3]
.text$mn:00000969                 cmp     eax, edx
.text$mn:0000096B                 jnz     short loc_9B3
.text$mn:0000096D                 mov     eax, 1
.text$mn:00000972                 shl     eax, 0
.text$mn:00000975                 mov     ecx, [ebp+var_4]
.text$mn:00000978                 mov     edx, [ecx+4]
.text$mn:0000097B                 movzx   eax, byte ptr [edx+eax]
.text$mn:0000097F                 mov     ecx, 3
.text$mn:00000984                 imul    edx, ecx, 3
.text$mn:00000987                 mov     ecx, 1
.text$mn:0000098C                 shl     ecx, 0
.text$mn:0000098F                 movzx   edx, ?k_Boms@Utf8_16@@2QAY02$$CBEA[edx+ecx] ; uchar const (* Utf8_16::k_Boms)[3]
.text$mn:00000997                 cmp     eax, edx
.text$mn:00000999                 jnz     short loc_9B3
.text$mn:0000099B                 mov     eax, [ebp+var_4]
.text$mn:0000099E                 mov     dword ptr [eax], 3
.text$mn:000009A4                 mov     ecx, [ebp+var_4]
.text$mn:000009A7                 mov     dword ptr [ecx+14h], 2
.text$mn:000009AE                 jmp     loc_B06
.text$mn:000009B3 ; ---------------------------------------------------------------------------
.text$mn:000009B3
.text$mn:000009B3 loc_9B3:                                ; CODE XREF: Utf8_16_Read::determineEncoding(void)+A5j
.text$mn:000009B3                                         ; Utf8_16_Read::determineEncoding(void)+D3j ...
.text$mn:000009B3                 mov     edx, [ebp+var_4]
.text$mn:000009B6                 cmp     dword ptr [edx+1Ch], 2
.text$mn:000009BA                 jbe     loc_A60
.text$mn:000009C0                 mov     eax, 1
.text$mn:000009C5                 imul    ecx, eax, 0
.text$mn:000009C8                 mov     edx, [ebp+var_4]
.text$mn:000009CB                 mov     eax, [edx+4]
.text$mn:000009CE                 movzx   ecx, byte ptr [eax+ecx]
.text$mn:000009D2                 mov     edx, 3
.text$mn:000009D7                 shl     edx, 0
.text$mn:000009DA                 mov     eax, 1
.text$mn:000009DF                 imul    eax, 0
.text$mn:000009E2                 movzx   edx, ?k_Boms@Utf8_16@@2QAY02$$CBEA[edx+eax] ; uchar const (* Utf8_16::k_Boms)[3]
.text$mn:000009EA                 cmp     ecx, edx
.text$mn:000009EC                 jnz     short loc_A60
.text$mn:000009EE                 mov     eax, 1
.text$mn:000009F3                 shl     eax, 0
.text$mn:000009F6                 mov     ecx, [ebp+var_4]
.text$mn:000009F9                 mov     edx, [ecx+4]
.text$mn:000009FC                 movzx   eax, byte ptr [edx+eax]
.text$mn:00000A00                 mov     ecx, 3
.text$mn:00000A05                 shl     ecx, 0
.text$mn:00000A08                 mov     edx, 1
.text$mn:00000A0D                 shl     edx, 0
.text$mn:00000A10                 movzx   ecx, ?k_Boms@Utf8_16@@2QAY02$$CBEA[ecx+edx] ; uchar const (* Utf8_16::k_Boms)[3]
.text$mn:00000A18                 cmp     eax, ecx
.text$mn:00000A1A                 jnz     short loc_A60
.text$mn:00000A1C                 mov     edx, 1
.text$mn:00000A21                 shl     edx, 1
.text$mn:00000A23                 mov     eax, [ebp+var_4]
.text$mn:00000A26                 mov     ecx, [eax+4]
.text$mn:00000A29                 movzx   edx, byte ptr [ecx+edx]
.text$mn:00000A2D                 mov     eax, 3
.text$mn:00000A32                 shl     eax, 0
.text$mn:00000A35                 mov     ecx, 1
.text$mn:00000A3A                 shl     ecx, 1
.text$mn:00000A3C                 movzx   eax, ?k_Boms@Utf8_16@@2QAY02$$CBEA[eax+ecx] ; uchar const (* Utf8_16::k_Boms)[3]
.text$mn:00000A44                 cmp     edx, eax
.text$mn:00000A46                 jnz     short loc_A60
.text$mn:00000A48                 mov     ecx, [ebp+var_4]
.text$mn:00000A4B                 mov     dword ptr [ecx], 1
.text$mn:00000A51                 mov     edx, [ebp+var_4]
.text$mn:00000A54                 mov     dword ptr [edx+14h], 3
.text$mn:00000A5B                 jmp     loc_B06
.text$mn:00000A60 ; ---------------------------------------------------------------------------
.text$mn:00000A60
.text$mn:00000A60 loc_A60:                                ; CODE XREF: Utf8_16_Read::determineEncoding(void)+122j
.text$mn:00000A60                                         ; Utf8_16_Read::determineEncoding(void)+154j ...
.text$mn:00000A60                 mov     eax, [ebp+var_4]
.text$mn:00000A63                 cmp     dword ptr [eax+1Ch], 1
.text$mn:00000A67                 jbe     short loc_AC6
.text$mn:00000A69                 mov     ecx, 1
.text$mn:00000A6E                 imul    edx, ecx, 0
.text$mn:00000A71                 mov     eax, [ebp+var_4]
.text$mn:00000A74                 mov     ecx, [eax+4]
.text$mn:00000A77                 movzx   edx, byte ptr [ecx+edx]
.text$mn:00000A7B                 test    edx, edx
.text$mn:00000A7D                 jz      short loc_AC6
.text$mn:00000A7F                 mov     eax, 1
.text$mn:00000A84                 shl     eax, 0
.text$mn:00000A87                 mov     ecx, [ebp+var_4]
.text$mn:00000A8A                 mov     edx, [ecx+4]
.text$mn:00000A8D                 movzx   eax, byte ptr [edx+eax]
.text$mn:00000A91                 test    eax, eax
.text$mn:00000A93                 jnz     short loc_AC6
.text$mn:00000A95                 lea     ecx, [ebp+iResult]
.text$mn:00000A98                 push    ecx             ; lpiResult
.text$mn:00000A99                 mov     edx, [ebp+var_4]
.text$mn:00000A9C                 mov     eax, [edx+1Ch]
.text$mn:00000A9F                 push    eax             ; iSize
.text$mn:00000AA0                 mov     ecx, [ebp+var_4]
.text$mn:00000AA3                 mov     edx, [ecx+4]
.text$mn:00000AA6                 push    edx             ; lpv
.text$mn:00000AA7                 call    dword ptr ds:__imp__IsTextUnicode@12 ; IsTextUnicode(x,x,x)
.text$mn:00000AAD                 test    eax, eax
.text$mn:00000AAF                 jz      short loc_AC6
.text$mn:00000AB1                 mov     eax, [ebp+var_4]
.text$mn:00000AB4                 mov     dword ptr [eax], 7
.text$mn:00000ABA                 mov     ecx, [ebp+var_4]
.text$mn:00000ABD                 mov     dword ptr [ecx+14h], 0
.text$mn:00000AC4                 jmp     short loc_B06
.text$mn:00000AC6 ; ---------------------------------------------------------------------------
.text$mn:00000AC6
.text$mn:00000AC6 loc_AC6:                                ; CODE XREF: Utf8_16_Read::determineEncoding(void)+1CFj
.text$mn:00000AC6                                         ; Utf8_16_Read::determineEncoding(void)+1E5j ...
.text$mn:00000AC6                 mov     ecx, [ebp+var_4]
.text$mn:00000AC9                 call    ?utf8_7bits_8bits@Utf8_16_Read@@IAE?AW4u78@@XZ ; Utf8_16_Read::utf8_7bits_8bits(void)
.text$mn:00000ACE                 mov     [ebp+var_8], eax
.text$mn:00000AD1                 cmp     [ebp+var_8], 0
.text$mn:00000AD5                 jnz     short loc_AE2
.text$mn:00000AD7                 mov     edx, [ebp+var_4]
.text$mn:00000ADA                 mov     dword ptr [edx], 4
.text$mn:00000AE0                 jmp     short loc_AFC
.text$mn:00000AE2 ; ---------------------------------------------------------------------------
.text$mn:00000AE2
.text$mn:00000AE2 loc_AE2:                                ; CODE XREF: Utf8_16_Read::determineEncoding(void)+23Dj
.text$mn:00000AE2                 cmp     [ebp+var_8], 1
.text$mn:00000AE6                 jnz     short loc_AF3
.text$mn:00000AE8                 mov     eax, [ebp+var_4]
.text$mn:00000AEB                 mov     dword ptr [eax], 5
.text$mn:00000AF1                 jmp     short loc_AFC
.text$mn:00000AF3 ; ---------------------------------------------------------------------------
.text$mn:00000AF3
.text$mn:00000AF3 loc_AF3:                                ; CODE XREF: Utf8_16_Read::determineEncoding(void)+24Ej
.text$mn:00000AF3                 mov     ecx, [ebp+var_4]
.text$mn:00000AF6                 mov     dword ptr [ecx], 0
.text$mn:00000AFC
.text$mn:00000AFC loc_AFC:                                ; CODE XREF: Utf8_16_Read::determineEncoding(void)+248j
.text$mn:00000AFC                                         ; Utf8_16_Read::determineEncoding(void)+259j
.text$mn:00000AFC                 mov     edx, [ebp+var_4]
.text$mn:00000AFF                 mov     dword ptr [edx+14h], 0
.text$mn:00000B06
.text$mn:00000B06 loc_B06:                                ; CODE XREF: Utf8_16_Read::determineEncoding(void)+99j
.text$mn:00000B06                                         ; Utf8_16_Read::determineEncoding(void)+116j ...
.text$mn:00000B06                 mov     esp, ebp
.text$mn:00000B08                 pop     ebp
.text$mn:00000B09                 retn
.text$mn:00000B09 ?determineEncoding@Utf8_16_Read@@IAEXXZ endp
.text$mn:00000B09
.text$mn:00000B09 ; ---------------------------------------------------------------------------
.text$mn:00000B0A                 db 0Eh dup(0CCh)
.text$mn:00000B18
.text$mn:00000B18 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B18
.text$mn:00000B18 ; Attributes: bp-based frame
.text$mn:00000B18
.text$mn:00000B18 ; protected: enum  u78 __thiscall Utf8_16_Read::utf8_7bits_8bits(void)
.text$mn:00000B18                 public ?utf8_7bits_8bits@Utf8_16_Read@@IAE?AW4u78@@XZ
.text$mn:00000B18 ?utf8_7bits_8bits@Utf8_16_Read@@IAE?AW4u78@@XZ proc near
.text$mn:00000B18                                         ; CODE XREF: Utf8_16_Read::determineEncoding(void)+231p
.text$mn:00000B18
.text$mn:00000B18 var_14          = dword ptr -14h
.text$mn:00000B18 var_10          = dword ptr -10h
.text$mn:00000B18 var_C           = dword ptr -0Ch
.text$mn:00000B18 var_8           = dword ptr -8
.text$mn:00000B18 var_4           = dword ptr -4
.text$mn:00000B18
.text$mn:00000B18                 push    ebp
.text$mn:00000B19                 mov     ebp, esp
.text$mn:00000B1B                 sub     esp, 14h
.text$mn:00000B1E                 mov     [ebp+var_14], ecx
.text$mn:00000B21                 mov     [ebp+var_C], 1
.text$mn:00000B28                 mov     [ebp+var_8], 1
.text$mn:00000B2F                 mov     eax, [ebp+var_14]
.text$mn:00000B32                 mov     ecx, [eax+4]
.text$mn:00000B35                 mov     [ebp+var_4], ecx
.text$mn:00000B38                 mov     edx, [ebp+var_14]
.text$mn:00000B3B                 mov     eax, [ebp+var_4]
.text$mn:00000B3E                 add     eax, [edx+1Ch]
.text$mn:00000B41                 mov     [ebp+var_10], eax
.text$mn:00000B44
.text$mn:00000B44 loc_B44:                                ; CODE XREF: Utf8_16_Read::utf8_7bits_8bits(void):loc_CB7j
.text$mn:00000B44                 mov     ecx, [ebp+var_4]
.text$mn:00000B47                 cmp     ecx, [ebp+var_10]
.text$mn:00000B4A                 jnb     loc_CBC
.text$mn:00000B50                 mov     edx, [ebp+var_4]
.text$mn:00000B53                 movzx   eax, byte ptr [edx]
.text$mn:00000B56                 test    eax, eax
.text$mn:00000B58                 jnz     short loc_B72
.text$mn:00000B5A                 mov     [ebp+var_8], 0
.text$mn:00000B61                 mov     [ebp+var_C], 0
.text$mn:00000B68                 jmp     loc_CBC
.text$mn:00000B6D ; ---------------------------------------------------------------------------
.text$mn:00000B6D                 jmp     loc_CB7
.text$mn:00000B72 ; ---------------------------------------------------------------------------
.text$mn:00000B72
.text$mn:00000B72 loc_B72:                                ; CODE XREF: Utf8_16_Read::utf8_7bits_8bits(void)+40j
.text$mn:00000B72                 mov     ecx, [ebp+var_4]
.text$mn:00000B75                 movzx   edx, byte ptr [ecx]
.text$mn:00000B78                 cmp     edx, 80h ; 'Ç'
.text$mn:00000B7E                 jge     short loc_B8E
.text$mn:00000B80                 mov     eax, [ebp+var_4]
.text$mn:00000B83                 add     eax, 1
.text$mn:00000B86                 mov     [ebp+var_4], eax
.text$mn:00000B89                 jmp     loc_CB7
.text$mn:00000B8E ; ---------------------------------------------------------------------------
.text$mn:00000B8E
.text$mn:00000B8E loc_B8E:                                ; CODE XREF: Utf8_16_Read::utf8_7bits_8bits(void)+66j
.text$mn:00000B8E                 mov     ecx, [ebp+var_4]
.text$mn:00000B91                 movzx   edx, byte ptr [ecx]
.text$mn:00000B94                 cmp     edx, 0C0h ; '+'
.text$mn:00000B9A                 jge     short loc_BB4
.text$mn:00000B9C                 mov     [ebp+var_8], 0
.text$mn:00000BA3                 mov     [ebp+var_C], 0
.text$mn:00000BAA                 jmp     loc_CBC
.text$mn:00000BAF ; ---------------------------------------------------------------------------
.text$mn:00000BAF                 jmp     loc_CB7
.text$mn:00000BB4 ; ---------------------------------------------------------------------------
.text$mn:00000BB4
.text$mn:00000BB4 loc_BB4:                                ; CODE XREF: Utf8_16_Read::utf8_7bits_8bits(void)+82j
.text$mn:00000BB4                 mov     eax, [ebp+var_4]
.text$mn:00000BB7                 movzx   ecx, byte ptr [eax]
.text$mn:00000BBA                 cmp     ecx, 0E0h ; 'a'
.text$mn:00000BC0                 jge     short loc_C24
.text$mn:00000BC2                 mov     [ebp+var_8], 0
.text$mn:00000BC9                 mov     edx, [ebp+var_10]
.text$mn:00000BCC                 sub     edx, 1
.text$mn:00000BCF                 cmp     [ebp+var_4], edx
.text$mn:00000BD2                 jb      short loc_BD9
.text$mn:00000BD4                 jmp     loc_CBC
.text$mn:00000BD9 ; ---------------------------------------------------------------------------
.text$mn:00000BD9
.text$mn:00000BD9 loc_BD9:                                ; CODE XREF: Utf8_16_Read::utf8_7bits_8bits(void)+BAj
.text$mn:00000BD9                 mov     eax, [ebp+var_4]
.text$mn:00000BDC                 movzx   ecx, byte ptr [eax]
.text$mn:00000BDF                 and     ecx, 0C0h
.text$mn:00000BE5                 cmp     ecx, 0C0h ; '+'
.text$mn:00000BEB                 jnz     short loc_C0A
.text$mn:00000BED                 mov     edx, 1
.text$mn:00000BF2                 shl     edx, 0
.text$mn:00000BF5                 mov     eax, [ebp+var_4]
.text$mn:00000BF8                 movzx   ecx, byte ptr [eax+edx]
.text$mn:00000BFC                 and     ecx, 0C0h
.text$mn:00000C02                 cmp     ecx, 80h ; 'Ç'
.text$mn:00000C08                 jz      short loc_C16
.text$mn:00000C0A
.text$mn:00000C0A loc_C0A:                                ; CODE XREF: Utf8_16_Read::utf8_7bits_8bits(void)+D3j
.text$mn:00000C0A                 mov     [ebp+var_C], 0
.text$mn:00000C11                 jmp     loc_CBC
.text$mn:00000C16 ; ---------------------------------------------------------------------------
.text$mn:00000C16
.text$mn:00000C16 loc_C16:                                ; CODE XREF: Utf8_16_Read::utf8_7bits_8bits(void)+F0j
.text$mn:00000C16                 mov     edx, [ebp+var_4]
.text$mn:00000C19                 add     edx, 2
.text$mn:00000C1C                 mov     [ebp+var_4], edx
.text$mn:00000C1F                 jmp     loc_CB7
.text$mn:00000C24 ; ---------------------------------------------------------------------------
.text$mn:00000C24
.text$mn:00000C24 loc_C24:                                ; CODE XREF: Utf8_16_Read::utf8_7bits_8bits(void)+A8j
.text$mn:00000C24                 mov     eax, [ebp+var_4]
.text$mn:00000C27                 movzx   ecx, byte ptr [eax]
.text$mn:00000C2A                 cmp     ecx, 0F0h ; '='
.text$mn:00000C30                 jge     short loc_CA7
.text$mn:00000C32                 mov     [ebp+var_8], 0
.text$mn:00000C39                 mov     edx, [ebp+var_10]
.text$mn:00000C3C                 sub     edx, 2
.text$mn:00000C3F                 cmp     [ebp+var_4], edx
.text$mn:00000C42                 jb      short loc_C46
.text$mn:00000C44                 jmp     short loc_CBC
.text$mn:00000C46 ; ---------------------------------------------------------------------------
.text$mn:00000C46
.text$mn:00000C46 loc_C46:                                ; CODE XREF: Utf8_16_Read::utf8_7bits_8bits(void)+12Aj
.text$mn:00000C46                 mov     eax, [ebp+var_4]
.text$mn:00000C49                 movzx   ecx, byte ptr [eax]
.text$mn:00000C4C                 and     ecx, 0E0h
.text$mn:00000C52                 cmp     ecx, 0E0h ; 'a'
.text$mn:00000C58                 jnz     short loc_C93
.text$mn:00000C5A                 mov     edx, 1
.text$mn:00000C5F                 shl     edx, 0
.text$mn:00000C62                 mov     eax, [ebp+var_4]
.text$mn:00000C65                 movzx   ecx, byte ptr [eax+edx]
.text$mn:00000C69                 and     ecx, 0C0h
.text$mn:00000C6F                 cmp     ecx, 80h ; 'Ç'
.text$mn:00000C75                 jnz     short loc_C93
.text$mn:00000C77                 mov     edx, 1
.text$mn:00000C7C                 shl     edx, 1
.text$mn:00000C7E                 mov     eax, [ebp+var_4]
.text$mn:00000C81                 movzx   ecx, byte ptr [eax+edx]
.text$mn:00000C85                 and     ecx, 0C0h
.text$mn:00000C8B                 cmp     ecx, 80h ; 'Ç'
.text$mn:00000C91                 jz      short loc_C9C
.text$mn:00000C93
.text$mn:00000C93 loc_C93:                                ; CODE XREF: Utf8_16_Read::utf8_7bits_8bits(void)+140j
.text$mn:00000C93                                         ; Utf8_16_Read::utf8_7bits_8bits(void)+15Dj
.text$mn:00000C93                 mov     [ebp+var_C], 0
.text$mn:00000C9A                 jmp     short loc_CBC
.text$mn:00000C9C ; ---------------------------------------------------------------------------
.text$mn:00000C9C
.text$mn:00000C9C loc_C9C:                                ; CODE XREF: Utf8_16_Read::utf8_7bits_8bits(void)+179j
.text$mn:00000C9C                 mov     edx, [ebp+var_4]
.text$mn:00000C9F                 add     edx, 3
.text$mn:00000CA2                 mov     [ebp+var_4], edx
.text$mn:00000CA5                 jmp     short loc_CB7
.text$mn:00000CA7 ; ---------------------------------------------------------------------------
.text$mn:00000CA7
.text$mn:00000CA7 loc_CA7:                                ; CODE XREF: Utf8_16_Read::utf8_7bits_8bits(void)+118j
.text$mn:00000CA7                 mov     [ebp+var_8], 0
.text$mn:00000CAE                 mov     [ebp+var_C], 0
.text$mn:00000CB5                 jmp     short loc_CBC
.text$mn:00000CB7 ; ---------------------------------------------------------------------------
.text$mn:00000CB7
.text$mn:00000CB7 loc_CB7:                                ; CODE XREF: Utf8_16_Read::utf8_7bits_8bits(void)+55j
.text$mn:00000CB7                                         ; Utf8_16_Read::utf8_7bits_8bits(void)+71j ...
.text$mn:00000CB7                 jmp     loc_B44
.text$mn:00000CBC ; ---------------------------------------------------------------------------
.text$mn:00000CBC
.text$mn:00000CBC loc_CBC:                                ; CODE XREF: Utf8_16_Read::utf8_7bits_8bits(void)+32j
.text$mn:00000CBC                                         ; Utf8_16_Read::utf8_7bits_8bits(void)+50j ...
.text$mn:00000CBC                 cmp     [ebp+var_8], 0
.text$mn:00000CC0                 jz      short loc_CC9
.text$mn:00000CC2                 mov     eax, 1
.text$mn:00000CC7                 jmp     short loc_CD8
.text$mn:00000CC9 ; ---------------------------------------------------------------------------
.text$mn:00000CC9
.text$mn:00000CC9 loc_CC9:                                ; CODE XREF: Utf8_16_Read::utf8_7bits_8bits(void)+1A8j
.text$mn:00000CC9                 cmp     [ebp+var_C], 0
.text$mn:00000CCD                 jz      short loc_CD3
.text$mn:00000CCF                 xor     eax, eax
.text$mn:00000CD1                 jmp     short loc_CD8
.text$mn:00000CD3 ; ---------------------------------------------------------------------------
.text$mn:00000CD3
.text$mn:00000CD3 loc_CD3:                                ; CODE XREF: Utf8_16_Read::utf8_7bits_8bits(void)+1B5j
.text$mn:00000CD3                 mov     eax, 2
.text$mn:00000CD8
.text$mn:00000CD8 loc_CD8:                                ; CODE XREF: Utf8_16_Read::utf8_7bits_8bits(void)+1AFj
.text$mn:00000CD8                                         ; Utf8_16_Read::utf8_7bits_8bits(void)+1B9j
.text$mn:00000CD8                 mov     esp, ebp
.text$mn:00000CDA                 pop     ebp
.text$mn:00000CDB                 retn
.text$mn:00000CDB ?utf8_7bits_8bits@Utf8_16_Read@@IAE?AW4u78@@XZ endp
.text$mn:00000CDB
.text$mn:00000CDB ; ---------------------------------------------------------------------------
.text$mn:00000CDC                 db 0Ch dup(0CCh)
.text$mn:00000CE8
.text$mn:00000CE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CE8
.text$mn:00000CE8 ; Attributes: bp-based frame
.text$mn:00000CE8
.text$mn:00000CE8 ; _DWORD __thiscall Utf8_16_Write::Utf8_16_Write(Utf8_16_Write *__hidden this)
.text$mn:00000CE8                 public ??0Utf8_16_Write@@QAE@XZ
.text$mn:00000CE8 ??0Utf8_16_Write@@QAE@XZ proc near
.text$mn:00000CE8
.text$mn:00000CE8 var_4           = dword ptr -4
.text$mn:00000CE8
.text$mn:00000CE8                 push    ebp
.text$mn:00000CE9                 mov     ebp, esp
.text$mn:00000CEB                 push    ecx
.text$mn:00000CEC                 mov     [ebp+var_4], ecx
.text$mn:00000CEF                 mov     eax, [ebp+var_4]
.text$mn:00000CF2                 mov     dword ptr [eax], 0
.text$mn:00000CF8                 mov     ecx, [ebp+var_4]
.text$mn:00000CFB                 mov     dword ptr [ecx+4], 0
.text$mn:00000D02                 mov     edx, [ebp+var_4]
.text$mn:00000D05                 mov     dword ptr [edx+8], 0
.text$mn:00000D0C                 mov     eax, [ebp+var_4]
.text$mn:00000D0F                 mov     byte ptr [eax+10h], 1
.text$mn:00000D13                 mov     ecx, [ebp+var_4]
.text$mn:00000D16                 mov     dword ptr [ecx+0Ch], 0
.text$mn:00000D1D                 mov     eax, [ebp+var_4]
.text$mn:00000D20                 mov     esp, ebp
.text$mn:00000D22                 pop     ebp
.text$mn:00000D23                 retn
.text$mn:00000D23 ??0Utf8_16_Write@@QAE@XZ endp
.text$mn:00000D23
.text$mn:00000D23 ; ---------------------------------------------------------------------------
.text$mn:00000D24                 align 8
.text$mn:00000D28
.text$mn:00000D28 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D28
.text$mn:00000D28 ; Attributes: bp-based frame
.text$mn:00000D28
.text$mn:00000D28 ; _DWORD __thiscall Utf8_16_Write::~Utf8_16_Write(Utf8_16_Write *__hidden this)
.text$mn:00000D28                 public ??1Utf8_16_Write@@QAE@XZ
.text$mn:00000D28 ??1Utf8_16_Write@@QAE@XZ proc near
.text$mn:00000D28
.text$mn:00000D28 var_4           = dword ptr -4
.text$mn:00000D28
.text$mn:00000D28                 push    ebp
.text$mn:00000D29                 mov     ebp, esp
.text$mn:00000D2B                 push    ecx
.text$mn:00000D2C                 mov     [ebp+var_4], ecx
.text$mn:00000D2F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000D32                 call    ?fclose@Utf8_16_Write@@QAEXXZ ; Utf8_16_Write::fclose(void)
.text$mn:00000D37                 mov     esp, ebp
.text$mn:00000D39                 pop     ebp
.text$mn:00000D3A                 retn
.text$mn:00000D3A ??1Utf8_16_Write@@QAE@XZ endp
.text$mn:00000D3A
.text$mn:00000D3A ; ---------------------------------------------------------------------------
.text$mn:00000D3B                 db 0Dh dup(0CCh)
.text$mn:00000D48
.text$mn:00000D48 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D48
.text$mn:00000D48 ; Attributes: bp-based frame
.text$mn:00000D48
.text$mn:00000D48 ; public: void __thiscall Utf8_16_Write::setEncoding(enum  UniMode)
.text$mn:00000D48                 public ?setEncoding@Utf8_16_Write@@QAEXW4UniMode@@@Z
.text$mn:00000D48 ?setEncoding@Utf8_16_Write@@QAEXW4UniMode@@@Z proc near
.text$mn:00000D48
.text$mn:00000D48 var_4           = dword ptr -4
.text$mn:00000D48 arg_0           = dword ptr  8
.text$mn:00000D48
.text$mn:00000D48                 push    ebp
.text$mn:00000D49                 mov     ebp, esp
.text$mn:00000D4B                 push    ecx
.text$mn:00000D4C                 mov     [ebp+var_4], ecx
.text$mn:00000D4F                 mov     eax, [ebp+var_4]
.text$mn:00000D52                 mov     ecx, [ebp+arg_0]
.text$mn:00000D55                 mov     [eax], ecx
.text$mn:00000D57                 mov     esp, ebp
.text$mn:00000D59                 pop     ebp
.text$mn:00000D5A                 retn    4
.text$mn:00000D5A ?setEncoding@Utf8_16_Write@@QAEXW4UniMode@@@Z endp
.text$mn:00000D5A
.text$mn:00000D5A ; ---------------------------------------------------------------------------
.text$mn:00000D5D                 db 0Bh dup(0CCh)
.text$mn:00000D68
.text$mn:00000D68 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D68
.text$mn:00000D68 ; Attributes: bp-based frame
.text$mn:00000D68
.text$mn:00000D68 ; struct _iobuf *__thiscall Utf8_16_Write::fopen(Utf8_16_Write *this, const wchar_t *Filename, const wchar_t *)
.text$mn:00000D68                 public ?fopen@Utf8_16_Write@@QAEPAU_iobuf@@PB_W0@Z
.text$mn:00000D68 ?fopen@Utf8_16_Write@@QAEPAU_iobuf@@PB_W0@Z proc near
.text$mn:00000D68
.text$mn:00000D68 var_4           = dword ptr -4
.text$mn:00000D68 Filename        = dword ptr  8
.text$mn:00000D68 Mode            = dword ptr  0Ch
.text$mn:00000D68
.text$mn:00000D68                 push    ebp
.text$mn:00000D69                 mov     ebp, esp
.text$mn:00000D6B                 push    ecx
.text$mn:00000D6C                 mov     [ebp+var_4], ecx
.text$mn:00000D6F                 mov     eax, [ebp+Mode]
.text$mn:00000D72                 push    eax             ; Mode
.text$mn:00000D73                 mov     ecx, [ebp+Filename]
.text$mn:00000D76                 push    ecx             ; Filename
.text$mn:00000D77                 call    __wfopen
.text$mn:00000D7C                 add     esp, 8
.text$mn:00000D7F                 mov     edx, [ebp+var_4]
.text$mn:00000D82                 mov     [edx+4], eax
.text$mn:00000D85                 mov     eax, [ebp+var_4]
.text$mn:00000D88                 mov     byte ptr [eax+10h], 1
.text$mn:00000D8C                 mov     ecx, [ebp+var_4]
.text$mn:00000D8F                 mov     eax, [ecx+4]
.text$mn:00000D92                 mov     esp, ebp
.text$mn:00000D94                 pop     ebp
.text$mn:00000D95                 retn    8
.text$mn:00000D95 ?fopen@Utf8_16_Write@@QAEPAU_iobuf@@PB_W0@Z endp
.text$mn:00000D95
.text$mn:00000D98
.text$mn:00000D98 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D98
.text$mn:00000D98 ; Attributes: bp-based frame
.text$mn:00000D98
.text$mn:00000D98 ; unsigned int __thiscall Utf8_16_Write::fwrite(Utf8_16_Write *this, const void *Str, unsigned int)
.text$mn:00000D98                 public ?fwrite@Utf8_16_Write@@QAEIPBXI@Z
.text$mn:00000D98 ?fwrite@Utf8_16_Write@@QAEIPBXI@Z proc near
.text$mn:00000D98
.text$mn:00000D98 var_20030       = byte ptr -20030h
.text$mn:00000D98 var_20018       = dword ptr -20018h
.text$mn:00000D98 var_20014       = dword ptr -20014h
.text$mn:00000D98 var_20010       = dword ptr -20010h
.text$mn:00000D98 var_2000C       = dword ptr -2000Ch
.text$mn:00000D98 var_20008       = dword ptr -20008h
.text$mn:00000D98 var_20004       = word ptr -20004h
.text$mn:00000D98 var_4           = dword ptr -4
.text$mn:00000D98 Str             = dword ptr  8
.text$mn:00000D98 Size            = dword ptr  0Ch
.text$mn:00000D98
.text$mn:00000D98                 push    ebp
.text$mn:00000D99                 mov     ebp, esp
.text$mn:00000D9B                 mov     eax, 20030h
.text$mn:00000DA0                 call    __chkstk
.text$mn:00000DA5                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000DAA                 xor     eax, ebp
.text$mn:00000DAC                 mov     [ebp+var_4], eax
.text$mn:00000DAF                 mov     [ebp+var_20008], ecx
.text$mn:00000DB5                 mov     eax, [ebp+var_20008]
.text$mn:00000DBB                 cmp     dword ptr [eax+4], 0
.text$mn:00000DBF                 jnz     short loc_DC8
.text$mn:00000DC1                 xor     eax, eax
.text$mn:00000DC3                 jmp     loc_FB1
.text$mn:00000DC8 ; ---------------------------------------------------------------------------
.text$mn:00000DC8
.text$mn:00000DC8 loc_DC8:                                ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint)+27j
.text$mn:00000DC8                 mov     [ebp+var_20010], 0
.text$mn:00000DD2                 mov     ecx, [ebp+var_20008]
.text$mn:00000DD8                 movzx   edx, byte ptr [ecx+10h]
.text$mn:00000DDC                 test    edx, edx
.text$mn:00000DDE                 jz      loc_E66
.text$mn:00000DE4                 mov     eax, [ebp+var_20008]
.text$mn:00000DEA                 mov     ecx, [eax]
.text$mn:00000DEC                 mov     [ebp+var_20014], ecx
.text$mn:00000DF2                 cmp     [ebp+var_20014], 1
.text$mn:00000DF9                 jz      short loc_E0F
.text$mn:00000DFB                 cmp     [ebp+var_20014], 1
.text$mn:00000E02                 jle     short loc_E5C
.text$mn:00000E04                 cmp     [ebp+var_20014], 3
.text$mn:00000E0B                 jle     short loc_E37
.text$mn:00000E0D                 jmp     short loc_E5C
.text$mn:00000E0F ; ---------------------------------------------------------------------------
.text$mn:00000E0F
.text$mn:00000E0F loc_E0F:                                ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint)+61j
.text$mn:00000E0F                 mov     edx, [ebp+var_20008]
.text$mn:00000E15                 mov     eax, [edx+4]
.text$mn:00000E18                 push    eax             ; File
.text$mn:00000E19                 push    1               ; Count
.text$mn:00000E1B                 push    3               ; Size
.text$mn:00000E1D                 mov     ecx, [ebp+var_20008]
.text$mn:00000E23                 imul    edx, [ecx], 3
.text$mn:00000E26                 add     edx, offset ?k_Boms@Utf8_16@@2QAY02$$CBEA ; uchar const (* Utf8_16::k_Boms)[3]
.text$mn:00000E2C                 push    edx             ; Str
.text$mn:00000E2D                 call    _fwrite
.text$mn:00000E32                 add     esp, 10h
.text$mn:00000E35                 jmp     short loc_E5C
.text$mn:00000E37 ; ---------------------------------------------------------------------------
.text$mn:00000E37
.text$mn:00000E37 loc_E37:                                ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint)+73j
.text$mn:00000E37                 mov     eax, [ebp+var_20008]
.text$mn:00000E3D                 mov     ecx, [eax+4]
.text$mn:00000E40                 push    ecx             ; File
.text$mn:00000E41                 push    1               ; Count
.text$mn:00000E43                 push    2               ; Size
.text$mn:00000E45                 mov     edx, [ebp+var_20008]
.text$mn:00000E4B                 imul    eax, [edx], 3
.text$mn:00000E4E                 add     eax, offset ?k_Boms@Utf8_16@@2QAY02$$CBEA ; uchar const (* Utf8_16::k_Boms)[3]
.text$mn:00000E53                 push    eax             ; Str
.text$mn:00000E54                 call    _fwrite
.text$mn:00000E59                 add     esp, 10h
.text$mn:00000E5C
.text$mn:00000E5C loc_E5C:                                ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint)+6Aj
.text$mn:00000E5C                                         ; Utf8_16_Write::fwrite(void const *,uint)+75j ...
.text$mn:00000E5C                 mov     ecx, [ebp+var_20008]
.text$mn:00000E62                 mov     byte ptr [ecx+10h], 0
.text$mn:00000E66
.text$mn:00000E66 loc_E66:                                ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint)+46j
.text$mn:00000E66                 mov     edx, [ebp+var_20008]
.text$mn:00000E6C                 mov     eax, [edx]
.text$mn:00000E6E                 mov     [ebp+var_20018], eax
.text$mn:00000E74                 cmp     [ebp+var_20018], 7 ; switch 8 cases
.text$mn:00000E7B                 ja      loc_FAB         ; jumptable 00000E8E default case
.text$mn:00000E81                 mov     ecx, [ebp+var_20018]
.text$mn:00000E87                 movzx   edx, ds:$LN21[ecx]
.text$mn:00000E8E                 jmp     ds:$LN22[edx*4] ; switch jump
.text$mn:00000E95 ; ---------------------------------------------------------------------------
.text$mn:00000E95
.text$mn:00000E95 $LN9_0:                                 ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint)+F6j
.text$mn:00000E95                                         ; DATA XREF: .text$mn:$LN22o
.text$mn:00000E95                 mov     eax, [ebp+var_20008] ; jumptable 00000E8E cases 0,1,4,5
.text$mn:00000E9B                 mov     ecx, [eax+4]
.text$mn:00000E9E                 push    ecx             ; File
.text$mn:00000E9F                 push    1               ; Count
.text$mn:00000EA1                 mov     edx, [ebp+Size]
.text$mn:00000EA4                 push    edx             ; Size
.text$mn:00000EA5                 mov     eax, [ebp+Str]
.text$mn:00000EA8                 push    eax             ; Str
.text$mn:00000EA9                 call    _fwrite
.text$mn:00000EAE                 add     esp, 10h
.text$mn:00000EB1                 mov     [ebp+var_20010], eax
.text$mn:00000EB7                 jmp     loc_FAB         ; jumptable 00000E8E default case
.text$mn:00000EBC ; ---------------------------------------------------------------------------
.text$mn:00000EBC
.text$mn:00000EBC $LN8_0:                                 ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint)+F6j
.text$mn:00000EBC                                         ; DATA XREF: .text$mn:$LN22o
.text$mn:00000EBC                 lea     ecx, [ebp+var_20030] ; jumptable 00000E8E cases 2,3,6,7
.text$mn:00000EC2                 call    ??0Utf8_Iter@@QAE@XZ ; Utf8_Iter::Utf8_Iter(void)
.text$mn:00000EC7                 mov     ecx, [ebp+var_20008]
.text$mn:00000ECD                 mov     edx, [ecx]
.text$mn:00000ECF                 push    edx
.text$mn:00000ED0                 mov     eax, [ebp+Size]
.text$mn:00000ED3                 push    eax
.text$mn:00000ED4                 mov     ecx, [ebp+Str]
.text$mn:00000ED7                 push    ecx
.text$mn:00000ED8                 lea     ecx, [ebp+var_20030]
.text$mn:00000EDE                 call    ?set@Utf8_Iter@@QAEXPBEIW4UniMode@@@Z ; Utf8_Iter::set(uchar const *,uint,UniMode)
.text$mn:00000EE3                 mov     [ebp+var_2000C], 0
.text$mn:00000EED
.text$mn:00000EED loc_EED:                                ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint):loc_F9Cj
.text$mn:00000EED                 lea     ecx, [ebp+var_20030]
.text$mn:00000EF3                 call    ??BUtf8_Iter@@QAE_NXZ ; Utf8_Iter::operator bool(void)
.text$mn:00000EF8                 movzx   edx, al
.text$mn:00000EFB                 test    edx, edx
.text$mn:00000EFD                 jz      loc_FA1
.text$mn:00000F03                 lea     ecx, [ebp+var_20030] ; this
.text$mn:00000F09                 call    ?canGet@Utf8_Iter@@QBE_NXZ ; Utf8_Iter::canGet(void)
.text$mn:00000F0E                 movzx   eax, al
.text$mn:00000F11                 test    eax, eax
.text$mn:00000F13                 jz      short loc_F3D
.text$mn:00000F15                 lea     ecx, [ebp+var_20030] ; this
.text$mn:00000F1B                 call    ?get@Utf8_Iter@@QBEGXZ ; Utf8_Iter::get(void)
.text$mn:00000F20                 mov     ecx, [ebp+var_2000C]
.text$mn:00000F26                 mov     [ebp+ecx*2+var_20004], ax
.text$mn:00000F2E                 mov     edx, [ebp+var_2000C]
.text$mn:00000F34                 add     edx, 1
.text$mn:00000F37                 mov     [ebp+var_2000C], edx
.text$mn:00000F3D
.text$mn:00000F3D loc_F3D:                                ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint)+17Bj
.text$mn:00000F3D                 lea     ecx, [ebp+var_20030]
.text$mn:00000F43                 call    ??EUtf8_Iter@@QAEXXZ ; Utf8_Iter::operator++(void)
.text$mn:00000F48                 cmp     [ebp+var_2000C], 10000h
.text$mn:00000F52                 jz      short loc_F66
.text$mn:00000F54                 lea     ecx, [ebp+var_20030]
.text$mn:00000F5A                 call    ??BUtf8_Iter@@QAE_NXZ ; Utf8_Iter::operator bool(void)
.text$mn:00000F5F                 movzx   eax, al
.text$mn:00000F62                 test    eax, eax
.text$mn:00000F64                 jnz     short loc_F9C
.text$mn:00000F66
.text$mn:00000F66 loc_F66:                                ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint)+1BAj
.text$mn:00000F66                 mov     ecx, [ebp+var_20008]
.text$mn:00000F6C                 mov     edx, [ecx+4]
.text$mn:00000F6F                 push    edx             ; File
.text$mn:00000F70                 push    1               ; Count
.text$mn:00000F72                 mov     eax, [ebp+var_2000C]
.text$mn:00000F78                 shl     eax, 1
.text$mn:00000F7A                 push    eax             ; Size
.text$mn:00000F7B                 lea     ecx, [ebp+var_20004]
.text$mn:00000F81                 push    ecx             ; Str
.text$mn:00000F82                 call    _fwrite
.text$mn:00000F87                 add     esp, 10h
.text$mn:00000F8A                 test    eax, eax
.text$mn:00000F8C                 jnz     short loc_F92
.text$mn:00000F8E                 xor     eax, eax
.text$mn:00000F90                 jmp     short loc_FB1
.text$mn:00000F92 ; ---------------------------------------------------------------------------
.text$mn:00000F92
.text$mn:00000F92 loc_F92:                                ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint)+1F4j
.text$mn:00000F92                 mov     [ebp+var_2000C], 0
.text$mn:00000F9C
.text$mn:00000F9C loc_F9C:                                ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint)+1CCj
.text$mn:00000F9C                 jmp     loc_EED
.text$mn:00000FA1 ; ---------------------------------------------------------------------------
.text$mn:00000FA1
.text$mn:00000FA1 loc_FA1:                                ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint)+165j
.text$mn:00000FA1                 mov     [ebp+var_20010], 1
.text$mn:00000FAB
.text$mn:00000FAB loc_FAB:                                ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint)+E3j
.text$mn:00000FAB                                         ; Utf8_16_Write::fwrite(void const *,uint)+11Fj
.text$mn:00000FAB                 mov     eax, [ebp+var_20010] ; jumptable 00000E8E default case
.text$mn:00000FB1
.text$mn:00000FB1 loc_FB1:                                ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint)+2Bj
.text$mn:00000FB1                                         ; Utf8_16_Write::fwrite(void const *,uint)+1F8j
.text$mn:00000FB1                 mov     ecx, [ebp+var_4]
.text$mn:00000FB4                 xor     ecx, ebp
.text$mn:00000FB6                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000FBB                 mov     esp, ebp
.text$mn:00000FBD                 pop     ebp
.text$mn:00000FBE                 retn    8
.text$mn:00000FBE ?fwrite@Utf8_16_Write@@QAEIPBXI@Z endp
.text$mn:00000FBE
.text$mn:00000FBE ; ---------------------------------------------------------------------------
.text$mn:00000FC1                 align 4
.text$mn:00000FC4 $LN22           dd offset $LN9_0        ; DATA XREF: Utf8_16_Write::fwrite(void const *,uint)+F6r
.text$mn:00000FC4                 dd offset $LN8_0        ; jump table for switch statement
.text$mn:00000FCC $LN21           db      0,     0,     1,     1
.text$mn:00000FCC                                         ; DATA XREF: Utf8_16_Write::fwrite(void const *,uint)+EFr
.text$mn:00000FCC                 db      0,     0,     1,     1 ; indirect table for switch statement
.text$mn:00000FD4                 align 8
.text$mn:00000FD8
.text$mn:00000FD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FD8
.text$mn:00000FD8 ; Attributes: bp-based frame
.text$mn:00000FD8
.text$mn:00000FD8 ; void __thiscall Utf8_16_Write::fclose(Utf8_16_Write *__hidden this)
.text$mn:00000FD8                 public ?fclose@Utf8_16_Write@@QAEXXZ
.text$mn:00000FD8 ?fclose@Utf8_16_Write@@QAEXXZ proc near ; CODE XREF: Utf8_16_Write::~Utf8_16_Write(void)+Ap
.text$mn:00000FD8
.text$mn:00000FD8 var_8           = dword ptr -8
.text$mn:00000FD8 var_4           = dword ptr -4
.text$mn:00000FD8
.text$mn:00000FD8                 push    ebp
.text$mn:00000FD9                 mov     ebp, esp
.text$mn:00000FDB                 sub     esp, 8
.text$mn:00000FDE                 mov     [ebp+var_4], ecx
.text$mn:00000FE1                 mov     eax, [ebp+var_4]
.text$mn:00000FE4                 cmp     dword ptr [eax+8], 0
.text$mn:00000FE8                 jz      short loc_FFF
.text$mn:00000FEA                 mov     ecx, [ebp+var_4]
.text$mn:00000FED                 mov     edx, [ecx+8]
.text$mn:00000FF0                 mov     [ebp+var_8], edx
.text$mn:00000FF3                 mov     eax, [ebp+var_8]
.text$mn:00000FF6                 push    eax             ; void *
.text$mn:00000FF7                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:00000FFC                 add     esp, 4
.text$mn:00000FFF
.text$mn:00000FFF loc_FFF:                                ; CODE XREF: Utf8_16_Write::fclose(void)+10j
.text$mn:00000FFF                 mov     ecx, [ebp+var_4]
.text$mn:00001002                 cmp     dword ptr [ecx+4], 0
.text$mn:00001006                 jz      short loc_1017
.text$mn:00001008                 mov     edx, [ebp+var_4]
.text$mn:0000100B                 mov     eax, [edx+4]
.text$mn:0000100E                 push    eax             ; File
.text$mn:0000100F                 call    _fclose
.text$mn:00001014                 add     esp, 4
.text$mn:00001017
.text$mn:00001017 loc_1017:                               ; CODE XREF: Utf8_16_Write::fclose(void)+2Ej
.text$mn:00001017                 mov     esp, ebp
.text$mn:00001019                 pop     ebp
.text$mn:0000101A                 retn
.text$mn:0000101A ?fclose@Utf8_16_Write@@QAEXXZ endp
.text$mn:0000101A
.text$mn:0000101A ; ---------------------------------------------------------------------------
.text$mn:0000101B                 db 0Dh dup(0CCh)
.text$mn:00001028
.text$mn:00001028 ; =============== S U B R O U T I N E =======================================
.text$mn:00001028
.text$mn:00001028 ; Attributes: bp-based frame
.text$mn:00001028
.text$mn:00001028 ; unsigned int __thiscall Utf8_16_Write::convert(Utf8_16_Write *this, char *Src, unsigned int)
.text$mn:00001028                 public ?convert@Utf8_16_Write@@QAEIPADI@Z
.text$mn:00001028 ?convert@Utf8_16_Write@@QAEIPADI@Z proc near
.text$mn:00001028
.text$mn:00001028 var_38          = byte ptr -38h
.text$mn:00001028 var_20          = dword ptr -20h
.text$mn:00001028 var_1C          = dword ptr -1Ch
.text$mn:00001028 var_18          = dword ptr -18h
.text$mn:00001028 var_14          = dword ptr -14h
.text$mn:00001028 var_10          = dword ptr -10h
.text$mn:00001028 var_C           = dword ptr -0Ch
.text$mn:00001028 var_8           = dword ptr -8
.text$mn:00001028 var_4           = dword ptr -4
.text$mn:00001028 Src             = dword ptr  8
.text$mn:00001028 Size            = dword ptr  0Ch
.text$mn:00001028
.text$mn:00001028                 push    ebp
.text$mn:00001029                 mov     ebp, esp
.text$mn:0000102B                 sub     esp, 38h
.text$mn:0000102E                 mov     [ebp+var_4], ecx
.text$mn:00001031                 mov     eax, [ebp+var_4]
.text$mn:00001034                 cmp     dword ptr [eax+8], 0
.text$mn:00001038                 jz      short loc_104F
.text$mn:0000103A                 mov     ecx, [ebp+var_4]
.text$mn:0000103D                 mov     edx, [ecx+8]
.text$mn:00001040                 mov     [ebp+var_10], edx
.text$mn:00001043                 mov     eax, [ebp+var_10]
.text$mn:00001046                 push    eax             ; void *
.text$mn:00001047                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:0000104C                 add     esp, 4
.text$mn:0000104F
.text$mn:0000104F loc_104F:                               ; CODE XREF: Utf8_16_Write::convert(char *,uint)+10j
.text$mn:0000104F                 mov     ecx, [ebp+var_4]
.text$mn:00001052                 mov     edx, [ecx]
.text$mn:00001054                 mov     [ebp+var_C], edx
.text$mn:00001057                 cmp     [ebp+var_C], 7  ; switch 8 cases
.text$mn:0000105B                 ja      loc_1206        ; jumptable 00001064 default case
.text$mn:00001061                 mov     eax, [ebp+var_C]
.text$mn:00001064                 jmp     ds:$LN17_0[eax*4] ; switch jump
.text$mn:0000106B ; ---------------------------------------------------------------------------
.text$mn:0000106B
.text$mn:0000106B $LN11:                                  ; CODE XREF: Utf8_16_Write::convert(char *,uint)+3Cj
.text$mn:0000106B                                         ; DATA XREF: .text$mn:$LN17_0o
.text$mn:0000106B                 mov     ecx, [ebp+var_4] ; jumptable 00001064 cases 0,4,5
.text$mn:0000106E                 mov     edx, [ebp+Size]
.text$mn:00001071                 mov     [ecx+0Ch], edx
.text$mn:00001074                 mov     eax, [ebp+var_4]
.text$mn:00001077                 mov     ecx, [eax+0Ch]
.text$mn:0000107A                 push    ecx             ; unsigned int
.text$mn:0000107B                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:00001080                 add     esp, 4
.text$mn:00001083                 mov     [ebp+var_14], eax
.text$mn:00001086                 mov     edx, [ebp+var_4]
.text$mn:00001089                 mov     eax, [ebp+var_14]
.text$mn:0000108C                 mov     [edx+8], eax
.text$mn:0000108F                 mov     ecx, [ebp+Size]
.text$mn:00001092                 push    ecx             ; Size
.text$mn:00001093                 mov     edx, [ebp+Src]
.text$mn:00001096                 push    edx             ; Src
.text$mn:00001097                 mov     eax, [ebp+var_4]
.text$mn:0000109A                 mov     ecx, [eax+8]
.text$mn:0000109D                 push    ecx             ; Dst
.text$mn:0000109E                 call    _memcpy
.text$mn:000010A3                 add     esp, 0Ch
.text$mn:000010A6                 jmp     loc_1206        ; jumptable 00001064 default case
.text$mn:000010AB ; ---------------------------------------------------------------------------
.text$mn:000010AB
.text$mn:000010AB $LN10_0:                                ; CODE XREF: Utf8_16_Write::convert(char *,uint)+3Cj
.text$mn:000010AB                                         ; DATA XREF: .text$mn:$LN17_0o
.text$mn:000010AB                 mov     edx, [ebp+Size] ; jumptable 00001064 case 1
.text$mn:000010AE                 add     edx, 3
.text$mn:000010B1                 mov     eax, [ebp+var_4]
.text$mn:000010B4                 mov     [eax+0Ch], edx
.text$mn:000010B7                 mov     ecx, [ebp+var_4]
.text$mn:000010BA                 mov     edx, [ecx+0Ch]
.text$mn:000010BD                 push    edx             ; unsigned int
.text$mn:000010BE                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:000010C3                 add     esp, 4
.text$mn:000010C6                 mov     [ebp+var_18], eax
.text$mn:000010C9                 mov     eax, [ebp+var_4]
.text$mn:000010CC                 mov     ecx, [ebp+var_18]
.text$mn:000010CF                 mov     [eax+8], ecx
.text$mn:000010D2                 push    3               ; Size
.text$mn:000010D4                 mov     edx, [ebp+var_4]
.text$mn:000010D7                 imul    eax, [edx], 3
.text$mn:000010DA                 add     eax, offset ?k_Boms@Utf8_16@@2QAY02$$CBEA ; uchar const (* Utf8_16::k_Boms)[3]
.text$mn:000010DF                 push    eax             ; Src
.text$mn:000010E0                 mov     ecx, [ebp+var_4]
.text$mn:000010E3                 mov     edx, [ecx+8]
.text$mn:000010E6                 push    edx             ; Dst
.text$mn:000010E7                 call    _memcpy
.text$mn:000010EC                 add     esp, 0Ch
.text$mn:000010EF                 mov     eax, [ebp+Size]
.text$mn:000010F2                 push    eax             ; Size
.text$mn:000010F3                 mov     ecx, [ebp+Src]
.text$mn:000010F6                 push    ecx             ; Src
.text$mn:000010F7                 mov     edx, 1
.text$mn:000010FC                 imul    eax, edx, 3
.text$mn:000010FF                 mov     ecx, [ebp+var_4]
.text$mn:00001102                 add     eax, [ecx+8]
.text$mn:00001105                 push    eax             ; Dst
.text$mn:00001106                 call    _memcpy
.text$mn:0000110B                 add     esp, 0Ch
.text$mn:0000110E                 jmp     loc_1206        ; jumptable 00001064 default case
.text$mn:00001113 ; ---------------------------------------------------------------------------
.text$mn:00001113
.text$mn:00001113 $LN9_1:                                 ; CODE XREF: Utf8_16_Write::convert(char *,uint)+3Cj
.text$mn:00001113                                         ; DATA XREF: .text$mn:$LN17_0o
.text$mn:00001113                 mov     [ebp+var_8], 0  ; jumptable 00001064 cases 2,3,6,7
.text$mn:0000111A                 mov     edx, [ebp+var_4]
.text$mn:0000111D                 cmp     dword ptr [edx], 2
.text$mn:00001120                 jz      short loc_112A
.text$mn:00001122                 mov     eax, [ebp+var_4]
.text$mn:00001125                 cmp     dword ptr [eax], 3
.text$mn:00001128                 jnz     short loc_1175
.text$mn:0000112A
.text$mn:0000112A loc_112A:                               ; CODE XREF: Utf8_16_Write::convert(char *,uint)+F8j
.text$mn:0000112A                 mov     ecx, [ebp+Size]
.text$mn:0000112D                 lea     edx, [ecx+ecx+2]
.text$mn:00001131                 push    edx             ; unsigned int
.text$mn:00001132                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:00001137                 add     esp, 4
.text$mn:0000113A                 mov     [ebp+var_1C], eax
.text$mn:0000113D                 mov     eax, [ebp+var_4]
.text$mn:00001140                 mov     ecx, [ebp+var_1C]
.text$mn:00001143                 mov     [eax+8], ecx
.text$mn:00001146                 push    2               ; Size
.text$mn:00001148                 mov     edx, [ebp+var_4]
.text$mn:0000114B                 imul    eax, [edx], 3
.text$mn:0000114E                 add     eax, offset ?k_Boms@Utf8_16@@2QAY02$$CBEA ; uchar const (* Utf8_16::k_Boms)[3]
.text$mn:00001153                 push    eax             ; Src
.text$mn:00001154                 mov     ecx, [ebp+var_4]
.text$mn:00001157                 mov     edx, [ecx+8]
.text$mn:0000115A                 push    edx             ; Dst
.text$mn:0000115B                 call    _memcpy
.text$mn:00001160                 add     esp, 0Ch
.text$mn:00001163                 mov     eax, 1
.text$mn:00001168                 shl     eax, 1
.text$mn:0000116A                 mov     ecx, [ebp+var_4]
.text$mn:0000116D                 add     eax, [ecx+8]
.text$mn:00001170                 mov     [ebp+var_8], eax
.text$mn:00001173                 jmp     short loc_1198
.text$mn:00001175 ; ---------------------------------------------------------------------------
.text$mn:00001175
.text$mn:00001175 loc_1175:                               ; CODE XREF: Utf8_16_Write::convert(char *,uint)+100j
.text$mn:00001175                 mov     edx, [ebp+Size]
.text$mn:00001178                 shl     edx, 1
.text$mn:0000117A                 push    edx             ; unsigned int
.text$mn:0000117B                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:00001180                 add     esp, 4
.text$mn:00001183                 mov     [ebp+var_20], eax
.text$mn:00001186                 mov     eax, [ebp+var_4]
.text$mn:00001189                 mov     ecx, [ebp+var_20]
.text$mn:0000118C                 mov     [eax+8], ecx
.text$mn:0000118F                 mov     edx, [ebp+var_4]
.text$mn:00001192                 mov     eax, [edx+8]
.text$mn:00001195                 mov     [ebp+var_8], eax
.text$mn:00001198
.text$mn:00001198 loc_1198:                               ; CODE XREF: Utf8_16_Write::convert(char *,uint)+14Bj
.text$mn:00001198                 lea     ecx, [ebp+var_38]
.text$mn:0000119B                 call    ??0Utf8_Iter@@QAE@XZ ; Utf8_Iter::Utf8_Iter(void)
.text$mn:000011A0                 mov     ecx, [ebp+var_4]
.text$mn:000011A3                 mov     edx, [ecx]
.text$mn:000011A5                 push    edx
.text$mn:000011A6                 mov     eax, [ebp+Size]
.text$mn:000011A9                 push    eax
.text$mn:000011AA                 mov     ecx, [ebp+Src]
.text$mn:000011AD                 push    ecx
.text$mn:000011AE                 lea     ecx, [ebp+var_38]
.text$mn:000011B1                 call    ?set@Utf8_Iter@@QAEXPBEIW4UniMode@@@Z ; Utf8_Iter::set(uchar const *,uint,UniMode)
.text$mn:000011B6                 jmp     short loc_11C0
.text$mn:000011B8 ; ---------------------------------------------------------------------------
.text$mn:000011B8
.text$mn:000011B8 loc_11B8:                               ; CODE XREF: Utf8_16_Write::convert(char *,uint):loc_11F5j
.text$mn:000011B8                 lea     ecx, [ebp+var_38]
.text$mn:000011BB                 call    ??EUtf8_Iter@@QAEXXZ ; Utf8_Iter::operator++(void)
.text$mn:000011C0
.text$mn:000011C0 loc_11C0:                               ; CODE XREF: Utf8_16_Write::convert(char *,uint)+18Ej
.text$mn:000011C0                 lea     ecx, [ebp+var_38]
.text$mn:000011C3                 call    ??BUtf8_Iter@@QAE_NXZ ; Utf8_Iter::operator bool(void)
.text$mn:000011C8                 movzx   edx, al
.text$mn:000011CB                 test    edx, edx
.text$mn:000011CD                 jz      short loc_11F7
.text$mn:000011CF                 lea     ecx, [ebp+var_38] ; this
.text$mn:000011D2                 call    ?canGet@Utf8_Iter@@QBE_NXZ ; Utf8_Iter::canGet(void)
.text$mn:000011D7                 movzx   eax, al
.text$mn:000011DA                 test    eax, eax
.text$mn:000011DC                 jz      short loc_11F5
.text$mn:000011DE                 lea     ecx, [ebp+var_38] ; this
.text$mn:000011E1                 call    ?get@Utf8_Iter@@QBEGXZ ; Utf8_Iter::get(void)
.text$mn:000011E6                 mov     ecx, [ebp+var_8]
.text$mn:000011E9                 mov     [ecx], ax
.text$mn:000011EC                 mov     edx, [ebp+var_8]
.text$mn:000011EF                 add     edx, 2
.text$mn:000011F2                 mov     [ebp+var_8], edx
.text$mn:000011F5
.text$mn:000011F5 loc_11F5:                               ; CODE XREF: Utf8_16_Write::convert(char *,uint)+1B4j
.text$mn:000011F5                 jmp     short loc_11B8
.text$mn:000011F7 ; ---------------------------------------------------------------------------
.text$mn:000011F7
.text$mn:000011F7 loc_11F7:                               ; CODE XREF: Utf8_16_Write::convert(char *,uint)+1A5j
.text$mn:000011F7                 mov     eax, [ebp+var_4]
.text$mn:000011FA                 mov     ecx, [ebp+var_8]
.text$mn:000011FD                 sub     ecx, [eax+8]
.text$mn:00001200                 mov     edx, [ebp+var_4]
.text$mn:00001203                 mov     [edx+0Ch], ecx
.text$mn:00001206
.text$mn:00001206 loc_1206:                               ; CODE XREF: Utf8_16_Write::convert(char *,uint)+33j
.text$mn:00001206                                         ; Utf8_16_Write::convert(char *,uint)+7Ej ...
.text$mn:00001206                 mov     eax, [ebp+var_4] ; jumptable 00001064 default case
.text$mn:00001209                 mov     eax, [eax+0Ch]
.text$mn:0000120C                 mov     esp, ebp
.text$mn:0000120E                 pop     ebp
.text$mn:0000120F                 retn    8
.text$mn:0000120F ?convert@Utf8_16_Write@@QAEIPADI@Z endp
.text$mn:0000120F
.text$mn:0000120F ; ---------------------------------------------------------------------------
.text$mn:00001212                 align 4
.text$mn:00001214 $LN17_0         dd offset $LN11         ; DATA XREF: Utf8_16_Write::convert(char *,uint)+3Cr
.text$mn:00001214                 dd offset $LN10_0       ; jump table for switch statement
.text$mn:00001214                 dd offset $LN9_1
.text$mn:00001214                 dd offset $LN9_1
.text$mn:00001214                 dd offset $LN11
.text$mn:00001214                 dd offset $LN11
.text$mn:00001214                 dd offset $LN9_1
.text$mn:00001214                 dd offset $LN9_1
.text$mn:00001214 _text$mn        ends
.text$mn:00001214
.text$mn:00001234 ; ===========================================================================
.text$mn:00001234
.text$mn:00001234 ; Segment type: Pure code
.text$mn:00001234 ; Segment permissions: Read/Execute
.text$mn:00001234 _text$mn        segment para public 'CODE' use32
.text$mn:00001234                 assume cs:_text$mn
.text$mn:00001234                 ;org 1234h
.text$mn:00001234 ; COMDAT (pick any)
.text$mn:00001234                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001234
.text$mn:00001234 ; =============== S U B R O U T I N E =======================================
.text$mn:00001234
.text$mn:00001234 ; Attributes: bp-based frame
.text$mn:00001234
.text$mn:00001234 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00001234                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00001234 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00001234                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00001234
.text$mn:00001234 var_4           = dword ptr -4
.text$mn:00001234 arg_0           = dword ptr  8
.text$mn:00001234
.text$mn:00001234                 push    ebp
.text$mn:00001235                 mov     ebp, esp
.text$mn:00001237                 push    ecx
.text$mn:00001238                 mov     [ebp+var_4], 0
.text$mn:0000123F                 cmp     [ebp+arg_0], 0
.text$mn:00001243                 jnz     short loc_1247
.text$mn:00001245                 jmp     short loc_1267
.text$mn:00001247 ; ---------------------------------------------------------------------------
.text$mn:00001247
.text$mn:00001247 loc_1247:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00001247                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:0000124B                 ja      short loc_1262
.text$mn:0000124D                 mov     eax, [ebp+arg_0]
.text$mn:00001250                 push    eax             ; unsigned int
.text$mn:00001251                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001256                 add     esp, 4
.text$mn:00001259                 mov     [ebp+var_4], eax
.text$mn:0000125C                 cmp     [ebp+var_4], 0
.text$mn:00001260                 jnz     short loc_1267
.text$mn:00001262
.text$mn:00001262 loc_1262:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:00001262                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001267
.text$mn:00001267 loc_1267:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00001267                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00001267                 mov     eax, [ebp+var_4]
.text$mn:0000126A                 mov     esp, ebp
.text$mn:0000126C                 pop     ebp
.text$mn:0000126D                 retn
.text$mn:0000126D ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:0000126D
.text$mn:0000126D ; ---------------------------------------------------------------------------
.text$mn:0000126E                 align 10h
.text$mn:0000126E _text$mn        ends
.text$mn:0000126E
.text$mn:00001270 ; ===========================================================================
.text$mn:00001270
.text$mn:00001270 ; Segment type: Pure code
.text$mn:00001270 ; Segment permissions: Read/Execute
.text$mn:00001270 _text$mn        segment para public 'CODE' use32
.text$mn:00001270                 assume cs:_text$mn
.text$mn:00001270                 ;org 1270h
.text$mn:00001270 ; COMDAT (pick any)
.text$mn:00001270                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001270
.text$mn:00001270 ; =============== S U B R O U T I N E =======================================
.text$mn:00001270
.text$mn:00001270 ; Attributes: bp-based frame
.text$mn:00001270
.text$mn:00001270 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00001270                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00001270 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00001270                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00001270
.text$mn:00001270 var_4           = dword ptr -4
.text$mn:00001270 arg_0           = dword ptr  8
.text$mn:00001270
.text$mn:00001270                 push    ebp
.text$mn:00001271                 mov     ebp, esp
.text$mn:00001273                 push    ecx
.text$mn:00001274                 mov     [ebp+var_4], 0
.text$mn:0000127B                 cmp     [ebp+arg_0], 0
.text$mn:0000127F                 jnz     short loc_1283
.text$mn:00001281                 jmp     short loc_12A9
.text$mn:00001283 ; ---------------------------------------------------------------------------
.text$mn:00001283
.text$mn:00001283 loc_1283:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:00001283                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:0000128A                 ja      short loc_12A4
.text$mn:0000128C                 mov     eax, [ebp+arg_0]
.text$mn:0000128F                 shl     eax, 3
.text$mn:00001292                 push    eax             ; unsigned int
.text$mn:00001293                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001298                 add     esp, 4
.text$mn:0000129B                 mov     [ebp+var_4], eax
.text$mn:0000129E                 cmp     [ebp+var_4], 0
.text$mn:000012A2                 jnz     short loc_12A9
.text$mn:000012A4
.text$mn:000012A4 loc_12A4:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:000012A4                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000012A9
.text$mn:000012A9 loc_12A9:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:000012A9                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:000012A9                 mov     eax, [ebp+var_4]
.text$mn:000012AC                 mov     esp, ebp
.text$mn:000012AE                 pop     ebp
.text$mn:000012AF                 retn
.text$mn:000012AF ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:000012AF
.text$mn:000012AF _text$mn        ends
.text$mn:000012AF
.text$mn:000012B0 ; ===========================================================================
.text$mn:000012B0
.text$mn:000012B0 ; Segment type: Pure code
.text$mn:000012B0 ; Segment permissions: Read/Execute
.text$mn:000012B0 _text$mn        segment para public 'CODE' use32
.text$mn:000012B0                 assume cs:_text$mn
.text$mn:000012B0                 ;org 12B0h
.text$mn:000012B0 ; COMDAT (pick any)
.text$mn:000012B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000012B0
.text$mn:000012B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000012B0
.text$mn:000012B0 ; Attributes: bp-based frame
.text$mn:000012B0
.text$mn:000012B0 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:000012B0                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:000012B0 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:000012B0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:000012B0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:000012B0
.text$mn:000012B0 arg_0           = dword ptr  8
.text$mn:000012B0 arg_4           = dword ptr  0Ch
.text$mn:000012B0 arg_8           = dword ptr  10h
.text$mn:000012B0
.text$mn:000012B0                 push    ebp
.text$mn:000012B1                 mov     ebp, esp
.text$mn:000012B3                 cmp     [ebp+arg_0], 0
.text$mn:000012B7                 jnz     short loc_12CE
.text$mn:000012B9                 mov     eax, [ebp+arg_8]
.text$mn:000012BC                 push    eax             ; unsigned int
.text$mn:000012BD                 mov     ecx, [ebp+arg_4]
.text$mn:000012C0                 push    ecx             ; wchar_t *
.text$mn:000012C1                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000012C6                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000012CB                 add     esp, 0Ch
.text$mn:000012CE
.text$mn:000012CE loc_12CE:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:000012CE                 pop     ebp
.text$mn:000012CF                 retn
.text$mn:000012CF ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:000012CF
.text$mn:000012CF _text$mn        ends
.text$mn:000012CF
.text$mn:000012D0 ; ===========================================================================
.text$mn:000012D0
.text$mn:000012D0 ; Segment type: Pure code
.text$mn:000012D0 ; Segment permissions: Read/Execute
.text$mn:000012D0 _text$mn        segment para public 'CODE' use32
.text$mn:000012D0                 assume cs:_text$mn
.text$mn:000012D0                 ;org 12D0h
.text$mn:000012D0 ; COMDAT (pick any)
.text$mn:000012D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000012D0
.text$mn:000012D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000012D0
.text$mn:000012D0 ; Attributes: bp-based frame
.text$mn:000012D0
.text$mn:000012D0 ; char * __cdecl std::addressof<char>(char &)
.text$mn:000012D0                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:000012D0 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:000012D0                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:000012D0                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:000012D0
.text$mn:000012D0 arg_0           = dword ptr  8
.text$mn:000012D0
.text$mn:000012D0                 push    ebp
.text$mn:000012D1                 mov     ebp, esp
.text$mn:000012D3                 mov     eax, [ebp+arg_0]
.text$mn:000012D6                 pop     ebp
.text$mn:000012D7                 retn
.text$mn:000012D7 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:000012D7
.text$mn:000012D7 _text$mn        ends
.text$mn:000012D7
.text$mn:000012D8 ; ===========================================================================
.text$mn:000012D8
.text$mn:000012D8 ; Segment type: Pure code
.text$mn:000012D8 ; Segment permissions: Read/Execute
.text$mn:000012D8 _text$mn        segment para public 'CODE' use32
.text$mn:000012D8                 assume cs:_text$mn
.text$mn:000012D8                 ;org 12D8h
.text$mn:000012D8 ; COMDAT (pick any)
.text$mn:000012D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000012D8
.text$mn:000012D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000012D8
.text$mn:000012D8 ; Attributes: bp-based frame
.text$mn:000012D8
.text$mn:000012D8 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:000012D8                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:000012D8 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000012D8                                         ; CODE XREF: $LN19+4Bp
.text$mn:000012D8
.text$mn:000012D8 var_4           = dword ptr -4
.text$mn:000012D8 arg_0           = dword ptr  8
.text$mn:000012D8 arg_4           = dword ptr  0Ch
.text$mn:000012D8
.text$mn:000012D8                 push    ebp
.text$mn:000012D9                 mov     ebp, esp
.text$mn:000012DB                 push    ecx
.text$mn:000012DC                 mov     [ebp+var_4], ecx
.text$mn:000012DF                 mov     eax, [ebp+arg_4]
.text$mn:000012E2                 push    eax
.text$mn:000012E3                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000012E8                 add     esp, 4
.text$mn:000012EB                 push    eax             ; int
.text$mn:000012EC                 mov     ecx, [ebp+arg_0]
.text$mn:000012EF                 push    ecx             ; void *
.text$mn:000012F0                 mov     edx, [ebp+var_4]
.text$mn:000012F3                 push    edx             ; int
.text$mn:000012F4                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:000012F9                 add     esp, 0Ch
.text$mn:000012FC                 mov     esp, ebp
.text$mn:000012FE                 pop     ebp
.text$mn:000012FF                 retn    8
.text$mn:000012FF ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000012FF
.text$mn:000012FF ; ---------------------------------------------------------------------------
.text$mn:00001302                 align 4
.text$mn:00001302 _text$mn        ends
.text$mn:00001302
.text$mn:00001304 ; ===========================================================================
.text$mn:00001304
.text$mn:00001304 ; Segment type: Pure code
.text$mn:00001304 ; Segment permissions: Read/Execute
.text$mn:00001304 _text$mn        segment para public 'CODE' use32
.text$mn:00001304                 assume cs:_text$mn
.text$mn:00001304                 ;org 1304h
.text$mn:00001304 ; COMDAT (pick any)
.text$mn:00001304                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001304
.text$mn:00001304 ; =============== S U B R O U T I N E =======================================
.text$mn:00001304
.text$mn:00001304 ; Attributes: bp-based frame
.text$mn:00001304
.text$mn:00001304 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00001304                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00001304 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00001304                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00001304
.text$mn:00001304 var_1C          = dword ptr -1Ch
.text$mn:00001304 var_18          = dword ptr -18h
.text$mn:00001304 var_14          = dword ptr -14h
.text$mn:00001304 var_10          = dword ptr -10h
.text$mn:00001304 var_C           = dword ptr -0Ch
.text$mn:00001304 var_4           = dword ptr -4
.text$mn:00001304 arg_0           = dword ptr  8
.text$mn:00001304 arg_4           = dword ptr  0Ch
.text$mn:00001304
.text$mn:00001304                 push    ebp
.text$mn:00001305                 mov     ebp, esp
.text$mn:00001307                 push    0FFFFFFFFh
.text$mn:00001309                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:0000130E                 mov     eax, large fs:0
.text$mn:00001314                 push    eax
.text$mn:00001315                 sub     esp, 10h
.text$mn:00001318                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000131D                 xor     eax, ebp
.text$mn:0000131F                 push    eax
.text$mn:00001320                 lea     eax, [ebp+var_C]
.text$mn:00001323                 mov     large fs:0, eax
.text$mn:00001329                 mov     [ebp+var_18], ecx
.text$mn:0000132C                 mov     eax, [ebp+arg_0]
.text$mn:0000132F                 push    eax             ; void *
.text$mn:00001330                 push    4               ; unsigned int
.text$mn:00001332                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00001337                 add     esp, 8
.text$mn:0000133A                 mov     [ebp+var_10], eax
.text$mn:0000133D                 mov     [ebp+var_4], 0
.text$mn:00001344                 cmp     [ebp+var_10], 0
.text$mn:00001348                 jz      short loc_1365
.text$mn:0000134A                 mov     ecx, [ebp+arg_4]
.text$mn:0000134D                 push    ecx
.text$mn:0000134E                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00001353                 add     esp, 4
.text$mn:00001356                 mov     edx, [ebp+var_10]
.text$mn:00001359                 mov     eax, [eax]
.text$mn:0000135B                 mov     [edx], eax
.text$mn:0000135D                 mov     ecx, [ebp+var_10]
.text$mn:00001360                 mov     [ebp+var_14], ecx
.text$mn:00001363                 jmp     short loc_136C
.text$mn:00001365 ; ---------------------------------------------------------------------------
.text$mn:00001365
.text$mn:00001365 loc_1365:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00001365                 mov     [ebp+var_14], 0
.text$mn:0000136C
.text$mn:0000136C loc_136C:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:0000136C                 mov     edx, [ebp+var_14]
.text$mn:0000136F                 mov     [ebp+var_1C], edx
.text$mn:00001372                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001379                 mov     ecx, [ebp+var_C]
.text$mn:0000137C                 mov     large fs:0, ecx
.text$mn:00001383                 pop     ecx
.text$mn:00001384                 mov     esp, ebp
.text$mn:00001386                 pop     ebp
.text$mn:00001387                 retn    8
.text$mn:00001387 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00001387
.text$mn:00001387 ; ---------------------------------------------------------------------------
.text$mn:0000138A                 align 4
.text$mn:0000138A _text$mn        ends
.text$mn:0000138A
.text$x:0000138C ; ===========================================================================
.text$x:0000138C
.text$x:0000138C ; Segment type: Pure code
.text$x:0000138C ; Segment permissions: Read/Execute
.text$x:0000138C _text$x         segment para public 'CODE' use32
.text$x:0000138C                 assume cs:_text$x
.text$x:0000138C                 ;org 138Ch
.text$x:0000138C ; COMDAT (pick associative to section at 1304)
.text$x:0000138C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000138C
.text$x:0000138C ; =============== S U B R O U T I N E =======================================
.text$x:0000138C
.text$x:0000138C
.text$x:0000138C __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:0000138C                                         ; DATA XREF: .xdata$x:00002F94o
.text$x:0000138C                 mov     eax, [ebp+8]
.text$x:0000138F                 push    eax
.text$x:00001390                 mov     eax, [ebp-10h]
.text$x:00001393                 push    eax             ; void *
.text$x:00001394                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00001399                 add     esp, 8
.text$x:0000139C                 retn
.text$x:0000139C __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:0000139C
.text$x:0000139D
.text$x:0000139D ; =============== S U B R O U T I N E =======================================
.text$x:0000139D
.text$x:0000139D
.text$x:0000139D __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:0000139D                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:0000139D
.text$x:0000139D arg_4           = dword ptr  8
.text$x:0000139D
.text$x:0000139D                 mov     edx, [esp+arg_4]
.text$x:000013A1                 lea     eax, [edx+0Ch]
.text$x:000013A4                 mov     ecx, [edx-14h]
.text$x:000013A7                 xor     ecx, eax
.text$x:000013A9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000013AE                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:000013B3                 jmp     ___CxxFrameHandler3
.text$x:000013B3 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:000013B3
.text$x:000013B3 _text$x         ends
.text$x:000013B3
.text$mn:000013B8 ; ===========================================================================
.text$mn:000013B8
.text$mn:000013B8 ; Segment type: Pure code
.text$mn:000013B8 ; Segment permissions: Read/Execute
.text$mn:000013B8 _text$mn        segment para public 'CODE' use32
.text$mn:000013B8                 assume cs:_text$mn
.text$mn:000013B8                 ;org 13B8h
.text$mn:000013B8 ; COMDAT (pick any)
.text$mn:000013B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000013B8
.text$mn:000013B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000013B8
.text$mn:000013B8 ; Attributes: bp-based frame
.text$mn:000013B8
.text$mn:000013B8 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:000013B8                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:000013B8 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:000013B8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:000013B8
.text$mn:000013B8 arg_0           = dword ptr  8
.text$mn:000013B8 arg_4           = dword ptr  0Ch
.text$mn:000013B8 arg_8           = dword ptr  10h
.text$mn:000013B8
.text$mn:000013B8                 push    ebp
.text$mn:000013B9                 mov     ebp, esp
.text$mn:000013BB                 mov     eax, [ebp+arg_8]
.text$mn:000013BE                 push    eax
.text$mn:000013BF                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000013C4                 add     esp, 4
.text$mn:000013C7                 push    eax             ; int
.text$mn:000013C8                 mov     ecx, [ebp+arg_4]
.text$mn:000013CB                 push    ecx             ; void *
.text$mn:000013CC                 mov     ecx, [ebp+arg_0]
.text$mn:000013CF                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:000013D4                 pop     ebp
.text$mn:000013D5                 retn
.text$mn:000013D5 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:000013D5
.text$mn:000013D5 ; ---------------------------------------------------------------------------
.text$mn:000013D6                 align 4
.text$mn:000013D6 _text$mn        ends
.text$mn:000013D6
.text$mn:000013D8 ; ===========================================================================
.text$mn:000013D8
.text$mn:000013D8 ; Segment type: Pure code
.text$mn:000013D8 ; Segment permissions: Read/Execute
.text$mn:000013D8 _text$mn        segment para public 'CODE' use32
.text$mn:000013D8                 assume cs:_text$mn
.text$mn:000013D8                 ;org 13D8h
.text$mn:000013D8 ; COMDAT (pick any)
.text$mn:000013D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000013D8
.text$mn:000013D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000013D8
.text$mn:000013D8 ; Attributes: bp-based frame
.text$mn:000013D8
.text$mn:000013D8 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:000013D8                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000013D8 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:000013D8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:000013D8
.text$mn:000013D8 var_1C          = dword ptr -1Ch
.text$mn:000013D8 var_18          = dword ptr -18h
.text$mn:000013D8 var_14          = dword ptr -14h
.text$mn:000013D8 var_10          = dword ptr -10h
.text$mn:000013D8 var_C           = dword ptr -0Ch
.text$mn:000013D8 var_4           = dword ptr -4
.text$mn:000013D8 arg_0           = dword ptr  8
.text$mn:000013D8 arg_4           = dword ptr  0Ch
.text$mn:000013D8
.text$mn:000013D8                 push    ebp
.text$mn:000013D9                 mov     ebp, esp
.text$mn:000013DB                 push    0FFFFFFFFh
.text$mn:000013DD                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000013E2                 mov     eax, large fs:0
.text$mn:000013E8                 push    eax
.text$mn:000013E9                 sub     esp, 10h
.text$mn:000013EC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000013F1                 xor     eax, ebp
.text$mn:000013F3                 push    eax
.text$mn:000013F4                 lea     eax, [ebp+var_C]
.text$mn:000013F7                 mov     large fs:0, eax
.text$mn:000013FD                 mov     [ebp+var_18], ecx
.text$mn:00001400                 mov     eax, [ebp+arg_0]
.text$mn:00001403                 push    eax             ; void *
.text$mn:00001404                 push    8               ; unsigned int
.text$mn:00001406                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000140B                 add     esp, 8
.text$mn:0000140E                 mov     [ebp+var_10], eax
.text$mn:00001411                 mov     [ebp+var_4], 0
.text$mn:00001418                 cmp     [ebp+var_10], 0
.text$mn:0000141C                 jz      short loc_143F
.text$mn:0000141E                 mov     ecx, [ebp+arg_4]
.text$mn:00001421                 push    ecx
.text$mn:00001422                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00001427                 add     esp, 4
.text$mn:0000142A                 mov     edx, [eax]
.text$mn:0000142C                 mov     eax, [eax+4]
.text$mn:0000142F                 mov     ecx, [ebp+var_10]
.text$mn:00001432                 mov     [ecx], edx
.text$mn:00001434                 mov     [ecx+4], eax
.text$mn:00001437                 mov     edx, [ebp+var_10]
.text$mn:0000143A                 mov     [ebp+var_14], edx
.text$mn:0000143D                 jmp     short loc_1446
.text$mn:0000143F ; ---------------------------------------------------------------------------
.text$mn:0000143F
.text$mn:0000143F loc_143F:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:0000143F                 mov     [ebp+var_14], 0
.text$mn:00001446
.text$mn:00001446 loc_1446:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00001446                 mov     eax, [ebp+var_14]
.text$mn:00001449                 mov     [ebp+var_1C], eax
.text$mn:0000144C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001453                 mov     ecx, [ebp+var_C]
.text$mn:00001456                 mov     large fs:0, ecx
.text$mn:0000145D                 pop     ecx
.text$mn:0000145E                 mov     esp, ebp
.text$mn:00001460                 pop     ebp
.text$mn:00001461                 retn    8
.text$mn:00001461 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00001461
.text$mn:00001461 _text$mn        ends
.text$mn:00001461
.text$x:00001464 ; ===========================================================================
.text$x:00001464
.text$x:00001464 ; Segment type: Pure code
.text$x:00001464 ; Segment permissions: Read/Execute
.text$x:00001464 _text$x         segment para public 'CODE' use32
.text$x:00001464                 assume cs:_text$x
.text$x:00001464                 ;org 1464h
.text$x:00001464 ; COMDAT (pick associative to section at 13D8)
.text$x:00001464                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001464
.text$x:00001464 ; =============== S U B R O U T I N E =======================================
.text$x:00001464
.text$x:00001464
.text$x:00001464 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00001464                                         ; DATA XREF: .xdata$x:00002F68o
.text$x:00001464                 mov     eax, [ebp+8]
.text$x:00001467                 push    eax
.text$x:00001468                 mov     eax, [ebp-10h]
.text$x:0000146B                 push    eax             ; void *
.text$x:0000146C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00001471                 add     esp, 8
.text$x:00001474                 retn
.text$x:00001474 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00001474
.text$x:00001475
.text$x:00001475 ; =============== S U B R O U T I N E =======================================
.text$x:00001475
.text$x:00001475
.text$x:00001475 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00001475                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00001475
.text$x:00001475 arg_4           = dword ptr  8
.text$x:00001475
.text$x:00001475                 mov     edx, [esp+arg_4]
.text$x:00001479                 lea     eax, [edx+0Ch]
.text$x:0000147C                 mov     ecx, [edx-14h]
.text$x:0000147F                 xor     ecx, eax
.text$x:00001481                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001486                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:0000148B                 jmp     ___CxxFrameHandler3
.text$x:0000148B __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:0000148B
.text$x:0000148B _text$x         ends
.text$x:0000148B
.text$mn:00001490 ; ===========================================================================
.text$mn:00001490
.text$mn:00001490 ; Segment type: Pure code
.text$mn:00001490 ; Segment permissions: Read/Execute
.text$mn:00001490 _text$mn        segment para public 'CODE' use32
.text$mn:00001490                 assume cs:_text$mn
.text$mn:00001490                 ;org 1490h
.text$mn:00001490 ; COMDAT (pick any)
.text$mn:00001490                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001490
.text$mn:00001490 ; =============== S U B R O U T I N E =======================================
.text$mn:00001490
.text$mn:00001490 ; Attributes: bp-based frame
.text$mn:00001490
.text$mn:00001490 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00001490                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00001490 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00001490                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00001490
.text$mn:00001490 var_4           = dword ptr -4
.text$mn:00001490 arg_0           = dword ptr  8
.text$mn:00001490
.text$mn:00001490                 push    ebp
.text$mn:00001491                 mov     ebp, esp
.text$mn:00001493                 push    ecx
.text$mn:00001494                 mov     [ebp+var_4], ecx
.text$mn:00001497                 mov     eax, [ebp+arg_0]
.text$mn:0000149A                 push    eax
.text$mn:0000149B                 mov     ecx, [ebp+var_4]
.text$mn:0000149E                 push    ecx
.text$mn:0000149F                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:000014A4                 add     esp, 8
.text$mn:000014A7                 mov     esp, ebp
.text$mn:000014A9                 pop     ebp
.text$mn:000014AA                 retn    4
.text$mn:000014AA ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:000014AA
.text$mn:000014AA ; ---------------------------------------------------------------------------
.text$mn:000014AD                 align 10h
.text$mn:000014AD _text$mn        ends
.text$mn:000014AD
.text$mn:000014B0 ; ===========================================================================
.text$mn:000014B0
.text$mn:000014B0 ; Segment type: Pure code
.text$mn:000014B0 ; Segment permissions: Read/Execute
.text$mn:000014B0 _text$mn        segment para public 'CODE' use32
.text$mn:000014B0                 assume cs:_text$mn
.text$mn:000014B0                 ;org 14B0h
.text$mn:000014B0 ; COMDAT (pick any)
.text$mn:000014B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014B0
.text$mn:000014B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000014B0
.text$mn:000014B0 ; Attributes: bp-based frame
.text$mn:000014B0
.text$mn:000014B0 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:000014B0                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:000014B0 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:000014B0                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:000014B0
.text$mn:000014B0 var_4           = dword ptr -4
.text$mn:000014B0
.text$mn:000014B0                 push    ebp
.text$mn:000014B1                 mov     ebp, esp
.text$mn:000014B3                 push    ecx
.text$mn:000014B4                 mov     [ebp+var_4], ecx
.text$mn:000014B7                 mov     esp, ebp
.text$mn:000014B9                 pop     ebp
.text$mn:000014BA                 retn    4
.text$mn:000014BA ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:000014BA
.text$mn:000014BA ; ---------------------------------------------------------------------------
.text$mn:000014BD                 align 10h
.text$mn:000014BD _text$mn        ends
.text$mn:000014BD
.text$mn:000014C0 ; ===========================================================================
.text$mn:000014C0
.text$mn:000014C0 ; Segment type: Pure code
.text$mn:000014C0 ; Segment permissions: Read/Execute
.text$mn:000014C0 _text$mn        segment para public 'CODE' use32
.text$mn:000014C0                 assume cs:_text$mn
.text$mn:000014C0                 ;org 14C0h
.text$mn:000014C0 ; COMDAT (pick any)
.text$mn:000014C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014C0
.text$mn:000014C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000014C0
.text$mn:000014C0 ; Attributes: bp-based frame
.text$mn:000014C0
.text$mn:000014C0 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:000014C0                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:000014C0 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:000014C0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:000014C0
.text$mn:000014C0 arg_0           = dword ptr  8
.text$mn:000014C0 arg_4           = dword ptr  0Ch
.text$mn:000014C0
.text$mn:000014C0                 push    ebp
.text$mn:000014C1                 mov     ebp, esp
.text$mn:000014C3                 mov     eax, [ebp+arg_4]
.text$mn:000014C6                 push    eax
.text$mn:000014C7                 mov     ecx, [ebp+arg_0]
.text$mn:000014CA                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:000014CF                 pop     ebp
.text$mn:000014D0                 retn
.text$mn:000014D0 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:000014D0
.text$mn:000014D0 ; ---------------------------------------------------------------------------
.text$mn:000014D1                 align 4
.text$mn:000014D1 _text$mn        ends
.text$mn:000014D1
.text$mn:000014D4 ; ===========================================================================
.text$mn:000014D4
.text$mn:000014D4 ; Segment type: Pure code
.text$mn:000014D4 ; Segment permissions: Read/Execute
.text$mn:000014D4 _text$mn        segment para public 'CODE' use32
.text$mn:000014D4                 assume cs:_text$mn
.text$mn:000014D4                 ;org 14D4h
.text$mn:000014D4 ; COMDAT (pick any)
.text$mn:000014D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014D4
.text$mn:000014D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000014D4
.text$mn:000014D4 ; Attributes: bp-based frame
.text$mn:000014D4
.text$mn:000014D4 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:000014D4                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:000014D4 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:000014D4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:000014D4
.text$mn:000014D4 var_4           = dword ptr -4
.text$mn:000014D4
.text$mn:000014D4                 push    ebp
.text$mn:000014D5                 mov     ebp, esp
.text$mn:000014D7                 push    ecx
.text$mn:000014D8                 mov     [ebp+var_4], ecx
.text$mn:000014DB                 mov     esp, ebp
.text$mn:000014DD                 pop     ebp
.text$mn:000014DE                 retn    4
.text$mn:000014DE ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:000014DE
.text$mn:000014DE ; ---------------------------------------------------------------------------
.text$mn:000014E1                 align 4
.text$mn:000014E1 _text$mn        ends
.text$mn:000014E1
.text$mn:000014E4 ; ===========================================================================
.text$mn:000014E4
.text$mn:000014E4 ; Segment type: Pure code
.text$mn:000014E4 ; Segment permissions: Read/Execute
.text$mn:000014E4 _text$mn        segment para public 'CODE' use32
.text$mn:000014E4                 assume cs:_text$mn
.text$mn:000014E4                 ;org 14E4h
.text$mn:000014E4 ; COMDAT (pick any)
.text$mn:000014E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014E4
.text$mn:000014E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000014E4
.text$mn:000014E4 ; Attributes: bp-based frame
.text$mn:000014E4
.text$mn:000014E4 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:000014E4                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:000014E4 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:000014E4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:000014E4                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:000014E4
.text$mn:000014E4 arg_0           = dword ptr  8
.text$mn:000014E4
.text$mn:000014E4                 push    ebp
.text$mn:000014E5                 mov     ebp, esp
.text$mn:000014E7                 mov     eax, [ebp+arg_0]
.text$mn:000014EA                 pop     ebp
.text$mn:000014EB                 retn
.text$mn:000014EB ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:000014EB
.text$mn:000014EB _text$mn        ends
.text$mn:000014EB
.text$mn:000014EC ; ===========================================================================
.text$mn:000014EC
.text$mn:000014EC ; Segment type: Pure code
.text$mn:000014EC ; Segment permissions: Read/Execute
.text$mn:000014EC _text$mn        segment para public 'CODE' use32
.text$mn:000014EC                 assume cs:_text$mn
.text$mn:000014EC                 ;org 14ECh
.text$mn:000014EC ; COMDAT (pick any)
.text$mn:000014EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014EC
.text$mn:000014EC ; =============== S U B R O U T I N E =======================================
.text$mn:000014EC
.text$mn:000014EC ; Attributes: bp-based frame
.text$mn:000014EC
.text$mn:000014EC ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:000014EC                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:000014EC ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:000014EC                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:000014EC
.text$mn:000014EC arg_0           = dword ptr  8
.text$mn:000014EC
.text$mn:000014EC                 push    ebp
.text$mn:000014ED                 mov     ebp, esp
.text$mn:000014EF                 mov     eax, [ebp+arg_0]
.text$mn:000014F2                 pop     ebp
.text$mn:000014F3                 retn
.text$mn:000014F3 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:000014F3
.text$mn:000014F3 _text$mn        ends
.text$mn:000014F3
.text$mn:000014F4 ; ===========================================================================
.text$mn:000014F4
.text$mn:000014F4 ; Segment type: Pure code
.text$mn:000014F4 ; Segment permissions: Read/Execute
.text$mn:000014F4 _text$mn        segment para public 'CODE' use32
.text$mn:000014F4                 assume cs:_text$mn
.text$mn:000014F4                 ;org 14F4h
.text$mn:000014F4 ; COMDAT (pick any)
.text$mn:000014F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014F4
.text$mn:000014F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000014F4
.text$mn:000014F4 ; Attributes: bp-based frame
.text$mn:000014F4
.text$mn:000014F4 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:000014F4                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:000014F4 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:000014F4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:000014F4
.text$mn:000014F4 var_10          = dword ptr -10h
.text$mn:000014F4 var_C           = dword ptr -0Ch
.text$mn:000014F4 var_4           = dword ptr -4
.text$mn:000014F4
.text$mn:000014F4                 push    ebp
.text$mn:000014F5                 mov     ebp, esp
.text$mn:000014F7                 push    0FFFFFFFFh
.text$mn:000014F9                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:000014FE                 mov     eax, large fs:0
.text$mn:00001504                 push    eax
.text$mn:00001505                 push    ecx
.text$mn:00001506                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000150B                 xor     eax, ebp
.text$mn:0000150D                 push    eax
.text$mn:0000150E                 lea     eax, [ebp+var_C]
.text$mn:00001511                 mov     large fs:0, eax
.text$mn:00001517                 mov     [ebp+var_10], ecx
.text$mn:0000151A                 mov     ecx, [ebp+var_10]
.text$mn:0000151D                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00001522                 mov     [ebp+var_4], 0
.text$mn:00001529                 mov     ecx, [ebp+var_10]
.text$mn:0000152C                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00001531                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001538                 mov     eax, [ebp+var_10]
.text$mn:0000153B                 mov     ecx, [ebp+var_C]
.text$mn:0000153E                 mov     large fs:0, ecx
.text$mn:00001545                 pop     ecx
.text$mn:00001546                 mov     esp, ebp
.text$mn:00001548                 pop     ebp
.text$mn:00001549                 retn    4
.text$mn:00001549 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00001549
.text$mn:00001549 _text$mn        ends
.text$mn:00001549
.text$x:0000154C ; ===========================================================================
.text$x:0000154C
.text$x:0000154C ; Segment type: Pure code
.text$x:0000154C ; Segment permissions: Read/Execute
.text$x:0000154C _text$x         segment para public 'CODE' use32
.text$x:0000154C                 assume cs:_text$x
.text$x:0000154C                 ;org 154Ch
.text$x:0000154C ; COMDAT (pick associative to section at 14F4)
.text$x:0000154C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000154C
.text$x:0000154C ; =============== S U B R O U T I N E =======================================
.text$x:0000154C
.text$x:0000154C
.text$x:0000154C __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:0000154C                                         ; DATA XREF: .xdata$x:00002CA0o
.text$x:0000154C                 mov     ecx, [ebp-10h]
.text$x:0000154F                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:0000154F __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:0000154F
.text$x:00001554
.text$x:00001554 ; =============== S U B R O U T I N E =======================================
.text$x:00001554
.text$x:00001554
.text$x:00001554 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00001554                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00001554
.text$x:00001554 arg_4           = dword ptr  8
.text$x:00001554
.text$x:00001554                 mov     edx, [esp+arg_4]
.text$x:00001558                 lea     eax, [edx+0Ch]
.text$x:0000155B                 mov     ecx, [edx-8]
.text$x:0000155E                 xor     ecx, eax
.text$x:00001560                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001565                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:0000156A                 jmp     ___CxxFrameHandler3
.text$x:0000156A __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:0000156A
.text$x:0000156A ; ---------------------------------------------------------------------------
.text$x:0000156F                 align 10h
.text$x:0000156F _text$x         ends
.text$x:0000156F
.text$mn:00001570 ; ===========================================================================
.text$mn:00001570
.text$mn:00001570 ; Segment type: Pure code
.text$mn:00001570 ; Segment permissions: Read/Execute
.text$mn:00001570 _text$mn        segment para public 'CODE' use32
.text$mn:00001570                 assume cs:_text$mn
.text$mn:00001570                 ;org 1570h
.text$mn:00001570 ; COMDAT (pick any)
.text$mn:00001570                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001570
.text$mn:00001570 ; =============== S U B R O U T I N E =======================================
.text$mn:00001570
.text$mn:00001570 ; Attributes: bp-based frame
.text$mn:00001570
.text$mn:00001570 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00001570                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001570 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00001570                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00001570
.text$mn:00001570 var_10          = dword ptr -10h
.text$mn:00001570 var_C           = dword ptr -0Ch
.text$mn:00001570 var_4           = dword ptr -4
.text$mn:00001570
.text$mn:00001570                 push    ebp
.text$mn:00001571                 mov     ebp, esp
.text$mn:00001573                 push    0FFFFFFFFh
.text$mn:00001575                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000157A                 mov     eax, large fs:0
.text$mn:00001580                 push    eax
.text$mn:00001581                 push    ecx
.text$mn:00001582                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001587                 xor     eax, ebp
.text$mn:00001589                 push    eax
.text$mn:0000158A                 lea     eax, [ebp+var_C]
.text$mn:0000158D                 mov     large fs:0, eax
.text$mn:00001593                 mov     [ebp+var_10], ecx
.text$mn:00001596                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001599                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000159E                 mov     [ebp+var_4], 0
.text$mn:000015A5                 mov     eax, [ebp+var_10]
.text$mn:000015A8                 mov     dword ptr [eax+14h], 0
.text$mn:000015AF                 mov     ecx, [ebp+var_10]
.text$mn:000015B2                 mov     dword ptr [ecx+18h], 0
.text$mn:000015B9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000015C0                 mov     eax, [ebp+var_10]
.text$mn:000015C3                 mov     ecx, [ebp+var_C]
.text$mn:000015C6                 mov     large fs:0, ecx
.text$mn:000015CD                 pop     ecx
.text$mn:000015CE                 mov     esp, ebp
.text$mn:000015D0                 pop     ebp
.text$mn:000015D1                 retn
.text$mn:000015D1 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:000015D1
.text$mn:000015D1 ; ---------------------------------------------------------------------------
.text$mn:000015D2                 align 4
.text$mn:000015D2 _text$mn        ends
.text$mn:000015D2
.text$x:000015D4 ; ===========================================================================
.text$x:000015D4
.text$x:000015D4 ; Segment type: Pure code
.text$x:000015D4 ; Segment permissions: Read/Execute
.text$x:000015D4 _text$x         segment para public 'CODE' use32
.text$x:000015D4                 assume cs:_text$x
.text$x:000015D4                 ;org 15D4h
.text$x:000015D4 ; COMDAT (pick associative to section at 1570)
.text$x:000015D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000015D4
.text$x:000015D4 ; =============== S U B R O U T I N E =======================================
.text$x:000015D4
.text$x:000015D4
.text$x:000015D4 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:000015D4                                         ; DATA XREF: .xdata$x:00002C48o
.text$x:000015D4                 mov     ecx, [ebp-10h]  ; this
.text$x:000015D7                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000015D7 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:000015D7
.text$x:000015DC
.text$x:000015DC ; =============== S U B R O U T I N E =======================================
.text$x:000015DC
.text$x:000015DC
.text$x:000015DC __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:000015DC                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:000015DC
.text$x:000015DC arg_4           = dword ptr  8
.text$x:000015DC
.text$x:000015DC                 mov     edx, [esp+arg_4]
.text$x:000015E0                 lea     eax, [edx+0Ch]
.text$x:000015E3                 mov     ecx, [edx-8]
.text$x:000015E6                 xor     ecx, eax
.text$x:000015E8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000015ED                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000015F2                 jmp     ___CxxFrameHandler3
.text$x:000015F2 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000015F2
.text$x:000015F2 ; ---------------------------------------------------------------------------
.text$x:000015F7                 align 4
.text$x:000015F7 _text$x         ends
.text$x:000015F7
.text$mn:000015F8 ; ===========================================================================
.text$mn:000015F8
.text$mn:000015F8 ; Segment type: Pure code
.text$mn:000015F8 ; Segment permissions: Read/Execute
.text$mn:000015F8 _text$mn        segment para public 'CODE' use32
.text$mn:000015F8                 assume cs:_text$mn
.text$mn:000015F8                 ;org 15F8h
.text$mn:000015F8 ; COMDAT (pick any)
.text$mn:000015F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000015F8
.text$mn:000015F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000015F8
.text$mn:000015F8 ; Attributes: bp-based frame
.text$mn:000015F8
.text$mn:000015F8 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:000015F8                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:000015F8 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:000015F8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:000015F8
.text$mn:000015F8 var_4           = dword ptr -4
.text$mn:000015F8
.text$mn:000015F8                 push    ebp
.text$mn:000015F9                 mov     ebp, esp
.text$mn:000015FB                 push    ecx
.text$mn:000015FC                 mov     [ebp+var_4], ecx
.text$mn:000015FF                 mov     ecx, [ebp+var_4]
.text$mn:00001602                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00001607                 mov     eax, [ebp+var_4]
.text$mn:0000160A                 mov     esp, ebp
.text$mn:0000160C                 pop     ebp
.text$mn:0000160D                 retn
.text$mn:0000160D ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:0000160D
.text$mn:0000160D ; ---------------------------------------------------------------------------
.text$mn:0000160E                 align 10h
.text$mn:0000160E _text$mn        ends
.text$mn:0000160E
.text$mn:00001610 ; ===========================================================================
.text$mn:00001610
.text$mn:00001610 ; Segment type: Pure code
.text$mn:00001610 ; Segment permissions: Read/Execute
.text$mn:00001610 _text$mn        segment para public 'CODE' use32
.text$mn:00001610                 assume cs:_text$mn
.text$mn:00001610                 ;org 1610h
.text$mn:00001610 ; COMDAT (pick any)
.text$mn:00001610                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001610
.text$mn:00001610 ; =============== S U B R O U T I N E =======================================
.text$mn:00001610
.text$mn:00001610 ; Attributes: bp-based frame
.text$mn:00001610
.text$mn:00001610 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00001610                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00001610 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00001610                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00001610
.text$mn:00001610 var_4           = dword ptr -4
.text$mn:00001610
.text$mn:00001610                 push    ebp
.text$mn:00001611                 mov     ebp, esp
.text$mn:00001613                 push    ecx
.text$mn:00001614                 mov     [ebp+var_4], ecx
.text$mn:00001617                 mov     eax, [ebp+var_4]
.text$mn:0000161A                 mov     esp, ebp
.text$mn:0000161C                 pop     ebp
.text$mn:0000161D                 retn
.text$mn:0000161D ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:0000161D
.text$mn:0000161D ; ---------------------------------------------------------------------------
.text$mn:0000161E                 align 10h
.text$mn:0000161E _text$mn        ends
.text$mn:0000161E
.text$mn:00001620 ; ===========================================================================
.text$mn:00001620
.text$mn:00001620 ; Segment type: Pure code
.text$mn:00001620 ; Segment permissions: Read/Execute
.text$mn:00001620 _text$mn        segment para public 'CODE' use32
.text$mn:00001620                 assume cs:_text$mn
.text$mn:00001620                 ;org 1620h
.text$mn:00001620 ; COMDAT (pick any)
.text$mn:00001620                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001620
.text$mn:00001620 ; =============== S U B R O U T I N E =======================================
.text$mn:00001620
.text$mn:00001620 ; Attributes: bp-based frame
.text$mn:00001620
.text$mn:00001620 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00001620                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00001620 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00001620                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:00001620                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:00001620
.text$mn:00001620 var_4           = dword ptr -4
.text$mn:00001620
.text$mn:00001620                 push    ebp
.text$mn:00001621                 mov     ebp, esp
.text$mn:00001623                 push    ecx
.text$mn:00001624                 mov     [ebp+var_4], ecx
.text$mn:00001627                 mov     eax, [ebp+var_4]
.text$mn:0000162A                 mov     esp, ebp
.text$mn:0000162C                 pop     ebp
.text$mn:0000162D                 retn
.text$mn:0000162D ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:0000162D
.text$mn:0000162D ; ---------------------------------------------------------------------------
.text$mn:0000162E                 align 10h
.text$mn:0000162E _text$mn        ends
.text$mn:0000162E
.text$mn:00001630 ; ===========================================================================
.text$mn:00001630
.text$mn:00001630 ; Segment type: Pure code
.text$mn:00001630 ; Segment permissions: Read/Execute
.text$mn:00001630 _text$mn        segment para public 'CODE' use32
.text$mn:00001630                 assume cs:_text$mn
.text$mn:00001630                 ;org 1630h
.text$mn:00001630 ; COMDAT (pick any)
.text$mn:00001630                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001630
.text$mn:00001630 ; =============== S U B R O U T I N E =======================================
.text$mn:00001630
.text$mn:00001630 ; Attributes: bp-based frame
.text$mn:00001630
.text$mn:00001630 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00001630                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00001630 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00001630                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00001630                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00001630
.text$mn:00001630 var_14          = dword ptr -14h
.text$mn:00001630 var_D           = byte ptr -0Dh
.text$mn:00001630 var_C           = dword ptr -0Ch
.text$mn:00001630 var_4           = dword ptr -4
.text$mn:00001630 Str             = dword ptr  8
.text$mn:00001630
.text$mn:00001630                 push    ebp
.text$mn:00001631                 mov     ebp, esp
.text$mn:00001633                 push    0FFFFFFFFh
.text$mn:00001635                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:0000163A                 mov     eax, large fs:0
.text$mn:00001640                 push    eax
.text$mn:00001641                 sub     esp, 8
.text$mn:00001644                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001649                 xor     eax, ebp
.text$mn:0000164B                 push    eax
.text$mn:0000164C                 lea     eax, [ebp+var_C]
.text$mn:0000164F                 mov     large fs:0, eax
.text$mn:00001655                 mov     [ebp+var_14], ecx
.text$mn:00001658                 lea     ecx, [ebp+var_D]
.text$mn:0000165B                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00001660                 push    eax
.text$mn:00001661                 mov     ecx, [ebp+var_14]
.text$mn:00001664                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00001669                 mov     [ebp+var_4], 0
.text$mn:00001670                 push    0               ; Size
.text$mn:00001672                 push    0               ; char
.text$mn:00001674                 mov     ecx, [ebp+var_14]
.text$mn:00001677                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000167C                 mov     eax, [ebp+Str]
.text$mn:0000167F                 push    eax             ; Str
.text$mn:00001680                 mov     ecx, [ebp+var_14]
.text$mn:00001683                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00001688                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000168F                 mov     eax, [ebp+var_14]
.text$mn:00001692                 mov     ecx, [ebp+var_C]
.text$mn:00001695                 mov     large fs:0, ecx
.text$mn:0000169C                 pop     ecx
.text$mn:0000169D                 mov     esp, ebp
.text$mn:0000169F                 pop     ebp
.text$mn:000016A0                 retn    4
.text$mn:000016A0 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:000016A0
.text$mn:000016A0 ; ---------------------------------------------------------------------------
.text$mn:000016A3                 align 4
.text$mn:000016A3 _text$mn        ends
.text$mn:000016A3
.text$x:000016A4 ; ===========================================================================
.text$x:000016A4
.text$x:000016A4 ; Segment type: Pure code
.text$x:000016A4 ; Segment permissions: Read/Execute
.text$x:000016A4 _text$x         segment para public 'CODE' use32
.text$x:000016A4                 assume cs:_text$x
.text$x:000016A4                 ;org 16A4h
.text$x:000016A4 ; COMDAT (pick associative to section at 1630)
.text$x:000016A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000016A4
.text$x:000016A4 ; =============== S U B R O U T I N E =======================================
.text$x:000016A4
.text$x:000016A4
.text$x:000016A4 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:000016A4                                         ; DATA XREF: .xdata$x:00002CF8o
.text$x:000016A4                 mov     ecx, [ebp-14h]
.text$x:000016A7                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:000016A7 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:000016A7
.text$x:000016AC
.text$x:000016AC ; =============== S U B R O U T I N E =======================================
.text$x:000016AC
.text$x:000016AC
.text$x:000016AC __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:000016AC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:000016AC
.text$x:000016AC arg_4           = dword ptr  8
.text$x:000016AC
.text$x:000016AC                 mov     edx, [esp+arg_4]
.text$x:000016B0                 lea     eax, [edx+0Ch]
.text$x:000016B3                 mov     ecx, [edx-0Ch]
.text$x:000016B6                 xor     ecx, eax
.text$x:000016B8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000016BD                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:000016C2                 jmp     ___CxxFrameHandler3
.text$x:000016C2 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:000016C2
.text$x:000016C2 ; ---------------------------------------------------------------------------
.text$x:000016C7                 align 4
.text$x:000016C7 _text$x         ends
.text$x:000016C7
.text$mn:000016C8 ; ===========================================================================
.text$mn:000016C8
.text$mn:000016C8 ; Segment type: Pure code
.text$mn:000016C8 ; Segment permissions: Read/Execute
.text$mn:000016C8 _text$mn        segment para public 'CODE' use32
.text$mn:000016C8                 assume cs:_text$mn
.text$mn:000016C8                 ;org 16C8h
.text$mn:000016C8 ; COMDAT (pick any)
.text$mn:000016C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016C8
.text$mn:000016C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000016C8
.text$mn:000016C8 ; Attributes: bp-based frame
.text$mn:000016C8
.text$mn:000016C8 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:000016C8                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:000016C8 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:000016C8                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:000016C8
.text$mn:000016C8 var_4           = dword ptr -4
.text$mn:000016C8
.text$mn:000016C8                 push    ebp
.text$mn:000016C9                 mov     ebp, esp
.text$mn:000016CB                 push    ecx
.text$mn:000016CC                 mov     [ebp+var_4], ecx
.text$mn:000016CF                 mov     eax, [ebp+var_4]
.text$mn:000016D2                 mov     dword ptr [eax], 0
.text$mn:000016D8                 mov     eax, [ebp+var_4]
.text$mn:000016DB                 mov     esp, ebp
.text$mn:000016DD                 pop     ebp
.text$mn:000016DE                 retn
.text$mn:000016DE ??0_Container_base12@std@@QAE@XZ endp
.text$mn:000016DE
.text$mn:000016DE ; ---------------------------------------------------------------------------
.text$mn:000016DF                 align 10h
.text$mn:000016DF _text$mn        ends
.text$mn:000016DF
.text$mn:000016E0 ; ===========================================================================
.text$mn:000016E0
.text$mn:000016E0 ; Segment type: Pure code
.text$mn:000016E0 ; Segment permissions: Read/Execute
.text$mn:000016E0 _text$mn        segment para public 'CODE' use32
.text$mn:000016E0                 assume cs:_text$mn
.text$mn:000016E0                 ;org 16E0h
.text$mn:000016E0 ; COMDAT (pick any)
.text$mn:000016E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016E0
.text$mn:000016E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000016E0
.text$mn:000016E0 ; Attributes: bp-based frame
.text$mn:000016E0
.text$mn:000016E0 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:000016E0                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:000016E0 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:000016E0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:000016E0
.text$mn:000016E0 var_4           = dword ptr -4
.text$mn:000016E0
.text$mn:000016E0                 push    ebp
.text$mn:000016E1                 mov     ebp, esp
.text$mn:000016E3                 push    ecx
.text$mn:000016E4                 mov     [ebp+var_4], ecx
.text$mn:000016E7                 mov     eax, [ebp+var_4]
.text$mn:000016EA                 mov     dword ptr [eax], 0
.text$mn:000016F0                 mov     ecx, [ebp+var_4]
.text$mn:000016F3                 mov     dword ptr [ecx+4], 0
.text$mn:000016FA                 mov     eax, [ebp+var_4]
.text$mn:000016FD                 mov     esp, ebp
.text$mn:000016FF                 pop     ebp
.text$mn:00001700                 retn
.text$mn:00001700 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00001700
.text$mn:00001700 ; ---------------------------------------------------------------------------
.text$mn:00001701                 align 4
.text$mn:00001701 _text$mn        ends
.text$mn:00001701
.text$mn:00001704 ; ===========================================================================
.text$mn:00001704
.text$mn:00001704 ; Segment type: Pure code
.text$mn:00001704 ; Segment permissions: Read/Execute
.text$mn:00001704 _text$mn        segment para public 'CODE' use32
.text$mn:00001704                 assume cs:_text$mn
.text$mn:00001704                 ;org 1704h
.text$mn:00001704 ; COMDAT (pick any)
.text$mn:00001704                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001704
.text$mn:00001704 ; =============== S U B R O U T I N E =======================================
.text$mn:00001704
.text$mn:00001704 ; Attributes: bp-based frame
.text$mn:00001704
.text$mn:00001704 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00001704                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00001704 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00001704                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00001704                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00001704
.text$mn:00001704 var_10          = dword ptr -10h
.text$mn:00001704 var_C           = dword ptr -0Ch
.text$mn:00001704 var_4           = dword ptr -4
.text$mn:00001704
.text$mn:00001704                 push    ebp
.text$mn:00001705                 mov     ebp, esp
.text$mn:00001707                 push    0FFFFFFFFh
.text$mn:00001709                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:0000170E                 mov     eax, large fs:0
.text$mn:00001714                 push    eax
.text$mn:00001715                 push    ecx
.text$mn:00001716                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000171B                 xor     eax, ebp
.text$mn:0000171D                 push    eax
.text$mn:0000171E                 lea     eax, [ebp+var_C]
.text$mn:00001721                 mov     large fs:0, eax
.text$mn:00001727                 mov     [ebp+var_10], ecx
.text$mn:0000172A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000172D                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00001732                 mov     [ebp+var_4], 0
.text$mn:00001739                 mov     eax, [ebp+var_10]
.text$mn:0000173C                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00001742                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001749                 mov     eax, [ebp+var_10]
.text$mn:0000174C                 mov     ecx, [ebp+var_C]
.text$mn:0000174F                 mov     large fs:0, ecx
.text$mn:00001756                 pop     ecx
.text$mn:00001757                 mov     esp, ebp
.text$mn:00001759                 pop     ebp
.text$mn:0000175A                 retn
.text$mn:0000175A ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:0000175A
.text$mn:0000175A ; ---------------------------------------------------------------------------
.text$mn:0000175B                 align 4
.text$mn:0000175B _text$mn        ends
.text$mn:0000175B
.text$x:0000175C ; ===========================================================================
.text$x:0000175C
.text$x:0000175C ; Segment type: Pure code
.text$x:0000175C ; Segment permissions: Read/Execute
.text$x:0000175C _text$x         segment para public 'CODE' use32
.text$x:0000175C                 assume cs:_text$x
.text$x:0000175C                 ;org 175Ch
.text$x:0000175C ; COMDAT (pick associative to section at 1704)
.text$x:0000175C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000175C
.text$x:0000175C ; =============== S U B R O U T I N E =======================================
.text$x:0000175C
.text$x:0000175C
.text$x:0000175C __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:0000175C                                         ; DATA XREF: .xdata$x:00002DDCo
.text$x:0000175C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000175F                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:0000175F __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:0000175F
.text$x:00001764
.text$x:00001764 ; =============== S U B R O U T I N E =======================================
.text$x:00001764
.text$x:00001764
.text$x:00001764 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00001764                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00001764
.text$x:00001764 arg_4           = dword ptr  8
.text$x:00001764
.text$x:00001764                 mov     edx, [esp+arg_4]
.text$x:00001768                 lea     eax, [edx+0Ch]
.text$x:0000176B                 mov     ecx, [edx-8]
.text$x:0000176E                 xor     ecx, eax
.text$x:00001770                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001775                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:0000177A                 jmp     ___CxxFrameHandler3
.text$x:0000177A __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:0000177A
.text$x:0000177A ; ---------------------------------------------------------------------------
.text$x:0000177F                 align 10h
.text$x:0000177F _text$x         ends
.text$x:0000177F
.text$mn:00001780 ; ===========================================================================
.text$mn:00001780
.text$mn:00001780 ; Segment type: Pure code
.text$mn:00001780 ; Segment permissions: Read/Execute
.text$mn:00001780 _text$mn        segment para public 'CODE' use32
.text$mn:00001780                 assume cs:_text$mn
.text$mn:00001780                 ;org 1780h
.text$mn:00001780 ; COMDAT (pick any)
.text$mn:00001780                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001780
.text$mn:00001780 ; =============== S U B R O U T I N E =======================================
.text$mn:00001780
.text$mn:00001780 ; Attributes: bp-based frame
.text$mn:00001780
.text$mn:00001780 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00001780                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00001780 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00001780                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00001780
.text$mn:00001780 var_10          = dword ptr -10h
.text$mn:00001780 var_C           = dword ptr -0Ch
.text$mn:00001780 var_4           = dword ptr -4
.text$mn:00001780
.text$mn:00001780                 push    ebp
.text$mn:00001781                 mov     ebp, esp
.text$mn:00001783                 push    0FFFFFFFFh
.text$mn:00001785                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:0000178A                 mov     eax, large fs:0
.text$mn:00001790                 push    eax
.text$mn:00001791                 push    ecx
.text$mn:00001792                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001797                 xor     eax, ebp
.text$mn:00001799                 push    eax
.text$mn:0000179A                 lea     eax, [ebp+var_C]
.text$mn:0000179D                 mov     large fs:0, eax
.text$mn:000017A3                 mov     [ebp+var_10], ecx
.text$mn:000017A6                 mov     ecx, [ebp+var_10] ; this
.text$mn:000017A9                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:000017AE                 mov     [ebp+var_4], 0
.text$mn:000017B5                 mov     eax, [ebp+var_10]
.text$mn:000017B8                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:000017BE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000017C5                 mov     eax, [ebp+var_10]
.text$mn:000017C8                 mov     ecx, [ebp+var_C]
.text$mn:000017CB                 mov     large fs:0, ecx
.text$mn:000017D2                 pop     ecx
.text$mn:000017D3                 mov     esp, ebp
.text$mn:000017D5                 pop     ebp
.text$mn:000017D6                 retn
.text$mn:000017D6 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:000017D6
.text$mn:000017D6 ; ---------------------------------------------------------------------------
.text$mn:000017D7                 align 4
.text$mn:000017D7 _text$mn        ends
.text$mn:000017D7
.text$x:000017D8 ; ===========================================================================
.text$x:000017D8
.text$x:000017D8 ; Segment type: Pure code
.text$x:000017D8 ; Segment permissions: Read/Execute
.text$x:000017D8 _text$x         segment para public 'CODE' use32
.text$x:000017D8                 assume cs:_text$x
.text$x:000017D8                 ;org 17D8h
.text$x:000017D8 ; COMDAT (pick associative to section at 1780)
.text$x:000017D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000017D8
.text$x:000017D8 ; =============== S U B R O U T I N E =======================================
.text$x:000017D8
.text$x:000017D8
.text$x:000017D8 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:000017D8                                         ; DATA XREF: .xdata$x:00002E60o
.text$x:000017D8                 mov     ecx, [ebp-10h]  ; this
.text$x:000017DB                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000017DB __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:000017DB
.text$x:000017E0
.text$x:000017E0 ; =============== S U B R O U T I N E =======================================
.text$x:000017E0
.text$x:000017E0
.text$x:000017E0 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:000017E0                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:000017E0
.text$x:000017E0 arg_4           = dword ptr  8
.text$x:000017E0
.text$x:000017E0                 mov     edx, [esp+arg_4]
.text$x:000017E4                 lea     eax, [edx+0Ch]
.text$x:000017E7                 mov     ecx, [edx-8]
.text$x:000017EA                 xor     ecx, eax
.text$x:000017EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000017F1                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:000017F6                 jmp     ___CxxFrameHandler3
.text$x:000017F6 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:000017F6
.text$x:000017F6 ; ---------------------------------------------------------------------------
.text$x:000017FB                 align 4
.text$x:000017FB _text$x         ends
.text$x:000017FB
.text$mn:000017FC ; ===========================================================================
.text$mn:000017FC
.text$mn:000017FC ; Segment type: Pure code
.text$mn:000017FC ; Segment permissions: Read/Execute
.text$mn:000017FC _text$mn        segment para public 'CODE' use32
.text$mn:000017FC                 assume cs:_text$mn
.text$mn:000017FC                 ;org 17FCh
.text$mn:000017FC ; COMDAT (pick any)
.text$mn:000017FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000017FC
.text$mn:000017FC ; =============== S U B R O U T I N E =======================================
.text$mn:000017FC
.text$mn:000017FC ; Attributes: bp-based frame
.text$mn:000017FC
.text$mn:000017FC ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:000017FC                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:000017FC ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:000017FC                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:000017FC
.text$mn:000017FC var_10          = dword ptr -10h
.text$mn:000017FC var_C           = dword ptr -0Ch
.text$mn:000017FC var_4           = dword ptr -4
.text$mn:000017FC
.text$mn:000017FC                 push    ebp
.text$mn:000017FD                 mov     ebp, esp
.text$mn:000017FF                 push    0FFFFFFFFh
.text$mn:00001801                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00001806                 mov     eax, large fs:0
.text$mn:0000180C                 push    eax
.text$mn:0000180D                 push    ecx
.text$mn:0000180E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001813                 xor     eax, ebp
.text$mn:00001815                 push    eax
.text$mn:00001816                 lea     eax, [ebp+var_C]
.text$mn:00001819                 mov     large fs:0, eax
.text$mn:0000181F                 mov     [ebp+var_10], ecx
.text$mn:00001822                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001825                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:0000182A                 mov     [ebp+var_4], 0
.text$mn:00001831                 mov     eax, [ebp+var_10]
.text$mn:00001834                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:0000183A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001841                 mov     eax, [ebp+var_10]
.text$mn:00001844                 mov     ecx, [ebp+var_C]
.text$mn:00001847                 mov     large fs:0, ecx
.text$mn:0000184E                 pop     ecx
.text$mn:0000184F                 mov     esp, ebp
.text$mn:00001851                 pop     ebp
.text$mn:00001852                 retn
.text$mn:00001852 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00001852
.text$mn:00001852 ; ---------------------------------------------------------------------------
.text$mn:00001853                 align 4
.text$mn:00001853 _text$mn        ends
.text$mn:00001853
.text$x:00001854 ; ===========================================================================
.text$x:00001854
.text$x:00001854 ; Segment type: Pure code
.text$x:00001854 ; Segment permissions: Read/Execute
.text$x:00001854 _text$x         segment para public 'CODE' use32
.text$x:00001854                 assume cs:_text$x
.text$x:00001854                 ;org 1854h
.text$x:00001854 ; COMDAT (pick associative to section at 17FC)
.text$x:00001854                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001854
.text$x:00001854 ; =============== S U B R O U T I N E =======================================
.text$x:00001854
.text$x:00001854
.text$x:00001854 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00001854                                         ; DATA XREF: .xdata$x:00002EE4o
.text$x:00001854                 mov     ecx, [ebp-10h]  ; this
.text$x:00001857                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001857 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00001857
.text$x:0000185C
.text$x:0000185C ; =============== S U B R O U T I N E =======================================
.text$x:0000185C
.text$x:0000185C
.text$x:0000185C __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:0000185C                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:0000185C
.text$x:0000185C arg_4           = dword ptr  8
.text$x:0000185C
.text$x:0000185C                 mov     edx, [esp+arg_4]
.text$x:00001860                 lea     eax, [edx+0Ch]
.text$x:00001863                 mov     ecx, [edx-8]
.text$x:00001866                 xor     ecx, eax
.text$x:00001868                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000186D                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00001872                 jmp     ___CxxFrameHandler3
.text$x:00001872 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00001872
.text$x:00001872 ; ---------------------------------------------------------------------------
.text$x:00001877                 align 4
.text$x:00001877 _text$x         ends
.text$x:00001877
.text$mn:00001878 ; ===========================================================================
.text$mn:00001878
.text$mn:00001878 ; Segment type: Pure code
.text$mn:00001878 ; Segment permissions: Read/Execute
.text$mn:00001878 _text$mn        segment para public 'CODE' use32
.text$mn:00001878                 assume cs:_text$mn
.text$mn:00001878                 ;org 1878h
.text$mn:00001878 ; COMDAT (pick any)
.text$mn:00001878                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001878
.text$mn:00001878 ; =============== S U B R O U T I N E =======================================
.text$mn:00001878
.text$mn:00001878 ; Attributes: bp-based frame
.text$mn:00001878
.text$mn:00001878 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00001878                 public ??0error_category@std@@QAE@XZ
.text$mn:00001878 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00001878
.text$mn:00001878 var_4           = dword ptr -4
.text$mn:00001878
.text$mn:00001878                 push    ebp
.text$mn:00001879                 mov     ebp, esp
.text$mn:0000187B                 push    ecx
.text$mn:0000187C                 mov     [ebp+var_4], ecx
.text$mn:0000187F                 mov     eax, [ebp+var_4]
.text$mn:00001882                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00001888                 mov     eax, [ebp+var_4]
.text$mn:0000188B                 mov     esp, ebp
.text$mn:0000188D                 pop     ebp
.text$mn:0000188E                 retn
.text$mn:0000188E ??0error_category@std@@QAE@XZ endp
.text$mn:0000188E
.text$mn:0000188E ; ---------------------------------------------------------------------------
.text$mn:0000188F                 align 10h
.text$mn:0000188F _text$mn        ends
.text$mn:0000188F
.text$mn:00001890 ; ===========================================================================
.text$mn:00001890
.text$mn:00001890 ; Segment type: Pure code
.text$mn:00001890 ; Segment permissions: Read/Execute
.text$mn:00001890 _text$mn        segment para public 'CODE' use32
.text$mn:00001890                 assume cs:_text$mn
.text$mn:00001890                 ;org 1890h
.text$mn:00001890 ; COMDAT (pick any)
.text$mn:00001890                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001890
.text$mn:00001890 ; =============== S U B R O U T I N E =======================================
.text$mn:00001890
.text$mn:00001890 ; Attributes: bp-based frame
.text$mn:00001890
.text$mn:00001890 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00001890                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00001890 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00001890                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00001890                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00001890
.text$mn:00001890 var_4           = dword ptr -4
.text$mn:00001890 arg_0           = dword ptr  8
.text$mn:00001890 arg_4           = dword ptr  0Ch
.text$mn:00001890
.text$mn:00001890                 push    ebp
.text$mn:00001891                 mov     ebp, esp
.text$mn:00001893                 push    ecx
.text$mn:00001894                 mov     [ebp+var_4], ecx
.text$mn:00001897                 mov     eax, [ebp+var_4]
.text$mn:0000189A                 mov     ecx, [ebp+arg_0]
.text$mn:0000189D                 mov     [eax], ecx
.text$mn:0000189F                 mov     edx, [ebp+var_4]
.text$mn:000018A2                 mov     eax, [ebp+arg_4]
.text$mn:000018A5                 mov     [edx+4], eax
.text$mn:000018A8                 mov     eax, [ebp+var_4]
.text$mn:000018AB                 mov     esp, ebp
.text$mn:000018AD                 pop     ebp
.text$mn:000018AE                 retn    8
.text$mn:000018AE ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:000018AE
.text$mn:000018AE ; ---------------------------------------------------------------------------
.text$mn:000018B1                 align 4
.text$mn:000018B1 _text$mn        ends
.text$mn:000018B1
.text$mn:000018B4 ; ===========================================================================
.text$mn:000018B4
.text$mn:000018B4 ; Segment type: Pure code
.text$mn:000018B4 ; Segment permissions: Read/Execute
.text$mn:000018B4 _text$mn        segment para public 'CODE' use32
.text$mn:000018B4                 assume cs:_text$mn
.text$mn:000018B4                 ;org 18B4h
.text$mn:000018B4 ; COMDAT (pick any)
.text$mn:000018B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000018B4
.text$mn:000018B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000018B4
.text$mn:000018B4 ; Attributes: bp-based frame
.text$mn:000018B4
.text$mn:000018B4 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:000018B4                 public ??0id@locale@std@@QAE@I@Z
.text$mn:000018B4 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:000018B4                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:000018B4
.text$mn:000018B4 var_4           = dword ptr -4
.text$mn:000018B4 arg_0           = dword ptr  8
.text$mn:000018B4
.text$mn:000018B4                 push    ebp
.text$mn:000018B5                 mov     ebp, esp
.text$mn:000018B7                 push    ecx
.text$mn:000018B8                 mov     [ebp+var_4], ecx
.text$mn:000018BB                 mov     eax, [ebp+var_4]
.text$mn:000018BE                 mov     ecx, [ebp+arg_0]
.text$mn:000018C1                 mov     [eax], ecx
.text$mn:000018C3                 mov     eax, [ebp+var_4]
.text$mn:000018C6                 mov     esp, ebp
.text$mn:000018C8                 pop     ebp
.text$mn:000018C9                 retn    4
.text$mn:000018C9 ??0id@locale@std@@QAE@I@Z endp
.text$mn:000018C9
.text$mn:000018C9 _text$mn        ends
.text$mn:000018C9
.text$mn:000018CC ; ===========================================================================
.text$mn:000018CC
.text$mn:000018CC ; Segment type: Pure code
.text$mn:000018CC ; Segment permissions: Read/Execute
.text$mn:000018CC _text$mn        segment para public 'CODE' use32
.text$mn:000018CC                 assume cs:_text$mn
.text$mn:000018CC                 ;org 18CCh
.text$mn:000018CC ; COMDAT (pick any)
.text$mn:000018CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000018CC
.text$mn:000018CC ; =============== S U B R O U T I N E =======================================
.text$mn:000018CC
.text$mn:000018CC ; Attributes: bp-based frame
.text$mn:000018CC
.text$mn:000018CC ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:000018CC                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:000018CC ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000018CC                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:000018CC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:000018CC
.text$mn:000018CC var_10          = dword ptr -10h
.text$mn:000018CC var_C           = dword ptr -0Ch
.text$mn:000018CC var_4           = dword ptr -4
.text$mn:000018CC
.text$mn:000018CC                 push    ebp
.text$mn:000018CD                 mov     ebp, esp
.text$mn:000018CF                 push    0FFFFFFFFh
.text$mn:000018D1                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:000018D6                 mov     eax, large fs:0
.text$mn:000018DC                 push    eax
.text$mn:000018DD                 push    ecx
.text$mn:000018DE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000018E3                 xor     eax, ebp
.text$mn:000018E5                 push    eax
.text$mn:000018E6                 lea     eax, [ebp+var_C]
.text$mn:000018E9                 mov     large fs:0, eax
.text$mn:000018EF                 mov     [ebp+var_10], ecx
.text$mn:000018F2                 mov     [ebp+var_4], 0
.text$mn:000018F9                 mov     ecx, [ebp+var_10]
.text$mn:000018FC                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00001901                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001908                 mov     ecx, [ebp+var_10]
.text$mn:0000190B                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00001910                 mov     ecx, [ebp+var_C]
.text$mn:00001913                 mov     large fs:0, ecx
.text$mn:0000191A                 pop     ecx
.text$mn:0000191B                 mov     esp, ebp
.text$mn:0000191D                 pop     ebp
.text$mn:0000191E                 retn
.text$mn:0000191E ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000191E
.text$mn:0000191E ; ---------------------------------------------------------------------------
.text$mn:0000191F                 align 10h
.text$mn:0000191F _text$mn        ends
.text$mn:0000191F
.text$x:00001920 ; ===========================================================================
.text$x:00001920
.text$x:00001920 ; Segment type: Pure code
.text$x:00001920 ; Segment permissions: Read/Execute
.text$x:00001920 _text$x         segment para public 'CODE' use32
.text$x:00001920                 assume cs:_text$x
.text$x:00001920                 ;org 1920h
.text$x:00001920 ; COMDAT (pick associative to section at 18CC)
.text$x:00001920                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001920
.text$x:00001920 ; =============== S U B R O U T I N E =======================================
.text$x:00001920
.text$x:00001920
.text$x:00001920 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00001920                                         ; DATA XREF: .xdata$x:00002CCCo
.text$x:00001920                 mov     ecx, [ebp-10h]
.text$x:00001923                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00001923 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00001923
.text$x:00001928
.text$x:00001928 ; =============== S U B R O U T I N E =======================================
.text$x:00001928
.text$x:00001928
.text$x:00001928 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00001928                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00001928
.text$x:00001928 arg_4           = dword ptr  8
.text$x:00001928
.text$x:00001928                 mov     edx, [esp+arg_4]
.text$x:0000192C                 lea     eax, [edx+0Ch]
.text$x:0000192F                 mov     ecx, [edx-8]
.text$x:00001932                 xor     ecx, eax
.text$x:00001934                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001939                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:0000193E                 jmp     ___CxxFrameHandler3
.text$x:0000193E __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:0000193E
.text$x:0000193E ; ---------------------------------------------------------------------------
.text$x:00001943                 align 4
.text$x:00001943 _text$x         ends
.text$x:00001943
.text$mn:00001944 ; ===========================================================================
.text$mn:00001944
.text$mn:00001944 ; Segment type: Pure code
.text$mn:00001944 ; Segment permissions: Read/Execute
.text$mn:00001944 _text$mn        segment para public 'CODE' use32
.text$mn:00001944                 assume cs:_text$mn
.text$mn:00001944                 ;org 1944h
.text$mn:00001944 ; COMDAT (pick any)
.text$mn:00001944                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001944
.text$mn:00001944 ; =============== S U B R O U T I N E =======================================
.text$mn:00001944
.text$mn:00001944 ; Attributes: bp-based frame
.text$mn:00001944
.text$mn:00001944 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00001944                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001944 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00001944                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00001944                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00001944
.text$mn:00001944 var_10          = dword ptr -10h
.text$mn:00001944 var_C           = dword ptr -0Ch
.text$mn:00001944 var_4           = dword ptr -4
.text$mn:00001944
.text$mn:00001944                 push    ebp
.text$mn:00001945                 mov     ebp, esp
.text$mn:00001947                 push    0FFFFFFFFh
.text$mn:00001949                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000194E                 mov     eax, large fs:0
.text$mn:00001954                 push    eax
.text$mn:00001955                 push    ecx
.text$mn:00001956                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000195B                 xor     eax, ebp
.text$mn:0000195D                 push    eax
.text$mn:0000195E                 lea     eax, [ebp+var_C]
.text$mn:00001961                 mov     large fs:0, eax
.text$mn:00001967                 mov     [ebp+var_10], ecx
.text$mn:0000196A                 mov     [ebp+var_4], 0
.text$mn:00001971                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001978                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000197B                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00001980                 mov     ecx, [ebp+var_C]
.text$mn:00001983                 mov     large fs:0, ecx
.text$mn:0000198A                 pop     ecx
.text$mn:0000198B                 mov     esp, ebp
.text$mn:0000198D                 pop     ebp
.text$mn:0000198E                 retn
.text$mn:0000198E ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:0000198E
.text$mn:0000198E ; ---------------------------------------------------------------------------
.text$mn:0000198F                 align 10h
.text$mn:0000198F _text$mn        ends
.text$mn:0000198F
.text$x:00001990 ; ===========================================================================
.text$x:00001990
.text$x:00001990 ; Segment type: Pure code
.text$x:00001990 ; Segment permissions: Read/Execute
.text$x:00001990 _text$x         segment para public 'CODE' use32
.text$x:00001990                 assume cs:_text$x
.text$x:00001990                 ;org 1990h
.text$x:00001990 ; COMDAT (pick associative to section at 1944)
.text$x:00001990                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001990
.text$x:00001990 ; =============== S U B R O U T I N E =======================================
.text$x:00001990
.text$x:00001990
.text$x:00001990 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00001990                                         ; DATA XREF: .xdata$x:00002C74o
.text$x:00001990                 mov     ecx, [ebp-10h]  ; this
.text$x:00001993                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00001993 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00001993
.text$x:00001998
.text$x:00001998 ; =============== S U B R O U T I N E =======================================
.text$x:00001998
.text$x:00001998
.text$x:00001998 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00001998                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00001998
.text$x:00001998 arg_4           = dword ptr  8
.text$x:00001998
.text$x:00001998                 mov     edx, [esp+arg_4]
.text$x:0000199C                 lea     eax, [edx+0Ch]
.text$x:0000199F                 mov     ecx, [edx-8]
.text$x:000019A2                 xor     ecx, eax
.text$x:000019A4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000019A9                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000019AE                 jmp     ___CxxFrameHandler3
.text$x:000019AE __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000019AE
.text$x:000019AE ; ---------------------------------------------------------------------------
.text$x:000019B3                 align 4
.text$x:000019B3 _text$x         ends
.text$x:000019B3
.text$mn:000019B4 ; ===========================================================================
.text$mn:000019B4
.text$mn:000019B4 ; Segment type: Pure code
.text$mn:000019B4 ; Segment permissions: Read/Execute
.text$mn:000019B4 _text$mn        segment para public 'CODE' use32
.text$mn:000019B4                 assume cs:_text$mn
.text$mn:000019B4                 ;org 19B4h
.text$mn:000019B4 ; COMDAT (pick any)
.text$mn:000019B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019B4
.text$mn:000019B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000019B4
.text$mn:000019B4 ; Attributes: bp-based frame
.text$mn:000019B4
.text$mn:000019B4 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:000019B4                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:000019B4 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:000019B4                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:000019B4                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:000019B4
.text$mn:000019B4 var_10          = dword ptr -10h
.text$mn:000019B4 var_C           = dword ptr -0Ch
.text$mn:000019B4 var_4           = dword ptr -4
.text$mn:000019B4
.text$mn:000019B4                 push    ebp
.text$mn:000019B5                 mov     ebp, esp
.text$mn:000019B7                 push    0FFFFFFFFh
.text$mn:000019B9                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:000019BE                 mov     eax, large fs:0
.text$mn:000019C4                 push    eax
.text$mn:000019C5                 push    ecx
.text$mn:000019C6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000019CB                 xor     eax, ebp
.text$mn:000019CD                 push    eax
.text$mn:000019CE                 lea     eax, [ebp+var_C]
.text$mn:000019D1                 mov     large fs:0, eax
.text$mn:000019D7                 mov     [ebp+var_10], ecx
.text$mn:000019DA                 mov     [ebp+var_4], 0
.text$mn:000019E1                 push    0               ; Size
.text$mn:000019E3                 push    1               ; char
.text$mn:000019E5                 mov     ecx, [ebp+var_10]
.text$mn:000019E8                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000019ED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000019F4                 mov     ecx, [ebp+var_10]
.text$mn:000019F7                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:000019FC                 mov     ecx, [ebp+var_C]
.text$mn:000019FF                 mov     large fs:0, ecx
.text$mn:00001A06                 pop     ecx
.text$mn:00001A07                 mov     esp, ebp
.text$mn:00001A09                 pop     ebp
.text$mn:00001A0A                 retn
.text$mn:00001A0A ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00001A0A
.text$mn:00001A0A ; ---------------------------------------------------------------------------
.text$mn:00001A0B                 align 4
.text$mn:00001A0B _text$mn        ends
.text$mn:00001A0B
.text$x:00001A0C ; ===========================================================================
.text$x:00001A0C
.text$x:00001A0C ; Segment type: Pure code
.text$x:00001A0C ; Segment permissions: Read/Execute
.text$x:00001A0C _text$x         segment para public 'CODE' use32
.text$x:00001A0C                 assume cs:_text$x
.text$x:00001A0C                 ;org 1A0Ch
.text$x:00001A0C ; COMDAT (pick associative to section at 19B4)
.text$x:00001A0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001A0C
.text$x:00001A0C ; =============== S U B R O U T I N E =======================================
.text$x:00001A0C
.text$x:00001A0C
.text$x:00001A0C __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00001A0C                                         ; DATA XREF: .xdata$x:00002D24o
.text$x:00001A0C                 mov     ecx, [ebp-10h]
.text$x:00001A0F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00001A0F __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00001A0F
.text$x:00001A14
.text$x:00001A14 ; =============== S U B R O U T I N E =======================================
.text$x:00001A14
.text$x:00001A14
.text$x:00001A14 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00001A14                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00001A14
.text$x:00001A14 arg_4           = dword ptr  8
.text$x:00001A14
.text$x:00001A14                 mov     edx, [esp+arg_4]
.text$x:00001A18                 lea     eax, [edx+0Ch]
.text$x:00001A1B                 mov     ecx, [edx-8]
.text$x:00001A1E                 xor     ecx, eax
.text$x:00001A20                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001A25                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00001A2A                 jmp     ___CxxFrameHandler3
.text$x:00001A2A __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00001A2A
.text$x:00001A2A ; ---------------------------------------------------------------------------
.text$x:00001A2F                 align 10h
.text$x:00001A2F _text$x         ends
.text$x:00001A2F
.text$mn:00001A30 ; ===========================================================================
.text$mn:00001A30
.text$mn:00001A30 ; Segment type: Pure code
.text$mn:00001A30 ; Segment permissions: Read/Execute
.text$mn:00001A30 _text$mn        segment para public 'CODE' use32
.text$mn:00001A30                 assume cs:_text$mn
.text$mn:00001A30                 ;org 1A30h
.text$mn:00001A30 ; COMDAT (pick any)
.text$mn:00001A30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A30
.text$mn:00001A30 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A30
.text$mn:00001A30 ; Attributes: bp-based frame
.text$mn:00001A30
.text$mn:00001A30 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00001A30                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00001A30 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00001A30                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00001A30                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:00001A30
.text$mn:00001A30 var_4           = dword ptr -4
.text$mn:00001A30
.text$mn:00001A30                 push    ebp
.text$mn:00001A31                 mov     ebp, esp
.text$mn:00001A33                 push    ecx
.text$mn:00001A34                 mov     [ebp+var_4], ecx
.text$mn:00001A37                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001A3A                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00001A3F                 mov     esp, ebp
.text$mn:00001A41                 pop     ebp
.text$mn:00001A42                 retn
.text$mn:00001A42 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00001A42
.text$mn:00001A42 ; ---------------------------------------------------------------------------
.text$mn:00001A43                 align 4
.text$mn:00001A43 _text$mn        ends
.text$mn:00001A43
.text$mn:00001A44 ; ===========================================================================
.text$mn:00001A44
.text$mn:00001A44 ; Segment type: Pure code
.text$mn:00001A44 ; Segment permissions: Read/Execute
.text$mn:00001A44 _text$mn        segment para public 'CODE' use32
.text$mn:00001A44                 assume cs:_text$mn
.text$mn:00001A44                 ;org 1A44h
.text$mn:00001A44 ; COMDAT (pick any)
.text$mn:00001A44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A44
.text$mn:00001A44 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A44
.text$mn:00001A44 ; Attributes: bp-based frame
.text$mn:00001A44
.text$mn:00001A44 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00001A44                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00001A44 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00001A44                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00001A44                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00001A44
.text$mn:00001A44 var_10          = dword ptr -10h
.text$mn:00001A44 var_C           = dword ptr -0Ch
.text$mn:00001A44 var_4           = dword ptr -4
.text$mn:00001A44
.text$mn:00001A44                 push    ebp
.text$mn:00001A45                 mov     ebp, esp
.text$mn:00001A47                 push    0FFFFFFFFh
.text$mn:00001A49                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00001A4E                 mov     eax, large fs:0
.text$mn:00001A54                 push    eax
.text$mn:00001A55                 push    ecx
.text$mn:00001A56                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001A5B                 xor     eax, ebp
.text$mn:00001A5D                 push    eax
.text$mn:00001A5E                 lea     eax, [ebp+var_C]
.text$mn:00001A61                 mov     large fs:0, eax
.text$mn:00001A67                 mov     [ebp+var_10], ecx
.text$mn:00001A6A                 mov     [ebp+var_4], 0
.text$mn:00001A71                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001A78                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001A7B                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00001A80                 mov     ecx, [ebp+var_C]
.text$mn:00001A83                 mov     large fs:0, ecx
.text$mn:00001A8A                 pop     ecx
.text$mn:00001A8B                 mov     esp, ebp
.text$mn:00001A8D                 pop     ebp
.text$mn:00001A8E                 retn
.text$mn:00001A8E ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00001A8E
.text$mn:00001A8E ; ---------------------------------------------------------------------------
.text$mn:00001A8F                 align 10h
.text$mn:00001A8F _text$mn        ends
.text$mn:00001A8F
.text$x:00001A90 ; ===========================================================================
.text$x:00001A90
.text$x:00001A90 ; Segment type: Pure code
.text$x:00001A90 ; Segment permissions: Read/Execute
.text$x:00001A90 _text$x         segment para public 'CODE' use32
.text$x:00001A90                 assume cs:_text$x
.text$x:00001A90                 ;org 1A90h
.text$x:00001A90 ; COMDAT (pick associative to section at 1A44)
.text$x:00001A90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001A90
.text$x:00001A90 ; =============== S U B R O U T I N E =======================================
.text$x:00001A90
.text$x:00001A90
.text$x:00001A90 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00001A90                                         ; DATA XREF: .xdata$x:00002E34o
.text$x:00001A90                 mov     ecx, [ebp-10h]  ; this
.text$x:00001A93                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00001A93 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00001A93
.text$x:00001A98
.text$x:00001A98 ; =============== S U B R O U T I N E =======================================
.text$x:00001A98
.text$x:00001A98
.text$x:00001A98 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00001A98                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00001A98
.text$x:00001A98 arg_4           = dword ptr  8
.text$x:00001A98
.text$x:00001A98                 mov     edx, [esp+arg_4]
.text$x:00001A9C                 lea     eax, [edx+0Ch]
.text$x:00001A9F                 mov     ecx, [edx-8]
.text$x:00001AA2                 xor     ecx, eax
.text$x:00001AA4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001AA9                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00001AAE                 jmp     ___CxxFrameHandler3
.text$x:00001AAE __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00001AAE
.text$x:00001AAE ; ---------------------------------------------------------------------------
.text$x:00001AB3                 align 4
.text$x:00001AB3 _text$x         ends
.text$x:00001AB3
.text$mn:00001AB4 ; ===========================================================================
.text$mn:00001AB4
.text$mn:00001AB4 ; Segment type: Pure code
.text$mn:00001AB4 ; Segment permissions: Read/Execute
.text$mn:00001AB4 _text$mn        segment para public 'CODE' use32
.text$mn:00001AB4                 assume cs:_text$mn
.text$mn:00001AB4                 ;org 1AB4h
.text$mn:00001AB4 ; COMDAT (pick any)
.text$mn:00001AB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001AB4
.text$mn:00001AB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AB4
.text$mn:00001AB4 ; Attributes: bp-based frame
.text$mn:00001AB4
.text$mn:00001AB4 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00001AB4                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00001AB4 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00001AB4                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00001AB4                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00001AB4
.text$mn:00001AB4 var_10          = dword ptr -10h
.text$mn:00001AB4 var_C           = dword ptr -0Ch
.text$mn:00001AB4 var_4           = dword ptr -4
.text$mn:00001AB4
.text$mn:00001AB4                 push    ebp
.text$mn:00001AB5                 mov     ebp, esp
.text$mn:00001AB7                 push    0FFFFFFFFh
.text$mn:00001AB9                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00001ABE                 mov     eax, large fs:0
.text$mn:00001AC4                 push    eax
.text$mn:00001AC5                 push    ecx
.text$mn:00001AC6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001ACB                 xor     eax, ebp
.text$mn:00001ACD                 push    eax
.text$mn:00001ACE                 lea     eax, [ebp+var_C]
.text$mn:00001AD1                 mov     large fs:0, eax
.text$mn:00001AD7                 mov     [ebp+var_10], ecx
.text$mn:00001ADA                 mov     [ebp+var_4], 0
.text$mn:00001AE1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001AE8                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001AEB                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001AF0                 mov     ecx, [ebp+var_C]
.text$mn:00001AF3                 mov     large fs:0, ecx
.text$mn:00001AFA                 pop     ecx
.text$mn:00001AFB                 mov     esp, ebp
.text$mn:00001AFD                 pop     ebp
.text$mn:00001AFE                 retn
.text$mn:00001AFE ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00001AFE
.text$mn:00001AFE ; ---------------------------------------------------------------------------
.text$mn:00001AFF                 align 10h
.text$mn:00001AFF _text$mn        ends
.text$mn:00001AFF
.text$x:00001B00 ; ===========================================================================
.text$x:00001B00
.text$x:00001B00 ; Segment type: Pure code
.text$x:00001B00 ; Segment permissions: Read/Execute
.text$x:00001B00 _text$x         segment para public 'CODE' use32
.text$x:00001B00                 assume cs:_text$x
.text$x:00001B00                 ;org 1B00h
.text$x:00001B00 ; COMDAT (pick associative to section at 1AB4)
.text$x:00001B00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001B00
.text$x:00001B00 ; =============== S U B R O U T I N E =======================================
.text$x:00001B00
.text$x:00001B00
.text$x:00001B00 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00001B00                                         ; DATA XREF: .xdata$x:00002EB8o
.text$x:00001B00                 mov     ecx, [ebp-10h]  ; this
.text$x:00001B03                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001B03 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00001B03
.text$x:00001B08
.text$x:00001B08 ; =============== S U B R O U T I N E =======================================
.text$x:00001B08
.text$x:00001B08
.text$x:00001B08 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00001B08                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00001B08
.text$x:00001B08 arg_4           = dword ptr  8
.text$x:00001B08
.text$x:00001B08                 mov     edx, [esp+arg_4]
.text$x:00001B0C                 lea     eax, [edx+0Ch]
.text$x:00001B0F                 mov     ecx, [edx-8]
.text$x:00001B12                 xor     ecx, eax
.text$x:00001B14                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001B19                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00001B1E                 jmp     ___CxxFrameHandler3
.text$x:00001B1E __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00001B1E
.text$x:00001B1E ; ---------------------------------------------------------------------------
.text$x:00001B23                 align 4
.text$x:00001B23 _text$x         ends
.text$x:00001B23
.text$mn:00001B24 ; ===========================================================================
.text$mn:00001B24
.text$mn:00001B24 ; Segment type: Pure code
.text$mn:00001B24 ; Segment permissions: Read/Execute
.text$mn:00001B24 _text$mn        segment para public 'CODE' use32
.text$mn:00001B24                 assume cs:_text$mn
.text$mn:00001B24                 ;org 1B24h
.text$mn:00001B24 ; COMDAT (pick any)
.text$mn:00001B24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B24
.text$mn:00001B24 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B24
.text$mn:00001B24 ; Attributes: bp-based frame
.text$mn:00001B24
.text$mn:00001B24 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00001B24                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00001B24 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00001B24                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00001B24                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00001B24
.text$mn:00001B24 var_10          = dword ptr -10h
.text$mn:00001B24 var_C           = dword ptr -0Ch
.text$mn:00001B24 var_4           = dword ptr -4
.text$mn:00001B24
.text$mn:00001B24                 push    ebp
.text$mn:00001B25                 mov     ebp, esp
.text$mn:00001B27                 push    0FFFFFFFFh
.text$mn:00001B29                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00001B2E                 mov     eax, large fs:0
.text$mn:00001B34                 push    eax
.text$mn:00001B35                 push    ecx
.text$mn:00001B36                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001B3B                 xor     eax, ebp
.text$mn:00001B3D                 push    eax
.text$mn:00001B3E                 lea     eax, [ebp+var_C]
.text$mn:00001B41                 mov     large fs:0, eax
.text$mn:00001B47                 mov     [ebp+var_10], ecx
.text$mn:00001B4A                 mov     [ebp+var_4], 0
.text$mn:00001B51                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001B58                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001B5B                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001B60                 mov     ecx, [ebp+var_C]
.text$mn:00001B63                 mov     large fs:0, ecx
.text$mn:00001B6A                 pop     ecx
.text$mn:00001B6B                 mov     esp, ebp
.text$mn:00001B6D                 pop     ebp
.text$mn:00001B6E                 retn
.text$mn:00001B6E ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00001B6E
.text$mn:00001B6E ; ---------------------------------------------------------------------------
.text$mn:00001B6F                 align 10h
.text$mn:00001B6F _text$mn        ends
.text$mn:00001B6F
.text$x:00001B70 ; ===========================================================================
.text$x:00001B70
.text$x:00001B70 ; Segment type: Pure code
.text$x:00001B70 ; Segment permissions: Read/Execute
.text$x:00001B70 _text$x         segment para public 'CODE' use32
.text$x:00001B70                 assume cs:_text$x
.text$x:00001B70                 ;org 1B70h
.text$x:00001B70 ; COMDAT (pick associative to section at 1B24)
.text$x:00001B70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001B70
.text$x:00001B70 ; =============== S U B R O U T I N E =======================================
.text$x:00001B70
.text$x:00001B70
.text$x:00001B70 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00001B70                                         ; DATA XREF: .xdata$x:00002F3Co
.text$x:00001B70                 mov     ecx, [ebp-10h]  ; this
.text$x:00001B73                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001B73 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00001B73
.text$x:00001B78
.text$x:00001B78 ; =============== S U B R O U T I N E =======================================
.text$x:00001B78
.text$x:00001B78
.text$x:00001B78 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00001B78                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00001B78
.text$x:00001B78 arg_4           = dword ptr  8
.text$x:00001B78
.text$x:00001B78                 mov     edx, [esp+arg_4]
.text$x:00001B7C                 lea     eax, [edx+0Ch]
.text$x:00001B7F                 mov     ecx, [edx-8]
.text$x:00001B82                 xor     ecx, eax
.text$x:00001B84                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001B89                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00001B8E                 jmp     ___CxxFrameHandler3
.text$x:00001B8E __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00001B8E
.text$x:00001B8E ; ---------------------------------------------------------------------------
.text$x:00001B93                 align 4
.text$x:00001B93 _text$x         ends
.text$x:00001B93
.text$mn:00001B94 ; ===========================================================================
.text$mn:00001B94
.text$mn:00001B94 ; Segment type: Pure code
.text$mn:00001B94 ; Segment permissions: Read/Execute
.text$mn:00001B94 _text$mn        segment para public 'CODE' use32
.text$mn:00001B94                 assume cs:_text$mn
.text$mn:00001B94                 ;org 1B94h
.text$mn:00001B94 ; COMDAT (pick any)
.text$mn:00001B94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B94
.text$mn:00001B94 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B94
.text$mn:00001B94 ; Attributes: bp-based frame
.text$mn:00001B94
.text$mn:00001B94 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00001B94                 public ??1error_category@std@@UAE@XZ
.text$mn:00001B94 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00001B94                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00001B94
.text$mn:00001B94 var_4           = dword ptr -4
.text$mn:00001B94
.text$mn:00001B94                 push    ebp
.text$mn:00001B95                 mov     ebp, esp
.text$mn:00001B97                 push    ecx
.text$mn:00001B98                 mov     [ebp+var_4], ecx
.text$mn:00001B9B                 mov     eax, [ebp+var_4]
.text$mn:00001B9E                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00001BA4                 mov     esp, ebp
.text$mn:00001BA6                 pop     ebp
.text$mn:00001BA7                 retn
.text$mn:00001BA7 ??1error_category@std@@UAE@XZ endp
.text$mn:00001BA7
.text$mn:00001BA7 _text$mn        ends
.text$mn:00001BA7
.text$mn:00001BA8 ; ===========================================================================
.text$mn:00001BA8
.text$mn:00001BA8 ; Segment type: Pure code
.text$mn:00001BA8 ; Segment permissions: Read/Execute
.text$mn:00001BA8 _text$mn        segment para public 'CODE' use32
.text$mn:00001BA8                 assume cs:_text$mn
.text$mn:00001BA8                 ;org 1BA8h
.text$mn:00001BA8 ; COMDAT (pick any)
.text$mn:00001BA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001BA8
.text$mn:00001BA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BA8
.text$mn:00001BA8 ; Attributes: bp-based frame
.text$mn:00001BA8
.text$mn:00001BA8 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00001BA8                 public ??2@YAPAXIPAX@Z
.text$mn:00001BA8 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00001BA8                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:00001BA8
.text$mn:00001BA8 arg_4           = dword ptr  0Ch
.text$mn:00001BA8
.text$mn:00001BA8                 push    ebp
.text$mn:00001BA9                 mov     ebp, esp
.text$mn:00001BAB                 mov     eax, [ebp+arg_4]
.text$mn:00001BAE                 pop     ebp
.text$mn:00001BAF                 retn
.text$mn:00001BAF ??2@YAPAXIPAX@Z endp
.text$mn:00001BAF
.text$mn:00001BAF _text$mn        ends
.text$mn:00001BAF
.text$mn:00001BB0 ; ===========================================================================
.text$mn:00001BB0
.text$mn:00001BB0 ; Segment type: Pure code
.text$mn:00001BB0 ; Segment permissions: Read/Execute
.text$mn:00001BB0 _text$mn        segment para public 'CODE' use32
.text$mn:00001BB0                 assume cs:_text$mn
.text$mn:00001BB0                 ;org 1BB0h
.text$mn:00001BB0 ; COMDAT (pick any)
.text$mn:00001BB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001BB0
.text$mn:00001BB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BB0
.text$mn:00001BB0 ; Attributes: bp-based frame
.text$mn:00001BB0
.text$mn:00001BB0 ; void __cdecl operator delete(void *)
.text$mn:00001BB0                 public ??3@YAXPAX0@Z
.text$mn:00001BB0 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00001BB0                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:00001BB0                 push    ebp
.text$mn:00001BB1                 mov     ebp, esp
.text$mn:00001BB3                 pop     ebp
.text$mn:00001BB4                 retn
.text$mn:00001BB4 ??3@YAXPAX0@Z   endp
.text$mn:00001BB4
.text$mn:00001BB4 ; ---------------------------------------------------------------------------
.text$mn:00001BB5                 align 4
.text$mn:00001BB5 _text$mn        ends
.text$mn:00001BB5
.text$mn:00001BB8 ; ===========================================================================
.text$mn:00001BB8
.text$mn:00001BB8 ; Segment type: Pure code
.text$mn:00001BB8 ; Segment permissions: Read/Execute
.text$mn:00001BB8 _text$mn        segment para public 'CODE' use32
.text$mn:00001BB8                 assume cs:_text$mn
.text$mn:00001BB8                 ;org 1BB8h
.text$mn:00001BB8 ; COMDAT (pick any)
.text$mn:00001BB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001BB8
.text$mn:00001BB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BB8
.text$mn:00001BB8 ; Attributes: bp-based frame
.text$mn:00001BB8
.text$mn:00001BB8 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00001BB8                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00001BB8 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00001BB8                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00001BB8                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00001BB8
.text$mn:00001BB8 var_8           = dword ptr -8
.text$mn:00001BB8 var_4           = dword ptr -4
.text$mn:00001BB8 arg_0           = dword ptr  8
.text$mn:00001BB8
.text$mn:00001BB8                 push    ebp
.text$mn:00001BB9                 mov     ebp, esp
.text$mn:00001BBB                 sub     esp, 8
.text$mn:00001BBE                 mov     [ebp+var_8], ecx
.text$mn:00001BC1                 mov     eax, [ebp+var_8]
.text$mn:00001BC4                 cmp     eax, [ebp+arg_0]
.text$mn:00001BC7                 jnz     short loc_1BD2
.text$mn:00001BC9                 mov     [ebp+var_4], 1
.text$mn:00001BD0                 jmp     short loc_1BD9
.text$mn:00001BD2 ; ---------------------------------------------------------------------------
.text$mn:00001BD2
.text$mn:00001BD2 loc_1BD2:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00001BD2                 mov     [ebp+var_4], 0
.text$mn:00001BD9
.text$mn:00001BD9 loc_1BD9:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00001BD9                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001BDC                 mov     esp, ebp
.text$mn:00001BDE                 pop     ebp
.text$mn:00001BDF                 retn    4
.text$mn:00001BDF ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00001BDF
.text$mn:00001BDF ; ---------------------------------------------------------------------------
.text$mn:00001BE2                 align 4
.text$mn:00001BE2 _text$mn        ends
.text$mn:00001BE2
.text$mn:00001BE4 ; ===========================================================================
.text$mn:00001BE4
.text$mn:00001BE4 ; Segment type: Pure code
.text$mn:00001BE4 ; Segment permissions: Read/Execute
.text$mn:00001BE4 _text$mn        segment para public 'CODE' use32
.text$mn:00001BE4                 assume cs:_text$mn
.text$mn:00001BE4                 ;org 1BE4h
.text$mn:00001BE4 ; COMDAT (pick any)
.text$mn:00001BE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001BE4
.text$mn:00001BE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BE4
.text$mn:00001BE4 ; Attributes: bp-based frame
.text$mn:00001BE4
.text$mn:00001BE4 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00001BE4                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00001BE4 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00001BE4                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00001BE4
.text$mn:00001BE4 var_8           = dword ptr -8
.text$mn:00001BE4 var_4           = dword ptr -4
.text$mn:00001BE4 arg_0           = dword ptr  8
.text$mn:00001BE4
.text$mn:00001BE4                 push    ebp
.text$mn:00001BE5                 mov     ebp, esp
.text$mn:00001BE7                 sub     esp, 8
.text$mn:00001BEA                 push    esi
.text$mn:00001BEB                 mov     [ebp+var_4], ecx
.text$mn:00001BEE                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001BF1                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00001BF6                 push    eax
.text$mn:00001BF7                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001BFA                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00001BFF                 mov     ecx, eax
.text$mn:00001C01                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00001C06                 movzx   eax, al
.text$mn:00001C09                 test    eax, eax
.text$mn:00001C0B                 jz      short loc_1C2C
.text$mn:00001C0D                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001C10                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00001C15                 mov     esi, eax
.text$mn:00001C17                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001C1A                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00001C1F                 cmp     esi, eax
.text$mn:00001C21                 jnz     short loc_1C2C
.text$mn:00001C23                 mov     [ebp+var_8], 1
.text$mn:00001C2A                 jmp     short loc_1C33
.text$mn:00001C2C ; ---------------------------------------------------------------------------
.text$mn:00001C2C
.text$mn:00001C2C loc_1C2C:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00001C2C                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00001C2C                 mov     [ebp+var_8], 0
.text$mn:00001C33
.text$mn:00001C33 loc_1C33:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00001C33                 mov     al, byte ptr [ebp+var_8]
.text$mn:00001C36                 pop     esi
.text$mn:00001C37                 mov     esp, ebp
.text$mn:00001C39                 pop     ebp
.text$mn:00001C3A                 retn    4
.text$mn:00001C3A ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00001C3A
.text$mn:00001C3A ; ---------------------------------------------------------------------------
.text$mn:00001C3D                 align 10h
.text$mn:00001C3D _text$mn        ends
.text$mn:00001C3D
.text$mn:00001C40 ; ===========================================================================
.text$mn:00001C40
.text$mn:00001C40 ; Segment type: Pure code
.text$mn:00001C40 ; Segment permissions: Read/Execute
.text$mn:00001C40 _text$mn        segment para public 'CODE' use32
.text$mn:00001C40                 assume cs:_text$mn
.text$mn:00001C40                 ;org 1C40h
.text$mn:00001C40 ; COMDAT (pick any)
.text$mn:00001C40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C40
.text$mn:00001C40 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C40
.text$mn:00001C40 ; Attributes: bp-based frame
.text$mn:00001C40
.text$mn:00001C40 ; public: __thiscall Utf16_Iter::operator bool(void)
.text$mn:00001C40                 public ??BUtf16_Iter@@QAE_NXZ
.text$mn:00001C40 ??BUtf16_Iter@@QAE_NXZ proc near        ; CODE XREF: Utf8_16_Read::convert(char *,uint)+163p
.text$mn:00001C40
.text$mn:00001C40 var_8           = dword ptr -8
.text$mn:00001C40 var_4           = dword ptr -4
.text$mn:00001C40
.text$mn:00001C40                 push    ebp
.text$mn:00001C41                 mov     ebp, esp
.text$mn:00001C43                 sub     esp, 8
.text$mn:00001C46                 mov     [ebp+var_4], ecx
.text$mn:00001C49                 mov     eax, [ebp+var_4]
.text$mn:00001C4C                 mov     ecx, [ebp+var_4]
.text$mn:00001C4F                 mov     edx, [eax+10h]
.text$mn:00001C52                 cmp     edx, [ecx+14h]
.text$mn:00001C55                 ja      short loc_1C60
.text$mn:00001C57                 mov     [ebp+var_8], 1
.text$mn:00001C5E                 jmp     short loc_1C67
.text$mn:00001C60 ; ---------------------------------------------------------------------------
.text$mn:00001C60
.text$mn:00001C60 loc_1C60:                               ; CODE XREF: Utf16_Iter::operator bool(void)+15j
.text$mn:00001C60                 mov     [ebp+var_8], 0
.text$mn:00001C67
.text$mn:00001C67 loc_1C67:                               ; CODE XREF: Utf16_Iter::operator bool(void)+1Ej
.text$mn:00001C67                 mov     al, byte ptr [ebp+var_8]
.text$mn:00001C6A                 mov     esp, ebp
.text$mn:00001C6C                 pop     ebp
.text$mn:00001C6D                 retn
.text$mn:00001C6D ??BUtf16_Iter@@QAE_NXZ endp
.text$mn:00001C6D
.text$mn:00001C6D ; ---------------------------------------------------------------------------
.text$mn:00001C6E                 align 10h
.text$mn:00001C6E _text$mn        ends
.text$mn:00001C6E
.text$mn:00001C70 ; ===========================================================================
.text$mn:00001C70
.text$mn:00001C70 ; Segment type: Pure code
.text$mn:00001C70 ; Segment permissions: Read/Execute
.text$mn:00001C70 _text$mn        segment para public 'CODE' use32
.text$mn:00001C70                 assume cs:_text$mn
.text$mn:00001C70                 ;org 1C70h
.text$mn:00001C70 ; COMDAT (pick any)
.text$mn:00001C70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C70
.text$mn:00001C70 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C70
.text$mn:00001C70 ; Attributes: bp-based frame
.text$mn:00001C70
.text$mn:00001C70 ; public: __thiscall Utf8_Iter::operator bool(void)
.text$mn:00001C70                 public ??BUtf8_Iter@@QAE_NXZ
.text$mn:00001C70 ??BUtf8_Iter@@QAE_NXZ proc near         ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint)+15Bp
.text$mn:00001C70                                         ; Utf8_16_Write::fwrite(void const *,uint)+1C2p ...
.text$mn:00001C70
.text$mn:00001C70 var_8           = dword ptr -8
.text$mn:00001C70 var_4           = dword ptr -4
.text$mn:00001C70
.text$mn:00001C70                 push    ebp
.text$mn:00001C71                 mov     ebp, esp
.text$mn:00001C73                 sub     esp, 8
.text$mn:00001C76                 mov     [ebp+var_4], ecx
.text$mn:00001C79                 mov     eax, [ebp+var_4]
.text$mn:00001C7C                 mov     ecx, [ebp+var_4]
.text$mn:00001C7F                 mov     edx, [eax+10h]
.text$mn:00001C82                 cmp     edx, [ecx+14h]
.text$mn:00001C85                 ja      short loc_1C90
.text$mn:00001C87                 mov     [ebp+var_8], 1
.text$mn:00001C8E                 jmp     short loc_1C97
.text$mn:00001C90 ; ---------------------------------------------------------------------------
.text$mn:00001C90
.text$mn:00001C90 loc_1C90:                               ; CODE XREF: Utf8_Iter::operator bool(void)+15j
.text$mn:00001C90                 mov     [ebp+var_8], 0
.text$mn:00001C97
.text$mn:00001C97 loc_1C97:                               ; CODE XREF: Utf8_Iter::operator bool(void)+1Ej
.text$mn:00001C97                 mov     al, byte ptr [ebp+var_8]
.text$mn:00001C9A                 mov     esp, ebp
.text$mn:00001C9C                 pop     ebp
.text$mn:00001C9D                 retn
.text$mn:00001C9D ??BUtf8_Iter@@QAE_NXZ endp
.text$mn:00001C9D
.text$mn:00001C9D ; ---------------------------------------------------------------------------
.text$mn:00001C9E                 align 10h
.text$mn:00001C9E _text$mn        ends
.text$mn:00001C9E
.text$mn:00001CA0 ; ===========================================================================
.text$mn:00001CA0
.text$mn:00001CA0 ; Segment type: Pure code
.text$mn:00001CA0 ; Segment permissions: Read/Execute
.text$mn:00001CA0 _text$mn        segment para public 'CODE' use32
.text$mn:00001CA0                 assume cs:_text$mn
.text$mn:00001CA0                 ;org 1CA0h
.text$mn:00001CA0 ; COMDAT (pick any)
.text$mn:00001CA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CA0
.text$mn:00001CA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CA0
.text$mn:00001CA0 ; Attributes: bp-based frame
.text$mn:00001CA0
.text$mn:00001CA0 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001CA0                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00001CA0 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001CA0
.text$mn:00001CA0 var_4           = dword ptr -4
.text$mn:00001CA0 arg_0           = dword ptr  8
.text$mn:00001CA0
.text$mn:00001CA0                 push    ebp
.text$mn:00001CA1                 mov     ebp, esp
.text$mn:00001CA3                 push    ecx
.text$mn:00001CA4                 mov     [ebp+var_4], ecx
.text$mn:00001CA7                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001CAA                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001CAF                 mov     eax, [ebp+arg_0]
.text$mn:00001CB2                 and     eax, 1
.text$mn:00001CB5                 jz      short loc_1CC3
.text$mn:00001CB7                 mov     ecx, [ebp+var_4]
.text$mn:00001CBA                 push    ecx             ; void *
.text$mn:00001CBB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001CC0                 add     esp, 4
.text$mn:00001CC3
.text$mn:00001CC3 loc_1CC3:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001CC3                 mov     eax, [ebp+var_4]
.text$mn:00001CC6                 mov     esp, ebp
.text$mn:00001CC8                 pop     ebp
.text$mn:00001CC9                 retn    4
.text$mn:00001CC9 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00001CC9
.text$mn:00001CC9 _text$mn        ends
.text$mn:00001CC9
.text$mn:00001CCC ; ===========================================================================
.text$mn:00001CCC
.text$mn:00001CCC ; Segment type: Pure code
.text$mn:00001CCC ; Segment permissions: Read/Execute
.text$mn:00001CCC _text$mn        segment para public 'CODE' use32
.text$mn:00001CCC                 assume cs:_text$mn
.text$mn:00001CCC                 ;org 1CCCh
.text$mn:00001CCC ; COMDAT (pick any)
.text$mn:00001CCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CCC
.text$mn:00001CCC ; =============== S U B R O U T I N E =======================================
.text$mn:00001CCC
.text$mn:00001CCC ; Attributes: bp-based frame
.text$mn:00001CCC
.text$mn:00001CCC ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001CCC                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00001CCC ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001CCC
.text$mn:00001CCC var_4           = dword ptr -4
.text$mn:00001CCC arg_0           = dword ptr  8
.text$mn:00001CCC
.text$mn:00001CCC                 push    ebp
.text$mn:00001CCD                 mov     ebp, esp
.text$mn:00001CCF                 push    ecx
.text$mn:00001CD0                 mov     [ebp+var_4], ecx
.text$mn:00001CD3                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001CD6                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00001CDB                 mov     eax, [ebp+arg_0]
.text$mn:00001CDE                 and     eax, 1
.text$mn:00001CE1                 jz      short loc_1CEF
.text$mn:00001CE3                 mov     ecx, [ebp+var_4]
.text$mn:00001CE6                 push    ecx             ; void *
.text$mn:00001CE7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001CEC                 add     esp, 4
.text$mn:00001CEF
.text$mn:00001CEF loc_1CEF:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001CEF                 mov     eax, [ebp+var_4]
.text$mn:00001CF2                 mov     esp, ebp
.text$mn:00001CF4                 pop     ebp
.text$mn:00001CF5                 retn    4
.text$mn:00001CF5 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00001CF5
.text$mn:00001CF5 _text$mn        ends
.text$mn:00001CF5
.text$mn:00001CF8 ; ===========================================================================
.text$mn:00001CF8
.text$mn:00001CF8 ; Segment type: Pure code
.text$mn:00001CF8 ; Segment permissions: Read/Execute
.text$mn:00001CF8 _text$mn        segment para public 'CODE' use32
.text$mn:00001CF8                 assume cs:_text$mn
.text$mn:00001CF8                 ;org 1CF8h
.text$mn:00001CF8 ; COMDAT (pick any)
.text$mn:00001CF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CF8
.text$mn:00001CF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CF8
.text$mn:00001CF8 ; Attributes: bp-based frame
.text$mn:00001CF8
.text$mn:00001CF8 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001CF8                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00001CF8 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001CF8
.text$mn:00001CF8 var_4           = dword ptr -4
.text$mn:00001CF8 arg_0           = dword ptr  8
.text$mn:00001CF8
.text$mn:00001CF8                 push    ebp
.text$mn:00001CF9                 mov     ebp, esp
.text$mn:00001CFB                 push    ecx
.text$mn:00001CFC                 mov     [ebp+var_4], ecx
.text$mn:00001CFF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001D02                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00001D07                 mov     eax, [ebp+arg_0]
.text$mn:00001D0A                 and     eax, 1
.text$mn:00001D0D                 jz      short loc_1D1B
.text$mn:00001D0F                 mov     ecx, [ebp+var_4]
.text$mn:00001D12                 push    ecx             ; void *
.text$mn:00001D13                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001D18                 add     esp, 4
.text$mn:00001D1B
.text$mn:00001D1B loc_1D1B:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001D1B                 mov     eax, [ebp+var_4]
.text$mn:00001D1E                 mov     esp, ebp
.text$mn:00001D20                 pop     ebp
.text$mn:00001D21                 retn    4
.text$mn:00001D21 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00001D21
.text$mn:00001D21 _text$mn        ends
.text$mn:00001D21
.text$mn:00001D24 ; ===========================================================================
.text$mn:00001D24
.text$mn:00001D24 ; Segment type: Pure code
.text$mn:00001D24 ; Segment permissions: Read/Execute
.text$mn:00001D24 _text$mn        segment para public 'CODE' use32
.text$mn:00001D24                 assume cs:_text$mn
.text$mn:00001D24                 ;org 1D24h
.text$mn:00001D24 ; COMDAT (pick any)
.text$mn:00001D24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D24
.text$mn:00001D24 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D24
.text$mn:00001D24 ; Attributes: bp-based frame
.text$mn:00001D24
.text$mn:00001D24 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001D24                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00001D24 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00001D24
.text$mn:00001D24 var_4           = dword ptr -4
.text$mn:00001D24 arg_0           = dword ptr  8
.text$mn:00001D24
.text$mn:00001D24                 push    ebp
.text$mn:00001D25                 mov     ebp, esp
.text$mn:00001D27                 push    ecx
.text$mn:00001D28                 mov     [ebp+var_4], ecx
.text$mn:00001D2B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001D2E                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00001D33                 mov     eax, [ebp+arg_0]
.text$mn:00001D36                 and     eax, 1
.text$mn:00001D39                 jz      short loc_1D47
.text$mn:00001D3B                 mov     ecx, [ebp+var_4]
.text$mn:00001D3E                 push    ecx             ; void *
.text$mn:00001D3F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001D44                 add     esp, 4
.text$mn:00001D47
.text$mn:00001D47 loc_1D47:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001D47                 mov     eax, [ebp+var_4]
.text$mn:00001D4A                 mov     esp, ebp
.text$mn:00001D4C                 pop     ebp
.text$mn:00001D4D                 retn    4
.text$mn:00001D4D ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00001D4D
.text$mn:00001D4D _text$mn        ends
.text$mn:00001D4D
.text$di:00001D50 ; ===========================================================================
.text$di:00001D50
.text$di:00001D50 ; Segment type: Pure code
.text$di:00001D50 ; Segment permissions: Read/Execute
.text$di:00001D50 _text$di        segment para public 'CODE' use32
.text$di:00001D50                 assume cs:_text$di
.text$di:00001D50                 ;org 1D50h
.text$di:00001D50 ; COMDAT (pick any)
.text$di:00001D50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001D50
.text$di:00001D50 ; =============== S U B R O U T I N E =======================================
.text$di:00001D50
.text$di:00001D50 ; Attributes: bp-based frame
.text$di:00001D50
.text$di:00001D50 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00001D50 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00001D50                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00001D50                 push    ebp
.text$di:00001D51                 mov     ebp, esp
.text$di:00001D53                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00001D58                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00001D5D                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001D62                 call    _atexit
.text$di:00001D67                 add     esp, 4
.text$di:00001D6A                 pop     ebp
.text$di:00001D6B                 retn
.text$di:00001D6B ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00001D6B
.text$di:00001D6B _text$di        ends
.text$di:00001D6B
.text$di:00001D6C ; ===========================================================================
.text$di:00001D6C
.text$di:00001D6C ; Segment type: Pure code
.text$di:00001D6C ; Segment permissions: Read/Execute
.text$di:00001D6C _text$di        segment para public 'CODE' use32
.text$di:00001D6C                 assume cs:_text$di
.text$di:00001D6C                 ;org 1D6Ch
.text$di:00001D6C ; COMDAT (pick any)
.text$di:00001D6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001D6C
.text$di:00001D6C ; =============== S U B R O U T I N E =======================================
.text$di:00001D6C
.text$di:00001D6C ; Attributes: bp-based frame
.text$di:00001D6C
.text$di:00001D6C ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00001D6C ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00001D6C                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00001D6C                 push    ebp
.text$di:00001D6D                 mov     ebp, esp
.text$di:00001D6F                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00001D74                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00001D79                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001D7E                 call    _atexit
.text$di:00001D83                 add     esp, 4
.text$di:00001D86                 pop     ebp
.text$di:00001D87                 retn
.text$di:00001D87 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00001D87
.text$di:00001D87 _text$di        ends
.text$di:00001D87
.text$di:00001D88 ; ===========================================================================
.text$di:00001D88
.text$di:00001D88 ; Segment type: Pure code
.text$di:00001D88 ; Segment permissions: Read/Execute
.text$di:00001D88 _text$di        segment para public 'CODE' use32
.text$di:00001D88                 assume cs:_text$di
.text$di:00001D88                 ;org 1D88h
.text$di:00001D88 ; COMDAT (pick any)
.text$di:00001D88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001D88
.text$di:00001D88 ; =============== S U B R O U T I N E =======================================
.text$di:00001D88
.text$di:00001D88 ; Attributes: bp-based frame
.text$di:00001D88
.text$di:00001D88 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00001D88 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00001D88                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00001D88                 push    ebp
.text$di:00001D89                 mov     ebp, esp
.text$di:00001D8B                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00001D90                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00001D95                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001D9A                 call    _atexit
.text$di:00001D9F                 add     esp, 4
.text$di:00001DA2                 pop     ebp
.text$di:00001DA3                 retn
.text$di:00001DA3 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00001DA3
.text$di:00001DA3 _text$di        ends
.text$di:00001DA3
.text$di:00001DA4 ; ===========================================================================
.text$di:00001DA4
.text$di:00001DA4 ; Segment type: Pure code
.text$di:00001DA4 ; Segment permissions: Read/Execute
.text$di:00001DA4 _text$di        segment para public 'CODE' use32
.text$di:00001DA4                 assume cs:_text$di
.text$di:00001DA4                 ;org 1DA4h
.text$di:00001DA4 ; COMDAT (pick any)
.text$di:00001DA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001DA4
.text$di:00001DA4 ; =============== S U B R O U T I N E =======================================
.text$di:00001DA4
.text$di:00001DA4 ; Attributes: bp-based frame
.text$di:00001DA4
.text$di:00001DA4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00001DA4 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001DA4                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00001DA4                 push    ebp
.text$di:00001DA5                 mov     ebp, esp
.text$di:00001DA7                 push    0               ; unsigned int
.text$di:00001DA9                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00001DAE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001DB3                 pop     ebp
.text$di:00001DB4                 retn
.text$di:00001DB4 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001DB4
.text$di:00001DB4 ; ---------------------------------------------------------------------------
.text$di:00001DB5                 align 4
.text$di:00001DB5 _text$di        ends
.text$di:00001DB5
.text$di:00001DB8 ; ===========================================================================
.text$di:00001DB8
.text$di:00001DB8 ; Segment type: Pure code
.text$di:00001DB8 ; Segment permissions: Read/Execute
.text$di:00001DB8 _text$di        segment para public 'CODE' use32
.text$di:00001DB8                 assume cs:_text$di
.text$di:00001DB8                 ;org 1DB8h
.text$di:00001DB8 ; COMDAT (pick any)
.text$di:00001DB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001DB8
.text$di:00001DB8 ; =============== S U B R O U T I N E =======================================
.text$di:00001DB8
.text$di:00001DB8 ; Attributes: bp-based frame
.text$di:00001DB8
.text$di:00001DB8 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00001DB8 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001DB8                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00001DB8                 push    ebp
.text$di:00001DB9                 mov     ebp, esp
.text$di:00001DBB                 push    0               ; unsigned int
.text$di:00001DBD                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00001DC2                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001DC7                 pop     ebp
.text$di:00001DC8                 retn
.text$di:00001DC8 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001DC8
.text$di:00001DC8 ; ---------------------------------------------------------------------------
.text$di:00001DC9                 align 4
.text$di:00001DC9 _text$di        ends
.text$di:00001DC9
.text$di:00001DCC ; ===========================================================================
.text$di:00001DCC
.text$di:00001DCC ; Segment type: Pure code
.text$di:00001DCC ; Segment permissions: Read/Execute
.text$di:00001DCC _text$di        segment para public 'CODE' use32
.text$di:00001DCC                 assume cs:_text$di
.text$di:00001DCC                 ;org 1DCCh
.text$di:00001DCC ; COMDAT (pick any)
.text$di:00001DCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001DCC
.text$di:00001DCC ; =============== S U B R O U T I N E =======================================
.text$di:00001DCC
.text$di:00001DCC ; Attributes: bp-based frame
.text$di:00001DCC
.text$di:00001DCC ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00001DCC ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001DCC                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00001DCC                 push    ebp
.text$di:00001DCD                 mov     ebp, esp
.text$di:00001DCF                 push    0               ; unsigned int
.text$di:00001DD1                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00001DD6                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001DDB                 pop     ebp
.text$di:00001DDC                 retn
.text$di:00001DDC ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001DDC
.text$di:00001DDC ; ---------------------------------------------------------------------------
.text$di:00001DDD                 align 10h
.text$di:00001DDD _text$di        ends
.text$di:00001DDD
.text$di:00001DE0 ; ===========================================================================
.text$di:00001DE0
.text$di:00001DE0 ; Segment type: Pure code
.text$di:00001DE0 ; Segment permissions: Read/Execute
.text$di:00001DE0 _text$di        segment para public 'CODE' use32
.text$di:00001DE0                 assume cs:_text$di
.text$di:00001DE0                 ;org 1DE0h
.text$di:00001DE0 ; COMDAT (pick any)
.text$di:00001DE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001DE0
.text$di:00001DE0 ; =============== S U B R O U T I N E =======================================
.text$di:00001DE0
.text$di:00001DE0 ; Attributes: bp-based frame
.text$di:00001DE0
.text$di:00001DE0 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00001DE0 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001DE0                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00001DE0                 push    ebp
.text$di:00001DE1                 mov     ebp, esp
.text$di:00001DE3                 push    0               ; unsigned int
.text$di:00001DE5                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00001DEA                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001DEF                 pop     ebp
.text$di:00001DF0                 retn
.text$di:00001DF0 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001DF0
.text$di:00001DF0 ; ---------------------------------------------------------------------------
.text$di:00001DF1                 align 4
.text$di:00001DF1 _text$di        ends
.text$di:00001DF1
.text$di:00001DF4 ; ===========================================================================
.text$di:00001DF4
.text$di:00001DF4 ; Segment type: Pure code
.text$di:00001DF4 ; Segment permissions: Read/Execute
.text$di:00001DF4 _text$di        segment para public 'CODE' use32
.text$di:00001DF4                 assume cs:_text$di
.text$di:00001DF4                 ;org 1DF4h
.text$di:00001DF4 ; COMDAT (pick any)
.text$di:00001DF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001DF4
.text$di:00001DF4 ; =============== S U B R O U T I N E =======================================
.text$di:00001DF4
.text$di:00001DF4 ; Attributes: bp-based frame
.text$di:00001DF4
.text$di:00001DF4 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00001DF4 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00001DF4
.text$di:00001DF4 var_1           = byte ptr -1
.text$di:00001DF4
.text$di:00001DF4                 push    ebp
.text$di:00001DF5                 mov     ebp, esp
.text$di:00001DF7                 push    ecx
.text$di:00001DF8                 xor     eax, eax
.text$di:00001DFA                 mov     [ebp+var_1], al
.text$di:00001DFD                 mov     esp, ebp
.text$di:00001DFF                 pop     ebp
.text$di:00001E00                 retn
.text$di:00001E00 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00001E00
.text$di:00001E00 ; ---------------------------------------------------------------------------
.text$di:00001E01                 align 4
.text$di:00001E01 _text$di        ends
.text$di:00001E01
.text$di:00001E04 ; ===========================================================================
.text$di:00001E04
.text$di:00001E04 ; Segment type: Pure code
.text$di:00001E04 ; Segment permissions: Read/Execute
.text$di:00001E04 _text$di        segment para public 'CODE' use32
.text$di:00001E04                 assume cs:_text$di
.text$di:00001E04                 ;org 1E04h
.text$di:00001E04 ; COMDAT (pick any)
.text$di:00001E04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001E04
.text$di:00001E04 ; =============== S U B R O U T I N E =======================================
.text$di:00001E04
.text$di:00001E04 ; Attributes: bp-based frame
.text$di:00001E04
.text$di:00001E04 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00001E04 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00001E04                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00001E04
.text$di:00001E04 var_1           = byte ptr -1
.text$di:00001E04
.text$di:00001E04                 push    ebp
.text$di:00001E05                 mov     ebp, esp
.text$di:00001E07                 push    ecx
.text$di:00001E08                 xor     eax, eax
.text$di:00001E0A                 mov     [ebp+var_1], al
.text$di:00001E0D                 mov     esp, ebp
.text$di:00001E0F                 pop     ebp
.text$di:00001E10                 retn
.text$di:00001E10 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00001E10
.text$di:00001E10 ; ---------------------------------------------------------------------------
.text$di:00001E11                 align 4
.text$di:00001E11 _text$di        ends
.text$di:00001E11
.text$yd:00001E14 ; ===========================================================================
.text$yd:00001E14
.text$yd:00001E14 ; Segment type: Pure code
.text$yd:00001E14 ; Segment permissions: Read/Execute
.text$yd:00001E14 _text$yd        segment para public 'CODE' use32
.text$yd:00001E14                 assume cs:_text$yd
.text$yd:00001E14                 ;org 1E14h
.text$yd:00001E14 ; COMDAT (pick any)
.text$yd:00001E14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00001E14
.text$yd:00001E14 ; =============== S U B R O U T I N E =======================================
.text$yd:00001E14
.text$yd:00001E14 ; Attributes: bp-based frame
.text$yd:00001E14
.text$yd:00001E14 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00001E14 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00001E14                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00001E14                 push    ebp
.text$yd:00001E15                 mov     ebp, esp
.text$yd:00001E17                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00001E1C                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00001E21                 pop     ebp
.text$yd:00001E22                 retn
.text$yd:00001E22 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00001E22
.text$yd:00001E22 ; ---------------------------------------------------------------------------
.text$yd:00001E23                 align 4
.text$yd:00001E23 _text$yd        ends
.text$yd:00001E23
.text$yd:00001E24 ; ===========================================================================
.text$yd:00001E24
.text$yd:00001E24 ; Segment type: Pure code
.text$yd:00001E24 ; Segment permissions: Read/Execute
.text$yd:00001E24 _text$yd        segment para public 'CODE' use32
.text$yd:00001E24                 assume cs:_text$yd
.text$yd:00001E24                 ;org 1E24h
.text$yd:00001E24 ; COMDAT (pick any)
.text$yd:00001E24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00001E24
.text$yd:00001E24 ; =============== S U B R O U T I N E =======================================
.text$yd:00001E24
.text$yd:00001E24 ; Attributes: bp-based frame
.text$yd:00001E24
.text$yd:00001E24 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00001E24 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00001E24                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00001E24                 push    ebp
.text$yd:00001E25                 mov     ebp, esp
.text$yd:00001E27                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00001E2C                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00001E31                 pop     ebp
.text$yd:00001E32                 retn
.text$yd:00001E32 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00001E32
.text$yd:00001E32 ; ---------------------------------------------------------------------------
.text$yd:00001E33                 align 4
.text$yd:00001E33 _text$yd        ends
.text$yd:00001E33
.text$yd:00001E34 ; ===========================================================================
.text$yd:00001E34
.text$yd:00001E34 ; Segment type: Pure code
.text$yd:00001E34 ; Segment permissions: Read/Execute
.text$yd:00001E34 _text$yd        segment para public 'CODE' use32
.text$yd:00001E34                 assume cs:_text$yd
.text$yd:00001E34                 ;org 1E34h
.text$yd:00001E34 ; COMDAT (pick any)
.text$yd:00001E34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00001E34
.text$yd:00001E34 ; =============== S U B R O U T I N E =======================================
.text$yd:00001E34
.text$yd:00001E34 ; Attributes: bp-based frame
.text$yd:00001E34
.text$yd:00001E34 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00001E34 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00001E34                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00001E34                 push    ebp
.text$yd:00001E35                 mov     ebp, esp
.text$yd:00001E37                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00001E3C                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00001E41                 pop     ebp
.text$yd:00001E42                 retn
.text$yd:00001E42 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00001E42
.text$yd:00001E42 ; ---------------------------------------------------------------------------
.text$yd:00001E43                 align 4
.text$yd:00001E43 _text$yd        ends
.text$yd:00001E43
.text$mn:00001E44 ; ===========================================================================
.text$mn:00001E44
.text$mn:00001E44 ; Segment type: Pure code
.text$mn:00001E44 ; Segment permissions: Read/Execute
.text$mn:00001E44 _text$mn        segment para public 'CODE' use32
.text$mn:00001E44                 assume cs:_text$mn
.text$mn:00001E44                 ;org 1E44h
.text$mn:00001E44 ; COMDAT (pick any)
.text$mn:00001E44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E44
.text$mn:00001E44 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E44
.text$mn:00001E44 ; Attributes: bp-based frame
.text$mn:00001E44
.text$mn:00001E44 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00001E44                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00001E44 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001E44                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00001E44
.text$mn:00001E44 var_10          = byte ptr -10h
.text$mn:00001E44 var_8           = dword ptr -8
.text$mn:00001E44 var_1           = byte ptr -1
.text$mn:00001E44
.text$mn:00001E44                 push    ebp
.text$mn:00001E45                 mov     ebp, esp
.text$mn:00001E47                 sub     esp, 10h
.text$mn:00001E4A                 mov     [ebp+var_8], ecx
.text$mn:00001E4D                 lea     ecx, [ebp+var_1]
.text$mn:00001E50                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001E55                 push    1
.text$mn:00001E57                 lea     ecx, [ebp+var_1]
.text$mn:00001E5A                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00001E5F                 mov     ecx, [ebp+var_8]
.text$mn:00001E62                 mov     [ecx], eax
.text$mn:00001E64                 lea     ecx, [ebp+var_10] ; this
.text$mn:00001E67                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00001E6C                 push    eax             ; int
.text$mn:00001E6D                 mov     edx, [ebp+var_8]
.text$mn:00001E70                 mov     eax, [edx]
.text$mn:00001E72                 push    eax             ; void *
.text$mn:00001E73                 lea     ecx, [ebp+var_1]
.text$mn:00001E76                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00001E7B                 mov     ecx, [ebp+var_8]
.text$mn:00001E7E                 mov     edx, [ecx]
.text$mn:00001E80                 mov     eax, [ebp+var_8]
.text$mn:00001E83                 mov     [edx], eax
.text$mn:00001E85                 mov     esp, ebp
.text$mn:00001E87                 pop     ebp
.text$mn:00001E88                 retn
.text$mn:00001E88 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001E88
.text$mn:00001E88 ; ---------------------------------------------------------------------------
.text$mn:00001E89                 align 4
.text$mn:00001E89 _text$mn        ends
.text$mn:00001E89
.text$mn:00001E8C ; ===========================================================================
.text$mn:00001E8C
.text$mn:00001E8C ; Segment type: Pure code
.text$mn:00001E8C ; Segment permissions: Read/Execute
.text$mn:00001E8C _text$mn        segment para public 'CODE' use32
.text$mn:00001E8C                 assume cs:_text$mn
.text$mn:00001E8C                 ;org 1E8Ch
.text$mn:00001E8C ; COMDAT (pick any)
.text$mn:00001E8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E8C
.text$mn:00001E8C ; =============== S U B R O U T I N E =======================================
.text$mn:00001E8C
.text$mn:00001E8C ; Attributes: bp-based frame
.text$mn:00001E8C
.text$mn:00001E8C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00001E8C                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001E8C ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00001E8C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00001E8C
.text$mn:00001E8C var_20          = dword ptr -20h
.text$mn:00001E8C var_1C          = dword ptr -1Ch
.text$mn:00001E8C var_18          = dword ptr -18h
.text$mn:00001E8C var_11          = byte ptr -11h
.text$mn:00001E8C var_10          = dword ptr -10h
.text$mn:00001E8C var_C           = byte ptr -0Ch
.text$mn:00001E8C var_4           = dword ptr -4
.text$mn:00001E8C arg_0           = dword ptr  8
.text$mn:00001E8C
.text$mn:00001E8C ; FUNCTION CHUNK AT .text$mn:00001FAE SIZE 00000009 BYTES
.text$mn:00001E8C
.text$mn:00001E8C                 push    ebp
.text$mn:00001E8D                 mov     ebp, esp
.text$mn:00001E8F                 push    0FFFFFFFFh
.text$mn:00001E91                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001E96                 mov     eax, large fs:0
.text$mn:00001E9C                 push    eax
.text$mn:00001E9D                 push    ecx
.text$mn:00001E9E                 sub     esp, 10h
.text$mn:00001EA1                 push    ebx
.text$mn:00001EA2                 push    esi
.text$mn:00001EA3                 push    edi
.text$mn:00001EA4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001EA9                 xor     eax, ebp
.text$mn:00001EAB                 push    eax
.text$mn:00001EAC                 lea     eax, [ebp+var_C]
.text$mn:00001EAF                 mov     large fs:0, eax
.text$mn:00001EB5                 mov     [ebp+var_10], esp
.text$mn:00001EB8                 mov     [ebp+var_18], ecx
.text$mn:00001EBB                 mov     eax, [ebp+arg_0]
.text$mn:00001EBE                 or      eax, 0Fh
.text$mn:00001EC1                 mov     [ebp+var_1C], eax
.text$mn:00001EC4                 mov     ecx, [ebp+var_18]
.text$mn:00001EC7                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001ECC                 cmp     eax, [ebp+var_1C]
.text$mn:00001ECF                 jnb     short loc_1ED9
.text$mn:00001ED1                 mov     ecx, [ebp+arg_0]
.text$mn:00001ED4                 mov     [ebp+var_1C], ecx
.text$mn:00001ED7                 jmp     short loc_1F2B
.text$mn:00001ED9 ; ---------------------------------------------------------------------------
.text$mn:00001ED9
.text$mn:00001ED9 loc_1ED9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00001ED9                 mov     edx, [ebp+var_18]
.text$mn:00001EDC                 mov     ecx, [edx+18h]
.text$mn:00001EDF                 shr     ecx, 1
.text$mn:00001EE1                 mov     eax, [ebp+var_1C]
.text$mn:00001EE4                 xor     edx, edx
.text$mn:00001EE6                 mov     esi, 3
.text$mn:00001EEB                 div     esi
.text$mn:00001EED                 cmp     ecx, eax
.text$mn:00001EEF                 ja      short loc_1EF3
.text$mn:00001EF1                 jmp     short loc_1F2B
.text$mn:00001EF3 ; ---------------------------------------------------------------------------
.text$mn:00001EF3
.text$mn:00001EF3 loc_1EF3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00001EF3                 mov     ecx, [ebp+var_18]
.text$mn:00001EF6                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001EFB                 mov     edx, [ebp+var_18]
.text$mn:00001EFE                 mov     ecx, [edx+18h]
.text$mn:00001F01                 shr     ecx, 1
.text$mn:00001F03                 sub     eax, ecx
.text$mn:00001F05                 mov     edx, [ebp+var_18]
.text$mn:00001F08                 cmp     [edx+18h], eax
.text$mn:00001F0B                 ja      short loc_1F20
.text$mn:00001F0D                 mov     eax, [ebp+var_18]
.text$mn:00001F10                 mov     ecx, [eax+18h]
.text$mn:00001F13                 shr     ecx, 1
.text$mn:00001F15                 mov     edx, [ebp+var_18]
.text$mn:00001F18                 add     ecx, [edx+18h]
.text$mn:00001F1B                 mov     [ebp+var_1C], ecx
.text$mn:00001F1E                 jmp     short loc_1F2B
.text$mn:00001F20 ; ---------------------------------------------------------------------------
.text$mn:00001F20
.text$mn:00001F20 loc_1F20:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00001F20                 mov     ecx, [ebp+var_18]
.text$mn:00001F23                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001F28                 mov     [ebp+var_1C], eax
.text$mn:00001F2B
.text$mn:00001F2B loc_1F2B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00001F2B                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00001F2B                 mov     [ebp+var_4], 0
.text$mn:00001F32                 mov     eax, [ebp+var_1C]
.text$mn:00001F35                 add     eax, 1
.text$mn:00001F38                 push    eax
.text$mn:00001F39                 lea     ecx, [ebp+var_11]
.text$mn:00001F3C                 push    ecx
.text$mn:00001F3D                 mov     ecx, [ebp+var_18]
.text$mn:00001F40                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001F45                 mov     ecx, eax
.text$mn:00001F47                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00001F4C                 mov     [ebp+var_20], eax
.text$mn:00001F4F                 jmp     short loc_1FAE
.text$mn:00001F4F ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00001F4F
.text$mn:00001F51
.text$mn:00001F51 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F51
.text$mn:00001F51
.text$mn:00001F51 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00001F51                                         ; DATA XREF: .xdata$x:00002D58o
.text$mn:00001F51
.text$mn:00001F51 ; FUNCTION CHUNK AT .text$mn:00001F98 SIZE 00000009 BYTES
.text$mn:00001F51 ; FUNCTION CHUNK AT .text$mn:00001FA8 SIZE 00000006 BYTES
.text$mn:00001F51
.text$mn:00001F51                 mov     [ebp-10h], esp
.text$mn:00001F54                 mov     edx, [ebp+8]
.text$mn:00001F57                 mov     [ebp-1Ch], edx
.text$mn:00001F5A                 mov     byte ptr [ebp-4], 2
.text$mn:00001F5E                 mov     eax, [ebp-1Ch]
.text$mn:00001F61                 add     eax, 1
.text$mn:00001F64                 push    eax
.text$mn:00001F65                 lea     ecx, [ebp-12h]
.text$mn:00001F68                 push    ecx
.text$mn:00001F69                 mov     ecx, [ebp-18h]
.text$mn:00001F6C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001F71                 mov     ecx, eax
.text$mn:00001F73                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00001F78                 mov     [ebp-20h], eax
.text$mn:00001F7B                 jmp     short loc_1F98
.text$mn:00001F7B __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00001F7B
.text$mn:00001F7D
.text$mn:00001F7D ; =============== S U B R O U T I N E =======================================
.text$mn:00001F7D
.text$mn:00001F7D ; Attributes: noreturn
.text$mn:00001F7D
.text$mn:00001F7D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00001F7D                                         ; DATA XREF: .xdata$x:00002D68o
.text$mn:00001F7D                 push    0               ; Size
.text$mn:00001F7F                 push    1               ; char
.text$mn:00001F81                 mov     ecx, [ebp-18h]
.text$mn:00001F84                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001F89                 push    0
.text$mn:00001F8B                 push    0
.text$mn:00001F8D                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00001F8D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00001F8D
.text$mn:00001F92 ; ---------------------------------------------------------------------------
.text$mn:00001F92                 mov     eax, offset $LN17
.text$mn:00001F97                 retn
.text$mn:00001F98 ; ---------------------------------------------------------------------------
.text$mn:00001F98 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001F98
.text$mn:00001F98 loc_1F98:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00001F98                 mov     dword ptr [ebp-4], 1
.text$mn:00001F9F                 jmp     short loc_1FA8
.text$mn:00001F9F ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001FA1
.text$mn:00001FA1 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FA1
.text$mn:00001FA1
.text$mn:00001FA1 $LN17           proc near               ; DATA XREF: .text$mn:00001F92o
.text$mn:00001FA1                 mov     dword ptr [ebp-4], 1
.text$mn:00001FA1 $LN17           endp ; sp-analysis failed
.text$mn:00001FA1
.text$mn:00001FA8 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001FA8
.text$mn:00001FA8 loc_1FA8:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00001FA8                 mov     eax, offset $LN19
.text$mn:00001FAD                 retn
.text$mn:00001FAD ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001FAE ; ---------------------------------------------------------------------------
.text$mn:00001FAE ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001FAE
.text$mn:00001FAE loc_1FAE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00001FAE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001FB5                 jmp     short loc_1FBE
.text$mn:00001FB5 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001FB7
.text$mn:00001FB7 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FB7
.text$mn:00001FB7
.text$mn:00001FB7 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_1FA8o
.text$mn:00001FB7                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00001FBE
.text$mn:00001FBE loc_1FBE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00001FBE                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00001FC2                 jbe     short loc_1FDD
.text$mn:00001FC4                 mov     edx, [ebp+0Ch]
.text$mn:00001FC7                 push    edx             ; Size
.text$mn:00001FC8                 mov     ecx, [ebp-18h]
.text$mn:00001FCB                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001FD0                 push    eax             ; Src
.text$mn:00001FD1                 mov     eax, [ebp-20h]
.text$mn:00001FD4                 push    eax             ; Dst
.text$mn:00001FD5                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001FDA                 add     esp, 0Ch
.text$mn:00001FDD
.text$mn:00001FDD loc_1FDD:                               ; CODE XREF: $LN19+Bj
.text$mn:00001FDD                 push    0               ; Size
.text$mn:00001FDF                 push    1               ; char
.text$mn:00001FE1                 mov     ecx, [ebp-18h]
.text$mn:00001FE4                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001FE9                 lea     ecx, [ebp-20h]
.text$mn:00001FEC                 push    ecx             ; int
.text$mn:00001FED                 mov     edx, [ebp-18h]
.text$mn:00001FF0                 add     edx, 4
.text$mn:00001FF3                 push    edx             ; void *
.text$mn:00001FF4                 lea     eax, [ebp-13h]
.text$mn:00001FF7                 push    eax
.text$mn:00001FF8                 mov     ecx, [ebp-18h]
.text$mn:00001FFB                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002000                 mov     ecx, eax
.text$mn:00002002                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00002007                 mov     ecx, [ebp-18h]
.text$mn:0000200A                 mov     edx, [ebp-1Ch]
.text$mn:0000200D                 mov     [ecx+18h], edx
.text$mn:00002010                 mov     eax, [ebp+0Ch]
.text$mn:00002013                 push    eax
.text$mn:00002014                 mov     ecx, [ebp-18h]
.text$mn:00002017                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000201C                 mov     ecx, [ebp-0Ch]
.text$mn:0000201F                 mov     large fs:0, ecx
.text$mn:00002026                 pop     ecx
.text$mn:00002027                 pop     edi
.text$mn:00002028                 pop     esi
.text$mn:00002029                 pop     ebx
.text$mn:0000202A                 mov     esp, ebp
.text$mn:0000202C                 pop     ebp
.text$mn:0000202D                 retn    8
.text$mn:0000202D $LN19           endp ; sp-analysis failed
.text$mn:0000202D
.text$mn:0000202D _text$mn        ends
.text$mn:0000202D
.text$x:00002030 ; ===========================================================================
.text$x:00002030
.text$x:00002030 ; Segment type: Pure code
.text$x:00002030 ; Segment permissions: Read/Execute
.text$x:00002030 _text$x         segment para public 'CODE' use32
.text$x:00002030                 assume cs:_text$x
.text$x:00002030                 ;org 2030h
.text$x:00002030 ; COMDAT (pick associative to section at 1E8C)
.text$x:00002030                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002030
.text$x:00002030 ; =============== S U B R O U T I N E =======================================
.text$x:00002030
.text$x:00002030
.text$x:00002030 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00002030                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00002030
.text$x:00002030 arg_4           = dword ptr  8
.text$x:00002030
.text$x:00002030                 mov     edx, [esp+arg_4]
.text$x:00002034                 lea     eax, [edx+0Ch]
.text$x:00002037                 mov     ecx, [edx-24h]
.text$x:0000203A                 xor     ecx, eax
.text$x:0000203C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002041                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00002046                 jmp     ___CxxFrameHandler3
.text$x:00002046 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00002046
.text$x:00002046 ; ---------------------------------------------------------------------------
.text$x:0000204B                 align 4
.text$x:0000204B _text$x         ends
.text$x:0000204B
.text$mn:0000204C ; ===========================================================================
.text$mn:0000204C
.text$mn:0000204C ; Segment type: Pure code
.text$mn:0000204C ; Segment permissions: Read/Execute
.text$mn:0000204C _text$mn        segment para public 'CODE' use32
.text$mn:0000204C                 assume cs:_text$mn
.text$mn:0000204C                 ;org 204Ch
.text$mn:0000204C ; COMDAT (pick any)
.text$mn:0000204C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000204C
.text$mn:0000204C ; =============== S U B R O U T I N E =======================================
.text$mn:0000204C
.text$mn:0000204C ; Attributes: bp-based frame
.text$mn:0000204C
.text$mn:0000204C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:0000204C                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:0000204C ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:0000204C                                         ; CODE XREF: $LN19+60p
.text$mn:0000204C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:0000204C
.text$mn:0000204C var_8           = dword ptr -8
.text$mn:0000204C var_1           = byte ptr -1
.text$mn:0000204C arg_0           = dword ptr  8
.text$mn:0000204C
.text$mn:0000204C                 push    ebp
.text$mn:0000204D                 mov     ebp, esp
.text$mn:0000204F                 sub     esp, 8
.text$mn:00002052                 mov     [ebp+var_8], ecx
.text$mn:00002055                 mov     [ebp+var_1], 0
.text$mn:00002059                 mov     eax, [ebp+var_8]
.text$mn:0000205C                 mov     ecx, [ebp+arg_0]
.text$mn:0000205F                 mov     [eax+14h], ecx
.text$mn:00002062                 lea     edx, [ebp+var_1]
.text$mn:00002065                 push    edx
.text$mn:00002066                 mov     ecx, [ebp+var_8]
.text$mn:00002069                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000206E                 add     eax, [ebp+arg_0]
.text$mn:00002071                 push    eax
.text$mn:00002072                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00002077                 add     esp, 8
.text$mn:0000207A                 mov     esp, ebp
.text$mn:0000207C                 pop     ebp
.text$mn:0000207D                 retn    4
.text$mn:0000207D ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:0000207D
.text$mn:0000207D _text$mn        ends
.text$mn:0000207D
.text$mn:00002080 ; ===========================================================================
.text$mn:00002080
.text$mn:00002080 ; Segment type: Pure code
.text$mn:00002080 ; Segment permissions: Read/Execute
.text$mn:00002080 _text$mn        segment para public 'CODE' use32
.text$mn:00002080                 assume cs:_text$mn
.text$mn:00002080                 ;org 2080h
.text$mn:00002080 ; COMDAT (pick any)
.text$mn:00002080                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002080
.text$mn:00002080 ; =============== S U B R O U T I N E =======================================
.text$mn:00002080
.text$mn:00002080 ; Attributes: bp-based frame
.text$mn:00002080
.text$mn:00002080 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00002080                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00002080 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00002080                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00002080
.text$mn:00002080 var_8           = dword ptr -8
.text$mn:00002080 var_1           = byte ptr -1
.text$mn:00002080
.text$mn:00002080                 push    ebp
.text$mn:00002081                 mov     ebp, esp
.text$mn:00002083                 sub     esp, 8
.text$mn:00002086                 mov     [ebp+var_8], ecx
.text$mn:00002089                 lea     ecx, [ebp+var_1]
.text$mn:0000208C                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00002091                 mov     ecx, [ebp+var_8] ; this
.text$mn:00002094                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00002099                 mov     eax, [ebp+var_8]
.text$mn:0000209C                 mov     ecx, [eax]
.text$mn:0000209E                 push    ecx
.text$mn:0000209F                 lea     ecx, [ebp+var_1]
.text$mn:000020A2                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000020A7                 push    1               ; int
.text$mn:000020A9                 mov     edx, [ebp+var_8]
.text$mn:000020AC                 mov     eax, [edx]
.text$mn:000020AE                 push    eax             ; void *
.text$mn:000020AF                 lea     ecx, [ebp+var_1]
.text$mn:000020B2                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:000020B7                 mov     ecx, [ebp+var_8]
.text$mn:000020BA                 mov     dword ptr [ecx], 0
.text$mn:000020C0                 mov     esp, ebp
.text$mn:000020C2                 pop     ebp
.text$mn:000020C3                 retn
.text$mn:000020C3 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000020C3
.text$mn:000020C3 _text$mn        ends
.text$mn:000020C3
.text$mn:000020C4 ; ===========================================================================
.text$mn:000020C4
.text$mn:000020C4 ; Segment type: Pure code
.text$mn:000020C4 ; Segment permissions: Read/Execute
.text$mn:000020C4 _text$mn        segment para public 'CODE' use32
.text$mn:000020C4                 assume cs:_text$mn
.text$mn:000020C4                 ;org 20C4h
.text$mn:000020C4 ; COMDAT (pick any)
.text$mn:000020C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020C4
.text$mn:000020C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000020C4
.text$mn:000020C4 ; Attributes: bp-based frame
.text$mn:000020C4
.text$mn:000020C4 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:000020C4                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:000020C4 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:000020C4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:000020C4                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:000020C4
.text$mn:000020C4 var_4           = dword ptr -4
.text$mn:000020C4 arg_0           = dword ptr  8
.text$mn:000020C4
.text$mn:000020C4                 push    ebp
.text$mn:000020C5                 mov     ebp, esp
.text$mn:000020C7                 push    ecx
.text$mn:000020C8                 mov     [ebp+var_4], ecx
.text$mn:000020CB                 mov     ecx, [ebp+arg_0]
.text$mn:000020CE                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:000020D3                 mov     eax, [ebp+arg_0]
.text$mn:000020D6                 mov     esp, ebp
.text$mn:000020D8                 pop     ebp
.text$mn:000020D9                 retn    4
.text$mn:000020D9 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:000020D9
.text$mn:000020D9 _text$mn        ends
.text$mn:000020D9
.text$mn:000020DC ; ===========================================================================
.text$mn:000020DC
.text$mn:000020DC ; Segment type: Pure code
.text$mn:000020DC ; Segment permissions: Read/Execute
.text$mn:000020DC _text$mn        segment para public 'CODE' use32
.text$mn:000020DC                 assume cs:_text$mn
.text$mn:000020DC                 ;org 20DCh
.text$mn:000020DC ; COMDAT (pick any)
.text$mn:000020DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020DC
.text$mn:000020DC ; =============== S U B R O U T I N E =======================================
.text$mn:000020DC
.text$mn:000020DC ; Attributes: bp-based frame
.text$mn:000020DC
.text$mn:000020DC ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:000020DC                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:000020DC ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:000020DC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:000020DC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:000020DC
.text$mn:000020DC var_C           = dword ptr -0Ch
.text$mn:000020DC Size            = dword ptr -8
.text$mn:000020DC var_4           = dword ptr -4
.text$mn:000020DC arg_0           = dword ptr  8
.text$mn:000020DC arg_4           = byte ptr  0Ch
.text$mn:000020DC
.text$mn:000020DC                 push    ebp
.text$mn:000020DD                 mov     ebp, esp
.text$mn:000020DF                 sub     esp, 0Ch
.text$mn:000020E2                 mov     [ebp+var_4], ecx
.text$mn:000020E5                 mov     ecx, [ebp+var_4]
.text$mn:000020E8                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000020ED                 cmp     eax, [ebp+arg_0]
.text$mn:000020F0                 jnb     short loc_20FA
.text$mn:000020F2                 mov     ecx, [ebp+var_4]
.text$mn:000020F5                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:000020FA
.text$mn:000020FA loc_20FA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:000020FA                 mov     eax, [ebp+var_4]
.text$mn:000020FD                 mov     ecx, [eax+18h]
.text$mn:00002100                 cmp     ecx, [ebp+arg_0]
.text$mn:00002103                 jnb     short loc_211A
.text$mn:00002105                 mov     edx, [ebp+var_4]
.text$mn:00002108                 mov     eax, [edx+14h]
.text$mn:0000210B                 push    eax
.text$mn:0000210C                 mov     ecx, [ebp+arg_0]
.text$mn:0000210F                 push    ecx
.text$mn:00002110                 mov     ecx, [ebp+var_4]
.text$mn:00002113                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00002118                 jmp     short loc_2164
.text$mn:0000211A ; ---------------------------------------------------------------------------
.text$mn:0000211A
.text$mn:0000211A loc_211A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:0000211A                 movzx   edx, [ebp+arg_4]
.text$mn:0000211E                 test    edx, edx
.text$mn:00002120                 jz      short loc_2154
.text$mn:00002122                 cmp     [ebp+arg_0], 10h
.text$mn:00002126                 jnb     short loc_2154
.text$mn:00002128                 mov     eax, [ebp+var_4]
.text$mn:0000212B                 mov     ecx, [ebp+arg_0]
.text$mn:0000212E                 cmp     ecx, [eax+14h]
.text$mn:00002131                 jnb     short loc_213B
.text$mn:00002133                 mov     edx, [ebp+arg_0]
.text$mn:00002136                 mov     [ebp+Size], edx
.text$mn:00002139                 jmp     short loc_2144
.text$mn:0000213B ; ---------------------------------------------------------------------------
.text$mn:0000213B
.text$mn:0000213B loc_213B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:0000213B                 mov     eax, [ebp+var_4]
.text$mn:0000213E                 mov     ecx, [eax+14h]
.text$mn:00002141                 mov     [ebp+Size], ecx
.text$mn:00002144
.text$mn:00002144 loc_2144:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00002144                 mov     edx, [ebp+Size]
.text$mn:00002147                 push    edx             ; Size
.text$mn:00002148                 push    1               ; char
.text$mn:0000214A                 mov     ecx, [ebp+var_4]
.text$mn:0000214D                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00002152                 jmp     short loc_2164
.text$mn:00002154 ; ---------------------------------------------------------------------------
.text$mn:00002154
.text$mn:00002154 loc_2154:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00002154                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00002154                 cmp     [ebp+arg_0], 0
.text$mn:00002158                 jnz     short loc_2164
.text$mn:0000215A                 push    0
.text$mn:0000215C                 mov     ecx, [ebp+var_4]
.text$mn:0000215F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002164
.text$mn:00002164 loc_2164:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00002164                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00002164                 cmp     [ebp+arg_0], 0
.text$mn:00002168                 jbe     short loc_2173
.text$mn:0000216A                 mov     [ebp+var_C], 1
.text$mn:00002171                 jmp     short loc_217A
.text$mn:00002173 ; ---------------------------------------------------------------------------
.text$mn:00002173
.text$mn:00002173 loc_2173:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00002173                 mov     [ebp+var_C], 0
.text$mn:0000217A
.text$mn:0000217A loc_217A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:0000217A                 mov     al, byte ptr [ebp+var_C]
.text$mn:0000217D                 mov     esp, ebp
.text$mn:0000217F                 pop     ebp
.text$mn:00002180                 retn    8
.text$mn:00002180 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00002180
.text$mn:00002180 ; ---------------------------------------------------------------------------
.text$mn:00002183                 align 4
.text$mn:00002183 _text$mn        ends
.text$mn:00002183
.text$mn:00002184 ; ===========================================================================
.text$mn:00002184
.text$mn:00002184 ; Segment type: Pure code
.text$mn:00002184 ; Segment permissions: Read/Execute
.text$mn:00002184 _text$mn        segment para public 'CODE' use32
.text$mn:00002184                 assume cs:_text$mn
.text$mn:00002184                 ;org 2184h
.text$mn:00002184 ; COMDAT (pick any)
.text$mn:00002184                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002184
.text$mn:00002184 ; =============== S U B R O U T I N E =======================================
.text$mn:00002184
.text$mn:00002184 ; Attributes: bp-based frame
.text$mn:00002184
.text$mn:00002184 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00002184                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00002184 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00002184                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00002184
.text$mn:00002184 var_4           = dword ptr -4
.text$mn:00002184 arg_0           = dword ptr  8
.text$mn:00002184
.text$mn:00002184                 push    ebp
.text$mn:00002185                 mov     ebp, esp
.text$mn:00002187                 push    ecx
.text$mn:00002188                 mov     [ebp+var_4], ecx
.text$mn:0000218B                 cmp     [ebp+arg_0], 0
.text$mn:0000218F                 jz      short loc_21B1
.text$mn:00002191                 mov     ecx, [ebp+var_4]
.text$mn:00002194                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002199                 cmp     [ebp+arg_0], eax
.text$mn:0000219C                 jb      short loc_21B1
.text$mn:0000219E                 mov     ecx, [ebp+var_4]
.text$mn:000021A1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000021A6                 mov     ecx, [ebp+var_4]
.text$mn:000021A9                 add     eax, [ecx+14h]
.text$mn:000021AC                 cmp     eax, [ebp+arg_0]
.text$mn:000021AF                 ja      short loc_21B7
.text$mn:000021B1
.text$mn:000021B1 loc_21B1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:000021B1                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:000021B1                 xor     al, al
.text$mn:000021B3                 jmp     short loc_21B9
.text$mn:000021B5 ; ---------------------------------------------------------------------------
.text$mn:000021B5                 jmp     short loc_21B9
.text$mn:000021B7 ; ---------------------------------------------------------------------------
.text$mn:000021B7
.text$mn:000021B7 loc_21B7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:000021B7                 mov     al, 1
.text$mn:000021B9
.text$mn:000021B9 loc_21B9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:000021B9                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:000021B9                 mov     esp, ebp
.text$mn:000021BB                 pop     ebp
.text$mn:000021BC                 retn    4
.text$mn:000021BC ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:000021BC
.text$mn:000021BC ; ---------------------------------------------------------------------------
.text$mn:000021BF                 align 10h
.text$mn:000021BF _text$mn        ends
.text$mn:000021BF
.text$mn:000021C0 ; ===========================================================================
.text$mn:000021C0
.text$mn:000021C0 ; Segment type: Pure code
.text$mn:000021C0 ; Segment permissions: Read/Execute
.text$mn:000021C0 _text$mn        segment para public 'CODE' use32
.text$mn:000021C0                 assume cs:_text$mn
.text$mn:000021C0                 ;org 21C0h
.text$mn:000021C0 ; COMDAT (pick any)
.text$mn:000021C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000021C0
.text$mn:000021C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000021C0
.text$mn:000021C0 ; Attributes: bp-based frame
.text$mn:000021C0
.text$mn:000021C0 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:000021C0                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:000021C0 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:000021C0                                         ; CODE XREF: $LN19+14p
.text$mn:000021C0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:000021C0
.text$mn:000021C0 var_8           = dword ptr -8
.text$mn:000021C0 var_4           = dword ptr -4
.text$mn:000021C0
.text$mn:000021C0                 push    ebp
.text$mn:000021C1                 mov     ebp, esp
.text$mn:000021C3                 sub     esp, 8
.text$mn:000021C6                 mov     [ebp+var_4], ecx
.text$mn:000021C9                 mov     eax, [ebp+var_4]
.text$mn:000021CC                 cmp     dword ptr [eax+18h], 10h
.text$mn:000021D0                 jb      short loc_21E6
.text$mn:000021D2                 mov     ecx, [ebp+var_4]
.text$mn:000021D5                 mov     edx, [ecx+4]
.text$mn:000021D8                 push    edx
.text$mn:000021D9                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000021DE                 add     esp, 4
.text$mn:000021E1                 mov     [ebp+var_8], eax
.text$mn:000021E4                 jmp     short loc_21EF
.text$mn:000021E6 ; ---------------------------------------------------------------------------
.text$mn:000021E6
.text$mn:000021E6 loc_21E6:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:000021E6                 mov     eax, [ebp+var_4]
.text$mn:000021E9                 add     eax, 4
.text$mn:000021EC                 mov     [ebp+var_8], eax
.text$mn:000021EF
.text$mn:000021EF loc_21EF:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000021EF                 mov     eax, [ebp+var_8]
.text$mn:000021F2                 mov     esp, ebp
.text$mn:000021F4                 pop     ebp
.text$mn:000021F5                 retn
.text$mn:000021F5 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:000021F5
.text$mn:000021F5 ; ---------------------------------------------------------------------------
.text$mn:000021F6                 align 4
.text$mn:000021F6 _text$mn        ends
.text$mn:000021F6
.text$mn:000021F8 ; ===========================================================================
.text$mn:000021F8
.text$mn:000021F8 ; Segment type: Pure code
.text$mn:000021F8 ; Segment permissions: Read/Execute
.text$mn:000021F8 _text$mn        segment para public 'CODE' use32
.text$mn:000021F8                 assume cs:_text$mn
.text$mn:000021F8                 ;org 21F8h
.text$mn:000021F8 ; COMDAT (pick any)
.text$mn:000021F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000021F8
.text$mn:000021F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000021F8
.text$mn:000021F8 ; Attributes: bp-based frame
.text$mn:000021F8
.text$mn:000021F8 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:000021F8                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:000021F8 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:000021F8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:000021F8
.text$mn:000021F8 var_8           = dword ptr -8
.text$mn:000021F8 var_4           = dword ptr -4
.text$mn:000021F8
.text$mn:000021F8                 push    ebp
.text$mn:000021F9                 mov     ebp, esp
.text$mn:000021FB                 sub     esp, 8
.text$mn:000021FE                 mov     [ebp+var_4], ecx
.text$mn:00002201                 mov     eax, [ebp+var_4]
.text$mn:00002204                 cmp     dword ptr [eax+18h], 10h
.text$mn:00002208                 jb      short loc_221E
.text$mn:0000220A                 mov     ecx, [ebp+var_4]
.text$mn:0000220D                 mov     edx, [ecx+4]
.text$mn:00002210                 push    edx
.text$mn:00002211                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00002216                 add     esp, 4
.text$mn:00002219                 mov     [ebp+var_8], eax
.text$mn:0000221C                 jmp     short loc_2227
.text$mn:0000221E ; ---------------------------------------------------------------------------
.text$mn:0000221E
.text$mn:0000221E loc_221E:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000221E                 mov     eax, [ebp+var_4]
.text$mn:00002221                 add     eax, 4
.text$mn:00002224                 mov     [ebp+var_8], eax
.text$mn:00002227
.text$mn:00002227 loc_2227:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00002227                 mov     eax, [ebp+var_8]
.text$mn:0000222A                 mov     esp, ebp
.text$mn:0000222C                 pop     ebp
.text$mn:0000222D                 retn
.text$mn:0000222D ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:0000222D
.text$mn:0000222D ; ---------------------------------------------------------------------------
.text$mn:0000222E                 align 10h
.text$mn:0000222E _text$mn        ends
.text$mn:0000222E
.text$mn:00002230 ; ===========================================================================
.text$mn:00002230
.text$mn:00002230 ; Segment type: Pure code
.text$mn:00002230 ; Segment permissions: Read/Execute
.text$mn:00002230 _text$mn        segment para public 'CODE' use32
.text$mn:00002230                 assume cs:_text$mn
.text$mn:00002230                 ;org 2230h
.text$mn:00002230 ; COMDAT (pick any)
.text$mn:00002230                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002230
.text$mn:00002230 ; =============== S U B R O U T I N E =======================================
.text$mn:00002230
.text$mn:00002230 ; Attributes: bp-based frame
.text$mn:00002230
.text$mn:00002230 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00002230                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00002230 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00002230                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00002230                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:00002230
.text$mn:00002230 var_18          = byte ptr -18h
.text$mn:00002230 var_14          = dword ptr -14h
.text$mn:00002230 var_10          = dword ptr -10h
.text$mn:00002230 var_C           = dword ptr -0Ch
.text$mn:00002230 var_4           = dword ptr -4
.text$mn:00002230
.text$mn:00002230                 push    ebp
.text$mn:00002231                 mov     ebp, esp
.text$mn:00002233                 push    0FFFFFFFFh
.text$mn:00002235                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:0000223A                 mov     eax, large fs:0
.text$mn:00002240                 push    eax
.text$mn:00002241                 sub     esp, 0Ch
.text$mn:00002244                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002249                 xor     eax, ebp
.text$mn:0000224B                 push    eax
.text$mn:0000224C                 lea     eax, [ebp+var_C]
.text$mn:0000224F                 mov     large fs:0, eax
.text$mn:00002255                 mov     [ebp+var_14], ecx
.text$mn:00002258                 mov     eax, [ebp+var_14]
.text$mn:0000225B                 cmp     dword ptr [eax], 0
.text$mn:0000225E                 jz      short loc_22BB
.text$mn:00002260                 push    3               ; int
.text$mn:00002262                 lea     ecx, [ebp+var_18] ; this
.text$mn:00002265                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000226A                 mov     [ebp+var_4], 0
.text$mn:00002271                 mov     ecx, [ebp+var_14]
.text$mn:00002274                 mov     edx, [ecx]
.text$mn:00002276                 add     edx, 4
.text$mn:00002279                 mov     [ebp+var_10], edx
.text$mn:0000227C                 jmp     short loc_228B
.text$mn:0000227E ; ---------------------------------------------------------------------------
.text$mn:0000227E
.text$mn:0000227E loc_227E:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:0000227E                 mov     eax, [ebp+var_10]
.text$mn:00002281                 mov     ecx, [eax]
.text$mn:00002283                 mov     edx, [ebp+var_10]
.text$mn:00002286                 mov     eax, [ecx+4]
.text$mn:00002289                 mov     [edx], eax
.text$mn:0000228B
.text$mn:0000228B loc_228B:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:0000228B                 mov     ecx, [ebp+var_10]
.text$mn:0000228E                 cmp     dword ptr [ecx], 0
.text$mn:00002291                 jz      short loc_22A0
.text$mn:00002293                 mov     edx, [ebp+var_10]
.text$mn:00002296                 mov     eax, [edx]
.text$mn:00002298                 mov     dword ptr [eax], 0
.text$mn:0000229E                 jmp     short loc_227E
.text$mn:000022A0 ; ---------------------------------------------------------------------------
.text$mn:000022A0
.text$mn:000022A0 loc_22A0:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:000022A0                 mov     ecx, [ebp+var_14]
.text$mn:000022A3                 mov     edx, [ecx]
.text$mn:000022A5                 mov     dword ptr [edx+4], 0
.text$mn:000022AC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000022B3                 lea     ecx, [ebp+var_18] ; this
.text$mn:000022B6                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000022BB
.text$mn:000022BB loc_22BB:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:000022BB                 mov     ecx, [ebp+var_C]
.text$mn:000022BE                 mov     large fs:0, ecx
.text$mn:000022C5                 pop     ecx
.text$mn:000022C6                 mov     esp, ebp
.text$mn:000022C8                 pop     ebp
.text$mn:000022C9                 retn
.text$mn:000022C9 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:000022C9
.text$mn:000022C9 ; ---------------------------------------------------------------------------
.text$mn:000022CA                 align 4
.text$mn:000022CA _text$mn        ends
.text$mn:000022CA
.text$x:000022CC ; ===========================================================================
.text$x:000022CC
.text$x:000022CC ; Segment type: Pure code
.text$x:000022CC ; Segment permissions: Read/Execute
.text$x:000022CC _text$x         segment para public 'CODE' use32
.text$x:000022CC                 assume cs:_text$x
.text$x:000022CC                 ;org 22CCh
.text$x:000022CC ; COMDAT (pick associative to section at 2230)
.text$x:000022CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000022CC
.text$x:000022CC ; =============== S U B R O U T I N E =======================================
.text$x:000022CC
.text$x:000022CC
.text$x:000022CC __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:000022CC                                         ; DATA XREF: .xdata$x:00002C1Co
.text$x:000022CC                 lea     ecx, [ebp-18h]  ; this
.text$x:000022CF                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000022CF __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:000022CF
.text$x:000022D4
.text$x:000022D4 ; =============== S U B R O U T I N E =======================================
.text$x:000022D4
.text$x:000022D4
.text$x:000022D4 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:000022D4                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:000022D4
.text$x:000022D4 arg_4           = dword ptr  8
.text$x:000022D4
.text$x:000022D4                 mov     edx, [esp+arg_4]
.text$x:000022D8                 lea     eax, [edx+0Ch]
.text$x:000022DB                 mov     ecx, [edx-10h]
.text$x:000022DE                 xor     ecx, eax
.text$x:000022E0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000022E5                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:000022EA                 jmp     ___CxxFrameHandler3
.text$x:000022EA __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:000022EA
.text$x:000022EA ; ---------------------------------------------------------------------------
.text$x:000022EF                 align 10h
.text$x:000022EF _text$x         ends
.text$x:000022EF
.text$mn:000022F0 ; ===========================================================================
.text$mn:000022F0
.text$mn:000022F0 ; Segment type: Pure code
.text$mn:000022F0 ; Segment permissions: Read/Execute
.text$mn:000022F0 _text$mn        segment para public 'CODE' use32
.text$mn:000022F0                 assume cs:_text$mn
.text$mn:000022F0                 ;org 22F0h
.text$mn:000022F0 ; COMDAT (pick any)
.text$mn:000022F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000022F0
.text$mn:000022F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000022F0
.text$mn:000022F0 ; Attributes: bp-based frame
.text$mn:000022F0
.text$mn:000022F0 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:000022F0                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:000022F0 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:000022F0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:000022F0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:000022F0
.text$mn:000022F0 var_C           = dword ptr -0Ch
.text$mn:000022F0 var_8           = dword ptr -8
.text$mn:000022F0 var_2           = byte ptr -2
.text$mn:000022F0 var_1           = byte ptr -1
.text$mn:000022F0 arg_0           = byte ptr  8
.text$mn:000022F0 Size            = dword ptr  0Ch
.text$mn:000022F0
.text$mn:000022F0                 push    ebp
.text$mn:000022F1                 mov     ebp, esp
.text$mn:000022F3                 sub     esp, 0Ch
.text$mn:000022F6                 mov     [ebp+var_8], ecx
.text$mn:000022F9                 movzx   eax, [ebp+arg_0]
.text$mn:000022FD                 test    eax, eax
.text$mn:000022FF                 jnz     short loc_2303
.text$mn:00002301                 jmp     short loc_2376
.text$mn:00002303 ; ---------------------------------------------------------------------------
.text$mn:00002303
.text$mn:00002303 loc_2303:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00002303                 mov     ecx, [ebp+var_8]
.text$mn:00002306                 cmp     dword ptr [ecx+18h], 10h
.text$mn:0000230A                 jb      short loc_2376
.text$mn:0000230C                 mov     edx, [ebp+var_8]
.text$mn:0000230F                 mov     eax, [edx+4]
.text$mn:00002312                 mov     [ebp+var_C], eax
.text$mn:00002315                 mov     ecx, [ebp+var_8]
.text$mn:00002318                 add     ecx, 4
.text$mn:0000231B                 push    ecx
.text$mn:0000231C                 lea     edx, [ebp+var_1]
.text$mn:0000231F                 push    edx
.text$mn:00002320                 mov     ecx, [ebp+var_8]
.text$mn:00002323                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002328                 mov     ecx, eax
.text$mn:0000232A                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:0000232F                 cmp     [ebp+Size], 0
.text$mn:00002333                 jbe     short loc_2355
.text$mn:00002335                 mov     eax, [ebp+Size]
.text$mn:00002338                 push    eax             ; Size
.text$mn:00002339                 mov     ecx, [ebp+var_C]
.text$mn:0000233C                 push    ecx
.text$mn:0000233D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00002342                 add     esp, 4
.text$mn:00002345                 push    eax             ; Src
.text$mn:00002346                 mov     edx, [ebp+var_8]
.text$mn:00002349                 add     edx, 4
.text$mn:0000234C                 push    edx             ; Dst
.text$mn:0000234D                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00002352                 add     esp, 0Ch
.text$mn:00002355
.text$mn:00002355 loc_2355:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00002355                 mov     eax, [ebp+var_8]
.text$mn:00002358                 mov     ecx, [eax+18h]
.text$mn:0000235B                 add     ecx, 1
.text$mn:0000235E                 push    ecx             ; int
.text$mn:0000235F                 mov     edx, [ebp+var_C]
.text$mn:00002362                 push    edx             ; void *
.text$mn:00002363                 lea     eax, [ebp+var_2]
.text$mn:00002366                 push    eax
.text$mn:00002367                 mov     ecx, [ebp+var_8]
.text$mn:0000236A                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000236F                 mov     ecx, eax
.text$mn:00002371                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:00002376
.text$mn:00002376 loc_2376:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:00002376                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:00002376                 mov     ecx, [ebp+var_8]
.text$mn:00002379                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00002380                 mov     edx, [ebp+Size]
.text$mn:00002383                 push    edx
.text$mn:00002384                 mov     ecx, [ebp+var_8]
.text$mn:00002387                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000238C                 mov     esp, ebp
.text$mn:0000238E                 pop     ebp
.text$mn:0000238F                 retn    8
.text$mn:0000238F ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:0000238F
.text$mn:0000238F ; ---------------------------------------------------------------------------
.text$mn:00002392                 align 4
.text$mn:00002392 _text$mn        ends
.text$mn:00002392
.text$mn:00002394 ; ===========================================================================
.text$mn:00002394
.text$mn:00002394 ; Segment type: Pure code
.text$mn:00002394 ; Segment permissions: Read/Execute
.text$mn:00002394 _text$mn        segment para public 'CODE' use32
.text$mn:00002394                 assume cs:_text$mn
.text$mn:00002394                 ;org 2394h
.text$mn:00002394 ; COMDAT (pick any)
.text$mn:00002394                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002394
.text$mn:00002394 ; =============== S U B R O U T I N E =======================================
.text$mn:00002394
.text$mn:00002394 ; Attributes: bp-based frame
.text$mn:00002394
.text$mn:00002394 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00002394                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00002394 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00002394                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00002394
.text$mn:00002394 var_4           = dword ptr -4
.text$mn:00002394
.text$mn:00002394                 push    ebp
.text$mn:00002395                 mov     ebp, esp
.text$mn:00002397                 push    ecx
.text$mn:00002398                 mov     [ebp+var_4], ecx
.text$mn:0000239B                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:000023A0                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000023A5                 mov     esp, ebp
.text$mn:000023A7                 pop     ebp
.text$mn:000023A8                 retn
.text$mn:000023A8 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000023A8
.text$mn:000023A8 ; ---------------------------------------------------------------------------
.text$mn:000023A9                 align 4
.text$mn:000023A9 _text$mn        ends
.text$mn:000023A9
.text$mn:000023AC ; ===========================================================================
.text$mn:000023AC
.text$mn:000023AC ; Segment type: Pure code
.text$mn:000023AC ; Segment permissions: Read/Execute
.text$mn:000023AC _text$mn        segment para public 'CODE' use32
.text$mn:000023AC                 assume cs:_text$mn
.text$mn:000023AC                 ;org 23ACh
.text$mn:000023AC ; COMDAT (pick any)
.text$mn:000023AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023AC
.text$mn:000023AC ; =============== S U B R O U T I N E =======================================
.text$mn:000023AC
.text$mn:000023AC ; Attributes: bp-based frame
.text$mn:000023AC
.text$mn:000023AC ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:000023AC                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000023AC ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000023AC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:000023AC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:000023AC
.text$mn:000023AC var_4           = dword ptr -4
.text$mn:000023AC
.text$mn:000023AC                 push    ebp
.text$mn:000023AD                 mov     ebp, esp
.text$mn:000023AF                 push    ecx
.text$mn:000023B0                 mov     [ebp+var_4], ecx
.text$mn:000023B3                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:000023B8                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:000023BD                 mov     esp, ebp
.text$mn:000023BF                 pop     ebp
.text$mn:000023C0                 retn
.text$mn:000023C0 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000023C0
.text$mn:000023C0 ; ---------------------------------------------------------------------------
.text$mn:000023C1                 align 4
.text$mn:000023C1 _text$mn        ends
.text$mn:000023C1
.text$mn:000023C4 ; ===========================================================================
.text$mn:000023C4
.text$mn:000023C4 ; Segment type: Pure code
.text$mn:000023C4 ; Segment permissions: Read/Execute
.text$mn:000023C4 _text$mn        segment para public 'CODE' use32
.text$mn:000023C4                 assume cs:_text$mn
.text$mn:000023C4                 ;org 23C4h
.text$mn:000023C4 ; COMDAT (pick any)
.text$mn:000023C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023C4
.text$mn:000023C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023C4
.text$mn:000023C4 ; Attributes: bp-based frame
.text$mn:000023C4
.text$mn:000023C4 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:000023C4                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:000023C4 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:000023C4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:000023C4                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:000023C4
.text$mn:000023C4 var_4           = dword ptr -4
.text$mn:000023C4 arg_0           = dword ptr  8
.text$mn:000023C4
.text$mn:000023C4                 push    ebp
.text$mn:000023C5                 mov     ebp, esp
.text$mn:000023C7                 push    ecx
.text$mn:000023C8                 mov     [ebp+var_4], ecx
.text$mn:000023CB                 mov     eax, [ebp+arg_0]
.text$mn:000023CE                 push    eax
.text$mn:000023CF                 mov     ecx, [ebp+var_4]
.text$mn:000023D2                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:000023D7                 mov     esp, ebp
.text$mn:000023D9                 pop     ebp
.text$mn:000023DA                 retn    4
.text$mn:000023DA ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:000023DA
.text$mn:000023DA ; ---------------------------------------------------------------------------
.text$mn:000023DD                 align 10h
.text$mn:000023DD _text$mn        ends
.text$mn:000023DD
.text$mn:000023E0 ; ===========================================================================
.text$mn:000023E0
.text$mn:000023E0 ; Segment type: Pure code
.text$mn:000023E0 ; Segment permissions: Read/Execute
.text$mn:000023E0 _text$mn        segment para public 'CODE' use32
.text$mn:000023E0                 assume cs:_text$mn
.text$mn:000023E0                 ;org 23E0h
.text$mn:000023E0 ; COMDAT (pick any)
.text$mn:000023E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023E0
.text$mn:000023E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000023E0
.text$mn:000023E0 ; Attributes: bp-based frame
.text$mn:000023E0
.text$mn:000023E0 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:000023E0                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:000023E0 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:000023E0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:000023E0
.text$mn:000023E0 var_4           = dword ptr -4
.text$mn:000023E0 arg_0           = dword ptr  8
.text$mn:000023E0
.text$mn:000023E0                 push    ebp
.text$mn:000023E1                 mov     ebp, esp
.text$mn:000023E3                 push    ecx
.text$mn:000023E4                 mov     [ebp+var_4], ecx
.text$mn:000023E7                 push    0
.text$mn:000023E9                 mov     eax, [ebp+arg_0]
.text$mn:000023EC                 push    eax
.text$mn:000023ED                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:000023F2                 add     esp, 8
.text$mn:000023F5                 mov     esp, ebp
.text$mn:000023F7                 pop     ebp
.text$mn:000023F8                 retn    4
.text$mn:000023F8 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:000023F8
.text$mn:000023F8 ; ---------------------------------------------------------------------------
.text$mn:000023FB                 align 4
.text$mn:000023FB _text$mn        ends
.text$mn:000023FB
.text$mn:000023FC ; ===========================================================================
.text$mn:000023FC
.text$mn:000023FC ; Segment type: Pure code
.text$mn:000023FC ; Segment permissions: Read/Execute
.text$mn:000023FC _text$mn        segment para public 'CODE' use32
.text$mn:000023FC                 assume cs:_text$mn
.text$mn:000023FC                 ;org 23FCh
.text$mn:000023FC ; COMDAT (pick any)
.text$mn:000023FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023FC
.text$mn:000023FC ; =============== S U B R O U T I N E =======================================
.text$mn:000023FC
.text$mn:000023FC ; Attributes: bp-based frame
.text$mn:000023FC
.text$mn:000023FC ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:000023FC                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:000023FC ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:000023FC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:000023FC
.text$mn:000023FC var_4           = dword ptr -4
.text$mn:000023FC arg_0           = dword ptr  8
.text$mn:000023FC
.text$mn:000023FC                 push    ebp
.text$mn:000023FD                 mov     ebp, esp
.text$mn:000023FF                 push    ecx
.text$mn:00002400                 mov     [ebp+var_4], ecx
.text$mn:00002403                 push    0
.text$mn:00002405                 mov     eax, [ebp+arg_0]
.text$mn:00002408                 push    eax
.text$mn:00002409                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:0000240E                 add     esp, 8
.text$mn:00002411                 mov     esp, ebp
.text$mn:00002413                 pop     ebp
.text$mn:00002414                 retn    4
.text$mn:00002414 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00002414
.text$mn:00002414 ; ---------------------------------------------------------------------------
.text$mn:00002417                 align 4
.text$mn:00002417 _text$mn        ends
.text$mn:00002417
.text$mn:00002418 ; ===========================================================================
.text$mn:00002418
.text$mn:00002418 ; Segment type: Pure code
.text$mn:00002418 ; Segment permissions: Read/Execute
.text$mn:00002418 _text$mn        segment para public 'CODE' use32
.text$mn:00002418                 assume cs:_text$mn
.text$mn:00002418                 ;org 2418h
.text$mn:00002418 ; COMDAT (pick any)
.text$mn:00002418                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002418
.text$mn:00002418 ; =============== S U B R O U T I N E =======================================
.text$mn:00002418
.text$mn:00002418 ; Attributes: bp-based frame
.text$mn:00002418
.text$mn:00002418 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00002418                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00002418 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00002418                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00002418
.text$mn:00002418 Size            = dword ptr -8
.text$mn:00002418 var_4           = dword ptr -4
.text$mn:00002418 arg_0           = dword ptr  8
.text$mn:00002418 arg_4           = dword ptr  0Ch
.text$mn:00002418 arg_8           = dword ptr  10h
.text$mn:00002418
.text$mn:00002418                 push    ebp
.text$mn:00002419                 mov     ebp, esp
.text$mn:0000241B                 sub     esp, 8
.text$mn:0000241E                 mov     [ebp+var_4], ecx
.text$mn:00002421                 mov     ecx, [ebp+arg_0]
.text$mn:00002424                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00002429                 cmp     eax, [ebp+arg_4]
.text$mn:0000242C                 jnb     short loc_2436
.text$mn:0000242E                 mov     ecx, [ebp+var_4]
.text$mn:00002431                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002436
.text$mn:00002436 loc_2436:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00002436                 mov     ecx, [ebp+arg_0]
.text$mn:00002439                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000243E                 sub     eax, [ebp+arg_4]
.text$mn:00002441                 mov     [ebp+Size], eax
.text$mn:00002444                 mov     eax, [ebp+arg_8]
.text$mn:00002447                 cmp     eax, [ebp+Size]
.text$mn:0000244A                 jnb     short loc_2452
.text$mn:0000244C                 mov     ecx, [ebp+arg_8]
.text$mn:0000244F                 mov     [ebp+Size], ecx
.text$mn:00002452
.text$mn:00002452 loc_2452:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00002452                 mov     edx, [ebp+var_4]
.text$mn:00002455                 cmp     edx, [ebp+arg_0]
.text$mn:00002458                 jnz     short loc_2479
.text$mn:0000245A                 mov     eax, [ebp+arg_4]
.text$mn:0000245D                 add     eax, [ebp+Size]
.text$mn:00002460                 push    eax
.text$mn:00002461                 mov     ecx, [ebp+var_4]
.text$mn:00002464                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00002469                 mov     ecx, [ebp+arg_4]
.text$mn:0000246C                 push    ecx
.text$mn:0000246D                 push    0
.text$mn:0000246F                 mov     ecx, [ebp+var_4]
.text$mn:00002472                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00002477                 jmp     short loc_24BB
.text$mn:00002479 ; ---------------------------------------------------------------------------
.text$mn:00002479
.text$mn:00002479 loc_2479:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00002479                 push    0
.text$mn:0000247B                 mov     edx, [ebp+Size]
.text$mn:0000247E                 push    edx
.text$mn:0000247F                 mov     ecx, [ebp+var_4]
.text$mn:00002482                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00002487                 movzx   eax, al
.text$mn:0000248A                 test    eax, eax
.text$mn:0000248C                 jz      short loc_24BB
.text$mn:0000248E                 mov     ecx, [ebp+Size]
.text$mn:00002491                 push    ecx             ; Size
.text$mn:00002492                 mov     ecx, [ebp+arg_0]
.text$mn:00002495                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000249A                 add     eax, [ebp+arg_4]
.text$mn:0000249D                 push    eax             ; Src
.text$mn:0000249E                 mov     ecx, [ebp+var_4]
.text$mn:000024A1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000024A6                 push    eax             ; Dst
.text$mn:000024A7                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000024AC                 add     esp, 0Ch
.text$mn:000024AF                 mov     edx, [ebp+Size]
.text$mn:000024B2                 push    edx
.text$mn:000024B3                 mov     ecx, [ebp+var_4]
.text$mn:000024B6                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000024BB
.text$mn:000024BB loc_24BB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:000024BB                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:000024BB                 mov     eax, [ebp+var_4]
.text$mn:000024BE                 mov     esp, ebp
.text$mn:000024C0                 pop     ebp
.text$mn:000024C1                 retn    0Ch
.text$mn:000024C1 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:000024C1
.text$mn:000024C1 _text$mn        ends
.text$mn:000024C1
.text$mn:000024C4 ; ===========================================================================
.text$mn:000024C4
.text$mn:000024C4 ; Segment type: Pure code
.text$mn:000024C4 ; Segment permissions: Read/Execute
.text$mn:000024C4 _text$mn        segment para public 'CODE' use32
.text$mn:000024C4                 assume cs:_text$mn
.text$mn:000024C4                 ;org 24C4h
.text$mn:000024C4 ; COMDAT (pick any)
.text$mn:000024C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000024C4
.text$mn:000024C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000024C4
.text$mn:000024C4 ; Attributes: bp-based frame
.text$mn:000024C4
.text$mn:000024C4 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:000024C4                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:000024C4 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:000024C4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:000024C4
.text$mn:000024C4 var_4           = dword ptr -4
.text$mn:000024C4 Str             = dword ptr  8
.text$mn:000024C4
.text$mn:000024C4                 push    ebp
.text$mn:000024C5                 mov     ebp, esp
.text$mn:000024C7                 push    ecx
.text$mn:000024C8                 mov     [ebp+var_4], ecx
.text$mn:000024CB                 push    490h            ; unsigned int
.text$mn:000024D0                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000024D5                 mov     eax, [ebp+Str]
.text$mn:000024D8                 push    eax             ; int
.text$mn:000024D9                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:000024DE                 add     esp, 0Ch
.text$mn:000024E1                 mov     ecx, [ebp+Str]
.text$mn:000024E4                 push    ecx             ; Str
.text$mn:000024E5                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:000024EA                 add     esp, 4
.text$mn:000024ED                 push    eax             ; Size
.text$mn:000024EE                 mov     edx, [ebp+Str]
.text$mn:000024F1                 push    edx             ; Src
.text$mn:000024F2                 mov     ecx, [ebp+var_4]
.text$mn:000024F5                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:000024FA                 mov     esp, ebp
.text$mn:000024FC                 pop     ebp
.text$mn:000024FD                 retn    4
.text$mn:000024FD ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:000024FD
.text$mn:000024FD _text$mn        ends
.text$mn:000024FD
.text$mn:00002500 ; ===========================================================================
.text$mn:00002500
.text$mn:00002500 ; Segment type: Pure code
.text$mn:00002500 ; Segment permissions: Read/Execute
.text$mn:00002500 _text$mn        segment para public 'CODE' use32
.text$mn:00002500                 assume cs:_text$mn
.text$mn:00002500                 ;org 2500h
.text$mn:00002500 ; COMDAT (pick any)
.text$mn:00002500                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002500
.text$mn:00002500 ; =============== S U B R O U T I N E =======================================
.text$mn:00002500
.text$mn:00002500 ; Attributes: bp-based frame
.text$mn:00002500
.text$mn:00002500 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00002500                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00002500 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00002500                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00002500
.text$mn:00002500 var_4           = dword ptr -4
.text$mn:00002500 Src             = dword ptr  8
.text$mn:00002500 Size            = dword ptr  0Ch
.text$mn:00002500
.text$mn:00002500                 push    ebp
.text$mn:00002501                 mov     ebp, esp
.text$mn:00002503                 push    ecx
.text$mn:00002504                 mov     [ebp+var_4], ecx
.text$mn:00002507                 cmp     [ebp+Size], 0
.text$mn:0000250B                 jz      short loc_2523
.text$mn:0000250D                 push    47Fh            ; unsigned int
.text$mn:00002512                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002517                 mov     eax, [ebp+Src]
.text$mn:0000251A                 push    eax             ; int
.text$mn:0000251B                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00002520                 add     esp, 0Ch
.text$mn:00002523
.text$mn:00002523 loc_2523:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00002523                 mov     ecx, [ebp+Src]
.text$mn:00002526                 push    ecx
.text$mn:00002527                 mov     ecx, [ebp+var_4]
.text$mn:0000252A                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:0000252F                 movzx   edx, al
.text$mn:00002532                 test    edx, edx
.text$mn:00002534                 jz      short loc_2556
.text$mn:00002536                 mov     eax, [ebp+Size]
.text$mn:00002539                 push    eax
.text$mn:0000253A                 mov     ecx, [ebp+var_4]
.text$mn:0000253D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002542                 mov     ecx, [ebp+Src]
.text$mn:00002545                 sub     ecx, eax
.text$mn:00002547                 push    ecx
.text$mn:00002548                 mov     edx, [ebp+var_4]
.text$mn:0000254B                 push    edx
.text$mn:0000254C                 mov     ecx, [ebp+var_4]
.text$mn:0000254F                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00002554                 jmp     short loc_2593
.text$mn:00002556 ; ---------------------------------------------------------------------------
.text$mn:00002556
.text$mn:00002556 loc_2556:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00002556                 push    0
.text$mn:00002558                 mov     eax, [ebp+Size]
.text$mn:0000255B                 push    eax
.text$mn:0000255C                 mov     ecx, [ebp+var_4]
.text$mn:0000255F                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00002564                 movzx   ecx, al
.text$mn:00002567                 test    ecx, ecx
.text$mn:00002569                 jz      short loc_2590
.text$mn:0000256B                 mov     edx, [ebp+Size]
.text$mn:0000256E                 push    edx             ; Size
.text$mn:0000256F                 mov     eax, [ebp+Src]
.text$mn:00002572                 push    eax             ; Src
.text$mn:00002573                 mov     ecx, [ebp+var_4]
.text$mn:00002576                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000257B                 push    eax             ; Dst
.text$mn:0000257C                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00002581                 add     esp, 0Ch
.text$mn:00002584                 mov     ecx, [ebp+Size]
.text$mn:00002587                 push    ecx
.text$mn:00002588                 mov     ecx, [ebp+var_4]
.text$mn:0000258B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002590
.text$mn:00002590 loc_2590:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00002590                 mov     eax, [ebp+var_4]
.text$mn:00002593
.text$mn:00002593 loc_2593:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:00002593                 mov     esp, ebp
.text$mn:00002595                 pop     ebp
.text$mn:00002596                 retn    8
.text$mn:00002596 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00002596
.text$mn:00002596 ; ---------------------------------------------------------------------------
.text$mn:00002599                 align 4
.text$mn:00002599 _text$mn        ends
.text$mn:00002599
.text$mn:0000259C ; ===========================================================================
.text$mn:0000259C
.text$mn:0000259C ; Segment type: Pure code
.text$mn:0000259C ; Segment permissions: Read/Execute
.text$mn:0000259C _text$mn        segment para public 'CODE' use32
.text$mn:0000259C                 assume cs:_text$mn
.text$mn:0000259C                 ;org 259Ch
.text$mn:0000259C ; COMDAT (pick any)
.text$mn:0000259C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000259C
.text$mn:0000259C ; =============== S U B R O U T I N E =======================================
.text$mn:0000259C
.text$mn:0000259C ; Attributes: bp-based frame
.text$mn:0000259C
.text$mn:0000259C ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:0000259C                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:0000259C ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:0000259C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:0000259C
.text$mn:0000259C arg_0           = dword ptr  8
.text$mn:0000259C arg_4           = dword ptr  0Ch
.text$mn:0000259C
.text$mn:0000259C                 push    ebp
.text$mn:0000259D                 mov     ebp, esp
.text$mn:0000259F                 mov     eax, [ebp+arg_0]
.text$mn:000025A2                 mov     ecx, [ebp+arg_4]
.text$mn:000025A5                 mov     dl, [ecx]
.text$mn:000025A7                 mov     [eax], dl
.text$mn:000025A9                 pop     ebp
.text$mn:000025AA                 retn
.text$mn:000025AA ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:000025AA
.text$mn:000025AA ; ---------------------------------------------------------------------------
.text$mn:000025AB                 align 4
.text$mn:000025AB _text$mn        ends
.text$mn:000025AB
.text$mn:000025AC ; ===========================================================================
.text$mn:000025AC
.text$mn:000025AC ; Segment type: Pure code
.text$mn:000025AC ; Segment permissions: Read/Execute
.text$mn:000025AC _text$mn        segment para public 'CODE' use32
.text$mn:000025AC                 assume cs:_text$mn
.text$mn:000025AC                 ;org 25ACh
.text$mn:000025AC ; COMDAT (pick any)
.text$mn:000025AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000025AC
.text$mn:000025AC ; =============== S U B R O U T I N E =======================================
.text$mn:000025AC
.text$mn:000025AC ; Attributes: bp-based frame
.text$mn:000025AC
.text$mn:000025AC ; bool __thiscall Utf8_Iter::canGet(Utf8_Iter *__hidden this)
.text$mn:000025AC                 public ?canGet@Utf8_Iter@@QBE_NXZ
.text$mn:000025AC ?canGet@Utf8_Iter@@QBE_NXZ proc near    ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint)+171p
.text$mn:000025AC                                         ; Utf8_16_Write::convert(char *,uint)+1AAp
.text$mn:000025AC
.text$mn:000025AC var_8           = dword ptr -8
.text$mn:000025AC var_4           = dword ptr -4
.text$mn:000025AC
.text$mn:000025AC                 push    ebp
.text$mn:000025AD                 mov     ebp, esp
.text$mn:000025AF                 sub     esp, 8
.text$mn:000025B2                 mov     [ebp+var_8], ecx
.text$mn:000025B5                 mov     eax, [ebp+var_8]
.text$mn:000025B8                 cmp     dword ptr [eax+4], 0
.text$mn:000025BC                 jnz     short loc_25C7
.text$mn:000025BE                 mov     [ebp+var_4], 1
.text$mn:000025C5                 jmp     short loc_25CE
.text$mn:000025C7 ; ---------------------------------------------------------------------------
.text$mn:000025C7
.text$mn:000025C7 loc_25C7:                               ; CODE XREF: Utf8_Iter::canGet(void)+10j
.text$mn:000025C7                 mov     [ebp+var_4], 0
.text$mn:000025CE
.text$mn:000025CE loc_25CE:                               ; CODE XREF: Utf8_Iter::canGet(void)+19j
.text$mn:000025CE                 mov     al, byte ptr [ebp+var_4]
.text$mn:000025D1                 mov     esp, ebp
.text$mn:000025D3                 pop     ebp
.text$mn:000025D4                 retn
.text$mn:000025D4 ?canGet@Utf8_Iter@@QBE_NXZ endp
.text$mn:000025D4
.text$mn:000025D4 ; ---------------------------------------------------------------------------
.text$mn:000025D5                 align 4
.text$mn:000025D5 _text$mn        ends
.text$mn:000025D5
.text$mn:000025D8 ; ===========================================================================
.text$mn:000025D8
.text$mn:000025D8 ; Segment type: Pure code
.text$mn:000025D8 ; Segment permissions: Read/Execute
.text$mn:000025D8 _text$mn        segment para public 'CODE' use32
.text$mn:000025D8                 assume cs:_text$mn
.text$mn:000025D8                 ;org 25D8h
.text$mn:000025D8 ; COMDAT (pick any)
.text$mn:000025D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000025D8
.text$mn:000025D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000025D8
.text$mn:000025D8 ; Attributes: bp-based frame
.text$mn:000025D8
.text$mn:000025D8 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:000025D8                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:000025D8 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000025D8                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:000025D8
.text$mn:000025D8 var_4           = dword ptr -4
.text$mn:000025D8
.text$mn:000025D8                 push    ebp
.text$mn:000025D9                 mov     ebp, esp
.text$mn:000025DB                 push    ecx
.text$mn:000025DC                 mov     [ebp+var_4], ecx
.text$mn:000025DF                 mov     eax, [ebp+var_4]
.text$mn:000025E2                 mov     eax, [eax+4]
.text$mn:000025E5                 mov     esp, ebp
.text$mn:000025E7                 pop     ebp
.text$mn:000025E8                 retn
.text$mn:000025E8 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:000025E8
.text$mn:000025E8 ; ---------------------------------------------------------------------------
.text$mn:000025E9                 align 4
.text$mn:000025E9 _text$mn        ends
.text$mn:000025E9
.text$mn:000025EC ; ===========================================================================
.text$mn:000025EC
.text$mn:000025EC ; Segment type: Pure code
.text$mn:000025EC ; Segment permissions: Read/Execute
.text$mn:000025EC _text$mn        segment para public 'CODE' use32
.text$mn:000025EC                 assume cs:_text$mn
.text$mn:000025EC                 ;org 25ECh
.text$mn:000025EC ; COMDAT (pick any)
.text$mn:000025EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000025EC
.text$mn:000025EC ; =============== S U B R O U T I N E =======================================
.text$mn:000025EC
.text$mn:000025EC ; Attributes: bp-based frame
.text$mn:000025EC
.text$mn:000025EC ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:000025EC                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:000025EC ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000025EC                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:000025EC                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:000025EC
.text$mn:000025EC var_4           = dword ptr -4
.text$mn:000025EC
.text$mn:000025EC                 push    ebp
.text$mn:000025ED                 mov     ebp, esp
.text$mn:000025EF                 push    ecx
.text$mn:000025F0                 mov     [ebp+var_4], ecx
.text$mn:000025F3                 mov     eax, [ebp+var_4]
.text$mn:000025F6                 mov     eax, [eax+4]
.text$mn:000025F9                 mov     esp, ebp
.text$mn:000025FB                 pop     ebp
.text$mn:000025FC                 retn
.text$mn:000025FC ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:000025FC
.text$mn:000025FC ; ---------------------------------------------------------------------------
.text$mn:000025FD                 align 10h
.text$mn:000025FD _text$mn        ends
.text$mn:000025FD
.text$mn:00002600 ; ===========================================================================
.text$mn:00002600
.text$mn:00002600 ; Segment type: Pure code
.text$mn:00002600 ; Segment permissions: Read/Execute
.text$mn:00002600 _text$mn        segment para public 'CODE' use32
.text$mn:00002600                 assume cs:_text$mn
.text$mn:00002600                 ;org 2600h
.text$mn:00002600 ; COMDAT (pick any)
.text$mn:00002600                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002600
.text$mn:00002600 ; =============== S U B R O U T I N E =======================================
.text$mn:00002600
.text$mn:00002600 ; Attributes: bp-based frame
.text$mn:00002600
.text$mn:00002600 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00002600                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00002600 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00002600                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00002600
.text$mn:00002600 var_4           = dword ptr -4
.text$mn:00002600 Dst             = dword ptr  8
.text$mn:00002600 Src             = dword ptr  0Ch
.text$mn:00002600 Size            = dword ptr  10h
.text$mn:00002600
.text$mn:00002600                 push    ebp
.text$mn:00002601                 mov     ebp, esp
.text$mn:00002603                 push    ecx
.text$mn:00002604                 cmp     [ebp+Size], 0
.text$mn:00002608                 jnz     short loc_2612
.text$mn:0000260A                 mov     eax, [ebp+Dst]
.text$mn:0000260D                 mov     [ebp+var_4], eax
.text$mn:00002610                 jmp     short loc_2629
.text$mn:00002612 ; ---------------------------------------------------------------------------
.text$mn:00002612
.text$mn:00002612 loc_2612:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00002612                 mov     ecx, [ebp+Size]
.text$mn:00002615                 push    ecx             ; Size
.text$mn:00002616                 mov     edx, [ebp+Src]
.text$mn:00002619                 push    edx             ; Src
.text$mn:0000261A                 mov     eax, [ebp+Dst]
.text$mn:0000261D                 push    eax             ; Dst
.text$mn:0000261E                 call    _memcpy
.text$mn:00002623                 add     esp, 0Ch
.text$mn:00002626                 mov     [ebp+var_4], eax
.text$mn:00002629
.text$mn:00002629 loc_2629:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00002629                 mov     eax, [ebp+var_4]
.text$mn:0000262C                 mov     esp, ebp
.text$mn:0000262E                 pop     ebp
.text$mn:0000262F                 retn
.text$mn:0000262F ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000262F
.text$mn:0000262F _text$mn        ends
.text$mn:0000262F
.text$mn:00002630 ; ===========================================================================
.text$mn:00002630
.text$mn:00002630 ; Segment type: Pure code
.text$mn:00002630 ; Segment permissions: Read/Execute
.text$mn:00002630 _text$mn        segment para public 'CODE' use32
.text$mn:00002630                 assume cs:_text$mn
.text$mn:00002630                 ;org 2630h
.text$mn:00002630 ; COMDAT (pick any)
.text$mn:00002630                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002630
.text$mn:00002630 ; =============== S U B R O U T I N E =======================================
.text$mn:00002630
.text$mn:00002630 ; Attributes: bp-based frame
.text$mn:00002630
.text$mn:00002630 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00002630                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00002630 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00002630                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00002630
.text$mn:00002630 var_4           = dword ptr -4
.text$mn:00002630 arg_0           = dword ptr  8
.text$mn:00002630 arg_4           = dword ptr  0Ch
.text$mn:00002630
.text$mn:00002630                 push    ebp
.text$mn:00002631                 mov     ebp, esp
.text$mn:00002633                 push    ecx
.text$mn:00002634                 mov     [ebp+var_4], ecx
.text$mn:00002637                 mov     eax, [ebp+arg_4]
.text$mn:0000263A                 push    eax             ; int
.text$mn:0000263B                 mov     ecx, [ebp+arg_0]
.text$mn:0000263E                 push    ecx             ; void *
.text$mn:0000263F                 mov     ecx, [ebp+var_4]
.text$mn:00002642                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00002647                 mov     esp, ebp
.text$mn:00002649                 pop     ebp
.text$mn:0000264A                 retn    8
.text$mn:0000264A ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:0000264A
.text$mn:0000264A ; ---------------------------------------------------------------------------
.text$mn:0000264D                 align 10h
.text$mn:0000264D _text$mn        ends
.text$mn:0000264D
.text$mn:00002650 ; ===========================================================================
.text$mn:00002650
.text$mn:00002650 ; Segment type: Pure code
.text$mn:00002650 ; Segment permissions: Read/Execute
.text$mn:00002650 _text$mn        segment para public 'CODE' use32
.text$mn:00002650                 assume cs:_text$mn
.text$mn:00002650                 ;org 2650h
.text$mn:00002650 ; COMDAT (pick any)
.text$mn:00002650                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002650
.text$mn:00002650 ; =============== S U B R O U T I N E =======================================
.text$mn:00002650
.text$mn:00002650 ; Attributes: bp-based frame
.text$mn:00002650
.text$mn:00002650 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00002650                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00002650 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00002650                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00002650
.text$mn:00002650 var_4           = dword ptr -4
.text$mn:00002650 arg_0           = dword ptr  8
.text$mn:00002650
.text$mn:00002650                 push    ebp
.text$mn:00002651                 mov     ebp, esp
.text$mn:00002653                 push    ecx
.text$mn:00002654                 mov     [ebp+var_4], ecx
.text$mn:00002657                 mov     eax, [ebp+arg_0]
.text$mn:0000265A                 push    eax             ; void *
.text$mn:0000265B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002660                 add     esp, 4
.text$mn:00002663                 mov     esp, ebp
.text$mn:00002665                 pop     ebp
.text$mn:00002666                 retn    8
.text$mn:00002666 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:00002666
.text$mn:00002666 ; ---------------------------------------------------------------------------
.text$mn:00002669                 align 4
.text$mn:00002669 _text$mn        ends
.text$mn:00002669
.text$mn:0000266C ; ===========================================================================
.text$mn:0000266C
.text$mn:0000266C ; Segment type: Pure code
.text$mn:0000266C ; Segment permissions: Read/Execute
.text$mn:0000266C _text$mn        segment para public 'CODE' use32
.text$mn:0000266C                 assume cs:_text$mn
.text$mn:0000266C                 ;org 266Ch
.text$mn:0000266C ; COMDAT (pick any)
.text$mn:0000266C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000266C
.text$mn:0000266C ; =============== S U B R O U T I N E =======================================
.text$mn:0000266C
.text$mn:0000266C ; Attributes: bp-based frame
.text$mn:0000266C
.text$mn:0000266C ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:0000266C                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:0000266C ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:0000266C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:0000266C
.text$mn:0000266C var_4           = dword ptr -4
.text$mn:0000266C arg_0           = dword ptr  8
.text$mn:0000266C
.text$mn:0000266C                 push    ebp
.text$mn:0000266D                 mov     ebp, esp
.text$mn:0000266F                 push    ecx
.text$mn:00002670                 mov     [ebp+var_4], ecx
.text$mn:00002673                 mov     eax, [ebp+arg_0]
.text$mn:00002676                 push    eax             ; void *
.text$mn:00002677                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000267C                 add     esp, 4
.text$mn:0000267F                 mov     esp, ebp
.text$mn:00002681                 pop     ebp
.text$mn:00002682                 retn    8
.text$mn:00002682 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00002682
.text$mn:00002682 ; ---------------------------------------------------------------------------
.text$mn:00002685                 align 4
.text$mn:00002685 _text$mn        ends
.text$mn:00002685
.text$mn:00002688 ; ===========================================================================
.text$mn:00002688
.text$mn:00002688 ; Segment type: Pure code
.text$mn:00002688 ; Segment permissions: Read/Execute
.text$mn:00002688 _text$mn        segment para public 'CODE' use32
.text$mn:00002688                 assume cs:_text$mn
.text$mn:00002688                 ;org 2688h
.text$mn:00002688 ; COMDAT (pick any)
.text$mn:00002688                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002688
.text$mn:00002688 ; =============== S U B R O U T I N E =======================================
.text$mn:00002688
.text$mn:00002688 ; Attributes: bp-based frame
.text$mn:00002688
.text$mn:00002688 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00002688                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00002688 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00002688                                         ; DATA XREF: .rdata:00003060o
.text$mn:00002688
.text$mn:00002688 var_4           = dword ptr -4
.text$mn:00002688 arg_0           = dword ptr  8
.text$mn:00002688 arg_4           = dword ptr  0Ch
.text$mn:00002688
.text$mn:00002688                 push    ebp
.text$mn:00002689                 mov     ebp, esp
.text$mn:0000268B                 push    ecx
.text$mn:0000268C                 mov     [ebp+var_4], ecx
.text$mn:0000268F                 mov     eax, [ebp+arg_4]
.text$mn:00002692                 push    eax             ; int
.text$mn:00002693                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00002698                 add     esp, 4
.text$mn:0000269B                 test    eax, eax
.text$mn:0000269D                 jz      short loc_26B8
.text$mn:0000269F                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:000026A4                 push    eax             ; struct std::error_category *
.text$mn:000026A5                 mov     ecx, [ebp+arg_4]
.text$mn:000026A8                 push    ecx             ; int
.text$mn:000026A9                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000026AC                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000026B1                 mov     eax, [ebp+arg_0]
.text$mn:000026B4                 jmp     short loc_26CD
.text$mn:000026B6 ; ---------------------------------------------------------------------------
.text$mn:000026B6                 jmp     short loc_26CD
.text$mn:000026B8 ; ---------------------------------------------------------------------------
.text$mn:000026B8
.text$mn:000026B8 loc_26B8:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:000026B8                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:000026BD                 push    eax             ; struct std::error_category *
.text$mn:000026BE                 mov     edx, [ebp+arg_4]
.text$mn:000026C1                 push    edx             ; int
.text$mn:000026C2                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000026C5                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000026CA                 mov     eax, [ebp+arg_0]
.text$mn:000026CD
.text$mn:000026CD loc_26CD:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:000026CD                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:000026CD                 mov     esp, ebp
.text$mn:000026CF                 pop     ebp
.text$mn:000026D0                 retn    8
.text$mn:000026D0 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000026D0
.text$mn:000026D0 ; ---------------------------------------------------------------------------
.text$mn:000026D3                 align 4
.text$mn:000026D3 _text$mn        ends
.text$mn:000026D3
.text$mn:000026D4 ; ===========================================================================
.text$mn:000026D4
.text$mn:000026D4 ; Segment type: Pure code
.text$mn:000026D4 ; Segment permissions: Read/Execute
.text$mn:000026D4 _text$mn        segment para public 'CODE' use32
.text$mn:000026D4                 assume cs:_text$mn
.text$mn:000026D4                 ;org 26D4h
.text$mn:000026D4 ; COMDAT (pick any)
.text$mn:000026D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000026D4
.text$mn:000026D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000026D4
.text$mn:000026D4 ; Attributes: bp-based frame
.text$mn:000026D4
.text$mn:000026D4 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:000026D4                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:000026D4 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:000026D4                                         ; DATA XREF: .rdata:00002FD0o
.text$mn:000026D4                                         ; .rdata:00002FECo ...
.text$mn:000026D4
.text$mn:000026D4 var_4           = dword ptr -4
.text$mn:000026D4 arg_0           = dword ptr  8
.text$mn:000026D4 arg_4           = dword ptr  0Ch
.text$mn:000026D4
.text$mn:000026D4                 push    ebp
.text$mn:000026D5                 mov     ebp, esp
.text$mn:000026D7                 push    ecx
.text$mn:000026D8                 mov     [ebp+var_4], ecx
.text$mn:000026DB                 mov     eax, [ebp+var_4]
.text$mn:000026DE                 push    eax             ; struct std::error_category *
.text$mn:000026DF                 mov     ecx, [ebp+arg_4]
.text$mn:000026E2                 push    ecx             ; int
.text$mn:000026E3                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000026E6                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000026EB                 mov     eax, [ebp+arg_0]
.text$mn:000026EE                 mov     esp, ebp
.text$mn:000026F0                 pop     ebp
.text$mn:000026F1                 retn    8
.text$mn:000026F1 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000026F1
.text$mn:000026F1 _text$mn        ends
.text$mn:000026F1
.text$mn:000026F4 ; ===========================================================================
.text$mn:000026F4
.text$mn:000026F4 ; Segment type: Pure code
.text$mn:000026F4 ; Segment permissions: Read/Execute
.text$mn:000026F4 _text$mn        segment para public 'CODE' use32
.text$mn:000026F4                 assume cs:_text$mn
.text$mn:000026F4                 ;org 26F4h
.text$mn:000026F4 ; COMDAT (pick any)
.text$mn:000026F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000026F4
.text$mn:000026F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000026F4
.text$mn:000026F4 ; Attributes: bp-based frame
.text$mn:000026F4
.text$mn:000026F4 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:000026F4                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:000026F4 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:000026F4                                         ; DATA XREF: .rdata:00002FD4o
.text$mn:000026F4                                         ; .rdata:00002FF0o ...
.text$mn:000026F4
.text$mn:000026F4 var_8           = dword ptr -8
.text$mn:000026F4 var_4           = dword ptr -4
.text$mn:000026F4 arg_0           = dword ptr  8
.text$mn:000026F4 arg_4           = dword ptr  0Ch
.text$mn:000026F4
.text$mn:000026F4                 push    ebp
.text$mn:000026F5                 mov     ebp, esp
.text$mn:000026F7                 sub     esp, 8
.text$mn:000026FA                 mov     [ebp+var_8], ecx
.text$mn:000026FD                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002700                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00002705                 push    eax
.text$mn:00002706                 mov     ecx, [ebp+var_8]
.text$mn:00002709                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000270E                 movzx   eax, al
.text$mn:00002711                 test    eax, eax
.text$mn:00002713                 jz      short loc_272B
.text$mn:00002715                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002718                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:0000271D                 cmp     eax, [ebp+arg_4]
.text$mn:00002720                 jnz     short loc_272B
.text$mn:00002722                 mov     [ebp+var_4], 1
.text$mn:00002729                 jmp     short loc_2732
.text$mn:0000272B ; ---------------------------------------------------------------------------
.text$mn:0000272B
.text$mn:0000272B loc_272B:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:0000272B                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:0000272B                 mov     [ebp+var_4], 0
.text$mn:00002732
.text$mn:00002732 loc_2732:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00002732                 mov     al, byte ptr [ebp+var_4]
.text$mn:00002735                 mov     esp, ebp
.text$mn:00002737                 pop     ebp
.text$mn:00002738                 retn    8
.text$mn:00002738 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00002738
.text$mn:00002738 ; ---------------------------------------------------------------------------
.text$mn:0000273B                 align 4
.text$mn:0000273B _text$mn        ends
.text$mn:0000273B
.text$mn:0000273C ; ===========================================================================
.text$mn:0000273C
.text$mn:0000273C ; Segment type: Pure code
.text$mn:0000273C ; Segment permissions: Read/Execute
.text$mn:0000273C _text$mn        segment para public 'CODE' use32
.text$mn:0000273C                 assume cs:_text$mn
.text$mn:0000273C                 ;org 273Ch
.text$mn:0000273C ; COMDAT (pick any)
.text$mn:0000273C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000273C
.text$mn:0000273C ; =============== S U B R O U T I N E =======================================
.text$mn:0000273C
.text$mn:0000273C ; Attributes: bp-based frame
.text$mn:0000273C
.text$mn:0000273C ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:0000273C                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:0000273C ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:0000273C                                         ; DATA XREF: .rdata:00002FD8o
.text$mn:0000273C                                         ; .rdata:00002FF4o ...
.text$mn:0000273C
.text$mn:0000273C var_C           = byte ptr -0Ch
.text$mn:0000273C var_4           = dword ptr -4
.text$mn:0000273C arg_0           = dword ptr  8
.text$mn:0000273C arg_4           = dword ptr  0Ch
.text$mn:0000273C
.text$mn:0000273C                 push    ebp
.text$mn:0000273D                 mov     ebp, esp
.text$mn:0000273F                 sub     esp, 0Ch
.text$mn:00002742                 mov     [ebp+var_4], ecx
.text$mn:00002745                 mov     eax, [ebp+arg_4]
.text$mn:00002748                 push    eax             ; std::error_condition *
.text$mn:00002749                 mov     ecx, [ebp+arg_0]
.text$mn:0000274C                 push    ecx
.text$mn:0000274D                 lea     edx, [ebp+var_C]
.text$mn:00002750                 push    edx
.text$mn:00002751                 mov     eax, [ebp+var_4]
.text$mn:00002754                 mov     edx, [eax]
.text$mn:00002756                 mov     ecx, [ebp+var_4]
.text$mn:00002759                 mov     eax, [edx+0Ch]
.text$mn:0000275C                 call    eax
.text$mn:0000275E                 mov     ecx, eax
.text$mn:00002760                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00002765                 mov     esp, ebp
.text$mn:00002767                 pop     ebp
.text$mn:00002768                 retn    8
.text$mn:00002768 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00002768
.text$mn:00002768 ; ---------------------------------------------------------------------------
.text$mn:0000276B                 align 4
.text$mn:0000276B _text$mn        ends
.text$mn:0000276B
.text$mn:0000276C ; ===========================================================================
.text$mn:0000276C
.text$mn:0000276C ; Segment type: Pure code
.text$mn:0000276C ; Segment permissions: Read/Execute
.text$mn:0000276C _text$mn        segment para public 'CODE' use32
.text$mn:0000276C                 assume cs:_text$mn
.text$mn:0000276C                 ;org 276Ch
.text$mn:0000276C ; COMDAT (pick any)
.text$mn:0000276C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000276C
.text$mn:0000276C ; =============== S U B R O U T I N E =======================================
.text$mn:0000276C
.text$mn:0000276C ; Attributes: bp-based frame
.text$mn:0000276C
.text$mn:0000276C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:0000276C                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:0000276C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:0000276C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:0000276C
.text$mn:0000276C var_4           = dword ptr -4
.text$mn:0000276C arg_0           = dword ptr  8
.text$mn:0000276C
.text$mn:0000276C                 push    ebp
.text$mn:0000276D                 mov     ebp, esp
.text$mn:0000276F                 push    ecx
.text$mn:00002770                 mov     [ebp+var_4], ecx
.text$mn:00002773                 mov     eax, [ebp+var_4]
.text$mn:00002776                 mov     ecx, [eax+14h]
.text$mn:00002779                 cmp     ecx, [ebp+arg_0]
.text$mn:0000277C                 jnb     short loc_2786
.text$mn:0000277E                 mov     ecx, [ebp+var_4]
.text$mn:00002781                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002786
.text$mn:00002786 loc_2786:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00002786                 mov     edx, [ebp+arg_0]
.text$mn:00002789                 push    edx
.text$mn:0000278A                 mov     ecx, [ebp+var_4]
.text$mn:0000278D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002792                 mov     eax, [ebp+var_4]
.text$mn:00002795                 mov     esp, ebp
.text$mn:00002797                 pop     ebp
.text$mn:00002798                 retn    4
.text$mn:00002798 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00002798
.text$mn:00002798 ; ---------------------------------------------------------------------------
.text$mn:0000279B                 align 4
.text$mn:0000279B _text$mn        ends
.text$mn:0000279B
.text$mn:0000279C ; ===========================================================================
.text$mn:0000279C
.text$mn:0000279C ; Segment type: Pure code
.text$mn:0000279C ; Segment permissions: Read/Execute
.text$mn:0000279C _text$mn        segment para public 'CODE' use32
.text$mn:0000279C                 assume cs:_text$mn
.text$mn:0000279C                 ;org 279Ch
.text$mn:0000279C ; COMDAT (pick any)
.text$mn:0000279C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000279C
.text$mn:0000279C ; =============== S U B R O U T I N E =======================================
.text$mn:0000279C
.text$mn:0000279C ; Attributes: bp-based frame
.text$mn:0000279C
.text$mn:0000279C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:0000279C                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:0000279C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:0000279C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:0000279C
.text$mn:0000279C var_C           = dword ptr -0Ch
.text$mn:0000279C Dst             = dword ptr -8
.text$mn:0000279C var_4           = dword ptr -4
.text$mn:0000279C arg_0           = dword ptr  8
.text$mn:0000279C arg_4           = dword ptr  0Ch
.text$mn:0000279C
.text$mn:0000279C                 push    ebp
.text$mn:0000279D                 mov     ebp, esp
.text$mn:0000279F                 sub     esp, 0Ch
.text$mn:000027A2                 mov     [ebp+var_4], ecx
.text$mn:000027A5                 mov     eax, [ebp+var_4]
.text$mn:000027A8                 mov     ecx, [eax+14h]
.text$mn:000027AB                 cmp     ecx, [ebp+arg_0]
.text$mn:000027AE                 jnb     short loc_27B8
.text$mn:000027B0                 mov     ecx, [ebp+var_4]
.text$mn:000027B3                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000027B8
.text$mn:000027B8 loc_27B8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:000027B8                 mov     edx, [ebp+var_4]
.text$mn:000027BB                 mov     eax, [edx+14h]
.text$mn:000027BE                 sub     eax, [ebp+arg_0]
.text$mn:000027C1                 cmp     eax, [ebp+arg_4]
.text$mn:000027C4                 ja      short loc_27D4
.text$mn:000027C6                 mov     ecx, [ebp+arg_0]
.text$mn:000027C9                 push    ecx
.text$mn:000027CA                 mov     ecx, [ebp+var_4]
.text$mn:000027CD                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000027D2                 jmp     short loc_281A
.text$mn:000027D4 ; ---------------------------------------------------------------------------
.text$mn:000027D4
.text$mn:000027D4 loc_27D4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:000027D4                 cmp     [ebp+arg_4], 0
.text$mn:000027D8                 jbe     short loc_281A
.text$mn:000027DA                 mov     ecx, [ebp+var_4]
.text$mn:000027DD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000027E2                 add     eax, [ebp+arg_0]
.text$mn:000027E5                 mov     [ebp+Dst], eax
.text$mn:000027E8                 mov     edx, [ebp+var_4]
.text$mn:000027EB                 mov     eax, [edx+14h]
.text$mn:000027EE                 sub     eax, [ebp+arg_4]
.text$mn:000027F1                 mov     [ebp+var_C], eax
.text$mn:000027F4                 mov     ecx, [ebp+var_C]
.text$mn:000027F7                 sub     ecx, [ebp+arg_0]
.text$mn:000027FA                 push    ecx             ; Size
.text$mn:000027FB                 mov     edx, [ebp+Dst]
.text$mn:000027FE                 add     edx, [ebp+arg_4]
.text$mn:00002801                 push    edx             ; Src
.text$mn:00002802                 mov     eax, [ebp+Dst]
.text$mn:00002805                 push    eax             ; Dst
.text$mn:00002806                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:0000280B                 add     esp, 0Ch
.text$mn:0000280E                 mov     ecx, [ebp+var_C]
.text$mn:00002811                 push    ecx
.text$mn:00002812                 mov     ecx, [ebp+var_4]
.text$mn:00002815                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000281A
.text$mn:0000281A loc_281A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:0000281A                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:0000281A                 mov     eax, [ebp+var_4]
.text$mn:0000281D                 mov     esp, ebp
.text$mn:0000281F                 pop     ebp
.text$mn:00002820                 retn    8
.text$mn:00002820 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00002820
.text$mn:00002820 ; ---------------------------------------------------------------------------
.text$mn:00002823                 align 4
.text$mn:00002823 _text$mn        ends
.text$mn:00002823
.text$mn:00002824 ; ===========================================================================
.text$mn:00002824
.text$mn:00002824 ; Segment type: Pure code
.text$mn:00002824 ; Segment permissions: Read/Execute
.text$mn:00002824 _text$mn        segment para public 'CODE' use32
.text$mn:00002824                 assume cs:_text$mn
.text$mn:00002824                 ;org 2824h
.text$mn:00002824 ; COMDAT (pick any)
.text$mn:00002824                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002824
.text$mn:00002824 ; =============== S U B R O U T I N E =======================================
.text$mn:00002824
.text$mn:00002824 ; Attributes: bp-based frame
.text$mn:00002824
.text$mn:00002824 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00002824                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00002824 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00002824                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00002824                 push    ebp
.text$mn:00002825                 mov     ebp, esp
.text$mn:00002827                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:0000282C                 pop     ebp
.text$mn:0000282D                 retn
.text$mn:0000282D ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:0000282D
.text$mn:0000282D ; ---------------------------------------------------------------------------
.text$mn:0000282E                 align 10h
.text$mn:0000282E _text$mn        ends
.text$mn:0000282E
.text$mn:00002830 ; ===========================================================================
.text$mn:00002830
.text$mn:00002830 ; Segment type: Pure code
.text$mn:00002830 ; Segment permissions: Read/Execute
.text$mn:00002830 _text$mn        segment para public 'CODE' use32
.text$mn:00002830                 assume cs:_text$mn
.text$mn:00002830                 ;org 2830h
.text$mn:00002830 ; COMDAT (pick any)
.text$mn:00002830                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002830
.text$mn:00002830 ; =============== S U B R O U T I N E =======================================
.text$mn:00002830
.text$mn:00002830 ; Attributes: bp-based frame
.text$mn:00002830
.text$mn:00002830 ; unsigned __int8 __thiscall Utf16_Iter::get(Utf16_Iter *__hidden this)
.text$mn:00002830                 public ?get@Utf16_Iter@@QBEEXZ
.text$mn:00002830 ?get@Utf16_Iter@@QBEEXZ proc near       ; CODE XREF: Utf8_16_Read::convert(char *,uint)+175p
.text$mn:00002830
.text$mn:00002830 var_4           = dword ptr -4
.text$mn:00002830
.text$mn:00002830                 push    ebp
.text$mn:00002831                 mov     ebp, esp
.text$mn:00002833                 push    ecx
.text$mn:00002834                 mov     [ebp+var_4], ecx
.text$mn:00002837                 mov     eax, [ebp+var_4]
.text$mn:0000283A                 mov     al, [eax+8]
.text$mn:0000283D                 mov     esp, ebp
.text$mn:0000283F                 pop     ebp
.text$mn:00002840                 retn
.text$mn:00002840 ?get@Utf16_Iter@@QBEEXZ endp
.text$mn:00002840
.text$mn:00002840 ; ---------------------------------------------------------------------------
.text$mn:00002841                 align 4
.text$mn:00002841 _text$mn        ends
.text$mn:00002841
.text$mn:00002844 ; ===========================================================================
.text$mn:00002844
.text$mn:00002844 ; Segment type: Pure code
.text$mn:00002844 ; Segment permissions: Read/Execute
.text$mn:00002844 _text$mn        segment para public 'CODE' use32
.text$mn:00002844                 assume cs:_text$mn
.text$mn:00002844                 ;org 2844h
.text$mn:00002844 ; COMDAT (pick any)
.text$mn:00002844                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002844
.text$mn:00002844 ; =============== S U B R O U T I N E =======================================
.text$mn:00002844
.text$mn:00002844 ; Attributes: bp-based frame
.text$mn:00002844
.text$mn:00002844 ; unsigned __int16 __thiscall Utf8_Iter::get(Utf8_Iter *__hidden this)
.text$mn:00002844                 public ?get@Utf8_Iter@@QBEGXZ
.text$mn:00002844 ?get@Utf8_Iter@@QBEGXZ proc near        ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint)+183p
.text$mn:00002844                                         ; Utf8_16_Write::convert(char *,uint)+1B9p
.text$mn:00002844
.text$mn:00002844 var_4           = dword ptr -4
.text$mn:00002844
.text$mn:00002844                 push    ebp
.text$mn:00002845                 mov     ebp, esp
.text$mn:00002847                 push    ecx
.text$mn:00002848                 mov     [ebp+var_4], ecx
.text$mn:0000284B                 mov     eax, [ebp+var_4]
.text$mn:0000284E                 cmp     dword ptr [eax+4], 0
.text$mn:00002852                 jz      short loc_2868
.text$mn:00002854                 push    51h ; 'Q'       ; Line
.text$mn:00002856                 push    offset ??_C@_1IC@ODAPDPOP@?$AAc?$AA?3?$AA?2?$AAw?$AAo?$AAr?$AAk?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?2?$AAn?$AAo?$AAt?$AAe?$AAp?$AAa?$AAd?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AA6@ ; "c:\\workspace\\notepad-plus-plus-6.7.9."...
.text$mn:0000285B                 push    offset ??_C@_1CG@LBBANLDB@?$AAm?$AA_?$AAe?$AAS?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAe?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@ ; "m_eState == eStart"
.text$mn:00002860                 call    __wassert
.text$mn:00002865 ; ---------------------------------------------------------------------------
.text$mn:00002865                 add     esp, 0Ch
.text$mn:00002868
.text$mn:00002868 loc_2868:                               ; CODE XREF: Utf8_Iter::get(void)+Ej
.text$mn:00002868                 mov     edx, [ebp+var_4]
.text$mn:0000286B                 mov     ax, [edx+8]
.text$mn:0000286F                 mov     esp, ebp
.text$mn:00002871                 pop     ebp
.text$mn:00002872                 retn
.text$mn:00002872 ?get@Utf8_Iter@@QBEGXZ endp
.text$mn:00002872
.text$mn:00002872 ; ---------------------------------------------------------------------------
.text$mn:00002873                 align 4
.text$mn:00002873 _text$mn        ends
.text$mn:00002873
.text$mn:00002874 ; ===========================================================================
.text$mn:00002874
.text$mn:00002874 ; Segment type: Pure code
.text$mn:00002874 ; Segment permissions: Read/Execute
.text$mn:00002874 _text$mn        segment para public 'CODE' use32
.text$mn:00002874                 assume cs:_text$mn
.text$mn:00002874                 ;org 2874h
.text$mn:00002874 ; COMDAT (pick any)
.text$mn:00002874                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002874
.text$mn:00002874 ; =============== S U B R O U T I N E =======================================
.text$mn:00002874
.text$mn:00002874 ; Attributes: bp-based frame
.text$mn:00002874
.text$mn:00002874 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00002874                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00002874 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00002874                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00002874
.text$mn:00002874 var_4           = dword ptr -4
.text$mn:00002874 Str             = dword ptr  8
.text$mn:00002874
.text$mn:00002874                 push    ebp
.text$mn:00002875                 mov     ebp, esp
.text$mn:00002877                 push    ecx
.text$mn:00002878                 mov     eax, [ebp+Str]
.text$mn:0000287B                 movsx   ecx, byte ptr [eax]
.text$mn:0000287E                 test    ecx, ecx
.text$mn:00002880                 jnz     short loc_288B
.text$mn:00002882                 mov     [ebp+var_4], 0
.text$mn:00002889                 jmp     short loc_289A
.text$mn:0000288B ; ---------------------------------------------------------------------------
.text$mn:0000288B
.text$mn:0000288B loc_288B:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:0000288B                 mov     edx, [ebp+Str]
.text$mn:0000288E                 push    edx             ; Str
.text$mn:0000288F                 call    _strlen
.text$mn:00002894                 add     esp, 4
.text$mn:00002897                 mov     [ebp+var_4], eax
.text$mn:0000289A
.text$mn:0000289A loc_289A:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:0000289A                 mov     eax, [ebp+var_4]
.text$mn:0000289D                 mov     esp, ebp
.text$mn:0000289F                 pop     ebp
.text$mn:000028A0                 retn
.text$mn:000028A0 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:000028A0
.text$mn:000028A0 ; ---------------------------------------------------------------------------
.text$mn:000028A1                 align 4
.text$mn:000028A1 _text$mn        ends
.text$mn:000028A1
.text$mn:000028A4 ; ===========================================================================
.text$mn:000028A4
.text$mn:000028A4 ; Segment type: Pure code
.text$mn:000028A4 ; Segment permissions: Read/Execute
.text$mn:000028A4 _text$mn        segment para public 'CODE' use32
.text$mn:000028A4                 assume cs:_text$mn
.text$mn:000028A4                 ;org 28A4h
.text$mn:000028A4 ; COMDAT (pick any)
.text$mn:000028A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000028A4
.text$mn:000028A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000028A4
.text$mn:000028A4 ; Attributes: bp-based frame
.text$mn:000028A4
.text$mn:000028A4 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:000028A4                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:000028A4 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:000028A4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:000028A4
.text$mn:000028A4 var_4           = dword ptr -4
.text$mn:000028A4
.text$mn:000028A4                 push    ebp
.text$mn:000028A5                 mov     ebp, esp
.text$mn:000028A7                 push    ecx
.text$mn:000028A8                 mov     [ebp+var_4], ecx
.text$mn:000028AB                 mov     eax, [ebp+var_4]
.text$mn:000028AE                 push    eax
.text$mn:000028AF                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:000028B4                 add     esp, 4
.text$mn:000028B7                 mov     esp, ebp
.text$mn:000028B9                 pop     ebp
.text$mn:000028BA                 retn
.text$mn:000028BA ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:000028BA
.text$mn:000028BA ; ---------------------------------------------------------------------------
.text$mn:000028BB                 align 4
.text$mn:000028BB _text$mn        ends
.text$mn:000028BB
.text$mn:000028BC ; ===========================================================================
.text$mn:000028BC
.text$mn:000028BC ; Segment type: Pure code
.text$mn:000028BC ; Segment permissions: Read/Execute
.text$mn:000028BC _text$mn        segment para public 'CODE' use32
.text$mn:000028BC                 assume cs:_text$mn
.text$mn:000028BC                 ;org 28BCh
.text$mn:000028BC ; COMDAT (pick any)
.text$mn:000028BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000028BC
.text$mn:000028BC ; =============== S U B R O U T I N E =======================================
.text$mn:000028BC
.text$mn:000028BC ; Attributes: bp-based frame
.text$mn:000028BC
.text$mn:000028BC ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:000028BC                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:000028BC ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:000028BC                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:000028BC
.text$mn:000028BC var_4           = dword ptr -4
.text$mn:000028BC
.text$mn:000028BC                 push    ebp
.text$mn:000028BD                 mov     ebp, esp
.text$mn:000028BF                 push    ecx
.text$mn:000028C0                 mov     [ebp+var_4], ecx
.text$mn:000028C3                 or      eax, 0FFFFFFFFh
.text$mn:000028C6                 mov     esp, ebp
.text$mn:000028C8                 pop     ebp
.text$mn:000028C9                 retn
.text$mn:000028C9 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:000028C9
.text$mn:000028C9 ; ---------------------------------------------------------------------------
.text$mn:000028CA                 align 4
.text$mn:000028CA _text$mn        ends
.text$mn:000028CA
.text$mn:000028CC ; ===========================================================================
.text$mn:000028CC
.text$mn:000028CC ; Segment type: Pure code
.text$mn:000028CC ; Segment permissions: Read/Execute
.text$mn:000028CC _text$mn        segment para public 'CODE' use32
.text$mn:000028CC                 assume cs:_text$mn
.text$mn:000028CC                 ;org 28CCh
.text$mn:000028CC ; COMDAT (pick any)
.text$mn:000028CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000028CC
.text$mn:000028CC ; =============== S U B R O U T I N E =======================================
.text$mn:000028CC
.text$mn:000028CC ; Attributes: bp-based frame
.text$mn:000028CC
.text$mn:000028CC ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:000028CC                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:000028CC ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:000028CC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:000028CC
.text$mn:000028CC arg_0           = dword ptr  8
.text$mn:000028CC
.text$mn:000028CC                 push    ebp
.text$mn:000028CD                 mov     ebp, esp
.text$mn:000028CF                 mov     ecx, [ebp+arg_0]
.text$mn:000028D2                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:000028D7                 pop     ebp
.text$mn:000028D8                 retn
.text$mn:000028D8 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:000028D8
.text$mn:000028D8 ; ---------------------------------------------------------------------------
.text$mn:000028D9                 align 4
.text$mn:000028D9 _text$mn        ends
.text$mn:000028D9
.text$mn:000028DC ; ===========================================================================
.text$mn:000028DC
.text$mn:000028DC ; Segment type: Pure code
.text$mn:000028DC ; Segment permissions: Read/Execute
.text$mn:000028DC _text$mn        segment para public 'CODE' use32
.text$mn:000028DC                 assume cs:_text$mn
.text$mn:000028DC                 ;org 28DCh
.text$mn:000028DC ; COMDAT (pick any)
.text$mn:000028DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000028DC
.text$mn:000028DC ; =============== S U B R O U T I N E =======================================
.text$mn:000028DC
.text$mn:000028DC ; Attributes: bp-based frame
.text$mn:000028DC
.text$mn:000028DC ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:000028DC                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:000028DC ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:000028DC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:000028DC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:000028DC
.text$mn:000028DC var_10          = dword ptr -10h
.text$mn:000028DC var_C           = dword ptr -0Ch
.text$mn:000028DC var_8           = dword ptr -8
.text$mn:000028DC var_1           = byte ptr -1
.text$mn:000028DC
.text$mn:000028DC                 push    ebp
.text$mn:000028DD                 mov     ebp, esp
.text$mn:000028DF                 sub     esp, 10h
.text$mn:000028E2                 mov     [ebp+var_10], ecx
.text$mn:000028E5                 lea     eax, [ebp+var_1]
.text$mn:000028E8                 push    eax
.text$mn:000028E9                 mov     ecx, [ebp+var_10]
.text$mn:000028EC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000028F1                 mov     ecx, eax
.text$mn:000028F3                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:000028F8                 mov     [ebp+var_8], eax
.text$mn:000028FB                 cmp     [ebp+var_8], 1
.text$mn:000028FF                 ja      short loc_290A
.text$mn:00002901                 mov     [ebp+var_C], 1
.text$mn:00002908                 jmp     short loc_2913
.text$mn:0000290A ; ---------------------------------------------------------------------------
.text$mn:0000290A
.text$mn:0000290A loc_290A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:0000290A                 mov     ecx, [ebp+var_8]
.text$mn:0000290D                 sub     ecx, 1
.text$mn:00002910                 mov     [ebp+var_C], ecx
.text$mn:00002913
.text$mn:00002913 loc_2913:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00002913                 mov     eax, [ebp+var_C]
.text$mn:00002916                 mov     esp, ebp
.text$mn:00002918                 pop     ebp
.text$mn:00002919                 retn
.text$mn:00002919 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002919
.text$mn:00002919 ; ---------------------------------------------------------------------------
.text$mn:0000291A                 align 4
.text$mn:0000291A _text$mn        ends
.text$mn:0000291A
.text$mn:0000291C ; ===========================================================================
.text$mn:0000291C
.text$mn:0000291C ; Segment type: Pure code
.text$mn:0000291C ; Segment permissions: Read/Execute
.text$mn:0000291C _text$mn        segment para public 'CODE' use32
.text$mn:0000291C                 assume cs:_text$mn
.text$mn:0000291C                 ;org 291Ch
.text$mn:0000291C ; COMDAT (pick any)
.text$mn:0000291C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000291C
.text$mn:0000291C ; =============== S U B R O U T I N E =======================================
.text$mn:0000291C
.text$mn:0000291C ; Attributes: bp-based frame
.text$mn:0000291C
.text$mn:0000291C ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:0000291C                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000291C ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000291C                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:0000291C                                         ; DATA XREF: .rdata:00002FE8o
.text$mn:0000291C
.text$mn:0000291C var_1C          = dword ptr -1Ch
.text$mn:0000291C var_18          = dword ptr -18h
.text$mn:0000291C Str             = dword ptr -14h
.text$mn:0000291C var_10          = dword ptr -10h
.text$mn:0000291C var_C           = dword ptr -0Ch
.text$mn:0000291C var_4           = dword ptr -4
.text$mn:0000291C arg_0           = dword ptr  8
.text$mn:0000291C arg_4           = dword ptr  0Ch
.text$mn:0000291C
.text$mn:0000291C                 push    ebp
.text$mn:0000291D                 mov     ebp, esp
.text$mn:0000291F                 push    0FFFFFFFFh
.text$mn:00002921                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002926                 mov     eax, large fs:0
.text$mn:0000292C                 push    eax
.text$mn:0000292D                 sub     esp, 10h
.text$mn:00002930                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002935                 xor     eax, ebp
.text$mn:00002937                 push    eax
.text$mn:00002938                 lea     eax, [ebp+var_C]
.text$mn:0000293B                 mov     large fs:0, eax
.text$mn:00002941                 mov     [ebp+var_1C], ecx
.text$mn:00002944                 mov     [ebp+var_18], 0
.text$mn:0000294B                 mov     eax, [ebp+arg_4]
.text$mn:0000294E                 push    eax             ; int
.text$mn:0000294F                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00002954                 add     esp, 4
.text$mn:00002957                 mov     [ebp+var_10], eax
.text$mn:0000295A                 cmp     [ebp+var_10], 0
.text$mn:0000295E                 jz      short loc_2968
.text$mn:00002960                 mov     ecx, [ebp+var_10]
.text$mn:00002963                 mov     [ebp+Str], ecx
.text$mn:00002966                 jmp     short loc_296F
.text$mn:00002968 ; ---------------------------------------------------------------------------
.text$mn:00002968
.text$mn:00002968 loc_2968:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00002968                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000296F
.text$mn:0000296F loc_296F:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:0000296F                 mov     edx, [ebp+Str]
.text$mn:00002972                 push    edx             ; Str
.text$mn:00002973                 mov     ecx, [ebp+arg_0]
.text$mn:00002976                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000297B                 mov     [ebp+var_4], 0
.text$mn:00002982                 mov     eax, [ebp+var_18]
.text$mn:00002985                 or      eax, 1
.text$mn:00002988                 mov     [ebp+var_18], eax
.text$mn:0000298B                 mov     eax, [ebp+arg_0]
.text$mn:0000298E                 mov     ecx, [ebp+var_C]
.text$mn:00002991                 mov     large fs:0, ecx
.text$mn:00002998                 pop     ecx
.text$mn:00002999                 mov     esp, ebp
.text$mn:0000299B                 pop     ebp
.text$mn:0000299C                 retn    8
.text$mn:0000299C ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000299C
.text$mn:0000299C ; ---------------------------------------------------------------------------
.text$mn:0000299F                 align 10h
.text$mn:0000299F _text$mn        ends
.text$mn:0000299F
.text$x:000029A0 ; ===========================================================================
.text$x:000029A0
.text$x:000029A0 ; Segment type: Pure code
.text$x:000029A0 ; Segment permissions: Read/Execute
.text$x:000029A0 _text$x         segment para public 'CODE' use32
.text$x:000029A0                 assume cs:_text$x
.text$x:000029A0                 ;org 29A0h
.text$x:000029A0 ; COMDAT (pick associative to section at 291C)
.text$x:000029A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000029A0
.text$x:000029A0 ; =============== S U B R O U T I N E =======================================
.text$x:000029A0
.text$x:000029A0
.text$x:000029A0 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000029A0                                         ; DATA XREF: .xdata$x:00002E08o
.text$x:000029A0                 mov     eax, [ebp-18h]
.text$x:000029A3                 and     eax, 1
.text$x:000029A6                 jz      $LN6
.text$x:000029AC                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:000029B0                 mov     ecx, [ebp+8]
.text$x:000029B3                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000029B8 ; ---------------------------------------------------------------------------
.text$x:000029B8
.text$x:000029B8 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000029B8                 retn
.text$x:000029B8 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000029B8
.text$x:000029B9
.text$x:000029B9 ; =============== S U B R O U T I N E =======================================
.text$x:000029B9
.text$x:000029B9
.text$x:000029B9 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000029B9                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:000029B9
.text$x:000029B9 arg_4           = dword ptr  8
.text$x:000029B9
.text$x:000029B9                 mov     edx, [esp+arg_4]
.text$x:000029BD                 lea     eax, [edx+0Ch]
.text$x:000029C0                 mov     ecx, [edx-14h]
.text$x:000029C3                 xor     ecx, eax
.text$x:000029C5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000029CA                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000029CF                 jmp     ___CxxFrameHandler3
.text$x:000029CF __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000029CF
.text$x:000029CF _text$x         ends
.text$x:000029CF
.text$mn:000029D4 ; ===========================================================================
.text$mn:000029D4
.text$mn:000029D4 ; Segment type: Pure code
.text$mn:000029D4 ; Segment permissions: Read/Execute
.text$mn:000029D4 _text$mn        segment para public 'CODE' use32
.text$mn:000029D4                 assume cs:_text$mn
.text$mn:000029D4                 ;org 29D4h
.text$mn:000029D4 ; COMDAT (pick any)
.text$mn:000029D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029D4
.text$mn:000029D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000029D4
.text$mn:000029D4 ; Attributes: bp-based frame
.text$mn:000029D4
.text$mn:000029D4 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:000029D4                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000029D4 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000029D4                                         ; DATA XREF: .rdata:0000301Co
.text$mn:000029D4
.text$mn:000029D4 var_14          = dword ptr -14h
.text$mn:000029D4 var_10          = dword ptr -10h
.text$mn:000029D4 var_C           = dword ptr -0Ch
.text$mn:000029D4 var_4           = dword ptr -4
.text$mn:000029D4 arg_0           = dword ptr  8
.text$mn:000029D4 arg_4           = dword ptr  0Ch
.text$mn:000029D4
.text$mn:000029D4                 push    ebp
.text$mn:000029D5                 mov     ebp, esp
.text$mn:000029D7                 push    0FFFFFFFFh
.text$mn:000029D9                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000029DE                 mov     eax, large fs:0
.text$mn:000029E4                 push    eax
.text$mn:000029E5                 sub     esp, 8
.text$mn:000029E8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000029ED                 xor     eax, ebp
.text$mn:000029EF                 push    eax
.text$mn:000029F0                 lea     eax, [ebp+var_C]
.text$mn:000029F3                 mov     large fs:0, eax
.text$mn:000029F9                 mov     [ebp+var_14], ecx
.text$mn:000029FC                 mov     [ebp+var_10], 0
.text$mn:00002A03                 cmp     [ebp+arg_4], 1
.text$mn:00002A07                 jnz     short loc_2A2D
.text$mn:00002A09                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00002A0E                 mov     ecx, [ebp+arg_0]
.text$mn:00002A11                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002A16                 mov     [ebp+var_4], 0
.text$mn:00002A1D                 mov     eax, [ebp+var_10]
.text$mn:00002A20                 or      eax, 1
.text$mn:00002A23                 mov     [ebp+var_10], eax
.text$mn:00002A26                 mov     eax, [ebp+arg_0]
.text$mn:00002A29                 jmp     short loc_2A50
.text$mn:00002A2B ; ---------------------------------------------------------------------------
.text$mn:00002A2B                 jmp     short loc_2A50
.text$mn:00002A2D ; ---------------------------------------------------------------------------
.text$mn:00002A2D
.text$mn:00002A2D loc_2A2D:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00002A2D                 mov     ecx, [ebp+arg_4]
.text$mn:00002A30                 push    ecx
.text$mn:00002A31                 mov     edx, [ebp+arg_0]
.text$mn:00002A34                 push    edx
.text$mn:00002A35                 mov     ecx, [ebp+var_14]
.text$mn:00002A38                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00002A3D                 mov     [ebp+var_4], 0
.text$mn:00002A44                 mov     eax, [ebp+var_10]
.text$mn:00002A47                 or      eax, 1
.text$mn:00002A4A                 mov     [ebp+var_10], eax
.text$mn:00002A4D                 mov     eax, [ebp+arg_0]
.text$mn:00002A50
.text$mn:00002A50 loc_2A50:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00002A50                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00002A50                 mov     ecx, [ebp+var_C]
.text$mn:00002A53                 mov     large fs:0, ecx
.text$mn:00002A5A                 pop     ecx
.text$mn:00002A5B                 mov     esp, ebp
.text$mn:00002A5D                 pop     ebp
.text$mn:00002A5E                 retn    8
.text$mn:00002A5E ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002A5E
.text$mn:00002A5E ; ---------------------------------------------------------------------------
.text$mn:00002A61                 align 4
.text$mn:00002A61 _text$mn        ends
.text$mn:00002A61
.text$x:00002A64 ; ===========================================================================
.text$x:00002A64
.text$x:00002A64 ; Segment type: Pure code
.text$x:00002A64 ; Segment permissions: Read/Execute
.text$x:00002A64 _text$x         segment para public 'CODE' use32
.text$x:00002A64                 assume cs:_text$x
.text$x:00002A64                 ;org 2A64h
.text$x:00002A64 ; COMDAT (pick associative to section at 29D4)
.text$x:00002A64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002A64
.text$x:00002A64 ; =============== S U B R O U T I N E =======================================
.text$x:00002A64
.text$x:00002A64
.text$x:00002A64 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002A64                                         ; DATA XREF: .xdata$x:00002E8Co
.text$x:00002A64                 mov     eax, [ebp-10h]
.text$x:00002A67                 and     eax, 1
.text$x:00002A6A                 jz      $LN6_0
.text$x:00002A70                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00002A74                 mov     ecx, [ebp+8]
.text$x:00002A77                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002A7C ; ---------------------------------------------------------------------------
.text$x:00002A7C
.text$x:00002A7C $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002A7C                 retn
.text$x:00002A7C __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002A7C
.text$x:00002A7D
.text$x:00002A7D ; =============== S U B R O U T I N E =======================================
.text$x:00002A7D
.text$x:00002A7D
.text$x:00002A7D __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002A7D                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00002A7D
.text$x:00002A7D arg_4           = dword ptr  8
.text$x:00002A7D
.text$x:00002A7D                 mov     edx, [esp+arg_4]
.text$x:00002A81                 lea     eax, [edx+0Ch]
.text$x:00002A84                 mov     ecx, [edx-0Ch]
.text$x:00002A87                 xor     ecx, eax
.text$x:00002A89                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002A8E                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00002A93                 jmp     ___CxxFrameHandler3
.text$x:00002A93 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00002A93
.text$x:00002A93 _text$x         ends
.text$x:00002A93
.text$mn:00002A98 ; ===========================================================================
.text$mn:00002A98
.text$mn:00002A98 ; Segment type: Pure code
.text$mn:00002A98 ; Segment permissions: Read/Execute
.text$mn:00002A98 _text$mn        segment para public 'CODE' use32
.text$mn:00002A98                 assume cs:_text$mn
.text$mn:00002A98                 ;org 2A98h
.text$mn:00002A98 ; COMDAT (pick any)
.text$mn:00002A98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A98
.text$mn:00002A98 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A98
.text$mn:00002A98 ; Attributes: bp-based frame
.text$mn:00002A98
.text$mn:00002A98 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00002A98                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002A98 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002A98                                         ; DATA XREF: .rdata:0000305Co
.text$mn:00002A98
.text$mn:00002A98 var_1C          = dword ptr -1Ch
.text$mn:00002A98 var_18          = dword ptr -18h
.text$mn:00002A98 Str             = dword ptr -14h
.text$mn:00002A98 var_10          = dword ptr -10h
.text$mn:00002A98 var_C           = dword ptr -0Ch
.text$mn:00002A98 var_4           = dword ptr -4
.text$mn:00002A98 arg_0           = dword ptr  8
.text$mn:00002A98 arg_4           = dword ptr  0Ch
.text$mn:00002A98
.text$mn:00002A98                 push    ebp
.text$mn:00002A99                 mov     ebp, esp
.text$mn:00002A9B                 push    0FFFFFFFFh
.text$mn:00002A9D                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002AA2                 mov     eax, large fs:0
.text$mn:00002AA8                 push    eax
.text$mn:00002AA9                 sub     esp, 10h
.text$mn:00002AAC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002AB1                 xor     eax, ebp
.text$mn:00002AB3                 push    eax
.text$mn:00002AB4                 lea     eax, [ebp+var_C]
.text$mn:00002AB7                 mov     large fs:0, eax
.text$mn:00002ABD                 mov     [ebp+var_1C], ecx
.text$mn:00002AC0                 mov     [ebp+var_18], 0
.text$mn:00002AC7                 mov     eax, [ebp+arg_4]
.text$mn:00002ACA                 push    eax             ; int
.text$mn:00002ACB                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00002AD0                 add     esp, 4
.text$mn:00002AD3                 mov     [ebp+var_10], eax
.text$mn:00002AD6                 cmp     [ebp+var_10], 0
.text$mn:00002ADA                 jz      short loc_2AE4
.text$mn:00002ADC                 mov     ecx, [ebp+var_10]
.text$mn:00002ADF                 mov     [ebp+Str], ecx
.text$mn:00002AE2                 jmp     short loc_2AEB
.text$mn:00002AE4 ; ---------------------------------------------------------------------------
.text$mn:00002AE4
.text$mn:00002AE4 loc_2AE4:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00002AE4                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00002AEB
.text$mn:00002AEB loc_2AEB:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00002AEB                 mov     edx, [ebp+Str]
.text$mn:00002AEE                 push    edx             ; Str
.text$mn:00002AEF                 mov     ecx, [ebp+arg_0]
.text$mn:00002AF2                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002AF7                 mov     [ebp+var_4], 0
.text$mn:00002AFE                 mov     eax, [ebp+var_18]
.text$mn:00002B01                 or      eax, 1
.text$mn:00002B04                 mov     [ebp+var_18], eax
.text$mn:00002B07                 mov     eax, [ebp+arg_0]
.text$mn:00002B0A                 mov     ecx, [ebp+var_C]
.text$mn:00002B0D                 mov     large fs:0, ecx
.text$mn:00002B14                 pop     ecx
.text$mn:00002B15                 mov     esp, ebp
.text$mn:00002B17                 pop     ebp
.text$mn:00002B18                 retn    8
.text$mn:00002B18 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002B18
.text$mn:00002B18 ; ---------------------------------------------------------------------------
.text$mn:00002B1B                 align 4
.text$mn:00002B1B _text$mn        ends
.text$mn:00002B1B
.text$x:00002B1C ; ===========================================================================
.text$x:00002B1C
.text$x:00002B1C ; Segment type: Pure code
.text$x:00002B1C ; Segment permissions: Read/Execute
.text$x:00002B1C _text$x         segment para public 'CODE' use32
.text$x:00002B1C                 assume cs:_text$x
.text$x:00002B1C                 ;org 2B1Ch
.text$x:00002B1C ; COMDAT (pick associative to section at 2A98)
.text$x:00002B1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002B1C
.text$x:00002B1C ; =============== S U B R O U T I N E =======================================
.text$x:00002B1C
.text$x:00002B1C
.text$x:00002B1C __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002B1C                                         ; DATA XREF: .xdata$x:00002F10o
.text$x:00002B1C                 mov     eax, [ebp-18h]
.text$x:00002B1F                 and     eax, 1
.text$x:00002B22                 jz      $LN6_1
.text$x:00002B28                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00002B2C                 mov     ecx, [ebp+8]
.text$x:00002B2F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002B34 ; ---------------------------------------------------------------------------
.text$x:00002B34
.text$x:00002B34 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002B34                 retn
.text$x:00002B34 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002B34
.text$x:00002B35
.text$x:00002B35 ; =============== S U B R O U T I N E =======================================
.text$x:00002B35
.text$x:00002B35
.text$x:00002B35 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002B35                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00002B35
.text$x:00002B35 arg_4           = dword ptr  8
.text$x:00002B35
.text$x:00002B35                 mov     edx, [esp+arg_4]
.text$x:00002B39                 lea     eax, [edx+0Ch]
.text$x:00002B3C                 mov     ecx, [edx-14h]
.text$x:00002B3F                 xor     ecx, eax
.text$x:00002B41                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002B46                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00002B4B                 jmp     ___CxxFrameHandler3
.text$x:00002B4B __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00002B4B
.text$x:00002B4B _text$x         ends
.text$x:00002B4B
.text$mn:00002B50 ; ===========================================================================
.text$mn:00002B50
.text$mn:00002B50 ; Segment type: Pure code
.text$mn:00002B50 ; Segment permissions: Read/Execute
.text$mn:00002B50 _text$mn        segment para public 'CODE' use32
.text$mn:00002B50                 assume cs:_text$mn
.text$mn:00002B50                 ;org 2B50h
.text$mn:00002B50 ; COMDAT (pick any)
.text$mn:00002B50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B50
.text$mn:00002B50 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B50
.text$mn:00002B50 ; Attributes: bp-based frame
.text$mn:00002B50
.text$mn:00002B50 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00002B50                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00002B50 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00002B50                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00002B50
.text$mn:00002B50 var_4           = dword ptr -4
.text$mn:00002B50 Dst             = dword ptr  8
.text$mn:00002B50 Src             = dword ptr  0Ch
.text$mn:00002B50 Size            = dword ptr  10h
.text$mn:00002B50
.text$mn:00002B50                 push    ebp
.text$mn:00002B51                 mov     ebp, esp
.text$mn:00002B53                 push    ecx
.text$mn:00002B54                 cmp     [ebp+Size], 0
.text$mn:00002B58                 jnz     short loc_2B62
.text$mn:00002B5A                 mov     eax, [ebp+Dst]
.text$mn:00002B5D                 mov     [ebp+var_4], eax
.text$mn:00002B60                 jmp     short loc_2B79
.text$mn:00002B62 ; ---------------------------------------------------------------------------
.text$mn:00002B62
.text$mn:00002B62 loc_2B62:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00002B62                 mov     ecx, [ebp+Size]
.text$mn:00002B65                 push    ecx             ; Size
.text$mn:00002B66                 mov     edx, [ebp+Src]
.text$mn:00002B69                 push    edx             ; Src
.text$mn:00002B6A                 mov     eax, [ebp+Dst]
.text$mn:00002B6D                 push    eax             ; Dst
.text$mn:00002B6E                 call    _memmove
.text$mn:00002B73                 add     esp, 0Ch
.text$mn:00002B76                 mov     [ebp+var_4], eax
.text$mn:00002B79
.text$mn:00002B79 loc_2B79:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00002B79                 mov     eax, [ebp+var_4]
.text$mn:00002B7C                 mov     esp, ebp
.text$mn:00002B7E                 pop     ebp
.text$mn:00002B7F                 retn
.text$mn:00002B7F ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00002B7F
.text$mn:00002B7F _text$mn        ends
.text$mn:00002B7F
.text$mn:00002B80 ; ===========================================================================
.text$mn:00002B80
.text$mn:00002B80 ; Segment type: Pure code
.text$mn:00002B80 ; Segment permissions: Read/Execute
.text$mn:00002B80 _text$mn        segment para public 'CODE' use32
.text$mn:00002B80                 assume cs:_text$mn
.text$mn:00002B80                 ;org 2B80h
.text$mn:00002B80 ; COMDAT (pick any)
.text$mn:00002B80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B80
.text$mn:00002B80 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B80
.text$mn:00002B80 ; Attributes: bp-based frame
.text$mn:00002B80
.text$mn:00002B80 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00002B80                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00002B80 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00002B80                                         ; DATA XREF: .rdata:00002FE4o
.text$mn:00002B80
.text$mn:00002B80 var_4           = dword ptr -4
.text$mn:00002B80
.text$mn:00002B80                 push    ebp
.text$mn:00002B81                 mov     ebp, esp
.text$mn:00002B83                 push    ecx
.text$mn:00002B84                 mov     [ebp+var_4], ecx
.text$mn:00002B87                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00002B8C                 mov     esp, ebp
.text$mn:00002B8E                 pop     ebp
.text$mn:00002B8F                 retn
.text$mn:00002B8F ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00002B8F
.text$mn:00002B8F _text$mn        ends
.text$mn:00002B8F
.text$mn:00002B90 ; ===========================================================================
.text$mn:00002B90
.text$mn:00002B90 ; Segment type: Pure code
.text$mn:00002B90 ; Segment permissions: Read/Execute
.text$mn:00002B90 _text$mn        segment para public 'CODE' use32
.text$mn:00002B90                 assume cs:_text$mn
.text$mn:00002B90                 ;org 2B90h
.text$mn:00002B90 ; COMDAT (pick any)
.text$mn:00002B90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B90
.text$mn:00002B90 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B90
.text$mn:00002B90 ; Attributes: bp-based frame
.text$mn:00002B90
.text$mn:00002B90 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00002B90                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00002B90 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00002B90                                         ; DATA XREF: .rdata:00003018o
.text$mn:00002B90
.text$mn:00002B90 var_4           = dword ptr -4
.text$mn:00002B90
.text$mn:00002B90                 push    ebp
.text$mn:00002B91                 mov     ebp, esp
.text$mn:00002B93                 push    ecx
.text$mn:00002B94                 mov     [ebp+var_4], ecx
.text$mn:00002B97                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00002B9C                 mov     esp, ebp
.text$mn:00002B9E                 pop     ebp
.text$mn:00002B9F                 retn
.text$mn:00002B9F ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00002B9F
.text$mn:00002B9F _text$mn        ends
.text$mn:00002B9F
.text$mn:00002BA0 ; ===========================================================================
.text$mn:00002BA0
.text$mn:00002BA0 ; Segment type: Pure code
.text$mn:00002BA0 ; Segment permissions: Read/Execute
.text$mn:00002BA0 _text$mn        segment para public 'CODE' use32
.text$mn:00002BA0                 assume cs:_text$mn
.text$mn:00002BA0                 ;org 2BA0h
.text$mn:00002BA0 ; COMDAT (pick any)
.text$mn:00002BA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BA0
.text$mn:00002BA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BA0
.text$mn:00002BA0 ; Attributes: bp-based frame
.text$mn:00002BA0
.text$mn:00002BA0 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00002BA0                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00002BA0 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00002BA0                                         ; DATA XREF: .rdata:00003058o
.text$mn:00002BA0
.text$mn:00002BA0 var_4           = dword ptr -4
.text$mn:00002BA0
.text$mn:00002BA0                 push    ebp
.text$mn:00002BA1                 mov     ebp, esp
.text$mn:00002BA3                 push    ecx
.text$mn:00002BA4                 mov     [ebp+var_4], ecx
.text$mn:00002BA7                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00002BAC                 mov     esp, ebp
.text$mn:00002BAE                 pop     ebp
.text$mn:00002BAF                 retn
.text$mn:00002BAF ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00002BAF
.text$mn:00002BAF _text$mn        ends
.text$mn:00002BAF
.text$mn:00002BB0 ; ===========================================================================
.text$mn:00002BB0
.text$mn:00002BB0 ; Segment type: Pure code
.text$mn:00002BB0 ; Segment permissions: Read/Execute
.text$mn:00002BB0 _text$mn        segment para public 'CODE' use32
.text$mn:00002BB0                 assume cs:_text$mn
.text$mn:00002BB0                 ;org 2BB0h
.text$mn:00002BB0 ; COMDAT (pick any)
.text$mn:00002BB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BB0
.text$mn:00002BB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BB0
.text$mn:00002BB0 ; Attributes: bp-based frame
.text$mn:00002BB0
.text$mn:00002BB0 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00002BB0                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00002BB0 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00002BB0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00002BB0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00002BB0
.text$mn:00002BB0 var_4           = dword ptr -4
.text$mn:00002BB0
.text$mn:00002BB0                 push    ebp
.text$mn:00002BB1                 mov     ebp, esp
.text$mn:00002BB3                 push    ecx
.text$mn:00002BB4                 mov     [ebp+var_4], ecx
.text$mn:00002BB7                 mov     eax, [ebp+var_4]
.text$mn:00002BBA                 mov     eax, [eax+14h]
.text$mn:00002BBD                 mov     esp, ebp
.text$mn:00002BBF                 pop     ebp
.text$mn:00002BC0                 retn
.text$mn:00002BC0 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002BC0
.text$mn:00002BC0 ; ---------------------------------------------------------------------------
.text$mn:00002BC1                 align 4
.text$mn:00002BC1 _text$mn        ends
.text$mn:00002BC1
.text$mn:00002BC4 ; ===========================================================================
.text$mn:00002BC4
.text$mn:00002BC4 ; Segment type: Pure code
.text$mn:00002BC4 ; Segment permissions: Read/Execute
.text$mn:00002BC4 _text$mn        segment para public 'CODE' use32
.text$mn:00002BC4                 assume cs:_text$mn
.text$mn:00002BC4                 ;org 2BC4h
.text$mn:00002BC4 ; COMDAT (pick any)
.text$mn:00002BC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BC4
.text$mn:00002BC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BC4
.text$mn:00002BC4 ; Attributes: bp-based frame
.text$mn:00002BC4
.text$mn:00002BC4 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00002BC4                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00002BC4 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00002BC4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_26B8p
.text$mn:00002BC4                 push    ebp
.text$mn:00002BC5                 mov     ebp, esp
.text$mn:00002BC7                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00002BCC                 pop     ebp
.text$mn:00002BCD                 retn
.text$mn:00002BCD ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00002BCD
.text$mn:00002BCD ; ---------------------------------------------------------------------------
.text$mn:00002BCE                 align 10h
.text$mn:00002BCE _text$mn        ends
.text$mn:00002BCE
.text$mn:00002BD0 ; ===========================================================================
.text$mn:00002BD0
.text$mn:00002BD0 ; Segment type: Pure code
.text$mn:00002BD0 ; Segment permissions: Read/Execute
.text$mn:00002BD0 _text$mn        segment para public 'CODE' use32
.text$mn:00002BD0                 assume cs:_text$mn
.text$mn:00002BD0                 ;org 2BD0h
.text$mn:00002BD0 ; COMDAT (pick any)
.text$mn:00002BD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BD0
.text$mn:00002BD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BD0
.text$mn:00002BD0 ; Attributes: bp-based frame
.text$mn:00002BD0
.text$mn:00002BD0 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00002BD0                 public ?value@error_code@std@@QBEHXZ
.text$mn:00002BD0 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00002BD0
.text$mn:00002BD0 var_4           = dword ptr -4
.text$mn:00002BD0
.text$mn:00002BD0                 push    ebp
.text$mn:00002BD1                 mov     ebp, esp
.text$mn:00002BD3                 push    ecx
.text$mn:00002BD4                 mov     [ebp+var_4], ecx
.text$mn:00002BD7                 mov     eax, [ebp+var_4]
.text$mn:00002BDA                 mov     eax, [eax]
.text$mn:00002BDC                 mov     esp, ebp
.text$mn:00002BDE                 pop     ebp
.text$mn:00002BDF                 retn
.text$mn:00002BDF ?value@error_code@std@@QBEHXZ endp
.text$mn:00002BDF
.text$mn:00002BDF _text$mn        ends
.text$mn:00002BDF
.text$mn:00002BE0 ; ===========================================================================
.text$mn:00002BE0
.text$mn:00002BE0 ; Segment type: Pure code
.text$mn:00002BE0 ; Segment permissions: Read/Execute
.text$mn:00002BE0 _text$mn        segment para public 'CODE' use32
.text$mn:00002BE0                 assume cs:_text$mn
.text$mn:00002BE0                 ;org 2BE0h
.text$mn:00002BE0 ; COMDAT (pick any)
.text$mn:00002BE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BE0
.text$mn:00002BE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BE0
.text$mn:00002BE0 ; Attributes: bp-based frame
.text$mn:00002BE0
.text$mn:00002BE0 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00002BE0                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00002BE0 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00002BE0                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00002BE0                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00002BE0
.text$mn:00002BE0 var_4           = dword ptr -4
.text$mn:00002BE0
.text$mn:00002BE0                 push    ebp
.text$mn:00002BE1                 mov     ebp, esp
.text$mn:00002BE3                 push    ecx
.text$mn:00002BE4                 mov     [ebp+var_4], ecx
.text$mn:00002BE7                 mov     eax, [ebp+var_4]
.text$mn:00002BEA                 mov     eax, [eax]
.text$mn:00002BEC                 mov     esp, ebp
.text$mn:00002BEE                 pop     ebp
.text$mn:00002BEF                 retn
.text$mn:00002BEF ?value@error_condition@std@@QBEHXZ endp
.text$mn:00002BEF
.text$mn:00002BEF _text$mn        ends
.text$mn:00002BEF
.text$mn:00002BF0 ; ===========================================================================
.text$mn:00002BF0
.text$mn:00002BF0 ; Segment type: Pure code
.text$mn:00002BF0 ; Segment permissions: Read/Execute
.text$mn:00002BF0 _text$mn        segment para public 'CODE' use32
.text$mn:00002BF0                 assume cs:_text$mn
.text$mn:00002BF0                 ;org 2BF0h
.text$mn:00002BF0 ; COMDAT (pick any)
.text$mn:00002BF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BF0
.text$mn:00002BF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BF0
.text$mn:00002BF0 ; Attributes: bp-based frame
.text$mn:00002BF0
.text$mn:00002BF0                 public _hypot
.text$mn:00002BF0 _hypot          proc near
.text$mn:00002BF0
.text$mn:00002BF0 var_10          = qword ptr -10h
.text$mn:00002BF0 var_8           = qword ptr -8
.text$mn:00002BF0 arg_0           = qword ptr  8
.text$mn:00002BF0 arg_8           = qword ptr  10h
.text$mn:00002BF0
.text$mn:00002BF0                 push    ebp
.text$mn:00002BF1                 mov     ebp, esp
.text$mn:00002BF3                 sub     esp, 8
.text$mn:00002BF6                 movsd   xmm0, [ebp+arg_8]
.text$mn:00002BFB                 movsd   [esp+8+var_8], xmm0
.text$mn:00002C00                 sub     esp, 8
.text$mn:00002C03                 movsd   xmm0, [ebp+arg_0]
.text$mn:00002C08                 movsd   [esp+10h+var_10], xmm0
.text$mn:00002C0D                 call    __hypot
.text$mn:00002C12                 add     esp, 10h
.text$mn:00002C15                 pop     ebp
.text$mn:00002C16                 retn
.text$mn:00002C16 _hypot          endp
.text$mn:00002C16
.text$mn:00002C16 ; ---------------------------------------------------------------------------
.text$mn:00002C17                 align 4
.text$mn:00002C17 _text$mn        ends
.text$mn:00002C17
.xdata$x:00002C18 ; ===========================================================================
.xdata$x:00002C18
.xdata$x:00002C18 ; Segment type: Pure data
.xdata$x:00002C18 ; Segment permissions: Read
.xdata$x:00002C18 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002C18                 assume cs:_xdata$x
.xdata$x:00002C18                 ;org 2C18h
.xdata$x:00002C18 ; COMDAT (pick associative to section at 2230)
.xdata$x:00002C18 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00002C18                                         ; DATA XREF: .xdata$x:00002C28o
.xdata$x:00002C19                 db 0FFh
.xdata$x:00002C1A                 db 0FFh
.xdata$x:00002C1B                 db 0FFh
.xdata$x:00002C1C                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00002C20 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00002C20                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00002C21                 db    5
.xdata$x:00002C22                 db  93h ; ô
.xdata$x:00002C23                 db  19h
.xdata$x:00002C24                 db    1
.xdata$x:00002C25                 db    0
.xdata$x:00002C26                 db    0
.xdata$x:00002C27                 db    0
.xdata$x:00002C28                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00002C2C                 db    0
.xdata$x:00002C2D                 db    0
.xdata$x:00002C2E                 db    0
.xdata$x:00002C2F                 db    0
.xdata$x:00002C30                 db    0
.xdata$x:00002C31                 db    0
.xdata$x:00002C32                 db    0
.xdata$x:00002C33                 db    0
.xdata$x:00002C34                 db    0
.xdata$x:00002C35                 db    0
.xdata$x:00002C36                 db    0
.xdata$x:00002C37                 db    0
.xdata$x:00002C38                 db    0
.xdata$x:00002C39                 db    0
.xdata$x:00002C3A                 db    0
.xdata$x:00002C3B                 db    0
.xdata$x:00002C3C                 db    0
.xdata$x:00002C3D                 db    0
.xdata$x:00002C3E                 db    0
.xdata$x:00002C3F                 db    0
.xdata$x:00002C40                 db    0
.xdata$x:00002C41                 db    0
.xdata$x:00002C42                 db    0
.xdata$x:00002C43                 db    0
.xdata$x:00002C43 _xdata$x        ends
.xdata$x:00002C43
.xdata$x:00002C44 ; ===========================================================================
.xdata$x:00002C44
.xdata$x:00002C44 ; Segment type: Pure data
.xdata$x:00002C44 ; Segment permissions: Read
.xdata$x:00002C44 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002C44                 assume cs:_xdata$x
.xdata$x:00002C44                 ;org 2C44h
.xdata$x:00002C44 ; COMDAT (pick associative to section at 1570)
.xdata$x:00002C44 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002C44                                         ; DATA XREF: .xdata$x:00002C54o
.xdata$x:00002C45                 db 0FFh
.xdata$x:00002C46                 db 0FFh
.xdata$x:00002C47                 db 0FFh
.xdata$x:00002C48                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002C4C __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002C4C                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002C4D                 db    5
.xdata$x:00002C4E                 db  93h ; ô
.xdata$x:00002C4F                 db  19h
.xdata$x:00002C50                 db    1
.xdata$x:00002C51                 db    0
.xdata$x:00002C52                 db    0
.xdata$x:00002C53                 db    0
.xdata$x:00002C54                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002C58                 db    0
.xdata$x:00002C59                 db    0
.xdata$x:00002C5A                 db    0
.xdata$x:00002C5B                 db    0
.xdata$x:00002C5C                 db    0
.xdata$x:00002C5D                 db    0
.xdata$x:00002C5E                 db    0
.xdata$x:00002C5F                 db    0
.xdata$x:00002C60                 db    0
.xdata$x:00002C61                 db    0
.xdata$x:00002C62                 db    0
.xdata$x:00002C63                 db    0
.xdata$x:00002C64                 db    0
.xdata$x:00002C65                 db    0
.xdata$x:00002C66                 db    0
.xdata$x:00002C67                 db    0
.xdata$x:00002C68                 db    0
.xdata$x:00002C69                 db    0
.xdata$x:00002C6A                 db    0
.xdata$x:00002C6B                 db    0
.xdata$x:00002C6C                 db    0
.xdata$x:00002C6D                 db    0
.xdata$x:00002C6E                 db    0
.xdata$x:00002C6F                 db    0
.xdata$x:00002C6F _xdata$x        ends
.xdata$x:00002C6F
.xdata$x:00002C70 ; ===========================================================================
.xdata$x:00002C70
.xdata$x:00002C70 ; Segment type: Pure data
.xdata$x:00002C70 ; Segment permissions: Read
.xdata$x:00002C70 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002C70                 assume cs:_xdata$x
.xdata$x:00002C70                 ;org 2C70h
.xdata$x:00002C70 ; COMDAT (pick associative to section at 1944)
.xdata$x:00002C70 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002C70                                         ; DATA XREF: .xdata$x:00002C80o
.xdata$x:00002C71                 db 0FFh
.xdata$x:00002C72                 db 0FFh
.xdata$x:00002C73                 db 0FFh
.xdata$x:00002C74                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002C78 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002C78                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002C79                 db    5
.xdata$x:00002C7A                 db  93h ; ô
.xdata$x:00002C7B                 db  19h
.xdata$x:00002C7C                 db    1
.xdata$x:00002C7D                 db    0
.xdata$x:00002C7E                 db    0
.xdata$x:00002C7F                 db    0
.xdata$x:00002C80                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002C84                 db    0
.xdata$x:00002C85                 db    0
.xdata$x:00002C86                 db    0
.xdata$x:00002C87                 db    0
.xdata$x:00002C88                 db    0
.xdata$x:00002C89                 db    0
.xdata$x:00002C8A                 db    0
.xdata$x:00002C8B                 db    0
.xdata$x:00002C8C                 db    0
.xdata$x:00002C8D                 db    0
.xdata$x:00002C8E                 db    0
.xdata$x:00002C8F                 db    0
.xdata$x:00002C90                 db    0
.xdata$x:00002C91                 db    0
.xdata$x:00002C92                 db    0
.xdata$x:00002C93                 db    0
.xdata$x:00002C94                 db    0
.xdata$x:00002C95                 db    0
.xdata$x:00002C96                 db    0
.xdata$x:00002C97                 db    0
.xdata$x:00002C98                 db    0
.xdata$x:00002C99                 db    0
.xdata$x:00002C9A                 db    0
.xdata$x:00002C9B                 db    0
.xdata$x:00002C9B _xdata$x        ends
.xdata$x:00002C9B
.xdata$x:00002C9C ; ===========================================================================
.xdata$x:00002C9C
.xdata$x:00002C9C ; Segment type: Pure data
.xdata$x:00002C9C ; Segment permissions: Read
.xdata$x:00002C9C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002C9C                 assume cs:_xdata$x
.xdata$x:00002C9C                 ;org 2C9Ch
.xdata$x:00002C9C ; COMDAT (pick associative to section at 14F4)
.xdata$x:00002C9C __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00002C9C                                         ; DATA XREF: .xdata$x:00002CACo
.xdata$x:00002C9D                 db 0FFh
.xdata$x:00002C9E                 db 0FFh
.xdata$x:00002C9F                 db 0FFh
.xdata$x:00002CA0                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00002CA4 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00002CA4                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00002CA5                 db    5
.xdata$x:00002CA6                 db  93h ; ô
.xdata$x:00002CA7                 db  19h
.xdata$x:00002CA8                 db    1
.xdata$x:00002CA9                 db    0
.xdata$x:00002CAA                 db    0
.xdata$x:00002CAB                 db    0
.xdata$x:00002CAC                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00002CB0                 db    0
.xdata$x:00002CB1                 db    0
.xdata$x:00002CB2                 db    0
.xdata$x:00002CB3                 db    0
.xdata$x:00002CB4                 db    0
.xdata$x:00002CB5                 db    0
.xdata$x:00002CB6                 db    0
.xdata$x:00002CB7                 db    0
.xdata$x:00002CB8                 db    0
.xdata$x:00002CB9                 db    0
.xdata$x:00002CBA                 db    0
.xdata$x:00002CBB                 db    0
.xdata$x:00002CBC                 db    0
.xdata$x:00002CBD                 db    0
.xdata$x:00002CBE                 db    0
.xdata$x:00002CBF                 db    0
.xdata$x:00002CC0                 db    0
.xdata$x:00002CC1                 db    0
.xdata$x:00002CC2                 db    0
.xdata$x:00002CC3                 db    0
.xdata$x:00002CC4                 db    0
.xdata$x:00002CC5                 db    0
.xdata$x:00002CC6                 db    0
.xdata$x:00002CC7                 db    0
.xdata$x:00002CC7 _xdata$x        ends
.xdata$x:00002CC7
.xdata$x:00002CC8 ; ===========================================================================
.xdata$x:00002CC8
.xdata$x:00002CC8 ; Segment type: Pure data
.xdata$x:00002CC8 ; Segment permissions: Read
.xdata$x:00002CC8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002CC8                 assume cs:_xdata$x
.xdata$x:00002CC8                 ;org 2CC8h
.xdata$x:00002CC8 ; COMDAT (pick associative to section at 18CC)
.xdata$x:00002CC8 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002CC8                                         ; DATA XREF: .xdata$x:00002CD8o
.xdata$x:00002CC9                 db 0FFh
.xdata$x:00002CCA                 db 0FFh
.xdata$x:00002CCB                 db 0FFh
.xdata$x:00002CCC                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00002CD0 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002CD0                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00002CD1                 db    5
.xdata$x:00002CD2                 db  93h ; ô
.xdata$x:00002CD3                 db  19h
.xdata$x:00002CD4                 db    1
.xdata$x:00002CD5                 db    0
.xdata$x:00002CD6                 db    0
.xdata$x:00002CD7                 db    0
.xdata$x:00002CD8                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00002CDC                 db    0
.xdata$x:00002CDD                 db    0
.xdata$x:00002CDE                 db    0
.xdata$x:00002CDF                 db    0
.xdata$x:00002CE0                 db    0
.xdata$x:00002CE1                 db    0
.xdata$x:00002CE2                 db    0
.xdata$x:00002CE3                 db    0
.xdata$x:00002CE4                 db    0
.xdata$x:00002CE5                 db    0
.xdata$x:00002CE6                 db    0
.xdata$x:00002CE7                 db    0
.xdata$x:00002CE8                 db    0
.xdata$x:00002CE9                 db    0
.xdata$x:00002CEA                 db    0
.xdata$x:00002CEB                 db    0
.xdata$x:00002CEC                 db    0
.xdata$x:00002CED                 db    0
.xdata$x:00002CEE                 db    0
.xdata$x:00002CEF                 db    0
.xdata$x:00002CF0                 db    0
.xdata$x:00002CF1                 db    0
.xdata$x:00002CF2                 db    0
.xdata$x:00002CF3                 db    0
.xdata$x:00002CF3 _xdata$x        ends
.xdata$x:00002CF3
.xdata$x:00002CF4 ; ===========================================================================
.xdata$x:00002CF4
.xdata$x:00002CF4 ; Segment type: Pure data
.xdata$x:00002CF4 ; Segment permissions: Read
.xdata$x:00002CF4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002CF4                 assume cs:_xdata$x
.xdata$x:00002CF4                 ;org 2CF4h
.xdata$x:00002CF4 ; COMDAT (pick associative to section at 1630)
.xdata$x:00002CF4 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00002CF4                                         ; DATA XREF: .xdata$x:00002D04o
.xdata$x:00002CF5                 db 0FFh
.xdata$x:00002CF6                 db 0FFh
.xdata$x:00002CF7                 db 0FFh
.xdata$x:00002CF8                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00002CFC __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00002CFC                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00002CFD                 db    5
.xdata$x:00002CFE                 db  93h ; ô
.xdata$x:00002CFF                 db  19h
.xdata$x:00002D00                 db    1
.xdata$x:00002D01                 db    0
.xdata$x:00002D02                 db    0
.xdata$x:00002D03                 db    0
.xdata$x:00002D04                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00002D08                 align 20h
.xdata$x:00002D08 _xdata$x        ends
.xdata$x:00002D08
.xdata$x:00002D20 ; ===========================================================================
.xdata$x:00002D20
.xdata$x:00002D20 ; Segment type: Pure data
.xdata$x:00002D20 ; Segment permissions: Read
.xdata$x:00002D20 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002D20                 assume cs:_xdata$x
.xdata$x:00002D20                 ;org 2D20h
.xdata$x:00002D20 ; COMDAT (pick associative to section at 19B4)
.xdata$x:00002D20 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00002D20                                         ; DATA XREF: .xdata$x:00002D30o
.xdata$x:00002D21                 db 0FFh
.xdata$x:00002D22                 db 0FFh
.xdata$x:00002D23                 db 0FFh
.xdata$x:00002D24                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00002D28 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00002D28                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00002D29                 db    5
.xdata$x:00002D2A                 db  93h ; ô
.xdata$x:00002D2B                 db  19h
.xdata$x:00002D2C                 db    1
.xdata$x:00002D2D                 db    0
.xdata$x:00002D2E                 db    0
.xdata$x:00002D2F                 db    0
.xdata$x:00002D30                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00002D34                 db    0
.xdata$x:00002D35                 db    0
.xdata$x:00002D36                 db    0
.xdata$x:00002D37                 db    0
.xdata$x:00002D38                 db    0
.xdata$x:00002D39                 db    0
.xdata$x:00002D3A                 db    0
.xdata$x:00002D3B                 db    0
.xdata$x:00002D3C                 db    0
.xdata$x:00002D3D                 db    0
.xdata$x:00002D3E                 db    0
.xdata$x:00002D3F                 db    0
.xdata$x:00002D40                 db    0
.xdata$x:00002D41                 db    0
.xdata$x:00002D42                 db    0
.xdata$x:00002D43                 db    0
.xdata$x:00002D44                 db    0
.xdata$x:00002D45                 db    0
.xdata$x:00002D46                 db    0
.xdata$x:00002D47                 db    0
.xdata$x:00002D48                 db    0
.xdata$x:00002D49                 db    0
.xdata$x:00002D4A                 db    0
.xdata$x:00002D4B                 db    0
.xdata$x:00002D4B _xdata$x        ends
.xdata$x:00002D4B
.xdata$x:00002D4C ; ===========================================================================
.xdata$x:00002D4C
.xdata$x:00002D4C ; Segment type: Pure data
.xdata$x:00002D4C ; Segment permissions: Read
.xdata$x:00002D4C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002D4C                 assume cs:_xdata$x
.xdata$x:00002D4C                 ;org 2D4Ch
.xdata$x:00002D4C ; COMDAT (pick associative to section at 1E8C)
.xdata$x:00002D4C __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00002D4C                                         ; DATA XREF: .xdata$x:00002DD4o
.xdata$x:00002D4D                 db    0
.xdata$x:00002D4E                 db    0
.xdata$x:00002D4F                 db    0
.xdata$x:00002D50                 db    0
.xdata$x:00002D51                 db    0
.xdata$x:00002D52                 db    0
.xdata$x:00002D53                 db    0
.xdata$x:00002D54                 db    0
.xdata$x:00002D55                 db    0
.xdata$x:00002D56                 db    0
.xdata$x:00002D57                 db    0
.xdata$x:00002D58                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00002D5C __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00002D5C                                         ; DATA XREF: .xdata$x:00002DC0o
.xdata$x:00002D5D                 db    0
.xdata$x:00002D5E                 db    0
.xdata$x:00002D5F                 db    0
.xdata$x:00002D60                 db    0
.xdata$x:00002D61                 db    0
.xdata$x:00002D62                 db    0
.xdata$x:00002D63                 db    0
.xdata$x:00002D64                 db    0
.xdata$x:00002D65                 db    0
.xdata$x:00002D66                 db    0
.xdata$x:00002D67                 db    0
.xdata$x:00002D68                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00002D6C __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00002D6C                                         ; DATA XREF: .xdata$x:00002D94o
.xdata$x:00002D6D                 db 0FFh
.xdata$x:00002D6E                 db 0FFh
.xdata$x:00002D6F                 db 0FFh
.xdata$x:00002D70                 db    0
.xdata$x:00002D71                 db    0
.xdata$x:00002D72                 db    0
.xdata$x:00002D73                 db    0
.xdata$x:00002D74                 db 0FFh
.xdata$x:00002D75                 db 0FFh
.xdata$x:00002D76                 db 0FFh
.xdata$x:00002D77                 db 0FFh
.xdata$x:00002D78                 db    0
.xdata$x:00002D79                 db    0
.xdata$x:00002D7A                 db    0
.xdata$x:00002D7B                 db    0
.xdata$x:00002D7C                 db    1
.xdata$x:00002D7D                 db    0
.xdata$x:00002D7E                 db    0
.xdata$x:00002D7F                 db    0
.xdata$x:00002D80                 db    0
.xdata$x:00002D81                 db    0
.xdata$x:00002D82                 db    0
.xdata$x:00002D83                 db    0
.xdata$x:00002D84                 db    1
.xdata$x:00002D85                 db    0
.xdata$x:00002D86                 db    0
.xdata$x:00002D87                 db    0
.xdata$x:00002D88                 db    0
.xdata$x:00002D89                 db    0
.xdata$x:00002D8A                 db    0
.xdata$x:00002D8B                 db    0
.xdata$x:00002D8C __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00002D8C                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00002D8D                 db    5
.xdata$x:00002D8E                 db  93h ; ô
.xdata$x:00002D8F                 db  19h
.xdata$x:00002D90                 db    4
.xdata$x:00002D91                 db    0
.xdata$x:00002D92                 db    0
.xdata$x:00002D93                 db    0
.xdata$x:00002D94                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002D98                 db    2
.xdata$x:00002D99                 db    0
.xdata$x:00002D9A                 db    0
.xdata$x:00002D9B                 db    0
.xdata$x:00002D9C                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002DA0                 db    0
.xdata$x:00002DA1                 db    0
.xdata$x:00002DA2                 db    0
.xdata$x:00002DA3                 db    0
.xdata$x:00002DA4                 db    0
.xdata$x:00002DA5                 db    0
.xdata$x:00002DA6                 db    0
.xdata$x:00002DA7                 db    0
.xdata$x:00002DA8                 db    0
.xdata$x:00002DA9                 db    0
.xdata$x:00002DAA                 db    0
.xdata$x:00002DAB                 db    0
.xdata$x:00002DAC                 db    0
.xdata$x:00002DAD                 db    0
.xdata$x:00002DAE                 db    0
.xdata$x:00002DAF                 db    0
.xdata$x:00002DB0 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00002DB0                                         ; DATA XREF: .xdata$x:00002D9Co
.xdata$x:00002DB1                 db    0
.xdata$x:00002DB2                 db    0
.xdata$x:00002DB3                 db    0
.xdata$x:00002DB4                 db    2
.xdata$x:00002DB5                 db    0
.xdata$x:00002DB6                 db    0
.xdata$x:00002DB7                 db    0
.xdata$x:00002DB8                 db    3
.xdata$x:00002DB9                 db    0
.xdata$x:00002DBA                 db    0
.xdata$x:00002DBB                 db    0
.xdata$x:00002DBC                 db    1
.xdata$x:00002DBD                 db    0
.xdata$x:00002DBE                 db    0
.xdata$x:00002DBF                 db    0
.xdata$x:00002DC0                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00002DC4                 db    0
.xdata$x:00002DC5                 db    0
.xdata$x:00002DC6                 db    0
.xdata$x:00002DC7                 db    0
.xdata$x:00002DC8                 db    0
.xdata$x:00002DC9                 db    0
.xdata$x:00002DCA                 db    0
.xdata$x:00002DCB                 db    0
.xdata$x:00002DCC                 db    3
.xdata$x:00002DCD                 db    0
.xdata$x:00002DCE                 db    0
.xdata$x:00002DCF                 db    0
.xdata$x:00002DD0                 db    1
.xdata$x:00002DD1                 db    0
.xdata$x:00002DD2                 db    0
.xdata$x:00002DD3                 db    0
.xdata$x:00002DD4                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00002DD4 _xdata$x        ends
.xdata$x:00002DD4
.xdata$x:00002DD8 ; ===========================================================================
.xdata$x:00002DD8
.xdata$x:00002DD8 ; Segment type: Pure data
.xdata$x:00002DD8 ; Segment permissions: Read
.xdata$x:00002DD8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002DD8                 assume cs:_xdata$x
.xdata$x:00002DD8                 ;org 2DD8h
.xdata$x:00002DD8 ; COMDAT (pick associative to section at 1704)
.xdata$x:00002DD8 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002DD8                                         ; DATA XREF: .xdata$x:00002DE8o
.xdata$x:00002DD9                 db 0FFh
.xdata$x:00002DDA                 db 0FFh
.xdata$x:00002DDB                 db 0FFh
.xdata$x:00002DDC                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00002DE0 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002DE0                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00002DE1                 db    5
.xdata$x:00002DE2                 db  93h ; ô
.xdata$x:00002DE3                 db  19h
.xdata$x:00002DE4                 db    1
.xdata$x:00002DE5                 db    0
.xdata$x:00002DE6                 db    0
.xdata$x:00002DE7                 db    0
.xdata$x:00002DE8                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00002DEC                 db    0
.xdata$x:00002DED                 db    0
.xdata$x:00002DEE                 db    0
.xdata$x:00002DEF                 db    0
.xdata$x:00002DF0                 db    0
.xdata$x:00002DF1                 db    0
.xdata$x:00002DF2                 db    0
.xdata$x:00002DF3                 db    0
.xdata$x:00002DF4                 db    0
.xdata$x:00002DF5                 db    0
.xdata$x:00002DF6                 db    0
.xdata$x:00002DF7                 db    0
.xdata$x:00002DF8                 db    0
.xdata$x:00002DF9                 db    0
.xdata$x:00002DFA                 db    0
.xdata$x:00002DFB                 db    0
.xdata$x:00002DFC                 db    0
.xdata$x:00002DFD                 db    0
.xdata$x:00002DFE                 db    0
.xdata$x:00002DFF                 db    0
.xdata$x:00002E00                 db    0
.xdata$x:00002E01                 db    0
.xdata$x:00002E02                 db    0
.xdata$x:00002E03                 db    0
.xdata$x:00002E03 _xdata$x        ends
.xdata$x:00002E03
.xdata$x:00002E04 ; ===========================================================================
.xdata$x:00002E04
.xdata$x:00002E04 ; Segment type: Pure data
.xdata$x:00002E04 ; Segment permissions: Read
.xdata$x:00002E04 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E04                 assume cs:_xdata$x
.xdata$x:00002E04                 ;org 2E04h
.xdata$x:00002E04 ; COMDAT (pick associative to section at 291C)
.xdata$x:00002E04 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002E04                                         ; DATA XREF: .xdata$x:00002E14o
.xdata$x:00002E05                 db 0FFh
.xdata$x:00002E06                 db 0FFh
.xdata$x:00002E07                 db 0FFh
.xdata$x:00002E08                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002E0C __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002E0C                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002E0D                 db    5
.xdata$x:00002E0E                 db  93h ; ô
.xdata$x:00002E0F                 db  19h
.xdata$x:00002E10                 db    1
.xdata$x:00002E11                 db    0
.xdata$x:00002E12                 db    0
.xdata$x:00002E13                 db    0
.xdata$x:00002E14                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002E18                 db    0
.xdata$x:00002E19                 db    0
.xdata$x:00002E1A                 db    0
.xdata$x:00002E1B                 db    0
.xdata$x:00002E1C                 db    0
.xdata$x:00002E1D                 db    0
.xdata$x:00002E1E                 db    0
.xdata$x:00002E1F                 db    0
.xdata$x:00002E20                 db    0
.xdata$x:00002E21                 db    0
.xdata$x:00002E22                 db    0
.xdata$x:00002E23                 db    0
.xdata$x:00002E24                 db    0
.xdata$x:00002E25                 db    0
.xdata$x:00002E26                 db    0
.xdata$x:00002E27                 db    0
.xdata$x:00002E28                 db    0
.xdata$x:00002E29                 db    0
.xdata$x:00002E2A                 db    0
.xdata$x:00002E2B                 db    0
.xdata$x:00002E2C                 db    0
.xdata$x:00002E2D                 db    0
.xdata$x:00002E2E                 db    0
.xdata$x:00002E2F                 db    0
.xdata$x:00002E2F _xdata$x        ends
.xdata$x:00002E2F
.xdata$x:00002E30 ; ===========================================================================
.xdata$x:00002E30
.xdata$x:00002E30 ; Segment type: Pure data
.xdata$x:00002E30 ; Segment permissions: Read
.xdata$x:00002E30 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E30                 assume cs:_xdata$x
.xdata$x:00002E30                 ;org 2E30h
.xdata$x:00002E30 ; COMDAT (pick associative to section at 1A44)
.xdata$x:00002E30 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002E30                                         ; DATA XREF: .xdata$x:00002E40o
.xdata$x:00002E31                 db 0FFh
.xdata$x:00002E32                 db 0FFh
.xdata$x:00002E33                 db 0FFh
.xdata$x:00002E34                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00002E38 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002E38                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00002E39                 db    5
.xdata$x:00002E3A                 db  93h ; ô
.xdata$x:00002E3B                 db  19h
.xdata$x:00002E3C                 db    1
.xdata$x:00002E3D                 db    0
.xdata$x:00002E3E                 db    0
.xdata$x:00002E3F                 db    0
.xdata$x:00002E40                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00002E44                 db    0
.xdata$x:00002E45                 db    0
.xdata$x:00002E46                 db    0
.xdata$x:00002E47                 db    0
.xdata$x:00002E48                 db    0
.xdata$x:00002E49                 db    0
.xdata$x:00002E4A                 db    0
.xdata$x:00002E4B                 db    0
.xdata$x:00002E4C                 db    0
.xdata$x:00002E4D                 db    0
.xdata$x:00002E4E                 db    0
.xdata$x:00002E4F                 db    0
.xdata$x:00002E50                 db    0
.xdata$x:00002E51                 db    0
.xdata$x:00002E52                 db    0
.xdata$x:00002E53                 db    0
.xdata$x:00002E54                 db    0
.xdata$x:00002E55                 db    0
.xdata$x:00002E56                 db    0
.xdata$x:00002E57                 db    0
.xdata$x:00002E58                 db    0
.xdata$x:00002E59                 db    0
.xdata$x:00002E5A                 db    0
.xdata$x:00002E5B                 db    0
.xdata$x:00002E5B _xdata$x        ends
.xdata$x:00002E5B
.xdata$x:00002E5C ; ===========================================================================
.xdata$x:00002E5C
.xdata$x:00002E5C ; Segment type: Pure data
.xdata$x:00002E5C ; Segment permissions: Read
.xdata$x:00002E5C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E5C                 assume cs:_xdata$x
.xdata$x:00002E5C                 ;org 2E5Ch
.xdata$x:00002E5C ; COMDAT (pick associative to section at 1780)
.xdata$x:00002E5C __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002E5C                                         ; DATA XREF: .xdata$x:00002E6Co
.xdata$x:00002E5D                 db 0FFh
.xdata$x:00002E5E                 db 0FFh
.xdata$x:00002E5F                 db 0FFh
.xdata$x:00002E60                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00002E64 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002E64                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00002E65                 db    5
.xdata$x:00002E66                 db  93h ; ô
.xdata$x:00002E67                 db  19h
.xdata$x:00002E68                 db    1
.xdata$x:00002E69                 db    0
.xdata$x:00002E6A                 db    0
.xdata$x:00002E6B                 db    0
.xdata$x:00002E6C                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00002E70                 db    0
.xdata$x:00002E71                 db    0
.xdata$x:00002E72                 db    0
.xdata$x:00002E73                 db    0
.xdata$x:00002E74                 db    0
.xdata$x:00002E75                 db    0
.xdata$x:00002E76                 db    0
.xdata$x:00002E77                 db    0
.xdata$x:00002E78                 db    0
.xdata$x:00002E79                 db    0
.xdata$x:00002E7A                 db    0
.xdata$x:00002E7B                 db    0
.xdata$x:00002E7C                 db    0
.xdata$x:00002E7D                 db    0
.xdata$x:00002E7E                 db    0
.xdata$x:00002E7F                 db    0
.xdata$x:00002E80                 db    0
.xdata$x:00002E81                 db    0
.xdata$x:00002E82                 db    0
.xdata$x:00002E83                 db    0
.xdata$x:00002E84                 db    0
.xdata$x:00002E85                 db    0
.xdata$x:00002E86                 db    0
.xdata$x:00002E87                 db    0
.xdata$x:00002E87 _xdata$x        ends
.xdata$x:00002E87
.xdata$x:00002E88 ; ===========================================================================
.xdata$x:00002E88
.xdata$x:00002E88 ; Segment type: Pure data
.xdata$x:00002E88 ; Segment permissions: Read
.xdata$x:00002E88 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E88                 assume cs:_xdata$x
.xdata$x:00002E88                 ;org 2E88h
.xdata$x:00002E88 ; COMDAT (pick associative to section at 29D4)
.xdata$x:00002E88 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002E88                                         ; DATA XREF: .xdata$x:00002E98o
.xdata$x:00002E89                 db 0FFh
.xdata$x:00002E8A                 db 0FFh
.xdata$x:00002E8B                 db 0FFh
.xdata$x:00002E8C                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002E90 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002E90                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002E91                 db    5
.xdata$x:00002E92                 db  93h ; ô
.xdata$x:00002E93                 db  19h
.xdata$x:00002E94                 db    1
.xdata$x:00002E95                 db    0
.xdata$x:00002E96                 db    0
.xdata$x:00002E97                 db    0
.xdata$x:00002E98                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002E9C                 db    0
.xdata$x:00002E9D                 db    0
.xdata$x:00002E9E                 db    0
.xdata$x:00002E9F                 db    0
.xdata$x:00002EA0                 db    0
.xdata$x:00002EA1                 db    0
.xdata$x:00002EA2                 db    0
.xdata$x:00002EA3                 db    0
.xdata$x:00002EA4                 db    0
.xdata$x:00002EA5                 db    0
.xdata$x:00002EA6                 db    0
.xdata$x:00002EA7                 db    0
.xdata$x:00002EA8                 db    0
.xdata$x:00002EA9                 db    0
.xdata$x:00002EAA                 db    0
.xdata$x:00002EAB                 db    0
.xdata$x:00002EAC                 db    0
.xdata$x:00002EAD                 db    0
.xdata$x:00002EAE                 db    0
.xdata$x:00002EAF                 db    0
.xdata$x:00002EB0                 db    0
.xdata$x:00002EB1                 db    0
.xdata$x:00002EB2                 db    0
.xdata$x:00002EB3                 db    0
.xdata$x:00002EB3 _xdata$x        ends
.xdata$x:00002EB3
.xdata$x:00002EB4 ; ===========================================================================
.xdata$x:00002EB4
.xdata$x:00002EB4 ; Segment type: Pure data
.xdata$x:00002EB4 ; Segment permissions: Read
.xdata$x:00002EB4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002EB4                 assume cs:_xdata$x
.xdata$x:00002EB4                 ;org 2EB4h
.xdata$x:00002EB4 ; COMDAT (pick associative to section at 1AB4)
.xdata$x:00002EB4 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002EB4                                         ; DATA XREF: .xdata$x:00002EC4o
.xdata$x:00002EB5                 db 0FFh
.xdata$x:00002EB6                 db 0FFh
.xdata$x:00002EB7                 db 0FFh
.xdata$x:00002EB8                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00002EBC __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002EBC                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00002EBD                 db    5
.xdata$x:00002EBE                 db  93h ; ô
.xdata$x:00002EBF                 db  19h
.xdata$x:00002EC0                 db    1
.xdata$x:00002EC1                 db    0
.xdata$x:00002EC2                 db    0
.xdata$x:00002EC3                 db    0
.xdata$x:00002EC4                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00002EC8                 align 20h
.xdata$x:00002EC8 _xdata$x        ends
.xdata$x:00002EC8
.xdata$x:00002EE0 ; ===========================================================================
.xdata$x:00002EE0
.xdata$x:00002EE0 ; Segment type: Pure data
.xdata$x:00002EE0 ; Segment permissions: Read
.xdata$x:00002EE0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002EE0                 assume cs:_xdata$x
.xdata$x:00002EE0                 ;org 2EE0h
.xdata$x:00002EE0 ; COMDAT (pick associative to section at 17FC)
.xdata$x:00002EE0 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002EE0                                         ; DATA XREF: .xdata$x:00002EF0o
.xdata$x:00002EE1                 db 0FFh
.xdata$x:00002EE2                 db 0FFh
.xdata$x:00002EE3                 db 0FFh
.xdata$x:00002EE4                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00002EE8 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002EE8                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00002EE9                 db    5
.xdata$x:00002EEA                 db  93h ; ô
.xdata$x:00002EEB                 db  19h
.xdata$x:00002EEC                 db    1
.xdata$x:00002EED                 db    0
.xdata$x:00002EEE                 db    0
.xdata$x:00002EEF                 db    0
.xdata$x:00002EF0                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00002EF4                 db    0
.xdata$x:00002EF5                 db    0
.xdata$x:00002EF6                 db    0
.xdata$x:00002EF7                 db    0
.xdata$x:00002EF8                 db    0
.xdata$x:00002EF9                 db    0
.xdata$x:00002EFA                 db    0
.xdata$x:00002EFB                 db    0
.xdata$x:00002EFC                 db    0
.xdata$x:00002EFD                 db    0
.xdata$x:00002EFE                 db    0
.xdata$x:00002EFF                 db    0
.xdata$x:00002F00                 db    0
.xdata$x:00002F01                 db    0
.xdata$x:00002F02                 db    0
.xdata$x:00002F03                 db    0
.xdata$x:00002F04                 db    0
.xdata$x:00002F05                 db    0
.xdata$x:00002F06                 db    0
.xdata$x:00002F07                 db    0
.xdata$x:00002F08                 db    0
.xdata$x:00002F09                 db    0
.xdata$x:00002F0A                 db    0
.xdata$x:00002F0B                 db    0
.xdata$x:00002F0B _xdata$x        ends
.xdata$x:00002F0B
.xdata$x:00002F0C ; ===========================================================================
.xdata$x:00002F0C
.xdata$x:00002F0C ; Segment type: Pure data
.xdata$x:00002F0C ; Segment permissions: Read
.xdata$x:00002F0C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002F0C                 assume cs:_xdata$x
.xdata$x:00002F0C                 ;org 2F0Ch
.xdata$x:00002F0C ; COMDAT (pick associative to section at 2A98)
.xdata$x:00002F0C __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002F0C                                         ; DATA XREF: .xdata$x:00002F1Co
.xdata$x:00002F0D                 db 0FFh
.xdata$x:00002F0E                 db 0FFh
.xdata$x:00002F0F                 db 0FFh
.xdata$x:00002F10                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002F14 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002F14                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002F15                 db    5
.xdata$x:00002F16                 db  93h ; ô
.xdata$x:00002F17                 db  19h
.xdata$x:00002F18                 db    1
.xdata$x:00002F19                 db    0
.xdata$x:00002F1A                 db    0
.xdata$x:00002F1B                 db    0
.xdata$x:00002F1C                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002F20                 db    0
.xdata$x:00002F21                 db    0
.xdata$x:00002F22                 db    0
.xdata$x:00002F23                 db    0
.xdata$x:00002F24                 db    0
.xdata$x:00002F25                 db    0
.xdata$x:00002F26                 db    0
.xdata$x:00002F27                 db    0
.xdata$x:00002F28                 db    0
.xdata$x:00002F29                 db    0
.xdata$x:00002F2A                 db    0
.xdata$x:00002F2B                 db    0
.xdata$x:00002F2C                 db    0
.xdata$x:00002F2D                 db    0
.xdata$x:00002F2E                 db    0
.xdata$x:00002F2F                 db    0
.xdata$x:00002F30                 db    0
.xdata$x:00002F31                 db    0
.xdata$x:00002F32                 db    0
.xdata$x:00002F33                 db    0
.xdata$x:00002F34                 db    0
.xdata$x:00002F35                 db    0
.xdata$x:00002F36                 db    0
.xdata$x:00002F37                 db    0
.xdata$x:00002F37 _xdata$x        ends
.xdata$x:00002F37
.xdata$x:00002F38 ; ===========================================================================
.xdata$x:00002F38
.xdata$x:00002F38 ; Segment type: Pure data
.xdata$x:00002F38 ; Segment permissions: Read
.xdata$x:00002F38 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002F38                 assume cs:_xdata$x
.xdata$x:00002F38                 ;org 2F38h
.xdata$x:00002F38 ; COMDAT (pick associative to section at 1B24)
.xdata$x:00002F38 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002F38                                         ; DATA XREF: .xdata$x:00002F48o
.xdata$x:00002F39                 db 0FFh
.xdata$x:00002F3A                 db 0FFh
.xdata$x:00002F3B                 db 0FFh
.xdata$x:00002F3C                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00002F40 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002F40                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00002F41                 db    5
.xdata$x:00002F42                 db  93h ; ô
.xdata$x:00002F43                 db  19h
.xdata$x:00002F44                 db    1
.xdata$x:00002F45                 db    0
.xdata$x:00002F46                 db    0
.xdata$x:00002F47                 db    0
.xdata$x:00002F48                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00002F4C                 db    0
.xdata$x:00002F4D                 db    0
.xdata$x:00002F4E                 db    0
.xdata$x:00002F4F                 db    0
.xdata$x:00002F50                 db    0
.xdata$x:00002F51                 db    0
.xdata$x:00002F52                 db    0
.xdata$x:00002F53                 db    0
.xdata$x:00002F54                 db    0
.xdata$x:00002F55                 db    0
.xdata$x:00002F56                 db    0
.xdata$x:00002F57                 db    0
.xdata$x:00002F58                 db    0
.xdata$x:00002F59                 db    0
.xdata$x:00002F5A                 db    0
.xdata$x:00002F5B                 db    0
.xdata$x:00002F5C                 db    0
.xdata$x:00002F5D                 db    0
.xdata$x:00002F5E                 db    0
.xdata$x:00002F5F                 db    0
.xdata$x:00002F60                 db    0
.xdata$x:00002F61                 db    0
.xdata$x:00002F62                 db    0
.xdata$x:00002F63                 db    0
.xdata$x:00002F63 _xdata$x        ends
.xdata$x:00002F63
.xdata$x:00002F64 ; ===========================================================================
.xdata$x:00002F64
.xdata$x:00002F64 ; Segment type: Pure data
.xdata$x:00002F64 ; Segment permissions: Read
.xdata$x:00002F64 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002F64                 assume cs:_xdata$x
.xdata$x:00002F64                 ;org 2F64h
.xdata$x:00002F64 ; COMDAT (pick associative to section at 13D8)
.xdata$x:00002F64 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00002F64                                         ; DATA XREF: .xdata$x:00002F74o
.xdata$x:00002F65                 db 0FFh
.xdata$x:00002F66                 db 0FFh
.xdata$x:00002F67                 db 0FFh
.xdata$x:00002F68                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00002F6C __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00002F6C                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00002F6D                 db    5
.xdata$x:00002F6E                 db  93h ; ô
.xdata$x:00002F6F                 db  19h
.xdata$x:00002F70                 db    1
.xdata$x:00002F71                 db    0
.xdata$x:00002F72                 db    0
.xdata$x:00002F73                 db    0
.xdata$x:00002F74                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00002F78                 db    0
.xdata$x:00002F79                 db    0
.xdata$x:00002F7A                 db    0
.xdata$x:00002F7B                 db    0
.xdata$x:00002F7C                 db    0
.xdata$x:00002F7D                 db    0
.xdata$x:00002F7E                 db    0
.xdata$x:00002F7F                 db    0
.xdata$x:00002F80                 db    0
.xdata$x:00002F81                 db    0
.xdata$x:00002F82                 db    0
.xdata$x:00002F83                 db    0
.xdata$x:00002F84                 db    0
.xdata$x:00002F85                 db    0
.xdata$x:00002F86                 db    0
.xdata$x:00002F87                 db    0
.xdata$x:00002F88                 db    0
.xdata$x:00002F89                 db    0
.xdata$x:00002F8A                 db    0
.xdata$x:00002F8B                 db    0
.xdata$x:00002F8C                 db    0
.xdata$x:00002F8D                 db    0
.xdata$x:00002F8E                 db    0
.xdata$x:00002F8F                 db    0
.xdata$x:00002F8F _xdata$x        ends
.xdata$x:00002F8F
.xdata$x:00002F90 ; ===========================================================================
.xdata$x:00002F90
.xdata$x:00002F90 ; Segment type: Pure data
.xdata$x:00002F90 ; Segment permissions: Read
.xdata$x:00002F90 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002F90                 assume cs:_xdata$x
.xdata$x:00002F90                 ;org 2F90h
.xdata$x:00002F90 ; COMDAT (pick associative to section at 1304)
.xdata$x:00002F90 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00002F90                                         ; DATA XREF: .xdata$x:00002FA0o
.xdata$x:00002F91                 db 0FFh
.xdata$x:00002F92                 db 0FFh
.xdata$x:00002F93                 db 0FFh
.xdata$x:00002F94                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00002F98 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00002F98                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00002F99                 db    5
.xdata$x:00002F9A                 db  93h ; ô
.xdata$x:00002F9B                 db  19h
.xdata$x:00002F9C                 db    1
.xdata$x:00002F9D                 db    0
.xdata$x:00002F9E                 db    0
.xdata$x:00002F9F                 db    0
.xdata$x:00002FA0                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00002FA4                 db    0
.xdata$x:00002FA5                 db    0
.xdata$x:00002FA6                 db    0
.xdata$x:00002FA7                 db    0
.xdata$x:00002FA8                 db    0
.xdata$x:00002FA9                 db    0
.xdata$x:00002FAA                 db    0
.xdata$x:00002FAB                 db    0
.xdata$x:00002FAC                 db    0
.xdata$x:00002FAD                 db    0
.xdata$x:00002FAE                 db    0
.xdata$x:00002FAF                 db    0
.xdata$x:00002FB0                 db    0
.xdata$x:00002FB1                 db    0
.xdata$x:00002FB2                 db    0
.xdata$x:00002FB3                 db    0
.xdata$x:00002FB4                 db    0
.xdata$x:00002FB5                 db    0
.xdata$x:00002FB6                 db    0
.xdata$x:00002FB7                 db    0
.xdata$x:00002FB8                 db    0
.xdata$x:00002FB9                 db    0
.xdata$x:00002FBA                 db    0
.xdata$x:00002FBB                 db    0
.xdata$x:00002FBB _xdata$x        ends
.xdata$x:00002FBB
.bss:00002FBC ; ===========================================================================
.bss:00002FBC
.bss:00002FBC ; Segment type: Uninitialized
.bss:00002FBC ; Segment permissions: Read/Write
.bss:00002FBC _bss            segment byte public 'BSS' use32
.bss:00002FBC                 assume cs:_bss
.bss:00002FBC                 ;org 2FBCh
.bss:00002FBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00002FBC _allocator_arg  db    ? ;
.bss:00002FBD _piecewise_construct db    ? ;
.bss:00002FBE                 align 10h
.bss:00002FBE _bss            ends
.bss:00002FBE
.rdata:00002FC0 ; ===========================================================================
.rdata:00002FC0
.rdata:00002FC0 ; Segment type: Pure data
.rdata:00002FC0 ; Segment permissions: Read
.rdata:00002FC0 _rdata          segment dword public 'DATA' use32
.rdata:00002FC0                 assume cs:_rdata
.rdata:00002FC0                 ;org 2FC0h
.rdata:00002FC0 ; COMDAT (pick largest)
.rdata:00002FC0                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00002FC4                 public ??_7error_category@std@@6B@
.rdata:00002FC4 ; const std::error_category::`vftable'
.rdata:00002FC4 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00002FC4                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00002FC4                                         ; std::error_category::~error_category(void)+Ao
.rdata:00002FC4                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00002FC8                 dd offset __purecall
.rdata:00002FCC                 dd offset __purecall
.rdata:00002FD0                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002FD4                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002FD8                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002FD8 _rdata          ends
.rdata:00002FD8
.rdata:00002FDC ; ===========================================================================
.rdata:00002FDC
.rdata:00002FDC ; Segment type: Pure data
.rdata:00002FDC ; Segment permissions: Read
.rdata:00002FDC _rdata          segment dword public 'DATA' use32
.rdata:00002FDC                 assume cs:_rdata
.rdata:00002FDC                 ;org 2FDCh
.rdata:00002FDC ; COMDAT (pick largest)
.rdata:00002FDC                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00002FE0                 public ??_7_Generic_error_category@std@@6B@
.rdata:00002FE0 ; const std::_Generic_error_category::`vftable'
.rdata:00002FE0 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00002FE0                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00002FE0                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00002FE4                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00002FE8                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00002FEC                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002FF0                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002FF4                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002FF4 _rdata          ends
.rdata:00002FF4
.rdata:00002FF8 ; ===========================================================================
.rdata:00002FF8
.rdata:00002FF8 ; Segment type: Pure data
.rdata:00002FF8 ; Segment permissions: Read
.rdata:00002FF8 _rdata          segment dword public 'DATA' use32
.rdata:00002FF8                 assume cs:_rdata
.rdata:00002FF8                 ;org 2FF8h
.rdata:00002FF8 ; COMDAT (pick any)
.rdata:00002FF8                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00002FF8 ; `string'
.rdata:00002FF8 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00002FF8                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00002FF8 _rdata          ends
.rdata:00002FF8
.rdata:00003000 ; ===========================================================================
.rdata:00003000
.rdata:00003000 ; Segment type: Pure data
.rdata:00003000 ; Segment permissions: Read
.rdata:00003000 _rdata          segment dword public 'DATA' use32
.rdata:00003000                 assume cs:_rdata
.rdata:00003000                 ;org 3000h
.rdata:00003000 ; COMDAT (pick any)
.rdata:00003000                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00003000 ; `string'
.rdata:00003000 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00003000                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_2968o
.rdata:00003000                                         ; std::_System_error_category::message(int):loc_2AE4o
.rdata:0000300E                 align 10h
.rdata:0000300E _rdata          ends
.rdata:0000300E
.rdata:00003010 ; ===========================================================================
.rdata:00003010
.rdata:00003010 ; Segment type: Pure data
.rdata:00003010 ; Segment permissions: Read
.rdata:00003010 _rdata          segment dword public 'DATA' use32
.rdata:00003010                 assume cs:_rdata
.rdata:00003010                 ;org 3010h
.rdata:00003010 ; COMDAT (pick largest)
.rdata:00003010                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00003014                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00003014 ; const std::_Iostream_error_category::`vftable'
.rdata:00003014 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00003014                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00003014                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00003018                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:0000301C                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00003020                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00003024                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00003028                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00003028 _rdata          ends
.rdata:00003028
.rdata:0000302C ; ===========================================================================
.rdata:0000302C
.rdata:0000302C ; Segment type: Pure data
.rdata:0000302C ; Segment permissions: Read
.rdata:0000302C _rdata          segment dword public 'DATA' use32
.rdata:0000302C                 assume cs:_rdata
.rdata:0000302C                 ;org 302Ch
.rdata:0000302C ; COMDAT (pick any)
.rdata:0000302C                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:0000302C ; `string'
.rdata:0000302C ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:0000302C                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00003035                 align 4
.rdata:00003035 _rdata          ends
.rdata:00003035
.rdata:00003038 ; ===========================================================================
.rdata:00003038
.rdata:00003038 ; Segment type: Pure data
.rdata:00003038 ; Segment permissions: Read
.rdata:00003038 _rdata          segment dword public 'DATA' use32
.rdata:00003038                 assume cs:_rdata
.rdata:00003038                 ;org 3038h
.rdata:00003038 ; COMDAT (pick any)
.rdata:00003038                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00003038 ; char `string'[]
.rdata:00003038 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00003038                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:0000304E                 align 10h
.rdata:0000304E _rdata          ends
.rdata:0000304E
.rdata:00003050 ; ===========================================================================
.rdata:00003050
.rdata:00003050 ; Segment type: Pure data
.rdata:00003050 ; Segment permissions: Read
.rdata:00003050 _rdata          segment dword public 'DATA' use32
.rdata:00003050                 assume cs:_rdata
.rdata:00003050                 ;org 3050h
.rdata:00003050 ; COMDAT (pick largest)
.rdata:00003050                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00003054                 public ??_7_System_error_category@std@@6B@
.rdata:00003054 ; const std::_System_error_category::`vftable'
.rdata:00003054 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00003054                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00003054                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00003058                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:0000305C                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00003060                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00003064                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00003068                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00003068 _rdata          ends
.rdata:00003068
.rdata:0000306C ; ===========================================================================
.rdata:0000306C
.rdata:0000306C ; Segment type: Pure data
.rdata:0000306C ; Segment permissions: Read
.rdata:0000306C _rdata          segment dword public 'DATA' use32
.rdata:0000306C                 assume cs:_rdata
.rdata:0000306C                 ;org 306Ch
.rdata:0000306C ; COMDAT (pick any)
.rdata:0000306C                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:0000306C ; `string'
.rdata:0000306C ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:0000306C                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00003073                 align 4
.rdata:00003073 _rdata          ends
.rdata:00003073
.bss:00003074 ; ===========================================================================
.bss:00003074
.bss:00003074 ; Segment type: Uninitialized
.bss:00003074 ; Segment permissions: Read/Write
.bss:00003074 _bss            segment dword public 'BSS' use32
.bss:00003074                 assume cs:_bss
.bss:00003074                 ;org 3074h
.bss:00003074 ; COMDAT (pick any)
.bss:00003074                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00003074                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00003074 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00003074 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00003074                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00003074                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00003075                 db    ? ;
.bss:00003076                 db    ? ;
.bss:00003077                 db    ? ;
.bss:00003077 _bss            ends
.bss:00003077
.bss:00003078 ; ===========================================================================
.bss:00003078
.bss:00003078 ; Segment type: Uninitialized
.bss:00003078 ; Segment permissions: Read/Write
.bss:00003078 _bss            segment dword public 'BSS' use32
.bss:00003078                 assume cs:_bss
.bss:00003078                 ;org 3078h
.bss:00003078 ; COMDAT (pick any)
.bss:00003078                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00003078                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00003078 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00003078 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00003078                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00003078                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00003079                 db    ? ;
.bss:0000307A                 db    ? ;
.bss:0000307B                 db    ? ;
.bss:0000307B _bss            ends
.bss:0000307B
.bss:0000307C ; ===========================================================================
.bss:0000307C
.bss:0000307C ; Segment type: Uninitialized
.bss:0000307C ; Segment permissions: Read/Write
.bss:0000307C _bss            segment dword public 'BSS' use32
.bss:0000307C                 assume cs:_bss
.bss:0000307C                 ;org 307Ch
.bss:0000307C ; COMDAT (pick any)
.bss:0000307C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000307C                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:0000307C ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:0000307C ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:0000307C                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:0000307C                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:0000307D                 db    ? ;
.bss:0000307E                 db    ? ;
.bss:0000307F                 db    ? ;
.bss:0000307F _bss            ends
.bss:0000307F
.bss:00003080 ; ===========================================================================
.bss:00003080
.bss:00003080 ; Segment type: Uninitialized
.bss:00003080 ; Segment permissions: Read/Write
.bss:00003080 _bss            segment dword public 'BSS' use32
.bss:00003080                 assume cs:_bss
.bss:00003080                 ;org 3080h
.bss:00003080 ; COMDAT (pick any)
.bss:00003080                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00003080                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00003080 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00003080 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00003080                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00003081                 db    ? ;
.bss:00003082                 db    ? ;
.bss:00003083                 db    ? ;
.bss:00003083 _bss            ends
.bss:00003083
.bss:00003084 ; ===========================================================================
.bss:00003084
.bss:00003084 ; Segment type: Uninitialized
.bss:00003084 ; Segment permissions: Read/Write
.bss:00003084 _bss            segment dword public 'BSS' use32
.bss:00003084                 assume cs:_bss
.bss:00003084                 ;org 3084h
.bss:00003084 ; COMDAT (pick any)
.bss:00003084                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00003084                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00003084 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00003084 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00003084                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00003085                 db    ? ;
.bss:00003086                 db    ? ;
.bss:00003087                 db    ? ;
.bss:00003087 _bss            ends
.bss:00003087
.rdata:00003088 ; ===========================================================================
.rdata:00003088
.rdata:00003088 ; Segment type: Pure data
.rdata:00003088 ; Segment permissions: Read
.rdata:00003088 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00003088 _rdata          segment para public 'DATA' use32
.rdata:00003088                 assume cs:_rdata
.rdata:00003088                 ;org 3088h
.rdata:00003088 ; COMDAT (pick any)
.rdata:00003088                 public ??_C@_1IC@ODAPDPOP@?$AAc?$AA?3?$AA?2?$AAw?$AAo?$AAr?$AAk?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?2?$AAn?$AAo?$AAt?$AAe?$AAp?$AAa?$AAd?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AA6@
.rdata:00003088 ; wchar_t `string'
.rdata:00003088 ??_C@_1IC@ODAPDPOP@?$AAc?$AA?3?$AA?2?$AAw?$AAo?$AAr?$AAk?$AAs?$AAp?$AAa?$AAc?$AAe?$AA?2?$AAn?$AAo?$AAt?$AAe?$AAp?$AAa?$AAd?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AAp?$AAl?$AAu?$AAs?$AA?9?$AA6@:
.rdata:00003088                                         ; DATA XREF: Utf8_Iter::get(void)+12o
.rdata:00003088                 unicode 0, <c:\workspace\notepad-plus-plus-6.7.9.2\powereditor\src\Ut>
.rdata:00003088                 unicode 0, <f8_16.h>,0
.rdata:0000310A                 align 4
.rdata:0000310A _rdata          ends
.rdata:0000310A
.rdata:0000310C ; ===========================================================================
.rdata:0000310C
.rdata:0000310C ; Segment type: Pure data
.rdata:0000310C ; Segment permissions: Read
.rdata:0000310C _rdata          segment dword public 'DATA' use32
.rdata:0000310C                 assume cs:_rdata
.rdata:0000310C                 ;org 310Ch
.rdata:0000310C ; COMDAT (pick any)
.rdata:0000310C                 public ??_C@_1CG@LBBANLDB@?$AAm?$AA_?$AAe?$AAS?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAe?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@
.rdata:0000310C ; wchar_t `string'
.rdata:0000310C ??_C@_1CG@LBBANLDB@?$AAm?$AA_?$AAe?$AAS?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAe?$AAS?$AAt?$AAa?$AAr?$AAt?$AA?$AA@:
.rdata:0000310C                                         ; DATA XREF: Utf8_Iter::get(void)+17o
.rdata:0000310C                 unicode 0, <m_eState == eStart>,0
.rdata:00003132                 align 4
.rdata:00003132 _rdata          ends
.rdata:00003132
.bss:00003134 ; ===========================================================================
.bss:00003134
.bss:00003134 ; Segment type: Uninitialized
.bss:00003134 ; Segment permissions: Read/Write
.bss:00003134 _bss            segment dword public 'BSS' use32
.bss:00003134                 assume cs:_bss
.bss:00003134                 ;org 3134h
.bss:00003134 ; COMDAT (pick any)
.bss:00003134                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00003134 ; unsigned int `public: unsigned int __thiscall Utf8_16_Read::convert(char *, unsigned int)'::`2'::nSkip
.bss:00003134 ?nSkip@?1??convert@Utf8_16_Read@@QAEIPADI@Z@4IA dd ?
.bss:00003134                                         ; DATA XREF: Utf8_16_Read::convert(char *,uint)+3Fw
.bss:00003134                                         ; Utf8_16_Read::convert(char *,uint)+9Cr ...
.bss:00003134 _bss            ends
.bss:00003134
.rdata:00003138 ; ===========================================================================
.rdata:00003138
.rdata:00003138 ; Segment type: Pure data
.rdata:00003138 ; Segment permissions: Read
.rdata:00003138 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00003138 _rdata          segment para public 'DATA' use32
.rdata:00003138                 assume cs:_rdata
.rdata:00003138                 ;org 3138h
.rdata:00003138 ; COMDAT (pick any)
.rdata:00003138                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00003138 ; wchar_t `string'
.rdata:00003138 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00003138                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00003138                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:00003138                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00003138                 unicode 0, <clude\xstring>,0
.rdata:000031C6                 align 4
.rdata:000031C6 _rdata          ends
.rdata:000031C6
.bss:000031C8 ; ===========================================================================
.bss:000031C8
.bss:000031C8 ; Segment type: Uninitialized
.bss:000031C8 ; Segment permissions: Read/Write
.bss:000031C8 _bss            segment dword public 'BSS' use32
.bss:000031C8                 assume cs:_bss
.bss:000031C8                 ;org 31C8h
.bss:000031C8 ; COMDAT (pick any)
.bss:000031C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000031C8                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:000031C8 ; std::locale::id std::numpunct<char>::id
.bss:000031C8 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:000031C8                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:000031C9                 db    ? ;
.bss:000031CA                 db    ? ;
.bss:000031CB                 db    ? ;
.bss:000031CB _bss            ends
.bss:000031CB
.bss:000031CC ; ===========================================================================
.bss:000031CC
.bss:000031CC ; Segment type: Uninitialized
.bss:000031CC ; Segment permissions: Read/Write
.bss:000031CC _bss            segment dword public 'BSS' use32
.bss:000031CC                 assume cs:_bss
.bss:000031CC                 ;org 31CCh
.bss:000031CC ; COMDAT (pick any)
.bss:000031CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000031CC                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:000031CC ; std::locale::id std::numpunct<wchar_t>::id
.bss:000031CC ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:000031CC                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:000031CD                 db    ? ;
.bss:000031CE                 db    ? ;
.bss:000031CF                 db    ? ;
.bss:000031CF _bss            ends
.bss:000031CF
.rdata:000031D0 ; ===========================================================================
.rdata:000031D0
.rdata:000031D0 ; Segment type: Pure data
.rdata:000031D0 ; Segment permissions: Read
.rdata:000031D0 _rdata          segment dword public 'DATA' use32
.rdata:000031D0                 assume cs:_rdata
.rdata:000031D0                 ;org 31D0h
.rdata:000031D0 ; COMDAT (pick any)
.rdata:000031D0                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:000031D0 ; char `string'[]
.rdata:000031D0 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:000031D0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:000031D0 _rdata          ends
.rdata:000031D0
.rdata:000031E0 ; ===========================================================================
.rdata:000031E0
.rdata:000031E0 ; Segment type: Pure data
.rdata:000031E0 ; Segment permissions: Read
.rdata:000031E0 _rdata          segment dword public 'DATA' use32
.rdata:000031E0                 assume cs:_rdata
.rdata:000031E0                 ;org 31E0h
.rdata:000031E0 ; COMDAT (pick any)
.rdata:000031E0                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:000031E0 ; char `string'[]
.rdata:000031E0 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:000031E0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:000031E0 _rdata          ends
.rdata:000031E0
.rdata:000031F8 ; ===========================================================================
.rdata:000031F8
.rdata:000031F8 ; Segment type: Pure data
.rdata:000031F8 ; Segment permissions: Read
.rdata:000031F8 _rdata          segment dword public 'DATA' use32
.rdata:000031F8                 assume cs:_rdata
.rdata:000031F8                 ;org 31F8h
.rdata:000031F8 ; COMDAT (pick any)
.rdata:000031F8                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:000031F8 ; wchar_t `string'
.rdata:000031F8 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:000031F8                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:000031F8                 unicode 0, <invalid null pointer>,0
.rdata:00003222                 align 4
.rdata:00003222 _rdata          ends
.rdata:00003222
.rdata$r:00003224 ; ===========================================================================
.rdata$r:00003224
.rdata$r:00003224 ; Segment type: Pure data
.rdata$r:00003224 ; Segment permissions: Read
.rdata$r:00003224 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003224                 assume cs:_rdata$r
.rdata$r:00003224                 ;org 3224h
.rdata$r:00003224 ; COMDAT (pick any)
.rdata$r:00003224                 public ??_R4error_category@std@@6B@
.rdata$r:00003224 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00003224 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00002FC0o
.rdata$r:00003225                 db    0
.rdata$r:00003226                 db    0
.rdata$r:00003227                 db    0
.rdata$r:00003228                 db    0
.rdata$r:00003229                 db    0
.rdata$r:0000322A                 db    0
.rdata$r:0000322B                 db    0
.rdata$r:0000322C                 db    0
.rdata$r:0000322D                 db    0
.rdata$r:0000322E                 db    0
.rdata$r:0000322F                 db    0
.rdata$r:00003230                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00003234                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003234 _rdata$r        ends
.rdata$r:00003234
.data$r:00003238 ; ===========================================================================
.data$r:00003238
.data$r:00003238 ; Segment type: Pure data
.data$r:00003238 ; Segment permissions: Read/Write
.data$r:00003238 _data$r         segment dword public 'DATA' use32
.data$r:00003238                 assume cs:_data$r
.data$r:00003238                 ;org 3238h
.data$r:00003238 ; COMDAT (pick any)
.data$r:00003238                 public ??_R0?AVerror_category@std@@@8
.data$r:00003238 ; class std::error_category `RTTI Type Descriptor'
.data$r:00003238 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003238                                         ; DATA XREF: .rdata$r:00003230o
.data$r:00003238                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003238                                         ; const type_info::`vftable'
.data$r:0000323C                 align 10h
.data$r:00003240 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:00003259                 align 4
.data$r:00003259 _data$r         ends
.data$r:00003259
.rdata$r:0000325C ; ===========================================================================
.rdata$r:0000325C
.rdata$r:0000325C ; Segment type: Pure data
.rdata$r:0000325C ; Segment permissions: Read
.rdata$r:0000325C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000325C                 assume cs:_rdata$r
.rdata$r:0000325C                 ;org 325Ch
.rdata$r:0000325C ; COMDAT (pick any)
.rdata$r:0000325C                 public ??_R3error_category@std@@8
.rdata$r:0000325C ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000325C ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00003234o
.rdata$r:0000325C                                         ; .rdata$r:0000328Co
.rdata$r:0000325D                 db    0
.rdata$r:0000325E                 db    0
.rdata$r:0000325F                 db    0
.rdata$r:00003260                 db    0
.rdata$r:00003261                 db    0
.rdata$r:00003262                 db    0
.rdata$r:00003263                 db    0
.rdata$r:00003264                 db    1
.rdata$r:00003265                 db    0
.rdata$r:00003266                 db    0
.rdata$r:00003267                 db    0
.rdata$r:00003268                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00003268 _rdata$r        ends
.rdata$r:00003268
.rdata$r:0000326C ; ===========================================================================
.rdata$r:0000326C
.rdata$r:0000326C ; Segment type: Pure data
.rdata$r:0000326C ; Segment permissions: Read
.rdata$r:0000326C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000326C                 assume cs:_rdata$r
.rdata$r:0000326C                 ;org 326Ch
.rdata$r:0000326C ; COMDAT (pick any)
.rdata$r:0000326C                 public ??_R2error_category@std@@8
.rdata$r:0000326C ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000326C ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000326C                                         ; DATA XREF: .rdata$r:00003268o
.rdata$r:0000326C                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003270                 db    0
.rdata$r:00003271                 align 4
.rdata$r:00003271 _rdata$r        ends
.rdata$r:00003271
.rdata$r:00003274 ; ===========================================================================
.rdata$r:00003274
.rdata$r:00003274 ; Segment type: Pure data
.rdata$r:00003274 ; Segment permissions: Read
.rdata$r:00003274 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003274                 assume cs:_rdata$r
.rdata$r:00003274                 ;org 3274h
.rdata$r:00003274 ; COMDAT (pick any)
.rdata$r:00003274                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00003274 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003274 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00003274                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00003274                                         ; .rdata$r:000032E4o ...
.rdata$r:00003274                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00003278                 align 10h
.rdata$r:00003280                 db 0FFh
.rdata$r:00003281                 db 0FFh
.rdata$r:00003282                 db 0FFh
.rdata$r:00003283                 db 0FFh
.rdata$r:00003284                 db    0
.rdata$r:00003285                 db    0
.rdata$r:00003286                 db    0
.rdata$r:00003287                 db    0
.rdata$r:00003288                 db  40h ; @
.rdata$r:00003289                 db    0
.rdata$r:0000328A                 db    0
.rdata$r:0000328B                 db    0
.rdata$r:0000328C                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000328C _rdata$r        ends
.rdata$r:0000328C
.rdata$r:00003290 ; ===========================================================================
.rdata$r:00003290
.rdata$r:00003290 ; Segment type: Pure data
.rdata$r:00003290 ; Segment permissions: Read
.rdata$r:00003290 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003290                 assume cs:_rdata$r
.rdata$r:00003290                 ;org 3290h
.rdata$r:00003290 ; COMDAT (pick any)
.rdata$r:00003290                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00003290 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00003290 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00003290                                         ; DATA XREF: .rdata:00002FDCo
.rdata$r:00003291                 db    0
.rdata$r:00003292                 db    0
.rdata$r:00003293                 db    0
.rdata$r:00003294                 db    0
.rdata$r:00003295                 db    0
.rdata$r:00003296                 db    0
.rdata$r:00003297                 db    0
.rdata$r:00003298                 db    0
.rdata$r:00003299                 db    0
.rdata$r:0000329A                 db    0
.rdata$r:0000329B                 db    0
.rdata$r:0000329C                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:000032A0                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000032A0 _rdata$r        ends
.rdata$r:000032A0
.data$r:000032A4 ; ===========================================================================
.data$r:000032A4
.data$r:000032A4 ; Segment type: Pure data
.data$r:000032A4 ; Segment permissions: Read/Write
.data$r:000032A4 _data$r         segment dword public 'DATA' use32
.data$r:000032A4                 assume cs:_data$r
.data$r:000032A4                 ;org 32A4h
.data$r:000032A4 ; COMDAT (pick any)
.data$r:000032A4                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:000032A4 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:000032A4 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000032A4                                         ; DATA XREF: .rdata$r:0000329Co
.data$r:000032A4                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000032A4                                         ; const type_info::`vftable'
.data$r:000032A8                 db    0
.data$r:000032A9                 db    0
.data$r:000032AA                 db    0
.data$r:000032AB                 db    0
.data$r:000032AC                 db  2Eh ; .
.data$r:000032AD                 db  3Fh ; ?
.data$r:000032AE                 db  41h ; A
.data$r:000032AF                 db  56h ; V
.data$r:000032B0                 db  5Fh ; _
.data$r:000032B1                 db  47h ; G
.data$r:000032B2                 db  65h ; e
.data$r:000032B3                 db  6Eh ; n
.data$r:000032B4                 db  65h ; e
.data$r:000032B5                 db  72h ; r
.data$r:000032B6                 db  69h ; i
.data$r:000032B7                 db  63h ; c
.data$r:000032B8                 db  5Fh ; _
.data$r:000032B9                 db  65h ; e
.data$r:000032BA                 db  72h ; r
.data$r:000032BB                 db  72h ; r
.data$r:000032BC                 db  6Fh ; o
.data$r:000032BD                 db  72h ; r
.data$r:000032BE                 db  5Fh ; _
.data$r:000032BF                 db  63h ; c
.data$r:000032C0                 db  61h ; a
.data$r:000032C1                 db  74h ; t
.data$r:000032C2                 db  65h ; e
.data$r:000032C3                 db  67h ; g
.data$r:000032C4                 db  6Fh ; o
.data$r:000032C5                 db  72h ; r
.data$r:000032C6                 db  79h ; y
.data$r:000032C7                 db  40h ; @
.data$r:000032C8                 db  73h ; s
.data$r:000032C9                 db  74h ; t
.data$r:000032CA                 db  64h ; d
.data$r:000032CB                 db  40h ; @
.data$r:000032CC                 db  40h ; @
.data$r:000032CD                 db    0
.data$r:000032CE                 align 10h
.data$r:000032CE _data$r         ends
.data$r:000032CE
.rdata$r:000032D0 ; ===========================================================================
.rdata$r:000032D0
.rdata$r:000032D0 ; Segment type: Pure data
.rdata$r:000032D0 ; Segment permissions: Read
.rdata$r:000032D0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000032D0                 assume cs:_rdata$r
.rdata$r:000032D0                 ;org 32D0h
.rdata$r:000032D0 ; COMDAT (pick any)
.rdata$r:000032D0                 public ??_R3_Generic_error_category@std@@8
.rdata$r:000032D0 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000032D0 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:000032D0                                         ; DATA XREF: .rdata$r:000032A0o
.rdata$r:000032D0                                         ; .rdata$r:00003304o
.rdata$r:000032D1                 db    0
.rdata$r:000032D2                 db    0
.rdata$r:000032D3                 db    0
.rdata$r:000032D4                 db    0
.rdata$r:000032D5                 db    0
.rdata$r:000032D6                 db    0
.rdata$r:000032D7                 db    0
.rdata$r:000032D8                 db    2
.rdata$r:000032D9                 db    0
.rdata$r:000032DA                 db    0
.rdata$r:000032DB                 db    0
.rdata$r:000032DC                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000032DC _rdata$r        ends
.rdata$r:000032DC
.rdata$r:000032E0 ; ===========================================================================
.rdata$r:000032E0
.rdata$r:000032E0 ; Segment type: Pure data
.rdata$r:000032E0 ; Segment permissions: Read
.rdata$r:000032E0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000032E0                 assume cs:_rdata$r
.rdata$r:000032E0                 ;org 32E0h
.rdata$r:000032E0 ; COMDAT (pick any)
.rdata$r:000032E0                 public ??_R2_Generic_error_category@std@@8
.rdata$r:000032E0 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000032E0 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:000032E0                                         ; DATA XREF: .rdata$r:000032DCo
.rdata$r:000032E0                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000032E4                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000032E8                 db    0
.rdata$r:000032E9                 align 4
.rdata$r:000032E9 _rdata$r        ends
.rdata$r:000032E9
.rdata$r:000032EC ; ===========================================================================
.rdata$r:000032EC
.rdata$r:000032EC ; Segment type: Pure data
.rdata$r:000032EC ; Segment permissions: Read
.rdata$r:000032EC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000032EC                 assume cs:_rdata$r
.rdata$r:000032EC                 ;org 32ECh
.rdata$r:000032EC ; COMDAT (pick any)
.rdata$r:000032EC                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:000032EC ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000032EC ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:000032EC                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:000032EC                                         ; .rdata$r:0000335Co ...
.rdata$r:000032EC                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:000032F0                 db    1
.rdata$r:000032F1                 db    0
.rdata$r:000032F2                 db    0
.rdata$r:000032F3                 db    0
.rdata$r:000032F4                 db    0
.rdata$r:000032F5                 db    0
.rdata$r:000032F6                 db    0
.rdata$r:000032F7                 db    0
.rdata$r:000032F8                 db 0FFh
.rdata$r:000032F9                 db 0FFh
.rdata$r:000032FA                 db 0FFh
.rdata$r:000032FB                 db 0FFh
.rdata$r:000032FC                 db    0
.rdata$r:000032FD                 db    0
.rdata$r:000032FE                 db    0
.rdata$r:000032FF                 db    0
.rdata$r:00003300                 db  40h ; @
.rdata$r:00003301                 db    0
.rdata$r:00003302                 db    0
.rdata$r:00003303                 db    0
.rdata$r:00003304                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003304 _rdata$r        ends
.rdata$r:00003304
.rdata$r:00003308 ; ===========================================================================
.rdata$r:00003308
.rdata$r:00003308 ; Segment type: Pure data
.rdata$r:00003308 ; Segment permissions: Read
.rdata$r:00003308 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003308                 assume cs:_rdata$r
.rdata$r:00003308                 ;org 3308h
.rdata$r:00003308 ; COMDAT (pick any)
.rdata$r:00003308                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00003308 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00003308 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00003308                                         ; DATA XREF: .rdata:00003010o
.rdata$r:00003309                 db    0
.rdata$r:0000330A                 db    0
.rdata$r:0000330B                 db    0
.rdata$r:0000330C                 db    0
.rdata$r:0000330D                 db    0
.rdata$r:0000330E                 db    0
.rdata$r:0000330F                 db    0
.rdata$r:00003310                 db    0
.rdata$r:00003311                 db    0
.rdata$r:00003312                 db    0
.rdata$r:00003313                 db    0
.rdata$r:00003314                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00003318                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003318 _rdata$r        ends
.rdata$r:00003318
.data$r:0000331C ; ===========================================================================
.data$r:0000331C
.data$r:0000331C ; Segment type: Pure data
.data$r:0000331C ; Segment permissions: Read/Write
.data$r:0000331C _data$r         segment dword public 'DATA' use32
.data$r:0000331C                 assume cs:_data$r
.data$r:0000331C                 ;org 331Ch
.data$r:0000331C ; COMDAT (pick any)
.data$r:0000331C                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:0000331C ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:0000331C ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000331C                                         ; DATA XREF: .rdata$r:00003314o
.data$r:0000331C                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000331C                                         ; const type_info::`vftable'
.data$r:00003320                 db    0
.data$r:00003321                 db    0
.data$r:00003322                 db    0
.data$r:00003323                 db    0
.data$r:00003324                 db  2Eh ; .
.data$r:00003325                 db  3Fh ; ?
.data$r:00003326                 db  41h ; A
.data$r:00003327                 db  56h ; V
.data$r:00003328                 db  5Fh ; _
.data$r:00003329                 db  49h ; I
.data$r:0000332A                 db  6Fh ; o
.data$r:0000332B                 db  73h ; s
.data$r:0000332C                 db  74h ; t
.data$r:0000332D                 db  72h ; r
.data$r:0000332E                 db  65h ; e
.data$r:0000332F                 db  61h ; a
.data$r:00003330                 db  6Dh ; m
.data$r:00003331                 db  5Fh ; _
.data$r:00003332                 db  65h ; e
.data$r:00003333                 db  72h ; r
.data$r:00003334                 db  72h ; r
.data$r:00003335                 db  6Fh ; o
.data$r:00003336                 db  72h ; r
.data$r:00003337                 db  5Fh ; _
.data$r:00003338                 db  63h ; c
.data$r:00003339                 db  61h ; a
.data$r:0000333A                 db  74h ; t
.data$r:0000333B                 db  65h ; e
.data$r:0000333C                 db  67h ; g
.data$r:0000333D                 db  6Fh ; o
.data$r:0000333E                 db  72h ; r
.data$r:0000333F                 db  79h ; y
.data$r:00003340                 db  40h ; @
.data$r:00003341                 db  73h ; s
.data$r:00003342                 db  74h ; t
.data$r:00003343                 db  64h ; d
.data$r:00003344                 db  40h ; @
.data$r:00003345                 db  40h ; @
.data$r:00003346                 db    0
.data$r:00003347                 align 4
.data$r:00003347 _data$r         ends
.data$r:00003347
.rdata$r:00003348 ; ===========================================================================
.rdata$r:00003348
.rdata$r:00003348 ; Segment type: Pure data
.rdata$r:00003348 ; Segment permissions: Read
.rdata$r:00003348 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003348                 assume cs:_rdata$r
.rdata$r:00003348                 ;org 3348h
.rdata$r:00003348 ; COMDAT (pick any)
.rdata$r:00003348                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00003348 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003348 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00003348                                         ; DATA XREF: .rdata$r:00003318o
.rdata$r:00003348                                         ; .rdata$r:00003380o
.rdata$r:00003349                 db    0
.rdata$r:0000334A                 db    0
.rdata$r:0000334B                 db    0
.rdata$r:0000334C                 db    0
.rdata$r:0000334D                 db    0
.rdata$r:0000334E                 db    0
.rdata$r:0000334F                 db    0
.rdata$r:00003350                 db    3
.rdata$r:00003351                 db    0
.rdata$r:00003352                 db    0
.rdata$r:00003353                 db    0
.rdata$r:00003354                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00003354 _rdata$r        ends
.rdata$r:00003354
.rdata$r:00003358 ; ===========================================================================
.rdata$r:00003358
.rdata$r:00003358 ; Segment type: Pure data
.rdata$r:00003358 ; Segment permissions: Read
.rdata$r:00003358 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003358                 assume cs:_rdata$r
.rdata$r:00003358                 ;org 3358h
.rdata$r:00003358 ; COMDAT (pick any)
.rdata$r:00003358                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00003358 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00003358 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00003358                                         ; DATA XREF: .rdata$r:00003354o
.rdata$r:00003358                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000335C                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003360                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003364                 db    0
.rdata$r:00003365                 align 4
.rdata$r:00003365 _rdata$r        ends
.rdata$r:00003365
.rdata$r:00003368 ; ===========================================================================
.rdata$r:00003368
.rdata$r:00003368 ; Segment type: Pure data
.rdata$r:00003368 ; Segment permissions: Read
.rdata$r:00003368 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003368                 assume cs:_rdata$r
.rdata$r:00003368                 ;org 3368h
.rdata$r:00003368 ; COMDAT (pick any)
.rdata$r:00003368                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00003368 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003368 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00003368                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00003368                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000336C                 db    2
.rdata$r:0000336D                 db    0
.rdata$r:0000336E                 db    0
.rdata$r:0000336F                 db    0
.rdata$r:00003370                 db    0
.rdata$r:00003371                 db    0
.rdata$r:00003372                 db    0
.rdata$r:00003373                 db    0
.rdata$r:00003374                 db 0FFh
.rdata$r:00003375                 db 0FFh
.rdata$r:00003376                 db 0FFh
.rdata$r:00003377                 db 0FFh
.rdata$r:00003378                 db    0
.rdata$r:00003379                 db    0
.rdata$r:0000337A                 db    0
.rdata$r:0000337B                 db    0
.rdata$r:0000337C                 db  40h ; @
.rdata$r:0000337D                 db    0
.rdata$r:0000337E                 db    0
.rdata$r:0000337F                 db    0
.rdata$r:00003380                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003380 _rdata$r        ends
.rdata$r:00003380
.rdata$r:00003384 ; ===========================================================================
.rdata$r:00003384
.rdata$r:00003384 ; Segment type: Pure data
.rdata$r:00003384 ; Segment permissions: Read
.rdata$r:00003384 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003384                 assume cs:_rdata$r
.rdata$r:00003384                 ;org 3384h
.rdata$r:00003384 ; COMDAT (pick any)
.rdata$r:00003384                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00003384 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00003384 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00003050o
.rdata$r:00003385                 db    0
.rdata$r:00003386                 db    0
.rdata$r:00003387                 db    0
.rdata$r:00003388                 db    0
.rdata$r:00003389                 db    0
.rdata$r:0000338A                 db    0
.rdata$r:0000338B                 db    0
.rdata$r:0000338C                 db    0
.rdata$r:0000338D                 db    0
.rdata$r:0000338E                 db    0
.rdata$r:0000338F                 db    0
.rdata$r:00003390                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00003394                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003394 _rdata$r        ends
.rdata$r:00003394
.data$r:00003398 ; ===========================================================================
.data$r:00003398
.data$r:00003398 ; Segment type: Pure data
.data$r:00003398 ; Segment permissions: Read/Write
.data$r:00003398 _data$r         segment dword public 'DATA' use32
.data$r:00003398                 assume cs:_data$r
.data$r:00003398                 ;org 3398h
.data$r:00003398 ; COMDAT (pick any)
.data$r:00003398                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00003398 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00003398 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003398                                         ; DATA XREF: .rdata$r:00003390o
.data$r:00003398                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003398                                         ; const type_info::`vftable'
.data$r:0000339C                 align 10h
.data$r:000033A0 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:000033C1                 align 4
.data$r:000033C1 _data$r         ends
.data$r:000033C1
.rdata$r:000033C4 ; ===========================================================================
.rdata$r:000033C4
.rdata$r:000033C4 ; Segment type: Pure data
.rdata$r:000033C4 ; Segment permissions: Read
.rdata$r:000033C4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000033C4                 assume cs:_rdata$r
.rdata$r:000033C4                 ;org 33C4h
.rdata$r:000033C4 ; COMDAT (pick any)
.rdata$r:000033C4                 public ??_R3_System_error_category@std@@8
.rdata$r:000033C4 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000033C4 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00003394o
.rdata$r:000033C4                                         ; .rdata$r:000033FCo
.rdata$r:000033C5                 db    0
.rdata$r:000033C6                 db    0
.rdata$r:000033C7                 db    0
.rdata$r:000033C8                 db    0
.rdata$r:000033C9                 db    0
.rdata$r:000033CA                 db    0
.rdata$r:000033CB                 db    0
.rdata$r:000033CC                 db    3
.rdata$r:000033CD                 db    0
.rdata$r:000033CE                 db    0
.rdata$r:000033CF                 db    0
.rdata$r:000033D0                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:000033D0 _rdata$r        ends
.rdata$r:000033D0
.rdata$r:000033D4 ; ===========================================================================
.rdata$r:000033D4
.rdata$r:000033D4 ; Segment type: Pure data
.rdata$r:000033D4 ; Segment permissions: Read
.rdata$r:000033D4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000033D4                 assume cs:_rdata$r
.rdata$r:000033D4                 ;org 33D4h
.rdata$r:000033D4 ; COMDAT (pick any)
.rdata$r:000033D4                 public ??_R2_System_error_category@std@@8
.rdata$r:000033D4 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:000033D4 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:000033D4                                         ; DATA XREF: .rdata$r:000033D0o
.rdata$r:000033D4                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000033D8                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000033DC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000033E0                 db    0
.rdata$r:000033E1                 align 4
.rdata$r:000033E1 _rdata$r        ends
.rdata$r:000033E1
.rdata$r:000033E4 ; ===========================================================================
.rdata$r:000033E4
.rdata$r:000033E4 ; Segment type: Pure data
.rdata$r:000033E4 ; Segment permissions: Read
.rdata$r:000033E4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000033E4                 assume cs:_rdata$r
.rdata$r:000033E4                 ;org 33E4h
.rdata$r:000033E4 ; COMDAT (pick any)
.rdata$r:000033E4                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:000033E4 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000033E4 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:000033E4                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:000033E4                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:000033E8                 db    2
.rdata$r:000033E9                 db    0
.rdata$r:000033EA                 db    0
.rdata$r:000033EB                 db    0
.rdata$r:000033EC                 db    0
.rdata$r:000033ED                 db    0
.rdata$r:000033EE                 db    0
.rdata$r:000033EF                 db    0
.rdata$r:000033F0                 db 0FFh
.rdata$r:000033F1                 db 0FFh
.rdata$r:000033F2                 db 0FFh
.rdata$r:000033F3                 db 0FFh
.rdata$r:000033F4                 db    0
.rdata$r:000033F5                 db    0
.rdata$r:000033F6                 db    0
.rdata$r:000033F7                 db    0
.rdata$r:000033F8                 db  40h ; @
.rdata$r:000033F9                 db    0
.rdata$r:000033FA                 db    0
.rdata$r:000033FB                 db    0
.rdata$r:000033FC                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000033FC _rdata$r        ends
.rdata$r:000033FC
.CRT$XCU:00003400 ; ===========================================================================
.CRT$XCU:00003400
.CRT$XCU:00003400 ; Segment type: Pure data
.CRT$XCU:00003400 ; Segment permissions: Read
.CRT$XCU:00003400 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003400                 assume cs:_CRT$XCU
.CRT$XCU:00003400                 ;org 3400h
.CRT$XCU:00003400 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00003404 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00003404 _CRT$XCU        ends
.CRT$XCU:00003404
.CRT$XCU:00003408 ; ===========================================================================
.CRT$XCU:00003408
.CRT$XCU:00003408 ; Segment type: Pure data
.CRT$XCU:00003408 ; Segment permissions: Read
.CRT$XCU:00003408 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003408                 assume cs:_CRT$XCU
.CRT$XCU:00003408                 ;org 3408h
.CRT$XCU:00003408 ; COMDAT (pick associative to section at 3074)
.CRT$XCU:00003408 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00003408 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00003408 _CRT$XCU        ends
.CRT$XCU:00003408
.CRT$XCU:0000340C ; ===========================================================================
.CRT$XCU:0000340C
.CRT$XCU:0000340C ; Segment type: Pure data
.CRT$XCU:0000340C ; Segment permissions: Read
.CRT$XCU:0000340C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000340C                 assume cs:_CRT$XCU
.CRT$XCU:0000340C                 ;org 340Ch
.CRT$XCU:0000340C ; COMDAT (pick associative to section at 3078)
.CRT$XCU:0000340C ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:0000340C ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:0000340C _CRT$XCU        ends
.CRT$XCU:0000340C
.CRT$XCU:00003410 ; ===========================================================================
.CRT$XCU:00003410
.CRT$XCU:00003410 ; Segment type: Pure data
.CRT$XCU:00003410 ; Segment permissions: Read
.CRT$XCU:00003410 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003410                 assume cs:_CRT$XCU
.CRT$XCU:00003410                 ;org 3410h
.CRT$XCU:00003410 ; COMDAT (pick associative to section at 307C)
.CRT$XCU:00003410 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00003410 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00003410 _CRT$XCU        ends
.CRT$XCU:00003410
.CRT$XCU:00003414 ; ===========================================================================
.CRT$XCU:00003414
.CRT$XCU:00003414 ; Segment type: Pure data
.CRT$XCU:00003414 ; Segment permissions: Read
.CRT$XCU:00003414 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003414                 assume cs:_CRT$XCU
.CRT$XCU:00003414                 ;org 3414h
.CRT$XCU:00003414 ; COMDAT (pick associative to section at 3080)
.CRT$XCU:00003414 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00003414 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00003414 _CRT$XCU        ends
.CRT$XCU:00003414
.CRT$XCU:00003418 ; ===========================================================================
.CRT$XCU:00003418
.CRT$XCU:00003418 ; Segment type: Pure data
.CRT$XCU:00003418 ; Segment permissions: Read
.CRT$XCU:00003418 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003418                 assume cs:_CRT$XCU
.CRT$XCU:00003418                 ;org 3418h
.CRT$XCU:00003418 ; COMDAT (pick associative to section at 3084)
.CRT$XCU:00003418 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:00003418 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:00003418 _CRT$XCU        ends
.CRT$XCU:00003418
.CRT$XCU:0000341C ; ===========================================================================
.CRT$XCU:0000341C
.CRT$XCU:0000341C ; Segment type: Pure data
.CRT$XCU:0000341C ; Segment permissions: Read
.CRT$XCU:0000341C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000341C                 assume cs:_CRT$XCU
.CRT$XCU:0000341C                 ;org 341Ch
.CRT$XCU:0000341C ; COMDAT (pick associative to section at 31C8)
.CRT$XCU:0000341C ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:0000341C ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:0000341C _CRT$XCU        ends
.CRT$XCU:0000341C
.CRT$XCU:00003420 ; ===========================================================================
.CRT$XCU:00003420
.CRT$XCU:00003420 ; Segment type: Pure data
.CRT$XCU:00003420 ; Segment permissions: Read
.CRT$XCU:00003420 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003420                 assume cs:_CRT$XCU
.CRT$XCU:00003420                 ;org 3420h
.CRT$XCU:00003420 ; COMDAT (pick associative to section at 31CC)
.CRT$XCU:00003420 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00003420 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00003420 _CRT$XCU        ends
.CRT$XCU:00003420
UNDEF:00003430 ; ===========================================================================
UNDEF:00003430
UNDEF:00003430 ; Segment type: Externs
UNDEF:00003430 ; UNDEF
UNDEF:00003430                 extrn __purecall:near   ; DATA XREF: .rdata:00002FC8o
UNDEF:00003430                                         ; .rdata:00002FCCo
UNDEF:00003434 ; void *__cdecl operator new(unsigned int)
UNDEF:00003434                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00003434                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p
UNDEF:00003438 ; void __cdecl operator delete(void *)
UNDEF:00003438                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:00003438                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:0000343C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000343C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000343C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00003440 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00003440                 extrn _memcpy:near      ; CODE XREF: Utf8_16_Write::convert(char *,uint)+76p
UNDEF:00003440                                         ; Utf8_16_Write::convert(char *,uint)+BFp ...
UNDEF:00003444 ; size_t __cdecl strlen(const char *Str)
UNDEF:00003444                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00003448 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00003448                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:0000344C ; BOOL __stdcall IsTextUnicode(const void *lpv, int iSize, LPINT lpiResult)
UNDEF:0000344C                 extrn __imp__IsTextUnicode@12:near
UNDEF:0000344C                                         ; CODE XREF: Utf8_16_Read::determineEncoding(void)+20Fp
UNDEF:0000344C                                         ; DATA XREF: Utf8_16_Read::determineEncoding(void)+20Fr
UNDEF:00003450 ; int __cdecl fclose(FILE *File)
UNDEF:00003450                 extrn _fclose:near      ; CODE XREF: Utf8_16_Write::fclose(void)+37p
UNDEF:00003454 ; size_t __cdecl fwrite(const void *Str, size_t Size, size_t Count, FILE *File)
UNDEF:00003454                 extrn _fwrite:near      ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint)+95p
UNDEF:00003454                                         ; Utf8_16_Write::fwrite(void const *,uint)+BCp ...
UNDEF:00003458 ; FILE *__cdecl _wfopen(const wchar_t *Filename, const wchar_t *Mode)
UNDEF:00003458                 extrn __wfopen:near     ; CODE XREF: Utf8_16_Write::fopen(wchar_t const *,wchar_t const *)+Fp
UNDEF:0000345C ; void __cdecl _wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
UNDEF:0000345C                 extrn __wassert:near    ; CODE XREF: Utf8_Iter::get(void)+1Cp
UNDEF:00003460 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00003460                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00003460                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00003464 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00003464                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00003464                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00003464                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:00003468                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:0000346C ; void __cdecl operator delete[](void *)
UNDEF:0000346C                 extrn ??_V@YAXPAX@Z:near
UNDEF:0000346C                                         ; CODE XREF: Utf8_16_Read::~Utf8_16_Read(void)+36p
UNDEF:0000346C                                         ; Utf8_16_Read::convert(char *,uint)+ECp ...
UNDEF:00003470 ; void *__cdecl operator new[](unsigned int)
UNDEF:00003470                 extrn ??_U@YAPAXI@Z:near
UNDEF:00003470                                         ; CODE XREF: Utf8_16_Read::convert(char *,uint)+102p
UNDEF:00003470                                         ; Utf8_16_Write::convert(char *,uint)+53p ...
UNDEF:00003474 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00003474                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00003474                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00003478 ; void __cdecl std::_Xbad_alloc()
UNDEF:00003478                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00003478                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_1262p
UNDEF:00003478                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_12A4p
UNDEF:0000347C ; void __cdecl std::_Xlength_error(const char *)
UNDEF:0000347C                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:0000347C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00003480 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00003480                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00003480                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00003484 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003484                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003484                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00003488 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00003488                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00003488                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00003488                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:0000348C ; const char *__cdecl std::_Winerror_map(int)
UNDEF:0000348C                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:0000348C                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00003490 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003490                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003490                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00003494 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003494                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003494                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00003498 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003498                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003498                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:0000349C ; __fastcall __security_check_cookie(x)
UNDEF:0000349C                 extrn @__security_check_cookie@4:near
UNDEF:0000349C                                         ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint)+21Ep
UNDEF:0000349C                                         ; __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+Cp ...
UNDEF:000034A0 ; __stdcall _CxxThrowException(x, x)
UNDEF:000034A0                 extrn __CxxThrowException@8:near
UNDEF:000034A0                                         ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:000034A4                 extrn ___CxxFrameHandler3:near
UNDEF:000034A4                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j
UNDEF:000034A4                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+16j ...
UNDEF:000034A8                 extrn __chkstk:near     ; CODE XREF: Utf8_16_Write::fwrite(void const *,uint)+8p
UNDEF:000034AC ; const type_info::`vftable'
UNDEF:000034AC                 extrn ??_7type_info@@6B@:near
UNDEF:000034AC                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:000034AC                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:000034B0                 extrn ___security_cookie:near
UNDEF:000034B0                                         ; DATA XREF: Utf8_16_Write::fwrite(void const *,uint)+Dr
UNDEF:000034B0                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+14r ...
UNDEF:000034B4                 extrn __fltused:near
UNDEF:000034B4
UNDEF:000034B4
UNDEF:000034B4                 end