.data:00000000 ;
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.data:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.data:00000000 ; |                      License info: 48-3677-7074-51                      |
.data:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ;
.data:00000000 ; Input MD5   : 3FC29037609927B7EC4309BFC186431C
.data:00000000 ; Input CRC32 : 7DCB9A8D
.data:00000000
.data:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\URLCtrl.obj
.data:00000000 ; Format      : COFF (X386MAGIC)
.data:00000000 ; includelib "uuid.lib"
.data:00000000 ; includelib "libcpmtd"
.data:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.data:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.data:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.data:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.data:00000000 ; includelib "LIBCMTD"
.data:00000000 ; includelib "OLDNAMES"
.data:00000000
.data:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.data:00000000
.data:00000000                 .686p
.data:00000000                 .mmx
.data:00000000                 .model flat
.data:00000000
.data:00000000 ; ===========================================================================
.data:00000000
.data:00000000 ; Segment type: Pure data
.data:00000000 ; Segment permissions: Read/Write
.data:00000000 ; Segment alignment 'qword' can not be represented in assembly
.data:00000000 _data           segment para public 'DATA' use32
.data:00000000                 assume cs:_data
.data:00000000 _XORMask        db 0FFh                 ; DATA XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+297o
.data:00000001                 db 0FFh
.data:00000002                 db 0FFh
.data:00000003                 db 0FFh
.data:00000004                 db 0F9h ; ·
.data:00000005                 db 0FFh
.data:00000006                 db 0FFh
.data:00000007                 db 0FFh
.data:00000008                 db 0F0h ; =
.data:00000009                 db 0FFh
.data:0000000A                 db 0FFh
.data:0000000B                 db 0FFh
.data:0000000C                 db 0F0h ; =
.data:0000000D                 db 0FFh
.data:0000000E                 db 0FFh
.data:0000000F                 db 0FFh
.data:00000010                 db 0F0h ; =
.data:00000011                 db 0FFh
.data:00000012                 db 0FFh
.data:00000013                 db 0FFh
.data:00000014                 db 0F0h ; =
.data:00000015                 db 0FFh
.data:00000016                 db 0FFh
.data:00000017                 db 0FFh
.data:00000018                 db 0F0h ; =
.data:00000019                 db  24h ; $
.data:0000001A                 db 0FFh
.data:0000001B                 db 0FFh
.data:0000001C                 db 0F0h ; =
.data:0000001D                 db    0
.data:0000001E                 db  7Fh ; 
.data:0000001F                 db 0FFh
.data:00000020                 db 0C0h ; +
.data:00000021                 db    0
.data:00000022                 db  7Fh ; 
.data:00000023                 db 0FFh
.data:00000024                 db  80h ; Ç
.data:00000025                 db    0
.data:00000026                 db  7Fh ; 
.data:00000027                 db 0FFh
.data:00000028                 db  80h ; Ç
.data:00000029                 db    0
.data:0000002A                 db  7Fh ; 
.data:0000002B                 db 0FFh
.data:0000002C                 db  80h ; Ç
.data:0000002D                 db    0
.data:0000002E                 db  7Fh ; 
.data:0000002F                 db 0FFh
.data:00000030                 db  80h ; Ç
.data:00000031                 db    0
.data:00000032                 db  7Fh ; 
.data:00000033                 db 0FFh
.data:00000034                 db  80h ; Ç
.data:00000035                 db    0
.data:00000036                 db  7Fh ; 
.data:00000037                 db 0FFh
.data:00000038                 db 0C0h ; +
.data:00000039                 db    0
.data:0000003A                 db  7Fh ; 
.data:0000003B                 db 0FFh
.data:0000003C                 db 0E0h ; a
.data:0000003D                 db    0
.data:0000003E                 db  7Fh ; 
.data:0000003F                 db 0FFh
.data:00000040                 db 0F0h ; =
.data:00000041                 db    0
.data:00000042                 db 0FFh
.data:00000043                 db 0FFh
.data:00000044                 db 0F0h ; =
.data:00000045                 db    0
.data:00000046                 db 0FFh
.data:00000047                 db 0FFh
.data:00000048                 db 0F0h ; =
.data:00000049                 db    0
.data:0000004A                 db 0FFh
.data:0000004B                 db 0FFh
.data:0000004C                 db 0FFh
.data:0000004D                 db 0FFh
.data:0000004E                 db 0FFh
.data:0000004F                 db 0FFh
.data:00000050                 db 0FFh
.data:00000051                 db 0FFh
.data:00000052                 db 0FFh
.data:00000053                 db 0FFh
.data:00000054                 db 0FFh
.data:00000055                 db 0FFh
.data:00000056                 db 0FFh
.data:00000057                 db 0FFh
.data:00000058                 db 0FFh
.data:00000059                 db 0FFh
.data:0000005A                 db 0FFh
.data:0000005B                 db 0FFh
.data:0000005C                 db 0FFh
.data:0000005D                 db 0FFh
.data:0000005E                 db 0FFh
.data:0000005F                 db 0FFh
.data:00000060                 db 0FFh
.data:00000061                 db 0FFh
.data:00000062                 db 0FFh
.data:00000063                 db 0FFh
.data:00000064                 db 0FFh
.data:00000065                 db 0FFh
.data:00000066                 db 0FFh
.data:00000067                 db 0FFh
.data:00000068                 db 0FFh
.data:00000069                 db 0FFh
.data:0000006A                 db 0FFh
.data:0000006B                 db 0FFh
.data:0000006C                 db 0FFh
.data:0000006D                 db 0FFh
.data:0000006E                 db 0FFh
.data:0000006F                 db 0FFh
.data:00000070                 db 0FFh
.data:00000071                 db 0FFh
.data:00000072                 db 0FFh
.data:00000073                 db 0FFh
.data:00000074                 db 0FFh
.data:00000075                 db 0FFh
.data:00000076                 db 0FFh
.data:00000077                 db 0FFh
.data:00000078                 db 0FFh
.data:00000079                 db 0FFh
.data:0000007A                 db 0FFh
.data:0000007B                 db 0FFh
.data:0000007C                 db 0FFh
.data:0000007D                 db 0FFh
.data:0000007E                 db 0FFh
.data:0000007F                 db 0FFh
.data:00000080 _ANDMask        db    0                 ; DATA XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+292o
.data:00000081                 db    0
.data:00000082                 db    0
.data:00000083                 db    0
.data:00000084                 db    0
.data:00000085                 db    0
.data:00000086                 db    0
.data:00000087                 db    0
.data:00000088                 db    6
.data:00000089                 db    0
.data:0000008A                 db    0
.data:0000008B                 db    0
.data:0000008C                 db    6
.data:0000008D                 db    0
.data:0000008E                 db    0
.data:0000008F                 db    0
.data:00000090                 db    6
.data:00000091                 db    0
.data:00000092                 db    0
.data:00000093                 db    0
.data:00000094                 db    6
.data:00000095                 db    0
.data:00000096                 db    0
.data:00000097                 db    0
.data:00000098                 db    6
.data:00000099                 db    0
.data:0000009A                 db    0
.data:0000009B                 db    0
.data:0000009C                 db    6
.data:0000009D                 db 0DBh ; ¦
.data:0000009E                 db    0
.data:0000009F                 db    0
.data:000000A0                 db    6
.data:000000A1                 db 0DBh ; ¦
.data:000000A2                 db    0
.data:000000A3                 db    0
.data:000000A4                 db  36h ; 6
.data:000000A5                 db 0DBh ; ¦
.data:000000A6                 db    0
.data:000000A7                 db    0
.data:000000A8                 db  36h ; 6
.data:000000A9                 db 0DBh ; ¦
.data:000000AA                 db    0
.data:000000AB                 db    0
.data:000000AC                 db  37h ; 7
.data:000000AD                 db 0FFh
.data:000000AE                 db    0
.data:000000AF                 db    0
.data:000000B0                 db  3Fh ; ?
.data:000000B1                 db 0FFh
.data:000000B2                 db    0
.data:000000B3                 db    0
.data:000000B4                 db  3Fh ; ?
.data:000000B5                 db 0FFh
.data:000000B6                 db    0
.data:000000B7                 db    0
.data:000000B8                 db  1Fh
.data:000000B9                 db 0FFh
.data:000000BA                 db    0
.data:000000BB                 db    0
.data:000000BC                 db  0Fh
.data:000000BD                 db 0FFh
.data:000000BE                 db    0
.data:000000BF                 db    0
.data:000000C0                 db    7
.data:000000C1                 db 0FEh ; ¦
.data:000000C2                 db    0
.data:000000C3                 db    0
.data:000000C4                 db    0
.data:000000C5                 db    0
.data:000000C6                 db    0
.data:000000C7                 db    0
.data:000000C8                 db    0
.data:000000C9                 db    0
.data:000000CA                 db    0
.data:000000CB                 db    0
.data:000000CC                 db    0
.data:000000CD                 db    0
.data:000000CE                 db    0
.data:000000CF                 db    0
.data:000000D0                 db    0
.data:000000D1                 db    0
.data:000000D2                 db    0
.data:000000D3                 db    0
.data:000000D4                 db    0
.data:000000D5                 db    0
.data:000000D6                 db    0
.data:000000D7                 db    0
.data:000000D8                 db    0
.data:000000D9                 db    0
.data:000000DA                 db    0
.data:000000DB                 db    0
.data:000000DC                 db    0
.data:000000DD                 db    0
.data:000000DE                 db    0
.data:000000DF                 db    0
.data:000000E0                 db    0
.data:000000E1                 db    0
.data:000000E2                 db    0
.data:000000E3                 db    0
.data:000000E4                 db    0
.data:000000E5                 db    0
.data:000000E6                 db    0
.data:000000E7                 db    0
.data:000000E8                 db    0
.data:000000E9                 db    0
.data:000000EA                 db    0
.data:000000EB                 db    0
.data:000000EC                 db    0
.data:000000ED                 db    0
.data:000000EE                 db    0
.data:000000EF                 db    0
.data:000000F0                 db    0
.data:000000F1                 db    0
.data:000000F2                 db    0
.data:000000F3                 db    0
.data:000000F4                 db    0
.data:000000F5                 db    0
.data:000000F6                 db    0
.data:000000F7                 db    0
.data:000000F8                 db    0
.data:000000F9                 db    0
.data:000000FA                 db    0
.data:000000FB                 db    0
.data:000000FC                 db    0
.data:000000FD                 db    0
.data:000000FE                 db    0
.data:000000FF                 db    0
.data:000000FF _data           ends
.data:000000FF
.rdata:00000100 ; ===========================================================================
.rdata:00000100
.rdata:00000100 ; Segment type: Pure data
.rdata:00000100 ; Segment permissions: Read
.rdata:00000100 _rdata          segment dword public 'DATA' use32
.rdata:00000100                 assume cs:_rdata
.rdata:00000100                 ;org 100h
.rdata:00000100 ; wchar_t _SG94724
.rdata:00000100 $SG94724        dw 0                    ; DATA XREF: URLCtrl::action(void)+AAo
.rdata:00000102                 db    0
.rdata:00000103                 db    0
.rdata:00000104 ; const WCHAR _SG94725
.rdata:00000104 $SG94725:                               ; DATA XREF: URLCtrl::action(void)+DDo
.rdata:00000104                 unicode 0, <open>,0
.rdata:0000010E                 align 10h
.rdata:00000110 ; const WCHAR _SG94728
.rdata:00000110 $SG94728:                               ; DATA XREF: URLCtrl::action(void)+115o
.rdata:00000110                 unicode 0, <open>,0
.rdata:0000011A                 align 4
.rdata:0000011A _rdata          ends
.rdata:0000011A
.text$mn:0000011C ; ===========================================================================
.text$mn:0000011C
.text$mn:0000011C ; Segment type: Pure code
.text$mn:0000011C ; Segment permissions: Read/Execute
.text$mn:0000011C _text$mn        segment para public 'CODE' use32
.text$mn:0000011C                 assume cs:_text$mn
.text$mn:0000011C                 ;org 11Ch
.text$mn:0000011C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000011C
.text$mn:0000011C ; =============== S U B R O U T I N E =======================================
.text$mn:0000011C
.text$mn:0000011C ; Attributes: bp-based frame
.text$mn:0000011C
.text$mn:0000011C ; void __thiscall URLCtrl::create(URLCtrl *this, HWND hWnd, wchar_t *Str, unsigned __int32)
.text$mn:0000011C                 public ?create@URLCtrl@@QAEXPAUHWND__@@PA_WK@Z
.text$mn:0000011C ?create@URLCtrl@@QAEXPAUHWND__@@PA_WK@Z proc near
.text$mn:0000011C
.text$mn:0000011C dwNewLong       = dword ptr -4
.text$mn:0000011C hWnd            = dword ptr  8
.text$mn:0000011C Str             = dword ptr  0Ch
.text$mn:0000011C arg_8           = dword ptr  10h
.text$mn:0000011C
.text$mn:0000011C                 push    ebp
.text$mn:0000011D                 mov     ebp, esp
.text$mn:0000011F                 push    ecx
.text$mn:00000120                 mov     [ebp+dwNewLong], ecx
.text$mn:00000123                 push    0FFFFFFF0h      ; nIndex
.text$mn:00000125                 mov     eax, [ebp+hWnd]
.text$mn:00000128                 push    eax             ; hWnd
.text$mn:00000129                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:0000012F                 or      eax, 100h
.text$mn:00000134                 push    eax             ; dwNewLong
.text$mn:00000135                 push    0FFFFFFF0h      ; nIndex
.text$mn:00000137                 mov     ecx, [ebp+hWnd]
.text$mn:0000013A                 push    ecx             ; hWnd
.text$mn:0000013B                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00000141                 cmp     [ebp+Str], 0
.text$mn:00000145                 jz      short loc_156
.text$mn:00000147                 mov     edx, [ebp+Str]
.text$mn:0000014A                 push    edx             ; Str
.text$mn:0000014B                 mov     ecx, [ebp+dwNewLong]
.text$mn:0000014E                 add     ecx, 10h
.text$mn:00000151                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:00000156
.text$mn:00000156 loc_156:                                ; CODE XREF: URLCtrl::create(HWND__ *,wchar_t *,ulong)+29j
.text$mn:00000156                 mov     eax, [ebp+dwNewLong]
.text$mn:00000159                 mov     ecx, [ebp+arg_8]
.text$mn:0000015C                 mov     [eax+40h], ecx
.text$mn:0000015F                 mov     edx, [ebp+dwNewLong]
.text$mn:00000162                 mov     dword ptr [edx+44h], 800080h
.text$mn:00000169                 push    offset ?URLCtrlProc@URLCtrl@@KGJPAUHWND__@@IIJ@Z ; dwNewLong
.text$mn:0000016E                 push    0FFFFFFFCh      ; nIndex
.text$mn:00000170                 mov     eax, [ebp+hWnd]
.text$mn:00000173                 push    eax             ; hWnd
.text$mn:00000174                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:0000017A                 mov     ecx, [ebp+dwNewLong]
.text$mn:0000017D                 mov     [ecx+3Ch], eax
.text$mn:00000180                 mov     edx, [ebp+dwNewLong]
.text$mn:00000183                 push    edx             ; dwNewLong
.text$mn:00000184                 push    0FFFFFFEBh      ; nIndex
.text$mn:00000186                 mov     eax, [ebp+hWnd]
.text$mn:00000189                 push    eax             ; hWnd
.text$mn:0000018A                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00000190                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000193                 mov     edx, [ebp+hWnd]
.text$mn:00000196                 mov     [ecx+0Ch], edx
.text$mn:00000199                 mov     esp, ebp
.text$mn:0000019B                 pop     ebp
.text$mn:0000019C                 retn    0Ch
.text$mn:0000019C ?create@URLCtrl@@QAEXPAUHWND__@@PA_WK@Z endp
.text$mn:0000019C
.text$mn:0000019C ; ---------------------------------------------------------------------------
.text$mn:0000019F                 db 0Dh dup(0CCh)
.text$mn:000001AC
.text$mn:000001AC ; =============== S U B R O U T I N E =======================================
.text$mn:000001AC
.text$mn:000001AC ; Attributes: bp-based frame
.text$mn:000001AC
.text$mn:000001AC ; void __thiscall URLCtrl::create(URLCtrl *this, HWND hWnd, int, HWND)
.text$mn:000001AC                 public ?create@URLCtrl@@QAEXPAUHWND__@@H0@Z
.text$mn:000001AC ?create@URLCtrl@@QAEXPAUHWND__@@H0@Z proc near
.text$mn:000001AC
.text$mn:000001AC dwNewLong       = dword ptr -4
.text$mn:000001AC hWnd            = dword ptr  8
.text$mn:000001AC arg_4           = dword ptr  0Ch
.text$mn:000001AC arg_8           = dword ptr  10h
.text$mn:000001AC
.text$mn:000001AC                 push    ebp
.text$mn:000001AD                 mov     ebp, esp
.text$mn:000001AF                 push    ecx
.text$mn:000001B0                 mov     [ebp+dwNewLong], ecx
.text$mn:000001B3                 push    0FFFFFFF0h      ; nIndex
.text$mn:000001B5                 mov     eax, [ebp+hWnd]
.text$mn:000001B8                 push    eax             ; hWnd
.text$mn:000001B9                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:000001BF                 or      eax, 100h
.text$mn:000001C4                 push    eax             ; dwNewLong
.text$mn:000001C5                 push    0FFFFFFF0h      ; nIndex
.text$mn:000001C7                 mov     ecx, [ebp+hWnd]
.text$mn:000001CA                 push    ecx             ; hWnd
.text$mn:000001CB                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:000001D1                 mov     edx, [ebp+dwNewLong]
.text$mn:000001D4                 mov     eax, [ebp+arg_4]
.text$mn:000001D7                 mov     [edx+38h], eax
.text$mn:000001DA                 mov     ecx, [ebp+dwNewLong]
.text$mn:000001DD                 mov     edx, [ebp+arg_8]
.text$mn:000001E0                 mov     [ecx+34h], edx
.text$mn:000001E3                 mov     eax, [ebp+dwNewLong]
.text$mn:000001E6                 mov     dword ptr [eax+40h], 0FF0000h
.text$mn:000001ED                 push    offset ?URLCtrlProc@URLCtrl@@KGJPAUHWND__@@IIJ@Z ; dwNewLong
.text$mn:000001F2                 push    0FFFFFFFCh      ; nIndex
.text$mn:000001F4                 mov     ecx, [ebp+hWnd]
.text$mn:000001F7                 push    ecx             ; hWnd
.text$mn:000001F8                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:000001FE                 mov     edx, [ebp+dwNewLong]
.text$mn:00000201                 mov     [edx+3Ch], eax
.text$mn:00000204                 mov     eax, [ebp+dwNewLong]
.text$mn:00000207                 push    eax             ; dwNewLong
.text$mn:00000208                 push    0FFFFFFEBh      ; nIndex
.text$mn:0000020A                 mov     ecx, [ebp+hWnd]
.text$mn:0000020D                 push    ecx             ; hWnd
.text$mn:0000020E                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00000214                 mov     edx, [ebp+dwNewLong]
.text$mn:00000217                 mov     eax, [ebp+hWnd]
.text$mn:0000021A                 mov     [edx+0Ch], eax
.text$mn:0000021D                 mov     esp, ebp
.text$mn:0000021F                 pop     ebp
.text$mn:00000220                 retn    0Ch
.text$mn:00000220 ?create@URLCtrl@@QAEXPAUHWND__@@H0@Z endp
.text$mn:00000220
.text$mn:00000220 ; ---------------------------------------------------------------------------
.text$mn:00000223                 db 9 dup(0CCh)
.text$mn:0000022C
.text$mn:0000022C ; =============== S U B R O U T I N E =======================================
.text$mn:0000022C
.text$mn:0000022C ; Attributes: bp-based frame
.text$mn:0000022C
.text$mn:0000022C ; void __thiscall URLCtrl::destroy(URLCtrl *__hidden this)
.text$mn:0000022C                 public ?destroy@URLCtrl@@UAEXXZ
.text$mn:0000022C ?destroy@URLCtrl@@UAEXXZ proc near
.text$mn:0000022C
.text$mn:0000022C var_4           = dword ptr -4
.text$mn:0000022C
.text$mn:0000022C                 push    ebp
.text$mn:0000022D                 mov     ebp, esp
.text$mn:0000022F                 push    ecx
.text$mn:00000230                 mov     [ebp+var_4], ecx
.text$mn:00000233                 mov     eax, [ebp+var_4]
.text$mn:00000236                 cmp     dword ptr [eax+2Ch], 0
.text$mn:0000023A                 jz      short loc_249
.text$mn:0000023C                 mov     ecx, [ebp+var_4]
.text$mn:0000023F                 mov     edx, [ecx+2Ch]
.text$mn:00000242                 push    edx             ; ho
.text$mn:00000243                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:00000249
.text$mn:00000249 loc_249:                                ; CODE XREF: URLCtrl::destroy(void)+Ej
.text$mn:00000249                 mov     eax, [ebp+var_4]
.text$mn:0000024C                 cmp     dword ptr [eax+30h], 0
.text$mn:00000250                 jz      short loc_25F
.text$mn:00000252                 mov     ecx, [ebp+var_4]
.text$mn:00000255                 mov     edx, [ecx+30h]
.text$mn:00000258                 push    edx             ; hCursor
.text$mn:00000259                 call    dword ptr ds:__imp__DestroyCursor@4 ; DestroyCursor(x)
.text$mn:0000025F
.text$mn:0000025F loc_25F:                                ; CODE XREF: URLCtrl::destroy(void)+24j
.text$mn:0000025F                 mov     esp, ebp
.text$mn:00000261                 pop     ebp
.text$mn:00000262                 retn
.text$mn:00000262 ?destroy@URLCtrl@@UAEXXZ endp
.text$mn:00000262
.text$mn:00000262 ; ---------------------------------------------------------------------------
.text$mn:00000263                 db 9 dup(0CCh)
.text$mn:0000026C
.text$mn:0000026C ; =============== S U B R O U T I N E =======================================
.text$mn:0000026C
.text$mn:0000026C ; Attributes: bp-based frame
.text$mn:0000026C
.text$mn:0000026C ; void __thiscall URLCtrl::action(URLCtrl *__hidden this)
.text$mn:0000026C                 public ?action@URLCtrl@@AAEXXZ
.text$mn:0000026C ?action@URLCtrl@@AAEXXZ proc near       ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+300p
.text$mn:0000026C                                         ; URLCtrl::runProc(HWND__ *,uint,uint,long)+33Dp
.text$mn:0000026C
.text$mn:0000026C hWnd            = dword ptr -214h
.text$mn:0000026C var_210         = dword ptr -210h
.text$mn:0000026C String          = word ptr -20Ch
.text$mn:0000026C var_4           = dword ptr -4
.text$mn:0000026C
.text$mn:0000026C                 push    ebp
.text$mn:0000026D                 mov     ebp, esp
.text$mn:0000026F                 sub     esp, 214h
.text$mn:00000275                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000027A                 xor     eax, ebp
.text$mn:0000027C                 mov     [ebp+var_4], eax
.text$mn:0000027F                 mov     [ebp+var_210], ecx
.text$mn:00000285                 mov     eax, [ebp+var_210]
.text$mn:0000028B                 cmp     dword ptr [eax+38h], 0
.text$mn:0000028F                 jz      short loc_2E0
.text$mn:00000291                 mov     ecx, [ebp+var_210]
.text$mn:00000297                 cmp     dword ptr [ecx+34h], 0
.text$mn:0000029B                 jz      short loc_2AE
.text$mn:0000029D                 mov     edx, [ebp+var_210]
.text$mn:000002A3                 mov     eax, [edx+34h]
.text$mn:000002A6                 mov     [ebp+hWnd], eax
.text$mn:000002AC                 jmp     short loc_2BD
.text$mn:000002AE ; ---------------------------------------------------------------------------
.text$mn:000002AE
.text$mn:000002AE loc_2AE:                                ; CODE XREF: URLCtrl::action(void)+2Fj
.text$mn:000002AE                 mov     ecx, [ebp+var_210]
.text$mn:000002B4                 mov     edx, [ecx+8]
.text$mn:000002B7                 mov     [ebp+hWnd], edx
.text$mn:000002BD
.text$mn:000002BD loc_2BD:                                ; CODE XREF: URLCtrl::action(void)+40j
.text$mn:000002BD                 push    0               ; lParam
.text$mn:000002BF                 mov     eax, [ebp+var_210]
.text$mn:000002C5                 mov     ecx, [eax+38h]
.text$mn:000002C8                 push    ecx             ; wParam
.text$mn:000002C9                 push    111h            ; Msg
.text$mn:000002CE                 mov     edx, [ebp+hWnd]
.text$mn:000002D4                 push    edx             ; hWnd
.text$mn:000002D5                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000002DB                 jmp     loc_38E
.text$mn:000002E0 ; ---------------------------------------------------------------------------
.text$mn:000002E0
.text$mn:000002E0 loc_2E0:                                ; CODE XREF: URLCtrl::action(void)+23j
.text$mn:000002E0                 mov     eax, [ebp+var_210]
.text$mn:000002E6                 mov     ecx, [ebp+var_210]
.text$mn:000002EC                 mov     edx, [ecx+44h]
.text$mn:000002EF                 mov     [eax+40h], edx
.text$mn:000002F2                 push    0               ; bErase
.text$mn:000002F4                 push    0               ; lpRect
.text$mn:000002F6                 mov     eax, [ebp+var_210]
.text$mn:000002FC                 mov     ecx, [eax+0Ch]
.text$mn:000002FF                 push    ecx             ; hWnd
.text$mn:00000300                 call    dword ptr ds:__imp__InvalidateRect@12 ; InvalidateRect(x,x,x)
.text$mn:00000306                 mov     edx, [ebp+var_210]
.text$mn:0000030C                 mov     eax, [edx+0Ch]
.text$mn:0000030F                 push    eax             ; hWnd
.text$mn:00000310                 call    dword ptr ds:__imp__UpdateWindow@4 ; UpdateWindow(x)
.text$mn:00000316                 push    offset $SG94724 ; Str
.text$mn:0000031B                 mov     ecx, [ebp+var_210]
.text$mn:00000321                 add     ecx, 10h
.text$mn:00000324                 push    ecx             ; int
.text$mn:00000325                 call    ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:0000032A                 add     esp, 8
.text$mn:0000032D                 movzx   edx, al
.text$mn:00000330                 test    edx, edx
.text$mn:00000332                 jz      short loc_358
.text$mn:00000334                 push    1               ; nShowCmd
.text$mn:00000336                 push    0               ; lpDirectory
.text$mn:00000338                 push    0               ; lpParameters
.text$mn:0000033A                 mov     ecx, [ebp+var_210]
.text$mn:00000340                 add     ecx, 10h
.text$mn:00000343                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00000348                 push    eax             ; lpFile
.text$mn:00000349                 push    offset $SG94725 ; "open"
.text$mn:0000034E                 push    0               ; hwnd
.text$mn:00000350                 call    dword ptr ds:__imp__ShellExecuteW@24 ; ShellExecuteW(x,x,x,x,x,x)
.text$mn:00000356                 jmp     short loc_38E
.text$mn:00000358 ; ---------------------------------------------------------------------------
.text$mn:00000358
.text$mn:00000358 loc_358:                                ; CODE XREF: URLCtrl::action(void)+C6j
.text$mn:00000358                 push    104h            ; nMaxCount
.text$mn:0000035D                 lea     eax, [ebp+String]
.text$mn:00000363                 push    eax             ; lpString
.text$mn:00000364                 mov     ecx, [ebp+var_210]
.text$mn:0000036A                 mov     edx, [ecx+0Ch]
.text$mn:0000036D                 push    edx             ; hWnd
.text$mn:0000036E                 call    dword ptr ds:__imp__GetWindowTextW@12 ; GetWindowTextW(x,x,x)
.text$mn:00000374                 push    1               ; nShowCmd
.text$mn:00000376                 push    0               ; lpDirectory
.text$mn:00000378                 push    0               ; lpParameters
.text$mn:0000037A                 lea     eax, [ebp+String]
.text$mn:00000380                 push    eax             ; lpFile
.text$mn:00000381                 push    offset $SG94728 ; "open"
.text$mn:00000386                 push    0               ; hwnd
.text$mn:00000388                 call    dword ptr ds:__imp__ShellExecuteW@24 ; ShellExecuteW(x,x,x,x,x,x)
.text$mn:0000038E
.text$mn:0000038E loc_38E:                                ; CODE XREF: URLCtrl::action(void)+6Fj
.text$mn:0000038E                                         ; URLCtrl::action(void)+EAj
.text$mn:0000038E                 mov     ecx, [ebp+var_4]
.text$mn:00000391                 xor     ecx, ebp
.text$mn:00000393                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000398                 mov     esp, ebp
.text$mn:0000039A                 pop     ebp
.text$mn:0000039B                 retn
.text$mn:0000039B ?action@URLCtrl@@AAEXXZ endp
.text$mn:0000039B
.text$mn:0000039C
.text$mn:0000039C ; =============== S U B R O U T I N E =======================================
.text$mn:0000039C
.text$mn:0000039C ; Attributes: bp-based frame
.text$mn:0000039C
.text$mn:0000039C ; __int32 __thiscall URLCtrl::runProc(URLCtrl *this, HWND hWnd, UINT Msg, WPARAM wParam, __int32)
.text$mn:0000039C                 public ?runProc@URLCtrl@@IAEJPAUHWND__@@IIJ@Z
.text$mn:0000039C ?runProc@URLCtrl@@IAEJPAUHWND__@@IIJ@Z proc near
.text$mn:0000039C                                         ; CODE XREF: URLCtrl::URLCtrlProc(HWND__ *,uint,uint,long)+21p
.text$mn:0000039C
.text$mn:0000039C var_2D8         = dword ptr -2D8h
.text$mn:0000039C var_2D4         = dword ptr -2D4h
.text$mn:0000039C h               = dword ptr -2D0h
.text$mn:0000039C var_2CC         = dword ptr -2CCh
.text$mn:0000039C hdc             = dword ptr -2C8h
.text$mn:0000039C format          = dword ptr -2C4h
.text$mn:0000039C var_2C0         = dword ptr -2C0h
.text$mn:0000039C var_2BC         = dword ptr -2BCh
.text$mn:0000039C Paint           = tagPAINTSTRUCT ptr -2B8h
.text$mn:0000039C pv              = byte ptr -278h
.text$mn:0000039C var_263         = byte ptr -263h
.text$mn:0000039C Rect            = tagRECT ptr -21Ch
.text$mn:0000039C String          = word ptr -20Ch
.text$mn:0000039C var_4           = dword ptr -4
.text$mn:0000039C hWnd            = dword ptr  8
.text$mn:0000039C Msg             = dword ptr  0Ch
.text$mn:0000039C wParam          = dword ptr  10h
.text$mn:0000039C lParam          = dword ptr  14h
.text$mn:0000039C
.text$mn:0000039C                 push    ebp
.text$mn:0000039D                 mov     ebp, esp
.text$mn:0000039F                 sub     esp, 2D8h
.text$mn:000003A5                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000003AA                 xor     eax, ebp
.text$mn:000003AC                 mov     [ebp+var_4], eax
.text$mn:000003AF                 mov     [ebp+var_2BC], ecx
.text$mn:000003B5                 mov     eax, [ebp+Msg]
.text$mn:000003B8                 mov     [ebp+var_2C0], eax
.text$mn:000003BE                 cmp     [ebp+var_2C0], 101h
.text$mn:000003C8                 ja      short loc_40D
.text$mn:000003CA                 cmp     [ebp+var_2C0], 101h
.text$mn:000003D4                 jz      loc_6B5
.text$mn:000003DA                 mov     ecx, [ebp+var_2C0]
.text$mn:000003E0                 sub     ecx, 0Ch
.text$mn:000003E3                 mov     [ebp+var_2C0], ecx
.text$mn:000003E9                 cmp     [ebp+var_2C0], 0F4h ; '(' ; switch 245 cases
.text$mn:000003F3                 ja      $LN18           ; jumptable 00000406 default case
.text$mn:000003F9                 mov     edx, [ebp+var_2C0]
.text$mn:000003FF                 movzx   eax, ds:$LN23[edx]
.text$mn:00000406                 jmp     ds:$LN24[eax*4] ; switch jump
.text$mn:0000040D ; ---------------------------------------------------------------------------
.text$mn:0000040D
.text$mn:0000040D loc_40D:                                ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+2Cj
.text$mn:0000040D                 cmp     [ebp+var_2C0], 200h
.text$mn:00000417                 jz      loc_622
.text$mn:0000041D                 cmp     [ebp+var_2C0], 201h
.text$mn:00000427                 jz      loc_672
.text$mn:0000042D                 cmp     [ebp+var_2C0], 202h
.text$mn:00000437                 jz      loc_67E
.text$mn:0000043D                 jmp     $LN18           ; jumptable 00000406 default case
.text$mn:00000442 ; ---------------------------------------------------------------------------
.text$mn:00000442                 jmp     $LN18           ; jumptable 00000406 default case
.text$mn:00000447 ; ---------------------------------------------------------------------------
.text$mn:00000447
.text$mn:00000447 $LN16:                                  ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+6Aj
.text$mn:00000447                                         ; DATA XREF: .text$mn:$LN24o
.text$mn:00000447                 push    0FFFFFFF0h      ; jumptable 00000406 case 3
.text$mn:00000449                 mov     ecx, [ebp+hWnd]
.text$mn:0000044C                 push    ecx             ; hWnd
.text$mn:0000044D                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:00000453                 mov     [ebp+var_2CC], eax
.text$mn:00000459                 mov     [ebp+format], 20h ; ' '
.text$mn:00000463                 mov     edx, [ebp+var_2CC]
.text$mn:00000469                 and     edx, 1
.text$mn:0000046C                 jz      short loc_47D
.text$mn:0000046E                 mov     eax, [ebp+format]
.text$mn:00000474                 or      eax, 1
.text$mn:00000477                 mov     [ebp+format], eax
.text$mn:0000047D
.text$mn:0000047D loc_47D:                                ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+D0j
.text$mn:0000047D                 mov     ecx, [ebp+var_2CC]
.text$mn:00000483                 and     ecx, 2
.text$mn:00000486                 jz      short loc_497
.text$mn:00000488                 mov     edx, [ebp+format]
.text$mn:0000048E                 or      edx, 2
.text$mn:00000491                 mov     [ebp+format], edx
.text$mn:00000497
.text$mn:00000497 loc_497:                                ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+EAj
.text$mn:00000497                 mov     eax, [ebp+var_2CC]
.text$mn:0000049D                 and     eax, 200h
.text$mn:000004A2                 jz      short loc_4B3
.text$mn:000004A4                 mov     ecx, [ebp+format]
.text$mn:000004AA                 or      ecx, 4
.text$mn:000004AD                 mov     [ebp+format], ecx
.text$mn:000004B3
.text$mn:000004B3 loc_4B3:                                ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+106j
.text$mn:000004B3                 lea     edx, [ebp+Rect]
.text$mn:000004B9                 push    edx             ; lpRect
.text$mn:000004BA                 mov     eax, [ebp+hWnd]
.text$mn:000004BD                 push    eax             ; hWnd
.text$mn:000004BE                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:000004C4                 lea     ecx, [ebp+Paint]
.text$mn:000004CA                 push    ecx             ; lpPaint
.text$mn:000004CB                 mov     edx, [ebp+hWnd]
.text$mn:000004CE                 push    edx             ; hWnd
.text$mn:000004CF                 call    dword ptr ds:__imp__BeginPaint@8 ; BeginPaint(x,x)
.text$mn:000004D5                 mov     [ebp+hdc], eax
.text$mn:000004DB                 mov     eax, [ebp+var_2BC]
.text$mn:000004E1                 mov     ecx, [eax+40h]
.text$mn:000004E4                 push    ecx             ; color
.text$mn:000004E5                 mov     edx, [ebp+hdc]
.text$mn:000004EB                 push    edx             ; hdc
.text$mn:000004EC                 call    dword ptr ds:__imp__SetTextColor@8 ; SetTextColor(x,x)
.text$mn:000004F2                 mov     eax, [ebp+hWnd]
.text$mn:000004F5                 push    eax             ; hWnd
.text$mn:000004F6                 call    dword ptr ds:__imp__GetParent@4 ; GetParent(x)
.text$mn:000004FC                 push    eax             ; HWND
.text$mn:000004FD                 call    ?getCtrlBgColor@@YAKPAUHWND__@@@Z ; getCtrlBgColor(HWND__ *)
.text$mn:00000502                 add     esp, 4
.text$mn:00000505                 push    eax             ; color
.text$mn:00000506                 mov     ecx, [ebp+hdc]
.text$mn:0000050C                 push    ecx             ; hdc
.text$mn:0000050D                 call    dword ptr ds:__imp__SetBkColor@8 ; SetBkColor(x,x)
.text$mn:00000513                 mov     edx, [ebp+var_2BC]
.text$mn:00000519                 cmp     dword ptr [edx+2Ch], 0
.text$mn:0000051D                 jnz     short loc_560
.text$mn:0000051F                 push    11h             ; i
.text$mn:00000521                 call    dword ptr ds:__imp__GetStockObject@4 ; GetStockObject(x)
.text$mn:00000527                 mov     [ebp+h], eax
.text$mn:0000052D                 lea     eax, [ebp+pv]
.text$mn:00000533                 push    eax             ; pv
.text$mn:00000534                 push    5Ch ; '\'       ; c
.text$mn:00000536                 mov     ecx, [ebp+h]
.text$mn:0000053C                 push    ecx             ; h
.text$mn:0000053D                 call    dword ptr ds:__imp__GetObjectW@12 ; GetObjectW(x,x,x)
.text$mn:00000543                 mov     [ebp+var_263], 1
.text$mn:0000054A                 lea     edx, [ebp+pv]
.text$mn:00000550                 push    edx             ; lplf
.text$mn:00000551                 call    dword ptr ds:__imp__CreateFontIndirectW@4 ; CreateFontIndirectW(x)
.text$mn:00000557                 mov     ecx, [ebp+var_2BC]
.text$mn:0000055D                 mov     [ecx+2Ch], eax
.text$mn:00000560
.text$mn:00000560 loc_560:                                ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+181j
.text$mn:00000560                 mov     edx, [ebp+var_2BC]
.text$mn:00000566                 mov     eax, [edx+2Ch]
.text$mn:00000569                 push    eax             ; h
.text$mn:0000056A                 mov     ecx, [ebp+hdc]
.text$mn:00000570                 push    ecx             ; hdc
.text$mn:00000571                 call    dword ptr ds:__imp__SelectObject@8 ; SelectObject(x,x)
.text$mn:00000577                 mov     [ebp+var_2D4], eax
.text$mn:0000057D                 push    104h            ; nMaxCount
.text$mn:00000582                 lea     edx, [ebp+String]
.text$mn:00000588                 push    edx             ; lpString
.text$mn:00000589                 mov     eax, [ebp+hWnd]
.text$mn:0000058C                 push    eax             ; hWnd
.text$mn:0000058D                 call    dword ptr ds:__imp__GetWindowTextW@12 ; GetWindowTextW(x,x,x)
.text$mn:00000593                 mov     ecx, [ebp+format]
.text$mn:00000599                 push    ecx             ; format
.text$mn:0000059A                 lea     edx, [ebp+Rect]
.text$mn:000005A0                 push    edx             ; lprc
.text$mn:000005A1                 push    0FFFFFFFFh      ; cchText
.text$mn:000005A3                 lea     eax, [ebp+String]
.text$mn:000005A9                 push    eax             ; lpchText
.text$mn:000005AA                 mov     ecx, [ebp+hdc]
.text$mn:000005B0                 push    ecx             ; hdc
.text$mn:000005B1                 call    dword ptr ds:__imp__DrawTextW@20 ; DrawTextW(x,x,x,x,x)
.text$mn:000005B7                 mov     edx, [ebp+var_2D4]
.text$mn:000005BD                 push    edx             ; h
.text$mn:000005BE                 mov     eax, [ebp+hdc]
.text$mn:000005C4                 push    eax             ; hdc
.text$mn:000005C5                 call    dword ptr ds:__imp__SelectObject@8 ; SelectObject(x,x)
.text$mn:000005CB                 lea     ecx, [ebp+Paint]
.text$mn:000005D1                 push    ecx             ; lpPaint
.text$mn:000005D2                 mov     edx, [ebp+hWnd]
.text$mn:000005D5                 push    edx             ; hWnd
.text$mn:000005D6                 call    dword ptr ds:__imp__EndPaint@8 ; EndPaint(x,x)
.text$mn:000005DC                 xor     eax, eax
.text$mn:000005DE                 jmp     loc_707
.text$mn:000005E3 ; ---------------------------------------------------------------------------
.text$mn:000005E3
.text$mn:000005E3 $LN11:                                  ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+6Aj
.text$mn:000005E3                                         ; DATA XREF: .text$mn:$LN24o
.text$mn:000005E3                 mov     eax, [ebp+lParam] ; jumptable 00000406 case 0
.text$mn:000005E6                 push    eax             ; lParam
.text$mn:000005E7                 mov     ecx, [ebp+wParam]
.text$mn:000005EA                 push    ecx             ; wParam
.text$mn:000005EB                 mov     edx, [ebp+Msg]
.text$mn:000005EE                 push    edx             ; Msg
.text$mn:000005EF                 mov     eax, [ebp+hWnd]
.text$mn:000005F2                 push    eax             ; hWnd
.text$mn:000005F3                 mov     ecx, [ebp+var_2BC]
.text$mn:000005F9                 mov     edx, [ecx+3Ch]
.text$mn:000005FC                 push    edx             ; lpPrevWndFunc
.text$mn:000005FD                 call    dword ptr ds:__imp__CallWindowProcW@20 ; CallWindowProcW(x,x,x,x,x)
.text$mn:00000603                 mov     [ebp+var_2D8], eax
.text$mn:00000609                 push    0               ; bErase
.text$mn:0000060B                 push    0               ; lpRect
.text$mn:0000060D                 mov     eax, [ebp+hWnd]
.text$mn:00000610                 push    eax             ; hWnd
.text$mn:00000611                 call    dword ptr ds:__imp__InvalidateRect@12 ; InvalidateRect(x,x,x)
.text$mn:00000617                 mov     eax, [ebp+var_2D8]
.text$mn:0000061D                 jmp     loc_707
.text$mn:00000622 ; ---------------------------------------------------------------------------
.text$mn:00000622
.text$mn:00000622 loc_622:                                ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+7Bj
.text$mn:00000622                 mov     ecx, [ebp+var_2BC]
.text$mn:00000628                 cmp     dword ptr [ecx+30h], 0
.text$mn:0000062C                 jnz     short loc_658
.text$mn:0000062E                 push    offset _ANDMask ; pvXORPlane
.text$mn:00000633                 push    offset _XORMask ; pvANDPlane
.text$mn:00000638                 push    20h ; ' '       ; nHeight
.text$mn:0000063A                 push    20h ; ' '       ; nWidth
.text$mn:0000063C                 push    2               ; yHotSpot
.text$mn:0000063E                 push    5               ; xHotSpot
.text$mn:00000640                 push    0               ; lpModuleName
.text$mn:00000642                 call    dword ptr ds:__imp__GetModuleHandleW@4 ; GetModuleHandleW(x)
.text$mn:00000648                 push    eax             ; hInst
.text$mn:00000649                 call    dword ptr ds:__imp__CreateCursor@28 ; CreateCursor(x,x,x,x,x,x,x)
.text$mn:0000064F                 mov     edx, [ebp+var_2BC]
.text$mn:00000655                 mov     [edx+30h], eax
.text$mn:00000658
.text$mn:00000658 loc_658:                                ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+290j
.text$mn:00000658                 mov     eax, [ebp+var_2BC]
.text$mn:0000065E                 mov     ecx, [eax+30h]
.text$mn:00000661                 push    ecx             ; hCursor
.text$mn:00000662                 call    dword ptr ds:__imp__SetCursor@4 ; SetCursor(x)
.text$mn:00000668                 mov     eax, 1
.text$mn:0000066D                 jmp     loc_707
.text$mn:00000672 ; ---------------------------------------------------------------------------
.text$mn:00000672
.text$mn:00000672 loc_672:                                ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+8Bj
.text$mn:00000672                 mov     edx, [ebp+var_2BC]
.text$mn:00000678                 mov     byte ptr [edx+48h], 1
.text$mn:0000067C                 jmp     short $LN18     ; jumptable 00000406 default case
.text$mn:0000067E ; ---------------------------------------------------------------------------
.text$mn:0000067E
.text$mn:0000067E loc_67E:                                ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+9Bj
.text$mn:0000067E                 mov     eax, [ebp+var_2BC]
.text$mn:00000684                 movzx   ecx, byte ptr [eax+48h]
.text$mn:00000688                 test    ecx, ecx
.text$mn:0000068A                 jz      short loc_6A1
.text$mn:0000068C                 mov     edx, [ebp+var_2BC]
.text$mn:00000692                 mov     byte ptr [edx+48h], 0
.text$mn:00000696                 mov     ecx, [ebp+var_2BC] ; this
.text$mn:0000069C                 call    ?action@URLCtrl@@AAEXXZ ; URLCtrl::action(void)
.text$mn:000006A1
.text$mn:000006A1 loc_6A1:                                ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+2EEj
.text$mn:000006A1                 jmp     short $LN18     ; jumptable 00000406 default case
.text$mn:000006A3 ; ---------------------------------------------------------------------------
.text$mn:000006A3
.text$mn:000006A3 $LN5:                                   ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+6Aj
.text$mn:000006A3                                         ; DATA XREF: .text$mn:$LN24o
.text$mn:000006A3                 cmp     [ebp+wParam], 20h ; ' ' ; jumptable 00000406 case 244
.text$mn:000006A7                 jnz     short loc_6B3
.text$mn:000006A9                 mov     eax, [ebp+var_2BC]
.text$mn:000006AF                 mov     byte ptr [eax+48h], 1
.text$mn:000006B3
.text$mn:000006B3 loc_6B3:                                ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+30Bj
.text$mn:000006B3                 jmp     short $LN18     ; jumptable 00000406 default case
.text$mn:000006B5 ; ---------------------------------------------------------------------------
.text$mn:000006B5
.text$mn:000006B5 loc_6B5:                                ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+38j
.text$mn:000006B5                 cmp     [ebp+wParam], 20h ; ' '
.text$mn:000006B9                 jnz     short loc_6DE
.text$mn:000006BB                 mov     ecx, [ebp+var_2BC]
.text$mn:000006C1                 movzx   edx, byte ptr [ecx+48h]
.text$mn:000006C5                 test    edx, edx
.text$mn:000006C7                 jz      short loc_6DE
.text$mn:000006C9                 mov     eax, [ebp+var_2BC]
.text$mn:000006CF                 mov     byte ptr [eax+48h], 0
.text$mn:000006D3                 mov     ecx, [ebp+var_2BC] ; this
.text$mn:000006D9                 call    ?action@URLCtrl@@AAEXXZ ; URLCtrl::action(void)
.text$mn:000006DE
.text$mn:000006DE loc_6DE:                                ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+31Dj
.text$mn:000006DE                                         ; URLCtrl::runProc(HWND__ *,uint,uint,long)+32Bj
.text$mn:000006DE                 jmp     short $LN18     ; jumptable 00000406 default case
.text$mn:000006E0 ; ---------------------------------------------------------------------------
.text$mn:000006E0
.text$mn:000006E0 $LN1:                                   ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+6Aj
.text$mn:000006E0                                         ; DATA XREF: .text$mn:$LN24o
.text$mn:000006E0                 mov     eax, 1          ; jumptable 00000406 case 120
.text$mn:000006E5                 jmp     short loc_707
.text$mn:000006E7 ; ---------------------------------------------------------------------------
.text$mn:000006E7
.text$mn:000006E7 $LN18:                                  ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+57j
.text$mn:000006E7                                         ; URLCtrl::runProc(HWND__ *,uint,uint,long)+6Aj ...
.text$mn:000006E7                 mov     ecx, [ebp+lParam] ; jumptable 00000406 default case
.text$mn:000006EA                 push    ecx             ; lParam
.text$mn:000006EB                 mov     edx, [ebp+wParam]
.text$mn:000006EE                 push    edx             ; wParam
.text$mn:000006EF                 mov     eax, [ebp+Msg]
.text$mn:000006F2                 push    eax             ; Msg
.text$mn:000006F3                 mov     ecx, [ebp+hWnd]
.text$mn:000006F6                 push    ecx             ; hWnd
.text$mn:000006F7                 mov     edx, [ebp+var_2BC]
.text$mn:000006FD                 mov     eax, [edx+3Ch]
.text$mn:00000700                 push    eax             ; lpPrevWndFunc
.text$mn:00000701                 call    dword ptr ds:__imp__CallWindowProcW@20 ; CallWindowProcW(x,x,x,x,x)
.text$mn:00000707
.text$mn:00000707 loc_707:                                ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+242j
.text$mn:00000707                                         ; URLCtrl::runProc(HWND__ *,uint,uint,long)+281j ...
.text$mn:00000707                 mov     ecx, [ebp+var_4]
.text$mn:0000070A                 xor     ecx, ebp
.text$mn:0000070C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000711                 mov     esp, ebp
.text$mn:00000713                 pop     ebp
.text$mn:00000714                 retn    10h
.text$mn:00000714 ?runProc@URLCtrl@@IAEJPAUHWND__@@IIJ@Z endp
.text$mn:00000714
.text$mn:00000714 ; ---------------------------------------------------------------------------
.text$mn:00000717                 align 4
.text$mn:00000718 $LN24           dd offset $LN11, offset $LN16, offset $LN1, offset $LN5
.text$mn:00000718                                         ; DATA XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+6Ar
.text$mn:00000718                 dd offset $LN18         ; jump table for switch statement
.text$mn:0000072C $LN23           db 0, 4, 4, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:0000072C                                         ; DATA XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+63r
.text$mn:0000072C                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 ; indirect table for switch statement
.text$mn:0000072C                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:0000072C                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:0000072C                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:0000072C                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:0000072C                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4
.text$mn:0000072C                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:0000072C                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:0000072C                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:0000072C                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:0000072C                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:0000072C                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
.text$mn:0000072C                 db 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3
.text$mn:00000821                 align 4
.text$mn:00000821 _text$mn        ends
.text$mn:00000821
.text$mn:00000824 ; ===========================================================================
.text$mn:00000824
.text$mn:00000824 ; Segment type: Pure code
.text$mn:00000824 ; Segment permissions: Read/Execute
.text$mn:00000824 _text$mn        segment para public 'CODE' use32
.text$mn:00000824                 assume cs:_text$mn
.text$mn:00000824                 ;org 824h
.text$mn:00000824 ; COMDAT (pick any)
.text$mn:00000824                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000824
.text$mn:00000824 ; =============== S U B R O U T I N E =======================================
.text$mn:00000824
.text$mn:00000824 ; Attributes: bp-based frame
.text$mn:00000824
.text$mn:00000824 ; int __cdecl std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(int, wchar_t *Str)
.text$mn:00000824                 public ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z
.text$mn:00000824 ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z proc near
.text$mn:00000824                                         ; CODE XREF: std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+Cp
.text$mn:00000824
.text$mn:00000824 var_4           = dword ptr -4
.text$mn:00000824 arg_0           = dword ptr  8
.text$mn:00000824 Str             = dword ptr  0Ch
.text$mn:00000824
.text$mn:00000824                 push    ebp
.text$mn:00000825                 mov     ebp, esp
.text$mn:00000827                 push    ecx
.text$mn:00000828                 mov     eax, [ebp+Str]
.text$mn:0000082B                 push    eax             ; Str
.text$mn:0000082C                 mov     ecx, [ebp+arg_0]
.text$mn:0000082F                 call    ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)
.text$mn:00000834                 test    eax, eax
.text$mn:00000836                 jnz     short loc_841
.text$mn:00000838                 mov     [ebp+var_4], 1
.text$mn:0000083F                 jmp     short loc_848
.text$mn:00000841 ; ---------------------------------------------------------------------------
.text$mn:00000841
.text$mn:00000841 loc_841:                                ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+12j
.text$mn:00000841                 mov     [ebp+var_4], 0
.text$mn:00000848
.text$mn:00000848 loc_848:                                ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+1Bj
.text$mn:00000848                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000084B                 mov     esp, ebp
.text$mn:0000084D                 pop     ebp
.text$mn:0000084E                 retn
.text$mn:0000084E ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z endp
.text$mn:0000084E
.text$mn:0000084E ; ---------------------------------------------------------------------------
.text$mn:0000084F                 align 10h
.text$mn:0000084F _text$mn        ends
.text$mn:0000084F
.text$mn:00000850 ; ===========================================================================
.text$mn:00000850
.text$mn:00000850 ; Segment type: Pure code
.text$mn:00000850 ; Segment permissions: Read/Execute
.text$mn:00000850 _text$mn        segment para public 'CODE' use32
.text$mn:00000850                 assume cs:_text$mn
.text$mn:00000850                 ;org 850h
.text$mn:00000850 ; COMDAT (pick any)
.text$mn:00000850                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000850
.text$mn:00000850 ; =============== S U B R O U T I N E =======================================
.text$mn:00000850
.text$mn:00000850 ; Attributes: bp-based frame
.text$mn:00000850
.text$mn:00000850 ; int __cdecl std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(int, wchar_t *Str)
.text$mn:00000850                 public ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z
.text$mn:00000850 ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z proc near
.text$mn:00000850                                         ; CODE XREF: URLCtrl::action(void)+B9p
.text$mn:00000850
.text$mn:00000850 var_4           = dword ptr -4
.text$mn:00000850 arg_0           = dword ptr  8
.text$mn:00000850 Str             = dword ptr  0Ch
.text$mn:00000850
.text$mn:00000850                 push    ebp
.text$mn:00000851                 mov     ebp, esp
.text$mn:00000853                 push    ecx
.text$mn:00000854                 mov     eax, [ebp+Str]
.text$mn:00000857                 push    eax             ; Str
.text$mn:00000858                 mov     ecx, [ebp+arg_0]
.text$mn:0000085B                 push    ecx             ; int
.text$mn:0000085C                 call    ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:00000861                 add     esp, 8
.text$mn:00000864                 movzx   edx, al
.text$mn:00000867                 test    edx, edx
.text$mn:00000869                 jnz     short loc_874
.text$mn:0000086B                 mov     [ebp+var_4], 1
.text$mn:00000872                 jmp     short loc_87B
.text$mn:00000874 ; ---------------------------------------------------------------------------
.text$mn:00000874
.text$mn:00000874 loc_874:                                ; CODE XREF: std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+19j
.text$mn:00000874                 mov     [ebp+var_4], 0
.text$mn:0000087B
.text$mn:0000087B loc_87B:                                ; CODE XREF: std::operator!=<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+22j
.text$mn:0000087B                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000087E                 mov     esp, ebp
.text$mn:00000880                 pop     ebp
.text$mn:00000881                 retn
.text$mn:00000881 ??$?9_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z endp
.text$mn:00000881
.text$mn:00000881 ; ---------------------------------------------------------------------------
.text$mn:00000882                 align 4
.text$mn:00000882 _text$mn        ends
.text$mn:00000882
.text$mn:00000884 ; ===========================================================================
.text$mn:00000884
.text$mn:00000884 ; Segment type: Pure code
.text$mn:00000884 ; Segment permissions: Read/Execute
.text$mn:00000884 _text$mn        segment para public 'CODE' use32
.text$mn:00000884                 assume cs:_text$mn
.text$mn:00000884                 ;org 884h
.text$mn:00000884 ; COMDAT (pick any)
.text$mn:00000884                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000884
.text$mn:00000884 ; =============== S U B R O U T I N E =======================================
.text$mn:00000884
.text$mn:00000884 ; Attributes: bp-based frame
.text$mn:00000884
.text$mn:00000884 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00000884                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00000884 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00000884                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00000884
.text$mn:00000884 var_4           = dword ptr -4
.text$mn:00000884 arg_0           = dword ptr  8
.text$mn:00000884
.text$mn:00000884                 push    ebp
.text$mn:00000885                 mov     ebp, esp
.text$mn:00000887                 push    ecx
.text$mn:00000888                 mov     [ebp+var_4], 0
.text$mn:0000088F                 cmp     [ebp+arg_0], 0
.text$mn:00000893                 jnz     short loc_897
.text$mn:00000895                 jmp     short loc_8B7
.text$mn:00000897 ; ---------------------------------------------------------------------------
.text$mn:00000897
.text$mn:00000897 loc_897:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00000897                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:0000089B                 ja      short loc_8B2
.text$mn:0000089D                 mov     eax, [ebp+arg_0]
.text$mn:000008A0                 push    eax             ; unsigned int
.text$mn:000008A1                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000008A6                 add     esp, 4
.text$mn:000008A9                 mov     [ebp+var_4], eax
.text$mn:000008AC                 cmp     [ebp+var_4], 0
.text$mn:000008B0                 jnz     short loc_8B7
.text$mn:000008B2
.text$mn:000008B2 loc_8B2:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:000008B2                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000008B7
.text$mn:000008B7 loc_8B7:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:000008B7                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:000008B7                 mov     eax, [ebp+var_4]
.text$mn:000008BA                 mov     esp, ebp
.text$mn:000008BC                 pop     ebp
.text$mn:000008BD                 retn
.text$mn:000008BD ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:000008BD
.text$mn:000008BD ; ---------------------------------------------------------------------------
.text$mn:000008BE                 align 10h
.text$mn:000008BE _text$mn        ends
.text$mn:000008BE
.text$mn:000008C0 ; ===========================================================================
.text$mn:000008C0
.text$mn:000008C0 ; Segment type: Pure code
.text$mn:000008C0 ; Segment permissions: Read/Execute
.text$mn:000008C0 _text$mn        segment para public 'CODE' use32
.text$mn:000008C0                 assume cs:_text$mn
.text$mn:000008C0                 ;org 8C0h
.text$mn:000008C0 ; COMDAT (pick any)
.text$mn:000008C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000008C0
.text$mn:000008C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000008C0
.text$mn:000008C0 ; Attributes: bp-based frame
.text$mn:000008C0
.text$mn:000008C0 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:000008C0                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:000008C0 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:000008C0                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:000008C0
.text$mn:000008C0 var_4           = dword ptr -4
.text$mn:000008C0 arg_0           = dword ptr  8
.text$mn:000008C0
.text$mn:000008C0                 push    ebp
.text$mn:000008C1                 mov     ebp, esp
.text$mn:000008C3                 push    ecx
.text$mn:000008C4                 mov     [ebp+var_4], 0
.text$mn:000008CB                 cmp     [ebp+arg_0], 0
.text$mn:000008CF                 jnz     short loc_8D3
.text$mn:000008D1                 jmp     short loc_8F9
.text$mn:000008D3 ; ---------------------------------------------------------------------------
.text$mn:000008D3
.text$mn:000008D3 loc_8D3:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:000008D3                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:000008DA                 ja      short loc_8F4
.text$mn:000008DC                 mov     eax, [ebp+arg_0]
.text$mn:000008DF                 shl     eax, 3
.text$mn:000008E2                 push    eax             ; unsigned int
.text$mn:000008E3                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000008E8                 add     esp, 4
.text$mn:000008EB                 mov     [ebp+var_4], eax
.text$mn:000008EE                 cmp     [ebp+var_4], 0
.text$mn:000008F2                 jnz     short loc_8F9
.text$mn:000008F4
.text$mn:000008F4 loc_8F4:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:000008F4                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000008F9
.text$mn:000008F9 loc_8F9:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:000008F9                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:000008F9                 mov     eax, [ebp+var_4]
.text$mn:000008FC                 mov     esp, ebp
.text$mn:000008FE                 pop     ebp
.text$mn:000008FF                 retn
.text$mn:000008FF ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:000008FF
.text$mn:000008FF _text$mn        ends
.text$mn:000008FF
.text$mn:00000900 ; ===========================================================================
.text$mn:00000900
.text$mn:00000900 ; Segment type: Pure code
.text$mn:00000900 ; Segment permissions: Read/Execute
.text$mn:00000900 _text$mn        segment para public 'CODE' use32
.text$mn:00000900                 assume cs:_text$mn
.text$mn:00000900                 ;org 900h
.text$mn:00000900 ; COMDAT (pick any)
.text$mn:00000900                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000900
.text$mn:00000900 ; =============== S U B R O U T I N E =======================================
.text$mn:00000900
.text$mn:00000900 ; Attributes: bp-based frame
.text$mn:00000900
.text$mn:00000900 ; wchar_t * __cdecl std::_Allocate<wchar_t>(unsigned int, wchar_t *)
.text$mn:00000900                 public ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
.text$mn:00000900 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z proc near
.text$mn:00000900                                         ; CODE XREF: std::allocator<wchar_t>::allocate(uint)+Dp
.text$mn:00000900
.text$mn:00000900 var_4           = dword ptr -4
.text$mn:00000900 arg_0           = dword ptr  8
.text$mn:00000900
.text$mn:00000900                 push    ebp
.text$mn:00000901                 mov     ebp, esp
.text$mn:00000903                 push    ecx
.text$mn:00000904                 mov     [ebp+var_4], 0
.text$mn:0000090B                 cmp     [ebp+arg_0], 0
.text$mn:0000090F                 jnz     short loc_913
.text$mn:00000911                 jmp     short loc_938
.text$mn:00000913 ; ---------------------------------------------------------------------------
.text$mn:00000913
.text$mn:00000913 loc_913:                                ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+Fj
.text$mn:00000913                 cmp     [ebp+arg_0], 7FFFFFFFh
.text$mn:0000091A                 ja      short loc_933
.text$mn:0000091C                 mov     eax, [ebp+arg_0]
.text$mn:0000091F                 shl     eax, 1
.text$mn:00000921                 push    eax             ; unsigned int
.text$mn:00000922                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000927                 add     esp, 4
.text$mn:0000092A                 mov     [ebp+var_4], eax
.text$mn:0000092D                 cmp     [ebp+var_4], 0
.text$mn:00000931                 jnz     short loc_938
.text$mn:00000933
.text$mn:00000933 loc_933:                                ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+1Aj
.text$mn:00000933                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000938
.text$mn:00000938 loc_938:                                ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+11j
.text$mn:00000938                                         ; std::_Allocate<wchar_t>(uint,wchar_t *)+31j
.text$mn:00000938                 mov     eax, [ebp+var_4]
.text$mn:0000093B                 mov     esp, ebp
.text$mn:0000093D                 pop     ebp
.text$mn:0000093E                 retn
.text$mn:0000093E ??$_Allocate@_W@std@@YAPA_WIPA_W@Z endp
.text$mn:0000093E
.text$mn:0000093E ; ---------------------------------------------------------------------------
.text$mn:0000093F                 align 10h
.text$mn:0000093F _text$mn        ends
.text$mn:0000093F
.text$mn:00000940 ; ===========================================================================
.text$mn:00000940
.text$mn:00000940 ; Segment type: Pure code
.text$mn:00000940 ; Segment permissions: Read/Execute
.text$mn:00000940 _text$mn        segment para public 'CODE' use32
.text$mn:00000940                 assume cs:_text$mn
.text$mn:00000940                 ;org 940h
.text$mn:00000940 ; COMDAT (pick any)
.text$mn:00000940                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000940
.text$mn:00000940 ; =============== S U B R O U T I N E =======================================
.text$mn:00000940
.text$mn:00000940 ; Attributes: bp-based frame
.text$mn:00000940
.text$mn:00000940 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:00000940                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:00000940 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:00000940                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:00000940                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:00000940
.text$mn:00000940 arg_0           = dword ptr  8
.text$mn:00000940 arg_4           = dword ptr  0Ch
.text$mn:00000940 arg_8           = dword ptr  10h
.text$mn:00000940
.text$mn:00000940                 push    ebp
.text$mn:00000941                 mov     ebp, esp
.text$mn:00000943                 cmp     [ebp+arg_0], 0
.text$mn:00000947                 jnz     short loc_95E
.text$mn:00000949                 mov     eax, [ebp+arg_8]
.text$mn:0000094C                 push    eax             ; unsigned int
.text$mn:0000094D                 mov     ecx, [ebp+arg_4]
.text$mn:00000950                 push    ecx             ; wchar_t *
.text$mn:00000951                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00000956                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000095B                 add     esp, 0Ch
.text$mn:0000095E
.text$mn:0000095E loc_95E:                                ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:0000095E                 pop     ebp
.text$mn:0000095F                 retn
.text$mn:0000095F ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:0000095F
.text$mn:0000095F _text$mn        ends
.text$mn:0000095F
.text$mn:00000960 ; ===========================================================================
.text$mn:00000960
.text$mn:00000960 ; Segment type: Pure code
.text$mn:00000960 ; Segment permissions: Read/Execute
.text$mn:00000960 _text$mn        segment para public 'CODE' use32
.text$mn:00000960                 assume cs:_text$mn
.text$mn:00000960                 ;org 960h
.text$mn:00000960 ; COMDAT (pick any)
.text$mn:00000960                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000960
.text$mn:00000960 ; =============== S U B R O U T I N E =======================================
.text$mn:00000960
.text$mn:00000960 ; Attributes: bp-based frame
.text$mn:00000960
.text$mn:00000960 ; int __cdecl std::_Debug_pointer<wchar_t>(int, wchar_t *, unsigned int)
.text$mn:00000960                 public ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z
.text$mn:00000960 ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z proc near
.text$mn:00000960                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+15p
.text$mn:00000960                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+1Bp ...
.text$mn:00000960
.text$mn:00000960 arg_0           = dword ptr  8
.text$mn:00000960 arg_4           = dword ptr  0Ch
.text$mn:00000960 arg_8           = dword ptr  10h
.text$mn:00000960
.text$mn:00000960                 push    ebp
.text$mn:00000961                 mov     ebp, esp
.text$mn:00000963                 cmp     [ebp+arg_0], 0
.text$mn:00000967                 jnz     short loc_97E
.text$mn:00000969                 mov     eax, [ebp+arg_8]
.text$mn:0000096C                 push    eax             ; unsigned int
.text$mn:0000096D                 mov     ecx, [ebp+arg_4]
.text$mn:00000970                 push    ecx             ; wchar_t *
.text$mn:00000971                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00000976                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000097B                 add     esp, 0Ch
.text$mn:0000097E
.text$mn:0000097E loc_97E:                                ; CODE XREF: std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+7j
.text$mn:0000097E                 pop     ebp
.text$mn:0000097F                 retn
.text$mn:0000097F ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z endp
.text$mn:0000097F
.text$mn:0000097F _text$mn        ends
.text$mn:0000097F
.text$mn:00000980 ; ===========================================================================
.text$mn:00000980
.text$mn:00000980 ; Segment type: Pure code
.text$mn:00000980 ; Segment permissions: Read/Execute
.text$mn:00000980 _text$mn        segment para public 'CODE' use32
.text$mn:00000980                 assume cs:_text$mn
.text$mn:00000980                 ;org 980h
.text$mn:00000980 ; COMDAT (pick any)
.text$mn:00000980                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000980
.text$mn:00000980 ; =============== S U B R O U T I N E =======================================
.text$mn:00000980
.text$mn:00000980 ; Attributes: bp-based frame
.text$mn:00000980
.text$mn:00000980 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00000980                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00000980 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00000980                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00000980                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00000980
.text$mn:00000980 arg_0           = dword ptr  8
.text$mn:00000980
.text$mn:00000980                 push    ebp
.text$mn:00000981                 mov     ebp, esp
.text$mn:00000983                 mov     eax, [ebp+arg_0]
.text$mn:00000986                 pop     ebp
.text$mn:00000987                 retn
.text$mn:00000987 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:00000987
.text$mn:00000987 _text$mn        ends
.text$mn:00000987
.text$mn:00000988 ; ===========================================================================
.text$mn:00000988
.text$mn:00000988 ; Segment type: Pure code
.text$mn:00000988 ; Segment permissions: Read/Execute
.text$mn:00000988 _text$mn        segment para public 'CODE' use32
.text$mn:00000988                 assume cs:_text$mn
.text$mn:00000988                 ;org 988h
.text$mn:00000988 ; COMDAT (pick any)
.text$mn:00000988                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000988
.text$mn:00000988 ; =============== S U B R O U T I N E =======================================
.text$mn:00000988
.text$mn:00000988 ; Attributes: bp-based frame
.text$mn:00000988
.text$mn:00000988 ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:00000988                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:00000988 ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:00000988                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:00000988                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p ...
.text$mn:00000988
.text$mn:00000988 arg_0           = dword ptr  8
.text$mn:00000988
.text$mn:00000988                 push    ebp
.text$mn:00000989                 mov     ebp, esp
.text$mn:0000098B                 mov     eax, [ebp+arg_0]
.text$mn:0000098E                 pop     ebp
.text$mn:0000098F                 retn
.text$mn:0000098F ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:0000098F
.text$mn:0000098F _text$mn        ends
.text$mn:0000098F
.text$mn:00000990 ; ===========================================================================
.text$mn:00000990
.text$mn:00000990 ; Segment type: Pure code
.text$mn:00000990 ; Segment permissions: Read/Execute
.text$mn:00000990 _text$mn        segment para public 'CODE' use32
.text$mn:00000990                 assume cs:_text$mn
.text$mn:00000990                 ;org 990h
.text$mn:00000990 ; COMDAT (pick any)
.text$mn:00000990                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000990
.text$mn:00000990 ; =============== S U B R O U T I N E =======================================
.text$mn:00000990
.text$mn:00000990 ; Attributes: bp-based frame
.text$mn:00000990
.text$mn:00000990 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00000990                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00000990 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00000990                                         ; CODE XREF: $LN19+4Bp
.text$mn:00000990
.text$mn:00000990 var_4           = dword ptr -4
.text$mn:00000990 arg_0           = dword ptr  8
.text$mn:00000990 arg_4           = dword ptr  0Ch
.text$mn:00000990
.text$mn:00000990                 push    ebp
.text$mn:00000991                 mov     ebp, esp
.text$mn:00000993                 push    ecx
.text$mn:00000994                 mov     [ebp+var_4], ecx
.text$mn:00000997                 mov     eax, [ebp+arg_4]
.text$mn:0000099A                 push    eax
.text$mn:0000099B                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000009A0                 add     esp, 4
.text$mn:000009A3                 push    eax             ; int
.text$mn:000009A4                 mov     ecx, [ebp+arg_0]
.text$mn:000009A7                 push    ecx             ; void *
.text$mn:000009A8                 mov     edx, [ebp+var_4]
.text$mn:000009AB                 push    edx             ; int
.text$mn:000009AC                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:000009B1                 add     esp, 0Ch
.text$mn:000009B4                 mov     esp, ebp
.text$mn:000009B6                 pop     ebp
.text$mn:000009B7                 retn    8
.text$mn:000009B7 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000009B7
.text$mn:000009B7 ; ---------------------------------------------------------------------------
.text$mn:000009BA                 align 4
.text$mn:000009BA _text$mn        ends
.text$mn:000009BA
.text$mn:000009BC ; ===========================================================================
.text$mn:000009BC
.text$mn:000009BC ; Segment type: Pure code
.text$mn:000009BC ; Segment permissions: Read/Execute
.text$mn:000009BC _text$mn        segment para public 'CODE' use32
.text$mn:000009BC                 assume cs:_text$mn
.text$mn:000009BC                 ;org 9BCh
.text$mn:000009BC ; COMDAT (pick any)
.text$mn:000009BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000009BC
.text$mn:000009BC ; =============== S U B R O U T I N E =======================================
.text$mn:000009BC
.text$mn:000009BC ; Attributes: bp-based frame
.text$mn:000009BC
.text$mn:000009BC ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:000009BC                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000009BC ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000009BC                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:000009BC
.text$mn:000009BC var_1C          = dword ptr -1Ch
.text$mn:000009BC var_18          = dword ptr -18h
.text$mn:000009BC var_14          = dword ptr -14h
.text$mn:000009BC var_10          = dword ptr -10h
.text$mn:000009BC var_C           = dword ptr -0Ch
.text$mn:000009BC var_4           = dword ptr -4
.text$mn:000009BC arg_0           = dword ptr  8
.text$mn:000009BC arg_4           = dword ptr  0Ch
.text$mn:000009BC
.text$mn:000009BC                 push    ebp
.text$mn:000009BD                 mov     ebp, esp
.text$mn:000009BF                 push    0FFFFFFFFh
.text$mn:000009C1                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000009C6                 mov     eax, large fs:0
.text$mn:000009CC                 push    eax
.text$mn:000009CD                 sub     esp, 10h
.text$mn:000009D0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000009D5                 xor     eax, ebp
.text$mn:000009D7                 push    eax
.text$mn:000009D8                 lea     eax, [ebp+var_C]
.text$mn:000009DB                 mov     large fs:0, eax
.text$mn:000009E1                 mov     [ebp+var_18], ecx
.text$mn:000009E4                 mov     eax, [ebp+arg_0]
.text$mn:000009E7                 push    eax             ; void *
.text$mn:000009E8                 push    4               ; unsigned int
.text$mn:000009EA                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000009EF                 add     esp, 8
.text$mn:000009F2                 mov     [ebp+var_10], eax
.text$mn:000009F5                 mov     [ebp+var_4], 0
.text$mn:000009FC                 cmp     [ebp+var_10], 0
.text$mn:00000A00                 jz      short loc_A1D
.text$mn:00000A02                 mov     ecx, [ebp+arg_4]
.text$mn:00000A05                 push    ecx
.text$mn:00000A06                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000A0B                 add     esp, 4
.text$mn:00000A0E                 mov     edx, [ebp+var_10]
.text$mn:00000A11                 mov     eax, [eax]
.text$mn:00000A13                 mov     [edx], eax
.text$mn:00000A15                 mov     ecx, [ebp+var_10]
.text$mn:00000A18                 mov     [ebp+var_14], ecx
.text$mn:00000A1B                 jmp     short loc_A24
.text$mn:00000A1D ; ---------------------------------------------------------------------------
.text$mn:00000A1D
.text$mn:00000A1D loc_A1D:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00000A1D                 mov     [ebp+var_14], 0
.text$mn:00000A24
.text$mn:00000A24 loc_A24:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00000A24                 mov     edx, [ebp+var_14]
.text$mn:00000A27                 mov     [ebp+var_1C], edx
.text$mn:00000A2A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000A31                 mov     ecx, [ebp+var_C]
.text$mn:00000A34                 mov     large fs:0, ecx
.text$mn:00000A3B                 pop     ecx
.text$mn:00000A3C                 mov     esp, ebp
.text$mn:00000A3E                 pop     ebp
.text$mn:00000A3F                 retn    8
.text$mn:00000A3F ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00000A3F
.text$mn:00000A3F ; ---------------------------------------------------------------------------
.text$mn:00000A42                 align 4
.text$mn:00000A42 _text$mn        ends
.text$mn:00000A42
.text$x:00000A44 ; ===========================================================================
.text$x:00000A44
.text$x:00000A44 ; Segment type: Pure code
.text$x:00000A44 ; Segment permissions: Read/Execute
.text$x:00000A44 _text$x         segment para public 'CODE' use32
.text$x:00000A44                 assume cs:_text$x
.text$x:00000A44                 ;org 0A44h
.text$x:00000A44 ; COMDAT (pick associative to section at 9BC)
.text$x:00000A44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00000A44
.text$x:00000A44 ; =============== S U B R O U T I N E =======================================
.text$x:00000A44
.text$x:00000A44
.text$x:00000A44 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00000A44                                         ; DATA XREF: .xdata$x:000031F4o
.text$x:00000A44                 mov     eax, [ebp+8]
.text$x:00000A47                 push    eax
.text$x:00000A48                 mov     eax, [ebp-10h]
.text$x:00000A4B                 push    eax             ; void *
.text$x:00000A4C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000A51                 add     esp, 8
.text$x:00000A54                 retn
.text$x:00000A54 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00000A54
.text$x:00000A55
.text$x:00000A55 ; =============== S U B R O U T I N E =======================================
.text$x:00000A55
.text$x:00000A55
.text$x:00000A55 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00000A55                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00000A55
.text$x:00000A55 arg_4           = dword ptr  8
.text$x:00000A55
.text$x:00000A55                 mov     edx, [esp+arg_4]
.text$x:00000A59                 lea     eax, [edx+0Ch]
.text$x:00000A5C                 mov     ecx, [edx-14h]
.text$x:00000A5F                 xor     ecx, eax
.text$x:00000A61                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000A66                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:00000A6B                 jmp     ___CxxFrameHandler3
.text$x:00000A6B __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:00000A6B
.text$x:00000A6B _text$x         ends
.text$x:00000A6B
.text$mn:00000A70 ; ===========================================================================
.text$mn:00000A70
.text$mn:00000A70 ; Segment type: Pure code
.text$mn:00000A70 ; Segment permissions: Read/Execute
.text$mn:00000A70 _text$mn        segment para public 'CODE' use32
.text$mn:00000A70                 assume cs:_text$mn
.text$mn:00000A70                 ;org 0A70h
.text$mn:00000A70 ; COMDAT (pick any)
.text$mn:00000A70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000A70
.text$mn:00000A70 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A70
.text$mn:00000A70 ; Attributes: bp-based frame
.text$mn:00000A70
.text$mn:00000A70 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00000A70                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00000A70 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00000A70                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00000A70
.text$mn:00000A70 arg_0           = dword ptr  8
.text$mn:00000A70 arg_4           = dword ptr  0Ch
.text$mn:00000A70 arg_8           = dword ptr  10h
.text$mn:00000A70
.text$mn:00000A70                 push    ebp
.text$mn:00000A71                 mov     ebp, esp
.text$mn:00000A73                 mov     eax, [ebp+arg_8]
.text$mn:00000A76                 push    eax
.text$mn:00000A77                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000A7C                 add     esp, 4
.text$mn:00000A7F                 push    eax             ; int
.text$mn:00000A80                 mov     ecx, [ebp+arg_4]
.text$mn:00000A83                 push    ecx             ; void *
.text$mn:00000A84                 mov     ecx, [ebp+arg_0]
.text$mn:00000A87                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00000A8C                 pop     ebp
.text$mn:00000A8D                 retn
.text$mn:00000A8D ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00000A8D
.text$mn:00000A8D ; ---------------------------------------------------------------------------
.text$mn:00000A8E                 align 10h
.text$mn:00000A8E _text$mn        ends
.text$mn:00000A8E
.text$mn:00000A90 ; ===========================================================================
.text$mn:00000A90
.text$mn:00000A90 ; Segment type: Pure code
.text$mn:00000A90 ; Segment permissions: Read/Execute
.text$mn:00000A90 _text$mn        segment para public 'CODE' use32
.text$mn:00000A90                 assume cs:_text$mn
.text$mn:00000A90                 ;org 0A90h
.text$mn:00000A90 ; COMDAT (pick any)
.text$mn:00000A90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000A90
.text$mn:00000A90 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A90
.text$mn:00000A90 ; Attributes: bp-based frame
.text$mn:00000A90
.text$mn:00000A90 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00000A90                 public ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00000A90 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00000A90                                         ; CODE XREF: $LN19_0+4Bp
.text$mn:00000A90
.text$mn:00000A90 var_4           = dword ptr -4
.text$mn:00000A90 arg_0           = dword ptr  8
.text$mn:00000A90 arg_4           = dword ptr  0Ch
.text$mn:00000A90
.text$mn:00000A90                 push    ebp
.text$mn:00000A91                 mov     ebp, esp
.text$mn:00000A93                 push    ecx
.text$mn:00000A94                 mov     [ebp+var_4], ecx
.text$mn:00000A97                 mov     eax, [ebp+arg_4]
.text$mn:00000A9A                 push    eax
.text$mn:00000A9B                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00000AA0                 add     esp, 4
.text$mn:00000AA3                 push    eax             ; int
.text$mn:00000AA4                 mov     ecx, [ebp+arg_0]
.text$mn:00000AA7                 push    ecx             ; void *
.text$mn:00000AA8                 mov     edx, [ebp+var_4]
.text$mn:00000AAB                 push    edx             ; int
.text$mn:00000AAC                 call    ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)
.text$mn:00000AB1                 add     esp, 0Ch
.text$mn:00000AB4                 mov     esp, ebp
.text$mn:00000AB6                 pop     ebp
.text$mn:00000AB7                 retn    8
.text$mn:00000AB7 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:00000AB7
.text$mn:00000AB7 ; ---------------------------------------------------------------------------
.text$mn:00000ABA                 align 4
.text$mn:00000ABA _text$mn        ends
.text$mn:00000ABA
.text$mn:00000ABC ; ===========================================================================
.text$mn:00000ABC
.text$mn:00000ABC ; Segment type: Pure code
.text$mn:00000ABC ; Segment permissions: Read/Execute
.text$mn:00000ABC _text$mn        segment para public 'CODE' use32
.text$mn:00000ABC                 assume cs:_text$mn
.text$mn:00000ABC                 ;org 0ABCh
.text$mn:00000ABC ; COMDAT (pick any)
.text$mn:00000ABC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000ABC
.text$mn:00000ABC ; =============== S U B R O U T I N E =======================================
.text$mn:00000ABC
.text$mn:00000ABC ; Attributes: bp-based frame
.text$mn:00000ABC
.text$mn:00000ABC ; int __stdcall std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00000ABC                 public ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00000ABC ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00000ABC                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)+17p
.text$mn:00000ABC
.text$mn:00000ABC var_1C          = dword ptr -1Ch
.text$mn:00000ABC var_18          = dword ptr -18h
.text$mn:00000ABC var_14          = dword ptr -14h
.text$mn:00000ABC var_10          = dword ptr -10h
.text$mn:00000ABC var_C           = dword ptr -0Ch
.text$mn:00000ABC var_4           = dword ptr -4
.text$mn:00000ABC arg_0           = dword ptr  8
.text$mn:00000ABC arg_4           = dword ptr  0Ch
.text$mn:00000ABC
.text$mn:00000ABC                 push    ebp
.text$mn:00000ABD                 mov     ebp, esp
.text$mn:00000ABF                 push    0FFFFFFFFh
.text$mn:00000AC1                 push    offset __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00000AC6                 mov     eax, large fs:0
.text$mn:00000ACC                 push    eax
.text$mn:00000ACD                 sub     esp, 10h
.text$mn:00000AD0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000AD5                 xor     eax, ebp
.text$mn:00000AD7                 push    eax
.text$mn:00000AD8                 lea     eax, [ebp+var_C]
.text$mn:00000ADB                 mov     large fs:0, eax
.text$mn:00000AE1                 mov     [ebp+var_18], ecx
.text$mn:00000AE4                 mov     eax, [ebp+arg_0]
.text$mn:00000AE7                 push    eax             ; void *
.text$mn:00000AE8                 push    4               ; unsigned int
.text$mn:00000AEA                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000AEF                 add     esp, 8
.text$mn:00000AF2                 mov     [ebp+var_10], eax
.text$mn:00000AF5                 mov     [ebp+var_4], 0
.text$mn:00000AFC                 cmp     [ebp+var_10], 0
.text$mn:00000B00                 jz      short loc_B1D
.text$mn:00000B02                 mov     ecx, [ebp+arg_4]
.text$mn:00000B05                 push    ecx
.text$mn:00000B06                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00000B0B                 add     esp, 4
.text$mn:00000B0E                 mov     edx, [ebp+var_10]
.text$mn:00000B11                 mov     eax, [eax]
.text$mn:00000B13                 mov     [edx], eax
.text$mn:00000B15                 mov     ecx, [ebp+var_10]
.text$mn:00000B18                 mov     [ebp+var_14], ecx
.text$mn:00000B1B                 jmp     short loc_B24
.text$mn:00000B1D ; ---------------------------------------------------------------------------
.text$mn:00000B1D
.text$mn:00000B1D loc_B1D:                                ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+44j
.text$mn:00000B1D                 mov     [ebp+var_14], 0
.text$mn:00000B24
.text$mn:00000B24 loc_B24:                                ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5Fj
.text$mn:00000B24                 mov     edx, [ebp+var_14]
.text$mn:00000B27                 mov     [ebp+var_1C], edx
.text$mn:00000B2A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000B31                 mov     ecx, [ebp+var_C]
.text$mn:00000B34                 mov     large fs:0, ecx
.text$mn:00000B3B                 pop     ecx
.text$mn:00000B3C                 mov     esp, ebp
.text$mn:00000B3E                 pop     ebp
.text$mn:00000B3F                 retn    8
.text$mn:00000B3F ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:00000B3F
.text$mn:00000B3F ; ---------------------------------------------------------------------------
.text$mn:00000B42                 align 4
.text$mn:00000B42 _text$mn        ends
.text$mn:00000B42
.text$x:00000B44 ; ===========================================================================
.text$x:00000B44
.text$x:00000B44 ; Segment type: Pure code
.text$x:00000B44 ; Segment permissions: Read/Execute
.text$x:00000B44 _text$x         segment para public 'CODE' use32
.text$x:00000B44                 assume cs:_text$x
.text$x:00000B44                 ;org 0B44h
.text$x:00000B44 ; COMDAT (pick associative to section at ABC)
.text$x:00000B44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00000B44
.text$x:00000B44 ; =============== S U B R O U T I N E =======================================
.text$x:00000B44
.text$x:00000B44
.text$x:00000B44 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 proc near
.text$x:00000B44                                         ; DATA XREF: .xdata$x:00003220o
.text$x:00000B44                 mov     eax, [ebp+8]
.text$x:00000B47                 push    eax
.text$x:00000B48                 mov     eax, [ebp-10h]
.text$x:00000B4B                 push    eax             ; void *
.text$x:00000B4C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000B51                 add     esp, 8
.text$x:00000B54                 retn
.text$x:00000B54 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 endp
.text$x:00000B54
.text$x:00000B55
.text$x:00000B55 ; =============== S U B R O U T I N E =======================================
.text$x:00000B55
.text$x:00000B55
.text$x:00000B55 __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$x:00000B55                                         ; DATA XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5o
.text$x:00000B55
.text$x:00000B55 arg_4           = dword ptr  8
.text$x:00000B55
.text$x:00000B55                 mov     edx, [esp+arg_4]
.text$x:00000B59                 lea     eax, [edx+0Ch]
.text$x:00000B5C                 mov     ecx, [edx-14h]
.text$x:00000B5F                 xor     ecx, eax
.text$x:00000B61                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000B66                 mov     eax, offset __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$x:00000B6B                 jmp     ___CxxFrameHandler3
.text$x:00000B6B __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$x:00000B6B
.text$x:00000B6B _text$x         ends
.text$x:00000B6B
.text$mn:00000B70 ; ===========================================================================
.text$mn:00000B70
.text$mn:00000B70 ; Segment type: Pure code
.text$mn:00000B70 ; Segment permissions: Read/Execute
.text$mn:00000B70 _text$mn        segment para public 'CODE' use32
.text$mn:00000B70                 assume cs:_text$mn
.text$mn:00000B70                 ;org 0B70h
.text$mn:00000B70 ; COMDAT (pick any)
.text$mn:00000B70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000B70
.text$mn:00000B70 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B70
.text$mn:00000B70 ; Attributes: bp-based frame
.text$mn:00000B70
.text$mn:00000B70 ; int __cdecl std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(int, void *, int)
.text$mn:00000B70                 public ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
.text$mn:00000B70 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z proc near
.text$mn:00000B70                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+1Cp
.text$mn:00000B70
.text$mn:00000B70 arg_0           = dword ptr  8
.text$mn:00000B70 arg_4           = dword ptr  0Ch
.text$mn:00000B70 arg_8           = dword ptr  10h
.text$mn:00000B70
.text$mn:00000B70                 push    ebp
.text$mn:00000B71                 mov     ebp, esp
.text$mn:00000B73                 mov     eax, [ebp+arg_8]
.text$mn:00000B76                 push    eax
.text$mn:00000B77                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00000B7C                 add     esp, 4
.text$mn:00000B7F                 push    eax             ; int
.text$mn:00000B80                 mov     ecx, [ebp+arg_4]
.text$mn:00000B83                 push    ecx             ; void *
.text$mn:00000B84                 mov     ecx, [ebp+arg_0]
.text$mn:00000B87                 call    ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:00000B8C                 pop     ebp
.text$mn:00000B8D                 retn
.text$mn:00000B8D ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z endp
.text$mn:00000B8D
.text$mn:00000B8D ; ---------------------------------------------------------------------------
.text$mn:00000B8E                 align 10h
.text$mn:00000B8E _text$mn        ends
.text$mn:00000B8E
.text$mn:00000B90 ; ===========================================================================
.text$mn:00000B90
.text$mn:00000B90 ; Segment type: Pure code
.text$mn:00000B90 ; Segment permissions: Read/Execute
.text$mn:00000B90 _text$mn        segment para public 'CODE' use32
.text$mn:00000B90                 assume cs:_text$mn
.text$mn:00000B90                 ;org 0B90h
.text$mn:00000B90 ; COMDAT (pick any)
.text$mn:00000B90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000B90
.text$mn:00000B90 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B90
.text$mn:00000B90 ; Attributes: bp-based frame
.text$mn:00000B90
.text$mn:00000B90 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00000B90                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00000B90 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00000B90                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00000B90
.text$mn:00000B90 var_1C          = dword ptr -1Ch
.text$mn:00000B90 var_18          = dword ptr -18h
.text$mn:00000B90 var_14          = dword ptr -14h
.text$mn:00000B90 var_10          = dword ptr -10h
.text$mn:00000B90 var_C           = dword ptr -0Ch
.text$mn:00000B90 var_4           = dword ptr -4
.text$mn:00000B90 arg_0           = dword ptr  8
.text$mn:00000B90 arg_4           = dword ptr  0Ch
.text$mn:00000B90
.text$mn:00000B90                 push    ebp
.text$mn:00000B91                 mov     ebp, esp
.text$mn:00000B93                 push    0FFFFFFFFh
.text$mn:00000B95                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00000B9A                 mov     eax, large fs:0
.text$mn:00000BA0                 push    eax
.text$mn:00000BA1                 sub     esp, 10h
.text$mn:00000BA4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000BA9                 xor     eax, ebp
.text$mn:00000BAB                 push    eax
.text$mn:00000BAC                 lea     eax, [ebp+var_C]
.text$mn:00000BAF                 mov     large fs:0, eax
.text$mn:00000BB5                 mov     [ebp+var_18], ecx
.text$mn:00000BB8                 mov     eax, [ebp+arg_0]
.text$mn:00000BBB                 push    eax             ; void *
.text$mn:00000BBC                 push    8               ; unsigned int
.text$mn:00000BBE                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000BC3                 add     esp, 8
.text$mn:00000BC6                 mov     [ebp+var_10], eax
.text$mn:00000BC9                 mov     [ebp+var_4], 0
.text$mn:00000BD0                 cmp     [ebp+var_10], 0
.text$mn:00000BD4                 jz      short loc_BF7
.text$mn:00000BD6                 mov     ecx, [ebp+arg_4]
.text$mn:00000BD9                 push    ecx
.text$mn:00000BDA                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00000BDF                 add     esp, 4
.text$mn:00000BE2                 mov     edx, [eax]
.text$mn:00000BE4                 mov     eax, [eax+4]
.text$mn:00000BE7                 mov     ecx, [ebp+var_10]
.text$mn:00000BEA                 mov     [ecx], edx
.text$mn:00000BEC                 mov     [ecx+4], eax
.text$mn:00000BEF                 mov     edx, [ebp+var_10]
.text$mn:00000BF2                 mov     [ebp+var_14], edx
.text$mn:00000BF5                 jmp     short loc_BFE
.text$mn:00000BF7 ; ---------------------------------------------------------------------------
.text$mn:00000BF7
.text$mn:00000BF7 loc_BF7:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00000BF7                 mov     [ebp+var_14], 0
.text$mn:00000BFE
.text$mn:00000BFE loc_BFE:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00000BFE                 mov     eax, [ebp+var_14]
.text$mn:00000C01                 mov     [ebp+var_1C], eax
.text$mn:00000C04                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000C0B                 mov     ecx, [ebp+var_C]
.text$mn:00000C0E                 mov     large fs:0, ecx
.text$mn:00000C15                 pop     ecx
.text$mn:00000C16                 mov     esp, ebp
.text$mn:00000C18                 pop     ebp
.text$mn:00000C19                 retn    8
.text$mn:00000C19 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00000C19
.text$mn:00000C19 _text$mn        ends
.text$mn:00000C19
.text$x:00000C1C ; ===========================================================================
.text$x:00000C1C
.text$x:00000C1C ; Segment type: Pure code
.text$x:00000C1C ; Segment permissions: Read/Execute
.text$x:00000C1C _text$x         segment para public 'CODE' use32
.text$x:00000C1C                 assume cs:_text$x
.text$x:00000C1C                 ;org 0C1Ch
.text$x:00000C1C ; COMDAT (pick associative to section at B90)
.text$x:00000C1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00000C1C
.text$x:00000C1C ; =============== S U B R O U T I N E =======================================
.text$x:00000C1C
.text$x:00000C1C
.text$x:00000C1C __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00000C1C                                         ; DATA XREF: .xdata$x:000031C8o
.text$x:00000C1C                 mov     eax, [ebp+8]
.text$x:00000C1F                 push    eax
.text$x:00000C20                 mov     eax, [ebp-10h]
.text$x:00000C23                 push    eax             ; void *
.text$x:00000C24                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000C29                 add     esp, 8
.text$x:00000C2C                 retn
.text$x:00000C2C __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00000C2C
.text$x:00000C2D
.text$x:00000C2D ; =============== S U B R O U T I N E =======================================
.text$x:00000C2D
.text$x:00000C2D
.text$x:00000C2D __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00000C2D                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00000C2D
.text$x:00000C2D arg_4           = dword ptr  8
.text$x:00000C2D
.text$x:00000C2D                 mov     edx, [esp+arg_4]
.text$x:00000C31                 lea     eax, [edx+0Ch]
.text$x:00000C34                 mov     ecx, [edx-14h]
.text$x:00000C37                 xor     ecx, eax
.text$x:00000C39                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000C3E                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00000C43                 jmp     ___CxxFrameHandler3
.text$x:00000C43 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00000C43
.text$x:00000C43 _text$x         ends
.text$x:00000C43
.text$mn:00000C48 ; ===========================================================================
.text$mn:00000C48
.text$mn:00000C48 ; Segment type: Pure code
.text$mn:00000C48 ; Segment permissions: Read/Execute
.text$mn:00000C48 _text$mn        segment para public 'CODE' use32
.text$mn:00000C48                 assume cs:_text$mn
.text$mn:00000C48                 ;org 0C48h
.text$mn:00000C48 ; COMDAT (pick any)
.text$mn:00000C48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000C48
.text$mn:00000C48 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C48
.text$mn:00000C48 ; Attributes: bp-based frame
.text$mn:00000C48
.text$mn:00000C48 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00000C48                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00000C48 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00000C48                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00000C48
.text$mn:00000C48 var_4           = dword ptr -4
.text$mn:00000C48 arg_0           = dword ptr  8
.text$mn:00000C48
.text$mn:00000C48                 push    ebp
.text$mn:00000C49                 mov     ebp, esp
.text$mn:00000C4B                 push    ecx
.text$mn:00000C4C                 mov     [ebp+var_4], ecx
.text$mn:00000C4F                 mov     eax, [ebp+arg_0]
.text$mn:00000C52                 push    eax
.text$mn:00000C53                 mov     ecx, [ebp+var_4]
.text$mn:00000C56                 push    ecx
.text$mn:00000C57                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00000C5C                 add     esp, 8
.text$mn:00000C5F                 mov     esp, ebp
.text$mn:00000C61                 pop     ebp
.text$mn:00000C62                 retn    4
.text$mn:00000C62 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00000C62
.text$mn:00000C62 ; ---------------------------------------------------------------------------
.text$mn:00000C65                 align 4
.text$mn:00000C65 _text$mn        ends
.text$mn:00000C65
.text$mn:00000C68 ; ===========================================================================
.text$mn:00000C68
.text$mn:00000C68 ; Segment type: Pure code
.text$mn:00000C68 ; Segment permissions: Read/Execute
.text$mn:00000C68 _text$mn        segment para public 'CODE' use32
.text$mn:00000C68                 assume cs:_text$mn
.text$mn:00000C68                 ;org 0C68h
.text$mn:00000C68 ; COMDAT (pick any)
.text$mn:00000C68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000C68
.text$mn:00000C68 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C68
.text$mn:00000C68 ; Attributes: bp-based frame
.text$mn:00000C68
.text$mn:00000C68 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000C68                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00000C68 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00000C68                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00000C68
.text$mn:00000C68 var_4           = dword ptr -4
.text$mn:00000C68
.text$mn:00000C68                 push    ebp
.text$mn:00000C69                 mov     ebp, esp
.text$mn:00000C6B                 push    ecx
.text$mn:00000C6C                 mov     [ebp+var_4], ecx
.text$mn:00000C6F                 mov     esp, ebp
.text$mn:00000C71                 pop     ebp
.text$mn:00000C72                 retn    4
.text$mn:00000C72 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00000C72
.text$mn:00000C72 ; ---------------------------------------------------------------------------
.text$mn:00000C75                 align 4
.text$mn:00000C75 _text$mn        ends
.text$mn:00000C75
.text$mn:00000C78 ; ===========================================================================
.text$mn:00000C78
.text$mn:00000C78 ; Segment type: Pure code
.text$mn:00000C78 ; Segment permissions: Read/Execute
.text$mn:00000C78 _text$mn        segment para public 'CODE' use32
.text$mn:00000C78                 assume cs:_text$mn
.text$mn:00000C78                 ;org 0C78h
.text$mn:00000C78 ; COMDAT (pick any)
.text$mn:00000C78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000C78
.text$mn:00000C78 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C78
.text$mn:00000C78 ; Attributes: bp-based frame
.text$mn:00000C78
.text$mn:00000C78 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00000C78                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00000C78 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00000C78                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00000C78
.text$mn:00000C78 arg_0           = dword ptr  8
.text$mn:00000C78 arg_4           = dword ptr  0Ch
.text$mn:00000C78
.text$mn:00000C78                 push    ebp
.text$mn:00000C79                 mov     ebp, esp
.text$mn:00000C7B                 mov     eax, [ebp+arg_4]
.text$mn:00000C7E                 push    eax
.text$mn:00000C7F                 mov     ecx, [ebp+arg_0]
.text$mn:00000C82                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000C87                 pop     ebp
.text$mn:00000C88                 retn
.text$mn:00000C88 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00000C88
.text$mn:00000C88 ; ---------------------------------------------------------------------------
.text$mn:00000C89                 align 4
.text$mn:00000C89 _text$mn        ends
.text$mn:00000C89
.text$mn:00000C8C ; ===========================================================================
.text$mn:00000C8C
.text$mn:00000C8C ; Segment type: Pure code
.text$mn:00000C8C ; Segment permissions: Read/Execute
.text$mn:00000C8C _text$mn        segment para public 'CODE' use32
.text$mn:00000C8C                 assume cs:_text$mn
.text$mn:00000C8C                 ;org 0C8Ch
.text$mn:00000C8C ; COMDAT (pick any)
.text$mn:00000C8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000C8C
.text$mn:00000C8C ; =============== S U B R O U T I N E =======================================
.text$mn:00000C8C
.text$mn:00000C8C ; Attributes: bp-based frame
.text$mn:00000C8C
.text$mn:00000C8C ; public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00000C8C                 public ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
.text$mn:00000C8C ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z proc near
.text$mn:00000C8C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+3Ap
.text$mn:00000C8C
.text$mn:00000C8C var_4           = dword ptr -4
.text$mn:00000C8C arg_0           = dword ptr  8
.text$mn:00000C8C
.text$mn:00000C8C                 push    ebp
.text$mn:00000C8D                 mov     ebp, esp
.text$mn:00000C8F                 push    ecx
.text$mn:00000C90                 mov     [ebp+var_4], ecx
.text$mn:00000C93                 mov     eax, [ebp+arg_0]
.text$mn:00000C96                 push    eax
.text$mn:00000C97                 mov     ecx, [ebp+var_4]
.text$mn:00000C9A                 push    ecx
.text$mn:00000C9B                 call    ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)
.text$mn:00000CA0                 add     esp, 8
.text$mn:00000CA3                 mov     esp, ebp
.text$mn:00000CA5                 pop     ebp
.text$mn:00000CA6                 retn    4
.text$mn:00000CA6 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z endp
.text$mn:00000CA6
.text$mn:00000CA6 ; ---------------------------------------------------------------------------
.text$mn:00000CA9                 align 4
.text$mn:00000CA9 _text$mn        ends
.text$mn:00000CA9
.text$mn:00000CAC ; ===========================================================================
.text$mn:00000CAC
.text$mn:00000CAC ; Segment type: Pure code
.text$mn:00000CAC ; Segment permissions: Read/Execute
.text$mn:00000CAC _text$mn        segment para public 'CODE' use32
.text$mn:00000CAC                 assume cs:_text$mn
.text$mn:00000CAC                 ;org 0CACh
.text$mn:00000CAC ; COMDAT (pick any)
.text$mn:00000CAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000CAC
.text$mn:00000CAC ; =============== S U B R O U T I N E =======================================
.text$mn:00000CAC
.text$mn:00000CAC ; Attributes: bp-based frame
.text$mn:00000CAC
.text$mn:00000CAC ; public: void __thiscall std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00000CAC                 public ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
.text$mn:00000CAC ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z proc near
.text$mn:00000CAC                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)+Ap
.text$mn:00000CAC
.text$mn:00000CAC var_4           = dword ptr -4
.text$mn:00000CAC
.text$mn:00000CAC                 push    ebp
.text$mn:00000CAD                 mov     ebp, esp
.text$mn:00000CAF                 push    ecx
.text$mn:00000CB0                 mov     [ebp+var_4], ecx
.text$mn:00000CB3                 mov     esp, ebp
.text$mn:00000CB5                 pop     ebp
.text$mn:00000CB6                 retn    4
.text$mn:00000CB6 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z endp
.text$mn:00000CB6
.text$mn:00000CB6 ; ---------------------------------------------------------------------------
.text$mn:00000CB9                 align 4
.text$mn:00000CB9 _text$mn        ends
.text$mn:00000CB9
.text$mn:00000CBC ; ===========================================================================
.text$mn:00000CBC
.text$mn:00000CBC ; Segment type: Pure code
.text$mn:00000CBC ; Segment permissions: Read/Execute
.text$mn:00000CBC _text$mn        segment para public 'CODE' use32
.text$mn:00000CBC                 assume cs:_text$mn
.text$mn:00000CBC                 ;org 0CBCh
.text$mn:00000CBC ; COMDAT (pick any)
.text$mn:00000CBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000CBC
.text$mn:00000CBC ; =============== S U B R O U T I N E =======================================
.text$mn:00000CBC
.text$mn:00000CBC ; Attributes: bp-based frame
.text$mn:00000CBC
.text$mn:00000CBC ; public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>>::destroy<wchar_t *>(class std::allocator<wchar_t> &, wchar_t * *)
.text$mn:00000CBC                 public ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
.text$mn:00000CBC ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z proc near
.text$mn:00000CBC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)+Fp
.text$mn:00000CBC
.text$mn:00000CBC arg_0           = dword ptr  8
.text$mn:00000CBC arg_4           = dword ptr  0Ch
.text$mn:00000CBC
.text$mn:00000CBC                 push    ebp
.text$mn:00000CBD                 mov     ebp, esp
.text$mn:00000CBF                 mov     eax, [ebp+arg_4]
.text$mn:00000CC2                 push    eax
.text$mn:00000CC3                 mov     ecx, [ebp+arg_0]
.text$mn:00000CC6                 call    ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00000CCB                 pop     ebp
.text$mn:00000CCC                 retn
.text$mn:00000CCC ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z endp
.text$mn:00000CCC
.text$mn:00000CCC ; ---------------------------------------------------------------------------
.text$mn:00000CCD                 align 10h
.text$mn:00000CCD _text$mn        ends
.text$mn:00000CCD
.text$mn:00000CD0 ; ===========================================================================
.text$mn:00000CD0
.text$mn:00000CD0 ; Segment type: Pure code
.text$mn:00000CD0 ; Segment permissions: Read/Execute
.text$mn:00000CD0 _text$mn        segment para public 'CODE' use32
.text$mn:00000CD0                 assume cs:_text$mn
.text$mn:00000CD0                 ;org 0CD0h
.text$mn:00000CD0 ; COMDAT (pick any)
.text$mn:00000CD0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000CD0
.text$mn:00000CD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CD0
.text$mn:00000CD0 ; Attributes: bp-based frame
.text$mn:00000CD0
.text$mn:00000CD0 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00000CD0                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00000CD0 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00000CD0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00000CD0
.text$mn:00000CD0 var_4           = dword ptr -4
.text$mn:00000CD0
.text$mn:00000CD0                 push    ebp
.text$mn:00000CD1                 mov     ebp, esp
.text$mn:00000CD3                 push    ecx
.text$mn:00000CD4                 mov     [ebp+var_4], ecx
.text$mn:00000CD7                 mov     esp, ebp
.text$mn:00000CD9                 pop     ebp
.text$mn:00000CDA                 retn    4
.text$mn:00000CDA ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00000CDA
.text$mn:00000CDA ; ---------------------------------------------------------------------------
.text$mn:00000CDD                 align 10h
.text$mn:00000CDD _text$mn        ends
.text$mn:00000CDD
.text$mn:00000CE0 ; ===========================================================================
.text$mn:00000CE0
.text$mn:00000CE0 ; Segment type: Pure code
.text$mn:00000CE0 ; Segment permissions: Read/Execute
.text$mn:00000CE0 _text$mn        segment para public 'CODE' use32
.text$mn:00000CE0                 assume cs:_text$mn
.text$mn:00000CE0                 ;org 0CE0h
.text$mn:00000CE0 ; COMDAT (pick any)
.text$mn:00000CE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000CE0
.text$mn:00000CE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CE0
.text$mn:00000CE0 ; Attributes: bp-based frame
.text$mn:00000CE0
.text$mn:00000CE0 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00000CE0                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00000CE0 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00000CE0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00000CE0                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00000CE0
.text$mn:00000CE0 arg_0           = dword ptr  8
.text$mn:00000CE0
.text$mn:00000CE0                 push    ebp
.text$mn:00000CE1                 mov     ebp, esp
.text$mn:00000CE3                 mov     eax, [ebp+arg_0]
.text$mn:00000CE6                 pop     ebp
.text$mn:00000CE7                 retn
.text$mn:00000CE7 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00000CE7
.text$mn:00000CE7 _text$mn        ends
.text$mn:00000CE7
.text$mn:00000CE8 ; ===========================================================================
.text$mn:00000CE8
.text$mn:00000CE8 ; Segment type: Pure code
.text$mn:00000CE8 ; Segment permissions: Read/Execute
.text$mn:00000CE8 _text$mn        segment para public 'CODE' use32
.text$mn:00000CE8                 assume cs:_text$mn
.text$mn:00000CE8                 ;org 0CE8h
.text$mn:00000CE8 ; COMDAT (pick any)
.text$mn:00000CE8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000CE8
.text$mn:00000CE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CE8
.text$mn:00000CE8 ; Attributes: bp-based frame
.text$mn:00000CE8
.text$mn:00000CE8 ; wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00000CE8                 public ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
.text$mn:00000CE8 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z proc near
.text$mn:00000CE8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+Bp
.text$mn:00000CE8                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+4Ap ...
.text$mn:00000CE8
.text$mn:00000CE8 arg_0           = dword ptr  8
.text$mn:00000CE8
.text$mn:00000CE8                 push    ebp
.text$mn:00000CE9                 mov     ebp, esp
.text$mn:00000CEB                 mov     eax, [ebp+arg_0]
.text$mn:00000CEE                 pop     ebp
.text$mn:00000CEF                 retn
.text$mn:00000CEF ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z endp
.text$mn:00000CEF
.text$mn:00000CEF _text$mn        ends
.text$mn:00000CEF
.text$mn:00000CF0 ; ===========================================================================
.text$mn:00000CF0
.text$mn:00000CF0 ; Segment type: Pure code
.text$mn:00000CF0 ; Segment permissions: Read/Execute
.text$mn:00000CF0 _text$mn        segment para public 'CODE' use32
.text$mn:00000CF0                 assume cs:_text$mn
.text$mn:00000CF0                 ;org 0CF0h
.text$mn:00000CF0 ; COMDAT (pick any)
.text$mn:00000CF0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000CF0
.text$mn:00000CF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CF0
.text$mn:00000CF0 ; Attributes: bp-based frame
.text$mn:00000CF0
.text$mn:00000CF0 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00000CF0                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00000CF0 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00000CF0                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00000CF0
.text$mn:00000CF0 arg_0           = dword ptr  8
.text$mn:00000CF0
.text$mn:00000CF0                 push    ebp
.text$mn:00000CF1                 mov     ebp, esp
.text$mn:00000CF3                 mov     eax, [ebp+arg_0]
.text$mn:00000CF6                 pop     ebp
.text$mn:00000CF7                 retn
.text$mn:00000CF7 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00000CF7
.text$mn:00000CF7 _text$mn        ends
.text$mn:00000CF7
.text$mn:00000CF8 ; ===========================================================================
.text$mn:00000CF8
.text$mn:00000CF8 ; Segment type: Pure code
.text$mn:00000CF8 ; Segment permissions: Read/Execute
.text$mn:00000CF8 _text$mn        segment para public 'CODE' use32
.text$mn:00000CF8                 assume cs:_text$mn
.text$mn:00000CF8                 ;org 0CF8h
.text$mn:00000CF8 ; COMDAT (pick any)
.text$mn:00000CF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000CF8
.text$mn:00000CF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CF8
.text$mn:00000CF8 ; Attributes: bp-based frame
.text$mn:00000CF8
.text$mn:00000CF8 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00000CF8                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000CF8 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00000CF8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00000CF8
.text$mn:00000CF8 var_10          = dword ptr -10h
.text$mn:00000CF8 var_C           = dword ptr -0Ch
.text$mn:00000CF8 var_4           = dword ptr -4
.text$mn:00000CF8
.text$mn:00000CF8                 push    ebp
.text$mn:00000CF9                 mov     ebp, esp
.text$mn:00000CFB                 push    0FFFFFFFFh
.text$mn:00000CFD                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000D02                 mov     eax, large fs:0
.text$mn:00000D08                 push    eax
.text$mn:00000D09                 push    ecx
.text$mn:00000D0A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000D0F                 xor     eax, ebp
.text$mn:00000D11                 push    eax
.text$mn:00000D12                 lea     eax, [ebp+var_C]
.text$mn:00000D15                 mov     large fs:0, eax
.text$mn:00000D1B                 mov     [ebp+var_10], ecx
.text$mn:00000D1E                 mov     ecx, [ebp+var_10]
.text$mn:00000D21                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00000D26                 mov     [ebp+var_4], 0
.text$mn:00000D2D                 mov     ecx, [ebp+var_10]
.text$mn:00000D30                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00000D35                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000D3C                 mov     eax, [ebp+var_10]
.text$mn:00000D3F                 mov     ecx, [ebp+var_C]
.text$mn:00000D42                 mov     large fs:0, ecx
.text$mn:00000D49                 pop     ecx
.text$mn:00000D4A                 mov     esp, ebp
.text$mn:00000D4C                 pop     ebp
.text$mn:00000D4D                 retn    4
.text$mn:00000D4D ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00000D4D
.text$mn:00000D4D _text$mn        ends
.text$mn:00000D4D
.text$x:00000D50 ; ===========================================================================
.text$x:00000D50
.text$x:00000D50 ; Segment type: Pure code
.text$x:00000D50 ; Segment permissions: Read/Execute
.text$x:00000D50 _text$x         segment para public 'CODE' use32
.text$x:00000D50                 assume cs:_text$x
.text$x:00000D50                 ;org 0D50h
.text$x:00000D50 ; COMDAT (pick associative to section at CF8)
.text$x:00000D50                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00000D50
.text$x:00000D50 ; =============== S U B R O U T I N E =======================================
.text$x:00000D50
.text$x:00000D50
.text$x:00000D50 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00000D50                                         ; DATA XREF: .xdata$x:00002E74o
.text$x:00000D50                 mov     ecx, [ebp-10h]
.text$x:00000D53                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00000D53 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00000D53
.text$x:00000D58
.text$x:00000D58 ; =============== S U B R O U T I N E =======================================
.text$x:00000D58
.text$x:00000D58
.text$x:00000D58 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00000D58                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00000D58
.text$x:00000D58 arg_4           = dword ptr  8
.text$x:00000D58
.text$x:00000D58                 mov     edx, [esp+arg_4]
.text$x:00000D5C                 lea     eax, [edx+0Ch]
.text$x:00000D5F                 mov     ecx, [edx-8]
.text$x:00000D62                 xor     ecx, eax
.text$x:00000D64                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000D69                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00000D6E                 jmp     ___CxxFrameHandler3
.text$x:00000D6E __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00000D6E
.text$x:00000D6E ; ---------------------------------------------------------------------------
.text$x:00000D73                 align 4
.text$x:00000D73 _text$x         ends
.text$x:00000D73
.text$mn:00000D74 ; ===========================================================================
.text$mn:00000D74
.text$mn:00000D74 ; Segment type: Pure code
.text$mn:00000D74 ; Segment permissions: Read/Execute
.text$mn:00000D74 _text$mn        segment para public 'CODE' use32
.text$mn:00000D74                 assume cs:_text$mn
.text$mn:00000D74                 ;org 0D74h
.text$mn:00000D74 ; COMDAT (pick any)
.text$mn:00000D74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000D74
.text$mn:00000D74 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D74
.text$mn:00000D74 ; Attributes: bp-based frame
.text$mn:00000D74
.text$mn:00000D74 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00000D74                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000D74 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00000D74                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00000D74
.text$mn:00000D74 var_10          = dword ptr -10h
.text$mn:00000D74 var_C           = dword ptr -0Ch
.text$mn:00000D74 var_4           = dword ptr -4
.text$mn:00000D74
.text$mn:00000D74                 push    ebp
.text$mn:00000D75                 mov     ebp, esp
.text$mn:00000D77                 push    0FFFFFFFFh
.text$mn:00000D79                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000D7E                 mov     eax, large fs:0
.text$mn:00000D84                 push    eax
.text$mn:00000D85                 push    ecx
.text$mn:00000D86                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000D8B                 xor     eax, ebp
.text$mn:00000D8D                 push    eax
.text$mn:00000D8E                 lea     eax, [ebp+var_C]
.text$mn:00000D91                 mov     large fs:0, eax
.text$mn:00000D97                 mov     [ebp+var_10], ecx
.text$mn:00000D9A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000D9D                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00000DA2                 mov     [ebp+var_4], 0
.text$mn:00000DA9                 mov     eax, [ebp+var_10]
.text$mn:00000DAC                 mov     dword ptr [eax+14h], 0
.text$mn:00000DB3                 mov     ecx, [ebp+var_10]
.text$mn:00000DB6                 mov     dword ptr [ecx+18h], 0
.text$mn:00000DBD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000DC4                 mov     eax, [ebp+var_10]
.text$mn:00000DC7                 mov     ecx, [ebp+var_C]
.text$mn:00000DCA                 mov     large fs:0, ecx
.text$mn:00000DD1                 pop     ecx
.text$mn:00000DD2                 mov     esp, ebp
.text$mn:00000DD4                 pop     ebp
.text$mn:00000DD5                 retn
.text$mn:00000DD5 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000DD5
.text$mn:00000DD5 ; ---------------------------------------------------------------------------
.text$mn:00000DD6                 align 4
.text$mn:00000DD6 _text$mn        ends
.text$mn:00000DD6
.text$x:00000DD8 ; ===========================================================================
.text$x:00000DD8
.text$x:00000DD8 ; Segment type: Pure code
.text$x:00000DD8 ; Segment permissions: Read/Execute
.text$x:00000DD8 _text$x         segment para public 'CODE' use32
.text$x:00000DD8                 assume cs:_text$x
.text$x:00000DD8                 ;org 0DD8h
.text$x:00000DD8 ; COMDAT (pick associative to section at D74)
.text$x:00000DD8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00000DD8
.text$x:00000DD8 ; =============== S U B R O U T I N E =======================================
.text$x:00000DD8
.text$x:00000DD8
.text$x:00000DD8 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00000DD8                                         ; DATA XREF: .xdata$x:00002E1Co
.text$x:00000DD8                 mov     ecx, [ebp-10h]  ; this
.text$x:00000DDB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00000DDB __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00000DDB
.text$x:00000DE0
.text$x:00000DE0 ; =============== S U B R O U T I N E =======================================
.text$x:00000DE0
.text$x:00000DE0
.text$x:00000DE0 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000DE0                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000DE0
.text$x:00000DE0 arg_4           = dword ptr  8
.text$x:00000DE0
.text$x:00000DE0                 mov     edx, [esp+arg_4]
.text$x:00000DE4                 lea     eax, [edx+0Ch]
.text$x:00000DE7                 mov     ecx, [edx-8]
.text$x:00000DEA                 xor     ecx, eax
.text$x:00000DEC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000DF1                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00000DF6                 jmp     ___CxxFrameHandler3
.text$x:00000DF6 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00000DF6
.text$x:00000DF6 ; ---------------------------------------------------------------------------
.text$x:00000DFB                 align 4
.text$x:00000DFB _text$x         ends
.text$x:00000DFB
.text$mn:00000DFC ; ===========================================================================
.text$mn:00000DFC
.text$mn:00000DFC ; Segment type: Pure code
.text$mn:00000DFC ; Segment permissions: Read/Execute
.text$mn:00000DFC _text$mn        segment para public 'CODE' use32
.text$mn:00000DFC                 assume cs:_text$mn
.text$mn:00000DFC                 ;org 0DFCh
.text$mn:00000DFC ; COMDAT (pick any)
.text$mn:00000DFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000DFC
.text$mn:00000DFC ; =============== S U B R O U T I N E =======================================
.text$mn:00000DFC
.text$mn:00000DFC ; Attributes: bp-based frame
.text$mn:00000DFC
.text$mn:00000DFC ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00000DFC                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00000DFC ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00000DFC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00000DFC
.text$mn:00000DFC var_4           = dword ptr -4
.text$mn:00000DFC
.text$mn:00000DFC                 push    ebp
.text$mn:00000DFD                 mov     ebp, esp
.text$mn:00000DFF                 push    ecx
.text$mn:00000E00                 mov     [ebp+var_4], ecx
.text$mn:00000E03                 mov     ecx, [ebp+var_4]
.text$mn:00000E06                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00000E0B                 mov     eax, [ebp+var_4]
.text$mn:00000E0E                 mov     esp, ebp
.text$mn:00000E10                 pop     ebp
.text$mn:00000E11                 retn
.text$mn:00000E11 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00000E11
.text$mn:00000E11 ; ---------------------------------------------------------------------------
.text$mn:00000E12                 align 4
.text$mn:00000E12 _text$mn        ends
.text$mn:00000E12
.text$mn:00000E14 ; ===========================================================================
.text$mn:00000E14
.text$mn:00000E14 ; Segment type: Pure code
.text$mn:00000E14 ; Segment permissions: Read/Execute
.text$mn:00000E14 _text$mn        segment para public 'CODE' use32
.text$mn:00000E14                 assume cs:_text$mn
.text$mn:00000E14                 ;org 0E14h
.text$mn:00000E14 ; COMDAT (pick any)
.text$mn:00000E14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000E14
.text$mn:00000E14 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E14
.text$mn:00000E14 ; Attributes: bp-based frame
.text$mn:00000E14
.text$mn:00000E14 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(void)
.text$mn:00000E14                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:00000E14 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:00000E14                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:00000E14
.text$mn:00000E14 var_4           = dword ptr -4
.text$mn:00000E14
.text$mn:00000E14                 push    ebp
.text$mn:00000E15                 mov     ebp, esp
.text$mn:00000E17                 push    ecx
.text$mn:00000E18                 mov     [ebp+var_4], ecx
.text$mn:00000E1B                 mov     ecx, [ebp+var_4]
.text$mn:00000E1E                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00000E23                 mov     eax, [ebp+var_4]
.text$mn:00000E26                 mov     esp, ebp
.text$mn:00000E28                 pop     ebp
.text$mn:00000E29                 retn
.text$mn:00000E29 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:00000E29
.text$mn:00000E29 ; ---------------------------------------------------------------------------
.text$mn:00000E2A                 align 4
.text$mn:00000E2A _text$mn        ends
.text$mn:00000E2A
.text$mn:00000E2C ; ===========================================================================
.text$mn:00000E2C
.text$mn:00000E2C ; Segment type: Pure code
.text$mn:00000E2C ; Segment permissions: Read/Execute
.text$mn:00000E2C _text$mn        segment para public 'CODE' use32
.text$mn:00000E2C                 assume cs:_text$mn
.text$mn:00000E2C                 ;org 0E2Ch
.text$mn:00000E2C ; COMDAT (pick any)
.text$mn:00000E2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000E2C
.text$mn:00000E2C ; =============== S U B R O U T I N E =======================================
.text$mn:00000E2C
.text$mn:00000E2C ; Attributes: bp-based frame
.text$mn:00000E2C
.text$mn:00000E2C ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00000E2C                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00000E2C ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00000E2C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00000E2C
.text$mn:00000E2C var_4           = dword ptr -4
.text$mn:00000E2C
.text$mn:00000E2C                 push    ebp
.text$mn:00000E2D                 mov     ebp, esp
.text$mn:00000E2F                 push    ecx
.text$mn:00000E30                 mov     [ebp+var_4], ecx
.text$mn:00000E33                 mov     eax, [ebp+var_4]
.text$mn:00000E36                 mov     esp, ebp
.text$mn:00000E38                 pop     ebp
.text$mn:00000E39                 retn
.text$mn:00000E39 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00000E39
.text$mn:00000E39 ; ---------------------------------------------------------------------------
.text$mn:00000E3A                 align 4
.text$mn:00000E3A _text$mn        ends
.text$mn:00000E3A
.text$mn:00000E3C ; ===========================================================================
.text$mn:00000E3C
.text$mn:00000E3C ; Segment type: Pure code
.text$mn:00000E3C ; Segment permissions: Read/Execute
.text$mn:00000E3C _text$mn        segment para public 'CODE' use32
.text$mn:00000E3C                 assume cs:_text$mn
.text$mn:00000E3C                 ;org 0E3Ch
.text$mn:00000E3C ; COMDAT (pick any)
.text$mn:00000E3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000E3C
.text$mn:00000E3C ; =============== S U B R O U T I N E =======================================
.text$mn:00000E3C
.text$mn:00000E3C ; Attributes: bp-based frame
.text$mn:00000E3C
.text$mn:00000E3C ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00000E3C                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00000E3C ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00000E3C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:00000E3C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:00000E3C
.text$mn:00000E3C var_4           = dword ptr -4
.text$mn:00000E3C
.text$mn:00000E3C                 push    ebp
.text$mn:00000E3D                 mov     ebp, esp
.text$mn:00000E3F                 push    ecx
.text$mn:00000E40                 mov     [ebp+var_4], ecx
.text$mn:00000E43                 mov     eax, [ebp+var_4]
.text$mn:00000E46                 mov     esp, ebp
.text$mn:00000E48                 pop     ebp
.text$mn:00000E49                 retn
.text$mn:00000E49 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00000E49
.text$mn:00000E49 ; ---------------------------------------------------------------------------
.text$mn:00000E4A                 align 4
.text$mn:00000E4A _text$mn        ends
.text$mn:00000E4A
.text$mn:00000E4C ; ===========================================================================
.text$mn:00000E4C
.text$mn:00000E4C ; Segment type: Pure code
.text$mn:00000E4C ; Segment permissions: Read/Execute
.text$mn:00000E4C _text$mn        segment para public 'CODE' use32
.text$mn:00000E4C                 assume cs:_text$mn
.text$mn:00000E4C                 ;org 0E4Ch
.text$mn:00000E4C ; COMDAT (pick any)
.text$mn:00000E4C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000E4C
.text$mn:00000E4C ; =============== S U B R O U T I N E =======================================
.text$mn:00000E4C
.text$mn:00000E4C ; Attributes: bp-based frame
.text$mn:00000E4C
.text$mn:00000E4C ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00000E4C                 public ??0?$allocator@_W@std@@QAE@XZ
.text$mn:00000E4C ??0?$allocator@_W@std@@QAE@XZ proc near ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)+Ap
.text$mn:00000E4C
.text$mn:00000E4C var_4           = dword ptr -4
.text$mn:00000E4C
.text$mn:00000E4C                 push    ebp
.text$mn:00000E4D                 mov     ebp, esp
.text$mn:00000E4F                 push    ecx
.text$mn:00000E50                 mov     [ebp+var_4], ecx
.text$mn:00000E53                 mov     eax, [ebp+var_4]
.text$mn:00000E56                 mov     esp, ebp
.text$mn:00000E58                 pop     ebp
.text$mn:00000E59                 retn
.text$mn:00000E59 ??0?$allocator@_W@std@@QAE@XZ endp
.text$mn:00000E59
.text$mn:00000E59 ; ---------------------------------------------------------------------------
.text$mn:00000E5A                 align 4
.text$mn:00000E5A _text$mn        ends
.text$mn:00000E5A
.text$mn:00000E5C ; ===========================================================================
.text$mn:00000E5C
.text$mn:00000E5C ; Segment type: Pure code
.text$mn:00000E5C ; Segment permissions: Read/Execute
.text$mn:00000E5C _text$mn        segment para public 'CODE' use32
.text$mn:00000E5C                 assume cs:_text$mn
.text$mn:00000E5C                 ;org 0E5Ch
.text$mn:00000E5C ; COMDAT (pick any)
.text$mn:00000E5C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000E5C
.text$mn:00000E5C ; =============== S U B R O U T I N E =======================================
.text$mn:00000E5C
.text$mn:00000E5C ; Attributes: bp-based frame
.text$mn:00000E5C
.text$mn:00000E5C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00000E5C                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00000E5C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00000E5C                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00000E5C                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00000E5C
.text$mn:00000E5C var_14          = dword ptr -14h
.text$mn:00000E5C var_D           = byte ptr -0Dh
.text$mn:00000E5C var_C           = dword ptr -0Ch
.text$mn:00000E5C var_4           = dword ptr -4
.text$mn:00000E5C Str             = dword ptr  8
.text$mn:00000E5C
.text$mn:00000E5C                 push    ebp
.text$mn:00000E5D                 mov     ebp, esp
.text$mn:00000E5F                 push    0FFFFFFFFh
.text$mn:00000E61                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00000E66                 mov     eax, large fs:0
.text$mn:00000E6C                 push    eax
.text$mn:00000E6D                 sub     esp, 8
.text$mn:00000E70                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000E75                 xor     eax, ebp
.text$mn:00000E77                 push    eax
.text$mn:00000E78                 lea     eax, [ebp+var_C]
.text$mn:00000E7B                 mov     large fs:0, eax
.text$mn:00000E81                 mov     [ebp+var_14], ecx
.text$mn:00000E84                 lea     ecx, [ebp+var_D]
.text$mn:00000E87                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00000E8C                 push    eax
.text$mn:00000E8D                 mov     ecx, [ebp+var_14]
.text$mn:00000E90                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00000E95                 mov     [ebp+var_4], 0
.text$mn:00000E9C                 push    0               ; Size
.text$mn:00000E9E                 push    0               ; char
.text$mn:00000EA0                 mov     ecx, [ebp+var_14]
.text$mn:00000EA3                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000EA8                 mov     eax, [ebp+Str]
.text$mn:00000EAB                 push    eax             ; Str
.text$mn:00000EAC                 mov     ecx, [ebp+var_14]
.text$mn:00000EAF                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00000EB4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000EBB                 mov     eax, [ebp+var_14]
.text$mn:00000EBE                 mov     ecx, [ebp+var_C]
.text$mn:00000EC1                 mov     large fs:0, ecx
.text$mn:00000EC8                 pop     ecx
.text$mn:00000EC9                 mov     esp, ebp
.text$mn:00000ECB                 pop     ebp
.text$mn:00000ECC                 retn    4
.text$mn:00000ECC ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00000ECC
.text$mn:00000ECC ; ---------------------------------------------------------------------------
.text$mn:00000ECF                 align 10h
.text$mn:00000ECF _text$mn        ends
.text$mn:00000ECF
.text$x:00000ED0 ; ===========================================================================
.text$x:00000ED0
.text$x:00000ED0 ; Segment type: Pure code
.text$x:00000ED0 ; Segment permissions: Read/Execute
.text$x:00000ED0 _text$x         segment para public 'CODE' use32
.text$x:00000ED0                 assume cs:_text$x
.text$x:00000ED0                 ;org 0ED0h
.text$x:00000ED0 ; COMDAT (pick associative to section at E5C)
.text$x:00000ED0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00000ED0
.text$x:00000ED0 ; =============== S U B R O U T I N E =======================================
.text$x:00000ED0
.text$x:00000ED0
.text$x:00000ED0 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00000ED0                                         ; DATA XREF: .xdata$x:00002ECCo
.text$x:00000ED0                 mov     ecx, [ebp-14h]
.text$x:00000ED3                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000ED3 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00000ED3
.text$x:00000ED8
.text$x:00000ED8 ; =============== S U B R O U T I N E =======================================
.text$x:00000ED8
.text$x:00000ED8
.text$x:00000ED8 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00000ED8                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00000ED8
.text$x:00000ED8 arg_4           = dword ptr  8
.text$x:00000ED8
.text$x:00000ED8                 mov     edx, [esp+arg_4]
.text$x:00000EDC                 lea     eax, [edx+0Ch]
.text$x:00000EDF                 mov     ecx, [edx-0Ch]
.text$x:00000EE2                 xor     ecx, eax
.text$x:00000EE4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000EE9                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00000EEE                 jmp     ___CxxFrameHandler3
.text$x:00000EEE __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00000EEE
.text$x:00000EEE ; ---------------------------------------------------------------------------
.text$x:00000EF3                 align 4
.text$x:00000EF3 _text$x         ends
.text$x:00000EF3
.text$mn:00000EF4 ; ===========================================================================
.text$mn:00000EF4
.text$mn:00000EF4 ; Segment type: Pure code
.text$mn:00000EF4 ; Segment permissions: Read/Execute
.text$mn:00000EF4 _text$mn        segment para public 'CODE' use32
.text$mn:00000EF4                 assume cs:_text$mn
.text$mn:00000EF4                 ;org 0EF4h
.text$mn:00000EF4 ; COMDAT (pick any)
.text$mn:00000EF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000EF4
.text$mn:00000EF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000EF4
.text$mn:00000EF4 ; Attributes: bp-based frame
.text$mn:00000EF4
.text$mn:00000EF4 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000EF4                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00000EF4 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00000EF4                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00000EF4
.text$mn:00000EF4 var_4           = dword ptr -4
.text$mn:00000EF4
.text$mn:00000EF4                 push    ebp
.text$mn:00000EF5                 mov     ebp, esp
.text$mn:00000EF7                 push    ecx
.text$mn:00000EF8                 mov     [ebp+var_4], ecx
.text$mn:00000EFB                 mov     eax, [ebp+var_4]
.text$mn:00000EFE                 mov     dword ptr [eax], 0
.text$mn:00000F04                 mov     eax, [ebp+var_4]
.text$mn:00000F07                 mov     esp, ebp
.text$mn:00000F09                 pop     ebp
.text$mn:00000F0A                 retn
.text$mn:00000F0A ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00000F0A
.text$mn:00000F0A ; ---------------------------------------------------------------------------
.text$mn:00000F0B                 align 4
.text$mn:00000F0B _text$mn        ends
.text$mn:00000F0B
.text$mn:00000F0C ; ===========================================================================
.text$mn:00000F0C
.text$mn:00000F0C ; Segment type: Pure code
.text$mn:00000F0C ; Segment permissions: Read/Execute
.text$mn:00000F0C _text$mn        segment para public 'CODE' use32
.text$mn:00000F0C                 assume cs:_text$mn
.text$mn:00000F0C                 ;org 0F0Ch
.text$mn:00000F0C ; COMDAT (pick any)
.text$mn:00000F0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000F0C
.text$mn:00000F0C ; =============== S U B R O U T I N E =======================================
.text$mn:00000F0C
.text$mn:00000F0C ; Attributes: bp-based frame
.text$mn:00000F0C
.text$mn:00000F0C ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00000F0C                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00000F0C ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00000F0C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00000F0C
.text$mn:00000F0C var_4           = dword ptr -4
.text$mn:00000F0C
.text$mn:00000F0C                 push    ebp
.text$mn:00000F0D                 mov     ebp, esp
.text$mn:00000F0F                 push    ecx
.text$mn:00000F10                 mov     [ebp+var_4], ecx
.text$mn:00000F13                 mov     eax, [ebp+var_4]
.text$mn:00000F16                 mov     dword ptr [eax], 0
.text$mn:00000F1C                 mov     ecx, [ebp+var_4]
.text$mn:00000F1F                 mov     dword ptr [ecx+4], 0
.text$mn:00000F26                 mov     eax, [ebp+var_4]
.text$mn:00000F29                 mov     esp, ebp
.text$mn:00000F2B                 pop     ebp
.text$mn:00000F2C                 retn
.text$mn:00000F2C ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00000F2C
.text$mn:00000F2C ; ---------------------------------------------------------------------------
.text$mn:00000F2D                 align 10h
.text$mn:00000F2D _text$mn        ends
.text$mn:00000F2D
.text$mn:00000F30 ; ===========================================================================
.text$mn:00000F30
.text$mn:00000F30 ; Segment type: Pure code
.text$mn:00000F30 ; Segment permissions: Read/Execute
.text$mn:00000F30 _text$mn        segment para public 'CODE' use32
.text$mn:00000F30                 assume cs:_text$mn
.text$mn:00000F30                 ;org 0F30h
.text$mn:00000F30 ; COMDAT (pick any)
.text$mn:00000F30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000F30
.text$mn:00000F30 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F30
.text$mn:00000F30 ; Attributes: bp-based frame
.text$mn:00000F30
.text$mn:00000F30 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00000F30                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00000F30 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00000F30                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00000F30                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00000F30
.text$mn:00000F30 var_10          = dword ptr -10h
.text$mn:00000F30 var_C           = dword ptr -0Ch
.text$mn:00000F30 var_4           = dword ptr -4
.text$mn:00000F30
.text$mn:00000F30                 push    ebp
.text$mn:00000F31                 mov     ebp, esp
.text$mn:00000F33                 push    0FFFFFFFFh
.text$mn:00000F35                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00000F3A                 mov     eax, large fs:0
.text$mn:00000F40                 push    eax
.text$mn:00000F41                 push    ecx
.text$mn:00000F42                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000F47                 xor     eax, ebp
.text$mn:00000F49                 push    eax
.text$mn:00000F4A                 lea     eax, [ebp+var_C]
.text$mn:00000F4D                 mov     large fs:0, eax
.text$mn:00000F53                 mov     [ebp+var_10], ecx
.text$mn:00000F56                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000F59                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00000F5E                 mov     [ebp+var_4], 0
.text$mn:00000F65                 mov     eax, [ebp+var_10]
.text$mn:00000F68                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00000F6E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000F75                 mov     eax, [ebp+var_10]
.text$mn:00000F78                 mov     ecx, [ebp+var_C]
.text$mn:00000F7B                 mov     large fs:0, ecx
.text$mn:00000F82                 pop     ecx
.text$mn:00000F83                 mov     esp, ebp
.text$mn:00000F85                 pop     ebp
.text$mn:00000F86                 retn
.text$mn:00000F86 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00000F86
.text$mn:00000F86 ; ---------------------------------------------------------------------------
.text$mn:00000F87                 align 4
.text$mn:00000F87 _text$mn        ends
.text$mn:00000F87
.text$x:00000F88 ; ===========================================================================
.text$x:00000F88
.text$x:00000F88 ; Segment type: Pure code
.text$x:00000F88 ; Segment permissions: Read/Execute
.text$x:00000F88 _text$x         segment para public 'CODE' use32
.text$x:00000F88                 assume cs:_text$x
.text$x:00000F88                 ;org 0F88h
.text$x:00000F88 ; COMDAT (pick associative to section at F30)
.text$x:00000F88                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00000F88
.text$x:00000F88 ; =============== S U B R O U T I N E =======================================
.text$x:00000F88
.text$x:00000F88
.text$x:00000F88 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00000F88                                         ; DATA XREF: .xdata$x:00002FB0o
.text$x:00000F88                 mov     ecx, [ebp-10h]  ; this
.text$x:00000F8B                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00000F8B __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00000F8B
.text$x:00000F90
.text$x:00000F90 ; =============== S U B R O U T I N E =======================================
.text$x:00000F90
.text$x:00000F90
.text$x:00000F90 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00000F90                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00000F90
.text$x:00000F90 arg_4           = dword ptr  8
.text$x:00000F90
.text$x:00000F90                 mov     edx, [esp+arg_4]
.text$x:00000F94                 lea     eax, [edx+0Ch]
.text$x:00000F97                 mov     ecx, [edx-8]
.text$x:00000F9A                 xor     ecx, eax
.text$x:00000F9C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000FA1                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00000FA6                 jmp     ___CxxFrameHandler3
.text$x:00000FA6 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00000FA6
.text$x:00000FA6 ; ---------------------------------------------------------------------------
.text$x:00000FAB                 align 4
.text$x:00000FAB _text$x         ends
.text$x:00000FAB
.text$mn:00000FAC ; ===========================================================================
.text$mn:00000FAC
.text$mn:00000FAC ; Segment type: Pure code
.text$mn:00000FAC ; Segment permissions: Read/Execute
.text$mn:00000FAC _text$mn        segment para public 'CODE' use32
.text$mn:00000FAC                 assume cs:_text$mn
.text$mn:00000FAC                 ;org 0FACh
.text$mn:00000FAC ; COMDAT (pick any)
.text$mn:00000FAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000FAC
.text$mn:00000FAC ; =============== S U B R O U T I N E =======================================
.text$mn:00000FAC
.text$mn:00000FAC ; Attributes: bp-based frame
.text$mn:00000FAC
.text$mn:00000FAC ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00000FAC                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00000FAC ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00000FAC                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00000FAC
.text$mn:00000FAC var_10          = dword ptr -10h
.text$mn:00000FAC var_C           = dword ptr -0Ch
.text$mn:00000FAC var_4           = dword ptr -4
.text$mn:00000FAC
.text$mn:00000FAC                 push    ebp
.text$mn:00000FAD                 mov     ebp, esp
.text$mn:00000FAF                 push    0FFFFFFFFh
.text$mn:00000FB1                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00000FB6                 mov     eax, large fs:0
.text$mn:00000FBC                 push    eax
.text$mn:00000FBD                 push    ecx
.text$mn:00000FBE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000FC3                 xor     eax, ebp
.text$mn:00000FC5                 push    eax
.text$mn:00000FC6                 lea     eax, [ebp+var_C]
.text$mn:00000FC9                 mov     large fs:0, eax
.text$mn:00000FCF                 mov     [ebp+var_10], ecx
.text$mn:00000FD2                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000FD5                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00000FDA                 mov     [ebp+var_4], 0
.text$mn:00000FE1                 mov     eax, [ebp+var_10]
.text$mn:00000FE4                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00000FEA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000FF1                 mov     eax, [ebp+var_10]
.text$mn:00000FF4                 mov     ecx, [ebp+var_C]
.text$mn:00000FF7                 mov     large fs:0, ecx
.text$mn:00000FFE                 pop     ecx
.text$mn:00000FFF                 mov     esp, ebp
.text$mn:00001001                 pop     ebp
.text$mn:00001002                 retn
.text$mn:00001002 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00001002
.text$mn:00001002 ; ---------------------------------------------------------------------------
.text$mn:00001003                 align 4
.text$mn:00001003 _text$mn        ends
.text$mn:00001003
.text$x:00001004 ; ===========================================================================
.text$x:00001004
.text$x:00001004 ; Segment type: Pure code
.text$x:00001004 ; Segment permissions: Read/Execute
.text$x:00001004 _text$x         segment para public 'CODE' use32
.text$x:00001004                 assume cs:_text$x
.text$x:00001004                 ;org 1004h
.text$x:00001004 ; COMDAT (pick associative to section at FAC)
.text$x:00001004                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001004
.text$x:00001004 ; =============== S U B R O U T I N E =======================================
.text$x:00001004
.text$x:00001004
.text$x:00001004 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00001004                                         ; DATA XREF: .xdata$x:00003034o
.text$x:00001004                 mov     ecx, [ebp-10h]  ; this
.text$x:00001007                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001007 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00001007
.text$x:0000100C
.text$x:0000100C ; =============== S U B R O U T I N E =======================================
.text$x:0000100C
.text$x:0000100C
.text$x:0000100C __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:0000100C                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:0000100C
.text$x:0000100C arg_4           = dword ptr  8
.text$x:0000100C
.text$x:0000100C                 mov     edx, [esp+arg_4]
.text$x:00001010                 lea     eax, [edx+0Ch]
.text$x:00001013                 mov     ecx, [edx-8]
.text$x:00001016                 xor     ecx, eax
.text$x:00001018                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000101D                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00001022                 jmp     ___CxxFrameHandler3
.text$x:00001022 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00001022
.text$x:00001022 ; ---------------------------------------------------------------------------
.text$x:00001027                 align 4
.text$x:00001027 _text$x         ends
.text$x:00001027
.text$mn:00001028 ; ===========================================================================
.text$mn:00001028
.text$mn:00001028 ; Segment type: Pure code
.text$mn:00001028 ; Segment permissions: Read/Execute
.text$mn:00001028 _text$mn        segment para public 'CODE' use32
.text$mn:00001028                 assume cs:_text$mn
.text$mn:00001028                 ;org 1028h
.text$mn:00001028 ; COMDAT (pick any)
.text$mn:00001028                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001028
.text$mn:00001028 ; =============== S U B R O U T I N E =======================================
.text$mn:00001028
.text$mn:00001028 ; Attributes: bp-based frame
.text$mn:00001028
.text$mn:00001028 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00001028                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00001028 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00001028                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00001028
.text$mn:00001028 var_10          = dword ptr -10h
.text$mn:00001028 var_C           = dword ptr -0Ch
.text$mn:00001028 var_4           = dword ptr -4
.text$mn:00001028
.text$mn:00001028                 push    ebp
.text$mn:00001029                 mov     ebp, esp
.text$mn:0000102B                 push    0FFFFFFFFh
.text$mn:0000102D                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00001032                 mov     eax, large fs:0
.text$mn:00001038                 push    eax
.text$mn:00001039                 push    ecx
.text$mn:0000103A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000103F                 xor     eax, ebp
.text$mn:00001041                 push    eax
.text$mn:00001042                 lea     eax, [ebp+var_C]
.text$mn:00001045                 mov     large fs:0, eax
.text$mn:0000104B                 mov     [ebp+var_10], ecx
.text$mn:0000104E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001051                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00001056                 mov     [ebp+var_4], 0
.text$mn:0000105D                 mov     eax, [ebp+var_10]
.text$mn:00001060                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00001066                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000106D                 mov     eax, [ebp+var_10]
.text$mn:00001070                 mov     ecx, [ebp+var_C]
.text$mn:00001073                 mov     large fs:0, ecx
.text$mn:0000107A                 pop     ecx
.text$mn:0000107B                 mov     esp, ebp
.text$mn:0000107D                 pop     ebp
.text$mn:0000107E                 retn
.text$mn:0000107E ??0_System_error_category@std@@QAE@XZ endp
.text$mn:0000107E
.text$mn:0000107E ; ---------------------------------------------------------------------------
.text$mn:0000107F                 align 10h
.text$mn:0000107F _text$mn        ends
.text$mn:0000107F
.text$x:00001080 ; ===========================================================================
.text$x:00001080
.text$x:00001080 ; Segment type: Pure code
.text$x:00001080 ; Segment permissions: Read/Execute
.text$x:00001080 _text$x         segment para public 'CODE' use32
.text$x:00001080                 assume cs:_text$x
.text$x:00001080                 ;org 1080h
.text$x:00001080 ; COMDAT (pick associative to section at 1028)
.text$x:00001080                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001080
.text$x:00001080 ; =============== S U B R O U T I N E =======================================
.text$x:00001080
.text$x:00001080
.text$x:00001080 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00001080                                         ; DATA XREF: .xdata$x:000030B8o
.text$x:00001080                 mov     ecx, [ebp-10h]  ; this
.text$x:00001083                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001083 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00001083
.text$x:00001088
.text$x:00001088 ; =============== S U B R O U T I N E =======================================
.text$x:00001088
.text$x:00001088
.text$x:00001088 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00001088                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00001088
.text$x:00001088 arg_4           = dword ptr  8
.text$x:00001088
.text$x:00001088                 mov     edx, [esp+arg_4]
.text$x:0000108C                 lea     eax, [edx+0Ch]
.text$x:0000108F                 mov     ecx, [edx-8]
.text$x:00001092                 xor     ecx, eax
.text$x:00001094                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001099                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:0000109E                 jmp     ___CxxFrameHandler3
.text$x:0000109E __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:0000109E
.text$x:0000109E ; ---------------------------------------------------------------------------
.text$x:000010A3                 align 4
.text$x:000010A3 _text$x         ends
.text$x:000010A3
.text$mn:000010A4 ; ===========================================================================
.text$mn:000010A4
.text$mn:000010A4 ; Segment type: Pure code
.text$mn:000010A4 ; Segment permissions: Read/Execute
.text$mn:000010A4 _text$mn        segment para public 'CODE' use32
.text$mn:000010A4                 assume cs:_text$mn
.text$mn:000010A4                 ;org 10A4h
.text$mn:000010A4 ; COMDAT (pick any)
.text$mn:000010A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000010A4
.text$mn:000010A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000010A4
.text$mn:000010A4 ; Attributes: bp-based frame
.text$mn:000010A4
.text$mn:000010A4 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:000010A4                 public ??0error_category@std@@QAE@XZ
.text$mn:000010A4 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:000010A4
.text$mn:000010A4 var_4           = dword ptr -4
.text$mn:000010A4
.text$mn:000010A4                 push    ebp
.text$mn:000010A5                 mov     ebp, esp
.text$mn:000010A7                 push    ecx
.text$mn:000010A8                 mov     [ebp+var_4], ecx
.text$mn:000010AB                 mov     eax, [ebp+var_4]
.text$mn:000010AE                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:000010B4                 mov     eax, [ebp+var_4]
.text$mn:000010B7                 mov     esp, ebp
.text$mn:000010B9                 pop     ebp
.text$mn:000010BA                 retn
.text$mn:000010BA ??0error_category@std@@QAE@XZ endp
.text$mn:000010BA
.text$mn:000010BA ; ---------------------------------------------------------------------------
.text$mn:000010BB                 align 4
.text$mn:000010BB _text$mn        ends
.text$mn:000010BB
.text$mn:000010BC ; ===========================================================================
.text$mn:000010BC
.text$mn:000010BC ; Segment type: Pure code
.text$mn:000010BC ; Segment permissions: Read/Execute
.text$mn:000010BC _text$mn        segment para public 'CODE' use32
.text$mn:000010BC                 assume cs:_text$mn
.text$mn:000010BC                 ;org 10BCh
.text$mn:000010BC ; COMDAT (pick any)
.text$mn:000010BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000010BC
.text$mn:000010BC ; =============== S U B R O U T I N E =======================================
.text$mn:000010BC
.text$mn:000010BC ; Attributes: bp-based frame
.text$mn:000010BC
.text$mn:000010BC ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:000010BC                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:000010BC ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:000010BC                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:000010BC                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:000010BC
.text$mn:000010BC var_4           = dword ptr -4
.text$mn:000010BC arg_0           = dword ptr  8
.text$mn:000010BC arg_4           = dword ptr  0Ch
.text$mn:000010BC
.text$mn:000010BC                 push    ebp
.text$mn:000010BD                 mov     ebp, esp
.text$mn:000010BF                 push    ecx
.text$mn:000010C0                 mov     [ebp+var_4], ecx
.text$mn:000010C3                 mov     eax, [ebp+var_4]
.text$mn:000010C6                 mov     ecx, [ebp+arg_0]
.text$mn:000010C9                 mov     [eax], ecx
.text$mn:000010CB                 mov     edx, [ebp+var_4]
.text$mn:000010CE                 mov     eax, [ebp+arg_4]
.text$mn:000010D1                 mov     [edx+4], eax
.text$mn:000010D4                 mov     eax, [ebp+var_4]
.text$mn:000010D7                 mov     esp, ebp
.text$mn:000010D9                 pop     ebp
.text$mn:000010DA                 retn    8
.text$mn:000010DA ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:000010DA
.text$mn:000010DA ; ---------------------------------------------------------------------------
.text$mn:000010DD                 align 10h
.text$mn:000010DD _text$mn        ends
.text$mn:000010DD
.text$mn:000010E0 ; ===========================================================================
.text$mn:000010E0
.text$mn:000010E0 ; Segment type: Pure code
.text$mn:000010E0 ; Segment permissions: Read/Execute
.text$mn:000010E0 _text$mn        segment para public 'CODE' use32
.text$mn:000010E0                 assume cs:_text$mn
.text$mn:000010E0                 ;org 10E0h
.text$mn:000010E0 ; COMDAT (pick any)
.text$mn:000010E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000010E0
.text$mn:000010E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000010E0
.text$mn:000010E0 ; Attributes: bp-based frame
.text$mn:000010E0
.text$mn:000010E0 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:000010E0                 public ??0id@locale@std@@QAE@I@Z
.text$mn:000010E0 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:000010E0                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:000010E0
.text$mn:000010E0 var_4           = dword ptr -4
.text$mn:000010E0 arg_0           = dword ptr  8
.text$mn:000010E0
.text$mn:000010E0                 push    ebp
.text$mn:000010E1                 mov     ebp, esp
.text$mn:000010E3                 push    ecx
.text$mn:000010E4                 mov     [ebp+var_4], ecx
.text$mn:000010E7                 mov     eax, [ebp+var_4]
.text$mn:000010EA                 mov     ecx, [ebp+arg_0]
.text$mn:000010ED                 mov     [eax], ecx
.text$mn:000010EF                 mov     eax, [ebp+var_4]
.text$mn:000010F2                 mov     esp, ebp
.text$mn:000010F4                 pop     ebp
.text$mn:000010F5                 retn    4
.text$mn:000010F5 ??0id@locale@std@@QAE@I@Z endp
.text$mn:000010F5
.text$mn:000010F5 _text$mn        ends
.text$mn:000010F5
.text$mn:000010F8 ; ===========================================================================
.text$mn:000010F8
.text$mn:000010F8 ; Segment type: Pure code
.text$mn:000010F8 ; Segment permissions: Read/Execute
.text$mn:000010F8 _text$mn        segment para public 'CODE' use32
.text$mn:000010F8                 assume cs:_text$mn
.text$mn:000010F8                 ;org 10F8h
.text$mn:000010F8 ; COMDAT (pick any)
.text$mn:000010F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000010F8
.text$mn:000010F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000010F8
.text$mn:000010F8 ; Attributes: bp-based frame
.text$mn:000010F8
.text$mn:000010F8 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:000010F8                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:000010F8 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000010F8                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:000010F8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:000010F8
.text$mn:000010F8 var_10          = dword ptr -10h
.text$mn:000010F8 var_C           = dword ptr -0Ch
.text$mn:000010F8 var_4           = dword ptr -4
.text$mn:000010F8
.text$mn:000010F8                 push    ebp
.text$mn:000010F9                 mov     ebp, esp
.text$mn:000010FB                 push    0FFFFFFFFh
.text$mn:000010FD                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00001102                 mov     eax, large fs:0
.text$mn:00001108                 push    eax
.text$mn:00001109                 push    ecx
.text$mn:0000110A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000110F                 xor     eax, ebp
.text$mn:00001111                 push    eax
.text$mn:00001112                 lea     eax, [ebp+var_C]
.text$mn:00001115                 mov     large fs:0, eax
.text$mn:0000111B                 mov     [ebp+var_10], ecx
.text$mn:0000111E                 mov     [ebp+var_4], 0
.text$mn:00001125                 mov     ecx, [ebp+var_10]
.text$mn:00001128                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:0000112D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001134                 mov     ecx, [ebp+var_10]
.text$mn:00001137                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:0000113C                 mov     ecx, [ebp+var_C]
.text$mn:0000113F                 mov     large fs:0, ecx
.text$mn:00001146                 pop     ecx
.text$mn:00001147                 mov     esp, ebp
.text$mn:00001149                 pop     ebp
.text$mn:0000114A                 retn
.text$mn:0000114A ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000114A
.text$mn:0000114A ; ---------------------------------------------------------------------------
.text$mn:0000114B                 align 4
.text$mn:0000114B _text$mn        ends
.text$mn:0000114B
.text$x:0000114C ; ===========================================================================
.text$x:0000114C
.text$x:0000114C ; Segment type: Pure code
.text$x:0000114C ; Segment permissions: Read/Execute
.text$x:0000114C _text$x         segment para public 'CODE' use32
.text$x:0000114C                 assume cs:_text$x
.text$x:0000114C                 ;org 114Ch
.text$x:0000114C ; COMDAT (pick associative to section at 10F8)
.text$x:0000114C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000114C
.text$x:0000114C ; =============== S U B R O U T I N E =======================================
.text$x:0000114C
.text$x:0000114C
.text$x:0000114C __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000114C                                         ; DATA XREF: .xdata$x:00002EA0o
.text$x:0000114C                 mov     ecx, [ebp-10h]
.text$x:0000114F                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:0000114F __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000114F
.text$x:00001154
.text$x:00001154 ; =============== S U B R O U T I N E =======================================
.text$x:00001154
.text$x:00001154
.text$x:00001154 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00001154                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00001154
.text$x:00001154 arg_4           = dword ptr  8
.text$x:00001154
.text$x:00001154                 mov     edx, [esp+arg_4]
.text$x:00001158                 lea     eax, [edx+0Ch]
.text$x:0000115B                 mov     ecx, [edx-8]
.text$x:0000115E                 xor     ecx, eax
.text$x:00001160                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001165                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:0000116A                 jmp     ___CxxFrameHandler3
.text$x:0000116A __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:0000116A
.text$x:0000116A ; ---------------------------------------------------------------------------
.text$x:0000116F                 align 10h
.text$x:0000116F _text$x         ends
.text$x:0000116F
.text$mn:00001170 ; ===========================================================================
.text$mn:00001170
.text$mn:00001170 ; Segment type: Pure code
.text$mn:00001170 ; Segment permissions: Read/Execute
.text$mn:00001170 _text$mn        segment para public 'CODE' use32
.text$mn:00001170                 assume cs:_text$mn
.text$mn:00001170                 ;org 1170h
.text$mn:00001170 ; COMDAT (pick any)
.text$mn:00001170                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001170
.text$mn:00001170 ; =============== S U B R O U T I N E =======================================
.text$mn:00001170
.text$mn:00001170 ; Attributes: bp-based frame
.text$mn:00001170
.text$mn:00001170 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00001170                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001170 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00001170                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00001170                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00001170
.text$mn:00001170 var_10          = dword ptr -10h
.text$mn:00001170 var_C           = dword ptr -0Ch
.text$mn:00001170 var_4           = dword ptr -4
.text$mn:00001170
.text$mn:00001170                 push    ebp
.text$mn:00001171                 mov     ebp, esp
.text$mn:00001173                 push    0FFFFFFFFh
.text$mn:00001175                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000117A                 mov     eax, large fs:0
.text$mn:00001180                 push    eax
.text$mn:00001181                 push    ecx
.text$mn:00001182                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001187                 xor     eax, ebp
.text$mn:00001189                 push    eax
.text$mn:0000118A                 lea     eax, [ebp+var_C]
.text$mn:0000118D                 mov     large fs:0, eax
.text$mn:00001193                 mov     [ebp+var_10], ecx
.text$mn:00001196                 mov     [ebp+var_4], 0
.text$mn:0000119D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000011A4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000011A7                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000011AC                 mov     ecx, [ebp+var_C]
.text$mn:000011AF                 mov     large fs:0, ecx
.text$mn:000011B6                 pop     ecx
.text$mn:000011B7                 mov     esp, ebp
.text$mn:000011B9                 pop     ebp
.text$mn:000011BA                 retn
.text$mn:000011BA ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:000011BA
.text$mn:000011BA ; ---------------------------------------------------------------------------
.text$mn:000011BB                 align 4
.text$mn:000011BB _text$mn        ends
.text$mn:000011BB
.text$x:000011BC ; ===========================================================================
.text$x:000011BC
.text$x:000011BC ; Segment type: Pure code
.text$x:000011BC ; Segment permissions: Read/Execute
.text$x:000011BC _text$x         segment para public 'CODE' use32
.text$x:000011BC                 assume cs:_text$x
.text$x:000011BC                 ;org 11BCh
.text$x:000011BC ; COMDAT (pick associative to section at 1170)
.text$x:000011BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000011BC
.text$x:000011BC ; =============== S U B R O U T I N E =======================================
.text$x:000011BC
.text$x:000011BC
.text$x:000011BC __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:000011BC                                         ; DATA XREF: .xdata$x:00002E48o
.text$x:000011BC                 mov     ecx, [ebp-10h]  ; this
.text$x:000011BF                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000011BF __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:000011BF
.text$x:000011C4
.text$x:000011C4 ; =============== S U B R O U T I N E =======================================
.text$x:000011C4
.text$x:000011C4
.text$x:000011C4 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:000011C4                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:000011C4
.text$x:000011C4 arg_4           = dword ptr  8
.text$x:000011C4
.text$x:000011C4                 mov     edx, [esp+arg_4]
.text$x:000011C8                 lea     eax, [edx+0Ch]
.text$x:000011CB                 mov     ecx, [edx-8]
.text$x:000011CE                 xor     ecx, eax
.text$x:000011D0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000011D5                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000011DA                 jmp     ___CxxFrameHandler3
.text$x:000011DA __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000011DA
.text$x:000011DA ; ---------------------------------------------------------------------------
.text$x:000011DF                 align 10h
.text$x:000011DF _text$x         ends
.text$x:000011DF
.text$mn:000011E0 ; ===========================================================================
.text$mn:000011E0
.text$mn:000011E0 ; Segment type: Pure code
.text$mn:000011E0 ; Segment permissions: Read/Execute
.text$mn:000011E0 _text$mn        segment para public 'CODE' use32
.text$mn:000011E0                 assume cs:_text$mn
.text$mn:000011E0                 ;org 11E0h
.text$mn:000011E0 ; COMDAT (pick any)
.text$mn:000011E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000011E0
.text$mn:000011E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000011E0
.text$mn:000011E0 ; Attributes: bp-based frame
.text$mn:000011E0
.text$mn:000011E0 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:000011E0                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:000011E0 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:000011E0                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:000011E0                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:000011E0
.text$mn:000011E0 var_10          = dword ptr -10h
.text$mn:000011E0 var_C           = dword ptr -0Ch
.text$mn:000011E0 var_4           = dword ptr -4
.text$mn:000011E0
.text$mn:000011E0                 push    ebp
.text$mn:000011E1                 mov     ebp, esp
.text$mn:000011E3                 push    0FFFFFFFFh
.text$mn:000011E5                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:000011EA                 mov     eax, large fs:0
.text$mn:000011F0                 push    eax
.text$mn:000011F1                 push    ecx
.text$mn:000011F2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000011F7                 xor     eax, ebp
.text$mn:000011F9                 push    eax
.text$mn:000011FA                 lea     eax, [ebp+var_C]
.text$mn:000011FD                 mov     large fs:0, eax
.text$mn:00001203                 mov     [ebp+var_10], ecx
.text$mn:00001206                 mov     [ebp+var_4], 0
.text$mn:0000120D                 push    0               ; Size
.text$mn:0000120F                 push    1               ; char
.text$mn:00001211                 mov     ecx, [ebp+var_10]
.text$mn:00001214                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001219                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001220                 mov     ecx, [ebp+var_10]
.text$mn:00001223                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00001228                 mov     ecx, [ebp+var_C]
.text$mn:0000122B                 mov     large fs:0, ecx
.text$mn:00001232                 pop     ecx
.text$mn:00001233                 mov     esp, ebp
.text$mn:00001235                 pop     ebp
.text$mn:00001236                 retn
.text$mn:00001236 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00001236
.text$mn:00001236 ; ---------------------------------------------------------------------------
.text$mn:00001237                 align 4
.text$mn:00001237 _text$mn        ends
.text$mn:00001237
.text$x:00001238 ; ===========================================================================
.text$x:00001238
.text$x:00001238 ; Segment type: Pure code
.text$x:00001238 ; Segment permissions: Read/Execute
.text$x:00001238 _text$x         segment para public 'CODE' use32
.text$x:00001238                 assume cs:_text$x
.text$x:00001238                 ;org 1238h
.text$x:00001238 ; COMDAT (pick associative to section at 11E0)
.text$x:00001238                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001238
.text$x:00001238 ; =============== S U B R O U T I N E =======================================
.text$x:00001238
.text$x:00001238
.text$x:00001238 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00001238                                         ; DATA XREF: .xdata$x:00002EF8o
.text$x:00001238                 mov     ecx, [ebp-10h]
.text$x:0000123B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000123B __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:0000123B
.text$x:00001240
.text$x:00001240 ; =============== S U B R O U T I N E =======================================
.text$x:00001240
.text$x:00001240
.text$x:00001240 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00001240                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00001240
.text$x:00001240 arg_4           = dword ptr  8
.text$x:00001240
.text$x:00001240                 mov     edx, [esp+arg_4]
.text$x:00001244                 lea     eax, [edx+0Ch]
.text$x:00001247                 mov     ecx, [edx-8]
.text$x:0000124A                 xor     ecx, eax
.text$x:0000124C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001251                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00001256                 jmp     ___CxxFrameHandler3
.text$x:00001256 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00001256
.text$x:00001256 ; ---------------------------------------------------------------------------
.text$x:0000125B                 align 4
.text$x:0000125B _text$x         ends
.text$x:0000125B
.text$mn:0000125C ; ===========================================================================
.text$mn:0000125C
.text$mn:0000125C ; Segment type: Pure code
.text$mn:0000125C ; Segment permissions: Read/Execute
.text$mn:0000125C _text$mn        segment para public 'CODE' use32
.text$mn:0000125C                 assume cs:_text$mn
.text$mn:0000125C                 ;org 125Ch
.text$mn:0000125C ; COMDAT (pick any)
.text$mn:0000125C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000125C
.text$mn:0000125C ; =============== S U B R O U T I N E =======================================
.text$mn:0000125C
.text$mn:0000125C ; Attributes: bp-based frame
.text$mn:0000125C
.text$mn:0000125C ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:0000125C                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:0000125C ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:0000125C                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:0000125C                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:0000125C
.text$mn:0000125C var_4           = dword ptr -4
.text$mn:0000125C
.text$mn:0000125C                 push    ebp
.text$mn:0000125D                 mov     ebp, esp
.text$mn:0000125F                 push    ecx
.text$mn:00001260                 mov     [ebp+var_4], ecx
.text$mn:00001263                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001266                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000126B                 mov     esp, ebp
.text$mn:0000126D                 pop     ebp
.text$mn:0000126E                 retn
.text$mn:0000126E ??1_Container_base12@std@@QAE@XZ endp
.text$mn:0000126E
.text$mn:0000126E ; ---------------------------------------------------------------------------
.text$mn:0000126F                 align 10h
.text$mn:0000126F _text$mn        ends
.text$mn:0000126F
.text$mn:00001270 ; ===========================================================================
.text$mn:00001270
.text$mn:00001270 ; Segment type: Pure code
.text$mn:00001270 ; Segment permissions: Read/Execute
.text$mn:00001270 _text$mn        segment para public 'CODE' use32
.text$mn:00001270                 assume cs:_text$mn
.text$mn:00001270                 ;org 1270h
.text$mn:00001270 ; COMDAT (pick any)
.text$mn:00001270                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001270
.text$mn:00001270 ; =============== S U B R O U T I N E =======================================
.text$mn:00001270
.text$mn:00001270 ; Attributes: bp-based frame
.text$mn:00001270
.text$mn:00001270 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00001270                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00001270 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00001270                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00001270                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00001270
.text$mn:00001270 var_10          = dword ptr -10h
.text$mn:00001270 var_C           = dword ptr -0Ch
.text$mn:00001270 var_4           = dword ptr -4
.text$mn:00001270
.text$mn:00001270                 push    ebp
.text$mn:00001271                 mov     ebp, esp
.text$mn:00001273                 push    0FFFFFFFFh
.text$mn:00001275                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:0000127A                 mov     eax, large fs:0
.text$mn:00001280                 push    eax
.text$mn:00001281                 push    ecx
.text$mn:00001282                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001287                 xor     eax, ebp
.text$mn:00001289                 push    eax
.text$mn:0000128A                 lea     eax, [ebp+var_C]
.text$mn:0000128D                 mov     large fs:0, eax
.text$mn:00001293                 mov     [ebp+var_10], ecx
.text$mn:00001296                 mov     [ebp+var_4], 0
.text$mn:0000129D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000012A4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000012A7                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:000012AC                 mov     ecx, [ebp+var_C]
.text$mn:000012AF                 mov     large fs:0, ecx
.text$mn:000012B6                 pop     ecx
.text$mn:000012B7                 mov     esp, ebp
.text$mn:000012B9                 pop     ebp
.text$mn:000012BA                 retn
.text$mn:000012BA ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:000012BA
.text$mn:000012BA ; ---------------------------------------------------------------------------
.text$mn:000012BB                 align 4
.text$mn:000012BB _text$mn        ends
.text$mn:000012BB
.text$x:000012BC ; ===========================================================================
.text$x:000012BC
.text$x:000012BC ; Segment type: Pure code
.text$x:000012BC ; Segment permissions: Read/Execute
.text$x:000012BC _text$x         segment para public 'CODE' use32
.text$x:000012BC                 assume cs:_text$x
.text$x:000012BC                 ;org 12BCh
.text$x:000012BC ; COMDAT (pick associative to section at 1270)
.text$x:000012BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000012BC
.text$x:000012BC ; =============== S U B R O U T I N E =======================================
.text$x:000012BC
.text$x:000012BC
.text$x:000012BC __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:000012BC                                         ; DATA XREF: .xdata$x:00003008o
.text$x:000012BC                 mov     ecx, [ebp-10h]  ; this
.text$x:000012BF                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000012BF __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:000012BF
.text$x:000012C4
.text$x:000012C4 ; =============== S U B R O U T I N E =======================================
.text$x:000012C4
.text$x:000012C4
.text$x:000012C4 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:000012C4                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:000012C4
.text$x:000012C4 arg_4           = dword ptr  8
.text$x:000012C4
.text$x:000012C4                 mov     edx, [esp+arg_4]
.text$x:000012C8                 lea     eax, [edx+0Ch]
.text$x:000012CB                 mov     ecx, [edx-8]
.text$x:000012CE                 xor     ecx, eax
.text$x:000012D0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000012D5                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:000012DA                 jmp     ___CxxFrameHandler3
.text$x:000012DA __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:000012DA
.text$x:000012DA ; ---------------------------------------------------------------------------
.text$x:000012DF                 align 10h
.text$x:000012DF _text$x         ends
.text$x:000012DF
.text$mn:000012E0 ; ===========================================================================
.text$mn:000012E0
.text$mn:000012E0 ; Segment type: Pure code
.text$mn:000012E0 ; Segment permissions: Read/Execute
.text$mn:000012E0 _text$mn        segment para public 'CODE' use32
.text$mn:000012E0                 assume cs:_text$mn
.text$mn:000012E0                 ;org 12E0h
.text$mn:000012E0 ; COMDAT (pick any)
.text$mn:000012E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000012E0
.text$mn:000012E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000012E0
.text$mn:000012E0 ; Attributes: bp-based frame
.text$mn:000012E0
.text$mn:000012E0 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000012E0                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:000012E0 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:000012E0                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:000012E0                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000012E0
.text$mn:000012E0 var_10          = dword ptr -10h
.text$mn:000012E0 var_C           = dword ptr -0Ch
.text$mn:000012E0 var_4           = dword ptr -4
.text$mn:000012E0
.text$mn:000012E0                 push    ebp
.text$mn:000012E1                 mov     ebp, esp
.text$mn:000012E3                 push    0FFFFFFFFh
.text$mn:000012E5                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:000012EA                 mov     eax, large fs:0
.text$mn:000012F0                 push    eax
.text$mn:000012F1                 push    ecx
.text$mn:000012F2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000012F7                 xor     eax, ebp
.text$mn:000012F9                 push    eax
.text$mn:000012FA                 lea     eax, [ebp+var_C]
.text$mn:000012FD                 mov     large fs:0, eax
.text$mn:00001303                 mov     [ebp+var_10], ecx
.text$mn:00001306                 mov     [ebp+var_4], 0
.text$mn:0000130D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001314                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001317                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:0000131C                 mov     ecx, [ebp+var_C]
.text$mn:0000131F                 mov     large fs:0, ecx
.text$mn:00001326                 pop     ecx
.text$mn:00001327                 mov     esp, ebp
.text$mn:00001329                 pop     ebp
.text$mn:0000132A                 retn
.text$mn:0000132A ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:0000132A
.text$mn:0000132A ; ---------------------------------------------------------------------------
.text$mn:0000132B                 align 4
.text$mn:0000132B _text$mn        ends
.text$mn:0000132B
.text$x:0000132C ; ===========================================================================
.text$x:0000132C
.text$x:0000132C ; Segment type: Pure code
.text$x:0000132C ; Segment permissions: Read/Execute
.text$x:0000132C _text$x         segment para public 'CODE' use32
.text$x:0000132C                 assume cs:_text$x
.text$x:0000132C                 ;org 132Ch
.text$x:0000132C ; COMDAT (pick associative to section at 12E0)
.text$x:0000132C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000132C
.text$x:0000132C ; =============== S U B R O U T I N E =======================================
.text$x:0000132C
.text$x:0000132C
.text$x:0000132C __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:0000132C                                         ; DATA XREF: .xdata$x:0000308Co
.text$x:0000132C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000132F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000132F __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:0000132F
.text$x:00001334
.text$x:00001334 ; =============== S U B R O U T I N E =======================================
.text$x:00001334
.text$x:00001334
.text$x:00001334 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00001334                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00001334
.text$x:00001334 arg_4           = dword ptr  8
.text$x:00001334
.text$x:00001334                 mov     edx, [esp+arg_4]
.text$x:00001338                 lea     eax, [edx+0Ch]
.text$x:0000133B                 mov     ecx, [edx-8]
.text$x:0000133E                 xor     ecx, eax
.text$x:00001340                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001345                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:0000134A                 jmp     ___CxxFrameHandler3
.text$x:0000134A __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:0000134A
.text$x:0000134A ; ---------------------------------------------------------------------------
.text$x:0000134F                 align 10h
.text$x:0000134F _text$x         ends
.text$x:0000134F
.text$mn:00001350 ; ===========================================================================
.text$mn:00001350
.text$mn:00001350 ; Segment type: Pure code
.text$mn:00001350 ; Segment permissions: Read/Execute
.text$mn:00001350 _text$mn        segment para public 'CODE' use32
.text$mn:00001350                 assume cs:_text$mn
.text$mn:00001350                 ;org 1350h
.text$mn:00001350 ; COMDAT (pick any)
.text$mn:00001350                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001350
.text$mn:00001350 ; =============== S U B R O U T I N E =======================================
.text$mn:00001350
.text$mn:00001350 ; Attributes: bp-based frame
.text$mn:00001350
.text$mn:00001350 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00001350                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00001350 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00001350                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00001350                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00001350
.text$mn:00001350 var_10          = dword ptr -10h
.text$mn:00001350 var_C           = dword ptr -0Ch
.text$mn:00001350 var_4           = dword ptr -4
.text$mn:00001350
.text$mn:00001350                 push    ebp
.text$mn:00001351                 mov     ebp, esp
.text$mn:00001353                 push    0FFFFFFFFh
.text$mn:00001355                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:0000135A                 mov     eax, large fs:0
.text$mn:00001360                 push    eax
.text$mn:00001361                 push    ecx
.text$mn:00001362                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001367                 xor     eax, ebp
.text$mn:00001369                 push    eax
.text$mn:0000136A                 lea     eax, [ebp+var_C]
.text$mn:0000136D                 mov     large fs:0, eax
.text$mn:00001373                 mov     [ebp+var_10], ecx
.text$mn:00001376                 mov     [ebp+var_4], 0
.text$mn:0000137D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001384                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001387                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:0000138C                 mov     ecx, [ebp+var_C]
.text$mn:0000138F                 mov     large fs:0, ecx
.text$mn:00001396                 pop     ecx
.text$mn:00001397                 mov     esp, ebp
.text$mn:00001399                 pop     ebp
.text$mn:0000139A                 retn
.text$mn:0000139A ??1_System_error_category@std@@UAE@XZ endp
.text$mn:0000139A
.text$mn:0000139A ; ---------------------------------------------------------------------------
.text$mn:0000139B                 align 4
.text$mn:0000139B _text$mn        ends
.text$mn:0000139B
.text$x:0000139C ; ===========================================================================
.text$x:0000139C
.text$x:0000139C ; Segment type: Pure code
.text$x:0000139C ; Segment permissions: Read/Execute
.text$x:0000139C _text$x         segment para public 'CODE' use32
.text$x:0000139C                 assume cs:_text$x
.text$x:0000139C                 ;org 139Ch
.text$x:0000139C ; COMDAT (pick associative to section at 1350)
.text$x:0000139C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000139C
.text$x:0000139C ; =============== S U B R O U T I N E =======================================
.text$x:0000139C
.text$x:0000139C
.text$x:0000139C __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:0000139C                                         ; DATA XREF: .xdata$x:00003110o
.text$x:0000139C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000139F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000139F __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:0000139F
.text$x:000013A4
.text$x:000013A4 ; =============== S U B R O U T I N E =======================================
.text$x:000013A4
.text$x:000013A4
.text$x:000013A4 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:000013A4                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:000013A4
.text$x:000013A4 arg_4           = dword ptr  8
.text$x:000013A4
.text$x:000013A4                 mov     edx, [esp+arg_4]
.text$x:000013A8                 lea     eax, [edx+0Ch]
.text$x:000013AB                 mov     ecx, [edx-8]
.text$x:000013AE                 xor     ecx, eax
.text$x:000013B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000013B5                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:000013BA                 jmp     ___CxxFrameHandler3
.text$x:000013BA __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:000013BA
.text$x:000013BA ; ---------------------------------------------------------------------------
.text$x:000013BF                 align 10h
.text$x:000013BF _text$x         ends
.text$x:000013BF
.text$mn:000013C0 ; ===========================================================================
.text$mn:000013C0
.text$mn:000013C0 ; Segment type: Pure code
.text$mn:000013C0 ; Segment permissions: Read/Execute
.text$mn:000013C0 _text$mn        segment para public 'CODE' use32
.text$mn:000013C0                 assume cs:_text$mn
.text$mn:000013C0                 ;org 13C0h
.text$mn:000013C0 ; COMDAT (pick any)
.text$mn:000013C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000013C0
.text$mn:000013C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000013C0
.text$mn:000013C0 ; Attributes: bp-based frame
.text$mn:000013C0
.text$mn:000013C0 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:000013C0                 public ??1error_category@std@@UAE@XZ
.text$mn:000013C0 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:000013C0                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:000013C0
.text$mn:000013C0 var_4           = dword ptr -4
.text$mn:000013C0
.text$mn:000013C0                 push    ebp
.text$mn:000013C1                 mov     ebp, esp
.text$mn:000013C3                 push    ecx
.text$mn:000013C4                 mov     [ebp+var_4], ecx
.text$mn:000013C7                 mov     eax, [ebp+var_4]
.text$mn:000013CA                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:000013D0                 mov     esp, ebp
.text$mn:000013D2                 pop     ebp
.text$mn:000013D3                 retn
.text$mn:000013D3 ??1error_category@std@@UAE@XZ endp
.text$mn:000013D3
.text$mn:000013D3 _text$mn        ends
.text$mn:000013D3
.text$mn:000013D4 ; ===========================================================================
.text$mn:000013D4
.text$mn:000013D4 ; Segment type: Pure code
.text$mn:000013D4 ; Segment permissions: Read/Execute
.text$mn:000013D4 _text$mn        segment para public 'CODE' use32
.text$mn:000013D4                 assume cs:_text$mn
.text$mn:000013D4                 ;org 13D4h
.text$mn:000013D4 ; COMDAT (pick any)
.text$mn:000013D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000013D4
.text$mn:000013D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000013D4
.text$mn:000013D4 ; Attributes: bp-based frame
.text$mn:000013D4
.text$mn:000013D4 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:000013D4                 public ??2@YAPAXIPAX@Z
.text$mn:000013D4 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:000013D4                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+2Ep ...
.text$mn:000013D4
.text$mn:000013D4 arg_4           = dword ptr  0Ch
.text$mn:000013D4
.text$mn:000013D4                 push    ebp
.text$mn:000013D5                 mov     ebp, esp
.text$mn:000013D7                 mov     eax, [ebp+arg_4]
.text$mn:000013DA                 pop     ebp
.text$mn:000013DB                 retn
.text$mn:000013DB ??2@YAPAXIPAX@Z endp
.text$mn:000013DB
.text$mn:000013DB _text$mn        ends
.text$mn:000013DB
.text$mn:000013DC ; ===========================================================================
.text$mn:000013DC
.text$mn:000013DC ; Segment type: Pure code
.text$mn:000013DC ; Segment permissions: Read/Execute
.text$mn:000013DC _text$mn        segment para public 'CODE' use32
.text$mn:000013DC                 assume cs:_text$mn
.text$mn:000013DC                 ;org 13DCh
.text$mn:000013DC ; COMDAT (pick any)
.text$mn:000013DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000013DC
.text$mn:000013DC ; =============== S U B R O U T I N E =======================================
.text$mn:000013DC
.text$mn:000013DC ; Attributes: bp-based frame
.text$mn:000013DC
.text$mn:000013DC ; void __cdecl operator delete(void *)
.text$mn:000013DC                 public ??3@YAXPAX0@Z
.text$mn:000013DC ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:000013DC                                         ; __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0+8p ...
.text$mn:000013DC                 push    ebp
.text$mn:000013DD                 mov     ebp, esp
.text$mn:000013DF                 pop     ebp
.text$mn:000013E0                 retn
.text$mn:000013E0 ??3@YAXPAX0@Z   endp
.text$mn:000013E0
.text$mn:000013E0 ; ---------------------------------------------------------------------------
.text$mn:000013E1                 align 4
.text$mn:000013E1 _text$mn        ends
.text$mn:000013E1
.text$mn:000013E4 ; ===========================================================================
.text$mn:000013E4
.text$mn:000013E4 ; Segment type: Pure code
.text$mn:000013E4 ; Segment permissions: Read/Execute
.text$mn:000013E4 _text$mn        segment para public 'CODE' use32
.text$mn:000013E4                 assume cs:_text$mn
.text$mn:000013E4                 ;org 13E4h
.text$mn:000013E4 ; COMDAT (pick any)
.text$mn:000013E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000013E4
.text$mn:000013E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000013E4
.text$mn:000013E4 ; Attributes: bp-based frame
.text$mn:000013E4
.text$mn:000013E4 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t *Str)
.text$mn:000013E4                 public ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
.text$mn:000013E4 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z proc near
.text$mn:000013E4                                         ; CODE XREF: URLCtrl::create(HWND__ *,wchar_t *,ulong)+35p
.text$mn:000013E4
.text$mn:000013E4 var_4           = dword ptr -4
.text$mn:000013E4 Str             = dword ptr  8
.text$mn:000013E4
.text$mn:000013E4                 push    ebp
.text$mn:000013E5                 mov     ebp, esp
.text$mn:000013E7                 push    ecx
.text$mn:000013E8                 mov     [ebp+var_4], ecx
.text$mn:000013EB                 mov     eax, [ebp+Str]
.text$mn:000013EE                 push    eax             ; Str
.text$mn:000013EF                 mov     ecx, [ebp+var_4]
.text$mn:000013F2                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:000013F7                 mov     esp, ebp
.text$mn:000013F9                 pop     ebp
.text$mn:000013FA                 retn    4
.text$mn:000013FA ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z endp
.text$mn:000013FA
.text$mn:000013FA ; ---------------------------------------------------------------------------
.text$mn:000013FD                 align 10h
.text$mn:000013FD _text$mn        ends
.text$mn:000013FD
.text$mn:00001400 ; ===========================================================================
.text$mn:00001400
.text$mn:00001400 ; Segment type: Pure code
.text$mn:00001400 ; Segment permissions: Read/Execute
.text$mn:00001400 _text$mn        segment para public 'CODE' use32
.text$mn:00001400                 assume cs:_text$mn
.text$mn:00001400                 ;org 1400h
.text$mn:00001400 ; COMDAT (pick any)
.text$mn:00001400                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001400
.text$mn:00001400 ; =============== S U B R O U T I N E =======================================
.text$mn:00001400
.text$mn:00001400 ; Attributes: bp-based frame
.text$mn:00001400
.text$mn:00001400 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00001400                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00001400 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00001400                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00001400                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00001400
.text$mn:00001400 var_8           = dword ptr -8
.text$mn:00001400 var_4           = dword ptr -4
.text$mn:00001400 arg_0           = dword ptr  8
.text$mn:00001400
.text$mn:00001400                 push    ebp
.text$mn:00001401                 mov     ebp, esp
.text$mn:00001403                 sub     esp, 8
.text$mn:00001406                 mov     [ebp+var_8], ecx
.text$mn:00001409                 mov     eax, [ebp+var_8]
.text$mn:0000140C                 cmp     eax, [ebp+arg_0]
.text$mn:0000140F                 jnz     short loc_141A
.text$mn:00001411                 mov     [ebp+var_4], 1
.text$mn:00001418                 jmp     short loc_1421
.text$mn:0000141A ; ---------------------------------------------------------------------------
.text$mn:0000141A
.text$mn:0000141A loc_141A:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:0000141A                 mov     [ebp+var_4], 0
.text$mn:00001421
.text$mn:00001421 loc_1421:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00001421                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001424                 mov     esp, ebp
.text$mn:00001426                 pop     ebp
.text$mn:00001427                 retn    4
.text$mn:00001427 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00001427
.text$mn:00001427 ; ---------------------------------------------------------------------------
.text$mn:0000142A                 align 4
.text$mn:0000142A _text$mn        ends
.text$mn:0000142A
.text$mn:0000142C ; ===========================================================================
.text$mn:0000142C
.text$mn:0000142C ; Segment type: Pure code
.text$mn:0000142C ; Segment permissions: Read/Execute
.text$mn:0000142C _text$mn        segment para public 'CODE' use32
.text$mn:0000142C                 assume cs:_text$mn
.text$mn:0000142C                 ;org 142Ch
.text$mn:0000142C ; COMDAT (pick any)
.text$mn:0000142C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000142C
.text$mn:0000142C ; =============== S U B R O U T I N E =======================================
.text$mn:0000142C
.text$mn:0000142C ; Attributes: bp-based frame
.text$mn:0000142C
.text$mn:0000142C ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:0000142C                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:0000142C ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:0000142C                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:0000142C
.text$mn:0000142C var_8           = dword ptr -8
.text$mn:0000142C var_4           = dword ptr -4
.text$mn:0000142C arg_0           = dword ptr  8
.text$mn:0000142C
.text$mn:0000142C                 push    ebp
.text$mn:0000142D                 mov     ebp, esp
.text$mn:0000142F                 sub     esp, 8
.text$mn:00001432                 push    esi
.text$mn:00001433                 mov     [ebp+var_4], ecx
.text$mn:00001436                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001439                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:0000143E                 push    eax
.text$mn:0000143F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001442                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00001447                 mov     ecx, eax
.text$mn:00001449                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000144E                 movzx   eax, al
.text$mn:00001451                 test    eax, eax
.text$mn:00001453                 jz      short loc_1474
.text$mn:00001455                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001458                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:0000145D                 mov     esi, eax
.text$mn:0000145F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001462                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00001467                 cmp     esi, eax
.text$mn:00001469                 jnz     short loc_1474
.text$mn:0000146B                 mov     [ebp+var_8], 1
.text$mn:00001472                 jmp     short loc_147B
.text$mn:00001474 ; ---------------------------------------------------------------------------
.text$mn:00001474
.text$mn:00001474 loc_1474:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00001474                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00001474                 mov     [ebp+var_8], 0
.text$mn:0000147B
.text$mn:0000147B loc_147B:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:0000147B                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000147E                 pop     esi
.text$mn:0000147F                 mov     esp, ebp
.text$mn:00001481                 pop     ebp
.text$mn:00001482                 retn    4
.text$mn:00001482 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00001482
.text$mn:00001482 ; ---------------------------------------------------------------------------
.text$mn:00001485                 align 4
.text$mn:00001485 _text$mn        ends
.text$mn:00001485
.text$mn:00001488 ; ===========================================================================
.text$mn:00001488
.text$mn:00001488 ; Segment type: Pure code
.text$mn:00001488 ; Segment permissions: Read/Execute
.text$mn:00001488 _text$mn        segment para public 'CODE' use32
.text$mn:00001488                 assume cs:_text$mn
.text$mn:00001488                 ;org 1488h
.text$mn:00001488 ; COMDAT (pick any)
.text$mn:00001488                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001488
.text$mn:00001488 ; =============== S U B R O U T I N E =======================================
.text$mn:00001488
.text$mn:00001488 ; Attributes: bp-based frame
.text$mn:00001488
.text$mn:00001488 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001488                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00001488 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001488
.text$mn:00001488 var_4           = dword ptr -4
.text$mn:00001488 arg_0           = dword ptr  8
.text$mn:00001488
.text$mn:00001488                 push    ebp
.text$mn:00001489                 mov     ebp, esp
.text$mn:0000148B                 push    ecx
.text$mn:0000148C                 mov     [ebp+var_4], ecx
.text$mn:0000148F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001492                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001497                 mov     eax, [ebp+arg_0]
.text$mn:0000149A                 and     eax, 1
.text$mn:0000149D                 jz      short loc_14AB
.text$mn:0000149F                 mov     ecx, [ebp+var_4]
.text$mn:000014A2                 push    ecx             ; void *
.text$mn:000014A3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000014A8                 add     esp, 4
.text$mn:000014AB
.text$mn:000014AB loc_14AB:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000014AB                 mov     eax, [ebp+var_4]
.text$mn:000014AE                 mov     esp, ebp
.text$mn:000014B0                 pop     ebp
.text$mn:000014B1                 retn    4
.text$mn:000014B1 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:000014B1
.text$mn:000014B1 _text$mn        ends
.text$mn:000014B1
.text$mn:000014B4 ; ===========================================================================
.text$mn:000014B4
.text$mn:000014B4 ; Segment type: Pure code
.text$mn:000014B4 ; Segment permissions: Read/Execute
.text$mn:000014B4 _text$mn        segment para public 'CODE' use32
.text$mn:000014B4                 assume cs:_text$mn
.text$mn:000014B4                 ;org 14B4h
.text$mn:000014B4 ; COMDAT (pick any)
.text$mn:000014B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000014B4
.text$mn:000014B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000014B4
.text$mn:000014B4 ; Attributes: bp-based frame
.text$mn:000014B4
.text$mn:000014B4 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000014B4                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:000014B4 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:000014B4
.text$mn:000014B4 var_4           = dword ptr -4
.text$mn:000014B4 arg_0           = dword ptr  8
.text$mn:000014B4
.text$mn:000014B4                 push    ebp
.text$mn:000014B5                 mov     ebp, esp
.text$mn:000014B7                 push    ecx
.text$mn:000014B8                 mov     [ebp+var_4], ecx
.text$mn:000014BB                 mov     ecx, [ebp+var_4] ; this
.text$mn:000014BE                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:000014C3                 mov     eax, [ebp+arg_0]
.text$mn:000014C6                 and     eax, 1
.text$mn:000014C9                 jz      short loc_14D7
.text$mn:000014CB                 mov     ecx, [ebp+var_4]
.text$mn:000014CE                 push    ecx             ; void *
.text$mn:000014CF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000014D4                 add     esp, 4
.text$mn:000014D7
.text$mn:000014D7 loc_14D7:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000014D7                 mov     eax, [ebp+var_4]
.text$mn:000014DA                 mov     esp, ebp
.text$mn:000014DC                 pop     ebp
.text$mn:000014DD                 retn    4
.text$mn:000014DD ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:000014DD
.text$mn:000014DD _text$mn        ends
.text$mn:000014DD
.text$mn:000014E0 ; ===========================================================================
.text$mn:000014E0
.text$mn:000014E0 ; Segment type: Pure code
.text$mn:000014E0 ; Segment permissions: Read/Execute
.text$mn:000014E0 _text$mn        segment para public 'CODE' use32
.text$mn:000014E0                 assume cs:_text$mn
.text$mn:000014E0                 ;org 14E0h
.text$mn:000014E0 ; COMDAT (pick any)
.text$mn:000014E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000014E0
.text$mn:000014E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000014E0
.text$mn:000014E0 ; Attributes: bp-based frame
.text$mn:000014E0
.text$mn:000014E0 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000014E0                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:000014E0 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:000014E0
.text$mn:000014E0 var_4           = dword ptr -4
.text$mn:000014E0 arg_0           = dword ptr  8
.text$mn:000014E0
.text$mn:000014E0                 push    ebp
.text$mn:000014E1                 mov     ebp, esp
.text$mn:000014E3                 push    ecx
.text$mn:000014E4                 mov     [ebp+var_4], ecx
.text$mn:000014E7                 mov     ecx, [ebp+var_4] ; this
.text$mn:000014EA                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:000014EF                 mov     eax, [ebp+arg_0]
.text$mn:000014F2                 and     eax, 1
.text$mn:000014F5                 jz      short loc_1503
.text$mn:000014F7                 mov     ecx, [ebp+var_4]
.text$mn:000014FA                 push    ecx             ; void *
.text$mn:000014FB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001500                 add     esp, 4
.text$mn:00001503
.text$mn:00001503 loc_1503:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001503                 mov     eax, [ebp+var_4]
.text$mn:00001506                 mov     esp, ebp
.text$mn:00001508                 pop     ebp
.text$mn:00001509                 retn    4
.text$mn:00001509 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00001509
.text$mn:00001509 _text$mn        ends
.text$mn:00001509
.text$mn:0000150C ; ===========================================================================
.text$mn:0000150C
.text$mn:0000150C ; Segment type: Pure code
.text$mn:0000150C ; Segment permissions: Read/Execute
.text$mn:0000150C _text$mn        segment para public 'CODE' use32
.text$mn:0000150C                 assume cs:_text$mn
.text$mn:0000150C                 ;org 150Ch
.text$mn:0000150C ; COMDAT (pick any)
.text$mn:0000150C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000150C
.text$mn:0000150C ; =============== S U B R O U T I N E =======================================
.text$mn:0000150C
.text$mn:0000150C ; Attributes: bp-based frame
.text$mn:0000150C
.text$mn:0000150C ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:0000150C                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:0000150C ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:0000150C
.text$mn:0000150C var_4           = dword ptr -4
.text$mn:0000150C arg_0           = dword ptr  8
.text$mn:0000150C
.text$mn:0000150C                 push    ebp
.text$mn:0000150D                 mov     ebp, esp
.text$mn:0000150F                 push    ecx
.text$mn:00001510                 mov     [ebp+var_4], ecx
.text$mn:00001513                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001516                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:0000151B                 mov     eax, [ebp+arg_0]
.text$mn:0000151E                 and     eax, 1
.text$mn:00001521                 jz      short loc_152F
.text$mn:00001523                 mov     ecx, [ebp+var_4]
.text$mn:00001526                 push    ecx             ; void *
.text$mn:00001527                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000152C                 add     esp, 4
.text$mn:0000152F
.text$mn:0000152F loc_152F:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000152F                 mov     eax, [ebp+var_4]
.text$mn:00001532                 mov     esp, ebp
.text$mn:00001534                 pop     ebp
.text$mn:00001535                 retn    4
.text$mn:00001535 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00001535
.text$mn:00001535 _text$mn        ends
.text$mn:00001535
.text$di:00001538 ; ===========================================================================
.text$di:00001538
.text$di:00001538 ; Segment type: Pure code
.text$di:00001538 ; Segment permissions: Read/Execute
.text$di:00001538 _text$di        segment para public 'CODE' use32
.text$di:00001538                 assume cs:_text$di
.text$di:00001538                 ;org 1538h
.text$di:00001538 ; COMDAT (pick any)
.text$di:00001538                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001538
.text$di:00001538 ; =============== S U B R O U T I N E =======================================
.text$di:00001538
.text$di:00001538 ; Attributes: bp-based frame
.text$di:00001538
.text$di:00001538 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00001538 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00001538                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00001538                 push    ebp
.text$di:00001539                 mov     ebp, esp
.text$di:0000153B                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00001540                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00001545                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:0000154A                 call    _atexit
.text$di:0000154F                 add     esp, 4
.text$di:00001552                 pop     ebp
.text$di:00001553                 retn
.text$di:00001553 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00001553
.text$di:00001553 _text$di        ends
.text$di:00001553
.text$di:00001554 ; ===========================================================================
.text$di:00001554
.text$di:00001554 ; Segment type: Pure code
.text$di:00001554 ; Segment permissions: Read/Execute
.text$di:00001554 _text$di        segment para public 'CODE' use32
.text$di:00001554                 assume cs:_text$di
.text$di:00001554                 ;org 1554h
.text$di:00001554 ; COMDAT (pick any)
.text$di:00001554                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001554
.text$di:00001554 ; =============== S U B R O U T I N E =======================================
.text$di:00001554
.text$di:00001554 ; Attributes: bp-based frame
.text$di:00001554
.text$di:00001554 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00001554 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00001554                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00001554                 push    ebp
.text$di:00001555                 mov     ebp, esp
.text$di:00001557                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:0000155C                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00001561                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001566                 call    _atexit
.text$di:0000156B                 add     esp, 4
.text$di:0000156E                 pop     ebp
.text$di:0000156F                 retn
.text$di:0000156F ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:0000156F
.text$di:0000156F _text$di        ends
.text$di:0000156F
.text$di:00001570 ; ===========================================================================
.text$di:00001570
.text$di:00001570 ; Segment type: Pure code
.text$di:00001570 ; Segment permissions: Read/Execute
.text$di:00001570 _text$di        segment para public 'CODE' use32
.text$di:00001570                 assume cs:_text$di
.text$di:00001570                 ;org 1570h
.text$di:00001570 ; COMDAT (pick any)
.text$di:00001570                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001570
.text$di:00001570 ; =============== S U B R O U T I N E =======================================
.text$di:00001570
.text$di:00001570 ; Attributes: bp-based frame
.text$di:00001570
.text$di:00001570 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00001570 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00001570                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00001570                 push    ebp
.text$di:00001571                 mov     ebp, esp
.text$di:00001573                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00001578                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:0000157D                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001582                 call    _atexit
.text$di:00001587                 add     esp, 4
.text$di:0000158A                 pop     ebp
.text$di:0000158B                 retn
.text$di:0000158B ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:0000158B
.text$di:0000158B _text$di        ends
.text$di:0000158B
.text$di:0000158C ; ===========================================================================
.text$di:0000158C
.text$di:0000158C ; Segment type: Pure code
.text$di:0000158C ; Segment permissions: Read/Execute
.text$di:0000158C _text$di        segment para public 'CODE' use32
.text$di:0000158C                 assume cs:_text$di
.text$di:0000158C                 ;org 158Ch
.text$di:0000158C ; COMDAT (pick any)
.text$di:0000158C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:0000158C
.text$di:0000158C ; =============== S U B R O U T I N E =======================================
.text$di:0000158C
.text$di:0000158C ; Attributes: bp-based frame
.text$di:0000158C
.text$di:0000158C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:0000158C ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:0000158C                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:0000158C                 push    ebp
.text$di:0000158D                 mov     ebp, esp
.text$di:0000158F                 push    0               ; unsigned int
.text$di:00001591                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00001596                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000159B                 pop     ebp
.text$di:0000159C                 retn
.text$di:0000159C ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:0000159C
.text$di:0000159C ; ---------------------------------------------------------------------------
.text$di:0000159D                 align 10h
.text$di:0000159D _text$di        ends
.text$di:0000159D
.text$di:000015A0 ; ===========================================================================
.text$di:000015A0
.text$di:000015A0 ; Segment type: Pure code
.text$di:000015A0 ; Segment permissions: Read/Execute
.text$di:000015A0 _text$di        segment para public 'CODE' use32
.text$di:000015A0                 assume cs:_text$di
.text$di:000015A0                 ;org 15A0h
.text$di:000015A0 ; COMDAT (pick any)
.text$di:000015A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000015A0
.text$di:000015A0 ; =============== S U B R O U T I N E =======================================
.text$di:000015A0
.text$di:000015A0 ; Attributes: bp-based frame
.text$di:000015A0
.text$di:000015A0 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:000015A0 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000015A0                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:000015A0                 push    ebp
.text$di:000015A1                 mov     ebp, esp
.text$di:000015A3                 push    0               ; unsigned int
.text$di:000015A5                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:000015AA                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000015AF                 pop     ebp
.text$di:000015B0                 retn
.text$di:000015B0 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000015B0
.text$di:000015B0 ; ---------------------------------------------------------------------------
.text$di:000015B1                 align 4
.text$di:000015B1 _text$di        ends
.text$di:000015B1
.text$di:000015B4 ; ===========================================================================
.text$di:000015B4
.text$di:000015B4 ; Segment type: Pure code
.text$di:000015B4 ; Segment permissions: Read/Execute
.text$di:000015B4 _text$di        segment para public 'CODE' use32
.text$di:000015B4                 assume cs:_text$di
.text$di:000015B4                 ;org 15B4h
.text$di:000015B4 ; COMDAT (pick any)
.text$di:000015B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000015B4
.text$di:000015B4 ; =============== S U B R O U T I N E =======================================
.text$di:000015B4
.text$di:000015B4 ; Attributes: bp-based frame
.text$di:000015B4
.text$di:000015B4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:000015B4 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000015B4                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:000015B4                 push    ebp
.text$di:000015B5                 mov     ebp, esp
.text$di:000015B7                 push    0               ; unsigned int
.text$di:000015B9                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:000015BE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000015C3                 pop     ebp
.text$di:000015C4                 retn
.text$di:000015C4 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000015C4
.text$di:000015C4 ; ---------------------------------------------------------------------------
.text$di:000015C5                 align 4
.text$di:000015C5 _text$di        ends
.text$di:000015C5
.text$di:000015C8 ; ===========================================================================
.text$di:000015C8
.text$di:000015C8 ; Segment type: Pure code
.text$di:000015C8 ; Segment permissions: Read/Execute
.text$di:000015C8 _text$di        segment para public 'CODE' use32
.text$di:000015C8                 assume cs:_text$di
.text$di:000015C8                 ;org 15C8h
.text$di:000015C8 ; COMDAT (pick any)
.text$di:000015C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000015C8
.text$di:000015C8 ; =============== S U B R O U T I N E =======================================
.text$di:000015C8
.text$di:000015C8 ; Attributes: bp-based frame
.text$di:000015C8
.text$di:000015C8 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:000015C8 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000015C8                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:000015C8                 push    ebp
.text$di:000015C9                 mov     ebp, esp
.text$di:000015CB                 push    0               ; unsigned int
.text$di:000015CD                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:000015D2                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000015D7                 pop     ebp
.text$di:000015D8                 retn
.text$di:000015D8 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000015D8
.text$di:000015D8 ; ---------------------------------------------------------------------------
.text$di:000015D9                 align 4
.text$di:000015D9 _text$di        ends
.text$di:000015D9
.text$di:000015DC ; ===========================================================================
.text$di:000015DC
.text$di:000015DC ; Segment type: Pure code
.text$di:000015DC ; Segment permissions: Read/Execute
.text$di:000015DC _text$di        segment para public 'CODE' use32
.text$di:000015DC                 assume cs:_text$di
.text$di:000015DC                 ;org 15DCh
.text$di:000015DC ; COMDAT (pick any)
.text$di:000015DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000015DC
.text$di:000015DC ; =============== S U B R O U T I N E =======================================
.text$di:000015DC
.text$di:000015DC ; Attributes: bp-based frame
.text$di:000015DC
.text$di:000015DC ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:000015DC ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:000015DC
.text$di:000015DC var_1           = byte ptr -1
.text$di:000015DC
.text$di:000015DC                 push    ebp
.text$di:000015DD                 mov     ebp, esp
.text$di:000015DF                 push    ecx
.text$di:000015E0                 xor     eax, eax
.text$di:000015E2                 mov     [ebp+var_1], al
.text$di:000015E5                 mov     esp, ebp
.text$di:000015E7                 pop     ebp
.text$di:000015E8                 retn
.text$di:000015E8 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:000015E8
.text$di:000015E8 ; ---------------------------------------------------------------------------
.text$di:000015E9                 align 4
.text$di:000015E9 _text$di        ends
.text$di:000015E9
.text$di:000015EC ; ===========================================================================
.text$di:000015EC
.text$di:000015EC ; Segment type: Pure code
.text$di:000015EC ; Segment permissions: Read/Execute
.text$di:000015EC _text$di        segment para public 'CODE' use32
.text$di:000015EC                 assume cs:_text$di
.text$di:000015EC                 ;org 15ECh
.text$di:000015EC ; COMDAT (pick any)
.text$di:000015EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000015EC
.text$di:000015EC ; =============== S U B R O U T I N E =======================================
.text$di:000015EC
.text$di:000015EC ; Attributes: bp-based frame
.text$di:000015EC
.text$di:000015EC ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:000015EC ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:000015EC                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:000015EC
.text$di:000015EC var_1           = byte ptr -1
.text$di:000015EC
.text$di:000015EC                 push    ebp
.text$di:000015ED                 mov     ebp, esp
.text$di:000015EF                 push    ecx
.text$di:000015F0                 xor     eax, eax
.text$di:000015F2                 mov     [ebp+var_1], al
.text$di:000015F5                 mov     esp, ebp
.text$di:000015F7                 pop     ebp
.text$di:000015F8                 retn
.text$di:000015F8 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:000015F8
.text$di:000015F8 ; ---------------------------------------------------------------------------
.text$di:000015F9                 align 4
.text$di:000015F9 _text$di        ends
.text$di:000015F9
.text$yd:000015FC ; ===========================================================================
.text$yd:000015FC
.text$yd:000015FC ; Segment type: Pure code
.text$yd:000015FC ; Segment permissions: Read/Execute
.text$yd:000015FC _text$yd        segment para public 'CODE' use32
.text$yd:000015FC                 assume cs:_text$yd
.text$yd:000015FC                 ;org 15FCh
.text$yd:000015FC ; COMDAT (pick any)
.text$yd:000015FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:000015FC
.text$yd:000015FC ; =============== S U B R O U T I N E =======================================
.text$yd:000015FC
.text$yd:000015FC ; Attributes: bp-based frame
.text$yd:000015FC
.text$yd:000015FC ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:000015FC ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:000015FC                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:000015FC                 push    ebp
.text$yd:000015FD                 mov     ebp, esp
.text$yd:000015FF                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00001604                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00001609                 pop     ebp
.text$yd:0000160A                 retn
.text$yd:0000160A ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:0000160A
.text$yd:0000160A ; ---------------------------------------------------------------------------
.text$yd:0000160B                 align 4
.text$yd:0000160B _text$yd        ends
.text$yd:0000160B
.text$yd:0000160C ; ===========================================================================
.text$yd:0000160C
.text$yd:0000160C ; Segment type: Pure code
.text$yd:0000160C ; Segment permissions: Read/Execute
.text$yd:0000160C _text$yd        segment para public 'CODE' use32
.text$yd:0000160C                 assume cs:_text$yd
.text$yd:0000160C                 ;org 160Ch
.text$yd:0000160C ; COMDAT (pick any)
.text$yd:0000160C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:0000160C
.text$yd:0000160C ; =============== S U B R O U T I N E =======================================
.text$yd:0000160C
.text$yd:0000160C ; Attributes: bp-based frame
.text$yd:0000160C
.text$yd:0000160C ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:0000160C ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:0000160C                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:0000160C                 push    ebp
.text$yd:0000160D                 mov     ebp, esp
.text$yd:0000160F                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00001614                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00001619                 pop     ebp
.text$yd:0000161A                 retn
.text$yd:0000161A ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:0000161A
.text$yd:0000161A ; ---------------------------------------------------------------------------
.text$yd:0000161B                 align 4
.text$yd:0000161B _text$yd        ends
.text$yd:0000161B
.text$yd:0000161C ; ===========================================================================
.text$yd:0000161C
.text$yd:0000161C ; Segment type: Pure code
.text$yd:0000161C ; Segment permissions: Read/Execute
.text$yd:0000161C _text$yd        segment para public 'CODE' use32
.text$yd:0000161C                 assume cs:_text$yd
.text$yd:0000161C                 ;org 161Ch
.text$yd:0000161C ; COMDAT (pick any)
.text$yd:0000161C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:0000161C
.text$yd:0000161C ; =============== S U B R O U T I N E =======================================
.text$yd:0000161C
.text$yd:0000161C ; Attributes: bp-based frame
.text$yd:0000161C
.text$yd:0000161C ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:0000161C ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:0000161C                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:0000161C                 push    ebp
.text$yd:0000161D                 mov     ebp, esp
.text$yd:0000161F                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00001624                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00001629                 pop     ebp
.text$yd:0000162A                 retn
.text$yd:0000162A ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:0000162A
.text$yd:0000162A ; ---------------------------------------------------------------------------
.text$yd:0000162B                 align 4
.text$yd:0000162B _text$yd        ends
.text$yd:0000162B
.text$mn:0000162C ; ===========================================================================
.text$mn:0000162C
.text$mn:0000162C ; Segment type: Pure code
.text$mn:0000162C ; Segment permissions: Read/Execute
.text$mn:0000162C _text$mn        segment para public 'CODE' use32
.text$mn:0000162C                 assume cs:_text$mn
.text$mn:0000162C                 ;org 162Ch
.text$mn:0000162C ; COMDAT (pick any)
.text$mn:0000162C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000162C
.text$mn:0000162C ; =============== S U B R O U T I N E =======================================
.text$mn:0000162C
.text$mn:0000162C ; Attributes: bp-based frame
.text$mn:0000162C
.text$mn:0000162C ; __int32 __stdcall URLCtrl::URLCtrlProc(HWND hWnd, UINT Msg, WPARAM wParam, __int32)
.text$mn:0000162C                 public ?URLCtrlProc@URLCtrl@@KGJPAUHWND__@@IIJ@Z
.text$mn:0000162C ?URLCtrlProc@URLCtrl@@KGJPAUHWND__@@IIJ@Z proc near
.text$mn:0000162C                                         ; DATA XREF: URLCtrl::create(HWND__ *,wchar_t *,ulong)+4Do
.text$mn:0000162C                                         ; URLCtrl::create(HWND__ *,int,HWND__ *)+41o
.text$mn:0000162C
.text$mn:0000162C hWnd            = dword ptr  8
.text$mn:0000162C Msg             = dword ptr  0Ch
.text$mn:0000162C wParam          = dword ptr  10h
.text$mn:0000162C arg_C           = dword ptr  14h
.text$mn:0000162C
.text$mn:0000162C                 push    ebp
.text$mn:0000162D                 mov     ebp, esp
.text$mn:0000162F                 mov     eax, [ebp+arg_C]
.text$mn:00001632                 push    eax             ; __int32
.text$mn:00001633                 mov     ecx, [ebp+wParam]
.text$mn:00001636                 push    ecx             ; wParam
.text$mn:00001637                 mov     edx, [ebp+Msg]
.text$mn:0000163A                 push    edx             ; Msg
.text$mn:0000163B                 mov     eax, [ebp+hWnd]
.text$mn:0000163E                 push    eax             ; hWnd
.text$mn:0000163F                 push    0FFFFFFEBh      ; nIndex
.text$mn:00001641                 mov     ecx, [ebp+hWnd]
.text$mn:00001644                 push    ecx             ; hWnd
.text$mn:00001645                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:0000164B                 mov     ecx, eax        ; this
.text$mn:0000164D                 call    ?runProc@URLCtrl@@IAEJPAUHWND__@@IIJ@Z ; URLCtrl::runProc(HWND__ *,uint,uint,long)
.text$mn:00001652                 pop     ebp
.text$mn:00001653                 retn    10h
.text$mn:00001653 ?URLCtrlProc@URLCtrl@@KGJPAUHWND__@@IIJ@Z endp
.text$mn:00001653
.text$mn:00001653 ; ---------------------------------------------------------------------------
.text$mn:00001656                 align 4
.text$mn:00001656 _text$mn        ends
.text$mn:00001656
.text$mn:00001658 ; ===========================================================================
.text$mn:00001658
.text$mn:00001658 ; Segment type: Pure code
.text$mn:00001658 ; Segment permissions: Read/Execute
.text$mn:00001658 _text$mn        segment para public 'CODE' use32
.text$mn:00001658                 assume cs:_text$mn
.text$mn:00001658                 ;org 1658h
.text$mn:00001658 ; COMDAT (pick any)
.text$mn:00001658                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001658
.text$mn:00001658 ; =============== S U B R O U T I N E =======================================
.text$mn:00001658
.text$mn:00001658 ; Attributes: bp-based frame
.text$mn:00001658
.text$mn:00001658 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00001658                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00001658 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001658                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00001658
.text$mn:00001658 var_10          = byte ptr -10h
.text$mn:00001658 var_8           = dword ptr -8
.text$mn:00001658 var_1           = byte ptr -1
.text$mn:00001658
.text$mn:00001658                 push    ebp
.text$mn:00001659                 mov     ebp, esp
.text$mn:0000165B                 sub     esp, 10h
.text$mn:0000165E                 mov     [ebp+var_8], ecx
.text$mn:00001661                 lea     ecx, [ebp+var_1]
.text$mn:00001664                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001669                 push    1
.text$mn:0000166B                 lea     ecx, [ebp+var_1]
.text$mn:0000166E                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00001673                 mov     ecx, [ebp+var_8]
.text$mn:00001676                 mov     [ecx], eax
.text$mn:00001678                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000167B                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00001680                 push    eax             ; int
.text$mn:00001681                 mov     edx, [ebp+var_8]
.text$mn:00001684                 mov     eax, [edx]
.text$mn:00001686                 push    eax             ; void *
.text$mn:00001687                 lea     ecx, [ebp+var_1]
.text$mn:0000168A                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000168F                 mov     ecx, [ebp+var_8]
.text$mn:00001692                 mov     edx, [ecx]
.text$mn:00001694                 mov     eax, [ebp+var_8]
.text$mn:00001697                 mov     [edx], eax
.text$mn:00001699                 mov     esp, ebp
.text$mn:0000169B                 pop     ebp
.text$mn:0000169C                 retn
.text$mn:0000169C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000169C
.text$mn:0000169C ; ---------------------------------------------------------------------------
.text$mn:0000169D                 align 10h
.text$mn:0000169D _text$mn        ends
.text$mn:0000169D
.text$mn:000016A0 ; ===========================================================================
.text$mn:000016A0
.text$mn:000016A0 ; Segment type: Pure code
.text$mn:000016A0 ; Segment permissions: Read/Execute
.text$mn:000016A0 _text$mn        segment para public 'CODE' use32
.text$mn:000016A0                 assume cs:_text$mn
.text$mn:000016A0                 ;org 16A0h
.text$mn:000016A0 ; COMDAT (pick any)
.text$mn:000016A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000016A0
.text$mn:000016A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000016A0
.text$mn:000016A0 ; Attributes: bp-based frame
.text$mn:000016A0
.text$mn:000016A0 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:000016A0                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000016A0 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:000016A0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:000016A0
.text$mn:000016A0 var_20          = dword ptr -20h
.text$mn:000016A0 var_1C          = dword ptr -1Ch
.text$mn:000016A0 var_18          = dword ptr -18h
.text$mn:000016A0 var_11          = byte ptr -11h
.text$mn:000016A0 var_10          = dword ptr -10h
.text$mn:000016A0 var_C           = byte ptr -0Ch
.text$mn:000016A0 var_4           = dword ptr -4
.text$mn:000016A0 arg_0           = dword ptr  8
.text$mn:000016A0
.text$mn:000016A0 ; FUNCTION CHUNK AT .text$mn:000017C2 SIZE 00000009 BYTES
.text$mn:000016A0
.text$mn:000016A0                 push    ebp
.text$mn:000016A1                 mov     ebp, esp
.text$mn:000016A3                 push    0FFFFFFFFh
.text$mn:000016A5                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000016AA                 mov     eax, large fs:0
.text$mn:000016B0                 push    eax
.text$mn:000016B1                 push    ecx
.text$mn:000016B2                 sub     esp, 10h
.text$mn:000016B5                 push    ebx
.text$mn:000016B6                 push    esi
.text$mn:000016B7                 push    edi
.text$mn:000016B8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000016BD                 xor     eax, ebp
.text$mn:000016BF                 push    eax
.text$mn:000016C0                 lea     eax, [ebp+var_C]
.text$mn:000016C3                 mov     large fs:0, eax
.text$mn:000016C9                 mov     [ebp+var_10], esp
.text$mn:000016CC                 mov     [ebp+var_18], ecx
.text$mn:000016CF                 mov     eax, [ebp+arg_0]
.text$mn:000016D2                 or      eax, 0Fh
.text$mn:000016D5                 mov     [ebp+var_1C], eax
.text$mn:000016D8                 mov     ecx, [ebp+var_18]
.text$mn:000016DB                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000016E0                 cmp     eax, [ebp+var_1C]
.text$mn:000016E3                 jnb     short loc_16ED
.text$mn:000016E5                 mov     ecx, [ebp+arg_0]
.text$mn:000016E8                 mov     [ebp+var_1C], ecx
.text$mn:000016EB                 jmp     short loc_173F
.text$mn:000016ED ; ---------------------------------------------------------------------------
.text$mn:000016ED
.text$mn:000016ED loc_16ED:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:000016ED                 mov     edx, [ebp+var_18]
.text$mn:000016F0                 mov     ecx, [edx+18h]
.text$mn:000016F3                 shr     ecx, 1
.text$mn:000016F5                 mov     eax, [ebp+var_1C]
.text$mn:000016F8                 xor     edx, edx
.text$mn:000016FA                 mov     esi, 3
.text$mn:000016FF                 div     esi
.text$mn:00001701                 cmp     ecx, eax
.text$mn:00001703                 ja      short loc_1707
.text$mn:00001705                 jmp     short loc_173F
.text$mn:00001707 ; ---------------------------------------------------------------------------
.text$mn:00001707
.text$mn:00001707 loc_1707:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00001707                 mov     ecx, [ebp+var_18]
.text$mn:0000170A                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000170F                 mov     edx, [ebp+var_18]
.text$mn:00001712                 mov     ecx, [edx+18h]
.text$mn:00001715                 shr     ecx, 1
.text$mn:00001717                 sub     eax, ecx
.text$mn:00001719                 mov     edx, [ebp+var_18]
.text$mn:0000171C                 cmp     [edx+18h], eax
.text$mn:0000171F                 ja      short loc_1734
.text$mn:00001721                 mov     eax, [ebp+var_18]
.text$mn:00001724                 mov     ecx, [eax+18h]
.text$mn:00001727                 shr     ecx, 1
.text$mn:00001729                 mov     edx, [ebp+var_18]
.text$mn:0000172C                 add     ecx, [edx+18h]
.text$mn:0000172F                 mov     [ebp+var_1C], ecx
.text$mn:00001732                 jmp     short loc_173F
.text$mn:00001734 ; ---------------------------------------------------------------------------
.text$mn:00001734
.text$mn:00001734 loc_1734:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00001734                 mov     ecx, [ebp+var_18]
.text$mn:00001737                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000173C                 mov     [ebp+var_1C], eax
.text$mn:0000173F
.text$mn:0000173F loc_173F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:0000173F                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:0000173F                 mov     [ebp+var_4], 0
.text$mn:00001746                 mov     eax, [ebp+var_1C]
.text$mn:00001749                 add     eax, 1
.text$mn:0000174C                 push    eax
.text$mn:0000174D                 lea     ecx, [ebp+var_11]
.text$mn:00001750                 push    ecx
.text$mn:00001751                 mov     ecx, [ebp+var_18]
.text$mn:00001754                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001759                 mov     ecx, eax
.text$mn:0000175B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00001760                 mov     [ebp+var_20], eax
.text$mn:00001763                 jmp     short loc_17C2
.text$mn:00001763 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00001763
.text$mn:00001765
.text$mn:00001765 ; =============== S U B R O U T I N E =======================================
.text$mn:00001765
.text$mn:00001765
.text$mn:00001765 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00001765                                         ; DATA XREF: .xdata$x:00002F2Co
.text$mn:00001765
.text$mn:00001765 ; FUNCTION CHUNK AT .text$mn:000017AC SIZE 00000009 BYTES
.text$mn:00001765 ; FUNCTION CHUNK AT .text$mn:000017BC SIZE 00000006 BYTES
.text$mn:00001765
.text$mn:00001765                 mov     [ebp-10h], esp
.text$mn:00001768                 mov     edx, [ebp+8]
.text$mn:0000176B                 mov     [ebp-1Ch], edx
.text$mn:0000176E                 mov     byte ptr [ebp-4], 2
.text$mn:00001772                 mov     eax, [ebp-1Ch]
.text$mn:00001775                 add     eax, 1
.text$mn:00001778                 push    eax
.text$mn:00001779                 lea     ecx, [ebp-12h]
.text$mn:0000177C                 push    ecx
.text$mn:0000177D                 mov     ecx, [ebp-18h]
.text$mn:00001780                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001785                 mov     ecx, eax
.text$mn:00001787                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:0000178C                 mov     [ebp-20h], eax
.text$mn:0000178F                 jmp     short loc_17AC
.text$mn:0000178F __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:0000178F
.text$mn:00001791
.text$mn:00001791 ; =============== S U B R O U T I N E =======================================
.text$mn:00001791
.text$mn:00001791 ; Attributes: noreturn
.text$mn:00001791
.text$mn:00001791 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00001791                                         ; DATA XREF: .xdata$x:00002F3Co
.text$mn:00001791                 push    0               ; Size
.text$mn:00001793                 push    1               ; char
.text$mn:00001795                 mov     ecx, [ebp-18h]
.text$mn:00001798                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000179D                 push    0
.text$mn:0000179F                 push    0
.text$mn:000017A1                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000017A1 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:000017A1
.text$mn:000017A6 ; ---------------------------------------------------------------------------
.text$mn:000017A6                 mov     eax, offset $LN17
.text$mn:000017AB                 retn
.text$mn:000017AC ; ---------------------------------------------------------------------------
.text$mn:000017AC ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000017AC
.text$mn:000017AC loc_17AC:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:000017AC                 mov     dword ptr [ebp-4], 1
.text$mn:000017B3                 jmp     short loc_17BC
.text$mn:000017B3 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000017B5
.text$mn:000017B5 ; =============== S U B R O U T I N E =======================================
.text$mn:000017B5
.text$mn:000017B5
.text$mn:000017B5 $LN17           proc near               ; DATA XREF: .text$mn:000017A6o
.text$mn:000017B5                 mov     dword ptr [ebp-4], 1
.text$mn:000017B5 $LN17           endp ; sp-analysis failed
.text$mn:000017B5
.text$mn:000017BC ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000017BC
.text$mn:000017BC loc_17BC:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:000017BC                 mov     eax, offset $LN19
.text$mn:000017C1                 retn
.text$mn:000017C1 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000017C2 ; ---------------------------------------------------------------------------
.text$mn:000017C2 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000017C2
.text$mn:000017C2 loc_17C2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:000017C2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000017C9                 jmp     short loc_17D2
.text$mn:000017C9 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000017CB
.text$mn:000017CB ; =============== S U B R O U T I N E =======================================
.text$mn:000017CB
.text$mn:000017CB
.text$mn:000017CB $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_17BCo
.text$mn:000017CB                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000017D2
.text$mn:000017D2 loc_17D2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:000017D2                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:000017D6                 jbe     short loc_17F1
.text$mn:000017D8                 mov     edx, [ebp+0Ch]
.text$mn:000017DB                 push    edx             ; Size
.text$mn:000017DC                 mov     ecx, [ebp-18h]
.text$mn:000017DF                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000017E4                 push    eax             ; Src
.text$mn:000017E5                 mov     eax, [ebp-20h]
.text$mn:000017E8                 push    eax             ; Dst
.text$mn:000017E9                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000017EE                 add     esp, 0Ch
.text$mn:000017F1
.text$mn:000017F1 loc_17F1:                               ; CODE XREF: $LN19+Bj
.text$mn:000017F1                 push    0               ; Size
.text$mn:000017F3                 push    1               ; char
.text$mn:000017F5                 mov     ecx, [ebp-18h]
.text$mn:000017F8                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000017FD                 lea     ecx, [ebp-20h]
.text$mn:00001800                 push    ecx             ; int
.text$mn:00001801                 mov     edx, [ebp-18h]
.text$mn:00001804                 add     edx, 4
.text$mn:00001807                 push    edx             ; void *
.text$mn:00001808                 lea     eax, [ebp-13h]
.text$mn:0000180B                 push    eax
.text$mn:0000180C                 mov     ecx, [ebp-18h]
.text$mn:0000180F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001814                 mov     ecx, eax
.text$mn:00001816                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:0000181B                 mov     ecx, [ebp-18h]
.text$mn:0000181E                 mov     edx, [ebp-1Ch]
.text$mn:00001821                 mov     [ecx+18h], edx
.text$mn:00001824                 mov     eax, [ebp+0Ch]
.text$mn:00001827                 push    eax
.text$mn:00001828                 mov     ecx, [ebp-18h]
.text$mn:0000182B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001830                 mov     ecx, [ebp-0Ch]
.text$mn:00001833                 mov     large fs:0, ecx
.text$mn:0000183A                 pop     ecx
.text$mn:0000183B                 pop     edi
.text$mn:0000183C                 pop     esi
.text$mn:0000183D                 pop     ebx
.text$mn:0000183E                 mov     esp, ebp
.text$mn:00001840                 pop     ebp
.text$mn:00001841                 retn    8
.text$mn:00001841 $LN19           endp ; sp-analysis failed
.text$mn:00001841
.text$mn:00001841 _text$mn        ends
.text$mn:00001841
.text$x:00001844 ; ===========================================================================
.text$x:00001844
.text$x:00001844 ; Segment type: Pure code
.text$x:00001844 ; Segment permissions: Read/Execute
.text$x:00001844 _text$x         segment para public 'CODE' use32
.text$x:00001844                 assume cs:_text$x
.text$x:00001844                 ;org 1844h
.text$x:00001844 ; COMDAT (pick associative to section at 16A0)
.text$x:00001844                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001844
.text$x:00001844 ; =============== S U B R O U T I N E =======================================
.text$x:00001844
.text$x:00001844
.text$x:00001844 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00001844                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00001844
.text$x:00001844 arg_4           = dword ptr  8
.text$x:00001844
.text$x:00001844                 mov     edx, [esp+arg_4]
.text$x:00001848                 lea     eax, [edx+0Ch]
.text$x:0000184B                 mov     ecx, [edx-24h]
.text$x:0000184E                 xor     ecx, eax
.text$x:00001850                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001855                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:0000185A                 jmp     ___CxxFrameHandler3
.text$x:0000185A __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:0000185A
.text$x:0000185A ; ---------------------------------------------------------------------------
.text$x:0000185F                 align 10h
.text$x:0000185F _text$x         ends
.text$x:0000185F
.text$mn:00001860 ; ===========================================================================
.text$mn:00001860
.text$mn:00001860 ; Segment type: Pure code
.text$mn:00001860 ; Segment permissions: Read/Execute
.text$mn:00001860 _text$mn        segment para public 'CODE' use32
.text$mn:00001860                 assume cs:_text$mn
.text$mn:00001860                 ;org 1860h
.text$mn:00001860 ; COMDAT (pick any)
.text$mn:00001860                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001860
.text$mn:00001860 ; =============== S U B R O U T I N E =======================================
.text$mn:00001860
.text$mn:00001860 ; Attributes: bp-based frame
.text$mn:00001860
.text$mn:00001860 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Copy(unsigned int, unsigned int)
.text$mn:00001860                 public ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00001860 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$mn:00001860                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+37p
.text$mn:00001860
.text$mn:00001860 var_20          = dword ptr -20h
.text$mn:00001860 var_1C          = dword ptr -1Ch
.text$mn:00001860 var_18          = dword ptr -18h
.text$mn:00001860 var_11          = byte ptr -11h
.text$mn:00001860 var_10          = dword ptr -10h
.text$mn:00001860 var_C           = byte ptr -0Ch
.text$mn:00001860 var_4           = dword ptr -4
.text$mn:00001860 arg_0           = dword ptr  8
.text$mn:00001860
.text$mn:00001860 ; FUNCTION CHUNK AT .text$mn:00001982 SIZE 00000009 BYTES
.text$mn:00001860
.text$mn:00001860                 push    ebp
.text$mn:00001861                 mov     ebp, esp
.text$mn:00001863                 push    0FFFFFFFFh
.text$mn:00001865                 push    offset __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:0000186A                 mov     eax, large fs:0
.text$mn:00001870                 push    eax
.text$mn:00001871                 push    ecx
.text$mn:00001872                 sub     esp, 10h
.text$mn:00001875                 push    ebx
.text$mn:00001876                 push    esi
.text$mn:00001877                 push    edi
.text$mn:00001878                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000187D                 xor     eax, ebp
.text$mn:0000187F                 push    eax
.text$mn:00001880                 lea     eax, [ebp+var_C]
.text$mn:00001883                 mov     large fs:0, eax
.text$mn:00001889                 mov     [ebp+var_10], esp
.text$mn:0000188C                 mov     [ebp+var_18], ecx
.text$mn:0000188F                 mov     eax, [ebp+arg_0]
.text$mn:00001892                 or      eax, 7
.text$mn:00001895                 mov     [ebp+var_1C], eax
.text$mn:00001898                 mov     ecx, [ebp+var_18]
.text$mn:0000189B                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:000018A0                 cmp     eax, [ebp+var_1C]
.text$mn:000018A3                 jnb     short loc_18AD
.text$mn:000018A5                 mov     ecx, [ebp+arg_0]
.text$mn:000018A8                 mov     [ebp+var_1C], ecx
.text$mn:000018AB                 jmp     short loc_18FF
.text$mn:000018AD ; ---------------------------------------------------------------------------
.text$mn:000018AD
.text$mn:000018AD loc_18AD:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+43j
.text$mn:000018AD                 mov     edx, [ebp+var_18]
.text$mn:000018B0                 mov     ecx, [edx+18h]
.text$mn:000018B3                 shr     ecx, 1
.text$mn:000018B5                 mov     eax, [ebp+var_1C]
.text$mn:000018B8                 xor     edx, edx
.text$mn:000018BA                 mov     esi, 3
.text$mn:000018BF                 div     esi
.text$mn:000018C1                 cmp     ecx, eax
.text$mn:000018C3                 ja      short loc_18C7
.text$mn:000018C5                 jmp     short loc_18FF
.text$mn:000018C7 ; ---------------------------------------------------------------------------
.text$mn:000018C7
.text$mn:000018C7 loc_18C7:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+63j
.text$mn:000018C7                 mov     ecx, [ebp+var_18]
.text$mn:000018CA                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:000018CF                 mov     edx, [ebp+var_18]
.text$mn:000018D2                 mov     ecx, [edx+18h]
.text$mn:000018D5                 shr     ecx, 1
.text$mn:000018D7                 sub     eax, ecx
.text$mn:000018D9                 mov     edx, [ebp+var_18]
.text$mn:000018DC                 cmp     [edx+18h], eax
.text$mn:000018DF                 ja      short loc_18F4
.text$mn:000018E1                 mov     eax, [ebp+var_18]
.text$mn:000018E4                 mov     ecx, [eax+18h]
.text$mn:000018E7                 shr     ecx, 1
.text$mn:000018E9                 mov     edx, [ebp+var_18]
.text$mn:000018EC                 add     ecx, [edx+18h]
.text$mn:000018EF                 mov     [ebp+var_1C], ecx
.text$mn:000018F2                 jmp     short loc_18FF
.text$mn:000018F4 ; ---------------------------------------------------------------------------
.text$mn:000018F4
.text$mn:000018F4 loc_18F4:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+7Fj
.text$mn:000018F4                 mov     ecx, [ebp+var_18]
.text$mn:000018F7                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:000018FC                 mov     [ebp+var_1C], eax
.text$mn:000018FF
.text$mn:000018FF loc_18FF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+4Bj
.text$mn:000018FF                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+65j ...
.text$mn:000018FF                 mov     [ebp+var_4], 0
.text$mn:00001906                 mov     eax, [ebp+var_1C]
.text$mn:00001909                 add     eax, 1
.text$mn:0000190C                 push    eax
.text$mn:0000190D                 lea     ecx, [ebp+var_11]
.text$mn:00001910                 push    ecx
.text$mn:00001911                 mov     ecx, [ebp+var_18]
.text$mn:00001914                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00001919                 mov     ecx, eax
.text$mn:0000191B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00001920                 mov     [ebp+var_20], eax
.text$mn:00001923                 jmp     short loc_1982
.text$mn:00001923 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$mn:00001923
.text$mn:00001925
.text$mn:00001925 ; =============== S U B R O U T I N E =======================================
.text$mn:00001925
.text$mn:00001925
.text$mn:00001925 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 proc near
.text$mn:00001925                                         ; DATA XREF: .xdata$x:00003144o
.text$mn:00001925
.text$mn:00001925 ; FUNCTION CHUNK AT .text$mn:0000196C SIZE 00000009 BYTES
.text$mn:00001925 ; FUNCTION CHUNK AT .text$mn:0000197C SIZE 00000006 BYTES
.text$mn:00001925
.text$mn:00001925                 mov     [ebp-10h], esp
.text$mn:00001928                 mov     edx, [ebp+8]
.text$mn:0000192B                 mov     [ebp-1Ch], edx
.text$mn:0000192E                 mov     byte ptr [ebp-4], 2
.text$mn:00001932                 mov     eax, [ebp-1Ch]
.text$mn:00001935                 add     eax, 1
.text$mn:00001938                 push    eax
.text$mn:00001939                 lea     ecx, [ebp-12h]
.text$mn:0000193C                 push    ecx
.text$mn:0000193D                 mov     ecx, [ebp-18h]
.text$mn:00001940                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00001945                 mov     ecx, eax
.text$mn:00001947                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:0000194C                 mov     [ebp-20h], eax
.text$mn:0000194F                 jmp     short loc_196C
.text$mn:0000194F __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 endp
.text$mn:0000194F
.text$mn:00001951
.text$mn:00001951 ; =============== S U B R O U T I N E =======================================
.text$mn:00001951
.text$mn:00001951 ; Attributes: noreturn
.text$mn:00001951
.text$mn:00001951 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 proc near
.text$mn:00001951                                         ; DATA XREF: .xdata$x:00003154o
.text$mn:00001951                 push    0
.text$mn:00001953                 push    1
.text$mn:00001955                 mov     ecx, [ebp-18h]
.text$mn:00001958                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000195D                 push    0
.text$mn:0000195F                 push    0
.text$mn:00001961                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00001961 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 endp
.text$mn:00001961
.text$mn:00001966 ; ---------------------------------------------------------------------------
.text$mn:00001966                 mov     eax, offset $LN17_0
.text$mn:0000196B                 retn
.text$mn:0000196C ; ---------------------------------------------------------------------------
.text$mn:0000196C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:0000196C
.text$mn:0000196C loc_196C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+2Aj
.text$mn:0000196C                 mov     dword ptr [ebp-4], 1
.text$mn:00001973                 jmp     short loc_197C
.text$mn:00001973 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00001975
.text$mn:00001975 ; =============== S U B R O U T I N E =======================================
.text$mn:00001975
.text$mn:00001975
.text$mn:00001975 $LN17_0         proc near               ; DATA XREF: .text$mn:00001966o
.text$mn:00001975                 mov     dword ptr [ebp-4], 1
.text$mn:00001975 $LN17_0         endp ; sp-analysis failed
.text$mn:00001975
.text$mn:0000197C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:0000197C
.text$mn:0000197C loc_197C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+4Ej
.text$mn:0000197C                 mov     eax, offset $LN19_0
.text$mn:00001981                 retn
.text$mn:00001981 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00001982 ; ---------------------------------------------------------------------------
.text$mn:00001982 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00001982
.text$mn:00001982 loc_1982:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+C3j
.text$mn:00001982                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001989                 jmp     short loc_1992
.text$mn:00001989 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:0000198B
.text$mn:0000198B ; =============== S U B R O U T I N E =======================================
.text$mn:0000198B
.text$mn:0000198B
.text$mn:0000198B $LN19_0         proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:loc_197Co
.text$mn:0000198B                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00001992
.text$mn:00001992 loc_1992:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+129j
.text$mn:00001992                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00001996                 jbe     short loc_19B1
.text$mn:00001998                 mov     edx, [ebp+0Ch]
.text$mn:0000199B                 push    edx             ; int
.text$mn:0000199C                 mov     ecx, [ebp-18h]
.text$mn:0000199F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000019A4                 push    eax             ; Src
.text$mn:000019A5                 mov     eax, [ebp-20h]
.text$mn:000019A8                 push    eax             ; Dst
.text$mn:000019A9                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:000019AE                 add     esp, 0Ch
.text$mn:000019B1
.text$mn:000019B1 loc_19B1:                               ; CODE XREF: $LN19_0+Bj
.text$mn:000019B1                 push    0
.text$mn:000019B3                 push    1
.text$mn:000019B5                 mov     ecx, [ebp-18h]
.text$mn:000019B8                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000019BD                 lea     ecx, [ebp-20h]
.text$mn:000019C0                 push    ecx             ; int
.text$mn:000019C1                 mov     edx, [ebp-18h]
.text$mn:000019C4                 add     edx, 4
.text$mn:000019C7                 push    edx             ; void *
.text$mn:000019C8                 lea     eax, [ebp-13h]
.text$mn:000019CB                 push    eax
.text$mn:000019CC                 mov     ecx, [ebp-18h]
.text$mn:000019CF                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000019D4                 mov     ecx, eax
.text$mn:000019D6                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:000019DB                 mov     ecx, [ebp-18h]
.text$mn:000019DE                 mov     edx, [ebp-1Ch]
.text$mn:000019E1                 mov     [ecx+18h], edx
.text$mn:000019E4                 mov     eax, [ebp+0Ch]
.text$mn:000019E7                 push    eax
.text$mn:000019E8                 mov     ecx, [ebp-18h]
.text$mn:000019EB                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000019F0                 mov     ecx, [ebp-0Ch]
.text$mn:000019F3                 mov     large fs:0, ecx
.text$mn:000019FA                 pop     ecx
.text$mn:000019FB                 pop     edi
.text$mn:000019FC                 pop     esi
.text$mn:000019FD                 pop     ebx
.text$mn:000019FE                 mov     esp, ebp
.text$mn:00001A00                 pop     ebp
.text$mn:00001A01                 retn    8
.text$mn:00001A01 $LN19_0         endp ; sp-analysis failed
.text$mn:00001A01
.text$mn:00001A01 _text$mn        ends
.text$mn:00001A01
.text$x:00001A04 ; ===========================================================================
.text$x:00001A04
.text$x:00001A04 ; Segment type: Pure code
.text$x:00001A04 ; Segment permissions: Read/Execute
.text$x:00001A04 _text$x         segment para public 'CODE' use32
.text$x:00001A04                 assume cs:_text$x
.text$x:00001A04                 ;org 1A04h
.text$x:00001A04 ; COMDAT (pick associative to section at 1860)
.text$x:00001A04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001A04
.text$x:00001A04 ; =============== S U B R O U T I N E =======================================
.text$x:00001A04
.text$x:00001A04
.text$x:00001A04 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$x:00001A04                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+5o
.text$x:00001A04
.text$x:00001A04 arg_4           = dword ptr  8
.text$x:00001A04
.text$x:00001A04                 mov     edx, [esp+arg_4]
.text$x:00001A08                 lea     eax, [edx+0Ch]
.text$x:00001A0B                 mov     ecx, [edx-24h]
.text$x:00001A0E                 xor     ecx, eax
.text$x:00001A10                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001A15                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$x:00001A1A                 jmp     ___CxxFrameHandler3
.text$x:00001A1A __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$x:00001A1A
.text$x:00001A1A ; ---------------------------------------------------------------------------
.text$x:00001A1F                 align 10h
.text$x:00001A1F _text$x         ends
.text$x:00001A1F
.text$mn:00001A20 ; ===========================================================================
.text$mn:00001A20
.text$mn:00001A20 ; Segment type: Pure code
.text$mn:00001A20 ; Segment permissions: Read/Execute
.text$mn:00001A20 _text$mn        segment para public 'CODE' use32
.text$mn:00001A20                 assume cs:_text$mn
.text$mn:00001A20                 ;org 1A20h
.text$mn:00001A20 ; COMDAT (pick any)
.text$mn:00001A20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A20
.text$mn:00001A20 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A20
.text$mn:00001A20 ; Attributes: bp-based frame
.text$mn:00001A20
.text$mn:00001A20 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00001A20                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00001A20 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00001A20                                         ; CODE XREF: $LN19+60p
.text$mn:00001A20                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00001A20
.text$mn:00001A20 var_8           = dword ptr -8
.text$mn:00001A20 var_1           = byte ptr -1
.text$mn:00001A20 arg_0           = dword ptr  8
.text$mn:00001A20
.text$mn:00001A20                 push    ebp
.text$mn:00001A21                 mov     ebp, esp
.text$mn:00001A23                 sub     esp, 8
.text$mn:00001A26                 mov     [ebp+var_8], ecx
.text$mn:00001A29                 mov     [ebp+var_1], 0
.text$mn:00001A2D                 mov     eax, [ebp+var_8]
.text$mn:00001A30                 mov     ecx, [ebp+arg_0]
.text$mn:00001A33                 mov     [eax+14h], ecx
.text$mn:00001A36                 lea     edx, [ebp+var_1]
.text$mn:00001A39                 push    edx
.text$mn:00001A3A                 mov     ecx, [ebp+var_8]
.text$mn:00001A3D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001A42                 add     eax, [ebp+arg_0]
.text$mn:00001A45                 push    eax
.text$mn:00001A46                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00001A4B                 add     esp, 8
.text$mn:00001A4E                 mov     esp, ebp
.text$mn:00001A50                 pop     ebp
.text$mn:00001A51                 retn    4
.text$mn:00001A51 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00001A51
.text$mn:00001A51 _text$mn        ends
.text$mn:00001A51
.text$mn:00001A54 ; ===========================================================================
.text$mn:00001A54
.text$mn:00001A54 ; Segment type: Pure code
.text$mn:00001A54 ; Segment permissions: Read/Execute
.text$mn:00001A54 _text$mn        segment para public 'CODE' use32
.text$mn:00001A54                 assume cs:_text$mn
.text$mn:00001A54                 ;org 1A54h
.text$mn:00001A54 ; COMDAT (pick any)
.text$mn:00001A54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A54
.text$mn:00001A54 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A54
.text$mn:00001A54 ; Attributes: bp-based frame
.text$mn:00001A54
.text$mn:00001A54 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Eos(unsigned int)
.text$mn:00001A54                 public ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:00001A54 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:00001A54                                         ; CODE XREF: $LN19_0+60p
.text$mn:00001A54                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+83p ...
.text$mn:00001A54
.text$mn:00001A54 var_8           = dword ptr -8
.text$mn:00001A54 var_2           = word ptr -2
.text$mn:00001A54 arg_0           = dword ptr  8
.text$mn:00001A54
.text$mn:00001A54                 push    ebp
.text$mn:00001A55                 mov     ebp, esp
.text$mn:00001A57                 sub     esp, 8
.text$mn:00001A5A                 mov     [ebp+var_8], ecx
.text$mn:00001A5D                 xor     eax, eax
.text$mn:00001A5F                 mov     [ebp+var_2], ax
.text$mn:00001A63                 mov     ecx, [ebp+var_8]
.text$mn:00001A66                 mov     edx, [ebp+arg_0]
.text$mn:00001A69                 mov     [ecx+14h], edx
.text$mn:00001A6C                 lea     eax, [ebp+var_2]
.text$mn:00001A6F                 push    eax
.text$mn:00001A70                 mov     ecx, [ebp+var_8]
.text$mn:00001A73                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001A78                 mov     ecx, [ebp+arg_0]
.text$mn:00001A7B                 lea     edx, [eax+ecx*2]
.text$mn:00001A7E                 push    edx
.text$mn:00001A7F                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:00001A84                 add     esp, 8
.text$mn:00001A87                 mov     esp, ebp
.text$mn:00001A89                 pop     ebp
.text$mn:00001A8A                 retn    4
.text$mn:00001A8A ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:00001A8A
.text$mn:00001A8A ; ---------------------------------------------------------------------------
.text$mn:00001A8D                 align 10h
.text$mn:00001A8D _text$mn        ends
.text$mn:00001A8D
.text$mn:00001A90 ; ===========================================================================
.text$mn:00001A90
.text$mn:00001A90 ; Segment type: Pure code
.text$mn:00001A90 ; Segment permissions: Read/Execute
.text$mn:00001A90 _text$mn        segment para public 'CODE' use32
.text$mn:00001A90                 assume cs:_text$mn
.text$mn:00001A90                 ;org 1A90h
.text$mn:00001A90 ; COMDAT (pick any)
.text$mn:00001A90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A90
.text$mn:00001A90 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A90
.text$mn:00001A90 ; Attributes: bp-based frame
.text$mn:00001A90
.text$mn:00001A90 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00001A90                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00001A90 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001A90                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00001A90
.text$mn:00001A90 var_8           = dword ptr -8
.text$mn:00001A90 var_1           = byte ptr -1
.text$mn:00001A90
.text$mn:00001A90                 push    ebp
.text$mn:00001A91                 mov     ebp, esp
.text$mn:00001A93                 sub     esp, 8
.text$mn:00001A96                 mov     [ebp+var_8], ecx
.text$mn:00001A99                 lea     ecx, [ebp+var_1]
.text$mn:00001A9C                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001AA1                 mov     ecx, [ebp+var_8] ; this
.text$mn:00001AA4                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00001AA9                 mov     eax, [ebp+var_8]
.text$mn:00001AAC                 mov     ecx, [eax]
.text$mn:00001AAE                 push    ecx
.text$mn:00001AAF                 lea     ecx, [ebp+var_1]
.text$mn:00001AB2                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00001AB7                 push    1               ; int
.text$mn:00001AB9                 mov     edx, [ebp+var_8]
.text$mn:00001ABC                 mov     eax, [edx]
.text$mn:00001ABE                 push    eax             ; void *
.text$mn:00001ABF                 lea     ecx, [ebp+var_1]
.text$mn:00001AC2                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00001AC7                 mov     ecx, [ebp+var_8]
.text$mn:00001ACA                 mov     dword ptr [ecx], 0
.text$mn:00001AD0                 mov     esp, ebp
.text$mn:00001AD2                 pop     ebp
.text$mn:00001AD3                 retn
.text$mn:00001AD3 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001AD3
.text$mn:00001AD3 _text$mn        ends
.text$mn:00001AD3
.text$mn:00001AD4 ; ===========================================================================
.text$mn:00001AD4
.text$mn:00001AD4 ; Segment type: Pure code
.text$mn:00001AD4 ; Segment permissions: Read/Execute
.text$mn:00001AD4 _text$mn        segment para public 'CODE' use32
.text$mn:00001AD4                 assume cs:_text$mn
.text$mn:00001AD4                 ;org 1AD4h
.text$mn:00001AD4 ; COMDAT (pick any)
.text$mn:00001AD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001AD4
.text$mn:00001AD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AD4
.text$mn:00001AD4 ; Attributes: bp-based frame
.text$mn:00001AD4
.text$mn:00001AD4 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00001AD4                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00001AD4 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00001AD4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00001AD4                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00001AD4
.text$mn:00001AD4 var_4           = dword ptr -4
.text$mn:00001AD4 arg_0           = dword ptr  8
.text$mn:00001AD4
.text$mn:00001AD4                 push    ebp
.text$mn:00001AD5                 mov     ebp, esp
.text$mn:00001AD7                 push    ecx
.text$mn:00001AD8                 mov     [ebp+var_4], ecx
.text$mn:00001ADB                 mov     ecx, [ebp+arg_0]
.text$mn:00001ADE                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00001AE3                 mov     eax, [ebp+arg_0]
.text$mn:00001AE6                 mov     esp, ebp
.text$mn:00001AE8                 pop     ebp
.text$mn:00001AE9                 retn    4
.text$mn:00001AE9 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00001AE9
.text$mn:00001AE9 _text$mn        ends
.text$mn:00001AE9
.text$mn:00001AEC ; ===========================================================================
.text$mn:00001AEC
.text$mn:00001AEC ; Segment type: Pure code
.text$mn:00001AEC ; Segment permissions: Read/Execute
.text$mn:00001AEC _text$mn        segment para public 'CODE' use32
.text$mn:00001AEC                 assume cs:_text$mn
.text$mn:00001AEC                 ;org 1AECh
.text$mn:00001AEC ; COMDAT (pick any)
.text$mn:00001AEC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001AEC
.text$mn:00001AEC ; =============== S U B R O U T I N E =======================================
.text$mn:00001AEC
.text$mn:00001AEC ; Attributes: bp-based frame
.text$mn:00001AEC
.text$mn:00001AEC ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:00001AEC                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:00001AEC ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:00001AEC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+B4p
.text$mn:00001AEC                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00001AEC
.text$mn:00001AEC var_4           = dword ptr -4
.text$mn:00001AEC arg_0           = dword ptr  8
.text$mn:00001AEC
.text$mn:00001AEC                 push    ebp
.text$mn:00001AED                 mov     ebp, esp
.text$mn:00001AEF                 push    ecx
.text$mn:00001AF0                 mov     [ebp+var_4], ecx
.text$mn:00001AF3                 mov     ecx, [ebp+arg_0]
.text$mn:00001AF6                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:00001AFB                 mov     eax, [ebp+arg_0]
.text$mn:00001AFE                 mov     esp, ebp
.text$mn:00001B00                 pop     ebp
.text$mn:00001B01                 retn    4
.text$mn:00001B01 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:00001B01
.text$mn:00001B01 _text$mn        ends
.text$mn:00001B01
.text$mn:00001B04 ; ===========================================================================
.text$mn:00001B04
.text$mn:00001B04 ; Segment type: Pure code
.text$mn:00001B04 ; Segment permissions: Read/Execute
.text$mn:00001B04 _text$mn        segment para public 'CODE' use32
.text$mn:00001B04                 assume cs:_text$mn
.text$mn:00001B04                 ;org 1B04h
.text$mn:00001B04 ; COMDAT (pick any)
.text$mn:00001B04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B04
.text$mn:00001B04 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B04
.text$mn:00001B04 ; Attributes: bp-based frame
.text$mn:00001B04
.text$mn:00001B04 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00001B04                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00001B04 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00001B04                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00001B04                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00001B04
.text$mn:00001B04 var_C           = dword ptr -0Ch
.text$mn:00001B04 Size            = dword ptr -8
.text$mn:00001B04 var_4           = dword ptr -4
.text$mn:00001B04 arg_0           = dword ptr  8
.text$mn:00001B04 arg_4           = byte ptr  0Ch
.text$mn:00001B04
.text$mn:00001B04                 push    ebp
.text$mn:00001B05                 mov     ebp, esp
.text$mn:00001B07                 sub     esp, 0Ch
.text$mn:00001B0A                 mov     [ebp+var_4], ecx
.text$mn:00001B0D                 mov     ecx, [ebp+var_4]
.text$mn:00001B10                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001B15                 cmp     eax, [ebp+arg_0]
.text$mn:00001B18                 jnb     short loc_1B22
.text$mn:00001B1A                 mov     ecx, [ebp+var_4]
.text$mn:00001B1D                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00001B22
.text$mn:00001B22 loc_1B22:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00001B22                 mov     eax, [ebp+var_4]
.text$mn:00001B25                 mov     ecx, [eax+18h]
.text$mn:00001B28                 cmp     ecx, [ebp+arg_0]
.text$mn:00001B2B                 jnb     short loc_1B42
.text$mn:00001B2D                 mov     edx, [ebp+var_4]
.text$mn:00001B30                 mov     eax, [edx+14h]
.text$mn:00001B33                 push    eax
.text$mn:00001B34                 mov     ecx, [ebp+arg_0]
.text$mn:00001B37                 push    ecx
.text$mn:00001B38                 mov     ecx, [ebp+var_4]
.text$mn:00001B3B                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00001B40                 jmp     short loc_1B8C
.text$mn:00001B42 ; ---------------------------------------------------------------------------
.text$mn:00001B42
.text$mn:00001B42 loc_1B42:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00001B42                 movzx   edx, [ebp+arg_4]
.text$mn:00001B46                 test    edx, edx
.text$mn:00001B48                 jz      short loc_1B7C
.text$mn:00001B4A                 cmp     [ebp+arg_0], 10h
.text$mn:00001B4E                 jnb     short loc_1B7C
.text$mn:00001B50                 mov     eax, [ebp+var_4]
.text$mn:00001B53                 mov     ecx, [ebp+arg_0]
.text$mn:00001B56                 cmp     ecx, [eax+14h]
.text$mn:00001B59                 jnb     short loc_1B63
.text$mn:00001B5B                 mov     edx, [ebp+arg_0]
.text$mn:00001B5E                 mov     [ebp+Size], edx
.text$mn:00001B61                 jmp     short loc_1B6C
.text$mn:00001B63 ; ---------------------------------------------------------------------------
.text$mn:00001B63
.text$mn:00001B63 loc_1B63:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00001B63                 mov     eax, [ebp+var_4]
.text$mn:00001B66                 mov     ecx, [eax+14h]
.text$mn:00001B69                 mov     [ebp+Size], ecx
.text$mn:00001B6C
.text$mn:00001B6C loc_1B6C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00001B6C                 mov     edx, [ebp+Size]
.text$mn:00001B6F                 push    edx             ; Size
.text$mn:00001B70                 push    1               ; char
.text$mn:00001B72                 mov     ecx, [ebp+var_4]
.text$mn:00001B75                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001B7A                 jmp     short loc_1B8C
.text$mn:00001B7C ; ---------------------------------------------------------------------------
.text$mn:00001B7C
.text$mn:00001B7C loc_1B7C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00001B7C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00001B7C                 cmp     [ebp+arg_0], 0
.text$mn:00001B80                 jnz     short loc_1B8C
.text$mn:00001B82                 push    0
.text$mn:00001B84                 mov     ecx, [ebp+var_4]
.text$mn:00001B87                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001B8C
.text$mn:00001B8C loc_1B8C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00001B8C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00001B8C                 cmp     [ebp+arg_0], 0
.text$mn:00001B90                 jbe     short loc_1B9B
.text$mn:00001B92                 mov     [ebp+var_C], 1
.text$mn:00001B99                 jmp     short loc_1BA2
.text$mn:00001B9B ; ---------------------------------------------------------------------------
.text$mn:00001B9B
.text$mn:00001B9B loc_1B9B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00001B9B                 mov     [ebp+var_C], 0
.text$mn:00001BA2
.text$mn:00001BA2 loc_1BA2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00001BA2                 mov     al, byte ptr [ebp+var_C]
.text$mn:00001BA5                 mov     esp, ebp
.text$mn:00001BA7                 pop     ebp
.text$mn:00001BA8                 retn    8
.text$mn:00001BA8 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00001BA8
.text$mn:00001BA8 ; ---------------------------------------------------------------------------
.text$mn:00001BAB                 align 4
.text$mn:00001BAB _text$mn        ends
.text$mn:00001BAB
.text$mn:00001BAC ; ===========================================================================
.text$mn:00001BAC
.text$mn:00001BAC ; Segment type: Pure code
.text$mn:00001BAC ; Segment permissions: Read/Execute
.text$mn:00001BAC _text$mn        segment para public 'CODE' use32
.text$mn:00001BAC                 assume cs:_text$mn
.text$mn:00001BAC                 ;org 1BACh
.text$mn:00001BAC ; COMDAT (pick any)
.text$mn:00001BAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001BAC
.text$mn:00001BAC ; =============== S U B R O U T I N E =======================================
.text$mn:00001BAC
.text$mn:00001BAC ; Attributes: bp-based frame
.text$mn:00001BAC
.text$mn:00001BAC ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Grow(unsigned int, bool)
.text$mn:00001BAC                 public ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
.text$mn:00001BAC ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z proc near
.text$mn:00001BAC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+6Ap
.text$mn:00001BAC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+61p
.text$mn:00001BAC
.text$mn:00001BAC var_C           = dword ptr -0Ch
.text$mn:00001BAC var_8           = dword ptr -8
.text$mn:00001BAC var_4           = dword ptr -4
.text$mn:00001BAC arg_0           = dword ptr  8
.text$mn:00001BAC arg_4           = byte ptr  0Ch
.text$mn:00001BAC
.text$mn:00001BAC                 push    ebp
.text$mn:00001BAD                 mov     ebp, esp
.text$mn:00001BAF                 sub     esp, 0Ch
.text$mn:00001BB2                 mov     [ebp+var_4], ecx
.text$mn:00001BB5                 mov     ecx, [ebp+var_4]
.text$mn:00001BB8                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00001BBD                 cmp     eax, [ebp+arg_0]
.text$mn:00001BC0                 jnb     short loc_1BCA
.text$mn:00001BC2                 mov     ecx, [ebp+var_4]
.text$mn:00001BC5                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:00001BCA
.text$mn:00001BCA loc_1BCA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+14j
.text$mn:00001BCA                 mov     eax, [ebp+var_4]
.text$mn:00001BCD                 mov     ecx, [eax+18h]
.text$mn:00001BD0                 cmp     ecx, [ebp+arg_0]
.text$mn:00001BD3                 jnb     short loc_1BEA
.text$mn:00001BD5                 mov     edx, [ebp+var_4]
.text$mn:00001BD8                 mov     eax, [edx+14h]
.text$mn:00001BDB                 push    eax
.text$mn:00001BDC                 mov     ecx, [ebp+arg_0]
.text$mn:00001BDF                 push    ecx
.text$mn:00001BE0                 mov     ecx, [ebp+var_4]
.text$mn:00001BE3                 call    ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)
.text$mn:00001BE8                 jmp     short loc_1C34
.text$mn:00001BEA ; ---------------------------------------------------------------------------
.text$mn:00001BEA
.text$mn:00001BEA loc_1BEA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+27j
.text$mn:00001BEA                 movzx   edx, [ebp+arg_4]
.text$mn:00001BEE                 test    edx, edx
.text$mn:00001BF0                 jz      short loc_1C24
.text$mn:00001BF2                 cmp     [ebp+arg_0], 8
.text$mn:00001BF6                 jnb     short loc_1C24
.text$mn:00001BF8                 mov     eax, [ebp+var_4]
.text$mn:00001BFB                 mov     ecx, [ebp+arg_0]
.text$mn:00001BFE                 cmp     ecx, [eax+14h]
.text$mn:00001C01                 jnb     short loc_1C0B
.text$mn:00001C03                 mov     edx, [ebp+arg_0]
.text$mn:00001C06                 mov     [ebp+var_8], edx
.text$mn:00001C09                 jmp     short loc_1C14
.text$mn:00001C0B ; ---------------------------------------------------------------------------
.text$mn:00001C0B
.text$mn:00001C0B loc_1C0B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+55j
.text$mn:00001C0B                 mov     eax, [ebp+var_4]
.text$mn:00001C0E                 mov     ecx, [eax+14h]
.text$mn:00001C11                 mov     [ebp+var_8], ecx
.text$mn:00001C14
.text$mn:00001C14 loc_1C14:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+5Dj
.text$mn:00001C14                 mov     edx, [ebp+var_8]
.text$mn:00001C17                 push    edx
.text$mn:00001C18                 push    1
.text$mn:00001C1A                 mov     ecx, [ebp+var_4]
.text$mn:00001C1D                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00001C22                 jmp     short loc_1C34
.text$mn:00001C24 ; ---------------------------------------------------------------------------
.text$mn:00001C24
.text$mn:00001C24 loc_1C24:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+44j
.text$mn:00001C24                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+4Aj
.text$mn:00001C24                 cmp     [ebp+arg_0], 0
.text$mn:00001C28                 jnz     short loc_1C34
.text$mn:00001C2A                 push    0
.text$mn:00001C2C                 mov     ecx, [ebp+var_4]
.text$mn:00001C2F                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00001C34
.text$mn:00001C34 loc_1C34:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+3Cj
.text$mn:00001C34                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+76j ...
.text$mn:00001C34                 cmp     [ebp+arg_0], 0
.text$mn:00001C38                 jbe     short loc_1C43
.text$mn:00001C3A                 mov     [ebp+var_C], 1
.text$mn:00001C41                 jmp     short loc_1C4A
.text$mn:00001C43 ; ---------------------------------------------------------------------------
.text$mn:00001C43
.text$mn:00001C43 loc_1C43:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+8Cj
.text$mn:00001C43                 mov     [ebp+var_C], 0
.text$mn:00001C4A
.text$mn:00001C4A loc_1C4A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+95j
.text$mn:00001C4A                 mov     al, byte ptr [ebp+var_C]
.text$mn:00001C4D                 mov     esp, ebp
.text$mn:00001C4F                 pop     ebp
.text$mn:00001C50                 retn    8
.text$mn:00001C50 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z endp
.text$mn:00001C50
.text$mn:00001C50 ; ---------------------------------------------------------------------------
.text$mn:00001C53                 align 4
.text$mn:00001C53 _text$mn        ends
.text$mn:00001C53
.text$mn:00001C54 ; ===========================================================================
.text$mn:00001C54
.text$mn:00001C54 ; Segment type: Pure code
.text$mn:00001C54 ; Segment permissions: Read/Execute
.text$mn:00001C54 _text$mn        segment para public 'CODE' use32
.text$mn:00001C54                 assume cs:_text$mn
.text$mn:00001C54                 ;org 1C54h
.text$mn:00001C54 ; COMDAT (pick any)
.text$mn:00001C54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001C54
.text$mn:00001C54 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C54
.text$mn:00001C54 ; Attributes: bp-based frame
.text$mn:00001C54
.text$mn:00001C54 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00001C54                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00001C54 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00001C54                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00001C54
.text$mn:00001C54 var_4           = dword ptr -4
.text$mn:00001C54 arg_0           = dword ptr  8
.text$mn:00001C54
.text$mn:00001C54                 push    ebp
.text$mn:00001C55                 mov     ebp, esp
.text$mn:00001C57                 push    ecx
.text$mn:00001C58                 mov     [ebp+var_4], ecx
.text$mn:00001C5B                 cmp     [ebp+arg_0], 0
.text$mn:00001C5F                 jz      short loc_1C81
.text$mn:00001C61                 mov     ecx, [ebp+var_4]
.text$mn:00001C64                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001C69                 cmp     [ebp+arg_0], eax
.text$mn:00001C6C                 jb      short loc_1C81
.text$mn:00001C6E                 mov     ecx, [ebp+var_4]
.text$mn:00001C71                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001C76                 mov     ecx, [ebp+var_4]
.text$mn:00001C79                 add     eax, [ecx+14h]
.text$mn:00001C7C                 cmp     eax, [ebp+arg_0]
.text$mn:00001C7F                 ja      short loc_1C87
.text$mn:00001C81
.text$mn:00001C81 loc_1C81:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00001C81                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00001C81                 xor     al, al
.text$mn:00001C83                 jmp     short loc_1C89
.text$mn:00001C85 ; ---------------------------------------------------------------------------
.text$mn:00001C85                 jmp     short loc_1C89
.text$mn:00001C87 ; ---------------------------------------------------------------------------
.text$mn:00001C87
.text$mn:00001C87 loc_1C87:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:00001C87                 mov     al, 1
.text$mn:00001C89
.text$mn:00001C89 loc_1C89:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00001C89                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00001C89                 mov     esp, ebp
.text$mn:00001C8B                 pop     ebp
.text$mn:00001C8C                 retn    4
.text$mn:00001C8C ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00001C8C
.text$mn:00001C8C ; ---------------------------------------------------------------------------
.text$mn:00001C8F                 align 10h
.text$mn:00001C8F _text$mn        ends
.text$mn:00001C8F
.text$mn:00001C90 ; ===========================================================================
.text$mn:00001C90
.text$mn:00001C90 ; Segment type: Pure code
.text$mn:00001C90 ; Segment permissions: Read/Execute
.text$mn:00001C90 _text$mn        segment para public 'CODE' use32
.text$mn:00001C90                 assume cs:_text$mn
.text$mn:00001C90                 ;org 1C90h
.text$mn:00001C90 ; COMDAT (pick any)
.text$mn:00001C90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001C90
.text$mn:00001C90 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C90
.text$mn:00001C90 ; Attributes: bp-based frame
.text$mn:00001C90
.text$mn:00001C90 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00001C90                 public ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
.text$mn:00001C90 ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z proc near
.text$mn:00001C90                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+2Ap
.text$mn:00001C90
.text$mn:00001C90 var_4           = dword ptr -4
.text$mn:00001C90 arg_0           = dword ptr  8
.text$mn:00001C90
.text$mn:00001C90                 push    ebp
.text$mn:00001C91                 mov     ebp, esp
.text$mn:00001C93                 push    ecx
.text$mn:00001C94                 mov     [ebp+var_4], ecx
.text$mn:00001C97                 cmp     [ebp+arg_0], 0
.text$mn:00001C9B                 jz      short loc_1CC0
.text$mn:00001C9D                 mov     ecx, [ebp+var_4]
.text$mn:00001CA0                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001CA5                 cmp     [ebp+arg_0], eax
.text$mn:00001CA8                 jb      short loc_1CC0
.text$mn:00001CAA                 mov     ecx, [ebp+var_4]
.text$mn:00001CAD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001CB2                 mov     ecx, [ebp+var_4]
.text$mn:00001CB5                 mov     edx, [ecx+14h]
.text$mn:00001CB8                 lea     eax, [eax+edx*2]
.text$mn:00001CBB                 cmp     eax, [ebp+arg_0]
.text$mn:00001CBE                 ja      short loc_1CC6
.text$mn:00001CC0
.text$mn:00001CC0 loc_1CC0:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+Bj
.text$mn:00001CC0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+18j
.text$mn:00001CC0                 xor     al, al
.text$mn:00001CC2                 jmp     short loc_1CC8
.text$mn:00001CC4 ; ---------------------------------------------------------------------------
.text$mn:00001CC4                 jmp     short loc_1CC8
.text$mn:00001CC6 ; ---------------------------------------------------------------------------
.text$mn:00001CC6
.text$mn:00001CC6 loc_1CC6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+2Ej
.text$mn:00001CC6                 mov     al, 1
.text$mn:00001CC8
.text$mn:00001CC8 loc_1CC8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+32j
.text$mn:00001CC8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+34j
.text$mn:00001CC8                 mov     esp, ebp
.text$mn:00001CCA                 pop     ebp
.text$mn:00001CCB                 retn    4
.text$mn:00001CCB ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z endp
.text$mn:00001CCB
.text$mn:00001CCB ; ---------------------------------------------------------------------------
.text$mn:00001CCE                 align 10h
.text$mn:00001CCE _text$mn        ends
.text$mn:00001CCE
.text$mn:00001CD0 ; ===========================================================================
.text$mn:00001CD0
.text$mn:00001CD0 ; Segment type: Pure code
.text$mn:00001CD0 ; Segment permissions: Read/Execute
.text$mn:00001CD0 _text$mn        segment para public 'CODE' use32
.text$mn:00001CD0                 assume cs:_text$mn
.text$mn:00001CD0                 ;org 1CD0h
.text$mn:00001CD0 ; COMDAT (pick any)
.text$mn:00001CD0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001CD0
.text$mn:00001CD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CD0
.text$mn:00001CD0 ; Attributes: bp-based frame
.text$mn:00001CD0
.text$mn:00001CD0 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001CD0                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00001CD0 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00001CD0                                         ; CODE XREF: $LN19+14p
.text$mn:00001CD0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00001CD0
.text$mn:00001CD0 var_8           = dword ptr -8
.text$mn:00001CD0 var_4           = dword ptr -4
.text$mn:00001CD0
.text$mn:00001CD0                 push    ebp
.text$mn:00001CD1                 mov     ebp, esp
.text$mn:00001CD3                 sub     esp, 8
.text$mn:00001CD6                 mov     [ebp+var_4], ecx
.text$mn:00001CD9                 mov     eax, [ebp+var_4]
.text$mn:00001CDC                 cmp     dword ptr [eax+18h], 10h
.text$mn:00001CE0                 jb      short loc_1CF6
.text$mn:00001CE2                 mov     ecx, [ebp+var_4]
.text$mn:00001CE5                 mov     edx, [ecx+4]
.text$mn:00001CE8                 push    edx
.text$mn:00001CE9                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001CEE                 add     esp, 4
.text$mn:00001CF1                 mov     [ebp+var_8], eax
.text$mn:00001CF4                 jmp     short loc_1CFF
.text$mn:00001CF6 ; ---------------------------------------------------------------------------
.text$mn:00001CF6
.text$mn:00001CF6 loc_1CF6:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00001CF6                 mov     eax, [ebp+var_4]
.text$mn:00001CF9                 add     eax, 4
.text$mn:00001CFC                 mov     [ebp+var_8], eax
.text$mn:00001CFF
.text$mn:00001CFF loc_1CFF:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00001CFF                 mov     eax, [ebp+var_8]
.text$mn:00001D02                 mov     esp, ebp
.text$mn:00001D04                 pop     ebp
.text$mn:00001D05                 retn
.text$mn:00001D05 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00001D05
.text$mn:00001D05 ; ---------------------------------------------------------------------------
.text$mn:00001D06                 align 4
.text$mn:00001D06 _text$mn        ends
.text$mn:00001D06
.text$mn:00001D08 ; ===========================================================================
.text$mn:00001D08
.text$mn:00001D08 ; Segment type: Pure code
.text$mn:00001D08 ; Segment permissions: Read/Execute
.text$mn:00001D08 _text$mn        segment para public 'CODE' use32
.text$mn:00001D08                 assume cs:_text$mn
.text$mn:00001D08                 ;org 1D08h
.text$mn:00001D08 ; COMDAT (pick any)
.text$mn:00001D08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D08
.text$mn:00001D08 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D08
.text$mn:00001D08 ; Attributes: bp-based frame
.text$mn:00001D08
.text$mn:00001D08 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00001D08                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00001D08 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00001D08                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00001D08
.text$mn:00001D08 var_8           = dword ptr -8
.text$mn:00001D08 var_4           = dword ptr -4
.text$mn:00001D08
.text$mn:00001D08                 push    ebp
.text$mn:00001D09                 mov     ebp, esp
.text$mn:00001D0B                 sub     esp, 8
.text$mn:00001D0E                 mov     [ebp+var_4], ecx
.text$mn:00001D11                 mov     eax, [ebp+var_4]
.text$mn:00001D14                 cmp     dword ptr [eax+18h], 10h
.text$mn:00001D18                 jb      short loc_1D2E
.text$mn:00001D1A                 mov     ecx, [ebp+var_4]
.text$mn:00001D1D                 mov     edx, [ecx+4]
.text$mn:00001D20                 push    edx
.text$mn:00001D21                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001D26                 add     esp, 4
.text$mn:00001D29                 mov     [ebp+var_8], eax
.text$mn:00001D2C                 jmp     short loc_1D37
.text$mn:00001D2E ; ---------------------------------------------------------------------------
.text$mn:00001D2E
.text$mn:00001D2E loc_1D2E:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00001D2E                 mov     eax, [ebp+var_4]
.text$mn:00001D31                 add     eax, 4
.text$mn:00001D34                 mov     [ebp+var_8], eax
.text$mn:00001D37
.text$mn:00001D37 loc_1D37:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00001D37                 mov     eax, [ebp+var_8]
.text$mn:00001D3A                 mov     esp, ebp
.text$mn:00001D3C                 pop     ebp
.text$mn:00001D3D                 retn
.text$mn:00001D3D ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00001D3D
.text$mn:00001D3D ; ---------------------------------------------------------------------------
.text$mn:00001D3E                 align 10h
.text$mn:00001D3E _text$mn        ends
.text$mn:00001D3E
.text$mn:00001D40 ; ===========================================================================
.text$mn:00001D40
.text$mn:00001D40 ; Segment type: Pure code
.text$mn:00001D40 ; Segment permissions: Read/Execute
.text$mn:00001D40 _text$mn        segment para public 'CODE' use32
.text$mn:00001D40                 assume cs:_text$mn
.text$mn:00001D40                 ;org 1D40h
.text$mn:00001D40 ; COMDAT (pick any)
.text$mn:00001D40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D40
.text$mn:00001D40 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D40
.text$mn:00001D40 ; Attributes: bp-based frame
.text$mn:00001D40
.text$mn:00001D40 ; public: wchar_t * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001D40                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
.text$mn:00001D40 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ proc near
.text$mn:00001D40                                         ; CODE XREF: $LN19_0+14p
.text$mn:00001D40                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+1Fp ...
.text$mn:00001D40
.text$mn:00001D40 var_8           = dword ptr -8
.text$mn:00001D40 var_4           = dword ptr -4
.text$mn:00001D40
.text$mn:00001D40                 push    ebp
.text$mn:00001D41                 mov     ebp, esp
.text$mn:00001D43                 sub     esp, 8
.text$mn:00001D46                 mov     [ebp+var_4], ecx
.text$mn:00001D49                 mov     eax, [ebp+var_4]
.text$mn:00001D4C                 cmp     dword ptr [eax+18h], 8
.text$mn:00001D50                 jb      short loc_1D66
.text$mn:00001D52                 mov     ecx, [ebp+var_4]
.text$mn:00001D55                 mov     edx, [ecx+4]
.text$mn:00001D58                 push    edx
.text$mn:00001D59                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00001D5E                 add     esp, 4
.text$mn:00001D61                 mov     [ebp+var_8], eax
.text$mn:00001D64                 jmp     short loc_1D6F
.text$mn:00001D66 ; ---------------------------------------------------------------------------
.text$mn:00001D66
.text$mn:00001D66 loc_1D66:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:00001D66                 mov     eax, [ebp+var_4]
.text$mn:00001D69                 add     eax, 4
.text$mn:00001D6C                 mov     [ebp+var_8], eax
.text$mn:00001D6F
.text$mn:00001D6F loc_1D6F:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00001D6F                 mov     eax, [ebp+var_8]
.text$mn:00001D72                 mov     esp, ebp
.text$mn:00001D74                 pop     ebp
.text$mn:00001D75                 retn
.text$mn:00001D75 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ endp
.text$mn:00001D75
.text$mn:00001D75 ; ---------------------------------------------------------------------------
.text$mn:00001D76                 align 4
.text$mn:00001D76 _text$mn        ends
.text$mn:00001D76
.text$mn:00001D78 ; ===========================================================================
.text$mn:00001D78
.text$mn:00001D78 ; Segment type: Pure code
.text$mn:00001D78 ; Segment permissions: Read/Execute
.text$mn:00001D78 _text$mn        segment para public 'CODE' use32
.text$mn:00001D78                 assume cs:_text$mn
.text$mn:00001D78                 ;org 1D78h
.text$mn:00001D78 ; COMDAT (pick any)
.text$mn:00001D78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D78
.text$mn:00001D78 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D78
.text$mn:00001D78 ; Attributes: bp-based frame
.text$mn:00001D78
.text$mn:00001D78 ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:00001D78                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:00001D78 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:00001D78                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+7Dp
.text$mn:00001D78                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)+Ap ...
.text$mn:00001D78
.text$mn:00001D78 var_8           = dword ptr -8
.text$mn:00001D78 var_4           = dword ptr -4
.text$mn:00001D78
.text$mn:00001D78                 push    ebp
.text$mn:00001D79                 mov     ebp, esp
.text$mn:00001D7B                 sub     esp, 8
.text$mn:00001D7E                 mov     [ebp+var_4], ecx
.text$mn:00001D81                 mov     eax, [ebp+var_4]
.text$mn:00001D84                 cmp     dword ptr [eax+18h], 8
.text$mn:00001D88                 jb      short loc_1D9E
.text$mn:00001D8A                 mov     ecx, [ebp+var_4]
.text$mn:00001D8D                 mov     edx, [ecx+4]
.text$mn:00001D90                 push    edx
.text$mn:00001D91                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00001D96                 add     esp, 4
.text$mn:00001D99                 mov     [ebp+var_8], eax
.text$mn:00001D9C                 jmp     short loc_1DA7
.text$mn:00001D9E ; ---------------------------------------------------------------------------
.text$mn:00001D9E
.text$mn:00001D9E loc_1D9E:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:00001D9E                 mov     eax, [ebp+var_4]
.text$mn:00001DA1                 add     eax, 4
.text$mn:00001DA4                 mov     [ebp+var_8], eax
.text$mn:00001DA7
.text$mn:00001DA7 loc_1DA7:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00001DA7                 mov     eax, [ebp+var_8]
.text$mn:00001DAA                 mov     esp, ebp
.text$mn:00001DAC                 pop     ebp
.text$mn:00001DAD                 retn
.text$mn:00001DAD ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:00001DAD
.text$mn:00001DAD ; ---------------------------------------------------------------------------
.text$mn:00001DAE                 align 10h
.text$mn:00001DAE _text$mn        ends
.text$mn:00001DAE
.text$mn:00001DB0 ; ===========================================================================
.text$mn:00001DB0
.text$mn:00001DB0 ; Segment type: Pure code
.text$mn:00001DB0 ; Segment permissions: Read/Execute
.text$mn:00001DB0 _text$mn        segment para public 'CODE' use32
.text$mn:00001DB0                 assume cs:_text$mn
.text$mn:00001DB0                 ;org 1DB0h
.text$mn:00001DB0 ; COMDAT (pick any)
.text$mn:00001DB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001DB0
.text$mn:00001DB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DB0
.text$mn:00001DB0 ; Attributes: bp-based frame
.text$mn:00001DB0
.text$mn:00001DB0 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00001DB0                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00001DB0 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00001DB0                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00001DB0                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:00001DB0
.text$mn:00001DB0 var_18          = byte ptr -18h
.text$mn:00001DB0 var_14          = dword ptr -14h
.text$mn:00001DB0 var_10          = dword ptr -10h
.text$mn:00001DB0 var_C           = dword ptr -0Ch
.text$mn:00001DB0 var_4           = dword ptr -4
.text$mn:00001DB0
.text$mn:00001DB0                 push    ebp
.text$mn:00001DB1                 mov     ebp, esp
.text$mn:00001DB3                 push    0FFFFFFFFh
.text$mn:00001DB5                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00001DBA                 mov     eax, large fs:0
.text$mn:00001DC0                 push    eax
.text$mn:00001DC1                 sub     esp, 0Ch
.text$mn:00001DC4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001DC9                 xor     eax, ebp
.text$mn:00001DCB                 push    eax
.text$mn:00001DCC                 lea     eax, [ebp+var_C]
.text$mn:00001DCF                 mov     large fs:0, eax
.text$mn:00001DD5                 mov     [ebp+var_14], ecx
.text$mn:00001DD8                 mov     eax, [ebp+var_14]
.text$mn:00001DDB                 cmp     dword ptr [eax], 0
.text$mn:00001DDE                 jz      short loc_1E3B
.text$mn:00001DE0                 push    3               ; int
.text$mn:00001DE2                 lea     ecx, [ebp+var_18] ; this
.text$mn:00001DE5                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00001DEA                 mov     [ebp+var_4], 0
.text$mn:00001DF1                 mov     ecx, [ebp+var_14]
.text$mn:00001DF4                 mov     edx, [ecx]
.text$mn:00001DF6                 add     edx, 4
.text$mn:00001DF9                 mov     [ebp+var_10], edx
.text$mn:00001DFC                 jmp     short loc_1E0B
.text$mn:00001DFE ; ---------------------------------------------------------------------------
.text$mn:00001DFE
.text$mn:00001DFE loc_1DFE:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:00001DFE                 mov     eax, [ebp+var_10]
.text$mn:00001E01                 mov     ecx, [eax]
.text$mn:00001E03                 mov     edx, [ebp+var_10]
.text$mn:00001E06                 mov     eax, [ecx+4]
.text$mn:00001E09                 mov     [edx], eax
.text$mn:00001E0B
.text$mn:00001E0B loc_1E0B:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00001E0B                 mov     ecx, [ebp+var_10]
.text$mn:00001E0E                 cmp     dword ptr [ecx], 0
.text$mn:00001E11                 jz      short loc_1E20
.text$mn:00001E13                 mov     edx, [ebp+var_10]
.text$mn:00001E16                 mov     eax, [edx]
.text$mn:00001E18                 mov     dword ptr [eax], 0
.text$mn:00001E1E                 jmp     short loc_1DFE
.text$mn:00001E20 ; ---------------------------------------------------------------------------
.text$mn:00001E20
.text$mn:00001E20 loc_1E20:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00001E20                 mov     ecx, [ebp+var_14]
.text$mn:00001E23                 mov     edx, [ecx]
.text$mn:00001E25                 mov     dword ptr [edx+4], 0
.text$mn:00001E2C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001E33                 lea     ecx, [ebp+var_18] ; this
.text$mn:00001E36                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00001E3B
.text$mn:00001E3B loc_1E3B:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00001E3B                 mov     ecx, [ebp+var_C]
.text$mn:00001E3E                 mov     large fs:0, ecx
.text$mn:00001E45                 pop     ecx
.text$mn:00001E46                 mov     esp, ebp
.text$mn:00001E48                 pop     ebp
.text$mn:00001E49                 retn
.text$mn:00001E49 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00001E49
.text$mn:00001E49 ; ---------------------------------------------------------------------------
.text$mn:00001E4A                 align 4
.text$mn:00001E4A _text$mn        ends
.text$mn:00001E4A
.text$x:00001E4C ; ===========================================================================
.text$x:00001E4C
.text$x:00001E4C ; Segment type: Pure code
.text$x:00001E4C ; Segment permissions: Read/Execute
.text$x:00001E4C _text$x         segment para public 'CODE' use32
.text$x:00001E4C                 assume cs:_text$x
.text$x:00001E4C                 ;org 1E4Ch
.text$x:00001E4C ; COMDAT (pick associative to section at 1DB0)
.text$x:00001E4C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001E4C
.text$x:00001E4C ; =============== S U B R O U T I N E =======================================
.text$x:00001E4C
.text$x:00001E4C
.text$x:00001E4C __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00001E4C                                         ; DATA XREF: .xdata$x:00002DF0o
.text$x:00001E4C                 lea     ecx, [ebp-18h]  ; this
.text$x:00001E4F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00001E4F __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:00001E4F
.text$x:00001E54
.text$x:00001E54 ; =============== S U B R O U T I N E =======================================
.text$x:00001E54
.text$x:00001E54
.text$x:00001E54 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00001E54                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00001E54
.text$x:00001E54 arg_4           = dword ptr  8
.text$x:00001E54
.text$x:00001E54                 mov     edx, [esp+arg_4]
.text$x:00001E58                 lea     eax, [edx+0Ch]
.text$x:00001E5B                 mov     ecx, [edx-10h]
.text$x:00001E5E                 xor     ecx, eax
.text$x:00001E60                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001E65                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00001E6A                 jmp     ___CxxFrameHandler3
.text$x:00001E6A __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00001E6A
.text$x:00001E6A ; ---------------------------------------------------------------------------
.text$x:00001E6F                 align 10h
.text$x:00001E6F _text$x         ends
.text$x:00001E6F
.text$mn:00001E70 ; ===========================================================================
.text$mn:00001E70
.text$mn:00001E70 ; Segment type: Pure code
.text$mn:00001E70 ; Segment permissions: Read/Execute
.text$mn:00001E70 _text$mn        segment para public 'CODE' use32
.text$mn:00001E70                 assume cs:_text$mn
.text$mn:00001E70                 ;org 1E70h
.text$mn:00001E70 ; COMDAT (pick any)
.text$mn:00001E70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001E70
.text$mn:00001E70 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E70
.text$mn:00001E70 ; Attributes: bp-based frame
.text$mn:00001E70
.text$mn:00001E70 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00001E70                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00001E70 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00001E70                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00001E70                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00001E70
.text$mn:00001E70 var_C           = dword ptr -0Ch
.text$mn:00001E70 var_8           = dword ptr -8
.text$mn:00001E70 var_2           = byte ptr -2
.text$mn:00001E70 var_1           = byte ptr -1
.text$mn:00001E70 arg_0           = byte ptr  8
.text$mn:00001E70 Size            = dword ptr  0Ch
.text$mn:00001E70
.text$mn:00001E70                 push    ebp
.text$mn:00001E71                 mov     ebp, esp
.text$mn:00001E73                 sub     esp, 0Ch
.text$mn:00001E76                 mov     [ebp+var_8], ecx
.text$mn:00001E79                 movzx   eax, [ebp+arg_0]
.text$mn:00001E7D                 test    eax, eax
.text$mn:00001E7F                 jnz     short loc_1E83
.text$mn:00001E81                 jmp     short loc_1EF6
.text$mn:00001E83 ; ---------------------------------------------------------------------------
.text$mn:00001E83
.text$mn:00001E83 loc_1E83:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00001E83                 mov     ecx, [ebp+var_8]
.text$mn:00001E86                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00001E8A                 jb      short loc_1EF6
.text$mn:00001E8C                 mov     edx, [ebp+var_8]
.text$mn:00001E8F                 mov     eax, [edx+4]
.text$mn:00001E92                 mov     [ebp+var_C], eax
.text$mn:00001E95                 mov     ecx, [ebp+var_8]
.text$mn:00001E98                 add     ecx, 4
.text$mn:00001E9B                 push    ecx
.text$mn:00001E9C                 lea     edx, [ebp+var_1]
.text$mn:00001E9F                 push    edx
.text$mn:00001EA0                 mov     ecx, [ebp+var_8]
.text$mn:00001EA3                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001EA8                 mov     ecx, eax
.text$mn:00001EAA                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00001EAF                 cmp     [ebp+Size], 0
.text$mn:00001EB3                 jbe     short loc_1ED5
.text$mn:00001EB5                 mov     eax, [ebp+Size]
.text$mn:00001EB8                 push    eax             ; Size
.text$mn:00001EB9                 mov     ecx, [ebp+var_C]
.text$mn:00001EBC                 push    ecx
.text$mn:00001EBD                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001EC2                 add     esp, 4
.text$mn:00001EC5                 push    eax             ; Src
.text$mn:00001EC6                 mov     edx, [ebp+var_8]
.text$mn:00001EC9                 add     edx, 4
.text$mn:00001ECC                 push    edx             ; Dst
.text$mn:00001ECD                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001ED2                 add     esp, 0Ch
.text$mn:00001ED5
.text$mn:00001ED5 loc_1ED5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00001ED5                 mov     eax, [ebp+var_8]
.text$mn:00001ED8                 mov     ecx, [eax+18h]
.text$mn:00001EDB                 add     ecx, 1
.text$mn:00001EDE                 push    ecx             ; int
.text$mn:00001EDF                 mov     edx, [ebp+var_C]
.text$mn:00001EE2                 push    edx             ; void *
.text$mn:00001EE3                 lea     eax, [ebp+var_2]
.text$mn:00001EE6                 push    eax
.text$mn:00001EE7                 mov     ecx, [ebp+var_8]
.text$mn:00001EEA                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001EEF                 mov     ecx, eax
.text$mn:00001EF1                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:00001EF6
.text$mn:00001EF6 loc_1EF6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:00001EF6                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:00001EF6                 mov     ecx, [ebp+var_8]
.text$mn:00001EF9                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00001F00                 mov     edx, [ebp+Size]
.text$mn:00001F03                 push    edx
.text$mn:00001F04                 mov     ecx, [ebp+var_8]
.text$mn:00001F07                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001F0C                 mov     esp, ebp
.text$mn:00001F0E                 pop     ebp
.text$mn:00001F0F                 retn    8
.text$mn:00001F0F ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:00001F0F
.text$mn:00001F0F ; ---------------------------------------------------------------------------
.text$mn:00001F12                 align 4
.text$mn:00001F12 _text$mn        ends
.text$mn:00001F12
.text$mn:00001F14 ; ===========================================================================
.text$mn:00001F14
.text$mn:00001F14 ; Segment type: Pure code
.text$mn:00001F14 ; Segment permissions: Read/Execute
.text$mn:00001F14 _text$mn        segment para public 'CODE' use32
.text$mn:00001F14                 assume cs:_text$mn
.text$mn:00001F14                 ;org 1F14h
.text$mn:00001F14 ; COMDAT (pick any)
.text$mn:00001F14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001F14
.text$mn:00001F14 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F14
.text$mn:00001F14 ; Attributes: bp-based frame
.text$mn:00001F14
.text$mn:00001F14 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy(bool, unsigned int)
.text$mn:00001F14                 public ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
.text$mn:00001F14 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z proc near
.text$mn:00001F14                                         ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1+7p
.text$mn:00001F14                                         ; $LN19_0+2Dp ...
.text$mn:00001F14
.text$mn:00001F14 var_C           = dword ptr -0Ch
.text$mn:00001F14 var_8           = dword ptr -8
.text$mn:00001F14 var_2           = byte ptr -2
.text$mn:00001F14 var_1           = byte ptr -1
.text$mn:00001F14 arg_0           = byte ptr  8
.text$mn:00001F14 arg_4           = dword ptr  0Ch
.text$mn:00001F14
.text$mn:00001F14                 push    ebp
.text$mn:00001F15                 mov     ebp, esp
.text$mn:00001F17                 sub     esp, 0Ch
.text$mn:00001F1A                 mov     [ebp+var_8], ecx
.text$mn:00001F1D                 movzx   eax, [ebp+arg_0]
.text$mn:00001F21                 test    eax, eax
.text$mn:00001F23                 jnz     short loc_1F27
.text$mn:00001F25                 jmp     short loc_1F9A
.text$mn:00001F27 ; ---------------------------------------------------------------------------
.text$mn:00001F27
.text$mn:00001F27 loc_1F27:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+Fj
.text$mn:00001F27                 mov     ecx, [ebp+var_8]
.text$mn:00001F2A                 cmp     dword ptr [ecx+18h], 8
.text$mn:00001F2E                 jb      short loc_1F9A
.text$mn:00001F30                 mov     edx, [ebp+var_8]
.text$mn:00001F33                 mov     eax, [edx+4]
.text$mn:00001F36                 mov     [ebp+var_C], eax
.text$mn:00001F39                 mov     ecx, [ebp+var_8]
.text$mn:00001F3C                 add     ecx, 4
.text$mn:00001F3F                 push    ecx
.text$mn:00001F40                 lea     edx, [ebp+var_1]
.text$mn:00001F43                 push    edx
.text$mn:00001F44                 mov     ecx, [ebp+var_8]
.text$mn:00001F47                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00001F4C                 mov     ecx, eax
.text$mn:00001F4E                 call    ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00001F53                 cmp     [ebp+arg_4], 0
.text$mn:00001F57                 jbe     short loc_1F79
.text$mn:00001F59                 mov     eax, [ebp+arg_4]
.text$mn:00001F5C                 push    eax             ; int
.text$mn:00001F5D                 mov     ecx, [ebp+var_C]
.text$mn:00001F60                 push    ecx
.text$mn:00001F61                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00001F66                 add     esp, 4
.text$mn:00001F69                 push    eax             ; Src
.text$mn:00001F6A                 mov     edx, [ebp+var_8]
.text$mn:00001F6D                 add     edx, 4
.text$mn:00001F70                 push    edx             ; Dst
.text$mn:00001F71                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00001F76                 add     esp, 0Ch
.text$mn:00001F79
.text$mn:00001F79 loc_1F79:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+43j
.text$mn:00001F79                 mov     eax, [ebp+var_8]
.text$mn:00001F7C                 mov     ecx, [eax+18h]
.text$mn:00001F7F                 add     ecx, 1
.text$mn:00001F82                 push    ecx             ; int
.text$mn:00001F83                 mov     edx, [ebp+var_C]
.text$mn:00001F86                 push    edx             ; void *
.text$mn:00001F87                 lea     eax, [ebp+var_2]
.text$mn:00001F8A                 push    eax
.text$mn:00001F8B                 mov     ecx, [ebp+var_8]
.text$mn:00001F8E                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00001F93                 mov     ecx, eax
.text$mn:00001F95                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:00001F9A
.text$mn:00001F9A loc_1F9A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+11j
.text$mn:00001F9A                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+1Aj
.text$mn:00001F9A                 mov     ecx, [ebp+var_8]
.text$mn:00001F9D                 mov     dword ptr [ecx+18h], 7
.text$mn:00001FA4                 mov     edx, [ebp+arg_4]
.text$mn:00001FA7                 push    edx
.text$mn:00001FA8                 mov     ecx, [ebp+var_8]
.text$mn:00001FAB                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00001FB0                 mov     esp, ebp
.text$mn:00001FB2                 pop     ebp
.text$mn:00001FB3                 retn    8
.text$mn:00001FB3 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z endp
.text$mn:00001FB3
.text$mn:00001FB3 ; ---------------------------------------------------------------------------
.text$mn:00001FB6                 align 4
.text$mn:00001FB6 _text$mn        ends
.text$mn:00001FB6
.text$mn:00001FB8 ; ===========================================================================
.text$mn:00001FB8
.text$mn:00001FB8 ; Segment type: Pure code
.text$mn:00001FB8 ; Segment permissions: Read/Execute
.text$mn:00001FB8 _text$mn        segment para public 'CODE' use32
.text$mn:00001FB8                 assume cs:_text$mn
.text$mn:00001FB8                 ;org 1FB8h
.text$mn:00001FB8 ; COMDAT (pick any)
.text$mn:00001FB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001FB8
.text$mn:00001FB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FB8
.text$mn:00001FB8 ; Attributes: bp-based frame
.text$mn:00001FB8
.text$mn:00001FB8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00001FB8                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00001FB8 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00001FB8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00001FB8
.text$mn:00001FB8 var_4           = dword ptr -4
.text$mn:00001FB8
.text$mn:00001FB8                 push    ebp
.text$mn:00001FB9                 mov     ebp, esp
.text$mn:00001FBB                 push    ecx
.text$mn:00001FBC                 mov     [ebp+var_4], ecx
.text$mn:00001FBF                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00001FC4                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00001FC9                 mov     esp, ebp
.text$mn:00001FCB                 pop     ebp
.text$mn:00001FCC                 retn
.text$mn:00001FCC ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00001FCC
.text$mn:00001FCC ; ---------------------------------------------------------------------------
.text$mn:00001FCD                 align 10h
.text$mn:00001FCD _text$mn        ends
.text$mn:00001FCD
.text$mn:00001FD0 ; ===========================================================================
.text$mn:00001FD0
.text$mn:00001FD0 ; Segment type: Pure code
.text$mn:00001FD0 ; Segment permissions: Read/Execute
.text$mn:00001FD0 _text$mn        segment para public 'CODE' use32
.text$mn:00001FD0                 assume cs:_text$mn
.text$mn:00001FD0                 ;org 1FD0h
.text$mn:00001FD0 ; COMDAT (pick any)
.text$mn:00001FD0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001FD0
.text$mn:00001FD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FD0
.text$mn:00001FD0 ; Attributes: bp-based frame
.text$mn:00001FD0
.text$mn:00001FD0 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xlen(void)const
.text$mn:00001FD0                 public ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:00001FD0 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:00001FD0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+19p
.text$mn:00001FD0
.text$mn:00001FD0 var_4           = dword ptr -4
.text$mn:00001FD0
.text$mn:00001FD0                 push    ebp
.text$mn:00001FD1                 mov     ebp, esp
.text$mn:00001FD3                 push    ecx
.text$mn:00001FD4                 mov     [ebp+var_4], ecx
.text$mn:00001FD7                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00001FDC                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00001FE1                 mov     esp, ebp
.text$mn:00001FE3                 pop     ebp
.text$mn:00001FE4                 retn
.text$mn:00001FE4 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00001FE4
.text$mn:00001FE4 ; ---------------------------------------------------------------------------
.text$mn:00001FE5                 align 4
.text$mn:00001FE5 _text$mn        ends
.text$mn:00001FE5
.text$mn:00001FE8 ; ===========================================================================
.text$mn:00001FE8
.text$mn:00001FE8 ; Segment type: Pure code
.text$mn:00001FE8 ; Segment permissions: Read/Execute
.text$mn:00001FE8 _text$mn        segment para public 'CODE' use32
.text$mn:00001FE8                 assume cs:_text$mn
.text$mn:00001FE8                 ;org 1FE8h
.text$mn:00001FE8 ; COMDAT (pick any)
.text$mn:00001FE8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001FE8
.text$mn:00001FE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FE8
.text$mn:00001FE8 ; Attributes: bp-based frame
.text$mn:00001FE8
.text$mn:00001FE8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00001FE8                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00001FE8 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00001FE8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00001FE8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00001FE8
.text$mn:00001FE8 var_4           = dword ptr -4
.text$mn:00001FE8
.text$mn:00001FE8                 push    ebp
.text$mn:00001FE9                 mov     ebp, esp
.text$mn:00001FEB                 push    ecx
.text$mn:00001FEC                 mov     [ebp+var_4], ecx
.text$mn:00001FEF                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00001FF4                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00001FF9                 mov     esp, ebp
.text$mn:00001FFB                 pop     ebp
.text$mn:00001FFC                 retn
.text$mn:00001FFC ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00001FFC
.text$mn:00001FFC ; ---------------------------------------------------------------------------
.text$mn:00001FFD                 align 10h
.text$mn:00001FFD _text$mn        ends
.text$mn:00001FFD
.text$mn:00002000 ; ===========================================================================
.text$mn:00002000
.text$mn:00002000 ; Segment type: Pure code
.text$mn:00002000 ; Segment permissions: Read/Execute
.text$mn:00002000 _text$mn        segment para public 'CODE' use32
.text$mn:00002000                 assume cs:_text$mn
.text$mn:00002000                 ;org 2000h
.text$mn:00002000 ; COMDAT (pick any)
.text$mn:00002000                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002000
.text$mn:00002000 ; =============== S U B R O U T I N E =======================================
.text$mn:00002000
.text$mn:00002000 ; Attributes: bp-based frame
.text$mn:00002000
.text$mn:00002000 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xran(void)const
.text$mn:00002000                 public ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:00002000 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:00002000                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p
.text$mn:00002000                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+33p ...
.text$mn:00002000
.text$mn:00002000 var_4           = dword ptr -4
.text$mn:00002000
.text$mn:00002000                 push    ebp
.text$mn:00002001                 mov     ebp, esp
.text$mn:00002003                 push    ecx
.text$mn:00002004                 mov     [ebp+var_4], ecx
.text$mn:00002007                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:0000200C                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00002011                 mov     esp, ebp
.text$mn:00002013                 pop     ebp
.text$mn:00002014                 retn
.text$mn:00002014 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00002014
.text$mn:00002014 ; ---------------------------------------------------------------------------
.text$mn:00002015                 align 4
.text$mn:00002015 _text$mn        ends
.text$mn:00002015
.text$mn:00002018 ; ===========================================================================
.text$mn:00002018
.text$mn:00002018 ; Segment type: Pure code
.text$mn:00002018 ; Segment permissions: Read/Execute
.text$mn:00002018 _text$mn        segment para public 'CODE' use32
.text$mn:00002018                 assume cs:_text$mn
.text$mn:00002018                 ;org 2018h
.text$mn:00002018 ; COMDAT (pick any)
.text$mn:00002018                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002018
.text$mn:00002018 ; =============== S U B R O U T I N E =======================================
.text$mn:00002018
.text$mn:00002018 ; Attributes: bp-based frame
.text$mn:00002018
.text$mn:00002018 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00002018                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00002018 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00002018                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00002018                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00002018
.text$mn:00002018 var_4           = dword ptr -4
.text$mn:00002018 arg_0           = dword ptr  8
.text$mn:00002018
.text$mn:00002018                 push    ebp
.text$mn:00002019                 mov     ebp, esp
.text$mn:0000201B                 push    ecx
.text$mn:0000201C                 mov     [ebp+var_4], ecx
.text$mn:0000201F                 mov     eax, [ebp+arg_0]
.text$mn:00002022                 push    eax
.text$mn:00002023                 mov     ecx, [ebp+var_4]
.text$mn:00002026                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:0000202B                 mov     esp, ebp
.text$mn:0000202D                 pop     ebp
.text$mn:0000202E                 retn    4
.text$mn:0000202E ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:0000202E
.text$mn:0000202E ; ---------------------------------------------------------------------------
.text$mn:00002031                 align 4
.text$mn:00002031 _text$mn        ends
.text$mn:00002031
.text$mn:00002034 ; ===========================================================================
.text$mn:00002034
.text$mn:00002034 ; Segment type: Pure code
.text$mn:00002034 ; Segment permissions: Read/Execute
.text$mn:00002034 _text$mn        segment para public 'CODE' use32
.text$mn:00002034                 assume cs:_text$mn
.text$mn:00002034                 ;org 2034h
.text$mn:00002034 ; COMDAT (pick any)
.text$mn:00002034                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002034
.text$mn:00002034 ; =============== S U B R O U T I N E =======================================
.text$mn:00002034
.text$mn:00002034 ; Attributes: bp-based frame
.text$mn:00002034
.text$mn:00002034 ; public: wchar_t * __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::allocate(unsigned int)
.text$mn:00002034                 public ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
.text$mn:00002034 ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z proc near
.text$mn:00002034                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+BBp
.text$mn:00002034                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+22p
.text$mn:00002034
.text$mn:00002034 var_4           = dword ptr -4
.text$mn:00002034 arg_0           = dword ptr  8
.text$mn:00002034
.text$mn:00002034                 push    ebp
.text$mn:00002035                 mov     ebp, esp
.text$mn:00002037                 push    ecx
.text$mn:00002038                 mov     [ebp+var_4], ecx
.text$mn:0000203B                 mov     eax, [ebp+arg_0]
.text$mn:0000203E                 push    eax
.text$mn:0000203F                 mov     ecx, [ebp+var_4]
.text$mn:00002042                 call    ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate(uint)
.text$mn:00002047                 mov     esp, ebp
.text$mn:00002049                 pop     ebp
.text$mn:0000204A                 retn    4
.text$mn:0000204A ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z endp
.text$mn:0000204A
.text$mn:0000204A ; ---------------------------------------------------------------------------
.text$mn:0000204D                 align 10h
.text$mn:0000204D _text$mn        ends
.text$mn:0000204D
.text$mn:00002050 ; ===========================================================================
.text$mn:00002050
.text$mn:00002050 ; Segment type: Pure code
.text$mn:00002050 ; Segment permissions: Read/Execute
.text$mn:00002050 _text$mn        segment para public 'CODE' use32
.text$mn:00002050                 assume cs:_text$mn
.text$mn:00002050                 ;org 2050h
.text$mn:00002050 ; COMDAT (pick any)
.text$mn:00002050                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002050
.text$mn:00002050 ; =============== S U B R O U T I N E =======================================
.text$mn:00002050
.text$mn:00002050 ; Attributes: bp-based frame
.text$mn:00002050
.text$mn:00002050 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00002050                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00002050 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00002050                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00002050
.text$mn:00002050 var_4           = dword ptr -4
.text$mn:00002050 arg_0           = dword ptr  8
.text$mn:00002050
.text$mn:00002050                 push    ebp
.text$mn:00002051                 mov     ebp, esp
.text$mn:00002053                 push    ecx
.text$mn:00002054                 mov     [ebp+var_4], ecx
.text$mn:00002057                 push    0
.text$mn:00002059                 mov     eax, [ebp+arg_0]
.text$mn:0000205C                 push    eax
.text$mn:0000205D                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00002062                 add     esp, 8
.text$mn:00002065                 mov     esp, ebp
.text$mn:00002067                 pop     ebp
.text$mn:00002068                 retn    4
.text$mn:00002068 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00002068
.text$mn:00002068 ; ---------------------------------------------------------------------------
.text$mn:0000206B                 align 4
.text$mn:0000206B _text$mn        ends
.text$mn:0000206B
.text$mn:0000206C ; ===========================================================================
.text$mn:0000206C
.text$mn:0000206C ; Segment type: Pure code
.text$mn:0000206C ; Segment permissions: Read/Execute
.text$mn:0000206C _text$mn        segment para public 'CODE' use32
.text$mn:0000206C                 assume cs:_text$mn
.text$mn:0000206C                 ;org 206Ch
.text$mn:0000206C ; COMDAT (pick any)
.text$mn:0000206C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000206C
.text$mn:0000206C ; =============== S U B R O U T I N E =======================================
.text$mn:0000206C
.text$mn:0000206C ; Attributes: bp-based frame
.text$mn:0000206C
.text$mn:0000206C ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:0000206C                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:0000206C ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:0000206C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:0000206C
.text$mn:0000206C var_4           = dword ptr -4
.text$mn:0000206C arg_0           = dword ptr  8
.text$mn:0000206C
.text$mn:0000206C                 push    ebp
.text$mn:0000206D                 mov     ebp, esp
.text$mn:0000206F                 push    ecx
.text$mn:00002070                 mov     [ebp+var_4], ecx
.text$mn:00002073                 push    0
.text$mn:00002075                 mov     eax, [ebp+arg_0]
.text$mn:00002078                 push    eax
.text$mn:00002079                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:0000207E                 add     esp, 8
.text$mn:00002081                 mov     esp, ebp
.text$mn:00002083                 pop     ebp
.text$mn:00002084                 retn    4
.text$mn:00002084 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00002084
.text$mn:00002084 ; ---------------------------------------------------------------------------
.text$mn:00002087                 align 4
.text$mn:00002087 _text$mn        ends
.text$mn:00002087
.text$mn:00002088 ; ===========================================================================
.text$mn:00002088
.text$mn:00002088 ; Segment type: Pure code
.text$mn:00002088 ; Segment permissions: Read/Execute
.text$mn:00002088 _text$mn        segment para public 'CODE' use32
.text$mn:00002088                 assume cs:_text$mn
.text$mn:00002088                 ;org 2088h
.text$mn:00002088 ; COMDAT (pick any)
.text$mn:00002088                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002088
.text$mn:00002088 ; =============== S U B R O U T I N E =======================================
.text$mn:00002088
.text$mn:00002088 ; Attributes: bp-based frame
.text$mn:00002088
.text$mn:00002088 ; public: wchar_t * __thiscall std::allocator<wchar_t>::allocate(unsigned int)
.text$mn:00002088                 public ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
.text$mn:00002088 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z proc near
.text$mn:00002088                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)+Ep
.text$mn:00002088
.text$mn:00002088 var_4           = dword ptr -4
.text$mn:00002088 arg_0           = dword ptr  8
.text$mn:00002088
.text$mn:00002088                 push    ebp
.text$mn:00002089                 mov     ebp, esp
.text$mn:0000208B                 push    ecx
.text$mn:0000208C                 mov     [ebp+var_4], ecx
.text$mn:0000208F                 push    0
.text$mn:00002091                 mov     eax, [ebp+arg_0]
.text$mn:00002094                 push    eax
.text$mn:00002095                 call    ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>(uint,wchar_t *)
.text$mn:0000209A                 add     esp, 8
.text$mn:0000209D                 mov     esp, ebp
.text$mn:0000209F                 pop     ebp
.text$mn:000020A0                 retn    4
.text$mn:000020A0 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z endp
.text$mn:000020A0
.text$mn:000020A0 ; ---------------------------------------------------------------------------
.text$mn:000020A3                 align 4
.text$mn:000020A3 _text$mn        ends
.text$mn:000020A3
.text$mn:000020A4 ; ===========================================================================
.text$mn:000020A4
.text$mn:000020A4 ; Segment type: Pure code
.text$mn:000020A4 ; Segment permissions: Read/Execute
.text$mn:000020A4 _text$mn        segment para public 'CODE' use32
.text$mn:000020A4                 assume cs:_text$mn
.text$mn:000020A4                 ;org 20A4h
.text$mn:000020A4 ; COMDAT (pick any)
.text$mn:000020A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000020A4
.text$mn:000020A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000020A4
.text$mn:000020A4 ; Attributes: bp-based frame
.text$mn:000020A4
.text$mn:000020A4 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:000020A4                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:000020A4 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:000020A4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:000020A4
.text$mn:000020A4 Size            = dword ptr -8
.text$mn:000020A4 var_4           = dword ptr -4
.text$mn:000020A4 arg_0           = dword ptr  8
.text$mn:000020A4 arg_4           = dword ptr  0Ch
.text$mn:000020A4 arg_8           = dword ptr  10h
.text$mn:000020A4
.text$mn:000020A4                 push    ebp
.text$mn:000020A5                 mov     ebp, esp
.text$mn:000020A7                 sub     esp, 8
.text$mn:000020AA                 mov     [ebp+var_4], ecx
.text$mn:000020AD                 mov     ecx, [ebp+arg_0]
.text$mn:000020B0                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:000020B5                 cmp     eax, [ebp+arg_4]
.text$mn:000020B8                 jnb     short loc_20C2
.text$mn:000020BA                 mov     ecx, [ebp+var_4]
.text$mn:000020BD                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000020C2
.text$mn:000020C2 loc_20C2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:000020C2                 mov     ecx, [ebp+arg_0]
.text$mn:000020C5                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:000020CA                 sub     eax, [ebp+arg_4]
.text$mn:000020CD                 mov     [ebp+Size], eax
.text$mn:000020D0                 mov     eax, [ebp+arg_8]
.text$mn:000020D3                 cmp     eax, [ebp+Size]
.text$mn:000020D6                 jnb     short loc_20DE
.text$mn:000020D8                 mov     ecx, [ebp+arg_8]
.text$mn:000020DB                 mov     [ebp+Size], ecx
.text$mn:000020DE
.text$mn:000020DE loc_20DE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:000020DE                 mov     edx, [ebp+var_4]
.text$mn:000020E1                 cmp     edx, [ebp+arg_0]
.text$mn:000020E4                 jnz     short loc_2105
.text$mn:000020E6                 mov     eax, [ebp+arg_4]
.text$mn:000020E9                 add     eax, [ebp+Size]
.text$mn:000020EC                 push    eax
.text$mn:000020ED                 mov     ecx, [ebp+var_4]
.text$mn:000020F0                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:000020F5                 mov     ecx, [ebp+arg_4]
.text$mn:000020F8                 push    ecx
.text$mn:000020F9                 push    0
.text$mn:000020FB                 mov     ecx, [ebp+var_4]
.text$mn:000020FE                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00002103                 jmp     short loc_2147
.text$mn:00002105 ; ---------------------------------------------------------------------------
.text$mn:00002105
.text$mn:00002105 loc_2105:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00002105                 push    0
.text$mn:00002107                 mov     edx, [ebp+Size]
.text$mn:0000210A                 push    edx
.text$mn:0000210B                 mov     ecx, [ebp+var_4]
.text$mn:0000210E                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00002113                 movzx   eax, al
.text$mn:00002116                 test    eax, eax
.text$mn:00002118                 jz      short loc_2147
.text$mn:0000211A                 mov     ecx, [ebp+Size]
.text$mn:0000211D                 push    ecx             ; Size
.text$mn:0000211E                 mov     ecx, [ebp+arg_0]
.text$mn:00002121                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002126                 add     eax, [ebp+arg_4]
.text$mn:00002129                 push    eax             ; Src
.text$mn:0000212A                 mov     ecx, [ebp+var_4]
.text$mn:0000212D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002132                 push    eax             ; Dst
.text$mn:00002133                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00002138                 add     esp, 0Ch
.text$mn:0000213B                 mov     edx, [ebp+Size]
.text$mn:0000213E                 push    edx
.text$mn:0000213F                 mov     ecx, [ebp+var_4]
.text$mn:00002142                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002147
.text$mn:00002147 loc_2147:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00002147                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00002147                 mov     eax, [ebp+var_4]
.text$mn:0000214A                 mov     esp, ebp
.text$mn:0000214C                 pop     ebp
.text$mn:0000214D                 retn    0Ch
.text$mn:0000214D ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:0000214D
.text$mn:0000214D _text$mn        ends
.text$mn:0000214D
.text$mn:00002150 ; ===========================================================================
.text$mn:00002150
.text$mn:00002150 ; Segment type: Pure code
.text$mn:00002150 ; Segment permissions: Read/Execute
.text$mn:00002150 _text$mn        segment para public 'CODE' use32
.text$mn:00002150                 assume cs:_text$mn
.text$mn:00002150                 ;org 2150h
.text$mn:00002150 ; COMDAT (pick any)
.text$mn:00002150                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002150
.text$mn:00002150 ; =============== S U B R O U T I N E =======================================
.text$mn:00002150
.text$mn:00002150 ; Attributes: bp-based frame
.text$mn:00002150
.text$mn:00002150 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00002150                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00002150 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00002150                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00002150
.text$mn:00002150 var_4           = dword ptr -4
.text$mn:00002150 Str             = dword ptr  8
.text$mn:00002150
.text$mn:00002150                 push    ebp
.text$mn:00002151                 mov     ebp, esp
.text$mn:00002153                 push    ecx
.text$mn:00002154                 mov     [ebp+var_4], ecx
.text$mn:00002157                 push    490h            ; unsigned int
.text$mn:0000215C                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002161                 mov     eax, [ebp+Str]
.text$mn:00002164                 push    eax             ; int
.text$mn:00002165                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000216A                 add     esp, 0Ch
.text$mn:0000216D                 mov     ecx, [ebp+Str]
.text$mn:00002170                 push    ecx             ; Str
.text$mn:00002171                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00002176                 add     esp, 4
.text$mn:00002179                 push    eax             ; Size
.text$mn:0000217A                 mov     edx, [ebp+Str]
.text$mn:0000217D                 push    edx             ; Src
.text$mn:0000217E                 mov     ecx, [ebp+var_4]
.text$mn:00002181                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00002186                 mov     esp, ebp
.text$mn:00002188                 pop     ebp
.text$mn:00002189                 retn    4
.text$mn:00002189 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00002189
.text$mn:00002189 _text$mn        ends
.text$mn:00002189
.text$mn:0000218C ; ===========================================================================
.text$mn:0000218C
.text$mn:0000218C ; Segment type: Pure code
.text$mn:0000218C ; Segment permissions: Read/Execute
.text$mn:0000218C _text$mn        segment para public 'CODE' use32
.text$mn:0000218C                 assume cs:_text$mn
.text$mn:0000218C                 ;org 218Ch
.text$mn:0000218C ; COMDAT (pick any)
.text$mn:0000218C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000218C
.text$mn:0000218C ; =============== S U B R O U T I N E =======================================
.text$mn:0000218C
.text$mn:0000218C ; Attributes: bp-based frame
.text$mn:0000218C
.text$mn:0000218C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:0000218C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:0000218C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:0000218C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:0000218C
.text$mn:0000218C var_4           = dword ptr -4
.text$mn:0000218C Src             = dword ptr  8
.text$mn:0000218C Size            = dword ptr  0Ch
.text$mn:0000218C
.text$mn:0000218C                 push    ebp
.text$mn:0000218D                 mov     ebp, esp
.text$mn:0000218F                 push    ecx
.text$mn:00002190                 mov     [ebp+var_4], ecx
.text$mn:00002193                 cmp     [ebp+Size], 0
.text$mn:00002197                 jz      short loc_21AF
.text$mn:00002199                 push    47Fh            ; unsigned int
.text$mn:0000219E                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000021A3                 mov     eax, [ebp+Src]
.text$mn:000021A6                 push    eax             ; int
.text$mn:000021A7                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:000021AC                 add     esp, 0Ch
.text$mn:000021AF
.text$mn:000021AF loc_21AF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:000021AF                 mov     ecx, [ebp+Src]
.text$mn:000021B2                 push    ecx
.text$mn:000021B3                 mov     ecx, [ebp+var_4]
.text$mn:000021B6                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:000021BB                 movzx   edx, al
.text$mn:000021BE                 test    edx, edx
.text$mn:000021C0                 jz      short loc_21E2
.text$mn:000021C2                 mov     eax, [ebp+Size]
.text$mn:000021C5                 push    eax
.text$mn:000021C6                 mov     ecx, [ebp+var_4]
.text$mn:000021C9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000021CE                 mov     ecx, [ebp+Src]
.text$mn:000021D1                 sub     ecx, eax
.text$mn:000021D3                 push    ecx
.text$mn:000021D4                 mov     edx, [ebp+var_4]
.text$mn:000021D7                 push    edx
.text$mn:000021D8                 mov     ecx, [ebp+var_4]
.text$mn:000021DB                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:000021E0                 jmp     short loc_221F
.text$mn:000021E2 ; ---------------------------------------------------------------------------
.text$mn:000021E2
.text$mn:000021E2 loc_21E2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:000021E2                 push    0
.text$mn:000021E4                 mov     eax, [ebp+Size]
.text$mn:000021E7                 push    eax
.text$mn:000021E8                 mov     ecx, [ebp+var_4]
.text$mn:000021EB                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000021F0                 movzx   ecx, al
.text$mn:000021F3                 test    ecx, ecx
.text$mn:000021F5                 jz      short loc_221C
.text$mn:000021F7                 mov     edx, [ebp+Size]
.text$mn:000021FA                 push    edx             ; Size
.text$mn:000021FB                 mov     eax, [ebp+Src]
.text$mn:000021FE                 push    eax             ; Src
.text$mn:000021FF                 mov     ecx, [ebp+var_4]
.text$mn:00002202                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002207                 push    eax             ; Dst
.text$mn:00002208                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000220D                 add     esp, 0Ch
.text$mn:00002210                 mov     ecx, [ebp+Size]
.text$mn:00002213                 push    ecx
.text$mn:00002214                 mov     ecx, [ebp+var_4]
.text$mn:00002217                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000221C
.text$mn:0000221C loc_221C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:0000221C                 mov     eax, [ebp+var_4]
.text$mn:0000221F
.text$mn:0000221F loc_221F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:0000221F                 mov     esp, ebp
.text$mn:00002221                 pop     ebp
.text$mn:00002222                 retn    8
.text$mn:00002222 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00002222
.text$mn:00002222 ; ---------------------------------------------------------------------------
.text$mn:00002225                 align 4
.text$mn:00002225 _text$mn        ends
.text$mn:00002225
.text$mn:00002228 ; ===========================================================================
.text$mn:00002228
.text$mn:00002228 ; Segment type: Pure code
.text$mn:00002228 ; Segment permissions: Read/Execute
.text$mn:00002228 _text$mn        segment para public 'CODE' use32
.text$mn:00002228                 assume cs:_text$mn
.text$mn:00002228                 ;org 2228h
.text$mn:00002228 ; COMDAT (pick any)
.text$mn:00002228                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002228
.text$mn:00002228 ; =============== S U B R O U T I N E =======================================
.text$mn:00002228
.text$mn:00002228 ; Attributes: bp-based frame
.text$mn:00002228
.text$mn:00002228 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:00002228                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00002228 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00002228                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+51p
.text$mn:00002228
.text$mn:00002228 var_8           = dword ptr -8
.text$mn:00002228 var_4           = dword ptr -4
.text$mn:00002228 arg_0           = dword ptr  8
.text$mn:00002228 arg_4           = dword ptr  0Ch
.text$mn:00002228 arg_8           = dword ptr  10h
.text$mn:00002228
.text$mn:00002228                 push    ebp
.text$mn:00002229                 mov     ebp, esp
.text$mn:0000222B                 sub     esp, 8
.text$mn:0000222E                 mov     [ebp+var_4], ecx
.text$mn:00002231                 mov     ecx, [ebp+arg_0]
.text$mn:00002234                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00002239                 cmp     eax, [ebp+arg_4]
.text$mn:0000223C                 jnb     short loc_2246
.text$mn:0000223E                 mov     ecx, [ebp+var_4]
.text$mn:00002241                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00002246
.text$mn:00002246 loc_2246:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:00002246                 mov     ecx, [ebp+arg_0]
.text$mn:00002249                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000224E                 sub     eax, [ebp+arg_4]
.text$mn:00002251                 mov     [ebp+var_8], eax
.text$mn:00002254                 mov     eax, [ebp+arg_8]
.text$mn:00002257                 cmp     eax, [ebp+var_8]
.text$mn:0000225A                 jnb     short loc_2262
.text$mn:0000225C                 mov     ecx, [ebp+arg_8]
.text$mn:0000225F                 mov     [ebp+var_8], ecx
.text$mn:00002262
.text$mn:00002262 loc_2262:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:00002262                 mov     edx, [ebp+var_4]
.text$mn:00002265                 cmp     edx, [ebp+arg_0]
.text$mn:00002268                 jnz     short loc_2289
.text$mn:0000226A                 mov     eax, [ebp+arg_4]
.text$mn:0000226D                 add     eax, [ebp+var_8]
.text$mn:00002270                 push    eax
.text$mn:00002271                 mov     ecx, [ebp+var_4]
.text$mn:00002274                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:00002279                 mov     ecx, [ebp+arg_4]
.text$mn:0000227C                 push    ecx
.text$mn:0000227D                 push    0
.text$mn:0000227F                 mov     ecx, [ebp+var_4]
.text$mn:00002282                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)
.text$mn:00002287                 jmp     short loc_22CE
.text$mn:00002289 ; ---------------------------------------------------------------------------
.text$mn:00002289
.text$mn:00002289 loc_2289:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+40j
.text$mn:00002289                 push    0
.text$mn:0000228B                 mov     edx, [ebp+var_8]
.text$mn:0000228E                 push    edx
.text$mn:0000228F                 mov     ecx, [ebp+var_4]
.text$mn:00002292                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00002297                 movzx   eax, al
.text$mn:0000229A                 test    eax, eax
.text$mn:0000229C                 jz      short loc_22CE
.text$mn:0000229E                 mov     ecx, [ebp+var_8]
.text$mn:000022A1                 push    ecx             ; int
.text$mn:000022A2                 mov     ecx, [ebp+arg_0]
.text$mn:000022A5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000022AA                 mov     edx, [ebp+arg_4]
.text$mn:000022AD                 lea     eax, [eax+edx*2]
.text$mn:000022B0                 push    eax             ; Src
.text$mn:000022B1                 mov     ecx, [ebp+var_4]
.text$mn:000022B4                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000022B9                 push    eax             ; Dst
.text$mn:000022BA                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:000022BF                 add     esp, 0Ch
.text$mn:000022C2                 mov     ecx, [ebp+var_8]
.text$mn:000022C5                 push    ecx
.text$mn:000022C6                 mov     ecx, [ebp+var_4]
.text$mn:000022C9                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000022CE
.text$mn:000022CE loc_22CE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Fj
.text$mn:000022CE                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+74j
.text$mn:000022CE                 mov     eax, [ebp+var_4]
.text$mn:000022D1                 mov     esp, ebp
.text$mn:000022D3                 pop     ebp
.text$mn:000022D4                 retn    0Ch
.text$mn:000022D4 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:000022D4
.text$mn:000022D4 ; ---------------------------------------------------------------------------
.text$mn:000022D7                 align 4
.text$mn:000022D7 _text$mn        ends
.text$mn:000022D7
.text$mn:000022D8 ; ===========================================================================
.text$mn:000022D8
.text$mn:000022D8 ; Segment type: Pure code
.text$mn:000022D8 ; Segment permissions: Read/Execute
.text$mn:000022D8 _text$mn        segment para public 'CODE' use32
.text$mn:000022D8                 assume cs:_text$mn
.text$mn:000022D8                 ;org 22D8h
.text$mn:000022D8 ; COMDAT (pick any)
.text$mn:000022D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000022D8
.text$mn:000022D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000022D8
.text$mn:000022D8 ; Attributes: bp-based frame
.text$mn:000022D8
.text$mn:000022D8 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t *Str)
.text$mn:000022D8                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:000022D8 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:000022D8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)+Ep
.text$mn:000022D8
.text$mn:000022D8 var_4           = dword ptr -4
.text$mn:000022D8 Str             = dword ptr  8
.text$mn:000022D8
.text$mn:000022D8                 push    ebp
.text$mn:000022D9                 mov     ebp, esp
.text$mn:000022DB                 push    ecx
.text$mn:000022DC                 mov     [ebp+var_4], ecx
.text$mn:000022DF                 push    490h            ; unsigned int
.text$mn:000022E4                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000022E9                 mov     eax, [ebp+Str]
.text$mn:000022EC                 push    eax             ; int
.text$mn:000022ED                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:000022F2                 add     esp, 0Ch
.text$mn:000022F5                 mov     ecx, [ebp+Str]
.text$mn:000022F8                 push    ecx             ; Str
.text$mn:000022F9                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:000022FE                 add     esp, 4
.text$mn:00002301                 push    eax             ; int
.text$mn:00002302                 mov     edx, [ebp+Str]
.text$mn:00002305                 push    edx             ; Src
.text$mn:00002306                 mov     ecx, [ebp+var_4]
.text$mn:00002309                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)
.text$mn:0000230E                 mov     esp, ebp
.text$mn:00002310                 pop     ebp
.text$mn:00002311                 retn    4
.text$mn:00002311 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:00002311
.text$mn:00002311 _text$mn        ends
.text$mn:00002311
.text$mn:00002314 ; ===========================================================================
.text$mn:00002314
.text$mn:00002314 ; Segment type: Pure code
.text$mn:00002314 ; Segment permissions: Read/Execute
.text$mn:00002314 _text$mn        segment para public 'CODE' use32
.text$mn:00002314                 assume cs:_text$mn
.text$mn:00002314                 ;org 2314h
.text$mn:00002314 ; COMDAT (pick any)
.text$mn:00002314                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002314
.text$mn:00002314 ; =============== S U B R O U T I N E =======================================
.text$mn:00002314
.text$mn:00002314 ; Attributes: bp-based frame
.text$mn:00002314
.text$mn:00002314 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(void *Src, int)
.text$mn:00002314                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:00002314 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:00002314                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+31p
.text$mn:00002314
.text$mn:00002314 var_4           = dword ptr -4
.text$mn:00002314 Src             = dword ptr  8
.text$mn:00002314 arg_4           = dword ptr  0Ch
.text$mn:00002314
.text$mn:00002314                 push    ebp
.text$mn:00002315                 mov     ebp, esp
.text$mn:00002317                 push    ecx
.text$mn:00002318                 mov     [ebp+var_4], ecx
.text$mn:0000231B                 cmp     [ebp+arg_4], 0
.text$mn:0000231F                 jz      short loc_2337
.text$mn:00002321                 push    47Fh            ; unsigned int
.text$mn:00002326                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000232B                 mov     eax, [ebp+Src]
.text$mn:0000232E                 push    eax             ; int
.text$mn:0000232F                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00002334                 add     esp, 0Ch
.text$mn:00002337
.text$mn:00002337 loc_2337:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+Bj
.text$mn:00002337                 mov     ecx, [ebp+Src]
.text$mn:0000233A                 push    ecx
.text$mn:0000233B                 mov     ecx, [ebp+var_4]
.text$mn:0000233E                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00002343                 movzx   edx, al
.text$mn:00002346                 test    edx, edx
.text$mn:00002348                 jz      short loc_236C
.text$mn:0000234A                 mov     eax, [ebp+arg_4]
.text$mn:0000234D                 push    eax
.text$mn:0000234E                 mov     ecx, [ebp+var_4]
.text$mn:00002351                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002356                 mov     ecx, [ebp+Src]
.text$mn:00002359                 sub     ecx, eax
.text$mn:0000235B                 sar     ecx, 1
.text$mn:0000235D                 push    ecx
.text$mn:0000235E                 mov     edx, [ebp+var_4]
.text$mn:00002361                 push    edx
.text$mn:00002362                 mov     ecx, [ebp+var_4]
.text$mn:00002365                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000236A                 jmp     short loc_23A9
.text$mn:0000236C ; ---------------------------------------------------------------------------
.text$mn:0000236C
.text$mn:0000236C loc_236C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+34j
.text$mn:0000236C                 push    0
.text$mn:0000236E                 mov     eax, [ebp+arg_4]
.text$mn:00002371                 push    eax
.text$mn:00002372                 mov     ecx, [ebp+var_4]
.text$mn:00002375                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000237A                 movzx   ecx, al
.text$mn:0000237D                 test    ecx, ecx
.text$mn:0000237F                 jz      short loc_23A6
.text$mn:00002381                 mov     edx, [ebp+arg_4]
.text$mn:00002384                 push    edx             ; int
.text$mn:00002385                 mov     eax, [ebp+Src]
.text$mn:00002388                 push    eax             ; Src
.text$mn:00002389                 mov     ecx, [ebp+var_4]
.text$mn:0000238C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002391                 push    eax             ; Dst
.text$mn:00002392                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00002397                 add     esp, 0Ch
.text$mn:0000239A                 mov     ecx, [ebp+arg_4]
.text$mn:0000239D                 push    ecx
.text$mn:0000239E                 mov     ecx, [ebp+var_4]
.text$mn:000023A1                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000023A6
.text$mn:000023A6 loc_23A6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+6Bj
.text$mn:000023A6                 mov     eax, [ebp+var_4]
.text$mn:000023A9
.text$mn:000023A9 loc_23A9:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+56j
.text$mn:000023A9                 mov     esp, ebp
.text$mn:000023AB                 pop     ebp
.text$mn:000023AC                 retn    8
.text$mn:000023AC ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:000023AC
.text$mn:000023AC ; ---------------------------------------------------------------------------
.text$mn:000023AF                 align 10h
.text$mn:000023AF _text$mn        ends
.text$mn:000023AF
.text$mn:000023B0 ; ===========================================================================
.text$mn:000023B0
.text$mn:000023B0 ; Segment type: Pure code
.text$mn:000023B0 ; Segment permissions: Read/Execute
.text$mn:000023B0 _text$mn        segment para public 'CODE' use32
.text$mn:000023B0                 assume cs:_text$mn
.text$mn:000023B0                 ;org 23B0h
.text$mn:000023B0 ; COMDAT (pick any)
.text$mn:000023B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023B0
.text$mn:000023B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000023B0
.text$mn:000023B0 ; Attributes: bp-based frame
.text$mn:000023B0
.text$mn:000023B0 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:000023B0                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:000023B0 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:000023B0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:000023B0
.text$mn:000023B0 arg_0           = dword ptr  8
.text$mn:000023B0 arg_4           = dword ptr  0Ch
.text$mn:000023B0
.text$mn:000023B0                 push    ebp
.text$mn:000023B1                 mov     ebp, esp
.text$mn:000023B3                 mov     eax, [ebp+arg_0]
.text$mn:000023B6                 mov     ecx, [ebp+arg_4]
.text$mn:000023B9                 mov     dl, [ecx]
.text$mn:000023BB                 mov     [eax], dl
.text$mn:000023BD                 pop     ebp
.text$mn:000023BE                 retn
.text$mn:000023BE ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:000023BE
.text$mn:000023BE ; ---------------------------------------------------------------------------
.text$mn:000023BF                 align 10h
.text$mn:000023BF _text$mn        ends
.text$mn:000023BF
.text$mn:000023C0 ; ===========================================================================
.text$mn:000023C0
.text$mn:000023C0 ; Segment type: Pure code
.text$mn:000023C0 ; Segment permissions: Read/Execute
.text$mn:000023C0 _text$mn        segment para public 'CODE' use32
.text$mn:000023C0                 assume cs:_text$mn
.text$mn:000023C0                 ;org 23C0h
.text$mn:000023C0 ; COMDAT (pick any)
.text$mn:000023C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023C0
.text$mn:000023C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000023C0
.text$mn:000023C0 ; Attributes: bp-based frame
.text$mn:000023C0
.text$mn:000023C0 ; public: static void __cdecl std::char_traits<wchar_t>::assign(wchar_t &, wchar_t const &)
.text$mn:000023C0                 public ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
.text$mn:000023C0 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z proc near
.text$mn:000023C0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+2Bp
.text$mn:000023C0
.text$mn:000023C0 arg_0           = dword ptr  8
.text$mn:000023C0 arg_4           = dword ptr  0Ch
.text$mn:000023C0
.text$mn:000023C0                 push    ebp
.text$mn:000023C1                 mov     ebp, esp
.text$mn:000023C3                 mov     eax, [ebp+arg_0]
.text$mn:000023C6                 mov     ecx, [ebp+arg_4]
.text$mn:000023C9                 mov     dx, [ecx]
.text$mn:000023CC                 mov     [eax], dx
.text$mn:000023CF                 pop     ebp
.text$mn:000023D0                 retn
.text$mn:000023D0 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z endp
.text$mn:000023D0
.text$mn:000023D0 ; ---------------------------------------------------------------------------
.text$mn:000023D1                 align 4
.text$mn:000023D1 _text$mn        ends
.text$mn:000023D1
.text$mn:000023D4 ; ===========================================================================
.text$mn:000023D4
.text$mn:000023D4 ; Segment type: Pure code
.text$mn:000023D4 ; Segment permissions: Read/Execute
.text$mn:000023D4 _text$mn        segment para public 'CODE' use32
.text$mn:000023D4                 assume cs:_text$mn
.text$mn:000023D4                 ;org 23D4h
.text$mn:000023D4 ; COMDAT (pick any)
.text$mn:000023D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023D4
.text$mn:000023D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023D4
.text$mn:000023D4 ; Attributes: bp-based frame
.text$mn:000023D4
.text$mn:000023D4 ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:000023D4                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:000023D4 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:000023D4                                         ; CODE XREF: URLCtrl::action(void)+D7p
.text$mn:000023D4
.text$mn:000023D4 var_4           = dword ptr -4
.text$mn:000023D4
.text$mn:000023D4                 push    ebp
.text$mn:000023D5                 mov     ebp, esp
.text$mn:000023D7                 push    ecx
.text$mn:000023D8                 mov     [ebp+var_4], ecx
.text$mn:000023DB                 mov     ecx, [ebp+var_4]
.text$mn:000023DE                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000023E3                 mov     esp, ebp
.text$mn:000023E5                 pop     ebp
.text$mn:000023E6                 retn
.text$mn:000023E6 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:000023E6
.text$mn:000023E6 ; ---------------------------------------------------------------------------
.text$mn:000023E7                 align 4
.text$mn:000023E7 _text$mn        ends
.text$mn:000023E7
.text$mn:000023E8 ; ===========================================================================
.text$mn:000023E8
.text$mn:000023E8 ; Segment type: Pure code
.text$mn:000023E8 ; Segment permissions: Read/Execute
.text$mn:000023E8 _text$mn        segment para public 'CODE' use32
.text$mn:000023E8                 assume cs:_text$mn
.text$mn:000023E8                 ;org 23E8h
.text$mn:000023E8 ; COMDAT (pick any)
.text$mn:000023E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023E8
.text$mn:000023E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000023E8
.text$mn:000023E8 ; Attributes: bp-based frame
.text$mn:000023E8
.text$mn:000023E8 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:000023E8                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:000023E8 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000023E8                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:000023E8
.text$mn:000023E8 var_4           = dword ptr -4
.text$mn:000023E8
.text$mn:000023E8                 push    ebp
.text$mn:000023E9                 mov     ebp, esp
.text$mn:000023EB                 push    ecx
.text$mn:000023EC                 mov     [ebp+var_4], ecx
.text$mn:000023EF                 mov     eax, [ebp+var_4]
.text$mn:000023F2                 mov     eax, [eax+4]
.text$mn:000023F5                 mov     esp, ebp
.text$mn:000023F7                 pop     ebp
.text$mn:000023F8                 retn
.text$mn:000023F8 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:000023F8
.text$mn:000023F8 ; ---------------------------------------------------------------------------
.text$mn:000023F9                 align 4
.text$mn:000023F9 _text$mn        ends
.text$mn:000023F9
.text$mn:000023FC ; ===========================================================================
.text$mn:000023FC
.text$mn:000023FC ; Segment type: Pure code
.text$mn:000023FC ; Segment permissions: Read/Execute
.text$mn:000023FC _text$mn        segment para public 'CODE' use32
.text$mn:000023FC                 assume cs:_text$mn
.text$mn:000023FC                 ;org 23FCh
.text$mn:000023FC ; COMDAT (pick any)
.text$mn:000023FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023FC
.text$mn:000023FC ; =============== S U B R O U T I N E =======================================
.text$mn:000023FC
.text$mn:000023FC ; Attributes: bp-based frame
.text$mn:000023FC
.text$mn:000023FC ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:000023FC                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:000023FC ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000023FC                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:000023FC                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:000023FC
.text$mn:000023FC var_4           = dword ptr -4
.text$mn:000023FC
.text$mn:000023FC                 push    ebp
.text$mn:000023FD                 mov     ebp, esp
.text$mn:000023FF                 push    ecx
.text$mn:00002400                 mov     [ebp+var_4], ecx
.text$mn:00002403                 mov     eax, [ebp+var_4]
.text$mn:00002406                 mov     eax, [eax+4]
.text$mn:00002409                 mov     esp, ebp
.text$mn:0000240B                 pop     ebp
.text$mn:0000240C                 retn
.text$mn:0000240C ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:0000240C
.text$mn:0000240C ; ---------------------------------------------------------------------------
.text$mn:0000240D                 align 10h
.text$mn:0000240D _text$mn        ends
.text$mn:0000240D
.text$mn:00002410 ; ===========================================================================
.text$mn:00002410
.text$mn:00002410 ; Segment type: Pure code
.text$mn:00002410 ; Segment permissions: Read/Execute
.text$mn:00002410 _text$mn        segment para public 'CODE' use32
.text$mn:00002410                 assume cs:_text$mn
.text$mn:00002410                 ;org 2410h
.text$mn:00002410 ; COMDAT (pick any)
.text$mn:00002410                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002410
.text$mn:00002410 ; =============== S U B R O U T I N E =======================================
.text$mn:00002410
.text$mn:00002410 ; Attributes: bp-based frame
.text$mn:00002410
.text$mn:00002410 ; public: int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::compare(unsigned int, unsigned int, wchar_t const *, unsigned int)const
.text$mn:00002410                 public ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z
.text$mn:00002410 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z proc near
.text$mn:00002410                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)+3Ap
.text$mn:00002410
.text$mn:00002410 var_18          = dword ptr -18h
.text$mn:00002410 var_14          = dword ptr -14h
.text$mn:00002410 var_10          = dword ptr -10h
.text$mn:00002410 var_C           = dword ptr -0Ch
.text$mn:00002410 var_8           = dword ptr -8
.text$mn:00002410 var_4           = dword ptr -4
.text$mn:00002410 arg_0           = dword ptr  8
.text$mn:00002410 arg_4           = dword ptr  0Ch
.text$mn:00002410 arg_8           = dword ptr  10h
.text$mn:00002410 arg_C           = dword ptr  14h
.text$mn:00002410
.text$mn:00002410                 push    ebp
.text$mn:00002411                 mov     ebp, esp
.text$mn:00002413                 sub     esp, 18h
.text$mn:00002416                 mov     [ebp+var_4], ecx
.text$mn:00002419                 cmp     [ebp+arg_C], 0
.text$mn:0000241D                 jz      short loc_2435
.text$mn:0000241F                 push    87Dh            ; unsigned int
.text$mn:00002424                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002429                 mov     eax, [ebp+arg_8]
.text$mn:0000242C                 push    eax             ; int
.text$mn:0000242D                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00002432                 add     esp, 0Ch
.text$mn:00002435
.text$mn:00002435 loc_2435:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+Dj
.text$mn:00002435                 mov     ecx, [ebp+var_4]
.text$mn:00002438                 mov     edx, [ecx+14h]
.text$mn:0000243B                 cmp     edx, [ebp+arg_0]
.text$mn:0000243E                 jnb     short loc_2448
.text$mn:00002440                 mov     ecx, [ebp+var_4]
.text$mn:00002443                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00002448
.text$mn:00002448 loc_2448:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+2Ej
.text$mn:00002448                 mov     eax, [ebp+var_4]
.text$mn:0000244B                 mov     ecx, [eax+14h]
.text$mn:0000244E                 sub     ecx, [ebp+arg_0]
.text$mn:00002451                 cmp     ecx, [ebp+arg_4]
.text$mn:00002454                 jnb     short loc_2462
.text$mn:00002456                 mov     edx, [ebp+var_4]
.text$mn:00002459                 mov     eax, [edx+14h]
.text$mn:0000245C                 sub     eax, [ebp+arg_0]
.text$mn:0000245F                 mov     [ebp+arg_4], eax
.text$mn:00002462
.text$mn:00002462 loc_2462:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+44j
.text$mn:00002462                 mov     ecx, [ebp+arg_4]
.text$mn:00002465                 cmp     ecx, [ebp+arg_C]
.text$mn:00002468                 jnb     short loc_2472
.text$mn:0000246A                 mov     edx, [ebp+arg_4]
.text$mn:0000246D                 mov     [ebp+var_8], edx
.text$mn:00002470                 jmp     short loc_2478
.text$mn:00002472 ; ---------------------------------------------------------------------------
.text$mn:00002472
.text$mn:00002472 loc_2472:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+58j
.text$mn:00002472                 mov     eax, [ebp+arg_C]
.text$mn:00002475                 mov     [ebp+var_8], eax
.text$mn:00002478
.text$mn:00002478 loc_2478:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+60j
.text$mn:00002478                 mov     ecx, [ebp+var_8]
.text$mn:0000247B                 push    ecx
.text$mn:0000247C                 mov     edx, [ebp+arg_8]
.text$mn:0000247F                 push    edx
.text$mn:00002480                 mov     ecx, [ebp+var_4]
.text$mn:00002483                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002488                 mov     ecx, [ebp+arg_0]
.text$mn:0000248B                 lea     edx, [eax+ecx*2]
.text$mn:0000248E                 push    edx
.text$mn:0000248F                 call    ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z ; std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)
.text$mn:00002494                 add     esp, 0Ch
.text$mn:00002497                 mov     [ebp+var_C], eax
.text$mn:0000249A                 cmp     [ebp+var_C], 0
.text$mn:0000249E                 jz      short loc_24A8
.text$mn:000024A0                 mov     eax, [ebp+var_C]
.text$mn:000024A3                 mov     [ebp+var_18], eax
.text$mn:000024A6                 jmp     short loc_24DD
.text$mn:000024A8 ; ---------------------------------------------------------------------------
.text$mn:000024A8
.text$mn:000024A8 loc_24A8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+8Ej
.text$mn:000024A8                 mov     ecx, [ebp+arg_4]
.text$mn:000024AB                 cmp     ecx, [ebp+arg_C]
.text$mn:000024AE                 jnb     short loc_24B9
.text$mn:000024B0                 mov     [ebp+var_14], 0FFFFFFFFh
.text$mn:000024B7                 jmp     short loc_24D7
.text$mn:000024B9 ; ---------------------------------------------------------------------------
.text$mn:000024B9
.text$mn:000024B9 loc_24B9:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+9Ej
.text$mn:000024B9                 mov     edx, [ebp+arg_4]
.text$mn:000024BC                 cmp     edx, [ebp+arg_C]
.text$mn:000024BF                 jnz     short loc_24CA
.text$mn:000024C1                 mov     [ebp+var_10], 0
.text$mn:000024C8                 jmp     short loc_24D1
.text$mn:000024CA ; ---------------------------------------------------------------------------
.text$mn:000024CA
.text$mn:000024CA loc_24CA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+AFj
.text$mn:000024CA                 mov     [ebp+var_10], 1
.text$mn:000024D1
.text$mn:000024D1 loc_24D1:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+B8j
.text$mn:000024D1                 mov     eax, [ebp+var_10]
.text$mn:000024D4                 mov     [ebp+var_14], eax
.text$mn:000024D7
.text$mn:000024D7 loc_24D7:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+A7j
.text$mn:000024D7                 mov     ecx, [ebp+var_14]
.text$mn:000024DA                 mov     [ebp+var_18], ecx
.text$mn:000024DD
.text$mn:000024DD loc_24DD:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+96j
.text$mn:000024DD                 mov     eax, [ebp+var_18]
.text$mn:000024E0                 mov     esp, ebp
.text$mn:000024E2                 pop     ebp
.text$mn:000024E3                 retn    10h
.text$mn:000024E3 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z endp
.text$mn:000024E3
.text$mn:000024E3 ; ---------------------------------------------------------------------------
.text$mn:000024E6                 align 4
.text$mn:000024E6 _text$mn        ends
.text$mn:000024E6
.text$mn:000024E8 ; ===========================================================================
.text$mn:000024E8
.text$mn:000024E8 ; Segment type: Pure code
.text$mn:000024E8 ; Segment permissions: Read/Execute
.text$mn:000024E8 _text$mn        segment para public 'CODE' use32
.text$mn:000024E8                 assume cs:_text$mn
.text$mn:000024E8                 ;org 24E8h
.text$mn:000024E8 ; COMDAT (pick any)
.text$mn:000024E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000024E8
.text$mn:000024E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000024E8
.text$mn:000024E8 ; Attributes: bp-based frame
.text$mn:000024E8
.text$mn:000024E8 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t *Str)
.text$mn:000024E8                 public ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z
.text$mn:000024E8 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z proc near
.text$mn:000024E8                                         ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+Bp
.text$mn:000024E8
.text$mn:000024E8 var_4           = dword ptr -4
.text$mn:000024E8 Str             = dword ptr  8
.text$mn:000024E8
.text$mn:000024E8                 push    ebp
.text$mn:000024E9                 mov     ebp, esp
.text$mn:000024EB                 push    ecx
.text$mn:000024EC                 mov     [ebp+var_4], ecx
.text$mn:000024EF                 push    86Eh            ; unsigned int
.text$mn:000024F4                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000024F9                 mov     eax, [ebp+Str]
.text$mn:000024FC                 push    eax             ; int
.text$mn:000024FD                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00002502                 add     esp, 0Ch
.text$mn:00002505                 mov     ecx, [ebp+Str]
.text$mn:00002508                 push    ecx             ; Str
.text$mn:00002509                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:0000250E                 add     esp, 4
.text$mn:00002511                 push    eax
.text$mn:00002512                 mov     edx, [ebp+Str]
.text$mn:00002515                 push    edx
.text$mn:00002516                 mov     eax, [ebp+var_4]
.text$mn:00002519                 mov     ecx, [eax+14h]
.text$mn:0000251C                 push    ecx
.text$mn:0000251D                 push    0
.text$mn:0000251F                 mov     ecx, [ebp+var_4]
.text$mn:00002522                 call    ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)
.text$mn:00002527                 mov     esp, ebp
.text$mn:00002529                 pop     ebp
.text$mn:0000252A                 retn    4
.text$mn:0000252A ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z endp
.text$mn:0000252A
.text$mn:0000252A ; ---------------------------------------------------------------------------
.text$mn:0000252D                 align 10h
.text$mn:0000252D _text$mn        ends
.text$mn:0000252D
.text$mn:00002530 ; ===========================================================================
.text$mn:00002530
.text$mn:00002530 ; Segment type: Pure code
.text$mn:00002530 ; Segment permissions: Read/Execute
.text$mn:00002530 _text$mn        segment para public 'CODE' use32
.text$mn:00002530                 assume cs:_text$mn
.text$mn:00002530                 ;org 2530h
.text$mn:00002530 ; COMDAT (pick any)
.text$mn:00002530                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002530
.text$mn:00002530 ; =============== S U B R O U T I N E =======================================
.text$mn:00002530
.text$mn:00002530 ; Attributes: bp-based frame
.text$mn:00002530
.text$mn:00002530 ; public: static int __cdecl std::char_traits<wchar_t>::compare(wchar_t const *, wchar_t const *, unsigned int)
.text$mn:00002530                 public ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z
.text$mn:00002530 ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z proc near
.text$mn:00002530                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+7Fp
.text$mn:00002530
.text$mn:00002530 var_4           = dword ptr -4
.text$mn:00002530 arg_0           = dword ptr  8
.text$mn:00002530 arg_4           = dword ptr  0Ch
.text$mn:00002530 arg_8           = dword ptr  10h
.text$mn:00002530
.text$mn:00002530                 push    ebp
.text$mn:00002531                 mov     ebp, esp
.text$mn:00002533                 push    ecx
.text$mn:00002534                 cmp     [ebp+arg_8], 0
.text$mn:00002538                 jnz     short loc_2543
.text$mn:0000253A                 mov     [ebp+var_4], 0
.text$mn:00002541                 jmp     short loc_255A
.text$mn:00002543 ; ---------------------------------------------------------------------------
.text$mn:00002543
.text$mn:00002543 loc_2543:                               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+8j
.text$mn:00002543                 mov     eax, [ebp+arg_8]
.text$mn:00002546                 push    eax
.text$mn:00002547                 mov     ecx, [ebp+arg_4]
.text$mn:0000254A                 push    ecx
.text$mn:0000254B                 mov     edx, [ebp+arg_0]
.text$mn:0000254E                 push    edx
.text$mn:0000254F                 call    _wmemcmp
.text$mn:00002554                 add     esp, 0Ch
.text$mn:00002557                 mov     [ebp+var_4], eax
.text$mn:0000255A
.text$mn:0000255A loc_255A:                               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+11j
.text$mn:0000255A                 mov     eax, [ebp+var_4]
.text$mn:0000255D                 mov     esp, ebp
.text$mn:0000255F                 pop     ebp
.text$mn:00002560                 retn
.text$mn:00002560 ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z endp
.text$mn:00002560
.text$mn:00002560 ; ---------------------------------------------------------------------------
.text$mn:00002561                 align 4
.text$mn:00002561 _text$mn        ends
.text$mn:00002561
.text$mn:00002564 ; ===========================================================================
.text$mn:00002564
.text$mn:00002564 ; Segment type: Pure code
.text$mn:00002564 ; Segment permissions: Read/Execute
.text$mn:00002564 _text$mn        segment para public 'CODE' use32
.text$mn:00002564                 assume cs:_text$mn
.text$mn:00002564                 ;org 2564h
.text$mn:00002564 ; COMDAT (pick any)
.text$mn:00002564                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002564
.text$mn:00002564 ; =============== S U B R O U T I N E =======================================
.text$mn:00002564
.text$mn:00002564 ; Attributes: bp-based frame
.text$mn:00002564
.text$mn:00002564 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00002564                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00002564 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00002564                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00002564
.text$mn:00002564 var_4           = dword ptr -4
.text$mn:00002564 Dst             = dword ptr  8
.text$mn:00002564 Src             = dword ptr  0Ch
.text$mn:00002564 Size            = dword ptr  10h
.text$mn:00002564
.text$mn:00002564                 push    ebp
.text$mn:00002565                 mov     ebp, esp
.text$mn:00002567                 push    ecx
.text$mn:00002568                 cmp     [ebp+Size], 0
.text$mn:0000256C                 jnz     short loc_2576
.text$mn:0000256E                 mov     eax, [ebp+Dst]
.text$mn:00002571                 mov     [ebp+var_4], eax
.text$mn:00002574                 jmp     short loc_258D
.text$mn:00002576 ; ---------------------------------------------------------------------------
.text$mn:00002576
.text$mn:00002576 loc_2576:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00002576                 mov     ecx, [ebp+Size]
.text$mn:00002579                 push    ecx             ; Size
.text$mn:0000257A                 mov     edx, [ebp+Src]
.text$mn:0000257D                 push    edx             ; Src
.text$mn:0000257E                 mov     eax, [ebp+Dst]
.text$mn:00002581                 push    eax             ; Dst
.text$mn:00002582                 call    _memcpy
.text$mn:00002587                 add     esp, 0Ch
.text$mn:0000258A                 mov     [ebp+var_4], eax
.text$mn:0000258D
.text$mn:0000258D loc_258D:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:0000258D                 mov     eax, [ebp+var_4]
.text$mn:00002590                 mov     esp, ebp
.text$mn:00002592                 pop     ebp
.text$mn:00002593                 retn
.text$mn:00002593 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00002593
.text$mn:00002593 _text$mn        ends
.text$mn:00002593
.text$mn:00002594 ; ===========================================================================
.text$mn:00002594
.text$mn:00002594 ; Segment type: Pure code
.text$mn:00002594 ; Segment permissions: Read/Execute
.text$mn:00002594 _text$mn        segment para public 'CODE' use32
.text$mn:00002594                 assume cs:_text$mn
.text$mn:00002594                 ;org 2594h
.text$mn:00002594 ; COMDAT (pick any)
.text$mn:00002594                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002594
.text$mn:00002594 ; =============== S U B R O U T I N E =======================================
.text$mn:00002594
.text$mn:00002594 ; Attributes: bp-based frame
.text$mn:00002594
.text$mn:00002594 ; int __cdecl std::char_traits<wchar_t>::copy(void *Dst, void *Src, int)
.text$mn:00002594                 public ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:00002594 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:00002594                                         ; CODE XREF: $LN19_0+1Ep
.text$mn:00002594                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00002594
.text$mn:00002594 var_4           = dword ptr -4
.text$mn:00002594 Dst             = dword ptr  8
.text$mn:00002594 Src             = dword ptr  0Ch
.text$mn:00002594 arg_8           = dword ptr  10h
.text$mn:00002594
.text$mn:00002594                 push    ebp
.text$mn:00002595                 mov     ebp, esp
.text$mn:00002597                 push    ecx
.text$mn:00002598                 cmp     [ebp+arg_8], 0
.text$mn:0000259C                 jnz     short loc_25A6
.text$mn:0000259E                 mov     eax, [ebp+Dst]
.text$mn:000025A1                 mov     [ebp+var_4], eax
.text$mn:000025A4                 jmp     short loc_25BD
.text$mn:000025A6 ; ---------------------------------------------------------------------------
.text$mn:000025A6
.text$mn:000025A6 loc_25A6:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+8j
.text$mn:000025A6                 mov     ecx, [ebp+arg_8]
.text$mn:000025A9                 push    ecx             ; int
.text$mn:000025AA                 mov     edx, [ebp+Src]
.text$mn:000025AD                 push    edx             ; Src
.text$mn:000025AE                 mov     eax, [ebp+Dst]
.text$mn:000025B1                 push    eax             ; Dst
.text$mn:000025B2                 call    _wmemcpy
.text$mn:000025B7                 add     esp, 0Ch
.text$mn:000025BA                 mov     [ebp+var_4], eax
.text$mn:000025BD
.text$mn:000025BD loc_25BD:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+10j
.text$mn:000025BD                 mov     eax, [ebp+var_4]
.text$mn:000025C0                 mov     esp, ebp
.text$mn:000025C2                 pop     ebp
.text$mn:000025C3                 retn
.text$mn:000025C3 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:000025C3
.text$mn:000025C3 _text$mn        ends
.text$mn:000025C3
.text$mn:000025C4 ; ===========================================================================
.text$mn:000025C4
.text$mn:000025C4 ; Segment type: Pure code
.text$mn:000025C4 ; Segment permissions: Read/Execute
.text$mn:000025C4 _text$mn        segment para public 'CODE' use32
.text$mn:000025C4                 assume cs:_text$mn
.text$mn:000025C4                 ;org 25C4h
.text$mn:000025C4 ; COMDAT (pick any)
.text$mn:000025C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000025C4
.text$mn:000025C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000025C4
.text$mn:000025C4 ; Attributes: bp-based frame
.text$mn:000025C4
.text$mn:000025C4 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:000025C4                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:000025C4 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:000025C4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:000025C4
.text$mn:000025C4 var_4           = dword ptr -4
.text$mn:000025C4 arg_0           = dword ptr  8
.text$mn:000025C4 arg_4           = dword ptr  0Ch
.text$mn:000025C4
.text$mn:000025C4                 push    ebp
.text$mn:000025C5                 mov     ebp, esp
.text$mn:000025C7                 push    ecx
.text$mn:000025C8                 mov     [ebp+var_4], ecx
.text$mn:000025CB                 mov     eax, [ebp+arg_4]
.text$mn:000025CE                 push    eax             ; int
.text$mn:000025CF                 mov     ecx, [ebp+arg_0]
.text$mn:000025D2                 push    ecx             ; void *
.text$mn:000025D3                 mov     ecx, [ebp+var_4]
.text$mn:000025D6                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:000025DB                 mov     esp, ebp
.text$mn:000025DD                 pop     ebp
.text$mn:000025DE                 retn    8
.text$mn:000025DE ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:000025DE
.text$mn:000025DE ; ---------------------------------------------------------------------------
.text$mn:000025E1                 align 4
.text$mn:000025E1 _text$mn        ends
.text$mn:000025E1
.text$mn:000025E4 ; ===========================================================================
.text$mn:000025E4
.text$mn:000025E4 ; Segment type: Pure code
.text$mn:000025E4 ; Segment permissions: Read/Execute
.text$mn:000025E4 _text$mn        segment para public 'CODE' use32
.text$mn:000025E4                 assume cs:_text$mn
.text$mn:000025E4                 ;org 25E4h
.text$mn:000025E4 ; COMDAT (pick any)
.text$mn:000025E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000025E4
.text$mn:000025E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000025E4
.text$mn:000025E4 ; Attributes: bp-based frame
.text$mn:000025E4
.text$mn:000025E4 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(void *, int)
.text$mn:000025E4                 public ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
.text$mn:000025E4 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z proc near
.text$mn:000025E4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+81p
.text$mn:000025E4
.text$mn:000025E4 var_4           = dword ptr -4
.text$mn:000025E4 arg_0           = dword ptr  8
.text$mn:000025E4 arg_4           = dword ptr  0Ch
.text$mn:000025E4
.text$mn:000025E4                 push    ebp
.text$mn:000025E5                 mov     ebp, esp
.text$mn:000025E7                 push    ecx
.text$mn:000025E8                 mov     [ebp+var_4], ecx
.text$mn:000025EB                 mov     eax, [ebp+arg_4]
.text$mn:000025EE                 push    eax             ; int
.text$mn:000025EF                 mov     ecx, [ebp+arg_0]
.text$mn:000025F2                 push    ecx             ; void *
.text$mn:000025F3                 mov     ecx, [ebp+var_4]
.text$mn:000025F6                 call    ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate(wchar_t *,uint)
.text$mn:000025FB                 mov     esp, ebp
.text$mn:000025FD                 pop     ebp
.text$mn:000025FE                 retn    8
.text$mn:000025FE ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z endp
.text$mn:000025FE
.text$mn:000025FE ; ---------------------------------------------------------------------------
.text$mn:00002601                 align 4
.text$mn:00002601 _text$mn        ends
.text$mn:00002601
.text$mn:00002604 ; ===========================================================================
.text$mn:00002604
.text$mn:00002604 ; Segment type: Pure code
.text$mn:00002604 ; Segment permissions: Read/Execute
.text$mn:00002604 _text$mn        segment para public 'CODE' use32
.text$mn:00002604                 assume cs:_text$mn
.text$mn:00002604                 ;org 2604h
.text$mn:00002604 ; COMDAT (pick any)
.text$mn:00002604                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002604
.text$mn:00002604 ; =============== S U B R O U T I N E =======================================
.text$mn:00002604
.text$mn:00002604 ; Attributes: bp-based frame
.text$mn:00002604
.text$mn:00002604 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00002604                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00002604 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00002604                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00002604
.text$mn:00002604 var_4           = dword ptr -4
.text$mn:00002604 arg_0           = dword ptr  8
.text$mn:00002604
.text$mn:00002604                 push    ebp
.text$mn:00002605                 mov     ebp, esp
.text$mn:00002607                 push    ecx
.text$mn:00002608                 mov     [ebp+var_4], ecx
.text$mn:0000260B                 mov     eax, [ebp+arg_0]
.text$mn:0000260E                 push    eax             ; void *
.text$mn:0000260F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002614                 add     esp, 4
.text$mn:00002617                 mov     esp, ebp
.text$mn:00002619                 pop     ebp
.text$mn:0000261A                 retn    8
.text$mn:0000261A ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:0000261A
.text$mn:0000261A ; ---------------------------------------------------------------------------
.text$mn:0000261D                 align 10h
.text$mn:0000261D _text$mn        ends
.text$mn:0000261D
.text$mn:00002620 ; ===========================================================================
.text$mn:00002620
.text$mn:00002620 ; Segment type: Pure code
.text$mn:00002620 ; Segment permissions: Read/Execute
.text$mn:00002620 _text$mn        segment para public 'CODE' use32
.text$mn:00002620                 assume cs:_text$mn
.text$mn:00002620                 ;org 2620h
.text$mn:00002620 ; COMDAT (pick any)
.text$mn:00002620                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002620
.text$mn:00002620 ; =============== S U B R O U T I N E =======================================
.text$mn:00002620
.text$mn:00002620 ; Attributes: bp-based frame
.text$mn:00002620
.text$mn:00002620 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00002620                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00002620 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00002620                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00002620
.text$mn:00002620 var_4           = dword ptr -4
.text$mn:00002620 arg_0           = dword ptr  8
.text$mn:00002620
.text$mn:00002620                 push    ebp
.text$mn:00002621                 mov     ebp, esp
.text$mn:00002623                 push    ecx
.text$mn:00002624                 mov     [ebp+var_4], ecx
.text$mn:00002627                 mov     eax, [ebp+arg_0]
.text$mn:0000262A                 push    eax             ; void *
.text$mn:0000262B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002630                 add     esp, 4
.text$mn:00002633                 mov     esp, ebp
.text$mn:00002635                 pop     ebp
.text$mn:00002636                 retn    8
.text$mn:00002636 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00002636
.text$mn:00002636 ; ---------------------------------------------------------------------------
.text$mn:00002639                 align 4
.text$mn:00002639 _text$mn        ends
.text$mn:00002639
.text$mn:0000263C ; ===========================================================================
.text$mn:0000263C
.text$mn:0000263C ; Segment type: Pure code
.text$mn:0000263C ; Segment permissions: Read/Execute
.text$mn:0000263C _text$mn        segment para public 'CODE' use32
.text$mn:0000263C                 assume cs:_text$mn
.text$mn:0000263C                 ;org 263Ch
.text$mn:0000263C ; COMDAT (pick any)
.text$mn:0000263C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000263C
.text$mn:0000263C ; =============== S U B R O U T I N E =======================================
.text$mn:0000263C
.text$mn:0000263C ; Attributes: bp-based frame
.text$mn:0000263C
.text$mn:0000263C ; int __stdcall std::allocator<wchar_t>::deallocate(void *, int)
.text$mn:0000263C                 public ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
.text$mn:0000263C ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z proc near
.text$mn:0000263C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)+12p
.text$mn:0000263C
.text$mn:0000263C var_4           = dword ptr -4
.text$mn:0000263C arg_0           = dword ptr  8
.text$mn:0000263C
.text$mn:0000263C                 push    ebp
.text$mn:0000263D                 mov     ebp, esp
.text$mn:0000263F                 push    ecx
.text$mn:00002640                 mov     [ebp+var_4], ecx
.text$mn:00002643                 mov     eax, [ebp+arg_0]
.text$mn:00002646                 push    eax             ; void *
.text$mn:00002647                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000264C                 add     esp, 4
.text$mn:0000264F                 mov     esp, ebp
.text$mn:00002651                 pop     ebp
.text$mn:00002652                 retn    8
.text$mn:00002652 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z endp
.text$mn:00002652
.text$mn:00002652 ; ---------------------------------------------------------------------------
.text$mn:00002655                 align 4
.text$mn:00002655 _text$mn        ends
.text$mn:00002655
.text$mn:00002658 ; ===========================================================================
.text$mn:00002658
.text$mn:00002658 ; Segment type: Pure code
.text$mn:00002658 ; Segment permissions: Read/Execute
.text$mn:00002658 _text$mn        segment para public 'CODE' use32
.text$mn:00002658                 assume cs:_text$mn
.text$mn:00002658                 ;org 2658h
.text$mn:00002658 ; COMDAT (pick any)
.text$mn:00002658                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002658
.text$mn:00002658 ; =============== S U B R O U T I N E =======================================
.text$mn:00002658
.text$mn:00002658 ; Attributes: bp-based frame
.text$mn:00002658
.text$mn:00002658 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00002658                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00002658 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00002658                                         ; DATA XREF: .rdata:000032ECo
.text$mn:00002658
.text$mn:00002658 var_4           = dword ptr -4
.text$mn:00002658 arg_0           = dword ptr  8
.text$mn:00002658 arg_4           = dword ptr  0Ch
.text$mn:00002658
.text$mn:00002658                 push    ebp
.text$mn:00002659                 mov     ebp, esp
.text$mn:0000265B                 push    ecx
.text$mn:0000265C                 mov     [ebp+var_4], ecx
.text$mn:0000265F                 mov     eax, [ebp+arg_4]
.text$mn:00002662                 push    eax             ; int
.text$mn:00002663                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00002668                 add     esp, 4
.text$mn:0000266B                 test    eax, eax
.text$mn:0000266D                 jz      short loc_2688
.text$mn:0000266F                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00002674                 push    eax             ; struct std::error_category *
.text$mn:00002675                 mov     ecx, [ebp+arg_4]
.text$mn:00002678                 push    ecx             ; int
.text$mn:00002679                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000267C                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00002681                 mov     eax, [ebp+arg_0]
.text$mn:00002684                 jmp     short loc_269D
.text$mn:00002686 ; ---------------------------------------------------------------------------
.text$mn:00002686                 jmp     short loc_269D
.text$mn:00002688 ; ---------------------------------------------------------------------------
.text$mn:00002688
.text$mn:00002688 loc_2688:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00002688                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:0000268D                 push    eax             ; struct std::error_category *
.text$mn:0000268E                 mov     edx, [ebp+arg_4]
.text$mn:00002691                 push    edx             ; int
.text$mn:00002692                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002695                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000269A                 mov     eax, [ebp+arg_0]
.text$mn:0000269D
.text$mn:0000269D loc_269D:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:0000269D                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:0000269D                 mov     esp, ebp
.text$mn:0000269F                 pop     ebp
.text$mn:000026A0                 retn    8
.text$mn:000026A0 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000026A0
.text$mn:000026A0 ; ---------------------------------------------------------------------------
.text$mn:000026A3                 align 4
.text$mn:000026A3 _text$mn        ends
.text$mn:000026A3
.text$mn:000026A4 ; ===========================================================================
.text$mn:000026A4
.text$mn:000026A4 ; Segment type: Pure code
.text$mn:000026A4 ; Segment permissions: Read/Execute
.text$mn:000026A4 _text$mn        segment para public 'CODE' use32
.text$mn:000026A4                 assume cs:_text$mn
.text$mn:000026A4                 ;org 26A4h
.text$mn:000026A4 ; COMDAT (pick any)
.text$mn:000026A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000026A4
.text$mn:000026A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000026A4
.text$mn:000026A4 ; Attributes: bp-based frame
.text$mn:000026A4
.text$mn:000026A4 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:000026A4                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:000026A4 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:000026A4                                         ; DATA XREF: .rdata:0000325Co
.text$mn:000026A4                                         ; .rdata:00003278o ...
.text$mn:000026A4
.text$mn:000026A4 var_4           = dword ptr -4
.text$mn:000026A4 arg_0           = dword ptr  8
.text$mn:000026A4 arg_4           = dword ptr  0Ch
.text$mn:000026A4
.text$mn:000026A4                 push    ebp
.text$mn:000026A5                 mov     ebp, esp
.text$mn:000026A7                 push    ecx
.text$mn:000026A8                 mov     [ebp+var_4], ecx
.text$mn:000026AB                 mov     eax, [ebp+var_4]
.text$mn:000026AE                 push    eax             ; struct std::error_category *
.text$mn:000026AF                 mov     ecx, [ebp+arg_4]
.text$mn:000026B2                 push    ecx             ; int
.text$mn:000026B3                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000026B6                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000026BB                 mov     eax, [ebp+arg_0]
.text$mn:000026BE                 mov     esp, ebp
.text$mn:000026C0                 pop     ebp
.text$mn:000026C1                 retn    8
.text$mn:000026C1 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000026C1
.text$mn:000026C1 _text$mn        ends
.text$mn:000026C1
.text$mn:000026C4 ; ===========================================================================
.text$mn:000026C4
.text$mn:000026C4 ; Segment type: Pure code
.text$mn:000026C4 ; Segment permissions: Read/Execute
.text$mn:000026C4 _text$mn        segment para public 'CODE' use32
.text$mn:000026C4                 assume cs:_text$mn
.text$mn:000026C4                 ;org 26C4h
.text$mn:000026C4 ; COMDAT (pick any)
.text$mn:000026C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000026C4
.text$mn:000026C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000026C4
.text$mn:000026C4 ; Attributes: bp-based frame
.text$mn:000026C4
.text$mn:000026C4 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:000026C4                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:000026C4 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:000026C4                                         ; DATA XREF: .rdata:00003260o
.text$mn:000026C4                                         ; .rdata:0000327Co ...
.text$mn:000026C4
.text$mn:000026C4 var_8           = dword ptr -8
.text$mn:000026C4 var_4           = dword ptr -4
.text$mn:000026C4 arg_0           = dword ptr  8
.text$mn:000026C4 arg_4           = dword ptr  0Ch
.text$mn:000026C4
.text$mn:000026C4                 push    ebp
.text$mn:000026C5                 mov     ebp, esp
.text$mn:000026C7                 sub     esp, 8
.text$mn:000026CA                 mov     [ebp+var_8], ecx
.text$mn:000026CD                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000026D0                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:000026D5                 push    eax
.text$mn:000026D6                 mov     ecx, [ebp+var_8]
.text$mn:000026D9                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:000026DE                 movzx   eax, al
.text$mn:000026E1                 test    eax, eax
.text$mn:000026E3                 jz      short loc_26FB
.text$mn:000026E5                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000026E8                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:000026ED                 cmp     eax, [ebp+arg_4]
.text$mn:000026F0                 jnz     short loc_26FB
.text$mn:000026F2                 mov     [ebp+var_4], 1
.text$mn:000026F9                 jmp     short loc_2702
.text$mn:000026FB ; ---------------------------------------------------------------------------
.text$mn:000026FB
.text$mn:000026FB loc_26FB:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:000026FB                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:000026FB                 mov     [ebp+var_4], 0
.text$mn:00002702
.text$mn:00002702 loc_2702:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00002702                 mov     al, byte ptr [ebp+var_4]
.text$mn:00002705                 mov     esp, ebp
.text$mn:00002707                 pop     ebp
.text$mn:00002708                 retn    8
.text$mn:00002708 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00002708
.text$mn:00002708 ; ---------------------------------------------------------------------------
.text$mn:0000270B                 align 4
.text$mn:0000270B _text$mn        ends
.text$mn:0000270B
.text$mn:0000270C ; ===========================================================================
.text$mn:0000270C
.text$mn:0000270C ; Segment type: Pure code
.text$mn:0000270C ; Segment permissions: Read/Execute
.text$mn:0000270C _text$mn        segment para public 'CODE' use32
.text$mn:0000270C                 assume cs:_text$mn
.text$mn:0000270C                 ;org 270Ch
.text$mn:0000270C ; COMDAT (pick any)
.text$mn:0000270C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000270C
.text$mn:0000270C ; =============== S U B R O U T I N E =======================================
.text$mn:0000270C
.text$mn:0000270C ; Attributes: bp-based frame
.text$mn:0000270C
.text$mn:0000270C ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:0000270C                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:0000270C ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:0000270C                                         ; DATA XREF: .rdata:00003264o
.text$mn:0000270C                                         ; .rdata:00003280o ...
.text$mn:0000270C
.text$mn:0000270C var_C           = byte ptr -0Ch
.text$mn:0000270C var_4           = dword ptr -4
.text$mn:0000270C arg_0           = dword ptr  8
.text$mn:0000270C arg_4           = dword ptr  0Ch
.text$mn:0000270C
.text$mn:0000270C                 push    ebp
.text$mn:0000270D                 mov     ebp, esp
.text$mn:0000270F                 sub     esp, 0Ch
.text$mn:00002712                 mov     [ebp+var_4], ecx
.text$mn:00002715                 mov     eax, [ebp+arg_4]
.text$mn:00002718                 push    eax             ; std::error_condition *
.text$mn:00002719                 mov     ecx, [ebp+arg_0]
.text$mn:0000271C                 push    ecx
.text$mn:0000271D                 lea     edx, [ebp+var_C]
.text$mn:00002720                 push    edx
.text$mn:00002721                 mov     eax, [ebp+var_4]
.text$mn:00002724                 mov     edx, [eax]
.text$mn:00002726                 mov     ecx, [ebp+var_4]
.text$mn:00002729                 mov     eax, [edx+0Ch]
.text$mn:0000272C                 call    eax
.text$mn:0000272E                 mov     ecx, eax
.text$mn:00002730                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00002735                 mov     esp, ebp
.text$mn:00002737                 pop     ebp
.text$mn:00002738                 retn    8
.text$mn:00002738 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00002738
.text$mn:00002738 ; ---------------------------------------------------------------------------
.text$mn:0000273B                 align 4
.text$mn:0000273B _text$mn        ends
.text$mn:0000273B
.text$mn:0000273C ; ===========================================================================
.text$mn:0000273C
.text$mn:0000273C ; Segment type: Pure code
.text$mn:0000273C ; Segment permissions: Read/Execute
.text$mn:0000273C _text$mn        segment para public 'CODE' use32
.text$mn:0000273C                 assume cs:_text$mn
.text$mn:0000273C                 ;org 273Ch
.text$mn:0000273C ; COMDAT (pick any)
.text$mn:0000273C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000273C
.text$mn:0000273C ; =============== S U B R O U T I N E =======================================
.text$mn:0000273C
.text$mn:0000273C ; Attributes: bp-based frame
.text$mn:0000273C
.text$mn:0000273C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:0000273C                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:0000273C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:0000273C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:0000273C
.text$mn:0000273C var_4           = dword ptr -4
.text$mn:0000273C arg_0           = dword ptr  8
.text$mn:0000273C
.text$mn:0000273C                 push    ebp
.text$mn:0000273D                 mov     ebp, esp
.text$mn:0000273F                 push    ecx
.text$mn:00002740                 mov     [ebp+var_4], ecx
.text$mn:00002743                 mov     eax, [ebp+var_4]
.text$mn:00002746                 mov     ecx, [eax+14h]
.text$mn:00002749                 cmp     ecx, [ebp+arg_0]
.text$mn:0000274C                 jnb     short loc_2756
.text$mn:0000274E                 mov     ecx, [ebp+var_4]
.text$mn:00002751                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002756
.text$mn:00002756 loc_2756:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00002756                 mov     edx, [ebp+arg_0]
.text$mn:00002759                 push    edx
.text$mn:0000275A                 mov     ecx, [ebp+var_4]
.text$mn:0000275D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002762                 mov     eax, [ebp+var_4]
.text$mn:00002765                 mov     esp, ebp
.text$mn:00002767                 pop     ebp
.text$mn:00002768                 retn    4
.text$mn:00002768 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00002768
.text$mn:00002768 ; ---------------------------------------------------------------------------
.text$mn:0000276B                 align 4
.text$mn:0000276B _text$mn        ends
.text$mn:0000276B
.text$mn:0000276C ; ===========================================================================
.text$mn:0000276C
.text$mn:0000276C ; Segment type: Pure code
.text$mn:0000276C ; Segment permissions: Read/Execute
.text$mn:0000276C _text$mn        segment para public 'CODE' use32
.text$mn:0000276C                 assume cs:_text$mn
.text$mn:0000276C                 ;org 276Ch
.text$mn:0000276C ; COMDAT (pick any)
.text$mn:0000276C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000276C
.text$mn:0000276C ; =============== S U B R O U T I N E =======================================
.text$mn:0000276C
.text$mn:0000276C ; Attributes: bp-based frame
.text$mn:0000276C
.text$mn:0000276C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:0000276C                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:0000276C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:0000276C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:0000276C
.text$mn:0000276C var_C           = dword ptr -0Ch
.text$mn:0000276C Dst             = dword ptr -8
.text$mn:0000276C var_4           = dword ptr -4
.text$mn:0000276C arg_0           = dword ptr  8
.text$mn:0000276C arg_4           = dword ptr  0Ch
.text$mn:0000276C
.text$mn:0000276C                 push    ebp
.text$mn:0000276D                 mov     ebp, esp
.text$mn:0000276F                 sub     esp, 0Ch
.text$mn:00002772                 mov     [ebp+var_4], ecx
.text$mn:00002775                 mov     eax, [ebp+var_4]
.text$mn:00002778                 mov     ecx, [eax+14h]
.text$mn:0000277B                 cmp     ecx, [ebp+arg_0]
.text$mn:0000277E                 jnb     short loc_2788
.text$mn:00002780                 mov     ecx, [ebp+var_4]
.text$mn:00002783                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002788
.text$mn:00002788 loc_2788:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00002788                 mov     edx, [ebp+var_4]
.text$mn:0000278B                 mov     eax, [edx+14h]
.text$mn:0000278E                 sub     eax, [ebp+arg_0]
.text$mn:00002791                 cmp     eax, [ebp+arg_4]
.text$mn:00002794                 ja      short loc_27A4
.text$mn:00002796                 mov     ecx, [ebp+arg_0]
.text$mn:00002799                 push    ecx
.text$mn:0000279A                 mov     ecx, [ebp+var_4]
.text$mn:0000279D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000027A2                 jmp     short loc_27EA
.text$mn:000027A4 ; ---------------------------------------------------------------------------
.text$mn:000027A4
.text$mn:000027A4 loc_27A4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:000027A4                 cmp     [ebp+arg_4], 0
.text$mn:000027A8                 jbe     short loc_27EA
.text$mn:000027AA                 mov     ecx, [ebp+var_4]
.text$mn:000027AD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000027B2                 add     eax, [ebp+arg_0]
.text$mn:000027B5                 mov     [ebp+Dst], eax
.text$mn:000027B8                 mov     edx, [ebp+var_4]
.text$mn:000027BB                 mov     eax, [edx+14h]
.text$mn:000027BE                 sub     eax, [ebp+arg_4]
.text$mn:000027C1                 mov     [ebp+var_C], eax
.text$mn:000027C4                 mov     ecx, [ebp+var_C]
.text$mn:000027C7                 sub     ecx, [ebp+arg_0]
.text$mn:000027CA                 push    ecx             ; Size
.text$mn:000027CB                 mov     edx, [ebp+Dst]
.text$mn:000027CE                 add     edx, [ebp+arg_4]
.text$mn:000027D1                 push    edx             ; Src
.text$mn:000027D2                 mov     eax, [ebp+Dst]
.text$mn:000027D5                 push    eax             ; Dst
.text$mn:000027D6                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:000027DB                 add     esp, 0Ch
.text$mn:000027DE                 mov     ecx, [ebp+var_C]
.text$mn:000027E1                 push    ecx
.text$mn:000027E2                 mov     ecx, [ebp+var_4]
.text$mn:000027E5                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000027EA
.text$mn:000027EA loc_27EA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:000027EA                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:000027EA                 mov     eax, [ebp+var_4]
.text$mn:000027ED                 mov     esp, ebp
.text$mn:000027EF                 pop     ebp
.text$mn:000027F0                 retn    8
.text$mn:000027F0 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:000027F0
.text$mn:000027F0 ; ---------------------------------------------------------------------------
.text$mn:000027F3                 align 4
.text$mn:000027F3 _text$mn        ends
.text$mn:000027F3
.text$mn:000027F4 ; ===========================================================================
.text$mn:000027F4
.text$mn:000027F4 ; Segment type: Pure code
.text$mn:000027F4 ; Segment permissions: Read/Execute
.text$mn:000027F4 _text$mn        segment para public 'CODE' use32
.text$mn:000027F4                 assume cs:_text$mn
.text$mn:000027F4                 ;org 27F4h
.text$mn:000027F4 ; COMDAT (pick any)
.text$mn:000027F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027F4
.text$mn:000027F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000027F4
.text$mn:000027F4 ; Attributes: bp-based frame
.text$mn:000027F4
.text$mn:000027F4 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int)
.text$mn:000027F4                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
.text$mn:000027F4 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z proc near
.text$mn:000027F4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Cp
.text$mn:000027F4
.text$mn:000027F4 var_4           = dword ptr -4
.text$mn:000027F4 arg_0           = dword ptr  8
.text$mn:000027F4
.text$mn:000027F4                 push    ebp
.text$mn:000027F5                 mov     ebp, esp
.text$mn:000027F7                 push    ecx
.text$mn:000027F8                 mov     [ebp+var_4], ecx
.text$mn:000027FB                 mov     eax, [ebp+var_4]
.text$mn:000027FE                 mov     ecx, [eax+14h]
.text$mn:00002801                 cmp     ecx, [ebp+arg_0]
.text$mn:00002804                 jnb     short loc_280E
.text$mn:00002806                 mov     ecx, [ebp+var_4]
.text$mn:00002809                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000280E
.text$mn:0000280E loc_280E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+10j
.text$mn:0000280E                 mov     edx, [ebp+arg_0]
.text$mn:00002811                 push    edx
.text$mn:00002812                 mov     ecx, [ebp+var_4]
.text$mn:00002815                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000281A                 mov     eax, [ebp+var_4]
.text$mn:0000281D                 mov     esp, ebp
.text$mn:0000281F                 pop     ebp
.text$mn:00002820                 retn    4
.text$mn:00002820 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z endp
.text$mn:00002820
.text$mn:00002820 ; ---------------------------------------------------------------------------
.text$mn:00002823                 align 4
.text$mn:00002823 _text$mn        ends
.text$mn:00002823
.text$mn:00002824 ; ===========================================================================
.text$mn:00002824
.text$mn:00002824 ; Segment type: Pure code
.text$mn:00002824 ; Segment permissions: Read/Execute
.text$mn:00002824 _text$mn        segment para public 'CODE' use32
.text$mn:00002824                 assume cs:_text$mn
.text$mn:00002824                 ;org 2824h
.text$mn:00002824 ; COMDAT (pick any)
.text$mn:00002824                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002824
.text$mn:00002824 ; =============== S U B R O U T I N E =======================================
.text$mn:00002824
.text$mn:00002824 ; Attributes: bp-based frame
.text$mn:00002824
.text$mn:00002824 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int, unsigned int)
.text$mn:00002824                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
.text$mn:00002824 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00002824                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Ap
.text$mn:00002824
.text$mn:00002824 var_C           = dword ptr -0Ch
.text$mn:00002824 Dst             = dword ptr -8
.text$mn:00002824 var_4           = dword ptr -4
.text$mn:00002824 arg_0           = dword ptr  8
.text$mn:00002824 arg_4           = dword ptr  0Ch
.text$mn:00002824
.text$mn:00002824                 push    ebp
.text$mn:00002825                 mov     ebp, esp
.text$mn:00002827                 sub     esp, 0Ch
.text$mn:0000282A                 mov     [ebp+var_4], ecx
.text$mn:0000282D                 mov     eax, [ebp+var_4]
.text$mn:00002830                 mov     ecx, [eax+14h]
.text$mn:00002833                 cmp     ecx, [ebp+arg_0]
.text$mn:00002836                 jnb     short loc_2840
.text$mn:00002838                 mov     ecx, [ebp+var_4]
.text$mn:0000283B                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00002840
.text$mn:00002840 loc_2840:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+12j
.text$mn:00002840                 mov     edx, [ebp+var_4]
.text$mn:00002843                 mov     eax, [edx+14h]
.text$mn:00002846                 sub     eax, [ebp+arg_0]
.text$mn:00002849                 cmp     eax, [ebp+arg_4]
.text$mn:0000284C                 ja      short loc_285C
.text$mn:0000284E                 mov     ecx, [ebp+arg_0]
.text$mn:00002851                 push    ecx
.text$mn:00002852                 mov     ecx, [ebp+var_4]
.text$mn:00002855                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000285A                 jmp     short loc_28A8
.text$mn:0000285C ; ---------------------------------------------------------------------------
.text$mn:0000285C
.text$mn:0000285C loc_285C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+28j
.text$mn:0000285C                 cmp     [ebp+arg_4], 0
.text$mn:00002860                 jbe     short loc_28A8
.text$mn:00002862                 mov     ecx, [ebp+var_4]
.text$mn:00002865                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000286A                 mov     edx, [ebp+arg_0]
.text$mn:0000286D                 lea     eax, [eax+edx*2]
.text$mn:00002870                 mov     [ebp+Dst], eax
.text$mn:00002873                 mov     ecx, [ebp+var_4]
.text$mn:00002876                 mov     edx, [ecx+14h]
.text$mn:00002879                 sub     edx, [ebp+arg_4]
.text$mn:0000287C                 mov     [ebp+var_C], edx
.text$mn:0000287F                 mov     eax, [ebp+var_C]
.text$mn:00002882                 sub     eax, [ebp+arg_0]
.text$mn:00002885                 push    eax             ; int
.text$mn:00002886                 mov     ecx, [ebp+arg_4]
.text$mn:00002889                 mov     edx, [ebp+Dst]
.text$mn:0000288C                 lea     eax, [edx+ecx*2]
.text$mn:0000288F                 push    eax             ; Src
.text$mn:00002890                 mov     ecx, [ebp+Dst]
.text$mn:00002893                 push    ecx             ; Dst
.text$mn:00002894                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00002899                 add     esp, 0Ch
.text$mn:0000289C                 mov     edx, [ebp+var_C]
.text$mn:0000289F                 push    edx
.text$mn:000028A0                 mov     ecx, [ebp+var_4]
.text$mn:000028A3                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000028A8
.text$mn:000028A8 loc_28A8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+36j
.text$mn:000028A8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+3Cj
.text$mn:000028A8                 mov     eax, [ebp+var_4]
.text$mn:000028AB                 mov     esp, ebp
.text$mn:000028AD                 pop     ebp
.text$mn:000028AE                 retn    8
.text$mn:000028AE ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z endp
.text$mn:000028AE
.text$mn:000028AE ; ---------------------------------------------------------------------------
.text$mn:000028B1                 align 4
.text$mn:000028B1 _text$mn        ends
.text$mn:000028B1
.text$mn:000028B4 ; ===========================================================================
.text$mn:000028B4
.text$mn:000028B4 ; Segment type: Pure code
.text$mn:000028B4 ; Segment permissions: Read/Execute
.text$mn:000028B4 _text$mn        segment para public 'CODE' use32
.text$mn:000028B4                 assume cs:_text$mn
.text$mn:000028B4                 ;org 28B4h
.text$mn:000028B4 ; COMDAT (pick any)
.text$mn:000028B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000028B4
.text$mn:000028B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000028B4
.text$mn:000028B4 ; Attributes: bp-based frame
.text$mn:000028B4
.text$mn:000028B4 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:000028B4                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:000028B4 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000028B4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:000028B4                 push    ebp
.text$mn:000028B5                 mov     ebp, esp
.text$mn:000028B7                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:000028BC                 pop     ebp
.text$mn:000028BD                 retn
.text$mn:000028BD ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000028BD
.text$mn:000028BD ; ---------------------------------------------------------------------------
.text$mn:000028BE                 align 10h
.text$mn:000028BE _text$mn        ends
.text$mn:000028BE
.text$mn:000028C0 ; ===========================================================================
.text$mn:000028C0
.text$mn:000028C0 ; Segment type: Pure code
.text$mn:000028C0 ; Segment permissions: Read/Execute
.text$mn:000028C0 _text$mn        segment para public 'CODE' use32
.text$mn:000028C0                 assume cs:_text$mn
.text$mn:000028C0                 ;org 28C0h
.text$mn:000028C0 ; COMDAT (pick any)
.text$mn:000028C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000028C0
.text$mn:000028C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000028C0
.text$mn:000028C0 ; Attributes: bp-based frame
.text$mn:000028C0
.text$mn:000028C0 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:000028C0                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:000028C0 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:000028C0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:000028C0
.text$mn:000028C0 var_4           = dword ptr -4
.text$mn:000028C0 Str             = dword ptr  8
.text$mn:000028C0
.text$mn:000028C0                 push    ebp
.text$mn:000028C1                 mov     ebp, esp
.text$mn:000028C3                 push    ecx
.text$mn:000028C4                 mov     eax, [ebp+Str]
.text$mn:000028C7                 movsx   ecx, byte ptr [eax]
.text$mn:000028CA                 test    ecx, ecx
.text$mn:000028CC                 jnz     short loc_28D7
.text$mn:000028CE                 mov     [ebp+var_4], 0
.text$mn:000028D5                 jmp     short loc_28E6
.text$mn:000028D7 ; ---------------------------------------------------------------------------
.text$mn:000028D7
.text$mn:000028D7 loc_28D7:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:000028D7                 mov     edx, [ebp+Str]
.text$mn:000028DA                 push    edx             ; Str
.text$mn:000028DB                 call    _strlen
.text$mn:000028E0                 add     esp, 4
.text$mn:000028E3                 mov     [ebp+var_4], eax
.text$mn:000028E6
.text$mn:000028E6 loc_28E6:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:000028E6                 mov     eax, [ebp+var_4]
.text$mn:000028E9                 mov     esp, ebp
.text$mn:000028EB                 pop     ebp
.text$mn:000028EC                 retn
.text$mn:000028EC ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:000028EC
.text$mn:000028EC ; ---------------------------------------------------------------------------
.text$mn:000028ED                 align 10h
.text$mn:000028ED _text$mn        ends
.text$mn:000028ED
.text$mn:000028F0 ; ===========================================================================
.text$mn:000028F0
.text$mn:000028F0 ; Segment type: Pure code
.text$mn:000028F0 ; Segment permissions: Read/Execute
.text$mn:000028F0 _text$mn        segment para public 'CODE' use32
.text$mn:000028F0                 assume cs:_text$mn
.text$mn:000028F0                 ;org 28F0h
.text$mn:000028F0 ; COMDAT (pick any)
.text$mn:000028F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000028F0
.text$mn:000028F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000028F0
.text$mn:000028F0 ; Attributes: bp-based frame
.text$mn:000028F0
.text$mn:000028F0 ; int __cdecl std::char_traits<wchar_t>::length(wchar_t *Str)
.text$mn:000028F0                 public ?length@?$char_traits@_W@std@@SAIPB_W@Z
.text$mn:000028F0 ?length@?$char_traits@_W@std@@SAIPB_W@Z proc near
.text$mn:000028F0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+21p
.text$mn:000028F0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)+21p
.text$mn:000028F0
.text$mn:000028F0 var_4           = dword ptr -4
.text$mn:000028F0 Str             = dword ptr  8
.text$mn:000028F0
.text$mn:000028F0                 push    ebp
.text$mn:000028F1                 mov     ebp, esp
.text$mn:000028F3                 push    ecx
.text$mn:000028F4                 mov     eax, [ebp+Str]
.text$mn:000028F7                 movzx   ecx, word ptr [eax]
.text$mn:000028FA                 test    ecx, ecx
.text$mn:000028FC                 jnz     short loc_2907
.text$mn:000028FE                 mov     [ebp+var_4], 0
.text$mn:00002905                 jmp     short loc_2916
.text$mn:00002907 ; ---------------------------------------------------------------------------
.text$mn:00002907
.text$mn:00002907 loc_2907:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+Cj
.text$mn:00002907                 mov     edx, [ebp+Str]
.text$mn:0000290A                 push    edx             ; Str
.text$mn:0000290B                 call    _wcslen
.text$mn:00002910                 add     esp, 4
.text$mn:00002913                 mov     [ebp+var_4], eax
.text$mn:00002916
.text$mn:00002916 loc_2916:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+15j
.text$mn:00002916                 mov     eax, [ebp+var_4]
.text$mn:00002919                 mov     esp, ebp
.text$mn:0000291B                 pop     ebp
.text$mn:0000291C                 retn
.text$mn:0000291C ?length@?$char_traits@_W@std@@SAIPB_W@Z endp
.text$mn:0000291C
.text$mn:0000291C ; ---------------------------------------------------------------------------
.text$mn:0000291D                 align 10h
.text$mn:0000291D _text$mn        ends
.text$mn:0000291D
.text$mn:00002920 ; ===========================================================================
.text$mn:00002920
.text$mn:00002920 ; Segment type: Pure code
.text$mn:00002920 ; Segment permissions: Read/Execute
.text$mn:00002920 _text$mn        segment para public 'CODE' use32
.text$mn:00002920                 assume cs:_text$mn
.text$mn:00002920                 ;org 2920h
.text$mn:00002920 ; COMDAT (pick any)
.text$mn:00002920                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002920
.text$mn:00002920 ; =============== S U B R O U T I N E =======================================
.text$mn:00002920
.text$mn:00002920 ; Attributes: bp-based frame
.text$mn:00002920
.text$mn:00002920 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00002920                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00002920 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00002920                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00002920
.text$mn:00002920 var_4           = dword ptr -4
.text$mn:00002920
.text$mn:00002920                 push    ebp
.text$mn:00002921                 mov     ebp, esp
.text$mn:00002923                 push    ecx
.text$mn:00002924                 mov     [ebp+var_4], ecx
.text$mn:00002927                 mov     eax, [ebp+var_4]
.text$mn:0000292A                 push    eax
.text$mn:0000292B                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00002930                 add     esp, 4
.text$mn:00002933                 mov     esp, ebp
.text$mn:00002935                 pop     ebp
.text$mn:00002936                 retn
.text$mn:00002936 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:00002936
.text$mn:00002936 ; ---------------------------------------------------------------------------
.text$mn:00002937                 align 4
.text$mn:00002937 _text$mn        ends
.text$mn:00002937
.text$mn:00002938 ; ===========================================================================
.text$mn:00002938
.text$mn:00002938 ; Segment type: Pure code
.text$mn:00002938 ; Segment permissions: Read/Execute
.text$mn:00002938 _text$mn        segment para public 'CODE' use32
.text$mn:00002938                 assume cs:_text$mn
.text$mn:00002938                 ;org 2938h
.text$mn:00002938 ; COMDAT (pick any)
.text$mn:00002938                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002938
.text$mn:00002938 ; =============== S U B R O U T I N E =======================================
.text$mn:00002938
.text$mn:00002938 ; Attributes: bp-based frame
.text$mn:00002938
.text$mn:00002938 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::max_size(void)const
.text$mn:00002938                 public ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:00002938 ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:00002938                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+17p
.text$mn:00002938
.text$mn:00002938 var_4           = dword ptr -4
.text$mn:00002938
.text$mn:00002938                 push    ebp
.text$mn:00002939                 mov     ebp, esp
.text$mn:0000293B                 push    ecx
.text$mn:0000293C                 mov     [ebp+var_4], ecx
.text$mn:0000293F                 mov     eax, [ebp+var_4]
.text$mn:00002942                 push    eax
.text$mn:00002943                 call    ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)
.text$mn:00002948                 add     esp, 4
.text$mn:0000294B                 mov     esp, ebp
.text$mn:0000294D                 pop     ebp
.text$mn:0000294E                 retn
.text$mn:0000294E ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:0000294E
.text$mn:0000294E ; ---------------------------------------------------------------------------
.text$mn:0000294F                 align 10h
.text$mn:0000294F _text$mn        ends
.text$mn:0000294F
.text$mn:00002950 ; ===========================================================================
.text$mn:00002950
.text$mn:00002950 ; Segment type: Pure code
.text$mn:00002950 ; Segment permissions: Read/Execute
.text$mn:00002950 _text$mn        segment para public 'CODE' use32
.text$mn:00002950                 assume cs:_text$mn
.text$mn:00002950                 ;org 2950h
.text$mn:00002950 ; COMDAT (pick any)
.text$mn:00002950                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002950
.text$mn:00002950 ; =============== S U B R O U T I N E =======================================
.text$mn:00002950
.text$mn:00002950 ; Attributes: bp-based frame
.text$mn:00002950
.text$mn:00002950 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00002950                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00002950 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00002950                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00002950
.text$mn:00002950 var_4           = dword ptr -4
.text$mn:00002950
.text$mn:00002950                 push    ebp
.text$mn:00002951                 mov     ebp, esp
.text$mn:00002953                 push    ecx
.text$mn:00002954                 mov     [ebp+var_4], ecx
.text$mn:00002957                 or      eax, 0FFFFFFFFh
.text$mn:0000295A                 mov     esp, ebp
.text$mn:0000295C                 pop     ebp
.text$mn:0000295D                 retn
.text$mn:0000295D ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:0000295D
.text$mn:0000295D ; ---------------------------------------------------------------------------
.text$mn:0000295E                 align 10h
.text$mn:0000295E _text$mn        ends
.text$mn:0000295E
.text$mn:00002960 ; ===========================================================================
.text$mn:00002960
.text$mn:00002960 ; Segment type: Pure code
.text$mn:00002960 ; Segment permissions: Read/Execute
.text$mn:00002960 _text$mn        segment para public 'CODE' use32
.text$mn:00002960                 assume cs:_text$mn
.text$mn:00002960                 ;org 2960h
.text$mn:00002960 ; COMDAT (pick any)
.text$mn:00002960                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002960
.text$mn:00002960 ; =============== S U B R O U T I N E =======================================
.text$mn:00002960
.text$mn:00002960 ; Attributes: bp-based frame
.text$mn:00002960
.text$mn:00002960 ; public: unsigned int __thiscall std::allocator<wchar_t>::max_size(void)const
.text$mn:00002960                 public ?max_size@?$allocator@_W@std@@QBEIXZ
.text$mn:00002960 ?max_size@?$allocator@_W@std@@QBEIXZ proc near
.text$mn:00002960                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)+6p
.text$mn:00002960
.text$mn:00002960 var_4           = dword ptr -4
.text$mn:00002960
.text$mn:00002960                 push    ebp
.text$mn:00002961                 mov     ebp, esp
.text$mn:00002963                 push    ecx
.text$mn:00002964                 mov     [ebp+var_4], ecx
.text$mn:00002967                 mov     eax, 7FFFFFFFh
.text$mn:0000296C                 mov     esp, ebp
.text$mn:0000296E                 pop     ebp
.text$mn:0000296F                 retn
.text$mn:0000296F ?max_size@?$allocator@_W@std@@QBEIXZ endp
.text$mn:0000296F
.text$mn:0000296F _text$mn        ends
.text$mn:0000296F
.text$mn:00002970 ; ===========================================================================
.text$mn:00002970
.text$mn:00002970 ; Segment type: Pure code
.text$mn:00002970 ; Segment permissions: Read/Execute
.text$mn:00002970 _text$mn        segment para public 'CODE' use32
.text$mn:00002970                 assume cs:_text$mn
.text$mn:00002970                 ;org 2970h
.text$mn:00002970 ; COMDAT (pick any)
.text$mn:00002970                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002970
.text$mn:00002970 ; =============== S U B R O U T I N E =======================================
.text$mn:00002970
.text$mn:00002970 ; Attributes: bp-based frame
.text$mn:00002970
.text$mn:00002970 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:00002970                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:00002970 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:00002970                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:00002970
.text$mn:00002970 arg_0           = dword ptr  8
.text$mn:00002970
.text$mn:00002970                 push    ebp
.text$mn:00002971                 mov     ebp, esp
.text$mn:00002973                 mov     ecx, [ebp+arg_0]
.text$mn:00002976                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:0000297B                 pop     ebp
.text$mn:0000297C                 retn
.text$mn:0000297C ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:0000297C
.text$mn:0000297C ; ---------------------------------------------------------------------------
.text$mn:0000297D                 align 10h
.text$mn:0000297D _text$mn        ends
.text$mn:0000297D
.text$mn:00002980 ; ===========================================================================
.text$mn:00002980
.text$mn:00002980 ; Segment type: Pure code
.text$mn:00002980 ; Segment permissions: Read/Execute
.text$mn:00002980 _text$mn        segment para public 'CODE' use32
.text$mn:00002980                 assume cs:_text$mn
.text$mn:00002980                 ;org 2980h
.text$mn:00002980 ; COMDAT (pick any)
.text$mn:00002980                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002980
.text$mn:00002980 ; =============== S U B R O U T I N E =======================================
.text$mn:00002980
.text$mn:00002980 ; Attributes: bp-based frame
.text$mn:00002980
.text$mn:00002980 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<wchar_t>>::max_size(class std::allocator<wchar_t> const &)
.text$mn:00002980                 public ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
.text$mn:00002980 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z proc near
.text$mn:00002980                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)+Bp
.text$mn:00002980
.text$mn:00002980 arg_0           = dword ptr  8
.text$mn:00002980
.text$mn:00002980                 push    ebp
.text$mn:00002981                 mov     ebp, esp
.text$mn:00002983                 mov     ecx, [ebp+arg_0]
.text$mn:00002986                 call    ?max_size@?$allocator@_W@std@@QBEIXZ ; std::allocator<wchar_t>::max_size(void)
.text$mn:0000298B                 pop     ebp
.text$mn:0000298C                 retn
.text$mn:0000298C ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z endp
.text$mn:0000298C
.text$mn:0000298C ; ---------------------------------------------------------------------------
.text$mn:0000298D                 align 10h
.text$mn:0000298D _text$mn        ends
.text$mn:0000298D
.text$mn:00002990 ; ===========================================================================
.text$mn:00002990
.text$mn:00002990 ; Segment type: Pure code
.text$mn:00002990 ; Segment permissions: Read/Execute
.text$mn:00002990 _text$mn        segment para public 'CODE' use32
.text$mn:00002990                 assume cs:_text$mn
.text$mn:00002990                 ;org 2990h
.text$mn:00002990 ; COMDAT (pick any)
.text$mn:00002990                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002990
.text$mn:00002990 ; =============== S U B R O U T I N E =======================================
.text$mn:00002990
.text$mn:00002990 ; Attributes: bp-based frame
.text$mn:00002990
.text$mn:00002990 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:00002990                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00002990 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00002990                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:00002990                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:00002990
.text$mn:00002990 var_10          = dword ptr -10h
.text$mn:00002990 var_C           = dword ptr -0Ch
.text$mn:00002990 var_8           = dword ptr -8
.text$mn:00002990 var_1           = byte ptr -1
.text$mn:00002990
.text$mn:00002990                 push    ebp
.text$mn:00002991                 mov     ebp, esp
.text$mn:00002993                 sub     esp, 10h
.text$mn:00002996                 mov     [ebp+var_10], ecx
.text$mn:00002999                 lea     eax, [ebp+var_1]
.text$mn:0000299C                 push    eax
.text$mn:0000299D                 mov     ecx, [ebp+var_10]
.text$mn:000029A0                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000029A5                 mov     ecx, eax
.text$mn:000029A7                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:000029AC                 mov     [ebp+var_8], eax
.text$mn:000029AF                 cmp     [ebp+var_8], 1
.text$mn:000029B3                 ja      short loc_29BE
.text$mn:000029B5                 mov     [ebp+var_C], 1
.text$mn:000029BC                 jmp     short loc_29C7
.text$mn:000029BE ; ---------------------------------------------------------------------------
.text$mn:000029BE
.text$mn:000029BE loc_29BE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:000029BE                 mov     ecx, [ebp+var_8]
.text$mn:000029C1                 sub     ecx, 1
.text$mn:000029C4                 mov     [ebp+var_C], ecx
.text$mn:000029C7
.text$mn:000029C7 loc_29C7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:000029C7                 mov     eax, [ebp+var_C]
.text$mn:000029CA                 mov     esp, ebp
.text$mn:000029CC                 pop     ebp
.text$mn:000029CD                 retn
.text$mn:000029CD ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:000029CD
.text$mn:000029CD ; ---------------------------------------------------------------------------
.text$mn:000029CE                 align 10h
.text$mn:000029CE _text$mn        ends
.text$mn:000029CE
.text$mn:000029D0 ; ===========================================================================
.text$mn:000029D0
.text$mn:000029D0 ; Segment type: Pure code
.text$mn:000029D0 ; Segment permissions: Read/Execute
.text$mn:000029D0 _text$mn        segment para public 'CODE' use32
.text$mn:000029D0                 assume cs:_text$mn
.text$mn:000029D0                 ;org 29D0h
.text$mn:000029D0 ; COMDAT (pick any)
.text$mn:000029D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000029D0
.text$mn:000029D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000029D0
.text$mn:000029D0 ; Attributes: bp-based frame
.text$mn:000029D0
.text$mn:000029D0 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::max_size(void)const
.text$mn:000029D0                 public ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:000029D0 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:000029D0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+3Bp
.text$mn:000029D0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+6Ap ...
.text$mn:000029D0
.text$mn:000029D0 var_10          = dword ptr -10h
.text$mn:000029D0 var_C           = dword ptr -0Ch
.text$mn:000029D0 var_8           = dword ptr -8
.text$mn:000029D0 var_1           = byte ptr -1
.text$mn:000029D0
.text$mn:000029D0                 push    ebp
.text$mn:000029D1                 mov     ebp, esp
.text$mn:000029D3                 sub     esp, 10h
.text$mn:000029D6                 mov     [ebp+var_10], ecx
.text$mn:000029D9                 lea     eax, [ebp+var_1]
.text$mn:000029DC                 push    eax
.text$mn:000029DD                 mov     ecx, [ebp+var_10]
.text$mn:000029E0                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000029E5                 mov     ecx, eax
.text$mn:000029E7                 call    ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)
.text$mn:000029EC                 mov     [ebp+var_8], eax
.text$mn:000029EF                 cmp     [ebp+var_8], 1
.text$mn:000029F3                 ja      short loc_29FE
.text$mn:000029F5                 mov     [ebp+var_C], 1
.text$mn:000029FC                 jmp     short loc_2A07
.text$mn:000029FE ; ---------------------------------------------------------------------------
.text$mn:000029FE
.text$mn:000029FE loc_29FE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+23j
.text$mn:000029FE                 mov     ecx, [ebp+var_8]
.text$mn:00002A01                 sub     ecx, 1
.text$mn:00002A04                 mov     [ebp+var_C], ecx
.text$mn:00002A07
.text$mn:00002A07 loc_2A07:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+2Cj
.text$mn:00002A07                 mov     eax, [ebp+var_C]
.text$mn:00002A0A                 mov     esp, ebp
.text$mn:00002A0C                 pop     ebp
.text$mn:00002A0D                 retn
.text$mn:00002A0D ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:00002A0D
.text$mn:00002A0D ; ---------------------------------------------------------------------------
.text$mn:00002A0E                 align 10h
.text$mn:00002A0E _text$mn        ends
.text$mn:00002A0E
.text$mn:00002A10 ; ===========================================================================
.text$mn:00002A10
.text$mn:00002A10 ; Segment type: Pure code
.text$mn:00002A10 ; Segment permissions: Read/Execute
.text$mn:00002A10 _text$mn        segment para public 'CODE' use32
.text$mn:00002A10                 assume cs:_text$mn
.text$mn:00002A10                 ;org 2A10h
.text$mn:00002A10 ; COMDAT (pick any)
.text$mn:00002A10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A10
.text$mn:00002A10 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A10
.text$mn:00002A10 ; Attributes: bp-based frame
.text$mn:00002A10
.text$mn:00002A10 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00002A10                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002A10 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002A10                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00002A10                                         ; DATA XREF: .rdata:00003274o
.text$mn:00002A10
.text$mn:00002A10 var_1C          = dword ptr -1Ch
.text$mn:00002A10 var_18          = dword ptr -18h
.text$mn:00002A10 Str             = dword ptr -14h
.text$mn:00002A10 var_10          = dword ptr -10h
.text$mn:00002A10 var_C           = dword ptr -0Ch
.text$mn:00002A10 var_4           = dword ptr -4
.text$mn:00002A10 arg_0           = dword ptr  8
.text$mn:00002A10 arg_4           = dword ptr  0Ch
.text$mn:00002A10
.text$mn:00002A10                 push    ebp
.text$mn:00002A11                 mov     ebp, esp
.text$mn:00002A13                 push    0FFFFFFFFh
.text$mn:00002A15                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002A1A                 mov     eax, large fs:0
.text$mn:00002A20                 push    eax
.text$mn:00002A21                 sub     esp, 10h
.text$mn:00002A24                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002A29                 xor     eax, ebp
.text$mn:00002A2B                 push    eax
.text$mn:00002A2C                 lea     eax, [ebp+var_C]
.text$mn:00002A2F                 mov     large fs:0, eax
.text$mn:00002A35                 mov     [ebp+var_1C], ecx
.text$mn:00002A38                 mov     [ebp+var_18], 0
.text$mn:00002A3F                 mov     eax, [ebp+arg_4]
.text$mn:00002A42                 push    eax             ; int
.text$mn:00002A43                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00002A48                 add     esp, 4
.text$mn:00002A4B                 mov     [ebp+var_10], eax
.text$mn:00002A4E                 cmp     [ebp+var_10], 0
.text$mn:00002A52                 jz      short loc_2A5C
.text$mn:00002A54                 mov     ecx, [ebp+var_10]
.text$mn:00002A57                 mov     [ebp+Str], ecx
.text$mn:00002A5A                 jmp     short loc_2A63
.text$mn:00002A5C ; ---------------------------------------------------------------------------
.text$mn:00002A5C
.text$mn:00002A5C loc_2A5C:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00002A5C                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00002A63
.text$mn:00002A63 loc_2A63:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:00002A63                 mov     edx, [ebp+Str]
.text$mn:00002A66                 push    edx             ; Str
.text$mn:00002A67                 mov     ecx, [ebp+arg_0]
.text$mn:00002A6A                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002A6F                 mov     [ebp+var_4], 0
.text$mn:00002A76                 mov     eax, [ebp+var_18]
.text$mn:00002A79                 or      eax, 1
.text$mn:00002A7C                 mov     [ebp+var_18], eax
.text$mn:00002A7F                 mov     eax, [ebp+arg_0]
.text$mn:00002A82                 mov     ecx, [ebp+var_C]
.text$mn:00002A85                 mov     large fs:0, ecx
.text$mn:00002A8C                 pop     ecx
.text$mn:00002A8D                 mov     esp, ebp
.text$mn:00002A8F                 pop     ebp
.text$mn:00002A90                 retn    8
.text$mn:00002A90 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002A90
.text$mn:00002A90 ; ---------------------------------------------------------------------------
.text$mn:00002A93                 align 4
.text$mn:00002A93 _text$mn        ends
.text$mn:00002A93
.text$x:00002A94 ; ===========================================================================
.text$x:00002A94
.text$x:00002A94 ; Segment type: Pure code
.text$x:00002A94 ; Segment permissions: Read/Execute
.text$x:00002A94 _text$x         segment para public 'CODE' use32
.text$x:00002A94                 assume cs:_text$x
.text$x:00002A94                 ;org 2A94h
.text$x:00002A94 ; COMDAT (pick associative to section at 2A10)
.text$x:00002A94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002A94
.text$x:00002A94 ; =============== S U B R O U T I N E =======================================
.text$x:00002A94
.text$x:00002A94
.text$x:00002A94 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002A94                                         ; DATA XREF: .xdata$x:00002FDCo
.text$x:00002A94                 mov     eax, [ebp-18h]
.text$x:00002A97                 and     eax, 1
.text$x:00002A9A                 jz      $LN6
.text$x:00002AA0                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00002AA4                 mov     ecx, [ebp+8]
.text$x:00002AA7                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002AAC ; ---------------------------------------------------------------------------
.text$x:00002AAC
.text$x:00002AAC $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002AAC                 retn
.text$x:00002AAC __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002AAC
.text$x:00002AAD
.text$x:00002AAD ; =============== S U B R O U T I N E =======================================
.text$x:00002AAD
.text$x:00002AAD
.text$x:00002AAD __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002AAD                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00002AAD
.text$x:00002AAD arg_4           = dword ptr  8
.text$x:00002AAD
.text$x:00002AAD                 mov     edx, [esp+arg_4]
.text$x:00002AB1                 lea     eax, [edx+0Ch]
.text$x:00002AB4                 mov     ecx, [edx-14h]
.text$x:00002AB7                 xor     ecx, eax
.text$x:00002AB9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002ABE                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00002AC3                 jmp     ___CxxFrameHandler3
.text$x:00002AC3 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00002AC3
.text$x:00002AC3 _text$x         ends
.text$x:00002AC3
.text$mn:00002AC8 ; ===========================================================================
.text$mn:00002AC8
.text$mn:00002AC8 ; Segment type: Pure code
.text$mn:00002AC8 ; Segment permissions: Read/Execute
.text$mn:00002AC8 _text$mn        segment para public 'CODE' use32
.text$mn:00002AC8                 assume cs:_text$mn
.text$mn:00002AC8                 ;org 2AC8h
.text$mn:00002AC8 ; COMDAT (pick any)
.text$mn:00002AC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002AC8
.text$mn:00002AC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AC8
.text$mn:00002AC8 ; Attributes: bp-based frame
.text$mn:00002AC8
.text$mn:00002AC8 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00002AC8                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002AC8 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002AC8                                         ; DATA XREF: .rdata:000032A8o
.text$mn:00002AC8
.text$mn:00002AC8 var_14          = dword ptr -14h
.text$mn:00002AC8 var_10          = dword ptr -10h
.text$mn:00002AC8 var_C           = dword ptr -0Ch
.text$mn:00002AC8 var_4           = dword ptr -4
.text$mn:00002AC8 arg_0           = dword ptr  8
.text$mn:00002AC8 arg_4           = dword ptr  0Ch
.text$mn:00002AC8
.text$mn:00002AC8                 push    ebp
.text$mn:00002AC9                 mov     ebp, esp
.text$mn:00002ACB                 push    0FFFFFFFFh
.text$mn:00002ACD                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002AD2                 mov     eax, large fs:0
.text$mn:00002AD8                 push    eax
.text$mn:00002AD9                 sub     esp, 8
.text$mn:00002ADC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002AE1                 xor     eax, ebp
.text$mn:00002AE3                 push    eax
.text$mn:00002AE4                 lea     eax, [ebp+var_C]
.text$mn:00002AE7                 mov     large fs:0, eax
.text$mn:00002AED                 mov     [ebp+var_14], ecx
.text$mn:00002AF0                 mov     [ebp+var_10], 0
.text$mn:00002AF7                 cmp     [ebp+arg_4], 1
.text$mn:00002AFB                 jnz     short loc_2B21
.text$mn:00002AFD                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00002B02                 mov     ecx, [ebp+arg_0]
.text$mn:00002B05                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002B0A                 mov     [ebp+var_4], 0
.text$mn:00002B11                 mov     eax, [ebp+var_10]
.text$mn:00002B14                 or      eax, 1
.text$mn:00002B17                 mov     [ebp+var_10], eax
.text$mn:00002B1A                 mov     eax, [ebp+arg_0]
.text$mn:00002B1D                 jmp     short loc_2B44
.text$mn:00002B1F ; ---------------------------------------------------------------------------
.text$mn:00002B1F                 jmp     short loc_2B44
.text$mn:00002B21 ; ---------------------------------------------------------------------------
.text$mn:00002B21
.text$mn:00002B21 loc_2B21:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00002B21                 mov     ecx, [ebp+arg_4]
.text$mn:00002B24                 push    ecx
.text$mn:00002B25                 mov     edx, [ebp+arg_0]
.text$mn:00002B28                 push    edx
.text$mn:00002B29                 mov     ecx, [ebp+var_14]
.text$mn:00002B2C                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00002B31                 mov     [ebp+var_4], 0
.text$mn:00002B38                 mov     eax, [ebp+var_10]
.text$mn:00002B3B                 or      eax, 1
.text$mn:00002B3E                 mov     [ebp+var_10], eax
.text$mn:00002B41                 mov     eax, [ebp+arg_0]
.text$mn:00002B44
.text$mn:00002B44 loc_2B44:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00002B44                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00002B44                 mov     ecx, [ebp+var_C]
.text$mn:00002B47                 mov     large fs:0, ecx
.text$mn:00002B4E                 pop     ecx
.text$mn:00002B4F                 mov     esp, ebp
.text$mn:00002B51                 pop     ebp
.text$mn:00002B52                 retn    8
.text$mn:00002B52 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002B52
.text$mn:00002B52 ; ---------------------------------------------------------------------------
.text$mn:00002B55                 align 4
.text$mn:00002B55 _text$mn        ends
.text$mn:00002B55
.text$x:00002B58 ; ===========================================================================
.text$x:00002B58
.text$x:00002B58 ; Segment type: Pure code
.text$x:00002B58 ; Segment permissions: Read/Execute
.text$x:00002B58 _text$x         segment para public 'CODE' use32
.text$x:00002B58                 assume cs:_text$x
.text$x:00002B58                 ;org 2B58h
.text$x:00002B58 ; COMDAT (pick associative to section at 2AC8)
.text$x:00002B58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002B58
.text$x:00002B58 ; =============== S U B R O U T I N E =======================================
.text$x:00002B58
.text$x:00002B58
.text$x:00002B58 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002B58                                         ; DATA XREF: .xdata$x:00003060o
.text$x:00002B58                 mov     eax, [ebp-10h]
.text$x:00002B5B                 and     eax, 1
.text$x:00002B5E                 jz      $LN6_0
.text$x:00002B64                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00002B68                 mov     ecx, [ebp+8]
.text$x:00002B6B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002B70 ; ---------------------------------------------------------------------------
.text$x:00002B70
.text$x:00002B70 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002B70                 retn
.text$x:00002B70 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002B70
.text$x:00002B71
.text$x:00002B71 ; =============== S U B R O U T I N E =======================================
.text$x:00002B71
.text$x:00002B71
.text$x:00002B71 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002B71                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00002B71
.text$x:00002B71 arg_4           = dword ptr  8
.text$x:00002B71
.text$x:00002B71                 mov     edx, [esp+arg_4]
.text$x:00002B75                 lea     eax, [edx+0Ch]
.text$x:00002B78                 mov     ecx, [edx-0Ch]
.text$x:00002B7B                 xor     ecx, eax
.text$x:00002B7D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002B82                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00002B87                 jmp     ___CxxFrameHandler3
.text$x:00002B87 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00002B87
.text$x:00002B87 _text$x         ends
.text$x:00002B87
.text$mn:00002B8C ; ===========================================================================
.text$mn:00002B8C
.text$mn:00002B8C ; Segment type: Pure code
.text$mn:00002B8C ; Segment permissions: Read/Execute
.text$mn:00002B8C _text$mn        segment para public 'CODE' use32
.text$mn:00002B8C                 assume cs:_text$mn
.text$mn:00002B8C                 ;org 2B8Ch
.text$mn:00002B8C ; COMDAT (pick any)
.text$mn:00002B8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B8C
.text$mn:00002B8C ; =============== S U B R O U T I N E =======================================
.text$mn:00002B8C
.text$mn:00002B8C ; Attributes: bp-based frame
.text$mn:00002B8C
.text$mn:00002B8C ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00002B8C                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002B8C ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002B8C                                         ; DATA XREF: .rdata:000032E8o
.text$mn:00002B8C
.text$mn:00002B8C var_1C          = dword ptr -1Ch
.text$mn:00002B8C var_18          = dword ptr -18h
.text$mn:00002B8C Str             = dword ptr -14h
.text$mn:00002B8C var_10          = dword ptr -10h
.text$mn:00002B8C var_C           = dword ptr -0Ch
.text$mn:00002B8C var_4           = dword ptr -4
.text$mn:00002B8C arg_0           = dword ptr  8
.text$mn:00002B8C arg_4           = dword ptr  0Ch
.text$mn:00002B8C
.text$mn:00002B8C                 push    ebp
.text$mn:00002B8D                 mov     ebp, esp
.text$mn:00002B8F                 push    0FFFFFFFFh
.text$mn:00002B91                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002B96                 mov     eax, large fs:0
.text$mn:00002B9C                 push    eax
.text$mn:00002B9D                 sub     esp, 10h
.text$mn:00002BA0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002BA5                 xor     eax, ebp
.text$mn:00002BA7                 push    eax
.text$mn:00002BA8                 lea     eax, [ebp+var_C]
.text$mn:00002BAB                 mov     large fs:0, eax
.text$mn:00002BB1                 mov     [ebp+var_1C], ecx
.text$mn:00002BB4                 mov     [ebp+var_18], 0
.text$mn:00002BBB                 mov     eax, [ebp+arg_4]
.text$mn:00002BBE                 push    eax             ; int
.text$mn:00002BBF                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00002BC4                 add     esp, 4
.text$mn:00002BC7                 mov     [ebp+var_10], eax
.text$mn:00002BCA                 cmp     [ebp+var_10], 0
.text$mn:00002BCE                 jz      short loc_2BD8
.text$mn:00002BD0                 mov     ecx, [ebp+var_10]
.text$mn:00002BD3                 mov     [ebp+Str], ecx
.text$mn:00002BD6                 jmp     short loc_2BDF
.text$mn:00002BD8 ; ---------------------------------------------------------------------------
.text$mn:00002BD8
.text$mn:00002BD8 loc_2BD8:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00002BD8                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00002BDF
.text$mn:00002BDF loc_2BDF:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00002BDF                 mov     edx, [ebp+Str]
.text$mn:00002BE2                 push    edx             ; Str
.text$mn:00002BE3                 mov     ecx, [ebp+arg_0]
.text$mn:00002BE6                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002BEB                 mov     [ebp+var_4], 0
.text$mn:00002BF2                 mov     eax, [ebp+var_18]
.text$mn:00002BF5                 or      eax, 1
.text$mn:00002BF8                 mov     [ebp+var_18], eax
.text$mn:00002BFB                 mov     eax, [ebp+arg_0]
.text$mn:00002BFE                 mov     ecx, [ebp+var_C]
.text$mn:00002C01                 mov     large fs:0, ecx
.text$mn:00002C08                 pop     ecx
.text$mn:00002C09                 mov     esp, ebp
.text$mn:00002C0B                 pop     ebp
.text$mn:00002C0C                 retn    8
.text$mn:00002C0C ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002C0C
.text$mn:00002C0C ; ---------------------------------------------------------------------------
.text$mn:00002C0F                 align 10h
.text$mn:00002C0F _text$mn        ends
.text$mn:00002C0F
.text$x:00002C10 ; ===========================================================================
.text$x:00002C10
.text$x:00002C10 ; Segment type: Pure code
.text$x:00002C10 ; Segment permissions: Read/Execute
.text$x:00002C10 _text$x         segment para public 'CODE' use32
.text$x:00002C10                 assume cs:_text$x
.text$x:00002C10                 ;org 2C10h
.text$x:00002C10 ; COMDAT (pick associative to section at 2B8C)
.text$x:00002C10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002C10
.text$x:00002C10 ; =============== S U B R O U T I N E =======================================
.text$x:00002C10
.text$x:00002C10
.text$x:00002C10 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002C10                                         ; DATA XREF: .xdata$x:000030E4o
.text$x:00002C10                 mov     eax, [ebp-18h]
.text$x:00002C13                 and     eax, 1
.text$x:00002C16                 jz      $LN6_1
.text$x:00002C1C                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00002C20                 mov     ecx, [ebp+8]
.text$x:00002C23                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002C28 ; ---------------------------------------------------------------------------
.text$x:00002C28
.text$x:00002C28 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002C28                 retn
.text$x:00002C28 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002C28
.text$x:00002C29
.text$x:00002C29 ; =============== S U B R O U T I N E =======================================
.text$x:00002C29
.text$x:00002C29
.text$x:00002C29 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002C29                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00002C29
.text$x:00002C29 arg_4           = dword ptr  8
.text$x:00002C29
.text$x:00002C29                 mov     edx, [esp+arg_4]
.text$x:00002C2D                 lea     eax, [edx+0Ch]
.text$x:00002C30                 mov     ecx, [edx-14h]
.text$x:00002C33                 xor     ecx, eax
.text$x:00002C35                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002C3A                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00002C3F                 jmp     ___CxxFrameHandler3
.text$x:00002C3F __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00002C3F
.text$x:00002C3F _text$x         ends
.text$x:00002C3F
.text$mn:00002C44 ; ===========================================================================
.text$mn:00002C44
.text$mn:00002C44 ; Segment type: Pure code
.text$mn:00002C44 ; Segment permissions: Read/Execute
.text$mn:00002C44 _text$mn        segment para public 'CODE' use32
.text$mn:00002C44                 assume cs:_text$mn
.text$mn:00002C44                 ;org 2C44h
.text$mn:00002C44 ; COMDAT (pick any)
.text$mn:00002C44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002C44
.text$mn:00002C44 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C44
.text$mn:00002C44 ; Attributes: bp-based frame
.text$mn:00002C44
.text$mn:00002C44 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00002C44                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00002C44 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00002C44                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00002C44
.text$mn:00002C44 var_4           = dword ptr -4
.text$mn:00002C44 Dst             = dword ptr  8
.text$mn:00002C44 Src             = dword ptr  0Ch
.text$mn:00002C44 Size            = dword ptr  10h
.text$mn:00002C44
.text$mn:00002C44                 push    ebp
.text$mn:00002C45                 mov     ebp, esp
.text$mn:00002C47                 push    ecx
.text$mn:00002C48                 cmp     [ebp+Size], 0
.text$mn:00002C4C                 jnz     short loc_2C56
.text$mn:00002C4E                 mov     eax, [ebp+Dst]
.text$mn:00002C51                 mov     [ebp+var_4], eax
.text$mn:00002C54                 jmp     short loc_2C6D
.text$mn:00002C56 ; ---------------------------------------------------------------------------
.text$mn:00002C56
.text$mn:00002C56 loc_2C56:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00002C56                 mov     ecx, [ebp+Size]
.text$mn:00002C59                 push    ecx             ; Size
.text$mn:00002C5A                 mov     edx, [ebp+Src]
.text$mn:00002C5D                 push    edx             ; Src
.text$mn:00002C5E                 mov     eax, [ebp+Dst]
.text$mn:00002C61                 push    eax             ; Dst
.text$mn:00002C62                 call    _memmove
.text$mn:00002C67                 add     esp, 0Ch
.text$mn:00002C6A                 mov     [ebp+var_4], eax
.text$mn:00002C6D
.text$mn:00002C6D loc_2C6D:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00002C6D                 mov     eax, [ebp+var_4]
.text$mn:00002C70                 mov     esp, ebp
.text$mn:00002C72                 pop     ebp
.text$mn:00002C73                 retn
.text$mn:00002C73 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00002C73
.text$mn:00002C73 _text$mn        ends
.text$mn:00002C73
.text$mn:00002C74 ; ===========================================================================
.text$mn:00002C74
.text$mn:00002C74 ; Segment type: Pure code
.text$mn:00002C74 ; Segment permissions: Read/Execute
.text$mn:00002C74 _text$mn        segment para public 'CODE' use32
.text$mn:00002C74                 assume cs:_text$mn
.text$mn:00002C74                 ;org 2C74h
.text$mn:00002C74 ; COMDAT (pick any)
.text$mn:00002C74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002C74
.text$mn:00002C74 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C74
.text$mn:00002C74 ; Attributes: bp-based frame
.text$mn:00002C74
.text$mn:00002C74 ; int __cdecl std::char_traits<wchar_t>::move(void *Dst, void *Src, int)
.text$mn:00002C74                 public ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:00002C74 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:00002C74                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+70p
.text$mn:00002C74
.text$mn:00002C74 var_4           = dword ptr -4
.text$mn:00002C74 Dst             = dword ptr  8
.text$mn:00002C74 Src             = dword ptr  0Ch
.text$mn:00002C74 arg_8           = dword ptr  10h
.text$mn:00002C74
.text$mn:00002C74                 push    ebp
.text$mn:00002C75                 mov     ebp, esp
.text$mn:00002C77                 push    ecx
.text$mn:00002C78                 cmp     [ebp+arg_8], 0
.text$mn:00002C7C                 jnz     short loc_2C86
.text$mn:00002C7E                 mov     eax, [ebp+Dst]
.text$mn:00002C81                 mov     [ebp+var_4], eax
.text$mn:00002C84                 jmp     short loc_2C9D
.text$mn:00002C86 ; ---------------------------------------------------------------------------
.text$mn:00002C86
.text$mn:00002C86 loc_2C86:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+8j
.text$mn:00002C86                 mov     ecx, [ebp+arg_8]
.text$mn:00002C89                 push    ecx             ; int
.text$mn:00002C8A                 mov     edx, [ebp+Src]
.text$mn:00002C8D                 push    edx             ; Src
.text$mn:00002C8E                 mov     eax, [ebp+Dst]
.text$mn:00002C91                 push    eax             ; Dst
.text$mn:00002C92                 call    _wmemmove
.text$mn:00002C97                 add     esp, 0Ch
.text$mn:00002C9A                 mov     [ebp+var_4], eax
.text$mn:00002C9D
.text$mn:00002C9D loc_2C9D:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+10j
.text$mn:00002C9D                 mov     eax, [ebp+var_4]
.text$mn:00002CA0                 mov     esp, ebp
.text$mn:00002CA2                 pop     ebp
.text$mn:00002CA3                 retn
.text$mn:00002CA3 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:00002CA3
.text$mn:00002CA3 _text$mn        ends
.text$mn:00002CA3
.text$mn:00002CA4 ; ===========================================================================
.text$mn:00002CA4
.text$mn:00002CA4 ; Segment type: Pure code
.text$mn:00002CA4 ; Segment permissions: Read/Execute
.text$mn:00002CA4 _text$mn        segment para public 'CODE' use32
.text$mn:00002CA4                 assume cs:_text$mn
.text$mn:00002CA4                 ;org 2CA4h
.text$mn:00002CA4 ; COMDAT (pick any)
.text$mn:00002CA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002CA4
.text$mn:00002CA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CA4
.text$mn:00002CA4 ; Attributes: bp-based frame
.text$mn:00002CA4
.text$mn:00002CA4 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00002CA4                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00002CA4 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00002CA4                                         ; DATA XREF: .rdata:00003270o
.text$mn:00002CA4
.text$mn:00002CA4 var_4           = dword ptr -4
.text$mn:00002CA4
.text$mn:00002CA4                 push    ebp
.text$mn:00002CA5                 mov     ebp, esp
.text$mn:00002CA7                 push    ecx
.text$mn:00002CA8                 mov     [ebp+var_4], ecx
.text$mn:00002CAB                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00002CB0                 mov     esp, ebp
.text$mn:00002CB2                 pop     ebp
.text$mn:00002CB3                 retn
.text$mn:00002CB3 ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00002CB3
.text$mn:00002CB3 _text$mn        ends
.text$mn:00002CB3
.text$mn:00002CB4 ; ===========================================================================
.text$mn:00002CB4
.text$mn:00002CB4 ; Segment type: Pure code
.text$mn:00002CB4 ; Segment permissions: Read/Execute
.text$mn:00002CB4 _text$mn        segment para public 'CODE' use32
.text$mn:00002CB4                 assume cs:_text$mn
.text$mn:00002CB4                 ;org 2CB4h
.text$mn:00002CB4 ; COMDAT (pick any)
.text$mn:00002CB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002CB4
.text$mn:00002CB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CB4
.text$mn:00002CB4 ; Attributes: bp-based frame
.text$mn:00002CB4
.text$mn:00002CB4 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00002CB4                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00002CB4 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00002CB4                                         ; DATA XREF: .rdata:000032A4o
.text$mn:00002CB4
.text$mn:00002CB4 var_4           = dword ptr -4
.text$mn:00002CB4
.text$mn:00002CB4                 push    ebp
.text$mn:00002CB5                 mov     ebp, esp
.text$mn:00002CB7                 push    ecx
.text$mn:00002CB8                 mov     [ebp+var_4], ecx
.text$mn:00002CBB                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00002CC0                 mov     esp, ebp
.text$mn:00002CC2                 pop     ebp
.text$mn:00002CC3                 retn
.text$mn:00002CC3 ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00002CC3
.text$mn:00002CC3 _text$mn        ends
.text$mn:00002CC3
.text$mn:00002CC4 ; ===========================================================================
.text$mn:00002CC4
.text$mn:00002CC4 ; Segment type: Pure code
.text$mn:00002CC4 ; Segment permissions: Read/Execute
.text$mn:00002CC4 _text$mn        segment para public 'CODE' use32
.text$mn:00002CC4                 assume cs:_text$mn
.text$mn:00002CC4                 ;org 2CC4h
.text$mn:00002CC4 ; COMDAT (pick any)
.text$mn:00002CC4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002CC4
.text$mn:00002CC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CC4
.text$mn:00002CC4 ; Attributes: bp-based frame
.text$mn:00002CC4
.text$mn:00002CC4 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00002CC4                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00002CC4 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00002CC4                                         ; DATA XREF: .rdata:000032E4o
.text$mn:00002CC4
.text$mn:00002CC4 var_4           = dword ptr -4
.text$mn:00002CC4
.text$mn:00002CC4                 push    ebp
.text$mn:00002CC5                 mov     ebp, esp
.text$mn:00002CC7                 push    ecx
.text$mn:00002CC8                 mov     [ebp+var_4], ecx
.text$mn:00002CCB                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00002CD0                 mov     esp, ebp
.text$mn:00002CD2                 pop     ebp
.text$mn:00002CD3                 retn
.text$mn:00002CD3 ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00002CD3
.text$mn:00002CD3 _text$mn        ends
.text$mn:00002CD3
.text$mn:00002CD4 ; ===========================================================================
.text$mn:00002CD4
.text$mn:00002CD4 ; Segment type: Pure code
.text$mn:00002CD4 ; Segment permissions: Read/Execute
.text$mn:00002CD4 _text$mn        segment para public 'CODE' use32
.text$mn:00002CD4                 assume cs:_text$mn
.text$mn:00002CD4                 ;org 2CD4h
.text$mn:00002CD4 ; COMDAT (pick any)
.text$mn:00002CD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002CD4
.text$mn:00002CD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CD4
.text$mn:00002CD4 ; Attributes: bp-based frame
.text$mn:00002CD4
.text$mn:00002CD4 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00002CD4                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00002CD4 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00002CD4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00002CD4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00002CD4
.text$mn:00002CD4 var_4           = dword ptr -4
.text$mn:00002CD4
.text$mn:00002CD4                 push    ebp
.text$mn:00002CD5                 mov     ebp, esp
.text$mn:00002CD7                 push    ecx
.text$mn:00002CD8                 mov     [ebp+var_4], ecx
.text$mn:00002CDB                 mov     eax, [ebp+var_4]
.text$mn:00002CDE                 mov     eax, [eax+14h]
.text$mn:00002CE1                 mov     esp, ebp
.text$mn:00002CE3                 pop     ebp
.text$mn:00002CE4                 retn
.text$mn:00002CE4 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002CE4
.text$mn:00002CE4 ; ---------------------------------------------------------------------------
.text$mn:00002CE5                 align 4
.text$mn:00002CE5 _text$mn        ends
.text$mn:00002CE5
.text$mn:00002CE8 ; ===========================================================================
.text$mn:00002CE8
.text$mn:00002CE8 ; Segment type: Pure code
.text$mn:00002CE8 ; Segment permissions: Read/Execute
.text$mn:00002CE8 _text$mn        segment para public 'CODE' use32
.text$mn:00002CE8                 assume cs:_text$mn
.text$mn:00002CE8                 ;org 2CE8h
.text$mn:00002CE8 ; COMDAT (pick any)
.text$mn:00002CE8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002CE8
.text$mn:00002CE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CE8
.text$mn:00002CE8 ; Attributes: bp-based frame
.text$mn:00002CE8
.text$mn:00002CE8 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::size(void)const
.text$mn:00002CE8                 public ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:00002CE8 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:00002CE8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+Cp
.text$mn:00002CE8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+21p
.text$mn:00002CE8
.text$mn:00002CE8 var_4           = dword ptr -4
.text$mn:00002CE8
.text$mn:00002CE8                 push    ebp
.text$mn:00002CE9                 mov     ebp, esp
.text$mn:00002CEB                 push    ecx
.text$mn:00002CEC                 mov     [ebp+var_4], ecx
.text$mn:00002CEF                 mov     eax, [ebp+var_4]
.text$mn:00002CF2                 mov     eax, [eax+14h]
.text$mn:00002CF5                 mov     esp, ebp
.text$mn:00002CF7                 pop     ebp
.text$mn:00002CF8                 retn
.text$mn:00002CF8 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:00002CF8
.text$mn:00002CF8 ; ---------------------------------------------------------------------------
.text$mn:00002CF9                 align 4
.text$mn:00002CF9 _text$mn        ends
.text$mn:00002CF9
.text$mn:00002CFC ; ===========================================================================
.text$mn:00002CFC
.text$mn:00002CFC ; Segment type: Pure code
.text$mn:00002CFC ; Segment permissions: Read/Execute
.text$mn:00002CFC _text$mn        segment para public 'CODE' use32
.text$mn:00002CFC                 assume cs:_text$mn
.text$mn:00002CFC                 ;org 2CFCh
.text$mn:00002CFC ; COMDAT (pick any)
.text$mn:00002CFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002CFC
.text$mn:00002CFC ; =============== S U B R O U T I N E =======================================
.text$mn:00002CFC
.text$mn:00002CFC ; Attributes: bp-based frame
.text$mn:00002CFC
.text$mn:00002CFC ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00002CFC                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00002CFC ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00002CFC                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_2688p
.text$mn:00002CFC                 push    ebp
.text$mn:00002CFD                 mov     ebp, esp
.text$mn:00002CFF                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00002D04                 pop     ebp
.text$mn:00002D05                 retn
.text$mn:00002D05 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00002D05
.text$mn:00002D05 ; ---------------------------------------------------------------------------
.text$mn:00002D06                 align 4
.text$mn:00002D06 _text$mn        ends
.text$mn:00002D06
.text$mn:00002D08 ; ===========================================================================
.text$mn:00002D08
.text$mn:00002D08 ; Segment type: Pure code
.text$mn:00002D08 ; Segment permissions: Read/Execute
.text$mn:00002D08 _text$mn        segment para public 'CODE' use32
.text$mn:00002D08                 assume cs:_text$mn
.text$mn:00002D08                 ;org 2D08h
.text$mn:00002D08 ; COMDAT (pick any)
.text$mn:00002D08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002D08
.text$mn:00002D08 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D08
.text$mn:00002D08 ; Attributes: bp-based frame
.text$mn:00002D08
.text$mn:00002D08 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00002D08                 public ?value@error_code@std@@QBEHXZ
.text$mn:00002D08 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00002D08
.text$mn:00002D08 var_4           = dword ptr -4
.text$mn:00002D08
.text$mn:00002D08                 push    ebp
.text$mn:00002D09                 mov     ebp, esp
.text$mn:00002D0B                 push    ecx
.text$mn:00002D0C                 mov     [ebp+var_4], ecx
.text$mn:00002D0F                 mov     eax, [ebp+var_4]
.text$mn:00002D12                 mov     eax, [eax]
.text$mn:00002D14                 mov     esp, ebp
.text$mn:00002D16                 pop     ebp
.text$mn:00002D17                 retn
.text$mn:00002D17 ?value@error_code@std@@QBEHXZ endp
.text$mn:00002D17
.text$mn:00002D17 _text$mn        ends
.text$mn:00002D17
.text$mn:00002D18 ; ===========================================================================
.text$mn:00002D18
.text$mn:00002D18 ; Segment type: Pure code
.text$mn:00002D18 ; Segment permissions: Read/Execute
.text$mn:00002D18 _text$mn        segment para public 'CODE' use32
.text$mn:00002D18                 assume cs:_text$mn
.text$mn:00002D18                 ;org 2D18h
.text$mn:00002D18 ; COMDAT (pick any)
.text$mn:00002D18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002D18
.text$mn:00002D18 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D18
.text$mn:00002D18 ; Attributes: bp-based frame
.text$mn:00002D18
.text$mn:00002D18 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00002D18                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00002D18 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00002D18                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00002D18                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00002D18
.text$mn:00002D18 var_4           = dword ptr -4
.text$mn:00002D18
.text$mn:00002D18                 push    ebp
.text$mn:00002D19                 mov     ebp, esp
.text$mn:00002D1B                 push    ecx
.text$mn:00002D1C                 mov     [ebp+var_4], ecx
.text$mn:00002D1F                 mov     eax, [ebp+var_4]
.text$mn:00002D22                 mov     eax, [eax]
.text$mn:00002D24                 mov     esp, ebp
.text$mn:00002D26                 pop     ebp
.text$mn:00002D27                 retn
.text$mn:00002D27 ?value@error_condition@std@@QBEHXZ endp
.text$mn:00002D27
.text$mn:00002D27 _text$mn        ends
.text$mn:00002D27
.text$mn:00002D28 ; ===========================================================================
.text$mn:00002D28
.text$mn:00002D28 ; Segment type: Pure code
.text$mn:00002D28 ; Segment permissions: Read/Execute
.text$mn:00002D28 _text$mn        segment para public 'CODE' use32
.text$mn:00002D28                 assume cs:_text$mn
.text$mn:00002D28                 ;org 2D28h
.text$mn:00002D28 ; COMDAT (pick any)
.text$mn:00002D28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002D28
.text$mn:00002D28 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D28
.text$mn:00002D28 ; Attributes: bp-based frame
.text$mn:00002D28
.text$mn:00002D28                 public _hypot
.text$mn:00002D28 _hypot          proc near
.text$mn:00002D28
.text$mn:00002D28 var_10          = qword ptr -10h
.text$mn:00002D28 var_8           = qword ptr -8
.text$mn:00002D28 arg_0           = qword ptr  8
.text$mn:00002D28 arg_8           = qword ptr  10h
.text$mn:00002D28
.text$mn:00002D28                 push    ebp
.text$mn:00002D29                 mov     ebp, esp
.text$mn:00002D2B                 sub     esp, 8
.text$mn:00002D2E                 movsd   xmm0, [ebp+arg_8]
.text$mn:00002D33                 movsd   [esp+8+var_8], xmm0
.text$mn:00002D38                 sub     esp, 8
.text$mn:00002D3B                 movsd   xmm0, [ebp+arg_0]
.text$mn:00002D40                 movsd   [esp+10h+var_10], xmm0
.text$mn:00002D45                 call    __hypot
.text$mn:00002D4A                 add     esp, 10h
.text$mn:00002D4D                 pop     ebp
.text$mn:00002D4E                 retn
.text$mn:00002D4E _hypot          endp
.text$mn:00002D4E
.text$mn:00002D4E ; ---------------------------------------------------------------------------
.text$mn:00002D4F                 align 10h
.text$mn:00002D4F _text$mn        ends
.text$mn:00002D4F
.text$mn:00002D50 ; ===========================================================================
.text$mn:00002D50
.text$mn:00002D50 ; Segment type: Pure code
.text$mn:00002D50 ; Segment permissions: Read/Execute
.text$mn:00002D50 _text$mn        segment para public 'CODE' use32
.text$mn:00002D50                 assume cs:_text$mn
.text$mn:00002D50                 ;org 2D50h
.text$mn:00002D50 ; COMDAT (pick any)
.text$mn:00002D50                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002D50
.text$mn:00002D50 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D50
.text$mn:00002D50 ; Attributes: bp-based frame
.text$mn:00002D50
.text$mn:00002D50                 public _wmemcmp
.text$mn:00002D50 _wmemcmp        proc near               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+1Fp
.text$mn:00002D50
.text$mn:00002D50 var_4           = dword ptr -4
.text$mn:00002D50 arg_0           = dword ptr  8
.text$mn:00002D50 arg_4           = dword ptr  0Ch
.text$mn:00002D50 arg_8           = dword ptr  10h
.text$mn:00002D50
.text$mn:00002D50                 push    ebp
.text$mn:00002D51                 mov     ebp, esp
.text$mn:00002D53                 push    ecx
.text$mn:00002D54                 jmp     short loc_2D71
.text$mn:00002D56 ; ---------------------------------------------------------------------------
.text$mn:00002D56
.text$mn:00002D56 loc_2D56:                               ; CODE XREF: _wmemcmp:loc_2DACj
.text$mn:00002D56                 mov     eax, [ebp+arg_0]
.text$mn:00002D59                 add     eax, 2
.text$mn:00002D5C                 mov     [ebp+arg_0], eax
.text$mn:00002D5F                 mov     ecx, [ebp+arg_4]
.text$mn:00002D62                 add     ecx, 2
.text$mn:00002D65                 mov     [ebp+arg_4], ecx
.text$mn:00002D68                 mov     edx, [ebp+arg_8]
.text$mn:00002D6B                 sub     edx, 1
.text$mn:00002D6E                 mov     [ebp+arg_8], edx
.text$mn:00002D71
.text$mn:00002D71 loc_2D71:                               ; CODE XREF: _wmemcmp+4j
.text$mn:00002D71                 cmp     [ebp+arg_8], 0
.text$mn:00002D75                 jbe     short loc_2DAE
.text$mn:00002D77                 mov     eax, [ebp+arg_0]
.text$mn:00002D7A                 movzx   ecx, word ptr [eax]
.text$mn:00002D7D                 mov     edx, [ebp+arg_4]
.text$mn:00002D80                 movzx   eax, word ptr [edx]
.text$mn:00002D83                 cmp     ecx, eax
.text$mn:00002D85                 jz      short loc_2DAC
.text$mn:00002D87                 mov     ecx, [ebp+arg_0]
.text$mn:00002D8A                 movzx   edx, word ptr [ecx]
.text$mn:00002D8D                 mov     eax, [ebp+arg_4]
.text$mn:00002D90                 movzx   ecx, word ptr [eax]
.text$mn:00002D93                 cmp     edx, ecx
.text$mn:00002D95                 jge     short loc_2DA0
.text$mn:00002D97                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002D9E                 jmp     short loc_2DA7
.text$mn:00002DA0 ; ---------------------------------------------------------------------------
.text$mn:00002DA0
.text$mn:00002DA0 loc_2DA0:                               ; CODE XREF: _wmemcmp+45j
.text$mn:00002DA0                 mov     [ebp+var_4], 1
.text$mn:00002DA7
.text$mn:00002DA7 loc_2DA7:                               ; CODE XREF: _wmemcmp+4Ej
.text$mn:00002DA7                 mov     eax, [ebp+var_4]
.text$mn:00002DAA                 jmp     short loc_2DB0
.text$mn:00002DAC ; ---------------------------------------------------------------------------
.text$mn:00002DAC
.text$mn:00002DAC loc_2DAC:                               ; CODE XREF: _wmemcmp+35j
.text$mn:00002DAC                 jmp     short loc_2D56
.text$mn:00002DAE ; ---------------------------------------------------------------------------
.text$mn:00002DAE
.text$mn:00002DAE loc_2DAE:                               ; CODE XREF: _wmemcmp+25j
.text$mn:00002DAE                 xor     eax, eax
.text$mn:00002DB0
.text$mn:00002DB0 loc_2DB0:                               ; CODE XREF: _wmemcmp+5Aj
.text$mn:00002DB0                 mov     esp, ebp
.text$mn:00002DB2                 pop     ebp
.text$mn:00002DB3                 retn
.text$mn:00002DB3 _wmemcmp        endp
.text$mn:00002DB3
.text$mn:00002DB3 _text$mn        ends
.text$mn:00002DB3
.text$mn:00002DB4 ; ===========================================================================
.text$mn:00002DB4
.text$mn:00002DB4 ; Segment type: Pure code
.text$mn:00002DB4 ; Segment permissions: Read/Execute
.text$mn:00002DB4 _text$mn        segment para public 'CODE' use32
.text$mn:00002DB4                 assume cs:_text$mn
.text$mn:00002DB4                 ;org 2DB4h
.text$mn:00002DB4 ; COMDAT (pick any)
.text$mn:00002DB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002DB4
.text$mn:00002DB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DB4
.text$mn:00002DB4 ; Attributes: bp-based frame
.text$mn:00002DB4
.text$mn:00002DB4 ; int __cdecl wmemcpy(void *Dst, void *Src, int)
.text$mn:00002DB4                 public _wmemcpy
.text$mn:00002DB4 _wmemcpy        proc near               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00002DB4
.text$mn:00002DB4 Dst             = dword ptr  8
.text$mn:00002DB4 Src             = dword ptr  0Ch
.text$mn:00002DB4 arg_8           = dword ptr  10h
.text$mn:00002DB4
.text$mn:00002DB4                 push    ebp
.text$mn:00002DB5                 mov     ebp, esp
.text$mn:00002DB7                 mov     eax, [ebp+arg_8]
.text$mn:00002DBA                 shl     eax, 1
.text$mn:00002DBC                 push    eax             ; Size
.text$mn:00002DBD                 mov     ecx, [ebp+Src]
.text$mn:00002DC0                 push    ecx             ; Src
.text$mn:00002DC1                 mov     edx, [ebp+Dst]
.text$mn:00002DC4                 push    edx             ; Dst
.text$mn:00002DC5                 call    _memcpy
.text$mn:00002DCA                 add     esp, 0Ch
.text$mn:00002DCD                 pop     ebp
.text$mn:00002DCE                 retn
.text$mn:00002DCE _wmemcpy        endp
.text$mn:00002DCE
.text$mn:00002DCE ; ---------------------------------------------------------------------------
.text$mn:00002DCF                 align 10h
.text$mn:00002DCF _text$mn        ends
.text$mn:00002DCF
.text$mn:00002DD0 ; ===========================================================================
.text$mn:00002DD0
.text$mn:00002DD0 ; Segment type: Pure code
.text$mn:00002DD0 ; Segment permissions: Read/Execute
.text$mn:00002DD0 _text$mn        segment para public 'CODE' use32
.text$mn:00002DD0                 assume cs:_text$mn
.text$mn:00002DD0                 ;org 2DD0h
.text$mn:00002DD0 ; COMDAT (pick any)
.text$mn:00002DD0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002DD0
.text$mn:00002DD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DD0
.text$mn:00002DD0 ; Attributes: bp-based frame
.text$mn:00002DD0
.text$mn:00002DD0 ; int __cdecl wmemmove(void *Dst, void *Src, int)
.text$mn:00002DD0                 public _wmemmove
.text$mn:00002DD0 _wmemmove       proc near               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00002DD0
.text$mn:00002DD0 Dst             = dword ptr  8
.text$mn:00002DD0 Src             = dword ptr  0Ch
.text$mn:00002DD0 arg_8           = dword ptr  10h
.text$mn:00002DD0
.text$mn:00002DD0                 push    ebp
.text$mn:00002DD1                 mov     ebp, esp
.text$mn:00002DD3                 mov     eax, [ebp+arg_8]
.text$mn:00002DD6                 shl     eax, 1
.text$mn:00002DD8                 push    eax             ; Size
.text$mn:00002DD9                 mov     ecx, [ebp+Src]
.text$mn:00002DDC                 push    ecx             ; Src
.text$mn:00002DDD                 mov     edx, [ebp+Dst]
.text$mn:00002DE0                 push    edx             ; Dst
.text$mn:00002DE1                 call    _memmove
.text$mn:00002DE6                 add     esp, 0Ch
.text$mn:00002DE9                 pop     ebp
.text$mn:00002DEA                 retn
.text$mn:00002DEA _wmemmove       endp
.text$mn:00002DEA
.text$mn:00002DEA ; ---------------------------------------------------------------------------
.text$mn:00002DEB                 align 4
.text$mn:00002DEB _text$mn        ends
.text$mn:00002DEB
.xdata$x:00002DEC ; ===========================================================================
.xdata$x:00002DEC
.xdata$x:00002DEC ; Segment type: Pure data
.xdata$x:00002DEC ; Segment permissions: Read
.xdata$x:00002DEC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002DEC                 assume cs:_xdata$x
.xdata$x:00002DEC                 ;org 2DECh
.xdata$x:00002DEC ; COMDAT (pick associative to section at 1DB0)
.xdata$x:00002DEC __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00002DEC                                         ; DATA XREF: .xdata$x:00002DFCo
.xdata$x:00002DED                 db 0FFh
.xdata$x:00002DEE                 db 0FFh
.xdata$x:00002DEF                 db 0FFh
.xdata$x:00002DF0                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00002DF4 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00002DF4                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00002DF5                 db    5
.xdata$x:00002DF6                 db  93h ; ô
.xdata$x:00002DF7                 db  19h
.xdata$x:00002DF8                 db    1
.xdata$x:00002DF9                 db    0
.xdata$x:00002DFA                 db    0
.xdata$x:00002DFB                 db    0
.xdata$x:00002DFC                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00002E00                 db    0
.xdata$x:00002E01                 db    0
.xdata$x:00002E02                 db    0
.xdata$x:00002E03                 db    0
.xdata$x:00002E04                 db    0
.xdata$x:00002E05                 db    0
.xdata$x:00002E06                 db    0
.xdata$x:00002E07                 db    0
.xdata$x:00002E08                 db    0
.xdata$x:00002E09                 db    0
.xdata$x:00002E0A                 db    0
.xdata$x:00002E0B                 db    0
.xdata$x:00002E0C                 db    0
.xdata$x:00002E0D                 db    0
.xdata$x:00002E0E                 db    0
.xdata$x:00002E0F                 db    0
.xdata$x:00002E10                 db    0
.xdata$x:00002E11                 db    0
.xdata$x:00002E12                 db    0
.xdata$x:00002E13                 db    0
.xdata$x:00002E14                 db    0
.xdata$x:00002E15                 db    0
.xdata$x:00002E16                 db    0
.xdata$x:00002E17                 db    0
.xdata$x:00002E17 _xdata$x        ends
.xdata$x:00002E17
.xdata$x:00002E18 ; ===========================================================================
.xdata$x:00002E18
.xdata$x:00002E18 ; Segment type: Pure data
.xdata$x:00002E18 ; Segment permissions: Read
.xdata$x:00002E18 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E18                 assume cs:_xdata$x
.xdata$x:00002E18                 ;org 2E18h
.xdata$x:00002E18 ; COMDAT (pick associative to section at D74)
.xdata$x:00002E18 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002E18                                         ; DATA XREF: .xdata$x:00002E28o
.xdata$x:00002E19                 db 0FFh
.xdata$x:00002E1A                 db 0FFh
.xdata$x:00002E1B                 db 0FFh
.xdata$x:00002E1C                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002E20 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002E20                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002E21                 db    5
.xdata$x:00002E22                 db  93h ; ô
.xdata$x:00002E23                 db  19h
.xdata$x:00002E24                 db    1
.xdata$x:00002E25                 db    0
.xdata$x:00002E26                 db    0
.xdata$x:00002E27                 db    0
.xdata$x:00002E28                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002E2C                 db    0
.xdata$x:00002E2D                 db    0
.xdata$x:00002E2E                 db    0
.xdata$x:00002E2F                 db    0
.xdata$x:00002E30                 db    0
.xdata$x:00002E31                 db    0
.xdata$x:00002E32                 db    0
.xdata$x:00002E33                 db    0
.xdata$x:00002E34                 db    0
.xdata$x:00002E35                 db    0
.xdata$x:00002E36                 db    0
.xdata$x:00002E37                 db    0
.xdata$x:00002E38                 db    0
.xdata$x:00002E39                 db    0
.xdata$x:00002E3A                 db    0
.xdata$x:00002E3B                 db    0
.xdata$x:00002E3C                 db    0
.xdata$x:00002E3D                 db    0
.xdata$x:00002E3E                 db    0
.xdata$x:00002E3F                 db    0
.xdata$x:00002E40                 db    0
.xdata$x:00002E41                 db    0
.xdata$x:00002E42                 db    0
.xdata$x:00002E43                 db    0
.xdata$x:00002E43 _xdata$x        ends
.xdata$x:00002E43
.xdata$x:00002E44 ; ===========================================================================
.xdata$x:00002E44
.xdata$x:00002E44 ; Segment type: Pure data
.xdata$x:00002E44 ; Segment permissions: Read
.xdata$x:00002E44 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E44                 assume cs:_xdata$x
.xdata$x:00002E44                 ;org 2E44h
.xdata$x:00002E44 ; COMDAT (pick associative to section at 1170)
.xdata$x:00002E44 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002E44                                         ; DATA XREF: .xdata$x:00002E54o
.xdata$x:00002E45                 db 0FFh
.xdata$x:00002E46                 db 0FFh
.xdata$x:00002E47                 db 0FFh
.xdata$x:00002E48                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002E4C __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002E4C                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002E4D                 db    5
.xdata$x:00002E4E                 db  93h ; ô
.xdata$x:00002E4F                 db  19h
.xdata$x:00002E50                 db    1
.xdata$x:00002E51                 db    0
.xdata$x:00002E52                 db    0
.xdata$x:00002E53                 db    0
.xdata$x:00002E54                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002E58                 db    0
.xdata$x:00002E59                 db    0
.xdata$x:00002E5A                 db    0
.xdata$x:00002E5B                 db    0
.xdata$x:00002E5C                 db    0
.xdata$x:00002E5D                 db    0
.xdata$x:00002E5E                 db    0
.xdata$x:00002E5F                 db    0
.xdata$x:00002E60                 db    0
.xdata$x:00002E61                 db    0
.xdata$x:00002E62                 db    0
.xdata$x:00002E63                 db    0
.xdata$x:00002E64                 db    0
.xdata$x:00002E65                 db    0
.xdata$x:00002E66                 db    0
.xdata$x:00002E67                 db    0
.xdata$x:00002E68                 db    0
.xdata$x:00002E69                 db    0
.xdata$x:00002E6A                 db    0
.xdata$x:00002E6B                 db    0
.xdata$x:00002E6C                 db    0
.xdata$x:00002E6D                 db    0
.xdata$x:00002E6E                 db    0
.xdata$x:00002E6F                 db    0
.xdata$x:00002E6F _xdata$x        ends
.xdata$x:00002E6F
.xdata$x:00002E70 ; ===========================================================================
.xdata$x:00002E70
.xdata$x:00002E70 ; Segment type: Pure data
.xdata$x:00002E70 ; Segment permissions: Read
.xdata$x:00002E70 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E70                 assume cs:_xdata$x
.xdata$x:00002E70                 ;org 2E70h
.xdata$x:00002E70 ; COMDAT (pick associative to section at CF8)
.xdata$x:00002E70 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00002E70                                         ; DATA XREF: .xdata$x:00002E80o
.xdata$x:00002E71                 db 0FFh
.xdata$x:00002E72                 db 0FFh
.xdata$x:00002E73                 db 0FFh
.xdata$x:00002E74                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00002E78 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00002E78                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00002E79                 db    5
.xdata$x:00002E7A                 db  93h ; ô
.xdata$x:00002E7B                 db  19h
.xdata$x:00002E7C                 db    1
.xdata$x:00002E7D                 db    0
.xdata$x:00002E7E                 db    0
.xdata$x:00002E7F                 db    0
.xdata$x:00002E80                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00002E84                 db    0
.xdata$x:00002E85                 db    0
.xdata$x:00002E86                 db    0
.xdata$x:00002E87                 db    0
.xdata$x:00002E88                 db    0
.xdata$x:00002E89                 db    0
.xdata$x:00002E8A                 db    0
.xdata$x:00002E8B                 db    0
.xdata$x:00002E8C                 db    0
.xdata$x:00002E8D                 db    0
.xdata$x:00002E8E                 db    0
.xdata$x:00002E8F                 db    0
.xdata$x:00002E90                 db    0
.xdata$x:00002E91                 db    0
.xdata$x:00002E92                 db    0
.xdata$x:00002E93                 db    0
.xdata$x:00002E94                 db    0
.xdata$x:00002E95                 db    0
.xdata$x:00002E96                 db    0
.xdata$x:00002E97                 db    0
.xdata$x:00002E98                 db    0
.xdata$x:00002E99                 db    0
.xdata$x:00002E9A                 db    0
.xdata$x:00002E9B                 db    0
.xdata$x:00002E9B _xdata$x        ends
.xdata$x:00002E9B
.xdata$x:00002E9C ; ===========================================================================
.xdata$x:00002E9C
.xdata$x:00002E9C ; Segment type: Pure data
.xdata$x:00002E9C ; Segment permissions: Read
.xdata$x:00002E9C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E9C                 assume cs:_xdata$x
.xdata$x:00002E9C                 ;org 2E9Ch
.xdata$x:00002E9C ; COMDAT (pick associative to section at 10F8)
.xdata$x:00002E9C __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002E9C                                         ; DATA XREF: .xdata$x:00002EACo
.xdata$x:00002E9D                 db 0FFh
.xdata$x:00002E9E                 db 0FFh
.xdata$x:00002E9F                 db 0FFh
.xdata$x:00002EA0                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00002EA4 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002EA4                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00002EA5                 db    5
.xdata$x:00002EA6                 db  93h ; ô
.xdata$x:00002EA7                 db  19h
.xdata$x:00002EA8                 db    1
.xdata$x:00002EA9                 db    0
.xdata$x:00002EAA                 db    0
.xdata$x:00002EAB                 db    0
.xdata$x:00002EAC                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00002EB0                 db    0
.xdata$x:00002EB1                 db    0
.xdata$x:00002EB2                 db    0
.xdata$x:00002EB3                 db    0
.xdata$x:00002EB4                 db    0
.xdata$x:00002EB5                 db    0
.xdata$x:00002EB6                 db    0
.xdata$x:00002EB7                 db    0
.xdata$x:00002EB8                 db    0
.xdata$x:00002EB9                 db    0
.xdata$x:00002EBA                 db    0
.xdata$x:00002EBB                 db    0
.xdata$x:00002EBC                 db    0
.xdata$x:00002EBD                 db    0
.xdata$x:00002EBE                 db    0
.xdata$x:00002EBF                 db    0
.xdata$x:00002EC0                 db    0
.xdata$x:00002EC1                 db    0
.xdata$x:00002EC2                 db    0
.xdata$x:00002EC3                 db    0
.xdata$x:00002EC4                 db    0
.xdata$x:00002EC5                 db    0
.xdata$x:00002EC6                 db    0
.xdata$x:00002EC7                 db    0
.xdata$x:00002EC7 _xdata$x        ends
.xdata$x:00002EC7
.xdata$x:00002EC8 ; ===========================================================================
.xdata$x:00002EC8
.xdata$x:00002EC8 ; Segment type: Pure data
.xdata$x:00002EC8 ; Segment permissions: Read
.xdata$x:00002EC8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002EC8                 assume cs:_xdata$x
.xdata$x:00002EC8                 ;org 2EC8h
.xdata$x:00002EC8 ; COMDAT (pick associative to section at E5C)
.xdata$x:00002EC8 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00002EC8                                         ; DATA XREF: .xdata$x:00002ED8o
.xdata$x:00002EC9                 db 0FFh
.xdata$x:00002ECA                 db 0FFh
.xdata$x:00002ECB                 db 0FFh
.xdata$x:00002ECC                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00002ED0 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00002ED0                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00002ED1                 db    5
.xdata$x:00002ED2                 db  93h ; ô
.xdata$x:00002ED3                 db  19h
.xdata$x:00002ED4                 db    1
.xdata$x:00002ED5                 db    0
.xdata$x:00002ED6                 db    0
.xdata$x:00002ED7                 db    0
.xdata$x:00002ED8                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00002EDC                 db    0
.xdata$x:00002EDD                 db    0
.xdata$x:00002EDE                 db    0
.xdata$x:00002EDF                 db    0
.xdata$x:00002EE0                 db    0
.xdata$x:00002EE1                 db    0
.xdata$x:00002EE2                 db    0
.xdata$x:00002EE3                 db    0
.xdata$x:00002EE4                 db    0
.xdata$x:00002EE5                 db    0
.xdata$x:00002EE6                 db    0
.xdata$x:00002EE7                 db    0
.xdata$x:00002EE8                 db    0
.xdata$x:00002EE9                 db    0
.xdata$x:00002EEA                 db    0
.xdata$x:00002EEB                 db    0
.xdata$x:00002EEC                 db    0
.xdata$x:00002EED                 db    0
.xdata$x:00002EEE                 db    0
.xdata$x:00002EEF                 db    0
.xdata$x:00002EF0                 db    0
.xdata$x:00002EF1                 db    0
.xdata$x:00002EF2                 db    0
.xdata$x:00002EF3                 db    0
.xdata$x:00002EF3 _xdata$x        ends
.xdata$x:00002EF3
.xdata$x:00002EF4 ; ===========================================================================
.xdata$x:00002EF4
.xdata$x:00002EF4 ; Segment type: Pure data
.xdata$x:00002EF4 ; Segment permissions: Read
.xdata$x:00002EF4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002EF4                 assume cs:_xdata$x
.xdata$x:00002EF4                 ;org 2EF4h
.xdata$x:00002EF4 ; COMDAT (pick associative to section at 11E0)
.xdata$x:00002EF4 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00002EF4                                         ; DATA XREF: .xdata$x:00002F04o
.xdata$x:00002EF5                 db 0FFh
.xdata$x:00002EF6                 db 0FFh
.xdata$x:00002EF7                 db 0FFh
.xdata$x:00002EF8                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00002EFC __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00002EFC                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00002EFD                 db    5
.xdata$x:00002EFE                 db  93h ; ô
.xdata$x:00002EFF                 db  19h
.xdata$x:00002F00                 db    1
.xdata$x:00002F01                 db    0
.xdata$x:00002F02                 db    0
.xdata$x:00002F03                 db    0
.xdata$x:00002F04                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00002F08                 align 20h
.xdata$x:00002F08 _xdata$x        ends
.xdata$x:00002F08
.xdata$x:00002F20 ; ===========================================================================
.xdata$x:00002F20
.xdata$x:00002F20 ; Segment type: Pure data
.xdata$x:00002F20 ; Segment permissions: Read
.xdata$x:00002F20 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002F20                 assume cs:_xdata$x
.xdata$x:00002F20                 ;org 2F20h
.xdata$x:00002F20 ; COMDAT (pick associative to section at 16A0)
.xdata$x:00002F20 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00002F20                                         ; DATA XREF: .xdata$x:00002FA8o
.xdata$x:00002F21                 db    0
.xdata$x:00002F22                 db    0
.xdata$x:00002F23                 db    0
.xdata$x:00002F24                 db    0
.xdata$x:00002F25                 db    0
.xdata$x:00002F26                 db    0
.xdata$x:00002F27                 db    0
.xdata$x:00002F28                 db    0
.xdata$x:00002F29                 db    0
.xdata$x:00002F2A                 db    0
.xdata$x:00002F2B                 db    0
.xdata$x:00002F2C                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00002F30 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00002F30                                         ; DATA XREF: .xdata$x:00002F94o
.xdata$x:00002F31                 db    0
.xdata$x:00002F32                 db    0
.xdata$x:00002F33                 db    0
.xdata$x:00002F34                 db    0
.xdata$x:00002F35                 db    0
.xdata$x:00002F36                 db    0
.xdata$x:00002F37                 db    0
.xdata$x:00002F38                 db    0
.xdata$x:00002F39                 db    0
.xdata$x:00002F3A                 db    0
.xdata$x:00002F3B                 db    0
.xdata$x:00002F3C                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00002F40 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00002F40                                         ; DATA XREF: .xdata$x:00002F68o
.xdata$x:00002F41                 db 0FFh
.xdata$x:00002F42                 db 0FFh
.xdata$x:00002F43                 db 0FFh
.xdata$x:00002F44                 db    0
.xdata$x:00002F45                 db    0
.xdata$x:00002F46                 db    0
.xdata$x:00002F47                 db    0
.xdata$x:00002F48                 db 0FFh
.xdata$x:00002F49                 db 0FFh
.xdata$x:00002F4A                 db 0FFh
.xdata$x:00002F4B                 db 0FFh
.xdata$x:00002F4C                 db    0
.xdata$x:00002F4D                 db    0
.xdata$x:00002F4E                 db    0
.xdata$x:00002F4F                 db    0
.xdata$x:00002F50                 db    1
.xdata$x:00002F51                 db    0
.xdata$x:00002F52                 db    0
.xdata$x:00002F53                 db    0
.xdata$x:00002F54                 db    0
.xdata$x:00002F55                 db    0
.xdata$x:00002F56                 db    0
.xdata$x:00002F57                 db    0
.xdata$x:00002F58                 db    1
.xdata$x:00002F59                 db    0
.xdata$x:00002F5A                 db    0
.xdata$x:00002F5B                 db    0
.xdata$x:00002F5C                 db    0
.xdata$x:00002F5D                 db    0
.xdata$x:00002F5E                 db    0
.xdata$x:00002F5F                 db    0
.xdata$x:00002F60 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00002F60                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00002F61                 db    5
.xdata$x:00002F62                 db  93h ; ô
.xdata$x:00002F63                 db  19h
.xdata$x:00002F64                 db    4
.xdata$x:00002F65                 db    0
.xdata$x:00002F66                 db    0
.xdata$x:00002F67                 db    0
.xdata$x:00002F68                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002F6C                 db    2
.xdata$x:00002F6D                 db    0
.xdata$x:00002F6E                 db    0
.xdata$x:00002F6F                 db    0
.xdata$x:00002F70                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002F74                 db    0
.xdata$x:00002F75                 db    0
.xdata$x:00002F76                 db    0
.xdata$x:00002F77                 db    0
.xdata$x:00002F78                 db    0
.xdata$x:00002F79                 db    0
.xdata$x:00002F7A                 db    0
.xdata$x:00002F7B                 db    0
.xdata$x:00002F7C                 db    0
.xdata$x:00002F7D                 db    0
.xdata$x:00002F7E                 db    0
.xdata$x:00002F7F                 db    0
.xdata$x:00002F80                 db    0
.xdata$x:00002F81                 db    0
.xdata$x:00002F82                 db    0
.xdata$x:00002F83                 db    0
.xdata$x:00002F84 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00002F84                                         ; DATA XREF: .xdata$x:00002F70o
.xdata$x:00002F85                 db    0
.xdata$x:00002F86                 db    0
.xdata$x:00002F87                 db    0
.xdata$x:00002F88                 db    2
.xdata$x:00002F89                 db    0
.xdata$x:00002F8A                 db    0
.xdata$x:00002F8B                 db    0
.xdata$x:00002F8C                 db    3
.xdata$x:00002F8D                 db    0
.xdata$x:00002F8E                 db    0
.xdata$x:00002F8F                 db    0
.xdata$x:00002F90                 db    1
.xdata$x:00002F91                 db    0
.xdata$x:00002F92                 db    0
.xdata$x:00002F93                 db    0
.xdata$x:00002F94                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00002F98                 align 10h
.xdata$x:00002FA0                 db    3
.xdata$x:00002FA1                 db    0
.xdata$x:00002FA2                 db    0
.xdata$x:00002FA3                 db    0
.xdata$x:00002FA4                 db    1
.xdata$x:00002FA5                 db    0
.xdata$x:00002FA6                 db    0
.xdata$x:00002FA7                 db    0
.xdata$x:00002FA8                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00002FA8 _xdata$x        ends
.xdata$x:00002FA8
.xdata$x:00002FAC ; ===========================================================================
.xdata$x:00002FAC
.xdata$x:00002FAC ; Segment type: Pure data
.xdata$x:00002FAC ; Segment permissions: Read
.xdata$x:00002FAC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002FAC                 assume cs:_xdata$x
.xdata$x:00002FAC                 ;org 2FACh
.xdata$x:00002FAC ; COMDAT (pick associative to section at F30)
.xdata$x:00002FAC __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002FAC                                         ; DATA XREF: .xdata$x:00002FBCo
.xdata$x:00002FAD                 db 0FFh
.xdata$x:00002FAE                 db 0FFh
.xdata$x:00002FAF                 db 0FFh
.xdata$x:00002FB0                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00002FB4 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002FB4                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00002FB5                 db    5
.xdata$x:00002FB6                 db  93h ; ô
.xdata$x:00002FB7                 db  19h
.xdata$x:00002FB8                 db    1
.xdata$x:00002FB9                 db    0
.xdata$x:00002FBA                 db    0
.xdata$x:00002FBB                 db    0
.xdata$x:00002FBC                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00002FC0                 db    0
.xdata$x:00002FC1                 db    0
.xdata$x:00002FC2                 db    0
.xdata$x:00002FC3                 db    0
.xdata$x:00002FC4                 db    0
.xdata$x:00002FC5                 db    0
.xdata$x:00002FC6                 db    0
.xdata$x:00002FC7                 db    0
.xdata$x:00002FC8                 db    0
.xdata$x:00002FC9                 db    0
.xdata$x:00002FCA                 db    0
.xdata$x:00002FCB                 db    0
.xdata$x:00002FCC                 db    0
.xdata$x:00002FCD                 db    0
.xdata$x:00002FCE                 db    0
.xdata$x:00002FCF                 db    0
.xdata$x:00002FD0                 db    0
.xdata$x:00002FD1                 db    0
.xdata$x:00002FD2                 db    0
.xdata$x:00002FD3                 db    0
.xdata$x:00002FD4                 db    0
.xdata$x:00002FD5                 db    0
.xdata$x:00002FD6                 db    0
.xdata$x:00002FD7                 db    0
.xdata$x:00002FD7 _xdata$x        ends
.xdata$x:00002FD7
.xdata$x:00002FD8 ; ===========================================================================
.xdata$x:00002FD8
.xdata$x:00002FD8 ; Segment type: Pure data
.xdata$x:00002FD8 ; Segment permissions: Read
.xdata$x:00002FD8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002FD8                 assume cs:_xdata$x
.xdata$x:00002FD8                 ;org 2FD8h
.xdata$x:00002FD8 ; COMDAT (pick associative to section at 2A10)
.xdata$x:00002FD8 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002FD8                                         ; DATA XREF: .xdata$x:00002FE8o
.xdata$x:00002FD9                 db 0FFh
.xdata$x:00002FDA                 db 0FFh
.xdata$x:00002FDB                 db 0FFh
.xdata$x:00002FDC                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002FE0 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002FE0                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002FE1                 db    5
.xdata$x:00002FE2                 db  93h ; ô
.xdata$x:00002FE3                 db  19h
.xdata$x:00002FE4                 db    1
.xdata$x:00002FE5                 db    0
.xdata$x:00002FE6                 db    0
.xdata$x:00002FE7                 db    0
.xdata$x:00002FE8                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002FEC                 db    0
.xdata$x:00002FED                 db    0
.xdata$x:00002FEE                 db    0
.xdata$x:00002FEF                 db    0
.xdata$x:00002FF0                 db    0
.xdata$x:00002FF1                 db    0
.xdata$x:00002FF2                 db    0
.xdata$x:00002FF3                 db    0
.xdata$x:00002FF4                 db    0
.xdata$x:00002FF5                 db    0
.xdata$x:00002FF6                 db    0
.xdata$x:00002FF7                 db    0
.xdata$x:00002FF8                 db    0
.xdata$x:00002FF9                 db    0
.xdata$x:00002FFA                 db    0
.xdata$x:00002FFB                 db    0
.xdata$x:00002FFC                 db    0
.xdata$x:00002FFD                 db    0
.xdata$x:00002FFE                 db    0
.xdata$x:00002FFF                 db    0
.xdata$x:00003000                 db    0
.xdata$x:00003001                 db    0
.xdata$x:00003002                 db    0
.xdata$x:00003003                 db    0
.xdata$x:00003003 _xdata$x        ends
.xdata$x:00003003
.xdata$x:00003004 ; ===========================================================================
.xdata$x:00003004
.xdata$x:00003004 ; Segment type: Pure data
.xdata$x:00003004 ; Segment permissions: Read
.xdata$x:00003004 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003004                 assume cs:_xdata$x
.xdata$x:00003004                 ;org 3004h
.xdata$x:00003004 ; COMDAT (pick associative to section at 1270)
.xdata$x:00003004 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00003004                                         ; DATA XREF: .xdata$x:00003014o
.xdata$x:00003005                 db 0FFh
.xdata$x:00003006                 db 0FFh
.xdata$x:00003007                 db 0FFh
.xdata$x:00003008                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:0000300C __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000300C                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:0000300D                 db    5
.xdata$x:0000300E                 db  93h ; ô
.xdata$x:0000300F                 db  19h
.xdata$x:00003010                 db    1
.xdata$x:00003011                 db    0
.xdata$x:00003012                 db    0
.xdata$x:00003013                 db    0
.xdata$x:00003014                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00003018                 db    0
.xdata$x:00003019                 db    0
.xdata$x:0000301A                 db    0
.xdata$x:0000301B                 db    0
.xdata$x:0000301C                 db    0
.xdata$x:0000301D                 db    0
.xdata$x:0000301E                 db    0
.xdata$x:0000301F                 db    0
.xdata$x:00003020                 db    0
.xdata$x:00003021                 db    0
.xdata$x:00003022                 db    0
.xdata$x:00003023                 db    0
.xdata$x:00003024                 db    0
.xdata$x:00003025                 db    0
.xdata$x:00003026                 db    0
.xdata$x:00003027                 db    0
.xdata$x:00003028                 db    0
.xdata$x:00003029                 db    0
.xdata$x:0000302A                 db    0
.xdata$x:0000302B                 db    0
.xdata$x:0000302C                 db    0
.xdata$x:0000302D                 db    0
.xdata$x:0000302E                 db    0
.xdata$x:0000302F                 db    0
.xdata$x:0000302F _xdata$x        ends
.xdata$x:0000302F
.xdata$x:00003030 ; ===========================================================================
.xdata$x:00003030
.xdata$x:00003030 ; Segment type: Pure data
.xdata$x:00003030 ; Segment permissions: Read
.xdata$x:00003030 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003030                 assume cs:_xdata$x
.xdata$x:00003030                 ;org 3030h
.xdata$x:00003030 ; COMDAT (pick associative to section at FAC)
.xdata$x:00003030 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00003030                                         ; DATA XREF: .xdata$x:00003040o
.xdata$x:00003031                 db 0FFh
.xdata$x:00003032                 db 0FFh
.xdata$x:00003033                 db 0FFh
.xdata$x:00003034                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00003038 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00003038                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00003039                 db    5
.xdata$x:0000303A                 db  93h ; ô
.xdata$x:0000303B                 db  19h
.xdata$x:0000303C                 db    1
.xdata$x:0000303D                 db    0
.xdata$x:0000303E                 db    0
.xdata$x:0000303F                 db    0
.xdata$x:00003040                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00003044                 db    0
.xdata$x:00003045                 db    0
.xdata$x:00003046                 db    0
.xdata$x:00003047                 db    0
.xdata$x:00003048                 db    0
.xdata$x:00003049                 db    0
.xdata$x:0000304A                 db    0
.xdata$x:0000304B                 db    0
.xdata$x:0000304C                 db    0
.xdata$x:0000304D                 db    0
.xdata$x:0000304E                 db    0
.xdata$x:0000304F                 db    0
.xdata$x:00003050                 db    0
.xdata$x:00003051                 db    0
.xdata$x:00003052                 db    0
.xdata$x:00003053                 db    0
.xdata$x:00003054                 db    0
.xdata$x:00003055                 db    0
.xdata$x:00003056                 db    0
.xdata$x:00003057                 db    0
.xdata$x:00003058                 db    0
.xdata$x:00003059                 db    0
.xdata$x:0000305A                 db    0
.xdata$x:0000305B                 db    0
.xdata$x:0000305B _xdata$x        ends
.xdata$x:0000305B
.xdata$x:0000305C ; ===========================================================================
.xdata$x:0000305C
.xdata$x:0000305C ; Segment type: Pure data
.xdata$x:0000305C ; Segment permissions: Read
.xdata$x:0000305C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000305C                 assume cs:_xdata$x
.xdata$x:0000305C                 ;org 305Ch
.xdata$x:0000305C ; COMDAT (pick associative to section at 2AC8)
.xdata$x:0000305C __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000305C                                         ; DATA XREF: .xdata$x:0000306Co
.xdata$x:0000305D                 db 0FFh
.xdata$x:0000305E                 db 0FFh
.xdata$x:0000305F                 db 0FFh
.xdata$x:00003060                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00003064 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00003064                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00003065                 db    5
.xdata$x:00003066                 db  93h ; ô
.xdata$x:00003067                 db  19h
.xdata$x:00003068                 db    1
.xdata$x:00003069                 db    0
.xdata$x:0000306A                 db    0
.xdata$x:0000306B                 db    0
.xdata$x:0000306C                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00003070                 db    0
.xdata$x:00003071                 db    0
.xdata$x:00003072                 db    0
.xdata$x:00003073                 db    0
.xdata$x:00003074                 db    0
.xdata$x:00003075                 db    0
.xdata$x:00003076                 db    0
.xdata$x:00003077                 db    0
.xdata$x:00003078                 db    0
.xdata$x:00003079                 db    0
.xdata$x:0000307A                 db    0
.xdata$x:0000307B                 db    0
.xdata$x:0000307C                 db    0
.xdata$x:0000307D                 db    0
.xdata$x:0000307E                 db    0
.xdata$x:0000307F                 db    0
.xdata$x:00003080                 db    0
.xdata$x:00003081                 db    0
.xdata$x:00003082                 db    0
.xdata$x:00003083                 db    0
.xdata$x:00003084                 db    0
.xdata$x:00003085                 db    0
.xdata$x:00003086                 db    0
.xdata$x:00003087                 db    0
.xdata$x:00003087 _xdata$x        ends
.xdata$x:00003087
.xdata$x:00003088 ; ===========================================================================
.xdata$x:00003088
.xdata$x:00003088 ; Segment type: Pure data
.xdata$x:00003088 ; Segment permissions: Read
.xdata$x:00003088 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003088                 assume cs:_xdata$x
.xdata$x:00003088                 ;org 3088h
.xdata$x:00003088 ; COMDAT (pick associative to section at 12E0)
.xdata$x:00003088 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00003088                                         ; DATA XREF: .xdata$x:00003098o
.xdata$x:00003089                 db 0FFh
.xdata$x:0000308A                 db 0FFh
.xdata$x:0000308B                 db 0FFh
.xdata$x:0000308C                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00003090 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00003090                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00003091                 db    5
.xdata$x:00003092                 db  93h ; ô
.xdata$x:00003093                 db  19h
.xdata$x:00003094                 db    1
.xdata$x:00003095                 db    0
.xdata$x:00003096                 db    0
.xdata$x:00003097                 db    0
.xdata$x:00003098                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:0000309C                 db    0
.xdata$x:0000309D                 db    0
.xdata$x:0000309E                 db    0
.xdata$x:0000309F                 db    0
.xdata$x:000030A0                 db    0
.xdata$x:000030A1                 db    0
.xdata$x:000030A2                 db    0
.xdata$x:000030A3                 db    0
.xdata$x:000030A4                 db    0
.xdata$x:000030A5                 db    0
.xdata$x:000030A6                 db    0
.xdata$x:000030A7                 db    0
.xdata$x:000030A8                 db    0
.xdata$x:000030A9                 db    0
.xdata$x:000030AA                 db    0
.xdata$x:000030AB                 db    0
.xdata$x:000030AC                 db    0
.xdata$x:000030AD                 db    0
.xdata$x:000030AE                 db    0
.xdata$x:000030AF                 db    0
.xdata$x:000030B0                 db    0
.xdata$x:000030B1                 db    0
.xdata$x:000030B2                 db    0
.xdata$x:000030B3                 db    0
.xdata$x:000030B3 _xdata$x        ends
.xdata$x:000030B3
.xdata$x:000030B4 ; ===========================================================================
.xdata$x:000030B4
.xdata$x:000030B4 ; Segment type: Pure data
.xdata$x:000030B4 ; Segment permissions: Read
.xdata$x:000030B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000030B4                 assume cs:_xdata$x
.xdata$x:000030B4                 ;org 30B4h
.xdata$x:000030B4 ; COMDAT (pick associative to section at 1028)
.xdata$x:000030B4 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000030B4                                         ; DATA XREF: .xdata$x:000030C4o
.xdata$x:000030B5                 db 0FFh
.xdata$x:000030B6                 db 0FFh
.xdata$x:000030B7                 db 0FFh
.xdata$x:000030B8                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:000030BC __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000030BC                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:000030BD                 db    5
.xdata$x:000030BE                 db  93h ; ô
.xdata$x:000030BF                 db  19h
.xdata$x:000030C0                 db    1
.xdata$x:000030C1                 db    0
.xdata$x:000030C2                 db    0
.xdata$x:000030C3                 db    0
.xdata$x:000030C4                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:000030C8                 align 20h
.xdata$x:000030C8 _xdata$x        ends
.xdata$x:000030C8
.xdata$x:000030E0 ; ===========================================================================
.xdata$x:000030E0
.xdata$x:000030E0 ; Segment type: Pure data
.xdata$x:000030E0 ; Segment permissions: Read
.xdata$x:000030E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000030E0                 assume cs:_xdata$x
.xdata$x:000030E0                 ;org 30E0h
.xdata$x:000030E0 ; COMDAT (pick associative to section at 2B8C)
.xdata$x:000030E0 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000030E0                                         ; DATA XREF: .xdata$x:000030F0o
.xdata$x:000030E1                 db 0FFh
.xdata$x:000030E2                 db 0FFh
.xdata$x:000030E3                 db 0FFh
.xdata$x:000030E4                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000030E8 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000030E8                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000030E9                 db    5
.xdata$x:000030EA                 db  93h ; ô
.xdata$x:000030EB                 db  19h
.xdata$x:000030EC                 db    1
.xdata$x:000030ED                 db    0
.xdata$x:000030EE                 db    0
.xdata$x:000030EF                 db    0
.xdata$x:000030F0                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000030F4                 db    0
.xdata$x:000030F5                 db    0
.xdata$x:000030F6                 db    0
.xdata$x:000030F7                 db    0
.xdata$x:000030F8                 db    0
.xdata$x:000030F9                 db    0
.xdata$x:000030FA                 db    0
.xdata$x:000030FB                 db    0
.xdata$x:000030FC                 db    0
.xdata$x:000030FD                 db    0
.xdata$x:000030FE                 db    0
.xdata$x:000030FF                 db    0
.xdata$x:00003100                 db    0
.xdata$x:00003101                 db    0
.xdata$x:00003102                 db    0
.xdata$x:00003103                 db    0
.xdata$x:00003104                 db    0
.xdata$x:00003105                 db    0
.xdata$x:00003106                 db    0
.xdata$x:00003107                 db    0
.xdata$x:00003108                 db    0
.xdata$x:00003109                 db    0
.xdata$x:0000310A                 db    0
.xdata$x:0000310B                 db    0
.xdata$x:0000310B _xdata$x        ends
.xdata$x:0000310B
.xdata$x:0000310C ; ===========================================================================
.xdata$x:0000310C
.xdata$x:0000310C ; Segment type: Pure data
.xdata$x:0000310C ; Segment permissions: Read
.xdata$x:0000310C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000310C                 assume cs:_xdata$x
.xdata$x:0000310C                 ;org 310Ch
.xdata$x:0000310C ; COMDAT (pick associative to section at 1350)
.xdata$x:0000310C __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000310C                                         ; DATA XREF: .xdata$x:0000311Co
.xdata$x:0000310D                 db 0FFh
.xdata$x:0000310E                 db 0FFh
.xdata$x:0000310F                 db 0FFh
.xdata$x:00003110                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00003114 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00003114                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00003115                 db    5
.xdata$x:00003116                 db  93h ; ô
.xdata$x:00003117                 db  19h
.xdata$x:00003118                 db    1
.xdata$x:00003119                 db    0
.xdata$x:0000311A                 db    0
.xdata$x:0000311B                 db    0
.xdata$x:0000311C                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00003120                 db    0
.xdata$x:00003121                 db    0
.xdata$x:00003122                 db    0
.xdata$x:00003123                 db    0
.xdata$x:00003124                 db    0
.xdata$x:00003125                 db    0
.xdata$x:00003126                 db    0
.xdata$x:00003127                 db    0
.xdata$x:00003128                 db    0
.xdata$x:00003129                 db    0
.xdata$x:0000312A                 db    0
.xdata$x:0000312B                 db    0
.xdata$x:0000312C                 db    0
.xdata$x:0000312D                 db    0
.xdata$x:0000312E                 db    0
.xdata$x:0000312F                 db    0
.xdata$x:00003130                 db    0
.xdata$x:00003131                 db    0
.xdata$x:00003132                 db    0
.xdata$x:00003133                 db    0
.xdata$x:00003134                 db    0
.xdata$x:00003135                 db    0
.xdata$x:00003136                 db    0
.xdata$x:00003137                 db    0
.xdata$x:00003137 _xdata$x        ends
.xdata$x:00003137
.xdata$x:00003138 ; ===========================================================================
.xdata$x:00003138
.xdata$x:00003138 ; Segment type: Pure data
.xdata$x:00003138 ; Segment permissions: Read
.xdata$x:00003138 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003138                 assume cs:_xdata$x
.xdata$x:00003138                 ;org 3138h
.xdata$x:00003138 ; COMDAT (pick associative to section at 1860)
.xdata$x:00003138 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00003138                                         ; DATA XREF: .xdata$x:000031C0o
.xdata$x:00003139                 db    0
.xdata$x:0000313A                 db    0
.xdata$x:0000313B                 db    0
.xdata$x:0000313C                 db    0
.xdata$x:0000313D                 db    0
.xdata$x:0000313E                 db    0
.xdata$x:0000313F                 db    0
.xdata$x:00003140                 db    0
.xdata$x:00003141                 db    0
.xdata$x:00003142                 db    0
.xdata$x:00003143                 db    0
.xdata$x:00003144                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.xdata$x:00003148 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00003148                                         ; DATA XREF: .xdata$x:000031ACo
.xdata$x:00003149                 db    0
.xdata$x:0000314A                 db    0
.xdata$x:0000314B                 db    0
.xdata$x:0000314C                 db    0
.xdata$x:0000314D                 db    0
.xdata$x:0000314E                 db    0
.xdata$x:0000314F                 db    0
.xdata$x:00003150                 db    0
.xdata$x:00003151                 db    0
.xdata$x:00003152                 db    0
.xdata$x:00003153                 db    0
.xdata$x:00003154                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
.xdata$x:00003158 __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00003158                                         ; DATA XREF: .xdata$x:00003180o
.xdata$x:00003159                 db 0FFh
.xdata$x:0000315A                 db 0FFh
.xdata$x:0000315B                 db 0FFh
.xdata$x:0000315C                 db    0
.xdata$x:0000315D                 db    0
.xdata$x:0000315E                 db    0
.xdata$x:0000315F                 db    0
.xdata$x:00003160                 db 0FFh
.xdata$x:00003161                 db 0FFh
.xdata$x:00003162                 db 0FFh
.xdata$x:00003163                 db 0FFh
.xdata$x:00003164                 db    0
.xdata$x:00003165                 db    0
.xdata$x:00003166                 db    0
.xdata$x:00003167                 db    0
.xdata$x:00003168                 db    1
.xdata$x:00003169                 db    0
.xdata$x:0000316A                 db    0
.xdata$x:0000316B                 db    0
.xdata$x:0000316C                 db    0
.xdata$x:0000316D                 db    0
.xdata$x:0000316E                 db    0
.xdata$x:0000316F                 db    0
.xdata$x:00003170                 db    1
.xdata$x:00003171                 db    0
.xdata$x:00003172                 db    0
.xdata$x:00003173                 db    0
.xdata$x:00003174                 db    0
.xdata$x:00003175                 db    0
.xdata$x:00003176                 db    0
.xdata$x:00003177                 db    0
.xdata$x:00003178 __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00003178                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z+11o
.xdata$x:00003179                 db    5
.xdata$x:0000317A                 db  93h ; ô
.xdata$x:0000317B                 db  19h
.xdata$x:0000317C                 db    4
.xdata$x:0000317D                 db    0
.xdata$x:0000317E                 db    0
.xdata$x:0000317F                 db    0
.xdata$x:00003180                 dd offset __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:00003184                 db    2
.xdata$x:00003185                 db    0
.xdata$x:00003186                 db    0
.xdata$x:00003187                 db    0
.xdata$x:00003188                 dd offset __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:0000318C                 db    0
.xdata$x:0000318D                 db    0
.xdata$x:0000318E                 db    0
.xdata$x:0000318F                 db    0
.xdata$x:00003190                 db    0
.xdata$x:00003191                 db    0
.xdata$x:00003192                 db    0
.xdata$x:00003193                 db    0
.xdata$x:00003194                 db    0
.xdata$x:00003195                 db    0
.xdata$x:00003196                 db    0
.xdata$x:00003197                 db    0
.xdata$x:00003198                 db    0
.xdata$x:00003199                 db    0
.xdata$x:0000319A                 db    0
.xdata$x:0000319B                 db    0
.xdata$x:0000319C __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db    2
.xdata$x:0000319C                                         ; DATA XREF: .xdata$x:00003188o
.xdata$x:0000319D                 db    0
.xdata$x:0000319E                 db    0
.xdata$x:0000319F                 db    0
.xdata$x:000031A0                 db    2
.xdata$x:000031A1                 db    0
.xdata$x:000031A2                 db    0
.xdata$x:000031A3                 db    0
.xdata$x:000031A4                 db    3
.xdata$x:000031A5                 db    0
.xdata$x:000031A6                 db    0
.xdata$x:000031A7                 db    0
.xdata$x:000031A8                 db    1
.xdata$x:000031A9                 db    0
.xdata$x:000031AA                 db    0
.xdata$x:000031AB                 db    0
.xdata$x:000031AC                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4
.xdata$x:000031B0                 db    0
.xdata$x:000031B1                 db    0
.xdata$x:000031B2                 db    0
.xdata$x:000031B3                 db    0
.xdata$x:000031B4                 db    0
.xdata$x:000031B5                 db    0
.xdata$x:000031B6                 db    0
.xdata$x:000031B7                 db    0
.xdata$x:000031B8                 db    3
.xdata$x:000031B9                 db    0
.xdata$x:000031BA                 db    0
.xdata$x:000031BB                 db    0
.xdata$x:000031BC                 db    1
.xdata$x:000031BD                 db    0
.xdata$x:000031BE                 db    0
.xdata$x:000031BF                 db    0
.xdata$x:000031C0                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5
.xdata$x:000031C0 _xdata$x        ends
.xdata$x:000031C0
.xdata$x:000031C4 ; ===========================================================================
.xdata$x:000031C4
.xdata$x:000031C4 ; Segment type: Pure data
.xdata$x:000031C4 ; Segment permissions: Read
.xdata$x:000031C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000031C4                 assume cs:_xdata$x
.xdata$x:000031C4                 ;org 31C4h
.xdata$x:000031C4 ; COMDAT (pick associative to section at B90)
.xdata$x:000031C4 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:000031C4                                         ; DATA XREF: .xdata$x:000031D4o
.xdata$x:000031C5                 db 0FFh
.xdata$x:000031C6                 db 0FFh
.xdata$x:000031C7                 db 0FFh
.xdata$x:000031C8                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:000031CC __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:000031CC                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:000031CD                 db    5
.xdata$x:000031CE                 db  93h ; ô
.xdata$x:000031CF                 db  19h
.xdata$x:000031D0                 db    1
.xdata$x:000031D1                 db    0
.xdata$x:000031D2                 db    0
.xdata$x:000031D3                 db    0
.xdata$x:000031D4                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:000031D8                 db    0
.xdata$x:000031D9                 db    0
.xdata$x:000031DA                 db    0
.xdata$x:000031DB                 db    0
.xdata$x:000031DC                 db    0
.xdata$x:000031DD                 db    0
.xdata$x:000031DE                 db    0
.xdata$x:000031DF                 db    0
.xdata$x:000031E0                 db    0
.xdata$x:000031E1                 db    0
.xdata$x:000031E2                 db    0
.xdata$x:000031E3                 db    0
.xdata$x:000031E4                 db    0
.xdata$x:000031E5                 db    0
.xdata$x:000031E6                 db    0
.xdata$x:000031E7                 db    0
.xdata$x:000031E8                 db    0
.xdata$x:000031E9                 db    0
.xdata$x:000031EA                 db    0
.xdata$x:000031EB                 db    0
.xdata$x:000031EC                 db    0
.xdata$x:000031ED                 db    0
.xdata$x:000031EE                 db    0
.xdata$x:000031EF                 db    0
.xdata$x:000031EF _xdata$x        ends
.xdata$x:000031EF
.xdata$x:000031F0 ; ===========================================================================
.xdata$x:000031F0
.xdata$x:000031F0 ; Segment type: Pure data
.xdata$x:000031F0 ; Segment permissions: Read
.xdata$x:000031F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000031F0                 assume cs:_xdata$x
.xdata$x:000031F0                 ;org 31F0h
.xdata$x:000031F0 ; COMDAT (pick associative to section at 9BC)
.xdata$x:000031F0 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:000031F0                                         ; DATA XREF: .xdata$x:00003200o
.xdata$x:000031F1                 db 0FFh
.xdata$x:000031F2                 db 0FFh
.xdata$x:000031F3                 db 0FFh
.xdata$x:000031F4                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:000031F8 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:000031F8                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:000031F9                 db    5
.xdata$x:000031FA                 db  93h ; ô
.xdata$x:000031FB                 db  19h
.xdata$x:000031FC                 db    1
.xdata$x:000031FD                 db    0
.xdata$x:000031FE                 db    0
.xdata$x:000031FF                 db    0
.xdata$x:00003200                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00003204                 db    0
.xdata$x:00003205                 db    0
.xdata$x:00003206                 db    0
.xdata$x:00003207                 db    0
.xdata$x:00003208                 db    0
.xdata$x:00003209                 db    0
.xdata$x:0000320A                 db    0
.xdata$x:0000320B                 db    0
.xdata$x:0000320C                 db    0
.xdata$x:0000320D                 db    0
.xdata$x:0000320E                 db    0
.xdata$x:0000320F                 db    0
.xdata$x:00003210                 db    0
.xdata$x:00003211                 db    0
.xdata$x:00003212                 db    0
.xdata$x:00003213                 db    0
.xdata$x:00003214                 db    0
.xdata$x:00003215                 db    0
.xdata$x:00003216                 db    0
.xdata$x:00003217                 db    0
.xdata$x:00003218                 db    0
.xdata$x:00003219                 db    0
.xdata$x:0000321A                 db    0
.xdata$x:0000321B                 db    0
.xdata$x:0000321B _xdata$x        ends
.xdata$x:0000321B
.xdata$x:0000321C ; ===========================================================================
.xdata$x:0000321C
.xdata$x:0000321C ; Segment type: Pure data
.xdata$x:0000321C ; Segment permissions: Read
.xdata$x:0000321C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000321C                 assume cs:_xdata$x
.xdata$x:0000321C                 ;org 321Ch
.xdata$x:0000321C ; COMDAT (pick associative to section at ABC)
.xdata$x:0000321C __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db 0FFh
.xdata$x:0000321C                                         ; DATA XREF: .xdata$x:0000322Co
.xdata$x:0000321D                 db 0FFh
.xdata$x:0000321E                 db 0FFh
.xdata$x:0000321F                 db 0FFh
.xdata$x:00003220                 dd offset __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0
.xdata$x:00003224 __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db  22h ; "
.xdata$x:00003224                                         ; DATA XREF: __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z+11o
.xdata$x:00003225                 db    5
.xdata$x:00003226                 db  93h ; ô
.xdata$x:00003227                 db  19h
.xdata$x:00003228                 db    1
.xdata$x:00003229                 db    0
.xdata$x:0000322A                 db    0
.xdata$x:0000322B                 db    0
.xdata$x:0000322C                 dd offset __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.xdata$x:00003230                 db    0
.xdata$x:00003231                 db    0
.xdata$x:00003232                 db    0
.xdata$x:00003233                 db    0
.xdata$x:00003234                 db    0
.xdata$x:00003235                 db    0
.xdata$x:00003236                 db    0
.xdata$x:00003237                 db    0
.xdata$x:00003238                 db    0
.xdata$x:00003239                 db    0
.xdata$x:0000323A                 db    0
.xdata$x:0000323B                 db    0
.xdata$x:0000323C                 db    0
.xdata$x:0000323D                 db    0
.xdata$x:0000323E                 db    0
.xdata$x:0000323F                 db    0
.xdata$x:00003240                 db    0
.xdata$x:00003241                 db    0
.xdata$x:00003242                 db    0
.xdata$x:00003243                 db    0
.xdata$x:00003244                 db    0
.xdata$x:00003245                 db    0
.xdata$x:00003246                 db    0
.xdata$x:00003247                 db    0
.xdata$x:00003247 _xdata$x        ends
.xdata$x:00003247
.bss:00003248 ; ===========================================================================
.bss:00003248
.bss:00003248 ; Segment type: Uninitialized
.bss:00003248 ; Segment permissions: Read/Write
.bss:00003248 _bss            segment byte public 'BSS' use32
.bss:00003248                 assume cs:_bss
.bss:00003248                 ;org 3248h
.bss:00003248                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00003248 _allocator_arg  db    ? ;
.bss:00003249 _piecewise_construct db    ? ;
.bss:0000324A                 align 4
.bss:0000324A _bss            ends
.bss:0000324A
.rdata:0000324C ; ===========================================================================
.rdata:0000324C
.rdata:0000324C ; Segment type: Pure data
.rdata:0000324C ; Segment permissions: Read
.rdata:0000324C _rdata          segment dword public 'DATA' use32
.rdata:0000324C                 assume cs:_rdata
.rdata:0000324C                 ;org 324Ch
.rdata:0000324C ; COMDAT (pick largest)
.rdata:0000324C                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00003250                 public ??_7error_category@std@@6B@
.rdata:00003250 ; const std::error_category::`vftable'
.rdata:00003250 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00003250                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00003250                                         ; std::error_category::~error_category(void)+Ao
.rdata:00003250                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00003254                 dd offset __purecall
.rdata:00003258                 dd offset __purecall
.rdata:0000325C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00003260                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00003264                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00003264 _rdata          ends
.rdata:00003264
.rdata:00003268 ; ===========================================================================
.rdata:00003268
.rdata:00003268 ; Segment type: Pure data
.rdata:00003268 ; Segment permissions: Read
.rdata:00003268 _rdata          segment dword public 'DATA' use32
.rdata:00003268                 assume cs:_rdata
.rdata:00003268                 ;org 3268h
.rdata:00003268 ; COMDAT (pick largest)
.rdata:00003268                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:0000326C                 public ??_7_Generic_error_category@std@@6B@
.rdata:0000326C ; const std::_Generic_error_category::`vftable'
.rdata:0000326C ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:0000326C                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:0000326C                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00003270                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00003274                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00003278                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000327C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00003280                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00003280 _rdata          ends
.rdata:00003280
.rdata:00003284 ; ===========================================================================
.rdata:00003284
.rdata:00003284 ; Segment type: Pure data
.rdata:00003284 ; Segment permissions: Read
.rdata:00003284 _rdata          segment dword public 'DATA' use32
.rdata:00003284                 assume cs:_rdata
.rdata:00003284                 ;org 3284h
.rdata:00003284 ; COMDAT (pick any)
.rdata:00003284                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00003284 ; `string'
.rdata:00003284 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00003284                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00003284 _rdata          ends
.rdata:00003284
.rdata:0000328C ; ===========================================================================
.rdata:0000328C
.rdata:0000328C ; Segment type: Pure data
.rdata:0000328C ; Segment permissions: Read
.rdata:0000328C _rdata          segment dword public 'DATA' use32
.rdata:0000328C                 assume cs:_rdata
.rdata:0000328C                 ;org 328Ch
.rdata:0000328C ; COMDAT (pick any)
.rdata:0000328C                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:0000328C ; `string'
.rdata:0000328C ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:0000328C                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_2A5Co
.rdata:0000328C                                         ; std::_System_error_category::message(int):loc_2BD8o
.rdata:0000329A                 align 4
.rdata:0000329A _rdata          ends
.rdata:0000329A
.rdata:0000329C ; ===========================================================================
.rdata:0000329C
.rdata:0000329C ; Segment type: Pure data
.rdata:0000329C ; Segment permissions: Read
.rdata:0000329C _rdata          segment dword public 'DATA' use32
.rdata:0000329C                 assume cs:_rdata
.rdata:0000329C                 ;org 329Ch
.rdata:0000329C ; COMDAT (pick largest)
.rdata:0000329C                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:000032A0                 public ??_7_Iostream_error_category@std@@6B@
.rdata:000032A0 ; const std::_Iostream_error_category::`vftable'
.rdata:000032A0 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:000032A0                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:000032A0                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:000032A4                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:000032A8                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:000032AC                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:000032B0                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000032B4                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000032B4 _rdata          ends
.rdata:000032B4
.rdata:000032B8 ; ===========================================================================
.rdata:000032B8
.rdata:000032B8 ; Segment type: Pure data
.rdata:000032B8 ; Segment permissions: Read
.rdata:000032B8 _rdata          segment dword public 'DATA' use32
.rdata:000032B8                 assume cs:_rdata
.rdata:000032B8                 ;org 32B8h
.rdata:000032B8 ; COMDAT (pick any)
.rdata:000032B8                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:000032B8 ; `string'
.rdata:000032B8 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:000032B8                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:000032C1                 align 4
.rdata:000032C1 _rdata          ends
.rdata:000032C1
.rdata:000032C4 ; ===========================================================================
.rdata:000032C4
.rdata:000032C4 ; Segment type: Pure data
.rdata:000032C4 ; Segment permissions: Read
.rdata:000032C4 _rdata          segment dword public 'DATA' use32
.rdata:000032C4                 assume cs:_rdata
.rdata:000032C4                 ;org 32C4h
.rdata:000032C4 ; COMDAT (pick any)
.rdata:000032C4                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:000032C4 ; char `string'[]
.rdata:000032C4 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:000032C4                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:000032DA                 align 4
.rdata:000032DA _rdata          ends
.rdata:000032DA
.rdata:000032DC ; ===========================================================================
.rdata:000032DC
.rdata:000032DC ; Segment type: Pure data
.rdata:000032DC ; Segment permissions: Read
.rdata:000032DC _rdata          segment dword public 'DATA' use32
.rdata:000032DC                 assume cs:_rdata
.rdata:000032DC                 ;org 32DCh
.rdata:000032DC ; COMDAT (pick largest)
.rdata:000032DC                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:000032E0                 public ??_7_System_error_category@std@@6B@
.rdata:000032E0 ; const std::_System_error_category::`vftable'
.rdata:000032E0 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:000032E0                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:000032E0                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:000032E4                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:000032E8                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:000032EC                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:000032F0                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000032F4                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000032F4 _rdata          ends
.rdata:000032F4
.rdata:000032F8 ; ===========================================================================
.rdata:000032F8
.rdata:000032F8 ; Segment type: Pure data
.rdata:000032F8 ; Segment permissions: Read
.rdata:000032F8 _rdata          segment dword public 'DATA' use32
.rdata:000032F8                 assume cs:_rdata
.rdata:000032F8                 ;org 32F8h
.rdata:000032F8 ; COMDAT (pick any)
.rdata:000032F8                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:000032F8 ; `string'
.rdata:000032F8 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:000032F8                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:000032FF                 align 10h
.rdata:000032FF _rdata          ends
.rdata:000032FF
.bss:00003300 ; ===========================================================================
.bss:00003300
.bss:00003300 ; Segment type: Uninitialized
.bss:00003300 ; Segment permissions: Read/Write
.bss:00003300 _bss            segment dword public 'BSS' use32
.bss:00003300                 assume cs:_bss
.bss:00003300                 ;org 3300h
.bss:00003300 ; COMDAT (pick any)
.bss:00003300                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00003300                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00003300 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00003300 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00003300                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00003300                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00003301                 db    ? ;
.bss:00003302                 db    ? ;
.bss:00003303                 db    ? ;
.bss:00003303 _bss            ends
.bss:00003303
.bss:00003304 ; ===========================================================================
.bss:00003304
.bss:00003304 ; Segment type: Uninitialized
.bss:00003304 ; Segment permissions: Read/Write
.bss:00003304 _bss            segment dword public 'BSS' use32
.bss:00003304                 assume cs:_bss
.bss:00003304                 ;org 3304h
.bss:00003304 ; COMDAT (pick any)
.bss:00003304                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00003304                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00003304 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00003304 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00003304                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00003304                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00003305                 db    ? ;
.bss:00003306                 db    ? ;
.bss:00003307                 db    ? ;
.bss:00003307 _bss            ends
.bss:00003307
.bss:00003308 ; ===========================================================================
.bss:00003308
.bss:00003308 ; Segment type: Uninitialized
.bss:00003308 ; Segment permissions: Read/Write
.bss:00003308 _bss            segment dword public 'BSS' use32
.bss:00003308                 assume cs:_bss
.bss:00003308                 ;org 3308h
.bss:00003308 ; COMDAT (pick any)
.bss:00003308                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00003308                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00003308 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00003308 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00003308                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00003308                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00003309                 db    ? ;
.bss:0000330A                 db    ? ;
.bss:0000330B                 db    ? ;
.bss:0000330B _bss            ends
.bss:0000330B
.bss:0000330C ; ===========================================================================
.bss:0000330C
.bss:0000330C ; Segment type: Uninitialized
.bss:0000330C ; Segment permissions: Read/Write
.bss:0000330C _bss            segment dword public 'BSS' use32
.bss:0000330C                 assume cs:_bss
.bss:0000330C                 ;org 330Ch
.bss:0000330C ; COMDAT (pick any)
.bss:0000330C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000330C                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000330C ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:0000330C ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000330C                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:0000330D                 db    ? ;
.bss:0000330E                 db    ? ;
.bss:0000330F                 db    ? ;
.bss:0000330F _bss            ends
.bss:0000330F
.bss:00003310 ; ===========================================================================
.bss:00003310
.bss:00003310 ; Segment type: Uninitialized
.bss:00003310 ; Segment permissions: Read/Write
.bss:00003310 _bss            segment dword public 'BSS' use32
.bss:00003310                 assume cs:_bss
.bss:00003310                 ;org 3310h
.bss:00003310 ; COMDAT (pick any)
.bss:00003310                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00003310                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00003310 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00003310 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00003310                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00003311                 db    ? ;
.bss:00003312                 db    ? ;
.bss:00003313                 db    ? ;
.bss:00003313 _bss            ends
.bss:00003313
.rdata:00003314 ; ===========================================================================
.rdata:00003314
.rdata:00003314 ; Segment type: Pure data
.rdata:00003314 ; Segment permissions: Read
.rdata:00003314 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00003314 _rdata          segment para public 'DATA' use32
.rdata:00003314                 assume cs:_rdata
.rdata:00003314                 ;org 3314h
.rdata:00003314 ; COMDAT (pick any)
.rdata:00003314                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00003314 ; wchar_t `string'
.rdata:00003314 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00003314                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00003314                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o ...
.rdata:00003314                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00003314                 unicode 0, <clude\xstring>,0
.rdata:000033A2                 align 4
.rdata:000033A2 _rdata          ends
.rdata:000033A2
.bss:000033A4 ; ===========================================================================
.bss:000033A4
.bss:000033A4 ; Segment type: Uninitialized
.bss:000033A4 ; Segment permissions: Read/Write
.bss:000033A4 _bss            segment dword public 'BSS' use32
.bss:000033A4                 assume cs:_bss
.bss:000033A4                 ;org 33A4h
.bss:000033A4 ; COMDAT (pick any)
.bss:000033A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000033A4                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:000033A4 ; std::locale::id std::numpunct<char>::id
.bss:000033A4 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:000033A4                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:000033A5                 db    ? ;
.bss:000033A6                 db    ? ;
.bss:000033A7                 db    ? ;
.bss:000033A7 _bss            ends
.bss:000033A7
.bss:000033A8 ; ===========================================================================
.bss:000033A8
.bss:000033A8 ; Segment type: Uninitialized
.bss:000033A8 ; Segment permissions: Read/Write
.bss:000033A8 _bss            segment dword public 'BSS' use32
.bss:000033A8                 assume cs:_bss
.bss:000033A8                 ;org 33A8h
.bss:000033A8 ; COMDAT (pick any)
.bss:000033A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000033A8                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:000033A8 ; std::locale::id std::numpunct<wchar_t>::id
.bss:000033A8 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:000033A8                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:000033A9                 db    ? ;
.bss:000033AA                 db    ? ;
.bss:000033AB                 db    ? ;
.bss:000033AB _bss            ends
.bss:000033AB
.rdata:000033AC ; ===========================================================================
.rdata:000033AC
.rdata:000033AC ; Segment type: Pure data
.rdata:000033AC ; Segment permissions: Read
.rdata:000033AC _rdata          segment dword public 'DATA' use32
.rdata:000033AC                 assume cs:_rdata
.rdata:000033AC                 ;org 33ACh
.rdata:000033AC ; COMDAT (pick any)
.rdata:000033AC                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:000033AC ; char `string'[]
.rdata:000033AC ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:000033AC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:000033AC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+7o
.rdata:000033AC _rdata          ends
.rdata:000033AC
.rdata:000033BC ; ===========================================================================
.rdata:000033BC
.rdata:000033BC ; Segment type: Pure data
.rdata:000033BC ; Segment permissions: Read
.rdata:000033BC _rdata          segment dword public 'DATA' use32
.rdata:000033BC                 assume cs:_rdata
.rdata:000033BC                 ;org 33BCh
.rdata:000033BC ; COMDAT (pick any)
.rdata:000033BC                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:000033BC ; char `string'[]
.rdata:000033BC ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:000033BC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:000033BC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+7o
.rdata:000033BC _rdata          ends
.rdata:000033BC
.rdata:000033D4 ; ===========================================================================
.rdata:000033D4
.rdata:000033D4 ; Segment type: Pure data
.rdata:000033D4 ; Segment permissions: Read
.rdata:000033D4 _rdata          segment dword public 'DATA' use32
.rdata:000033D4                 assume cs:_rdata
.rdata:000033D4                 ;org 33D4h
.rdata:000033D4 ; COMDAT (pick any)
.rdata:000033D4                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:000033D4 ; wchar_t `string'
.rdata:000033D4 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:000033D4                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:000033D4                                         ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+11o
.rdata:000033D4                 unicode 0, <invalid null pointer>,0
.rdata:000033FE                 align 10h
.rdata:000033FE _rdata          ends
.rdata:000033FE
.rdata$r:00003400 ; ===========================================================================
.rdata$r:00003400
.rdata$r:00003400 ; Segment type: Pure data
.rdata$r:00003400 ; Segment permissions: Read
.rdata$r:00003400 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003400                 assume cs:_rdata$r
.rdata$r:00003400                 ;org 3400h
.rdata$r:00003400 ; COMDAT (pick any)
.rdata$r:00003400                 public ??_R4error_category@std@@6B@
.rdata$r:00003400 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00003400 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:0000324Co
.rdata$r:00003401                 db    0
.rdata$r:00003402                 db    0
.rdata$r:00003403                 db    0
.rdata$r:00003404                 db    0
.rdata$r:00003405                 db    0
.rdata$r:00003406                 db    0
.rdata$r:00003407                 db    0
.rdata$r:00003408                 db    0
.rdata$r:00003409                 db    0
.rdata$r:0000340A                 db    0
.rdata$r:0000340B                 db    0
.rdata$r:0000340C                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00003410                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003410 _rdata$r        ends
.rdata$r:00003410
.data$r:00003414 ; ===========================================================================
.data$r:00003414
.data$r:00003414 ; Segment type: Pure data
.data$r:00003414 ; Segment permissions: Read/Write
.data$r:00003414 _data$r         segment dword public 'DATA' use32
.data$r:00003414                 assume cs:_data$r
.data$r:00003414                 ;org 3414h
.data$r:00003414 ; COMDAT (pick any)
.data$r:00003414                 public ??_R0?AVerror_category@std@@@8
.data$r:00003414 ; class std::error_category `RTTI Type Descriptor'
.data$r:00003414 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003414                                         ; DATA XREF: .rdata$r:0000340Co
.data$r:00003414                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003414                                         ; const type_info::`vftable'
.data$r:00003418                 db    0
.data$r:00003419                 db    0
.data$r:0000341A                 db    0
.data$r:0000341B                 db    0
.data$r:0000341C                 db  2Eh ; .
.data$r:0000341D                 db  3Fh ; ?
.data$r:0000341E                 db  41h ; A
.data$r:0000341F                 db  56h ; V
.data$r:00003420                 db  65h ; e
.data$r:00003421                 db  72h ; r
.data$r:00003422                 db  72h ; r
.data$r:00003423                 db  6Fh ; o
.data$r:00003424                 db  72h ; r
.data$r:00003425                 db  5Fh ; _
.data$r:00003426                 db  63h ; c
.data$r:00003427                 db  61h ; a
.data$r:00003428                 db  74h ; t
.data$r:00003429                 db  65h ; e
.data$r:0000342A                 db  67h ; g
.data$r:0000342B                 db  6Fh ; o
.data$r:0000342C                 db  72h ; r
.data$r:0000342D                 db  79h ; y
.data$r:0000342E                 db  40h ; @
.data$r:0000342F                 db  73h ; s
.data$r:00003430                 db  74h ; t
.data$r:00003431                 db  64h ; d
.data$r:00003432                 db  40h ; @
.data$r:00003433                 db  40h ; @
.data$r:00003434                 db    0
.data$r:00003435                 align 4
.data$r:00003435 _data$r         ends
.data$r:00003435
.rdata$r:00003438 ; ===========================================================================
.rdata$r:00003438
.rdata$r:00003438 ; Segment type: Pure data
.rdata$r:00003438 ; Segment permissions: Read
.rdata$r:00003438 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003438                 assume cs:_rdata$r
.rdata$r:00003438                 ;org 3438h
.rdata$r:00003438 ; COMDAT (pick any)
.rdata$r:00003438                 public ??_R3error_category@std@@8
.rdata$r:00003438 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003438 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00003410o
.rdata$r:00003438                                         ; .rdata$r:00003468o
.rdata$r:00003439                 db    0
.rdata$r:0000343A                 db    0
.rdata$r:0000343B                 db    0
.rdata$r:0000343C                 db    0
.rdata$r:0000343D                 db    0
.rdata$r:0000343E                 db    0
.rdata$r:0000343F                 db    0
.rdata$r:00003440                 db    1
.rdata$r:00003441                 db    0
.rdata$r:00003442                 db    0
.rdata$r:00003443                 db    0
.rdata$r:00003444                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00003444 _rdata$r        ends
.rdata$r:00003444
.rdata$r:00003448 ; ===========================================================================
.rdata$r:00003448
.rdata$r:00003448 ; Segment type: Pure data
.rdata$r:00003448 ; Segment permissions: Read
.rdata$r:00003448 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003448                 assume cs:_rdata$r
.rdata$r:00003448                 ;org 3448h
.rdata$r:00003448 ; COMDAT (pick any)
.rdata$r:00003448                 public ??_R2error_category@std@@8
.rdata$r:00003448 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00003448 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00003448                                         ; DATA XREF: .rdata$r:00003444o
.rdata$r:00003448                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000344C                 db    0
.rdata$r:0000344D                 align 10h
.rdata$r:0000344D _rdata$r        ends
.rdata$r:0000344D
.rdata$r:00003450 ; ===========================================================================
.rdata$r:00003450
.rdata$r:00003450 ; Segment type: Pure data
.rdata$r:00003450 ; Segment permissions: Read
.rdata$r:00003450 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003450                 assume cs:_rdata$r
.rdata$r:00003450                 ;org 3450h
.rdata$r:00003450 ; COMDAT (pick any)
.rdata$r:00003450                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00003450 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003450 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00003450                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00003450                                         ; .rdata$r:000034C0o ...
.rdata$r:00003450                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00003454                 db    0
.rdata$r:00003455                 db    0
.rdata$r:00003456                 db    0
.rdata$r:00003457                 db    0
.rdata$r:00003458                 db    0
.rdata$r:00003459                 db    0
.rdata$r:0000345A                 db    0
.rdata$r:0000345B                 db    0
.rdata$r:0000345C                 db 0FFh
.rdata$r:0000345D                 db 0FFh
.rdata$r:0000345E                 db 0FFh
.rdata$r:0000345F                 db 0FFh
.rdata$r:00003460                 db    0
.rdata$r:00003461                 db    0
.rdata$r:00003462                 db    0
.rdata$r:00003463                 db    0
.rdata$r:00003464                 db  40h ; @
.rdata$r:00003465                 db    0
.rdata$r:00003466                 db    0
.rdata$r:00003467                 db    0
.rdata$r:00003468                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003468 _rdata$r        ends
.rdata$r:00003468
.rdata$r:0000346C ; ===========================================================================
.rdata$r:0000346C
.rdata$r:0000346C ; Segment type: Pure data
.rdata$r:0000346C ; Segment permissions: Read
.rdata$r:0000346C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000346C                 assume cs:_rdata$r
.rdata$r:0000346C                 ;org 346Ch
.rdata$r:0000346C ; COMDAT (pick any)
.rdata$r:0000346C                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:0000346C ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:0000346C ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:0000346C                                         ; DATA XREF: .rdata:00003268o
.rdata$r:0000346D                 db    0
.rdata$r:0000346E                 db    0
.rdata$r:0000346F                 db    0
.rdata$r:00003470                 db    0
.rdata$r:00003471                 db    0
.rdata$r:00003472                 db    0
.rdata$r:00003473                 db    0
.rdata$r:00003474                 db    0
.rdata$r:00003475                 db    0
.rdata$r:00003476                 db    0
.rdata$r:00003477                 db    0
.rdata$r:00003478                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000347C                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000347C _rdata$r        ends
.rdata$r:0000347C
.data$r:00003480 ; ===========================================================================
.data$r:00003480
.data$r:00003480 ; Segment type: Pure data
.data$r:00003480 ; Segment permissions: Read/Write
.data$r:00003480 _data$r         segment dword public 'DATA' use32
.data$r:00003480                 assume cs:_data$r
.data$r:00003480                 ;org 3480h
.data$r:00003480 ; COMDAT (pick any)
.data$r:00003480                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00003480 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00003480 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003480                                         ; DATA XREF: .rdata$r:00003478o
.data$r:00003480                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003480                                         ; const type_info::`vftable'
.data$r:00003484                 align 8
.data$r:00003488 a_?av_generic_e db '.?AV_Generic_error_category@std@@',0
.data$r:000034AA                 align 4
.data$r:000034AA _data$r         ends
.data$r:000034AA
.rdata$r:000034AC ; ===========================================================================
.rdata$r:000034AC
.rdata$r:000034AC ; Segment type: Pure data
.rdata$r:000034AC ; Segment permissions: Read
.rdata$r:000034AC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000034AC                 assume cs:_rdata$r
.rdata$r:000034AC                 ;org 34ACh
.rdata$r:000034AC ; COMDAT (pick any)
.rdata$r:000034AC                 public ??_R3_Generic_error_category@std@@8
.rdata$r:000034AC ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000034AC ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:000034AC                                         ; DATA XREF: .rdata$r:0000347Co
.rdata$r:000034AC                                         ; .rdata$r:000034E0o
.rdata$r:000034AD                 db    0
.rdata$r:000034AE                 db    0
.rdata$r:000034AF                 db    0
.rdata$r:000034B0                 db    0
.rdata$r:000034B1                 db    0
.rdata$r:000034B2                 db    0
.rdata$r:000034B3                 db    0
.rdata$r:000034B4                 db    2
.rdata$r:000034B5                 db    0
.rdata$r:000034B6                 db    0
.rdata$r:000034B7                 db    0
.rdata$r:000034B8                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000034B8 _rdata$r        ends
.rdata$r:000034B8
.rdata$r:000034BC ; ===========================================================================
.rdata$r:000034BC
.rdata$r:000034BC ; Segment type: Pure data
.rdata$r:000034BC ; Segment permissions: Read
.rdata$r:000034BC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000034BC                 assume cs:_rdata$r
.rdata$r:000034BC                 ;org 34BCh
.rdata$r:000034BC ; COMDAT (pick any)
.rdata$r:000034BC                 public ??_R2_Generic_error_category@std@@8
.rdata$r:000034BC ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000034BC ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:000034BC                                         ; DATA XREF: .rdata$r:000034B8o
.rdata$r:000034BC                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000034C0                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000034C4                 db    0
.rdata$r:000034C5                 align 4
.rdata$r:000034C5 _rdata$r        ends
.rdata$r:000034C5
.rdata$r:000034C8 ; ===========================================================================
.rdata$r:000034C8
.rdata$r:000034C8 ; Segment type: Pure data
.rdata$r:000034C8 ; Segment permissions: Read
.rdata$r:000034C8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000034C8                 assume cs:_rdata$r
.rdata$r:000034C8                 ;org 34C8h
.rdata$r:000034C8 ; COMDAT (pick any)
.rdata$r:000034C8                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:000034C8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000034C8 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:000034C8                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:000034C8                                         ; .rdata$r:00003538o ...
.rdata$r:000034C8                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:000034CC                 db    1
.rdata$r:000034CD                 db    0
.rdata$r:000034CE                 db    0
.rdata$r:000034CF                 db    0
.rdata$r:000034D0                 db    0
.rdata$r:000034D1                 db    0
.rdata$r:000034D2                 db    0
.rdata$r:000034D3                 db    0
.rdata$r:000034D4                 db 0FFh
.rdata$r:000034D5                 db 0FFh
.rdata$r:000034D6                 db 0FFh
.rdata$r:000034D7                 db 0FFh
.rdata$r:000034D8                 db    0
.rdata$r:000034D9                 db    0
.rdata$r:000034DA                 db    0
.rdata$r:000034DB                 db    0
.rdata$r:000034DC                 db  40h ; @
.rdata$r:000034DD                 db    0
.rdata$r:000034DE                 db    0
.rdata$r:000034DF                 db    0
.rdata$r:000034E0                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000034E0 _rdata$r        ends
.rdata$r:000034E0
.rdata$r:000034E4 ; ===========================================================================
.rdata$r:000034E4
.rdata$r:000034E4 ; Segment type: Pure data
.rdata$r:000034E4 ; Segment permissions: Read
.rdata$r:000034E4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000034E4                 assume cs:_rdata$r
.rdata$r:000034E4                 ;org 34E4h
.rdata$r:000034E4 ; COMDAT (pick any)
.rdata$r:000034E4                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:000034E4 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:000034E4 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:000034E4                                         ; DATA XREF: .rdata:0000329Co
.rdata$r:000034E5                 db    0
.rdata$r:000034E6                 db    0
.rdata$r:000034E7                 db    0
.rdata$r:000034E8                 db    0
.rdata$r:000034E9                 db    0
.rdata$r:000034EA                 db    0
.rdata$r:000034EB                 db    0
.rdata$r:000034EC                 db    0
.rdata$r:000034ED                 db    0
.rdata$r:000034EE                 db    0
.rdata$r:000034EF                 db    0
.rdata$r:000034F0                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:000034F4                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000034F4 _rdata$r        ends
.rdata$r:000034F4
.data$r:000034F8 ; ===========================================================================
.data$r:000034F8
.data$r:000034F8 ; Segment type: Pure data
.data$r:000034F8 ; Segment permissions: Read/Write
.data$r:000034F8 _data$r         segment dword public 'DATA' use32
.data$r:000034F8                 assume cs:_data$r
.data$r:000034F8                 ;org 34F8h
.data$r:000034F8 ; COMDAT (pick any)
.data$r:000034F8                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:000034F8 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:000034F8 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000034F8                                         ; DATA XREF: .rdata$r:000034F0o
.data$r:000034F8                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000034F8                                         ; const type_info::`vftable'
.data$r:000034FC                 align 10h
.data$r:00003500 a_?av_iostream_ db '.?AV_Iostream_error_category@std@@',0
.data$r:00003523                 align 4
.data$r:00003523 _data$r         ends
.data$r:00003523
.rdata$r:00003524 ; ===========================================================================
.rdata$r:00003524
.rdata$r:00003524 ; Segment type: Pure data
.rdata$r:00003524 ; Segment permissions: Read
.rdata$r:00003524 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003524                 assume cs:_rdata$r
.rdata$r:00003524                 ;org 3524h
.rdata$r:00003524 ; COMDAT (pick any)
.rdata$r:00003524                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00003524 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003524 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00003524                                         ; DATA XREF: .rdata$r:000034F4o
.rdata$r:00003524                                         ; .rdata$r:0000355Co
.rdata$r:00003525                 db    0
.rdata$r:00003526                 db    0
.rdata$r:00003527                 db    0
.rdata$r:00003528                 db    0
.rdata$r:00003529                 db    0
.rdata$r:0000352A                 db    0
.rdata$r:0000352B                 db    0
.rdata$r:0000352C                 db    3
.rdata$r:0000352D                 db    0
.rdata$r:0000352E                 db    0
.rdata$r:0000352F                 db    0
.rdata$r:00003530                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00003530 _rdata$r        ends
.rdata$r:00003530
.rdata$r:00003534 ; ===========================================================================
.rdata$r:00003534
.rdata$r:00003534 ; Segment type: Pure data
.rdata$r:00003534 ; Segment permissions: Read
.rdata$r:00003534 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003534                 assume cs:_rdata$r
.rdata$r:00003534                 ;org 3534h
.rdata$r:00003534 ; COMDAT (pick any)
.rdata$r:00003534                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00003534 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00003534 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00003534                                         ; DATA XREF: .rdata$r:00003530o
.rdata$r:00003534                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003538                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000353C                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003540                 db    0
.rdata$r:00003541                 align 4
.rdata$r:00003541 _rdata$r        ends
.rdata$r:00003541
.rdata$r:00003544 ; ===========================================================================
.rdata$r:00003544
.rdata$r:00003544 ; Segment type: Pure data
.rdata$r:00003544 ; Segment permissions: Read
.rdata$r:00003544 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003544                 assume cs:_rdata$r
.rdata$r:00003544                 ;org 3544h
.rdata$r:00003544 ; COMDAT (pick any)
.rdata$r:00003544                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00003544 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003544 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00003544                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00003544                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00003548                 db    2
.rdata$r:00003549                 db    0
.rdata$r:0000354A                 db    0
.rdata$r:0000354B                 db    0
.rdata$r:0000354C                 db    0
.rdata$r:0000354D                 db    0
.rdata$r:0000354E                 db    0
.rdata$r:0000354F                 db    0
.rdata$r:00003550                 db 0FFh
.rdata$r:00003551                 db 0FFh
.rdata$r:00003552                 db 0FFh
.rdata$r:00003553                 db 0FFh
.rdata$r:00003554                 db    0
.rdata$r:00003555                 db    0
.rdata$r:00003556                 db    0
.rdata$r:00003557                 db    0
.rdata$r:00003558                 db  40h ; @
.rdata$r:00003559                 db    0
.rdata$r:0000355A                 db    0
.rdata$r:0000355B                 db    0
.rdata$r:0000355C                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000355C _rdata$r        ends
.rdata$r:0000355C
.rdata$r:00003560 ; ===========================================================================
.rdata$r:00003560
.rdata$r:00003560 ; Segment type: Pure data
.rdata$r:00003560 ; Segment permissions: Read
.rdata$r:00003560 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003560                 assume cs:_rdata$r
.rdata$r:00003560                 ;org 3560h
.rdata$r:00003560 ; COMDAT (pick any)
.rdata$r:00003560                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00003560 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00003560 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:000032DCo
.rdata$r:00003561                 db    0
.rdata$r:00003562                 db    0
.rdata$r:00003563                 db    0
.rdata$r:00003564                 db    0
.rdata$r:00003565                 db    0
.rdata$r:00003566                 db    0
.rdata$r:00003567                 db    0
.rdata$r:00003568                 db    0
.rdata$r:00003569                 db    0
.rdata$r:0000356A                 db    0
.rdata$r:0000356B                 db    0
.rdata$r:0000356C                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00003570                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003570 _rdata$r        ends
.rdata$r:00003570
.data$r:00003574 ; ===========================================================================
.data$r:00003574
.data$r:00003574 ; Segment type: Pure data
.data$r:00003574 ; Segment permissions: Read/Write
.data$r:00003574 _data$r         segment dword public 'DATA' use32
.data$r:00003574                 assume cs:_data$r
.data$r:00003574                 ;org 3574h
.data$r:00003574 ; COMDAT (pick any)
.data$r:00003574                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00003574 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00003574 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003574                                         ; DATA XREF: .rdata$r:0000356Co
.data$r:00003574                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003574                                         ; const type_info::`vftable'
.data$r:00003578                 db    0
.data$r:00003579                 db    0
.data$r:0000357A                 db    0
.data$r:0000357B                 db    0
.data$r:0000357C                 db  2Eh ; .
.data$r:0000357D                 db  3Fh ; ?
.data$r:0000357E                 db  41h ; A
.data$r:0000357F                 db  56h ; V
.data$r:00003580                 db  5Fh ; _
.data$r:00003581                 db  53h ; S
.data$r:00003582                 db  79h ; y
.data$r:00003583                 db  73h ; s
.data$r:00003584                 db  74h ; t
.data$r:00003585                 db  65h ; e
.data$r:00003586                 db  6Dh ; m
.data$r:00003587                 db  5Fh ; _
.data$r:00003588                 db  65h ; e
.data$r:00003589                 db  72h ; r
.data$r:0000358A                 db  72h ; r
.data$r:0000358B                 db  6Fh ; o
.data$r:0000358C                 db  72h ; r
.data$r:0000358D                 db  5Fh ; _
.data$r:0000358E                 db  63h ; c
.data$r:0000358F                 db  61h ; a
.data$r:00003590                 db  74h ; t
.data$r:00003591                 db  65h ; e
.data$r:00003592                 db  67h ; g
.data$r:00003593                 db  6Fh ; o
.data$r:00003594                 db  72h ; r
.data$r:00003595                 db  79h ; y
.data$r:00003596                 db  40h ; @
.data$r:00003597                 db  73h ; s
.data$r:00003598                 db  74h ; t
.data$r:00003599                 db  64h ; d
.data$r:0000359A                 db  40h ; @
.data$r:0000359B                 db  40h ; @
.data$r:0000359C                 db    0
.data$r:0000359D                 align 10h
.data$r:0000359D _data$r         ends
.data$r:0000359D
.rdata$r:000035A0 ; ===========================================================================
.rdata$r:000035A0
.rdata$r:000035A0 ; Segment type: Pure data
.rdata$r:000035A0 ; Segment permissions: Read
.rdata$r:000035A0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000035A0                 assume cs:_rdata$r
.rdata$r:000035A0                 ;org 35A0h
.rdata$r:000035A0 ; COMDAT (pick any)
.rdata$r:000035A0                 public ??_R3_System_error_category@std@@8
.rdata$r:000035A0 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000035A0 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00003570o
.rdata$r:000035A0                                         ; .rdata$r:000035D8o
.rdata$r:000035A1                 db    0
.rdata$r:000035A2                 db    0
.rdata$r:000035A3                 db    0
.rdata$r:000035A4                 db    0
.rdata$r:000035A5                 db    0
.rdata$r:000035A6                 db    0
.rdata$r:000035A7                 db    0
.rdata$r:000035A8                 db    3
.rdata$r:000035A9                 db    0
.rdata$r:000035AA                 db    0
.rdata$r:000035AB                 db    0
.rdata$r:000035AC                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:000035AC _rdata$r        ends
.rdata$r:000035AC
.rdata$r:000035B0 ; ===========================================================================
.rdata$r:000035B0
.rdata$r:000035B0 ; Segment type: Pure data
.rdata$r:000035B0 ; Segment permissions: Read
.rdata$r:000035B0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000035B0                 assume cs:_rdata$r
.rdata$r:000035B0                 ;org 35B0h
.rdata$r:000035B0 ; COMDAT (pick any)
.rdata$r:000035B0                 public ??_R2_System_error_category@std@@8
.rdata$r:000035B0 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:000035B0 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:000035B0                                         ; DATA XREF: .rdata$r:000035ACo
.rdata$r:000035B0                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000035B4                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000035B8                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000035BC                 db    0
.rdata$r:000035BD                 align 10h
.rdata$r:000035BD _rdata$r        ends
.rdata$r:000035BD
.rdata$r:000035C0 ; ===========================================================================
.rdata$r:000035C0
.rdata$r:000035C0 ; Segment type: Pure data
.rdata$r:000035C0 ; Segment permissions: Read
.rdata$r:000035C0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000035C0                 assume cs:_rdata$r
.rdata$r:000035C0                 ;org 35C0h
.rdata$r:000035C0 ; COMDAT (pick any)
.rdata$r:000035C0                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:000035C0 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000035C0 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:000035C0                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:000035C0                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:000035C4                 db    2
.rdata$r:000035C5                 db    0
.rdata$r:000035C6                 db    0
.rdata$r:000035C7                 db    0
.rdata$r:000035C8                 db    0
.rdata$r:000035C9                 db    0
.rdata$r:000035CA                 db    0
.rdata$r:000035CB                 db    0
.rdata$r:000035CC                 db 0FFh
.rdata$r:000035CD                 db 0FFh
.rdata$r:000035CE                 db 0FFh
.rdata$r:000035CF                 db 0FFh
.rdata$r:000035D0                 db    0
.rdata$r:000035D1                 db    0
.rdata$r:000035D2                 db    0
.rdata$r:000035D3                 db    0
.rdata$r:000035D4                 db  40h ; @
.rdata$r:000035D5                 db    0
.rdata$r:000035D6                 db    0
.rdata$r:000035D7                 db    0
.rdata$r:000035D8                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000035D8 _rdata$r        ends
.rdata$r:000035D8
.CRT$XCU:000035DC ; ===========================================================================
.CRT$XCU:000035DC
.CRT$XCU:000035DC ; Segment type: Pure data
.CRT$XCU:000035DC ; Segment permissions: Read
.CRT$XCU:000035DC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000035DC                 assume cs:_CRT$XCU
.CRT$XCU:000035DC                 ;org 35DCh
.CRT$XCU:000035DC _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:000035E0 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:000035E0 _CRT$XCU        ends
.CRT$XCU:000035E0
.CRT$XCU:000035E4 ; ===========================================================================
.CRT$XCU:000035E4
.CRT$XCU:000035E4 ; Segment type: Pure data
.CRT$XCU:000035E4 ; Segment permissions: Read
.CRT$XCU:000035E4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000035E4                 assume cs:_CRT$XCU
.CRT$XCU:000035E4                 ;org 35E4h
.CRT$XCU:000035E4 ; COMDAT (pick associative to section at 3300)
.CRT$XCU:000035E4 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:000035E4 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:000035E4 _CRT$XCU        ends
.CRT$XCU:000035E4
.CRT$XCU:000035E8 ; ===========================================================================
.CRT$XCU:000035E8
.CRT$XCU:000035E8 ; Segment type: Pure data
.CRT$XCU:000035E8 ; Segment permissions: Read
.CRT$XCU:000035E8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000035E8                 assume cs:_CRT$XCU
.CRT$XCU:000035E8                 ;org 35E8h
.CRT$XCU:000035E8 ; COMDAT (pick associative to section at 3304)
.CRT$XCU:000035E8 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:000035E8 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:000035E8 _CRT$XCU        ends
.CRT$XCU:000035E8
.CRT$XCU:000035EC ; ===========================================================================
.CRT$XCU:000035EC
.CRT$XCU:000035EC ; Segment type: Pure data
.CRT$XCU:000035EC ; Segment permissions: Read
.CRT$XCU:000035EC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000035EC                 assume cs:_CRT$XCU
.CRT$XCU:000035EC                 ;org 35ECh
.CRT$XCU:000035EC ; COMDAT (pick associative to section at 3308)
.CRT$XCU:000035EC ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:000035EC ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:000035EC _CRT$XCU        ends
.CRT$XCU:000035EC
.CRT$XCU:000035F0 ; ===========================================================================
.CRT$XCU:000035F0
.CRT$XCU:000035F0 ; Segment type: Pure data
.CRT$XCU:000035F0 ; Segment permissions: Read
.CRT$XCU:000035F0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000035F0                 assume cs:_CRT$XCU
.CRT$XCU:000035F0                 ;org 35F0h
.CRT$XCU:000035F0 ; COMDAT (pick associative to section at 330C)
.CRT$XCU:000035F0 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:000035F0 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:000035F0 _CRT$XCU        ends
.CRT$XCU:000035F0
.CRT$XCU:000035F4 ; ===========================================================================
.CRT$XCU:000035F4
.CRT$XCU:000035F4 ; Segment type: Pure data
.CRT$XCU:000035F4 ; Segment permissions: Read
.CRT$XCU:000035F4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000035F4                 assume cs:_CRT$XCU
.CRT$XCU:000035F4                 ;org 35F4h
.CRT$XCU:000035F4 ; COMDAT (pick associative to section at 3310)
.CRT$XCU:000035F4 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:000035F4 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:000035F4 _CRT$XCU        ends
.CRT$XCU:000035F4
.CRT$XCU:000035F8 ; ===========================================================================
.CRT$XCU:000035F8
.CRT$XCU:000035F8 ; Segment type: Pure data
.CRT$XCU:000035F8 ; Segment permissions: Read
.CRT$XCU:000035F8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000035F8                 assume cs:_CRT$XCU
.CRT$XCU:000035F8                 ;org 35F8h
.CRT$XCU:000035F8 ; COMDAT (pick associative to section at 33A4)
.CRT$XCU:000035F8 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:000035F8 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:000035F8 _CRT$XCU        ends
.CRT$XCU:000035F8
.CRT$XCU:000035FC ; ===========================================================================
.CRT$XCU:000035FC
.CRT$XCU:000035FC ; Segment type: Pure data
.CRT$XCU:000035FC ; Segment permissions: Read
.CRT$XCU:000035FC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000035FC                 assume cs:_CRT$XCU
.CRT$XCU:000035FC                 ;org 35FCh
.CRT$XCU:000035FC ; COMDAT (pick associative to section at 33A8)
.CRT$XCU:000035FC ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:000035FC ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:000035FC _CRT$XCU        ends
.CRT$XCU:000035FC
UNDEF:00003600 ; ===========================================================================
UNDEF:00003600
UNDEF:00003600 ; Segment type: Externs
UNDEF:00003600 ; UNDEF
UNDEF:00003600                 extrn __purecall:near   ; DATA XREF: .rdata:00003254o
UNDEF:00003600                                         ; .rdata:00003258o
UNDEF:00003604 ; void *__cdecl operator new(unsigned int)
UNDEF:00003604                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00003604                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p ...
UNDEF:00003608 ; void __cdecl operator delete(void *)
UNDEF:00003608                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:00003608                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:0000360C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000360C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000360C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00003610 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00003610                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00003610                                         ; _wmemcpy+11p
UNDEF:00003614 ; size_t __cdecl strlen(const char *Str)
UNDEF:00003614                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00003618 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00003618                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:00003618                                         ; _wmemmove+11p
UNDEF:0000361C ; size_t __cdecl wcslen(const wchar_t *Str)
UNDEF:0000361C                 extrn _wcslen:near      ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+1Bp
UNDEF:00003620 ; HMODULE __stdcall GetModuleHandleW(LPCWSTR lpModuleName)
UNDEF:00003620                 extrn __imp__GetModuleHandleW@4:near
UNDEF:00003620                                         ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+2A6p
UNDEF:00003620                                         ; DATA XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+2A6r
UNDEF:00003624 ; HFONT __stdcall CreateFontIndirectW(const LOGFONTW *lplf)
UNDEF:00003624                 extrn __imp__CreateFontIndirectW@4:near
UNDEF:00003624                                         ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+1B5p
UNDEF:00003624                                         ; DATA XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+1B5r
UNDEF:00003628 ; BOOL __stdcall DeleteObject(HGDIOBJ ho)
UNDEF:00003628                 extrn __imp__DeleteObject@4:near
UNDEF:00003628                                         ; CODE XREF: URLCtrl::destroy(void)+17p
UNDEF:00003628                                         ; DATA XREF: URLCtrl::destroy(void)+17r
UNDEF:0000362C ; HGDIOBJ __stdcall GetStockObject(int i)
UNDEF:0000362C                 extrn __imp__GetStockObject@4:near
UNDEF:0000362C                                         ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+185p
UNDEF:0000362C                                         ; DATA XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+185r
UNDEF:00003630 ; HGDIOBJ __stdcall SelectObject(HDC hdc, HGDIOBJ h)
UNDEF:00003630                 extrn __imp__SelectObject@8:near
UNDEF:00003630                                         ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+1D5p
UNDEF:00003630                                         ; URLCtrl::runProc(HWND__ *,uint,uint,long)+229p
UNDEF:00003630                                         ; DATA XREF: ...
UNDEF:00003634 ; COLORREF __stdcall SetBkColor(HDC hdc, COLORREF color)
UNDEF:00003634                 extrn __imp__SetBkColor@8:near
UNDEF:00003634                                         ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+171p
UNDEF:00003634                                         ; DATA XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+171r
UNDEF:00003638 ; COLORREF __stdcall SetTextColor(HDC hdc, COLORREF color)
UNDEF:00003638                 extrn __imp__SetTextColor@8:near
UNDEF:00003638                                         ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+150p
UNDEF:00003638                                         ; DATA XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+150r
UNDEF:0000363C ; int __stdcall GetObjectW(HANDLE h, int c, LPVOID pv)
UNDEF:0000363C                 extrn __imp__GetObjectW@12:near
UNDEF:0000363C                                         ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+1A1p
UNDEF:0000363C                                         ; DATA XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+1A1r
UNDEF:00003640 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00003640                 extrn __imp__SendMessageW@16:near
UNDEF:00003640                                         ; CODE XREF: URLCtrl::action(void)+69p
UNDEF:00003640                                         ; DATA XREF: URLCtrl::action(void)+69r
UNDEF:00003644 ; LRESULT __stdcall CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00003644                 extrn __imp__CallWindowProcW@20:near
UNDEF:00003644                                         ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+261p
UNDEF:00003644                                         ; URLCtrl::runProc(HWND__ *,uint,uint,long)+365p
UNDEF:00003644                                         ; DATA XREF: ...
UNDEF:00003648 ; int __stdcall DrawTextW(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format)
UNDEF:00003648                 extrn __imp__DrawTextW@20:near
UNDEF:00003648                                         ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+215p
UNDEF:00003648                                         ; DATA XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+215r
UNDEF:0000364C ; BOOL __stdcall UpdateWindow(HWND hWnd)
UNDEF:0000364C                 extrn __imp__UpdateWindow@4:near
UNDEF:0000364C                                         ; CODE XREF: URLCtrl::action(void)+A4p
UNDEF:0000364C                                         ; DATA XREF: URLCtrl::action(void)+A4r
UNDEF:00003650 ; HDC __stdcall BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint)
UNDEF:00003650                 extrn __imp__BeginPaint@8:near
UNDEF:00003650                                         ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+133p
UNDEF:00003650                                         ; DATA XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+133r
UNDEF:00003654 ; BOOL __stdcall EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint)
UNDEF:00003654                 extrn __imp__EndPaint@8:near
UNDEF:00003654                                         ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+23Ap
UNDEF:00003654                                         ; DATA XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+23Ar
UNDEF:00003658 ; BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
UNDEF:00003658                 extrn __imp__InvalidateRect@12:near
UNDEF:00003658                                         ; CODE XREF: URLCtrl::action(void)+94p
UNDEF:00003658                                         ; URLCtrl::runProc(HWND__ *,uint,uint,long)+275p
UNDEF:00003658                                         ; DATA XREF: ...
UNDEF:0000365C ; int __stdcall GetWindowTextW(HWND hWnd, LPWSTR lpString, int nMaxCount)
UNDEF:0000365C                 extrn __imp__GetWindowTextW@12:near
UNDEF:0000365C                                         ; CODE XREF: URLCtrl::action(void)+102p
UNDEF:0000365C                                         ; URLCtrl::runProc(HWND__ *,uint,uint,long)+1F1p
UNDEF:0000365C                                         ; DATA XREF: ...
UNDEF:00003660 ; BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect)
UNDEF:00003660                 extrn __imp__GetClientRect@8:near
UNDEF:00003660                                         ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+122p
UNDEF:00003660                                         ; DATA XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+122r
UNDEF:00003664 ; HCURSOR __stdcall SetCursor(HCURSOR hCursor)
UNDEF:00003664                 extrn __imp__SetCursor@4:near
UNDEF:00003664                                         ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+2C6p
UNDEF:00003664                                         ; DATA XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+2C6r
UNDEF:00003668 ; LONG __stdcall GetWindowLongW(HWND hWnd, int nIndex)
UNDEF:00003668                 extrn __imp__GetWindowLongW@8:near
UNDEF:00003668                                         ; CODE XREF: URLCtrl::create(HWND__ *,wchar_t *,ulong)+Dp
UNDEF:00003668                                         ; URLCtrl::create(HWND__ *,int,HWND__ *)+Dp ...
UNDEF:0000366C ; LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
UNDEF:0000366C                 extrn __imp__SetWindowLongW@12:near
UNDEF:0000366C                                         ; CODE XREF: URLCtrl::create(HWND__ *,wchar_t *,ulong)+1Fp
UNDEF:0000366C                                         ; URLCtrl::create(HWND__ *,wchar_t *,ulong)+58p ...
UNDEF:00003670 ; HWND __stdcall GetParent(HWND hWnd)
UNDEF:00003670                 extrn __imp__GetParent@4:near
UNDEF:00003670                                         ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+15Ap
UNDEF:00003670                                         ; DATA XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+15Ar
UNDEF:00003674 ; HCURSOR __stdcall CreateCursor(HINSTANCE hInst, int xHotSpot, int yHotSpot, int nWidth, int nHeight, const void *pvANDPlane, const void *pvXORPlane)
UNDEF:00003674                 extrn __imp__CreateCursor@28:near
UNDEF:00003674                                         ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+2ADp
UNDEF:00003674                                         ; DATA XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+2ADr
UNDEF:00003678 ; BOOL __stdcall DestroyCursor(HCURSOR hCursor)
UNDEF:00003678                 extrn __imp__DestroyCursor@4:near
UNDEF:00003678                                         ; CODE XREF: URLCtrl::destroy(void)+2Dp
UNDEF:00003678                                         ; DATA XREF: URLCtrl::destroy(void)+2Dr
UNDEF:0000367C ; HINSTANCE __stdcall ShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd)
UNDEF:0000367C                 extrn __imp__ShellExecuteW@24:near
UNDEF:0000367C                                         ; CODE XREF: URLCtrl::action(void)+E4p
UNDEF:0000367C                                         ; URLCtrl::action(void)+11Cp
UNDEF:0000367C                                         ; DATA XREF: ...
UNDEF:00003680 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00003680                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00003680                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00003684 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00003684                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00003684                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00003684                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:00003688                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:0000368C ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:0000368C                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:0000368C                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:0000368C                                         ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+16p
UNDEF:00003690 ; void __cdecl std::_Xbad_alloc()
UNDEF:00003690                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00003690                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_8B2p
UNDEF:00003690                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_8F4p ...
UNDEF:00003694 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00003694                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00003694                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00003694                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+Cp
UNDEF:00003698 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00003698                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00003698                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00003698                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+Cp
UNDEF:0000369C ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000369C                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000369C                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:000036A0 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:000036A0                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:000036A0                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:000036A0                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:000036A4 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:000036A4                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:000036A4                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:000036A8 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:000036A8                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000036A8                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:000036AC ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:000036AC                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000036AC                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:000036B0 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:000036B0                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000036B0                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:000036B4 ; unsigned __int32 __cdecl getCtrlBgColor(HWND)
UNDEF:000036B4                 extrn ?getCtrlBgColor@@YAKPAUHWND__@@@Z:near
UNDEF:000036B4                                         ; CODE XREF: URLCtrl::runProc(HWND__ *,uint,uint,long)+161p
UNDEF:000036B8 ; __fastcall __security_check_cookie(x)
UNDEF:000036B8                 extrn @__security_check_cookie@4:near
UNDEF:000036B8                                         ; CODE XREF: URLCtrl::action(void)+127p
UNDEF:000036B8                                         ; URLCtrl::runProc(HWND__ *,uint,uint,long)+370p ...
UNDEF:000036BC ; __stdcall _CxxThrowException(x, x)
UNDEF:000036BC                 extrn __CxxThrowException@8:near
UNDEF:000036BC                                         ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:000036BC                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1+10p
UNDEF:000036C0                 extrn ___CxxFrameHandler3:near
UNDEF:000036C0                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j
UNDEF:000036C0                                         ; __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z+16j ...
UNDEF:000036C4 ; const type_info::`vftable'
UNDEF:000036C4                 extrn ??_7type_info@@6B@:near
UNDEF:000036C4                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:000036C4                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:000036C8                 extrn ___security_cookie:near
UNDEF:000036C8                                         ; DATA XREF: URLCtrl::action(void)+9r
UNDEF:000036C8                                         ; URLCtrl::runProc(HWND__ *,uint,uint,long)+9r ...
UNDEF:000036CC                 extrn __fltused:near
UNDEF:000036CC
UNDEF:000036CC
UNDEF:000036CC                 end